[{"original_method":"/**\n     * Creates a channel with the given properties. Connects to the channel, then creates a PullPushAdapter\n     * and starts it\n     */\n    public ReplicatedTree(String groupname, String props, long state_fetch_timeout) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.connect(this.groupname);\n        start();\n    }","id":30000,"modified_method":"/**\n     * Creates a channel with the given properties. Connects to the channel, then creates a PullPushAdapter\n     * and starts it\n     */\n    public ReplicatedTree(String groupname, String props, long state_fetch_timeout) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.setReceiver(this);\n        channel.connect(this.groupname);\n        start();\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"Node createChild(String child_name, String fqn, Node parent, String key, Object value) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap();\n            child=(Node)children.get(child_name);\n            if(child != null)\n                child.setData(key, value);\n            else {\n                child=new Node(child_name, fqn, parent, key, value);\n                children.put(child_name, child);\n            }\n            return child;\n        }","id":30001,"modified_method":"Node createChild(String child_name, String fqn, Node parent, String key, Object value) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap<String,Node>();\n            child=(Node)children.get(child_name);\n            if(child != null)\n                child.setData(key, value);\n            else {\n                child=new Node(child_name, fqn, parent, key, value);\n                children.put(child_name, child);\n            }\n            return child;\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"void print(StringBuilder sb, int indent) {\n            printIndent(sb, indent);\n            sb.append(SEPARATOR).append(name);\n            if(children != null && children.size() > 0) {\n                Collection values=children.values();\n                for(Iterator it=values.iterator(); it.hasNext();) {\n                    sb.append('\\n');\n                    ((Node)it.next()).print(sb, indent + INDENT);\n                }\n            }\n        }","id":30002,"modified_method":"void print(StringBuilder sb, int indent) {\n            printIndent(sb, indent);\n            sb.append(SEPARATOR).append(name);\n            if(children != null && !children.isEmpty()) {\n                Collection values=children.values();\n                for(Iterator it=values.iterator(); it.hasNext();) {\n                    sb.append('\\n');\n                    ((Node)it.next()).print(sb, indent + INDENT);\n                }\n            }\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"void setData(Map data) {\n            if(data == null) return;\n            if(this.data == null)\n                this.data=new HashMap();\n            this.data.putAll(data);\n        }","id":30003,"modified_method":"void setData(Map data) {\n            if(data == null) return;\n            if(this.data == null)\n                this.data=new HashMap<String,Object>();\n            this.data.putAll(data);\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"public final void start() throws Exception {\n        if(request_handler == null) {\n            request_handler=new Thread(this, \"ReplicatedTree.RequestHandler thread\");\n            request_handler.setDaemon(true);\n            request_handler.start();\n        }\n        adapter=new PullPushAdapter(channel, this, this);\n        adapter.setListener(this);\n        boolean rc=channel.getState(null, state_fetch_timeout);\n\n        if(log.isInfoEnabled()) {\n            if(rc)\n                log.info(\"state was retrieved successfully\");\n            else\n                log.info(\"state could not be retrieved (first member)\");\n        }\n    }","id":30004,"modified_method":"public final void start() throws Exception {\n        boolean rc=channel.getState(null, state_fetch_timeout);\n        if(log.isInfoEnabled()) {\n            if(rc)\n                log.info(\"state was retrieved successfully\");\n            else\n                log.info(\"state could not be retrieved (first member)\");\n        }\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyNodeModified(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).nodeModified(fqn);\n    }","id":30005,"modified_method":"void notifyNodeModified(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).nodeModified(fqn);\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"public ReplicatedTree(String groupname, String props, long state_fetch_timeout, boolean jmx) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.jmx=jmx;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.connect(this.groupname);\n        if(jmx) {\n            MBeanServer server=Util.getMBeanServer();\n            if(server == null)\n                throw new Exception(\"No MBeanServers found; need to run with an MBeanServer present, or inside JDK 5\");\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName() , true);\n        }\n        start();\n    }","id":30006,"modified_method":"public ReplicatedTree(String groupname, String props, long state_fetch_timeout, boolean jmx) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.jmx=jmx;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.setReceiver(this);\n        channel.connect(this.groupname);\n\n        if(jmx) {\n            MBeanServer server=Util.getMBeanServer();\n            if(server == null)\n                throw new Exception(\"No MBeanServers found; need to run with an MBeanServer present, or inside JDK 5\");\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName() , true);\n        }\n        start();\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"boolean childExists(String child_name) {\n            if(child_name == null) return false;\n            return children != null && children.containsKey(child_name);\n        }","id":30007,"modified_method":"boolean childExists(String child_name) {\n            return child_name != null && children != null && children.containsKey(child_name);\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void viewAccepted(View new_view) {\n        Vector new_mbrs=new_view.getMembers();\n\n        // todo: if MergeView, fetch and reconcile state from coordinator\n        // actually maybe this is best left up to the application ? we just notify them and let\n        // the appl handle it ?\n\n        if(new_mbrs != null) {\n            notifyViewChange(new_view);\n            members.removeAllElements();\n            for(int i=0; i < new_mbrs.size(); i++)\n                members.addElement(new_mbrs.elementAt(i));\n        }\n\t\t//if size is bigger than one, there are more peers in the group\n\t\t//otherwise there is only one server.\n        send_message=members.size() > 1;\n    }","id":30008,"modified_method":"public void viewAccepted(View new_view) {\n        Vector<Address> new_mbrs=new_view.getMembers();\n\n        // todo: if MergeView, fetch and reconcile state from coordinator\n        // actually maybe this is best left up to the application ? we just notify them and let the appl handle it ?\n\n        if(new_mbrs != null) {\n            notifyViewChange(new_view);\n            members.removeAllElements();\n            for(int i=0; i < new_mbrs.size(); i++)\n                members.addElement(new_mbrs.elementAt(i));\n        }\n\t\t//if size is bigger than one, there are more peers in the group\n\t\t//otherwise there is only one server.\n        send_message=members.size() > 1;\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyNodeAdded(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).nodeAdded(fqn);\n    }","id":30009,"modified_method":"void notifyNodeAdded(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).nodeAdded(fqn);\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"void setData(String key, Object value) {\n            if(this.data == null)\n                this.data=new HashMap();\n            this.data.put(key, value);\n        }","id":30010,"modified_method":"void setData(String key, Object value) {\n            if(this.data == null)\n                this.data=new HashMap<String,Object>();\n            this.data.put(key, value);\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        if(request_handler != null && request_handler.isAlive()) {\n            request_queue.close(true);\n            request_handler=null;\n        }\n\n        request_handler=null;\n        if(channel != null) {\n            channel.close();\n        }\n        if(adapter != null) {\n            adapter.stop();\n            adapter=null;\n        }\n        channel=null;\n    }","id":30011,"modified_method":"public void stop() {\n        Util.close(channel);\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyViewChange(View v) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).viewChange(v);\n    }","id":30012,"modified_method":"void notifyViewChange(View v) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).viewChange(v);\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"Node createChild(String child_name, String fqn, Node parent, HashMap data) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap();\n            child=(Node)children.get(child_name);\n            if(child != null)\n                child.setData(data);\n            else {\n                child=new Node(child_name, fqn, parent, data);\n                children.put(child_name, child);\n            }\n            return child;\n        }","id":30013,"modified_method":"Node createChild(String child_name, String fqn, Node parent, HashMap<String,Object> data) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap<String,Node>();\n            child=children.get(child_name);\n            if(child != null)\n                child.setData(data);\n            else {\n                child=new Node(child_name, fqn, parent, data);\n                children.put(child_name, child);\n            }\n            return child;\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Callback. Process the contents of the message; typically an _add() or _set() request */\n    public void receive(Message msg) {\n        Request req=null;\n\n        if(msg == null || msg.getLength() == 0)\n            return;\n        try {\n            req=(Request)msg.getObject();\n            request_queue.add(req);\n        }\n        catch(QueueClosedException queue_closed_ex) {\n            if(log.isErrorEnabled()) log.error(\"request queue is null\");\n        }\n        catch(Exception ex) {\n            if(log.isErrorEnabled()) log.error(\"failed unmarshalling request: \" + ex);\n        }\n    }","id":30014,"modified_method":"/** Callback. Process the contents of the message; typically an _add() or _set() request */\n    public void receive(Message msg) {\n        Request req=null;\n\n        if(msg == null || msg.getLength() == 0)\n            return;\n        try {\n            req=(Request)msg.getObject();\n\n            String fqn=req.fqn;\n            switch(req.type) {\n                case Request.PUT:\n                    if(req.key != null && req.value != null)\n                        _put(fqn, req.key, req.value);\n                    else\n                        _put(fqn, req.data);\n                    break;\n                case Request.REMOVE:\n                    if(req.key != null)\n                        _remove(fqn, req.key);\n                    else\n                        _remove(fqn);\n                    break;\n                default:\n                    if(log.isErrorEnabled()) log.error(\"type \" + req.type + \" unknown\");\n                    break;\n            }\n        }\n        catch(Exception ex) {\n            if(log.isErrorEnabled()) log.error(\"failed unmarshalling request: \" + ex);\n        }\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"private Node(String child_name, String fqn, Node parent, String key, Object value) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data == null) data=new HashMap();\n            data.put(key, value);\n        }","id":30015,"modified_method":"private Node(String child_name, String fqn, Node parent, String key, Object value) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data == null) data=new HashMap<String,Object>();\n            data.put(key, value);\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Expects an already connected channel. Creates a PullPushAdapter and starts it\n     */\n    public ReplicatedTree(JChannel channel) throws Exception {\n        this.channel=channel;\n        start();\n    }","id":30016,"modified_method":"/**\n     * Expects an already connected channel. Creates a PullPushAdapter and starts it\n     */\n    public ReplicatedTree(JChannel channel) throws Exception {\n        this.channel=channel;\n        channel.setReceiver(this);\n        start();\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"private Node(String child_name, String fqn, Node parent, HashMap data) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data != null) this.data=(HashMap)data.clone();\n        }","id":30017,"modified_method":"private Node(String child_name, String fqn, Node parent, Map<String,Object> data) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data != null) this.data=(HashMap<String,Object>)((HashMap)data).clone();\n        }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyNodeRemoved(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).nodeRemoved(fqn);\n    }","id":30018,"modified_method":"void notifyNodeRemoved(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).nodeRemoved(fqn);\n    }","commit_id":"0c246b212b0e6fb0dd5c4062b0b126b783cb967a","url":"https://github.com/belaban/JGroups"},{"original_method":"public static boolean processArgs(Object proxy, String args[],\n            String args0[], String args1[], Hashtable aliases) throws Exception {\n        for (int i = 0; i < args.length; i++) {\n            String arg = args[i];\n            if (arg.startsWith(\"-\"))\n                arg = arg.substring(1);\n            if (aliases != null && aliases.get(arg) != null)\n                arg = (String) aliases.get(arg);\n\n            if (args0 != null) {\n                boolean set = false;\n                for (int j = 0; j < args0.length; j++) {\n                    if (args0[j].equalsIgnoreCase(arg)) {\n                        setProperty(proxy, args0[j], \"true\");\n                        set = true;\n                        break;\n                    }\n                }\n                if (set)\n                    continue;\n            }\n            if (args1 != null) {\n                for (int j = 0; j < args1.length; j++) {\n                    if (args1[j].equalsIgnoreCase(arg)) {\n                        i++;\n                        if (i >= args.length)\n                            return false;\n                        setProperty(proxy, arg, args[i]);\n                        break;\n                    }\n                }\n            } else {\n                // if args1 is not specified,assume all other options have param\n                i++;\n                if (i >= args.length)\n                    return false;\n                setProperty(proxy, arg, args[i]);\n            }\n\n        }\n        return true;\n    }","id":30019,"modified_method":"public static boolean processArgs(Object proxy, String args[],\n            String args0[], String args1[],\n            Hashtable<String,String> aliases) throws Exception {\n        for (int i = 0; i < args.length; i++) {\n            String arg = args[i];\n            if (arg.startsWith(\"-\"))\n                arg = arg.substring(1);\n            if (aliases != null && aliases.get(arg) != null)\n                arg = aliases.get(arg);\n\n            if (args0 != null) {\n                boolean set = false;\n                for (int j = 0; j < args0.length; j++) {\n                    if (args0[j].equalsIgnoreCase(arg)) {\n                        setProperty(proxy, args0[j], \"true\");\n                        set = true;\n                        break;\n                    }\n                }\n                if (set)\n                    continue;\n            }\n            if (args1 != null) {\n                for (int j = 0; j < args1.length; j++) {\n                    if (args1[j].equalsIgnoreCase(arg)) {\n                        i++;\n                        if (i >= args.length)\n                            return false;\n                        setProperty(proxy, arg, args[i]);\n                        break;\n                    }\n                }\n            } else {\n                // if args1 is not specified,assume all other options have param\n                i++;\n                if (i >= args.length)\n                    return false;\n                setProperty(proxy, arg, args[i]);\n            }\n\n        }\n        return true;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static Object callMethod0(Object target, String methodN)\n            throws Exception {\n        if (target == null) {\n            d(\"Assert: Illegal params \" + target);\n            return null;\n        }\n        if (dbg > 0)\n            d(\"callMethod0 \" + target.getClass().getName() + \".\" + methodN);\n\n        Class params[] = new Class[0];\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null)\n            throw new NoSuchMethodException(target.getClass().getName() + \" \"\n                    + methodN);\n        return m.invoke(target, emptyArray);\n    }","id":30020,"modified_method":"public static Object callMethod0(Object target, String methodN)\n            throws Exception {\n        if (target == null) {\n            d(\"Assert: Illegal params \" + target);\n            return null;\n        }\n        if (dbg > 0)\n            d(\"callMethod0 \" + target.getClass().getName() + \".\" + methodN);\n\n        Class<?> params[] = new Class[0];\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null)\n            throw new NoSuchMethodException(target.getClass().getName() + \" \"\n                    + methodN);\n        return m.invoke(target, emptyArray);\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Find a method with the right name If found, call the method ( if param is\n     * int or boolean we'll convert value to the right type before) - that means\n     * you can have setDebug(1).\n     */\n    public static boolean setProperty(Object o, String name, String value) {\n        if (dbg > 1)\n            d(\"setProperty(\" + o.getClass() + \" \" + name + \"=\" + value + \")\");\n\n        String setter = \"set\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method setPropertyMethodVoid = null;\n            Method setPropertyMethodBool = null;\n\n            // First, the ideal case - a setFoo( String ) method\n            for (int i = 0; i < methods.length; i++) {\n                Class paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 1\n                        && \"java.lang.String\".equals(paramT[0].getName())) {\n\n                    methods[i].invoke(o, new Object[] { value });\n                    return true;\n                }\n            }\n\n            // Try a setFoo ( int ) or ( boolean )\n            for (int i = 0; i < methods.length; i++) {\n                boolean ok = true;\n                if (setter.equals(methods[i].getName())\n                        && methods[i].getParameterTypes().length == 1) {\n\n                    // match - find the type and invoke it\n                    Class paramType = methods[i].getParameterTypes()[0];\n                    Object params[] = new Object[1];\n\n                    // Try a setFoo ( int )\n                    if (\"java.lang.Integer\".equals(paramType.getName())\n                            || \"int\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Integer(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n                    // Try a setFoo ( long )\n                    }else if (\"java.lang.Long\".equals(paramType.getName())\n                                || \"long\".equals(paramType.getName())) {\n                            try {\n                                params[0] = new Long(value);\n                            } catch (NumberFormatException ex) {\n                                ok = false;\n                            }\n\n                        // Try a setFoo ( boolean )\n                    } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                            || \"boolean\".equals(paramType.getName())) {\n                        params[0] = new Boolean(value);\n\n                        // Try a setFoo ( InetAddress )\n                    } else if (\"java.net.InetAddress\".equals(paramType\n                            .getName())) {\n                        try {\n                            params[0] = InetAddress.getByName(value);\n                        } catch (UnknownHostException exc) {\n                            d(\"Unable to resolve host name:\" + value);\n                            ok = false;\n                        }\n\n                        // Unknown type\n                    } else {\n                        d(\"Unknown type \" + paramType.getName());\n                    }\n\n                    if (ok) {\n                        methods[i].invoke(o, params);\n                        return true;\n                    }\n                }\n\n                // save \"setProperty\" for later\n                if (\"setProperty\".equals(methods[i].getName())) {\n                    if (methods[i].getReturnType()==Boolean.TYPE){\n                        setPropertyMethodBool = methods[i];\n                    }else {\n                        setPropertyMethodVoid = methods[i];    \n                    }\n                    \n                }\n            }\n\n            // Ok, no setXXX found, try a setProperty(\"name\", \"value\")\n            if (setPropertyMethodBool != null || setPropertyMethodVoid != null) {\n                Object params[] = new Object[2];\n                params[0] = name;\n                params[1] = value;\n                if (setPropertyMethodBool != null) {\n                    try {\n                        return (Boolean) setPropertyMethodBool.invoke(o, params);\n                    }catch (IllegalArgumentException biae) {\n                        //the boolean method had the wrong\n                        //parameter types. lets try the other\n                        if (setPropertyMethodVoid!=null) {\n                            setPropertyMethodVoid.invoke(o, params);\n                            return true;\n                        }else {\n                            throw biae;\n                        }\n                    }\n                } else {\n                    setPropertyMethodVoid.invoke(o, params);\n                    return true;\n                }\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name + \" \" + value, ex2);\n        } catch (SecurityException ex1) {\n            if (dbg > 0)\n                d(\"SecurityException for \" + o.getClass() + \" \" + name + \"=\"\n                        + value + \")\");\n            if (dbg > 1)\n                ex1.printStackTrace();\n        } catch (IllegalAccessException iae) {\n            if (dbg > 0)\n                d(\"IllegalAccessException for \" + o.getClass() + \" \" + name\n                        + \"=\" + value + \")\");\n            if (dbg > 1)\n                iae.printStackTrace();\n        } catch (InvocationTargetException ie) {\n            if (dbg > 0)\n                d(\"InvocationTargetException for \" + o.getClass() + \" \" + name\n                        + \"=\" + value + \")\");\n            if (dbg > 1)\n                ie.printStackTrace();\n        }\n        return false;\n    }","id":30021,"modified_method":"/**\n     * Find a method with the right name If found, call the method ( if param is\n     * int or boolean we'll convert value to the right type before) - that means\n     * you can have setDebug(1).\n     */\n    public static boolean setProperty(Object o, String name, String value) {\n        if (dbg > 1)\n            d(\"setProperty(\" + o.getClass() + \" \" + name + \"=\" + value + \")\");\n\n        String setter = \"set\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method setPropertyMethodVoid = null;\n            Method setPropertyMethodBool = null;\n\n            // First, the ideal case - a setFoo( String ) method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 1\n                        && \"java.lang.String\".equals(paramT[0].getName())) {\n\n                    methods[i].invoke(o, new Object[] { value });\n                    return true;\n                }\n            }\n\n            // Try a setFoo ( int ) or ( boolean )\n            for (int i = 0; i < methods.length; i++) {\n                boolean ok = true;\n                if (setter.equals(methods[i].getName())\n                        && methods[i].getParameterTypes().length == 1) {\n\n                    // match - find the type and invoke it\n                    Class<?> paramType = methods[i].getParameterTypes()[0];\n                    Object params[] = new Object[1];\n\n                    // Try a setFoo ( int )\n                    if (\"java.lang.Integer\".equals(paramType.getName())\n                            || \"int\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Integer(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n                    // Try a setFoo ( long )\n                    }else if (\"java.lang.Long\".equals(paramType.getName())\n                                || \"long\".equals(paramType.getName())) {\n                            try {\n                                params[0] = new Long(value);\n                            } catch (NumberFormatException ex) {\n                                ok = false;\n                            }\n\n                        // Try a setFoo ( boolean )\n                    } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                            || \"boolean\".equals(paramType.getName())) {\n                        params[0] = new Boolean(value);\n\n                        // Try a setFoo ( InetAddress )\n                    } else if (\"java.net.InetAddress\".equals(paramType\n                            .getName())) {\n                        try {\n                            params[0] = InetAddress.getByName(value);\n                        } catch (UnknownHostException exc) {\n                            d(\"Unable to resolve host name:\" + value);\n                            ok = false;\n                        }\n\n                        // Unknown type\n                    } else {\n                        d(\"Unknown type \" + paramType.getName());\n                    }\n\n                    if (ok) {\n                        methods[i].invoke(o, params);\n                        return true;\n                    }\n                }\n\n                // save \"setProperty\" for later\n                if (\"setProperty\".equals(methods[i].getName())) {\n                    if (methods[i].getReturnType()==Boolean.TYPE){\n                        setPropertyMethodBool = methods[i];\n                    }else {\n                        setPropertyMethodVoid = methods[i];    \n                    }\n                    \n                }\n            }\n\n            // Ok, no setXXX found, try a setProperty(\"name\", \"value\")\n            if (setPropertyMethodBool != null || setPropertyMethodVoid != null) {\n                Object params[] = new Object[2];\n                params[0] = name;\n                params[1] = value;\n                if (setPropertyMethodBool != null) {\n                    try {\n                        return (Boolean) setPropertyMethodBool.invoke(o, params);\n                    }catch (IllegalArgumentException biae) {\n                        //the boolean method had the wrong\n                        //parameter types. lets try the other\n                        if (setPropertyMethodVoid!=null) {\n                            setPropertyMethodVoid.invoke(o, params);\n                            return true;\n                        }else {\n                            throw biae;\n                        }\n                    }\n                } else {\n                    setPropertyMethodVoid.invoke(o, params);\n                    return true;\n                }\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name + \" \" + value, ex2);\n        } catch (SecurityException ex1) {\n            if (dbg > 0)\n                d(\"SecurityException for \" + o.getClass() + \" \" + name + \"=\"\n                        + value + \")\");\n            if (dbg > 1)\n                ex1.printStackTrace();\n        } catch (IllegalAccessException iae) {\n            if (dbg > 0)\n                d(\"IllegalAccessException for \" + o.getClass() + \" \" + name\n                        + \"=\" + value + \")\");\n            if (dbg > 1)\n                iae.printStackTrace();\n        } catch (InvocationTargetException ie) {\n            if (dbg > 0)\n                d(\"InvocationTargetException for \" + o.getClass() + \" \" + name\n                        + \"=\" + value + \")\");\n            if (dbg > 1)\n                ie.printStackTrace();\n        }\n        return false;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static Object callMethodN(Object target, String methodN,\n            Object params[], Class typeParams[]) throws Exception {\n        Method m = null;\n        m = findMethod(target.getClass(), methodN, typeParams);\n        if (m == null) {\n            d(\"Can't find method \" + methodN + \" in \" + target + \" CLASS \"\n                    + target.getClass());\n            return null;\n        }\n        Object o = m.invoke(target, params);\n\n        if (dbg > 0) {\n            // debug\n            StringBuffer sb = new StringBuffer();\n            sb.append(\"\" + target.getClass().getName() + \".\" + methodN + \"( \");\n            for (int i = 0; i < params.length; i++) {\n                if (i > 0)\n                    sb.append(\", \");\n                sb.append(params[i]);\n            }\n            sb.append(\")\");\n            d(sb.toString());\n        }\n        return o;\n    }","id":30022,"modified_method":"public static Object callMethodN(Object target, String methodN,\n            Object params[], Class<?> typeParams[]) throws Exception {\n        Method m = null;\n        m = findMethod(target.getClass(), methodN, typeParams);\n        if (m == null) {\n            d(\"Can't find method \" + methodN + \" in \" + target + \" CLASS \"\n                    + target.getClass());\n            return null;\n        }\n        Object o = m.invoke(target, params);\n\n        if (dbg > 0) {\n            // debug\n            StringBuffer sb = new StringBuffer();\n            sb.append(\"\" + target.getClass().getName() + \".\" + methodN + \"( \");\n            for (int i = 0; i < params.length; i++) {\n                if (i > 0)\n                    sb.append(\", \");\n                sb.append(params[i]);\n            }\n            sb.append(\")\");\n            d(sb.toString());\n        }\n        return o;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/** Test if the object implements a particular\n     *  method\n     */\n    public static boolean hasHook(Object obj, String methodN) {\n        try {\n            Method myMethods[] = findMethods(obj.getClass());\n            for (int i = 0; i < myMethods.length; i++) {\n                if (methodN.equals(myMethods[i].getName())) {\n                    // check if it's overriden\n                    Class declaring = myMethods[i].getDeclaringClass();\n                    Class parentOfDeclaring = declaring.getSuperclass();\n                    // this works only if the base class doesn't extend\n                    // another class.\n\n                    // if the method is declared in a top level class\n                    // like BaseInterceptor parent is Object, otherwise\n                    // parent is BaseInterceptor or an intermediate class\n                    if (!\"java.lang.Object\".equals(parentOfDeclaring.getName())) {\n                        return true;\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return false;\n    }","id":30023,"modified_method":"/** Test if the object implements a particular\n     *  method\n     */\n    public static boolean hasHook(Object obj, String methodN) {\n        try {\n            Method myMethods[] = findMethods(obj.getClass());\n            for (int i = 0; i < myMethods.length; i++) {\n                if (methodN.equals(myMethods[i].getName())) {\n                    // check if it's overriden\n                    Class<?> declaring = myMethods[i].getDeclaringClass();\n                    Class<?> parentOfDeclaring = declaring.getSuperclass();\n                    // this works only if the base class doesn't extend\n                    // another class.\n\n                    // if the method is declared in a top level class\n                    // like BaseInterceptor parent is Object, otherwise\n                    // parent is BaseInterceptor or an intermediate class\n                    if (!\"java.lang.Object\".equals(parentOfDeclaring.getName())) {\n                        return true;\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return false;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static String[] findVoidSetters(Class c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector v = new Vector();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 0) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = (String) v.elementAt(i);\n        }\n        return s;\n    }","id":30024,"modified_method":"public static String[] findVoidSetters(Class<?> c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector<String> v = new Vector<String>();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 0) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = v.elementAt(i);\n        }\n        return s;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Call void setAttribute( String ,Object )\n     */\n    public static void setAttribute(Object proxy, String n, Object v)\n            throws Exception {\n        if (proxy instanceof AttributeHolder) {\n            ((AttributeHolder) proxy).setAttribute(n, v);\n            return;\n        }\n\n        Method executeM = null;\n        Class c = proxy.getClass();\n        Class params[] = new Class[2];\n        params[0] = String.class;\n        params[1] = Object.class;\n        executeM = findMethod(c, \"setAttribute\", params);\n        if (executeM == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"No setAttribute in \" + proxy.getClass());\n            return;\n        }\n        if (false)\n            if (log.isDebugEnabled())\n                log.debug(\"Setting \" + n + \"=\" + v + \"  in \" + proxy);\n        executeM.invoke(proxy, new Object[] { n, v });\n        return;\n    }","id":30025,"modified_method":"/**\n     * Call void setAttribute( String ,Object )\n     */\n    public static void setAttribute(Object proxy, String n, Object v)\n            throws Exception {\n        if (proxy instanceof AttributeHolder) {\n            ((AttributeHolder) proxy).setAttribute(n, v);\n            return;\n        }\n\n        Method executeM = null;\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[2];\n        params[0] = String.class;\n        params[1] = Object.class;\n        executeM = findMethod(c, \"setAttribute\", params);\n        if (executeM == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"No setAttribute in \" + proxy.getClass());\n            return;\n        }\n        if (false)\n            if (log.isDebugEnabled())\n                log.debug(\"Setting \" + n + \"=\" + v + \"  in \" + proxy);\n        executeM.invoke(proxy, new Object[] { n, v });\n        return;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct a URL classpath from files in a directory, a cpath property,\n     * and tools.jar.\n     */\n    public static URL[] getClassPath(String dir, String cpath,\n            String cpathProp, boolean addTools) throws IOException,\n            MalformedURLException {\n        Vector jarsV = new Vector();\n        if (dir != null) {\n            // Add dir/classes first, if it exists\n            URL url = getURL(dir, \"classes\");\n            if (url != null)\n                jarsV.addElement(url);\n            addToClassPath(jarsV, dir);\n        }\n\n        if (cpath != null)\n            addJarsFromClassPath(jarsV, cpath);\n\n        if (cpathProp != null) {\n            String cpath1 = System.getProperty(cpathProp);\n            addJarsFromClassPath(jarsV, cpath1);\n        }\n\n        if (addTools)\n            addToolsJar(jarsV);\n\n        return getClassPath(jarsV);\n    }","id":30026,"modified_method":"/**\n     * Construct a URL classpath from files in a directory, a cpath property,\n     * and tools.jar.\n     */\n    public static URL[] getClassPath(String dir, String cpath,\n            String cpathProp, boolean addTools) throws IOException,\n            MalformedURLException {\n        Vector<URL> jarsV = new Vector<URL>();\n        if (dir != null) {\n            // Add dir/classes first, if it exists\n            URL url = getURL(dir, \"classes\");\n            if (url != null)\n                jarsV.addElement(url);\n            addToClassPath(jarsV, dir);\n        }\n\n        if (cpath != null)\n            addJarsFromClassPath(jarsV, cpath);\n\n        if (cpathProp != null) {\n            String cpath1 = System.getProperty(cpathProp);\n            addJarsFromClassPath(jarsV, cpath1);\n        }\n\n        if (addTools)\n            addToolsJar(jarsV);\n\n        return getClassPath(jarsV);\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Call execute() - any ant-like task should work\n     */\n    public static void execute(Object proxy, String method) throws Exception {\n        Method executeM = null;\n        Class c = proxy.getClass();\n        Class params[] = new Class[0];\n        //\tparams[0]=args.getClass();\n        executeM = findMethod(c, method, params);\n        if (executeM == null) {\n            throw new RuntimeException(\"No execute in \" + proxy.getClass());\n        }\n        executeM.invoke(proxy, (Object[]) null);//new Object[] { args });\n    }","id":30027,"modified_method":"/**\n     * Call execute() - any ant-like task should work\n     */\n    public static void execute(Object proxy, String method) throws Exception {\n        Method executeM = null;\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[0];\n        //\tparams[0]=args.getClass();\n        executeM = findMethod(c, method, params);\n        if (executeM == null) {\n            throw new RuntimeException(\"No execute in \" + proxy.getClass());\n        }\n        executeM.invoke(proxy, (Object[]) null);//new Object[] { args });\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Return a URL[] that can be used to construct a class loader\n     */\n    public static URL[] getClassPath(Vector v) {\n        URL[] urls = new URL[v.size()];\n        for (int i = 0; i < v.size(); i++) {\n            urls[i] = (URL) v.elementAt(i);\n        }\n        return urls;\n    }","id":30028,"modified_method":"/**\n     * Return a URL[] that can be used to construct a class loader\n     */\n    public static URL[] getClassPath(Vector<URL> v) {\n        URL[] urls = new URL[v.size()];\n        for (int i = 0; i < v.size(); i++) {\n            urls[i] = v.elementAt(i);\n        }\n        return urls;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Replace ${NAME} with the property value\n     */\n    public static String replaceProperties(String value, Hashtable staticProp,\n            PropertySource dynamicProp[]) {\n        if (value.indexOf(\"$\") < 0) {\n            return value;\n        }\n        StringBuffer sb = new StringBuffer();\n        int prev = 0;\n        // assert value!=nil\n        int pos;\n        while ((pos = value.indexOf(\"$\", prev)) >= 0) {\n            if (pos > 0) {\n                sb.append(value.substring(prev, pos));\n            }\n            if (pos == (value.length() - 1)) {\n                sb.append('$');\n                prev = pos + 1;\n            } else if (value.charAt(pos + 1) != '{') {\n                sb.append('$');\n                prev = pos + 1; // XXX\n            } else {\n                int endName = value.indexOf('}', pos);\n                if (endName < 0) {\n                    sb.append(value.substring(pos));\n                    prev = value.length();\n                    continue;\n                }\n                String n = value.substring(pos + 2, endName);\n                String v = null;\n                if (staticProp != null) {\n                    v = (String) ((Hashtable) staticProp).get(n);\n                }\n                if (v == null && dynamicProp != null) {\n                    for (int i = 0; i < dynamicProp.length; i++) {\n                        v = dynamicProp[i].getProperty(n);\n                        if (v != null) {\n                            break;\n                        }\n                    }\n                }\n                if (v == null)\n                    v = \"${\" + n + \"}\";\n\n                sb.append(v);\n                prev = endName + 1;\n            }\n        }\n        if (prev < value.length())\n            sb.append(value.substring(prev));\n        return sb.toString();\n    }","id":30029,"modified_method":"/**\n     * Replace ${NAME} with the property value\n     */\n    public static String replaceProperties(String value,\n            Hashtable<String,String> staticProp, PropertySource dynamicProp[]) {\n        if (value.indexOf(\"$\") < 0) {\n            return value;\n        }\n        StringBuffer sb = new StringBuffer();\n        int prev = 0;\n        // assert value!=nil\n        int pos;\n        while ((pos = value.indexOf(\"$\", prev)) >= 0) {\n            if (pos > 0) {\n                sb.append(value.substring(prev, pos));\n            }\n            if (pos == (value.length() - 1)) {\n                sb.append('$');\n                prev = pos + 1;\n            } else if (value.charAt(pos + 1) != '{') {\n                sb.append('$');\n                prev = pos + 1; // XXX\n            } else {\n                int endName = value.indexOf('}', pos);\n                if (endName < 0) {\n                    sb.append(value.substring(pos));\n                    prev = value.length();\n                    continue;\n                }\n                String n = value.substring(pos + 2, endName);\n                String v = null;\n                if (staticProp != null) {\n                    v = staticProp.get(n);\n                }\n                if (v == null && dynamicProp != null) {\n                    for (int i = 0; i < dynamicProp.length; i++) {\n                        v = dynamicProp[i].getProperty(n);\n                        if (v != null) {\n                            break;\n                        }\n                    }\n                }\n                if (v == null)\n                    v = \"${\" + n + \"}\";\n\n                sb.append(v);\n                prev = endName + 1;\n            }\n        }\n        if (prev < value.length())\n            sb.append(value.substring(prev));\n        return sb.toString();\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static Object callMethod1(Object target, String methodN,\n            Object param1, String typeParam1, ClassLoader cl) throws Exception {\n        if (target == null || param1 == null) {\n            d(\"Assert: Illegal params \" + target + \" \" + param1);\n        }\n        if (dbg > 0)\n            d(\"callMethod1 \" + target.getClass().getName() + \" \"\n                    + param1.getClass().getName() + \" \" + typeParam1);\n\n        Class params[] = new Class[1];\n        if (typeParam1 == null)\n            params[0] = param1.getClass();\n        else\n            params[0] = cl.loadClass(typeParam1);\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null)\n            throw new NoSuchMethodException(target.getClass().getName() + \" \"\n                    + methodN);\n        return m.invoke(target, new Object[] { param1 });\n    }","id":30030,"modified_method":"public static Object callMethod1(Object target, String methodN,\n            Object param1, String typeParam1, ClassLoader cl) throws Exception {\n        if (target == null || param1 == null) {\n            d(\"Assert: Illegal params \" + target + \" \" + param1);\n        }\n        if (dbg > 0)\n            d(\"callMethod1 \" + target.getClass().getName() + \" \"\n                    + param1.getClass().getName() + \" \" + typeParam1);\n\n        Class<?> params[] = new Class[1];\n        if (typeParam1 == null)\n            params[0] = param1.getClass();\n        else\n            params[0] = cl.loadClass(typeParam1);\n        Method m = findMethod(target.getClass(), methodN, params);\n        if (m == null)\n            throw new NoSuchMethodException(target.getClass().getName() + \" \"\n                    + methodN);\n        return m.invoke(target, new Object[] { param1 });\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static boolean processArgs(Object proxy, String args[])\n            throws Exception {\n        String args0[] = null;\n        if (null != findMethod(proxy.getClass(), \"getOptions1\", new Class[] {})) {\n            args0 = (String[]) callMethod0(proxy, \"getOptions1\");\n        }\n\n        if (args0 == null) {\n            //args0=findVoidSetters(proxy.getClass());\n            args0 = findBooleanSetters(proxy.getClass());\n        }\n        Hashtable h = null;\n        if (null != findMethod(proxy.getClass(), \"getOptionAliases\",\n                new Class[] {})) {\n            h = (Hashtable) callMethod0(proxy, \"getOptionAliases\");\n        }\n        return processArgs(proxy, args, args0, null, h);\n    }","id":30031,"modified_method":"public static boolean processArgs(Object proxy, String args[])\n            throws Exception {\n        String args0[] = null;\n        if (null != findMethod(proxy.getClass(), \"getOptions1\", new Class[] {})) {\n            args0 = (String[]) callMethod0(proxy, \"getOptions1\");\n        }\n\n        if (args0 == null) {\n            //args0=findVoidSetters(proxy.getClass());\n            args0 = findBooleanSetters(proxy.getClass());\n        }\n        Hashtable<String,String> h = null;\n        if (null != findMethod(proxy.getClass(), \"getOptionAliases\",\n                new Class[] {})) {\n            h = (Hashtable<String,String>) callMethod0(proxy,\n                    \"getOptionAliases\");\n        }\n        return processArgs(proxy, args, args0, null, h);\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Add elements from the classpath <i>cp <\/i> to a Vector <i>jars <\/i> as\n     * file URLs (We use Vector for JDK 1.1 compat).\n     * <p>\n     * \n     * @param jars The jar list\n     * @param cp a String classpath of directory or jar file elements\n     *   separated by path.separator delimiters.\n     * @throws IOException If an I/O error occurs\n     * @throws MalformedURLException Doh ;)\n     */\n    public static void addJarsFromClassPath(Vector jars, String cp)\n            throws IOException, MalformedURLException {\n        String sep = System.getProperty(\"path.separator\");\n        String token;\n        StringTokenizer st;\n        if (cp != null) {\n            st = new StringTokenizer(cp, sep);\n            while (st.hasMoreTokens()) {\n                File f = new File(st.nextToken());\n                String path = f.getCanonicalPath();\n                if (f.isDirectory()) {\n                    path += \"/\";\n                }\n                URL url = new URL(\"file\", \"\", path);\n                if (!jars.contains(url)) {\n                    jars.addElement(url);\n                }\n            }\n        }\n    }","id":30032,"modified_method":"/**\n     * Add elements from the classpath <i>cp <\/i> to a Vector <i>jars <\/i> as\n     * file URLs (We use Vector for JDK 1.1 compat).\n     * <p>\n     * \n     * @param jars The jar list\n     * @param cp a String classpath of directory or jar file elements\n     *   separated by path.separator delimiters.\n     * @throws IOException If an I/O error occurs\n     * @throws MalformedURLException Doh ;)\n     */\n    public static void addJarsFromClassPath(Vector<URL> jars, String cp)\n            throws IOException, MalformedURLException {\n        String sep = System.getProperty(\"path.separator\");\n        String token;\n        StringTokenizer st;\n        if (cp != null) {\n            st = new StringTokenizer(cp, sep);\n            while (st.hasMoreTokens()) {\n                File f = new File(st.nextToken());\n                String path = f.getCanonicalPath();\n                if (f.isDirectory()) {\n                    path += \"/\";\n                }\n                URL url = new URL(\"file\", \"\", path);\n                if (!jars.contains(url)) {\n                    jars.addElement(url);\n                }\n            }\n        }\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static Method findMethod(Class c, String name, Class params[]) {\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    }","id":30033,"modified_method":"public static Method findMethod(Class<?> c, String name,\n            Class<?> params[]) {\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class<?> methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/** \n     */\n    public static void setProperty(Object o, String name) {\n        String setter = \"set\" + capitalize(name);\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method setPropertyMethod = null;\n            // find setFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 0) {\n                    methods[i].invoke(o, new Object[] {});\n                    return;\n                }\n            }\n        } catch (Exception ex1) {\n            if (dbg > 0)\n                d(\"Exception for \" + o.getClass() + \" \" + name);\n            if (dbg > 1)\n                ex1.printStackTrace();\n        }\n    }","id":30034,"modified_method":"/** \n     */\n    public static void setProperty(Object o, String name) {\n        String setter = \"set\" + capitalize(name);\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method setPropertyMethod = null;\n            // find setFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 0) {\n                    methods[i].invoke(o, new Object[] {});\n                    return;\n                }\n            }\n        } catch (Exception ex1) {\n            if (dbg > 0)\n                d(\"Exception for \" + o.getClass() + \" \" + name);\n            if (dbg > 1)\n                ex1.printStackTrace();\n        }\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static Object getProperty(Object o, String name) {\n        String getter = \"get\" + capitalize(name);\n        String isGetter = \"is\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method getPropertyMethod = null;\n\n            // First, the ideal case - a getFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class paramT[] = methods[i].getParameterTypes();\n                if (getter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n                if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n\n                if (\"getProperty\".equals(methods[i].getName())) {\n                    getPropertyMethod = methods[i];\n                }\n            }\n\n            // Ok, no setXXX found, try a getProperty(\"name\")\n            if (getPropertyMethod != null) {\n                Object params[] = new Object[1];\n                params[0] = name;\n                return getPropertyMethod.invoke(o, params);\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name, ex2);\n        } catch (SecurityException ex1) {\n            if (dbg > 0)\n                d(\"SecurityException for \" + o.getClass() + \" \" + name + \")\");\n            if (dbg > 1)\n                ex1.printStackTrace();\n        } catch (IllegalAccessException iae) {\n            if (dbg > 0)\n                d(\"IllegalAccessException for \" + o.getClass() + \" \" + name\n                        + \")\");\n            if (dbg > 1)\n                iae.printStackTrace();\n        } catch (InvocationTargetException ie) {\n            if (dbg > 0)\n                d(\"InvocationTargetException for \" + o.getClass() + \" \" + name\n                        + \")\");\n            if (dbg > 1)\n                ie.printStackTrace();\n        }\n        return null;\n    }","id":30035,"modified_method":"public static Object getProperty(Object o, String name) {\n        String getter = \"get\" + capitalize(name);\n        String isGetter = \"is\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method getPropertyMethod = null;\n\n            // First, the ideal case - a getFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (getter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n                if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n\n                if (\"getProperty\".equals(methods[i].getName())) {\n                    getPropertyMethod = methods[i];\n                }\n            }\n\n            // Ok, no setXXX found, try a getProperty(\"name\")\n            if (getPropertyMethod != null) {\n                Object params[] = new Object[1];\n                params[0] = name;\n                return getPropertyMethod.invoke(o, params);\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name, ex2);\n        } catch (SecurityException ex1) {\n            if (dbg > 0)\n                d(\"SecurityException for \" + o.getClass() + \" \" + name + \")\");\n            if (dbg > 1)\n                ex1.printStackTrace();\n        } catch (IllegalAccessException iae) {\n            if (dbg > 0)\n                d(\"IllegalAccessException for \" + o.getClass() + \" \" + name\n                        + \")\");\n            if (dbg > 1)\n                iae.printStackTrace();\n        } catch (InvocationTargetException ie) {\n            if (dbg > 0)\n                d(\"InvocationTargetException for \" + o.getClass() + \" \" + name\n                        + \")\");\n            if (dbg > 1)\n                ie.printStackTrace();\n        }\n        return null;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Add all the jar files in a dir to the classpath, represented as a Vector\n     * of URLs.\n     */\n    public static void addToClassPath(Vector cpV, String dir) {\n        try {\n            String cpComp[] = getFilesByExt(dir, \".jar\");\n            if (cpComp != null) {\n                int jarCount = cpComp.length;\n                for (int i = 0; i < jarCount; i++) {\n                    URL url = getURL(dir, cpComp[i]);\n                    if (url != null)\n                        cpV.addElement(url);\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }","id":30036,"modified_method":"/**\n     * Add all the jar files in a dir to the classpath, represented as a Vector\n     * of URLs.\n     */\n    public static void addToClassPath(Vector<URL> cpV, String dir) {\n        try {\n            String cpComp[] = getFilesByExt(dir, \".jar\");\n            if (cpComp != null) {\n                int jarCount = cpComp.length;\n                for (int i = 0; i < jarCount; i++) {\n                    URL url = getURL(dir, cpComp[i]);\n                    if (url != null)\n                        cpV.addElement(url);\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static void callMain(Class c, String args[]) throws Exception {\n        Class p[] = new Class[1];\n        p[0] = args.getClass();\n        Method m = c.getMethod(\"main\", p);\n        m.invoke(c, new Object[] { args });\n    }","id":30037,"modified_method":"public static void callMain(Class<?> c, String args[]) throws Exception {\n        Class<?> p[] = new Class[1];\n        p[0] = args.getClass();\n        Method m = c.getMethod(\"main\", p);\n        m.invoke(c, new Object[] { args });\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Call void getAttribute( String )\n     */\n    public static Object getAttribute(Object proxy, String n) throws Exception {\n        Method executeM = null;\n        Class c = proxy.getClass();\n        Class params[] = new Class[1];\n        params[0] = String.class;\n        executeM = findMethod(c, \"getAttribute\", params);\n        if (executeM == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"No getAttribute in \" + proxy.getClass());\n            return null;\n        }\n        return executeM.invoke(proxy, new Object[] { n });\n    }","id":30038,"modified_method":"/**\n     * Call void getAttribute( String )\n     */\n    public static Object getAttribute(Object proxy, String n) throws Exception {\n        Method executeM = null;\n        Class<?> c = proxy.getClass();\n        Class<?> params[] = new Class[1];\n        params[0] = String.class;\n        executeM = findMethod(c, \"getAttribute\", params);\n        if (executeM == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"No getAttribute in \" + proxy.getClass());\n            return null;\n        }\n        return executeM.invoke(proxy, new Object[] { n });\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static String[] findBooleanSetters(Class c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector v = new Vector();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 1\n                    && \"boolean\".equalsIgnoreCase(m[i].getParameterTypes()[0]\n                            .getName())) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = (String) v.elementAt(i);\n        }\n        return s;\n    }","id":30039,"modified_method":"public static String[] findBooleanSetters(Class<?> c) {\n        Method m[] = findMethods(c);\n        if (m == null)\n            return null;\n        Vector<String> v = new Vector<String>();\n        for (int i = 0; i < m.length; i++) {\n            if (m[i].getName().startsWith(\"set\")\n                    && m[i].getParameterTypes().length == 1\n                    && \"boolean\".equalsIgnoreCase(m[i].getParameterTypes()[0]\n                            .getName())) {\n                String arg = m[i].getName().substring(3);\n                v.addElement(unCapitalize(arg));\n            }\n        }\n        String s[] = new String[v.size()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = v.elementAt(i);\n        }\n        return s;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct a URLClassLoader. Will compile and work in JDK1.1 too.\n     */\n    public static ClassLoader getURLClassLoader(URL urls[], ClassLoader parent) {\n        try {\n            Class urlCL = Class.forName(\"java.net.URLClassLoader\");\n            Class paramT[] = new Class[2];\n            paramT[0] = urls.getClass();\n            paramT[1] = ClassLoader.class;\n            Method m = findMethod(urlCL, \"newInstance\", paramT);\n            if (m == null)\n                return null;\n\n            ClassLoader cl = (ClassLoader) m.invoke(urlCL, new Object[] { urls,\n                    parent });\n            return cl;\n        } catch (ClassNotFoundException ex) {\n            // jdk1.1\n            return null;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }","id":30040,"modified_method":"/**\n     * Construct a URLClassLoader. Will compile and work in JDK1.1 too.\n     */\n    public static ClassLoader getURLClassLoader(URL urls[], ClassLoader parent) {\n        try {\n            Class<?> urlCL = Class.forName(\"java.net.URLClassLoader\");\n            Class<?> paramT[] = new Class[2];\n            paramT[0] = urls.getClass();\n            paramT[1] = ClassLoader.class;\n            Method m = findMethod(urlCL, \"newInstance\", paramT);\n            if (m == null)\n                return null;\n\n            ClassLoader cl = (ClassLoader) m.invoke(urlCL, new Object[] { urls,\n                    parent });\n            return cl;\n        } catch (ClassNotFoundException ex) {\n            // jdk1.1\n            return null;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static Method[] findMethods(Class c) {\n        Method methods[] = (Method[]) objectMethods.get(c);\n        if (methods != null)\n            return methods;\n\n        methods = c.getMethods();\n        objectMethods.put(c, methods);\n        return methods;\n    }","id":30041,"modified_method":"public static Method[] findMethods(Class<?> c) {\n        Method methods[] = objectMethods.get(c);\n        if (methods != null)\n            return methods;\n\n        methods = c.getMethods();\n        objectMethods.put(c, methods);\n        return methods;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static Object convert(String object, Class paramType) {\n        Object result = null;\n        if (\"java.lang.String\".equals(paramType.getName())) {\n            result = object;\n        } else if (\"java.lang.Integer\".equals(paramType.getName())\n                || \"int\".equals(paramType.getName())) {\n            try {\n                result = new Integer(object);\n            } catch (NumberFormatException ex) {\n            }\n            // Try a setFoo ( boolean )\n        } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                || \"boolean\".equals(paramType.getName())) {\n            result = new Boolean(object);\n\n            // Try a setFoo ( InetAddress )\n        } else if (\"java.net.InetAddress\".equals(paramType\n                .getName())) {\n            try {\n                result = InetAddress.getByName(object);\n            } catch (UnknownHostException exc) {\n                d(\"Unable to resolve host name:\" + object);\n            }\n\n            // Unknown type\n        } else {\n            d(\"Unknown type \" + paramType.getName());\n        }\n        if (result == null) {\n            throw new IllegalArgumentException(\"Can't convert argument: \" + object);\n        }\n        return result;\n    }","id":30042,"modified_method":"public static Object convert(String object, Class<?> paramType) {\n        Object result = null;\n        if (\"java.lang.String\".equals(paramType.getName())) {\n            result = object;\n        } else if (\"java.lang.Integer\".equals(paramType.getName())\n                || \"int\".equals(paramType.getName())) {\n            try {\n                result = new Integer(object);\n            } catch (NumberFormatException ex) {\n            }\n            // Try a setFoo ( boolean )\n        } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                || \"boolean\".equals(paramType.getName())) {\n            result = new Boolean(object);\n\n            // Try a setFoo ( InetAddress )\n        } else if (\"java.net.InetAddress\".equals(paramType\n                .getName())) {\n            try {\n                result = InetAddress.getByName(object);\n            } catch (UnknownHostException exc) {\n                d(\"Unable to resolve host name:\" + object);\n            }\n\n            // Unknown type\n        } else {\n            d(\"Unknown type \" + paramType.getName());\n        }\n        if (result == null) {\n            throw new IllegalArgumentException(\"Can't convert argument: \" + object);\n        }\n        return result;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static void addToolsJar(Vector v) {\n        try {\n            // Add tools.jar in any case\n            File f = new File(System.getProperty(\"java.home\")\n                    + \"/../lib/tools.jar\");\n\n            if (!f.exists()) {\n                // On some systems java.home gets set to the root of jdk.\n                // That's a bug, but we can work around and be nice.\n                f = new File(System.getProperty(\"java.home\") + \"/lib/tools.jar\");\n                if (f.exists()) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Detected strange java.home value \"\n                            + System.getProperty(\"java.home\")\n                            + \", it should point to jre\");\n                }\n            }\n            URL url = new URL(\"file\", \"\", f.getAbsolutePath());\n\n            v.addElement(url);\n        } catch (MalformedURLException ex) {\n            ex.printStackTrace();\n        }\n    }","id":30043,"modified_method":"public static void addToolsJar(Vector<URL> v) {\n        try {\n            // Add tools.jar in any case\n            File f = new File(System.getProperty(\"java.home\")\n                    + \"/../lib/tools.jar\");\n\n            if (!f.exists()) {\n                // On some systems java.home gets set to the root of jdk.\n                // That's a bug, but we can work around and be nice.\n                f = new File(System.getProperty(\"java.home\") + \"/lib/tools.jar\");\n                if (f.exists()) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"Detected strange java.home value \"\n                            + System.getProperty(\"java.home\")\n                            + \", it should point to jre\");\n                }\n            }\n            URL url = new URL(\"file\", \"\", f.getAbsolutePath());\n\n            v.addElement(url);\n        } catch (MalformedURLException ex) {\n            ex.printStackTrace();\n        }\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public Object nextElement() {\n        String current=next;\n        findNext();\n        return current;\n    }","id":30044,"modified_method":"public String nextElement() {\n        String current=next;\n        findNext();\n        return current;\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public Object nextElement() {\n        MessageBytes current=next;\n        findNext();\n        return current.toString();\n    }","id":30045,"modified_method":"public String nextElement() {\n        MessageBytes current=next;\n        findNext();\n        return current.toString();\n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(ByteChunk bc) {\n\n        // If the cache is null, then either caching is disabled, or we're\n        // still training\n        if (bcCache == null) {\n            String value = bc.toStringInternal();\n            if (byteEnabled && (value.length() < maxStringSize)) {\n                // If training, everything is synced\n                synchronized (bcStats) {\n                    // If the cache has been generated on a previous invocation\n                    // while waiting fot the lock, just return the toString value\n                    // we just calculated\n                    if (bcCache != null) {\n                        return value;\n                    }\n                    // Two cases: either we just exceeded the train count, in which\n                    // case the cache must be created, or we just update the count for\n                    // the string\n                    if (bcCount > trainThreshold) {\n                        long t1 = System.currentTimeMillis();\n                        // Sort the entries according to occurrence\n                        TreeMap tempMap = new TreeMap();\n                        Iterator entries = bcStats.keySet().iterator();\n                        while (entries.hasNext()) {\n                            ByteEntry entry = (ByteEntry) entries.next();\n                            int[] countA = (int[]) bcStats.get(entry);\n                            Integer count = new Integer(countA[0]);\n                            // Add to the list for that count\n                            ArrayList list = (ArrayList) tempMap.get(count);\n                            if (list == null) {\n                                // Create list\n                                list = new ArrayList();\n                                tempMap.put(count, list);\n                            }\n                            list.add(entry);\n                        }\n                        // Allocate array of the right size\n                        int size = bcStats.size();\n                        if (size > cacheSize) {\n                            size = cacheSize;\n                        }\n                        ByteEntry[] tempbcCache = new ByteEntry[size];\n                        // Fill it up using an alphabetical order\n                        // and a dumb insert sort\n                        ByteChunk tempChunk = new ByteChunk();\n                        int n = 0;\n                        while (n < size) {\n                            Object key = tempMap.lastKey();\n                            ArrayList list = (ArrayList) tempMap.get(key);\n                            ByteEntry[] list2 = \n                                (ByteEntry[]) list.toArray(new ByteEntry[list.size()]);\n                            for (int i = 0; i < list.size() && n < size; i++) {\n                                ByteEntry entry = (ByteEntry) list.get(i);\n                                tempChunk.setBytes(entry.name, 0, entry.name.length);\n                                int insertPos = findClosest(tempChunk, tempbcCache, n);\n                                if (insertPos == n) {\n                                    tempbcCache[n + 1] = entry;\n                                } else {\n                                    System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, \n                                            insertPos + 2, n - insertPos - 1);\n                                    tempbcCache[insertPos + 1] = entry;\n                                }\n                                n++;\n                            }\n                            tempMap.remove(key);\n                        }\n                        bcCount = 0;\n                        bcStats.clear();\n                        bcCache = tempbcCache;\n                        if (log.isDebugEnabled()) {\n                            long t2 = System.currentTimeMillis();\n                            log.debug(\"ByteCache generation time: \" + (t2 - t1) + \"ms\");\n                        }\n                    } else {\n                        bcCount++;\n                        // Allocate new ByteEntry for the lookup\n                        ByteEntry entry = new ByteEntry();\n                        entry.value = value;\n                        int[] count = (int[]) bcStats.get(entry);\n                        if (count == null) {\n                            int end = bc.getEnd();\n                            int start = bc.getStart();\n                            // Create byte array and copy bytes\n                            entry.name = new byte[bc.getLength()];\n                            System.arraycopy(bc.getBuffer(), start, entry.name, 0, end - start);\n                            // Set encoding\n                            entry.enc = bc.getEncoding();\n                            // Initialize occurrence count to one \n                            count = new int[1];\n                            count[0] = 1;\n                            // Set in the stats hash map\n                            bcStats.put(entry, count);\n                        } else {\n                            count[0] = count[0] + 1;\n                        }\n                    }\n                }\n            }\n            return value;\n        } else {\n            accessCount++;\n            // Find the corresponding String\n            String result = find(bc);\n            if (result == null) {\n                return bc.toStringInternal();\n            }\n            // Note: We don't care about safety for the stats\n            hitCount++;\n            return result;\n        }\n        \n    }","id":30046,"modified_method":"public static String toString(ByteChunk bc) {\n\n        // If the cache is null, then either caching is disabled, or we're\n        // still training\n        if (bcCache == null) {\n            String value = bc.toStringInternal();\n            if (byteEnabled && (value.length() < maxStringSize)) {\n                // If training, everything is synced\n                synchronized (bcStats) {\n                    // If the cache has been generated on a previous invocation\n                    // while waiting fot the lock, just return the toString value\n                    // we just calculated\n                    if (bcCache != null) {\n                        return value;\n                    }\n                    // Two cases: either we just exceeded the train count, in which\n                    // case the cache must be created, or we just update the count for\n                    // the string\n                    if (bcCount > trainThreshold) {\n                        long t1 = System.currentTimeMillis();\n                        // Sort the entries according to occurrence\n                        TreeMap<Integer,ArrayList<ByteEntry>> tempMap =\n                            new TreeMap<Integer,ArrayList<ByteEntry>>();\n                        Iterator<ByteEntry> entries =\n                            bcStats.keySet().iterator();\n                        while (entries.hasNext()) {\n                            ByteEntry entry = entries.next();\n                            int[] countA = bcStats.get(entry);\n                            Integer count = new Integer(countA[0]);\n                            // Add to the list for that count\n                            ArrayList<ByteEntry> list = tempMap.get(count);\n                            if (list == null) {\n                                // Create list\n                                list = new ArrayList<ByteEntry>();\n                                tempMap.put(count, list);\n                            }\n                            list.add(entry);\n                        }\n                        // Allocate array of the right size\n                        int size = bcStats.size();\n                        if (size > cacheSize) {\n                            size = cacheSize;\n                        }\n                        ByteEntry[] tempbcCache = new ByteEntry[size];\n                        // Fill it up using an alphabetical order\n                        // and a dumb insert sort\n                        ByteChunk tempChunk = new ByteChunk();\n                        int n = 0;\n                        while (n < size) {\n                            Object key = tempMap.lastKey();\n                            ArrayList<ByteEntry> list = tempMap.get(key);\n                            for (int i = 0; i < list.size() && n < size; i++) {\n                                ByteEntry entry = list.get(i);\n                                tempChunk.setBytes(entry.name, 0, entry.name.length);\n                                int insertPos = findClosest(tempChunk, tempbcCache, n);\n                                if (insertPos == n) {\n                                    tempbcCache[n + 1] = entry;\n                                } else {\n                                    System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, \n                                            insertPos + 2, n - insertPos - 1);\n                                    tempbcCache[insertPos + 1] = entry;\n                                }\n                                n++;\n                            }\n                            tempMap.remove(key);\n                        }\n                        bcCount = 0;\n                        bcStats.clear();\n                        bcCache = tempbcCache;\n                        if (log.isDebugEnabled()) {\n                            long t2 = System.currentTimeMillis();\n                            log.debug(\"ByteCache generation time: \" + (t2 - t1) + \"ms\");\n                        }\n                    } else {\n                        bcCount++;\n                        // Allocate new ByteEntry for the lookup\n                        ByteEntry entry = new ByteEntry();\n                        entry.value = value;\n                        int[] count = bcStats.get(entry);\n                        if (count == null) {\n                            int end = bc.getEnd();\n                            int start = bc.getStart();\n                            // Create byte array and copy bytes\n                            entry.name = new byte[bc.getLength()];\n                            System.arraycopy(bc.getBuffer(), start, entry.name, 0, end - start);\n                            // Set encoding\n                            entry.enc = bc.getEncoding();\n                            // Initialize occurrence count to one \n                            count = new int[1];\n                            count[0] = 1;\n                            // Set in the stats hash map\n                            bcStats.put(entry, count);\n                        } else {\n                            count[0] = count[0] + 1;\n                        }\n                    }\n                }\n            }\n            return value;\n        } else {\n            accessCount++;\n            // Find the corresponding String\n            String result = find(bc);\n            if (result == null) {\n                return bc.toStringInternal();\n            }\n            // Note: We don't care about safety for the stats\n            hitCount++;\n            return result;\n        }\n        \n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(CharChunk cc) {\n        \n        // If the cache is null, then either caching is disabled, or we're\n        // still training\n        if (ccCache == null) {\n            String value = cc.toStringInternal();\n            if (charEnabled && (value.length() < maxStringSize)) {\n                // If training, everything is synced\n                synchronized (ccStats) {\n                    // If the cache has been generated on a previous invocation\n                    // while waiting fot the lock, just return the toString value\n                    // we just calculated\n                    if (ccCache != null) {\n                        return value;\n                    }\n                    // Two cases: either we just exceeded the train count, in which\n                    // case the cache must be created, or we just update the count for\n                    // the string\n                    if (ccCount > trainThreshold) {\n                        long t1 = System.currentTimeMillis();\n                        // Sort the entries according to occurrence\n                        TreeMap tempMap = new TreeMap();\n                        Iterator entries = ccStats.keySet().iterator();\n                        while (entries.hasNext()) {\n                            CharEntry entry = (CharEntry) entries.next();\n                            int[] countA = (int[]) ccStats.get(entry);\n                            Integer count = new Integer(countA[0]);\n                            // Add to the list for that count\n                            ArrayList list = (ArrayList) tempMap.get(count);\n                            if (list == null) {\n                                // Create list\n                                list = new ArrayList();\n                                tempMap.put(count, list);\n                            }\n                            list.add(entry);\n                        }\n                        // Allocate array of the right size\n                        int size = ccStats.size();\n                        if (size > cacheSize) {\n                            size = cacheSize;\n                        }\n                        CharEntry[] tempccCache = new CharEntry[size];\n                        // Fill it up using an alphabetical order\n                        // and a dumb insert sort\n                        CharChunk tempChunk = new CharChunk();\n                        int n = 0;\n                        while (n < size) {\n                            Object key = tempMap.lastKey();\n                            ArrayList list = (ArrayList) tempMap.get(key);\n                            CharEntry[] list2 = \n                                (CharEntry[]) list.toArray(new CharEntry[list.size()]);\n                            for (int i = 0; i < list.size() && n < size; i++) {\n                                CharEntry entry = (CharEntry) list.get(i);\n                                tempChunk.setChars(entry.name, 0, entry.name.length);\n                                int insertPos = findClosest(tempChunk, tempccCache, n);\n                                if (insertPos == n) {\n                                    tempccCache[n + 1] = entry;\n                                } else {\n                                    System.arraycopy(tempccCache, insertPos + 1, tempccCache, \n                                            insertPos + 2, n - insertPos - 1);\n                                    tempccCache[insertPos + 1] = entry;\n                                }\n                                n++;\n                            }\n                            tempMap.remove(key);\n                        }\n                        ccCount = 0;\n                        ccStats.clear();\n                        ccCache = tempccCache;\n                        if (log.isDebugEnabled()) {\n                            long t2 = System.currentTimeMillis();\n                            log.debug(\"CharCache generation time: \" + (t2 - t1) + \"ms\");\n                        }\n                    } else {\n                        ccCount++;\n                        // Allocate new CharEntry for the lookup\n                        CharEntry entry = new CharEntry();\n                        entry.value = value;\n                        int[] count = (int[]) ccStats.get(entry);\n                        if (count == null) {\n                            int end = cc.getEnd();\n                            int start = cc.getStart();\n                            // Create char array and copy chars\n                            entry.name = new char[cc.getLength()];\n                            System.arraycopy(cc.getBuffer(), start, entry.name, 0, end - start);\n                            // Initialize occurrence count to one \n                            count = new int[1];\n                            count[0] = 1;\n                            // Set in the stats hash map\n                            ccStats.put(entry, count);\n                        } else {\n                            count[0] = count[0] + 1;\n                        }\n                    }\n                }\n            }\n            return value;\n        } else {\n            accessCount++;\n            // Find the corresponding String\n            String result = find(cc);\n            if (result == null) {\n                return cc.toStringInternal();\n            }\n            // Note: We don't care about safety for the stats\n            hitCount++;\n            return result;\n        }\n        \n    }","id":30047,"modified_method":"public static String toString(CharChunk cc) {\n        \n        // If the cache is null, then either caching is disabled, or we're\n        // still training\n        if (ccCache == null) {\n            String value = cc.toStringInternal();\n            if (charEnabled && (value.length() < maxStringSize)) {\n                // If training, everything is synced\n                synchronized (ccStats) {\n                    // If the cache has been generated on a previous invocation\n                    // while waiting fot the lock, just return the toString value\n                    // we just calculated\n                    if (ccCache != null) {\n                        return value;\n                    }\n                    // Two cases: either we just exceeded the train count, in which\n                    // case the cache must be created, or we just update the count for\n                    // the string\n                    if (ccCount > trainThreshold) {\n                        long t1 = System.currentTimeMillis();\n                        // Sort the entries according to occurrence\n                        TreeMap<Integer,ArrayList<CharEntry>> tempMap =\n                            new TreeMap<Integer,ArrayList<CharEntry>>();\n                        Iterator<CharEntry> entries = ccStats.keySet().iterator();\n                        while (entries.hasNext()) {\n                            CharEntry entry = entries.next();\n                            int[] countA = ccStats.get(entry);\n                            Integer count = new Integer(countA[0]);\n                            // Add to the list for that count\n                            ArrayList<CharEntry> list = tempMap.get(count);\n                            if (list == null) {\n                                // Create list\n                                list = new ArrayList<CharEntry>();\n                                tempMap.put(count, list);\n                            }\n                            list.add(entry);\n                        }\n                        // Allocate array of the right size\n                        int size = ccStats.size();\n                        if (size > cacheSize) {\n                            size = cacheSize;\n                        }\n                        CharEntry[] tempccCache = new CharEntry[size];\n                        // Fill it up using an alphabetical order\n                        // and a dumb insert sort\n                        CharChunk tempChunk = new CharChunk();\n                        int n = 0;\n                        while (n < size) {\n                            Object key = tempMap.lastKey();\n                            ArrayList<CharEntry> list = tempMap.get(key);\n                            for (int i = 0; i < list.size() && n < size; i++) {\n                                CharEntry entry = list.get(i);\n                                tempChunk.setChars(entry.name, 0, entry.name.length);\n                                int insertPos = findClosest(tempChunk, tempccCache, n);\n                                if (insertPos == n) {\n                                    tempccCache[n + 1] = entry;\n                                } else {\n                                    System.arraycopy(tempccCache, insertPos + 1, tempccCache, \n                                            insertPos + 2, n - insertPos - 1);\n                                    tempccCache[insertPos + 1] = entry;\n                                }\n                                n++;\n                            }\n                            tempMap.remove(key);\n                        }\n                        ccCount = 0;\n                        ccStats.clear();\n                        ccCache = tempccCache;\n                        if (log.isDebugEnabled()) {\n                            long t2 = System.currentTimeMillis();\n                            log.debug(\"CharCache generation time: \" + (t2 - t1) + \"ms\");\n                        }\n                    } else {\n                        ccCount++;\n                        // Allocate new CharEntry for the lookup\n                        CharEntry entry = new CharEntry();\n                        entry.value = value;\n                        int[] count = ccStats.get(entry);\n                        if (count == null) {\n                            int end = cc.getEnd();\n                            int start = cc.getStart();\n                            // Create char array and copy chars\n                            entry.name = new char[cc.getLength()];\n                            System.arraycopy(cc.getBuffer(), start, entry.name, 0, end - start);\n                            // Initialize occurrence count to one \n                            count = new int[1];\n                            count[0] = 1;\n                            // Set in the stats hash map\n                            ccStats.put(entry, count);\n                        } else {\n                            count[0] = count[0] + 1;\n                        }\n                    }\n                }\n            }\n            return value;\n        } else {\n            accessCount++;\n            // Find the corresponding String\n            String result = find(cc);\n            if (result == null) {\n                return cc.toStringInternal();\n            }\n            // Note: We don't care about safety for the stats\n            hitCount++;\n            return result;\n        }\n        \n    }","commit_id":"1f982a7570dad52a815b167233d9dc889ec78c16","url":"https://github.com/apache/tomcat"},{"original_method":"private void generateCustomEnd(Node.CustomTag n, String tagHandlerVar,\r\n                String tagEvalVar, String tagPushBodyCountVar) {\r\n\r\n            if (!n.hasEmptyBody()) {\r\n                if (n.implementsIterationTag()) {\r\n                    out.printin(\"int evalDoAfterBody = \");\r\n                    out.print(tagHandlerVar);\r\n                    out.println(\".doAfterBody();\");\r\n\r\n                    // Synchronize AT_BEGIN and NESTED scripting variables\r\n                    syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n                    syncScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                    out\r\n                            .printil(\"if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN)\");\r\n                    out.pushIndent();\r\n                    out.printil(\"break;\");\r\n                    out.popIndent();\r\n\r\n                    out.popIndent();\r\n                    out.printil(\"} while (true);\");\r\n                }\r\n\r\n                restoreScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                if (n.implementsBodyTag()) {\r\n                    out.printin(\"if (\");\r\n                    out.print(tagEvalVar);\r\n                    out\r\n                            .println(\" != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {\");\r\n                    out.pushIndent();\r\n                    out.printil(\"out = _jspx_page_context.popBody();\");\r\n                    if (n.implementsTryCatchFinally()) {\r\n                        out.printin(tagPushBodyCountVar);\r\n                        out.println(\"[0]--;\");\r\n                    } else if (pushBodyCountVar != null) {\r\n                        out.printin(pushBodyCountVar);\r\n                        out.println(\"[0]--;\");\r\n                    }\r\n                    out.popIndent();\r\n                    out.printil(\"}\");\r\n                }\r\n\r\n                out.popIndent(); // EVAL_BODY\r\n                out.printil(\"}\");\r\n            }\r\n\r\n            out.printin(\"if (\");\r\n            out.print(tagHandlerVar);\r\n            out\r\n                    .println(\".doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {\");\r\n            out.pushIndent();\r\n            if (!n.implementsTryCatchFinally()) {\r\n                if (isPoolingEnabled) {\r\n                    out.printin(n.getTagHandlerPoolName());\r\n                    out.print(\".reuse(\");\r\n                    out.print(tagHandlerVar);\r\n                    out.println(\");\");\r\n                } else {\r\n                    out.printin(tagHandlerVar);\r\n                    out.println(\".release();\");\r\n                }\r\n            }\r\n            if (isTagFile || isFragment) {\r\n                out.printil(\"throw new SkipPageException();\");\r\n            } else {\r\n                out.printil((methodNesting > 0) ? \"return true;\" : \"return;\");\r\n            }\r\n            out.popIndent();\r\n            out.printil(\"}\");\r\n            // Synchronize AT_BEGIN scripting variables\r\n            syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n\r\n            // TryCatchFinally\r\n            if (n.implementsTryCatchFinally()) {\r\n                out.popIndent(); // try\r\n                out.printil(\"} catch (Throwable _jspx_exception) {\");\r\n                out.pushIndent();\r\n\r\n                out.printin(\"while (\");\r\n                out.print(tagPushBodyCountVar);\r\n                out.println(\"[0]-- > 0)\");\r\n                out.pushIndent();\r\n                out.printil(\"out = _jspx_page_context.popBody();\");\r\n                out.popIndent();\r\n\r\n                out.printin(tagHandlerVar);\r\n                out.println(\".doCatch(_jspx_exception);\");\r\n                out.popIndent();\r\n                out.printil(\"} finally {\");\r\n                out.pushIndent();\r\n                out.printin(tagHandlerVar);\r\n                out.println(\".doFinally();\");\r\n            }\r\n\r\n            if (isPoolingEnabled) {\r\n                out.printin(n.getTagHandlerPoolName());\r\n                out.print(\".reuse(\");\r\n                out.print(tagHandlerVar);\r\n                out.println(\");\");\r\n            } else {\r\n                out.printin(tagHandlerVar);\r\n                out.println(\".release();\");\r\n            }\r\n\r\n            if (n.implementsTryCatchFinally()) {\r\n                out.popIndent();\r\n                out.printil(\"}\");\r\n            }\r\n\r\n            // Declare and synchronize AT_END scripting variables (must do this\r\n            // outside the try/catch/finally block)\r\n            declareScriptingVars(n, VariableInfo.AT_END);\r\n            syncScriptingVars(n, VariableInfo.AT_END);\r\n\r\n            restoreScriptingVars(n, VariableInfo.AT_BEGIN);\r\n        }","id":30048,"modified_method":"private void generateCustomEnd(Node.CustomTag n, String tagHandlerVar,\r\n                String tagEvalVar, String tagPushBodyCountVar) {\r\n\r\n            if (!n.hasEmptyBody()) {\r\n                if (n.implementsIterationTag()) {\r\n                    out.printin(\"int evalDoAfterBody = \");\r\n                    out.print(tagHandlerVar);\r\n                    out.println(\".doAfterBody();\");\r\n\r\n                    // Synchronize AT_BEGIN and NESTED scripting variables\r\n                    syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n                    syncScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                    out\r\n                            .printil(\"if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN)\");\r\n                    out.pushIndent();\r\n                    out.printil(\"break;\");\r\n                    out.popIndent();\r\n\r\n                    out.popIndent();\r\n                    out.printil(\"} while (true);\");\r\n                }\r\n\r\n                restoreScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                if (n.implementsBodyTag()) {\r\n                    out.printin(\"if (\");\r\n                    out.print(tagEvalVar);\r\n                    out\r\n                            .println(\" != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {\");\r\n                    out.pushIndent();\r\n                    out.printil(\"out = _jspx_page_context.popBody();\");\r\n                    if (n.implementsTryCatchFinally()) {\r\n                        out.printin(tagPushBodyCountVar);\r\n                        out.println(\"[0]--;\");\r\n                    } else if (pushBodyCountVar != null) {\r\n                        out.printin(pushBodyCountVar);\r\n                        out.println(\"[0]--;\");\r\n                    }\r\n                    out.popIndent();\r\n                    out.printil(\"}\");\r\n                }\r\n\r\n                out.popIndent(); // EVAL_BODY\r\n                out.printil(\"}\");\r\n            }\r\n\r\n            out.printin(\"if (\");\r\n            out.print(tagHandlerVar);\r\n            out\r\n                    .println(\".doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {\");\r\n            out.pushIndent();\r\n            if (!n.implementsTryCatchFinally()) {\r\n                if (isPoolingEnabled) {\r\n                    out.printin(n.getTagHandlerPoolName());\r\n                    out.print(\".reuse(\");\r\n                    out.print(tagHandlerVar);\r\n                    out.println(\");\");\r\n                } else {\r\n                    out.printin(tagHandlerVar);\r\n                    out.println(\".release();\");\r\n                    out.println(\"try {\");\r\n                    out.pushIndent();\r\n                    out.printin(\"org.apache.jasper.runtime.AnnotationProcessor.preDestroy(\");\r\n                    out.print(tagHandlerVar);\r\n                    out.println(\");\");\r\n                    out.popIndent();\r\n                    out.println(\"} catch (Exception e) {\");\r\n                    out.pushIndent();\r\n                    out.println(\"log(\\\"Error processing preDestroy on tag instance of \\\" +\");\r\n                    out.printin(tagHandlerVar);\r\n                    out.println(\".getClass().getName());\");\r\n                    out.popIndent();\r\n                    out.println(\"}\");\r\n                }\r\n            }\r\n            if (isTagFile || isFragment) {\r\n                out.printil(\"throw new SkipPageException();\");\r\n            } else {\r\n                out.printil((methodNesting > 0) ? \"return true;\" : \"return;\");\r\n            }\r\n            out.popIndent();\r\n            out.printil(\"}\");\r\n            // Synchronize AT_BEGIN scripting variables\r\n            syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n\r\n            // TryCatchFinally\r\n            if (n.implementsTryCatchFinally()) {\r\n                out.popIndent(); // try\r\n                out.printil(\"} catch (Throwable _jspx_exception) {\");\r\n                out.pushIndent();\r\n\r\n                out.printin(\"while (\");\r\n                out.print(tagPushBodyCountVar);\r\n                out.println(\"[0]-- > 0)\");\r\n                out.pushIndent();\r\n                out.printil(\"out = _jspx_page_context.popBody();\");\r\n                out.popIndent();\r\n\r\n                out.printin(tagHandlerVar);\r\n                out.println(\".doCatch(_jspx_exception);\");\r\n                out.popIndent();\r\n                out.printil(\"} finally {\");\r\n                out.pushIndent();\r\n                out.printin(tagHandlerVar);\r\n                out.println(\".doFinally();\");\r\n            }\r\n\r\n            if (isPoolingEnabled) {\r\n                out.printin(n.getTagHandlerPoolName());\r\n                out.print(\".reuse(\");\r\n                out.print(tagHandlerVar);\r\n                out.println(\");\");\r\n            } else {\r\n                out.printin(tagHandlerVar);\r\n                out.println(\".release();\");\r\n                out.println(\"try {\");\r\n                out.pushIndent();\r\n                out.printin(\"org.apache.jasper.runtime.AnnotationProcessor.preDestroy(\");\r\n                out.print(tagHandlerVar);\r\n                out.println(\");\");\r\n                out.println(\"} catch (Exception e) {\");\r\n                out.println(\"log(\\\"Error processing preDestroy on tag instance of \\\" +\");\r\n                out.printin(tagHandlerVar);\r\n                out.println(\".getClass().getName());\");\r\n                out.popIndent();\r\n                out.println(\"}\");\r\n            }\r\n\r\n            if (n.implementsTryCatchFinally()) {\r\n                out.popIndent();\r\n                out.printil(\"}\");\r\n            }\r\n\r\n            // Declare and synchronize AT_END scripting variables (must do this\r\n            // outside the try/catch/finally block)\r\n            declareScriptingVars(n, VariableInfo.AT_END);\r\n            syncScriptingVars(n, VariableInfo.AT_END);\r\n\r\n            restoreScriptingVars(n, VariableInfo.AT_BEGIN);\r\n        }","commit_id":"a955206bfec222de6cd8c537d303a879dd267425","url":"https://github.com/apache/tomcat"},{"original_method":"/**\r\n     * Generates the _jspInit() method for instantiating the tag handler pools.\r\n     * For tag file, _jspInit has to be invoked manually, and the ServletConfig\r\n     * object explicitly passed.\r\n     * \r\n     * In JSP 2.1, we also instantiate an ExpressionFactory\r\n     */\r\n    private void generateInit() {\r\n\r\n        if (ctxt.isTagFile()) {\r\n            out.printil(\"private void _jspInit(ServletConfig config) {\");\r\n        } else {\r\n            out.printil(\"public void _jspInit() {\");\r\n        }\r\n\r\n        out.pushIndent();\r\n        if (isPoolingEnabled) {\r\n            for (int i = 0; i < tagHandlerPoolNames.size(); i++) {\r\n                out.printin((String) tagHandlerPoolNames.elementAt(i));\r\n                out\r\n                        .print(\" = org.apache.jasper.runtime.TagHandlerPool.getTagHandlerPool(\");\r\n                if (ctxt.isTagFile()) {\r\n                    out.print(\"config\");\r\n                } else {\r\n                    out.print(\"getServletConfig()\");\r\n                }\r\n                out.println(\");\");\r\n            }\r\n        }\r\n        \r\n        out.printin(VAR_EXPRESSIONFACTORY);\r\n        out.print(\" = JspFactory.getDefaultFactory().getJspApplicationContext(\");\r\n        if (ctxt.isTagFile()) {\r\n            out.print(\"config\");\r\n        } else {\r\n            out.print(\"getServletConfig()\");\r\n        }\r\n        out.println(\".getServletContext()).getExpressionFactory();\");\r\n        \r\n        out.popIndent();\r\n        out.printil(\"}\");\r\n        out.println();\r\n    }","id":30049,"modified_method":"/**\r\n     * Generates the _jspInit() method for instantiating the tag handler pools.\r\n     * For tag file, _jspInit has to be invoked manually, and the ServletConfig\r\n     * object explicitly passed.\r\n     * \r\n     * In JSP 2.1, we also instantiate an ExpressionFactory\r\n     */\r\n    private void generateInit() {\r\n\r\n        if (ctxt.isTagFile()) {\r\n            out.printil(\"private void _jspInit(ServletConfig config) {\");\r\n        } else {\r\n            out.printil(\"public void _jspInit() {\");\r\n        }\r\n\r\n        out.pushIndent();\r\n        if (isPoolingEnabled) {\r\n            for (int i = 0; i < tagHandlerPoolNames.size(); i++) {\r\n                out.printin(tagHandlerPoolNames.elementAt(i));\r\n                out\r\n                        .print(\" = org.apache.jasper.runtime.TagHandlerPool.getTagHandlerPool(\");\r\n                if (ctxt.isTagFile()) {\r\n                    out.print(\"config\");\r\n                } else {\r\n                    out.print(\"getServletConfig()\");\r\n                }\r\n                out.println(\");\");\r\n            }\r\n        }\r\n        \r\n        out.printin(VAR_EXPRESSIONFACTORY);\r\n        out.print(\" = JspFactory.getDefaultFactory().getJspApplicationContext(\");\r\n        if (ctxt.isTagFile()) {\r\n            out.print(\"config\");\r\n        } else {\r\n            out.print(\"getServletConfig()\");\r\n        }\r\n        out.println(\".getServletContext()).getExpressionFactory();\");\r\n        \r\n        out.popIndent();\r\n        out.printil(\"}\");\r\n        out.println();\r\n    }","commit_id":"a955206bfec222de6cd8c537d303a879dd267425","url":"https://github.com/apache/tomcat"},{"original_method":"/**\r\n     * Generates the _jspDestroy() method which is responsible for calling the\r\n     * release() method on every tag handler in any of the tag handler pools.\r\n     */\r\n    private void generateDestroy() {\r\n\r\n        out.printil(\"public void _jspDestroy() {\");\r\n        out.pushIndent();\r\n        \r\n        if (isPoolingEnabled) {\r\n            for (int i = 0; i < tagHandlerPoolNames.size(); i++) {\r\n                out.printin((String) tagHandlerPoolNames.elementAt(i));\r\n                out.println(\".release();\");\r\n            }\r\n        }\r\n        \r\n        out.popIndent();\r\n        out.printil(\"}\");\r\n        out.println();\r\n    }","id":30050,"modified_method":"/**\r\n     * Generates the _jspDestroy() method which is responsible for calling the\r\n     * release() method on every tag handler in any of the tag handler pools.\r\n     */\r\n    private void generateDestroy() {\r\n\r\n        out.printil(\"public void _jspDestroy() {\");\r\n        out.pushIndent();\r\n        \r\n        if (isPoolingEnabled) {\r\n            for (int i = 0; i < tagHandlerPoolNames.size(); i++) {\r\n                out.printin(\"Tag handler = \");\r\n                out.printin(tagHandlerPoolNames.elementAt(i));\r\n                out.println(\";\");\r\n                out.println(\"handler.release();\");\r\n                out.println(\"try {\");\r\n                out.pushIndent();\r\n                out.println(\"org.apache.jasper.runtime.AnnotationProcessor.preDestroy(handler);\");\r\n                out.popIndent();\r\n                out.println(\"} catch (Exception e) {\");\r\n                out.pushIndent();\r\n                out.println(\"log(\\\"Error processing preDestroy on tag instance of \\\" \");\r\n                out.println(\" + handler.getClass().getName());\");\r\n                out.popIndent();\r\n                out.println(\"}\");\r\n            }\r\n        }\r\n        \r\n        out.popIndent();\r\n        out.printil(\"}\");\r\n        out.println();\r\n    }","commit_id":"a955206bfec222de6cd8c537d303a879dd267425","url":"https://github.com/apache/tomcat"},{"original_method":"private void generateCustomStart(Node.CustomTag n,\r\n                TagHandlerInfo handlerInfo, String tagHandlerVar,\r\n                String tagEvalVar, String tagPushBodyCountVar)\r\n                throws JasperException {\r\n\r\n            Class tagHandlerClass = handlerInfo.getTagHandlerClass();\r\n\r\n            out.printin(\"//  \");\r\n            out.println(n.getQName());\r\n            n.setBeginJavaLine(out.getJavaLine());\r\n\r\n            // Declare AT_BEGIN scripting variables\r\n            declareScriptingVars(n, VariableInfo.AT_BEGIN);\r\n            saveScriptingVars(n, VariableInfo.AT_BEGIN);\r\n\r\n            String tagHandlerClassName = JspUtil\r\n                    .getCanonicalName(tagHandlerClass);\r\n            out.printin(tagHandlerClassName);\r\n            out.print(\" \");\r\n            out.print(tagHandlerVar);\r\n            out.print(\" = \");\r\n            if (isPoolingEnabled) {\r\n                out.print(\"(\");\r\n                out.print(tagHandlerClassName);\r\n                out.print(\") \");\r\n                out.print(n.getTagHandlerPoolName());\r\n                out.print(\".get(\");\r\n                out.print(tagHandlerClassName);\r\n                out.println(\".class);\");\r\n            } else {\r\n                out.print(\"new \");\r\n                out.print(tagHandlerClassName);\r\n                out.println(\"();\");\r\n            }\r\n\r\n            // includes setting the context\r\n            generateSetters(n, tagHandlerVar, handlerInfo, false);\r\n\r\n            // JspIdConsumer (after context has been set)\r\n            if (n.implementsJspIdConsumer()) {\r\n                out.printin(tagHandlerVar);\r\n                out.print(\".setJspId(\\\"\");\r\n                out.print(createJspId());\r\n                out.println(\"\\\");\");\r\n            }\r\n\r\n            if (n.implementsTryCatchFinally()) {\r\n                out.printin(\"int[] \");\r\n                out.print(tagPushBodyCountVar);\r\n                out.println(\" = new int[] { 0 };\");\r\n                out.printil(\"try {\");\r\n                out.pushIndent();\r\n            }\r\n            out.printin(\"int \");\r\n            out.print(tagEvalVar);\r\n            out.print(\" = \");\r\n            out.print(tagHandlerVar);\r\n            out.println(\".doStartTag();\");\r\n\r\n            if (!n.implementsBodyTag()) {\r\n                // Synchronize AT_BEGIN scripting variables\r\n                syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n            }\r\n\r\n            if (!n.hasEmptyBody()) {\r\n                out.printin(\"if (\");\r\n                out.print(tagEvalVar);\r\n                out.println(\" != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {\");\r\n                out.pushIndent();\r\n\r\n                // Declare NESTED scripting variables\r\n                declareScriptingVars(n, VariableInfo.NESTED);\r\n                saveScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                if (n.implementsBodyTag()) {\r\n                    out.printin(\"if (\");\r\n                    out.print(tagEvalVar);\r\n                    out\r\n                            .println(\" != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {\");\r\n                    // Assume EVAL_BODY_BUFFERED\r\n                    out.pushIndent();\r\n                    out.printil(\"out = _jspx_page_context.pushBody();\");\r\n                    if (n.implementsTryCatchFinally()) {\r\n                        out.printin(tagPushBodyCountVar);\r\n                        out.println(\"[0]++;\");\r\n                    } else if (pushBodyCountVar != null) {\r\n                        out.printin(pushBodyCountVar);\r\n                        out.println(\"[0]++;\");\r\n                    }\r\n                    out.printin(tagHandlerVar);\r\n                    out\r\n                            .println(\".setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);\");\r\n                    out.printin(tagHandlerVar);\r\n                    out.println(\".doInitBody();\");\r\n\r\n                    out.popIndent();\r\n                    out.printil(\"}\");\r\n\r\n                    // Synchronize AT_BEGIN and NESTED scripting variables\r\n                    syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n                    syncScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                } else {\r\n                    // Synchronize NESTED scripting variables\r\n                    syncScriptingVars(n, VariableInfo.NESTED);\r\n                }\r\n\r\n                if (n.implementsIterationTag()) {\r\n                    out.printil(\"do {\");\r\n                    out.pushIndent();\r\n                }\r\n            }\r\n            // Map the Java lines that handles start of custom tags to the\r\n            // JSP line for this tag\r\n            n.setEndJavaLine(out.getJavaLine());\r\n        }","id":30051,"modified_method":"private void generateCustomStart(Node.CustomTag n,\r\n                TagHandlerInfo handlerInfo, String tagHandlerVar,\r\n                String tagEvalVar, String tagPushBodyCountVar)\r\n                throws JasperException {\r\n\r\n            Class tagHandlerClass = handlerInfo.getTagHandlerClass();\r\n\r\n            out.printin(\"//  \");\r\n            out.println(n.getQName());\r\n            n.setBeginJavaLine(out.getJavaLine());\r\n\r\n            // Declare AT_BEGIN scripting variables\r\n            declareScriptingVars(n, VariableInfo.AT_BEGIN);\r\n            saveScriptingVars(n, VariableInfo.AT_BEGIN);\r\n\r\n            String tagHandlerClassName = JspUtil\r\n                    .getCanonicalName(tagHandlerClass);\r\n            out.printin(tagHandlerClassName);\r\n            out.print(\" \");\r\n            out.print(tagHandlerVar);\r\n            out.print(\" = \");\r\n            if (isPoolingEnabled) {\r\n                out.print(\"(\");\r\n                out.print(tagHandlerClassName);\r\n                out.print(\") \");\r\n                out.print(n.getTagHandlerPoolName());\r\n                out.print(\".get(\");\r\n                out.print(tagHandlerClassName);\r\n                out.println(\".class);\");\r\n            } else {\r\n                out.print(\"new \");\r\n                out.print(tagHandlerClassName);\r\n                out.println(\"();\");\r\n                out.printin(\"org.apache.jasper.runtime.AnnotationProcessor.postConstruct(\");\r\n                out.print(tagHandlerVar);\r\n                out.println(\");\");\r\n            }\r\n\r\n            // includes setting the context\r\n            generateSetters(n, tagHandlerVar, handlerInfo, false);\r\n\r\n            // JspIdConsumer (after context has been set)\r\n            if (n.implementsJspIdConsumer()) {\r\n                out.printin(tagHandlerVar);\r\n                out.print(\".setJspId(\\\"\");\r\n                out.print(createJspId());\r\n                out.println(\"\\\");\");\r\n            }\r\n\r\n            if (n.implementsTryCatchFinally()) {\r\n                out.printin(\"int[] \");\r\n                out.print(tagPushBodyCountVar);\r\n                out.println(\" = new int[] { 0 };\");\r\n                out.printil(\"try {\");\r\n                out.pushIndent();\r\n            }\r\n            out.printin(\"int \");\r\n            out.print(tagEvalVar);\r\n            out.print(\" = \");\r\n            out.print(tagHandlerVar);\r\n            out.println(\".doStartTag();\");\r\n\r\n            if (!n.implementsBodyTag()) {\r\n                // Synchronize AT_BEGIN scripting variables\r\n                syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n            }\r\n\r\n            if (!n.hasEmptyBody()) {\r\n                out.printin(\"if (\");\r\n                out.print(tagEvalVar);\r\n                out.println(\" != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {\");\r\n                out.pushIndent();\r\n\r\n                // Declare NESTED scripting variables\r\n                declareScriptingVars(n, VariableInfo.NESTED);\r\n                saveScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                if (n.implementsBodyTag()) {\r\n                    out.printin(\"if (\");\r\n                    out.print(tagEvalVar);\r\n                    out\r\n                            .println(\" != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) {\");\r\n                    // Assume EVAL_BODY_BUFFERED\r\n                    out.pushIndent();\r\n                    out.printil(\"out = _jspx_page_context.pushBody();\");\r\n                    if (n.implementsTryCatchFinally()) {\r\n                        out.printin(tagPushBodyCountVar);\r\n                        out.println(\"[0]++;\");\r\n                    } else if (pushBodyCountVar != null) {\r\n                        out.printin(pushBodyCountVar);\r\n                        out.println(\"[0]++;\");\r\n                    }\r\n                    out.printin(tagHandlerVar);\r\n                    out\r\n                            .println(\".setBodyContent((javax.servlet.jsp.tagext.BodyContent) out);\");\r\n                    out.printin(tagHandlerVar);\r\n                    out.println(\".doInitBody();\");\r\n\r\n                    out.popIndent();\r\n                    out.printil(\"}\");\r\n\r\n                    // Synchronize AT_BEGIN and NESTED scripting variables\r\n                    syncScriptingVars(n, VariableInfo.AT_BEGIN);\r\n                    syncScriptingVars(n, VariableInfo.NESTED);\r\n\r\n                } else {\r\n                    // Synchronize NESTED scripting variables\r\n                    syncScriptingVars(n, VariableInfo.NESTED);\r\n                }\r\n\r\n                if (n.implementsIterationTag()) {\r\n                    out.printil(\"do {\");\r\n                    out.pushIndent();\r\n                }\r\n            }\r\n            // Map the Java lines that handles start of custom tags to the\r\n            // JSP line for this tag\r\n            n.setEndJavaLine(out.getJavaLine());\r\n        }","commit_id":"a955206bfec222de6cd8c537d303a879dd267425","url":"https://github.com/apache/tomcat"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address) evt.getArg();\n            break;\n\n        case Event.MSG:\n            Message msg=(Message) evt.getArg();\n            FdHeader hdr=(FdHeader) msg.getHeader(name);\n            if(hdr == null)\n                break;  // message did not originate from FD_SOCK layer, just pass up\n\n            switch(hdr.type) {\n\n            case FdHeader.SUSPECT:\n                if(hdr.mbrs != null) {\n                    if(log.isDebugEnabled()) log.debug(\"[SUSPECT] hdr=\" + hdr);\n                    for(Address m: hdr.mbrs) {\n                        if(local_addr != null && m.equals(local_addr)) {\n                            if(warn)\n                                log.warn(\"I was suspected by \" + msg.getSrc() + \"; ignoring the SUSPECT message\");\n                            continue;\n                        }\n                        up_prot.up(new Event(Event.SUSPECT, m));\n                        down_prot.down(new Event(Event.SUSPECT, m));\n                    }\n                }\n                else\n                    if(warn) log.warn(\"[SUSPECT]: hdr.mbrs == null\");\n                break;\n\n                // If I have the sock for 'hdr.mbr', return it. Otherwise look it up in my cache and return it\n            case FdHeader.WHO_HAS_SOCK:\n                if(local_addr != null && local_addr.equals(msg.getSrc()))\n                    return null; // don't reply to WHO_HAS bcasts sent by me !\n\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"hdr.mbr is null\");\n                    return null;\n                }\n\n                if(trace) log.trace(\"who-has-sock \" + hdr.mbr);\n\n                // 1. Try my own address, maybe it's me whose socket is wanted\n                if(local_addr != null && local_addr.equals(hdr.mbr) && srv_sock_addr != null) {\n                    sendIHaveSockMessage(msg.getSrc(), local_addr, srv_sock_addr);  // unicast message to msg.getSrc()\n                    return null;\n                }\n\n                // 2. If I don't have it, maybe it is in the cache\n                if(cache.containsKey(hdr.mbr))\n                    sendIHaveSockMessage(msg.getSrc(), hdr.mbr, (IpAddress) cache.get(hdr.mbr));  // ucast msg\n                break;\n\n\n                // Update the cache with the addr:sock_addr entry (if on the same host)\n            case FdHeader.I_HAVE_SOCK:\n                if(hdr.mbr == null || hdr.sock_addr == null) {\n                    if(log.isErrorEnabled()) log.error(\"[I_HAVE_SOCK]: hdr.mbr is null or hdr.sock_addr == null\");\n                    return null;\n                }\n\n                // if(!cache.containsKey(hdr.mbr))\n                cache.put(hdr.mbr, hdr.sock_addr); // update the cache\n                if(trace) log.trace(\"i-have-sock: \" + hdr.mbr + \" --> \" +\n                                                   hdr.sock_addr + \" (cache is \" + cache + ')');\n\n                if(ping_dest != null && hdr.mbr.equals(ping_dest))\n                    ping_addr_promise.setResult(hdr.sock_addr);\n                break;\n\n                // Return the cache to the sender of this message\n            case FdHeader.GET_CACHE:\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE): hdr.mbr == null\");\n                    return null;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE_RSP);\n                hdr.cachedAddrs=(Hashtable) cache.clone();\n                msg=new Message(hdr.mbr, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                break;\n\n            case FdHeader.GET_CACHE_RSP:\n                if(hdr.cachedAddrs == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE_RSP): cache is null\");\n                    return null;\n                }\n                get_cache_promise.setResult(hdr.cachedAddrs);\n                break;\n            }\n            return null;\n\n            case Event.CONFIG:\n                if(bind_addr == null) {\n                    Map config=(Map)evt.getArg();\n                    bind_addr=(InetAddress)config.get(\"bind_addr\");\n                }\n                break;\n        }\n\n        return up_prot.up(evt);                                        // pass up to the layer above us\n    }","id":30052,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address) evt.getArg();\n            break;\n\n        case Event.MSG:\n            Message msg=(Message) evt.getArg();\n            FdHeader hdr=(FdHeader) msg.getHeader(name);\n            if(hdr == null)\n                break;  // message did not originate from FD_SOCK layer, just pass up\n\n            switch(hdr.type) {\n\n            case FdHeader.SUSPECT:\n                if(hdr.mbrs != null) {\n                    if(log.isDebugEnabled()) log.debug(\"[SUSPECT] hdr=\" + hdr);\n                    for(Address m: hdr.mbrs) {\n                        if(local_addr != null && m.equals(local_addr)) {\n                            if(warn)\n                                log.warn(\"I was suspected by \" + msg.getSrc() + \"; ignoring the SUSPECT message\");\n                            continue;\n                        }\n                        up_prot.up(new Event(Event.SUSPECT, m));\n                        down_prot.down(new Event(Event.SUSPECT, m));\n                    }\n                }\n                else\n                    if(warn) log.warn(\"[SUSPECT]: hdr.mbrs == null\");\n                break;\n\n                // If I have the sock for 'hdr.mbr', return it. Otherwise look it up in my cache and return it\n            case FdHeader.WHO_HAS_SOCK:\n                if(local_addr != null && local_addr.equals(msg.getSrc()))\n                    return null; // don't reply to WHO_HAS bcasts sent by me !\n\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"hdr.mbr is null\");\n                    return null;\n                }\n\n                if(trace) log.trace(\"who-has-sock \" + hdr.mbr);\n\n                // 1. Try my own address, maybe it's me whose socket is wanted\n                if(local_addr != null && local_addr.equals(hdr.mbr) && srv_sock_addr != null) {\n                    sendIHaveSockMessage(msg.getSrc(), local_addr, srv_sock_addr);  // unicast message to msg.getSrc()\n                    return null;\n                }\n\n                // 2. If I don't have it, maybe it is in the cache\n                if(cache.containsKey(hdr.mbr))\n                    sendIHaveSockMessage(msg.getSrc(), hdr.mbr, cache.get(hdr.mbr));  // ucast msg\n                break;\n\n\n                // Update the cache with the addr:sock_addr entry (if on the same host)\n            case FdHeader.I_HAVE_SOCK:\n                if(hdr.mbr == null || hdr.sock_addr == null) {\n                    if(log.isErrorEnabled()) log.error(\"[I_HAVE_SOCK]: hdr.mbr is null or hdr.sock_addr == null\");\n                    return null;\n                }\n\n                // if(!cache.containsKey(hdr.mbr))\n                cache.put(hdr.mbr, hdr.sock_addr); // update the cache\n                if(trace) log.trace(\"i-have-sock: \" + hdr.mbr + \" --> \" +\n                                                   hdr.sock_addr + \" (cache is \" + cache + ')');\n\n                if(ping_dest != null && hdr.mbr.equals(ping_dest))\n                    ping_addr_promise.setResult(hdr.sock_addr);\n                break;\n\n                // Return the cache to the sender of this message\n            case FdHeader.GET_CACHE:\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE): hdr.mbr == null\");\n                    return null;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE_RSP);\n                hdr.cachedAddrs=(Hashtable<Address,IpAddress>)cache.clone();\n                msg=new Message(hdr.mbr, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                break;\n\n            case FdHeader.GET_CACHE_RSP:\n                if(hdr.cachedAddrs == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE_RSP): cache is null\");\n                    return null;\n                }\n                get_cache_promise.setResult(hdr.cachedAddrs);\n                break;\n            }\n            return null;\n\n            case Event.CONFIG:\n                if(bind_addr == null) {\n                    Map config=(Map)evt.getArg();\n                    bind_addr=(InetAddress)config.get(\"bind_addr\");\n                }\n                break;\n        }\n\n        return up_prot.up(evt);                                        // pass up to the layer above us\n    }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"public FdHeader(byte type, Set mbrs) {\n            this.type=type;\n            this.mbrs=mbrs;\n        }","id":30053,"modified_method":"public FdHeader(byte type, Set<Address> mbrs) {\n            this.type=type;\n            this.mbrs=mbrs;\n        }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            Message suspect_msg;\n            FdHeader hdr;\n\n            if(log.isDebugEnabled())\n                log.debug(\"broadcasting SUSPECT message (suspected_mbrs=\" + suspected_mbrs + \") to group\");\n\n            synchronized(suspected_mbrs) {\n                if(suspected_mbrs.isEmpty()) {\n                    stopTask();\n                    if(log.isDebugEnabled()) log.debug(\"task done (no suspected members)\");\n                    return;\n                }\n\n                hdr=new FdHeader(FdHeader.SUSPECT);\n                hdr.mbrs=new HashSet(suspected_mbrs);\n            }\n            suspect_msg=new Message();       // mcast SUSPECT to all members\n            suspect_msg.setFlag(Message.OOB);\n            suspect_msg.putHeader(name, hdr);\n            down_prot.down(new Event(Event.MSG, suspect_msg));\n            if(log.isDebugEnabled()) log.debug(\"task done\");\n        }","id":30054,"modified_method":"public void run() {\n            Message suspect_msg;\n            FdHeader hdr;\n\n            if(log.isDebugEnabled())\n                log.debug(\"broadcasting SUSPECT message (suspected_mbrs=\" + suspected_mbrs + \") to group\");\n\n            synchronized(suspected_mbrs) {\n                if(suspected_mbrs.isEmpty()) {\n                    stopTask();\n                    if(log.isDebugEnabled()) log.debug(\"task done (no suspected members)\");\n                    return;\n                }\n\n                hdr=new FdHeader(FdHeader.SUSPECT);\n                hdr.mbrs=new HashSet<Address>(suspected_mbrs);\n            }\n            suspect_msg=new Message();       // mcast SUSPECT to all members\n            suspect_msg.setFlag(Message.OOB);\n            suspect_msg.putHeader(name, hdr);\n            down_prot.down(new Event(Event.MSG, suspect_msg));\n            if(log.isDebugEnabled()) log.debug(\"task done\");\n        }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.UNSUSPECT:\n                bcast_task.removeSuspectedMember((Address)evt.getArg());\n                break;\n\n            case Event.CONNECT:\n                Object ret=down_prot.down(evt);\n                group_name=(String)evt.getArg();\n                srv_sock=Util.createServerSocket(bind_addr, start_port); // grab a random unused port above 10000\n                srv_sock_addr=new IpAddress(bind_addr, srv_sock.getLocalPort());\n                startServerSocket();\n                return ret;\n\n            case Event.DISCONNECT:\n                group_name=null;\n                String tmp, prefix=Global.THREAD_PREFIX;\n                int index;\n                tmp=srv_sock_handler != null? srv_sock_handler.getName() : null;\n                if(tmp != null) {\n                    index=tmp.indexOf(prefix);\n                    if(index > -1) {\n                        tmp=tmp.substring(0, index);\n                        srv_sock_handler.setName(tmp);\n                    }\n                }\n                synchronized(pinger_mutex) {\n                    tmp=pinger_thread != null? pinger_thread.getName() : null;\n                    if(tmp != null) {\n                        index=tmp.indexOf(prefix);\n                        if(index > -1) {\n                            tmp=tmp.substring(0, index);\n                            pinger_thread.setName(tmp);\n                        }\n                    }\n                }\n\n                stopServerSocket();\n\n                break;\n\n            case Event.VIEW_CHANGE:\n                View v=(View) evt.getArg();\n                Vector new_mbrs=v.getMembers();\n                down_prot.down(evt);\n\n                synchronized(this) {\n                    members.removeAllElements();\n                    members.addAll(new_mbrs);\n                    bcast_task.adjustSuspectedMembers(members);\n                    pingable_mbrs.removeAllElements();\n                    pingable_mbrs.addAll(members);\n                    if(log.isDebugEnabled()) log.debug(\"VIEW_CHANGE received: \" + members);\n\n                    // 1. Get the addr:pid cache from the coordinator (only if not already fetched)\n                    if(!got_cache_from_coord) {\n                        getCacheFromCoordinator();\n                        got_cache_from_coord=true;\n                    }\n\n                    // 2. Broadcast my own addr:sock to all members so they can update their cache\n                    if(!srv_sock_sent) {\n                        if(srv_sock_addr != null) {\n                            sendIHaveSockMessage(null, // send to all members\n                                    local_addr,\n                                    srv_sock_addr);\n                            srv_sock_sent=true;\n                        }\n                        else\n                            if(warn) log.warn(\"(VIEW_CHANGE): srv_sock_addr == null\");\n                    }\n\n                    // 3. Remove all entries in 'cache' which are not in the new membership\n                    Address mbr;\n                    for(Enumeration e=cache.keys(); e.hasMoreElements();) {\n                        mbr=(Address) e.nextElement();\n                        if(!members.contains(mbr))\n                            cache.remove(mbr);\n                    }\n\n                    if(members.size() > 1) {\n                        synchronized(pinger_mutex) {\n                            if(pinger_thread != null && pinger_thread.isAlive()) {\n                                Address tmp_ping_dest=determinePingDest();\n                                if(ping_dest != null && tmp_ping_dest != null && !ping_dest.equals(tmp_ping_dest)) {\n                                    interruptPingerThread(); // allows the thread to use the new socket\n                                }\n                            }\n                            else\n                                startPingerThread(); // only starts if not yet running\n                        }\n                    }\n                    else {\n                        ping_dest=null;\n                        stopPingerThread();\n                    }\n                }\n                return null; // we already passed down the event above\n\n            default:\n                return down_prot.down(evt);\n        }\n\n        return down_prot.down(evt);\n    }","id":30055,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.UNSUSPECT:\n                bcast_task.removeSuspectedMember((Address)evt.getArg());\n                break;\n\n            case Event.CONNECT:\n                Object ret=down_prot.down(evt);\n                group_name=(String)evt.getArg();\n                srv_sock=Util.createServerSocket(bind_addr, start_port); // grab a random unused port above 10000\n                srv_sock_addr=new IpAddress(bind_addr, srv_sock.getLocalPort());\n                startServerSocket();\n                return ret;\n\n            case Event.DISCONNECT:\n                group_name=null;\n                String tmp, prefix=Global.THREAD_PREFIX;\n                int index;\n                tmp=srv_sock_handler != null? srv_sock_handler.getName() : null;\n                if(tmp != null) {\n                    index=tmp.indexOf(prefix);\n                    if(index > -1) {\n                        tmp=tmp.substring(0, index);\n                        srv_sock_handler.setName(tmp);\n                    }\n                }\n                synchronized(pinger_mutex) {\n                    tmp=pinger_thread != null? pinger_thread.getName() : null;\n                    if(tmp != null) {\n                        index=tmp.indexOf(prefix);\n                        if(index > -1) {\n                            tmp=tmp.substring(0, index);\n                            pinger_thread.setName(tmp);\n                        }\n                    }\n                }\n\n                stopServerSocket();\n\n                break;\n\n            case Event.VIEW_CHANGE:\n                View v=(View) evt.getArg();\n                Vector<Address> new_mbrs=v.getMembers();\n                down_prot.down(evt);\n\n                synchronized(this) {\n                    members.removeAllElements();\n                    members.addAll(new_mbrs);\n                    bcast_task.adjustSuspectedMembers(members);\n                    pingable_mbrs.removeAllElements();\n                    pingable_mbrs.addAll(members);\n                    if(log.isDebugEnabled()) log.debug(\"VIEW_CHANGE received: \" + members);\n\n                    // 1. Get the addr:pid cache from the coordinator (only if not already fetched)\n                    if(!got_cache_from_coord) {\n                        getCacheFromCoordinator();\n                        got_cache_from_coord=true;\n                    }\n\n                    // 2. Broadcast my own addr:sock to all members so they can update their cache\n                    if(!srv_sock_sent) {\n                        if(srv_sock_addr != null) {\n                            sendIHaveSockMessage(null, // send to all members\n                                    local_addr,\n                                    srv_sock_addr);\n                            srv_sock_sent=true;\n                        }\n                        else\n                            if(warn) log.warn(\"(VIEW_CHANGE): srv_sock_addr == null\");\n                    }\n\n                    // 3. Remove all entries in 'cache' which are not in the new membership\n                    Address mbr;\n                    for(Enumeration e=cache.keys(); e.hasMoreElements();) {\n                        mbr=(Address) e.nextElement();\n                        if(!members.contains(mbr))\n                            cache.remove(mbr);\n                    }\n\n                    if(members.size() > 1) {\n                        synchronized(pinger_mutex) {\n                            if(pinger_thread != null && pinger_thread.isAlive()) {\n                                Address tmp_ping_dest=determinePingDest();\n                                if(ping_dest != null && tmp_ping_dest != null && !ping_dest.equals(tmp_ping_dest)) {\n                                    interruptPingerThread(); // allows the thread to use the new socket\n                                }\n                            }\n                            else\n                                startPingerThread(); // only starts if not yet running\n                        }\n                    }\n                    else {\n                        ping_dest=null;\n                        stopPingerThread();\n                    }\n                }\n                return null; // we already passed down the event above\n\n            default:\n                return down_prot.down(evt);\n        }\n\n        return down_prot.down(evt);\n    }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"Address determineCoordinator() {\n        return !members.isEmpty()? (Address) members.elementAt(0) : null;\n    }","id":30056,"modified_method":"Address determineCoordinator() {\n        return !members.isEmpty()? members.elementAt(0) : null;\n    }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"public FdHeader(byte type, Hashtable cachedAddrs) {\n            this.type=type;\n            this.cachedAddrs=cachedAddrs;\n        }","id":30057,"modified_method":"public FdHeader(byte type, Hashtable<Address,IpAddress> cachedAddrs) {\n            this.type=type;\n            this.cachedAddrs=cachedAddrs;\n        }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"ClientConnectionHandler(Socket client_sock, List clients) {\n            setName(\"ClientConnectionHandler\");\n            setDaemon(true);\n            this.client_sock=client_sock;\n            this.clients.addAll(clients);\n        }","id":30058,"modified_method":"ClientConnectionHandler(Socket client_sock, List<ClientConnectionHandler> clients) {\n            setName(\"ClientConnectionHandler\");\n            setDaemon(true);\n            this.client_sock=client_sock;\n            this.clients.addAll(clients);\n        }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            type=in.readByte();\n            mbr=(Address) in.readObject();\n            sock_addr=(IpAddress) in.readObject();\n            cachedAddrs=(Hashtable) in.readObject();\n            mbrs=(Set)in.readObject();\n        }","id":30059,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            type=in.readByte();\n            mbr=(Address) in.readObject();\n            sock_addr=(IpAddress) in.readObject();\n            cachedAddrs=(Hashtable<Address,IpAddress>) in.readObject();\n            mbrs=(Set<Address>)in.readObject();\n        }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a SUSPECT message to all group members. Only the coordinator (or the next member in line if the coord\n     * itself is suspected) will react to this message by installing a new view. To overcome the unreliability\n     * of the SUSPECT message (it may be lost because we are not above any retransmission layer), the following scheme\n     * is used: after sending the SUSPECT message, it is also added to the broadcast task, which will periodically\n     * re-send the SUSPECT until a view is received in which the suspected process is not a member anymore. The reason is\n     * that - at one point - either the coordinator or another participant taking over for a crashed coordinator, will\n     * react to the SUSPECT message and issue a new view, at which point the broadcast task stops.\n     */\n    void broadcastSuspectMessage(Address suspected_mbr) {\n        Message suspect_msg;\n        FdHeader hdr;\n\n        if(suspected_mbr == null) return;\n\n        if(trace) log.trace(\"suspecting \" + suspected_mbr + \" (own address is \" + local_addr + ')');\n\n        // 1. Send a SUSPECT message right away; the broadcast task will take some time to send it (sleeps first)\n        hdr=new FdHeader(FdHeader.SUSPECT);\n        hdr.mbrs=new HashSet(1);\n        hdr.mbrs.add(suspected_mbr);\n        suspect_msg=new Message();\n        suspect_msg.setFlag(Message.OOB);\n        suspect_msg.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, suspect_msg));\n\n        // 2. Add to broadcast task and start latter (if not yet running). The task will end when\n        //    suspected members are removed from the membership\n        bcast_task.addSuspectedMember(suspected_mbr);\n        if(stats) {\n            num_suspect_events++;\n            suspect_history.add(suspected_mbr);\n        }\n    }","id":30060,"modified_method":"/**\n     * Sends a SUSPECT message to all group members. Only the coordinator (or the next member in line if the coord\n     * itself is suspected) will react to this message by installing a new view. To overcome the unreliability\n     * of the SUSPECT message (it may be lost because we are not above any retransmission layer), the following scheme\n     * is used: after sending the SUSPECT message, it is also added to the broadcast task, which will periodically\n     * re-send the SUSPECT until a view is received in which the suspected process is not a member anymore. The reason is\n     * that - at one point - either the coordinator or another participant taking over for a crashed coordinator, will\n     * react to the SUSPECT message and issue a new view, at which point the broadcast task stops.\n     */\n    void broadcastSuspectMessage(Address suspected_mbr) {\n        Message suspect_msg;\n        FdHeader hdr;\n\n        if(suspected_mbr == null) return;\n\n        if(trace) log.trace(\"suspecting \" + suspected_mbr + \" (own address is \" + local_addr + ')');\n\n        // 1. Send a SUSPECT message right away; the broadcast task will take some time to send it (sleeps first)\n        hdr=new FdHeader(FdHeader.SUSPECT);\n        hdr.mbrs=new HashSet<Address>(1);\n        hdr.mbrs.add(suspected_mbr);\n        suspect_msg=new Message();\n        suspect_msg.setFlag(Message.OOB);\n        suspect_msg.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, suspect_msg));\n\n        // 2. Add to broadcast task and start latter (if not yet running). The task will end when\n        //    suspected members are removed from the membership\n        bcast_task.addSuspectedMember(suspected_mbr);\n        if(stats) {\n            num_suspect_events++;\n            suspect_history.add(suspected_mbr);\n        }\n    }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"private void startTask() {\n            if(future == null || future.isDone()) {\n                future=timer.scheduleWithFixedDelay(this, suspect_msg_interval, suspect_msg_interval, TimeUnit.MILLISECONDS);\n            }\n        }","id":30061,"modified_method":"private void startTask() {\n            if(future == null || future.isDone()) {\n                try {\n                    future=timer.scheduleWithFixedDelay(this, suspect_msg_interval, suspect_msg_interval, TimeUnit.MILLISECONDS);\n                }\n                catch(RejectedExecutionException e) {\n                    if(warn)\n                        log.warn(\"task \" + this + \" was rejected as timer thread pool is shutting down\");\n                }\n            }\n        }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"private Address determinePingDest() {\n        Address tmp;\n\n        if(pingable_mbrs == null || pingable_mbrs.size() < 2 || local_addr == null)\n            return null;\n        for(int i=0; i < pingable_mbrs.size(); i++) {\n            tmp=(Address) pingable_mbrs.elementAt(i);\n            if(local_addr.equals(tmp)) {\n                if(i + 1 >= pingable_mbrs.size())\n                    return (Address) pingable_mbrs.elementAt(0);\n                else\n                    return (Address) pingable_mbrs.elementAt(i + 1);\n            }\n        }\n        return null;\n    }","id":30062,"modified_method":"private Address determinePingDest() {\n        Address tmp;\n\n        if(pingable_mbrs == null || pingable_mbrs.size() < 2 || local_addr == null)\n            return null;\n        for(int i=0; i < pingable_mbrs.size(); i++) {\n            tmp=pingable_mbrs.elementAt(i);\n            if(local_addr.equals(tmp)) {\n                if(i + 1 >= pingable_mbrs.size())\n                    return pingable_mbrs.elementAt(0);\n                else\n                    return pingable_mbrs.elementAt(i + 1);\n            }\n        }\n        return null;\n    }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Determines coordinator C. If C is null and we are the first member, return. Else loop: send GET_CACHE message\n     * to coordinator and wait for GET_CACHE_RSP response. Loop until valid response has been received.\n     */\n    void getCacheFromCoordinator() {\n        Address coord;\n        int attempts=num_tries;\n        Message msg;\n        FdHeader hdr;\n        Hashtable result;\n\n        get_cache_promise.reset();\n        while(attempts > 0) {\n            if((coord=determineCoordinator()) != null) {\n                if(coord.equals(local_addr)) { // we are the first member --> empty cache\n                    if(log.isDebugEnabled()) log.debug(\"first member; cache is empty\");\n                    return;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE);\n                hdr.mbr=local_addr;\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                result=(Hashtable) get_cache_promise.getResult(get_cache_timeout);\n                if(result != null) {\n                    cache.putAll(result); // replace all entries (there should be none !) in cache with the new values\n                    if(trace) log.trace(\"got cache from \" + coord + \": cache is \" + cache);\n                    return;\n                }\n                else {\n                    if(log.isErrorEnabled()) log.error(\"received null cache; retrying\");\n                }\n            }\n\n            Util.sleep(get_cache_retry_timeout);\n            --attempts;\n        }\n    }","id":30063,"modified_method":"/**\n     * Determines coordinator C. If C is null and we are the first member, return. Else loop: send GET_CACHE message\n     * to coordinator and wait for GET_CACHE_RSP response. Loop until valid response has been received.\n     */\n    void getCacheFromCoordinator() {\n        Address coord;\n        int attempts=num_tries;\n        Message msg;\n        FdHeader hdr;\n        Hashtable<Address,IpAddress> result;\n\n        get_cache_promise.reset();\n        while(attempts > 0) {\n            if((coord=determineCoordinator()) != null) {\n                if(coord.equals(local_addr)) { // we are the first member --> empty cache\n                    if(log.isDebugEnabled()) log.debug(\"first member; cache is empty\");\n                    return;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE);\n                hdr.mbr=local_addr;\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                result=(Hashtable<Address,IpAddress>) get_cache_promise.getResult(get_cache_timeout);\n                if(result != null) {\n                    cache.putAll(result); // replace all entries (there should be none !) in cache with the new values\n                    if(trace) log.trace(\"got cache from \" + coord + \": cache is \" + cache);\n                    return;\n                }\n                else {\n                    if(log.isErrorEnabled()) log.error(\"received null cache; retrying\");\n                }\n            }\n\n            Util.sleep(get_cache_retry_timeout);\n            --attempts;\n        }\n    }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n            int size;\n            type=in.readByte();\n            mbr=Util.readAddress(in);\n            sock_addr=(IpAddress)Util.readStreamable(IpAddress.class, in);\n            size=in.readInt();\n            if(size > 0) {\n                if(cachedAddrs == null)\n                    cachedAddrs=new Hashtable();\n                for(int i=0; i < size; i++) {\n                    Address key=Util.readAddress(in);\n                    IpAddress val=(IpAddress)Util.readStreamable(IpAddress.class, in);\n                    cachedAddrs.put(key, val);\n                }\n            }\n            size=in.readInt();\n            if(size > 0) {\n                if(mbrs == null)\n                    mbrs=new HashSet();\n                for(int i=0; i < size; i++) {\n                    Address addr=Util.readAddress(in);\n                    mbrs.add(addr);\n                }\n            }\n        }","id":30064,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n            int size;\n            type=in.readByte();\n            mbr=Util.readAddress(in);\n            sock_addr=(IpAddress)Util.readStreamable(IpAddress.class, in);\n            size=in.readInt();\n            if(size > 0) {\n                if(cachedAddrs == null)\n                    cachedAddrs=new Hashtable();\n                for(int i=0; i < size; i++) {\n                    Address key=Util.readAddress(in);\n                    IpAddress val=(IpAddress)Util.readStreamable(IpAddress.class, in);\n                    cachedAddrs.put(key, val);\n                }\n            }\n            size=in.readInt();\n            if(size > 0) {\n                if(mbrs == null)\n                    mbrs=new HashSet<Address>();\n                for(int i=0; i < size; i++) {\n                    Address addr=Util.readAddress(in);\n                    mbrs.add(addr);\n                }\n            }\n        }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Attempts to obtain the ping_addr first from the cache, then by unicasting q request to <code>mbr<\/code>,\n     then by multicasting a request to all members.\n     */\n    private IpAddress fetchPingAddress(Address mbr) {\n        IpAddress ret;\n        Message ping_addr_req;\n        FdHeader hdr;\n\n        if(mbr == null) {\n            if(log.isErrorEnabled()) log.error(\"mbr == null\");\n            return null;\n        }\n        // 1. Try to get from cache. Add a little delay so that joining mbrs can send their socket address before\n        //    we ask them to do so\n        ret=(IpAddress)cache.get(mbr);\n        if(ret != null) {\n            return ret;\n        }\n\n        Util.sleep(300);\n        if((ret=(IpAddress)cache.get(mbr)) != null)\n            return ret;\n\n\n        // 2. Try to get from mbr\n        ping_addr_promise.reset();\n        ping_addr_req=new Message(mbr, null, null); // unicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        if(!running) return null;\n        ret=(IpAddress)ping_addr_promise.getResult(3000);\n        if(ret != null) {\n            return ret;\n        }\n\n\n        // 3. Try to get from all members\n        ping_addr_req=new Message(null); // multicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        ret=(IpAddress) ping_addr_promise.getResult(3000);\n        return ret;\n    }","id":30065,"modified_method":"/**\n     Attempts to obtain the ping_addr first from the cache, then by unicasting q request to <code>mbr<\/code>,\n     then by multicasting a request to all members.\n     */\n    private IpAddress fetchPingAddress(Address mbr) {\n        IpAddress ret;\n        Message ping_addr_req;\n        FdHeader hdr;\n\n        if(mbr == null) {\n            if(log.isErrorEnabled()) log.error(\"mbr == null\");\n            return null;\n        }\n        // 1. Try to get from cache. Add a little delay so that joining mbrs can send their socket address before\n        //    we ask them to do so\n        ret=cache.get(mbr);\n        if(ret != null) {\n            return ret;\n        }\n\n        Util.sleep(300);\n        if((ret=cache.get(mbr)) != null)\n            return ret;\n\n\n        // 2. Try to get from mbr\n        ping_addr_promise.reset();\n        ping_addr_req=new Message(mbr, null, null); // unicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        if(!running) return null;\n        ret=(IpAddress)ping_addr_promise.getResult(3000);\n        if(ret != null) {\n            return ret;\n        }\n\n\n        // 3. Try to get from all members\n        ping_addr_req=new Message(null); // multicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        ret=(IpAddress) ping_addr_promise.getResult(3000);\n        return ret;\n    }","commit_id":"e18129fdd80ec024a3d1ecb234206922399de746","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Return an array with the status of each thread. The status\n     * indicates the current request processing stage ( for tomcat ) or\n     * whatever the thread is doing ( if the application using TP provide\n     * this info )\n     *\n     * @return The status of all threads\n     */\n    public String[] getThreadStatus() {\n        String status[]=new String[ threads.size()];\n        Iterator it=threads.keySet().iterator();\n        for( int i=0; ( i<status.length && it.hasNext()); i++ ) {\n            ThreadWithAttributes twa=(ThreadWithAttributes)\n                    it.next();\n            status[i]=twa.getCurrentStage(this);\n        }\n        return status;\n    }","id":30066,"modified_method":"/** Return an array with the status of each thread. The status\n     * indicates the current request processing stage ( for tomcat ) or\n     * whatever the thread is doing ( if the application using TP provide\n     * this info )\n     *\n     * @return The status of all threads\n     */\n    public String[] getThreadStatus() {\n        String status[]=new String[ threads.size()];\n        Iterator<Thread> it=threads.keySet().iterator();\n        for( int i=0; ( i<status.length && it.hasNext()); i++ ) {\n            ThreadWithAttributes twa=(ThreadWithAttributes)\n                    it.next();\n            status[i]=twa.getCurrentStage(this);\n        }\n        return status;\n    }","commit_id":"0b66b6a984e234a61e4f82766746748cb637ca25","url":"https://github.com/apache/tomcat"},{"original_method":"/** Return an array with the current \"param\" ( XXX better name ? )\n     * of each thread. This is typically the last request.\n     *\n     * @return The params of all threads\n     */\n    public String[] getThreadParam() {\n        String status[]=new String[ threads.size()];\n        Iterator it=threads.keySet().iterator();\n        for( int i=0; ( i<status.length && it.hasNext()); i++ ) {\n            ThreadWithAttributes twa=(ThreadWithAttributes)\n                    it.next();\n            Object o=twa.getParam(this);\n            status[i]=(o==null)? null : o.toString();\n        }\n        return status;\n    }","id":30067,"modified_method":"/** Return an array with the current \"param\" ( XXX better name ? )\n     * of each thread. This is typically the last request.\n     *\n     * @return The params of all threads\n     */\n    public String[] getThreadParam() {\n        String status[]=new String[ threads.size()];\n        Iterator<Thread> it=threads.keySet().iterator();\n        for( int i=0; ( i<status.length && it.hasNext()); i++ ) {\n            ThreadWithAttributes twa=(ThreadWithAttributes)\n                    it.next();\n            Object o=twa.getParam(this);\n            status[i]=(o==null)? null : o.toString();\n        }\n        return status;\n    }","commit_id":"0b66b6a984e234a61e4f82766746748cb637ca25","url":"https://github.com/apache/tomcat"},{"original_method":"/** \n     * Debug display of the stage of each thread. The return is html style,\n     * for display in the console ( it can be easily parsed too ).\n     *\n     * @return The thread status display\n     */\n    public String threadStatusString() {\n        StringBuffer sb=new StringBuffer();\n        Iterator it=threads.keySet().iterator();\n        sb.append(\"<ul>\");\n        while( it.hasNext()) {\n            sb.append(\"<li>\");\n            ThreadWithAttributes twa=(ThreadWithAttributes)\n                    it.next();\n            sb.append(twa.getCurrentStage(this) ).append(\" \");\n            sb.append( twa.getParam(this));\n            sb.append( \"<\/li>\\n\");\n        }\n        sb.append(\"<\/ul>\");\n        return sb.toString();\n    }","id":30068,"modified_method":"/** \n     * Debug display of the stage of each thread. The return is html style,\n     * for display in the console ( it can be easily parsed too ).\n     *\n     * @return The thread status display\n     */\n    public String threadStatusString() {\n        StringBuffer sb=new StringBuffer();\n        Iterator<Thread> it=threads.keySet().iterator();\n        sb.append(\"<ul>\");\n        while( it.hasNext()) {\n            sb.append(\"<li>\");\n            ThreadWithAttributes twa=(ThreadWithAttributes)\n                    it.next();\n            sb.append(twa.getCurrentStage(this) ).append(\" \");\n            sb.append( twa.getParam(this));\n            sb.append( \"<\/li>\\n\");\n        }\n        sb.append(\"<\/ul>\");\n        return sb.toString();\n    }","commit_id":"0b66b6a984e234a61e4f82766746748cb637ca25","url":"https://github.com/apache/tomcat"},{"original_method":"public void addThread( Thread t, ControlRunnable cr ) {\n        threads.put( t, cr );\n        for( int i=0; i<listeners.size(); i++ ) {\n            ThreadPoolListener tpl=(ThreadPoolListener)listeners.elementAt(i);\n            tpl.threadStart(this, t);\n        }\n    }","id":30069,"modified_method":"public void addThread( Thread t, ControlRunnable cr ) {\n        threads.put( t, cr );\n        for( int i=0; i<listeners.size(); i++ ) {\n            ThreadPoolListener tpl = listeners.elementAt(i);\n            tpl.threadStart(this, t);\n        }\n    }","commit_id":"0b66b6a984e234a61e4f82766746748cb637ca25","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Sets the thread priority for current\n     * and future threads in this pool.\n     *\n     * @param threadPriority The new priority\n     * @throws IllegalArgumentException If the specified\n     *  priority is less than Thread.MIN_PRIORITY or\n     *  more than Thread.MAX_PRIORITY \n     */\n    public synchronized void setThreadPriority(int threadPriority) {\n        if(log.isDebugEnabled())\n            log.debug(getClass().getName() +\n                      \": setPriority(\" + threadPriority + \"): here.\");\n\n      if (threadPriority < Thread.MIN_PRIORITY) {\n        throw new IllegalArgumentException(\"new priority < MIN_PRIORITY\");\n      } else if (threadPriority > Thread.MAX_PRIORITY) {\n        throw new IllegalArgumentException(\"new priority > MAX_PRIORITY\");\n      }\n\n      // Set for future threads\n      this.threadPriority = threadPriority;\n\n      Enumeration currentThreads = getThreads();\n      Thread t = null;\n      while(currentThreads.hasMoreElements()) {\n        t = (Thread) currentThreads.nextElement();\n        t.setPriority(threadPriority);\n      } \n    }","id":30070,"modified_method":"/**\n     * Sets the thread priority for current\n     * and future threads in this pool.\n     *\n     * @param threadPriority The new priority\n     * @throws IllegalArgumentException If the specified\n     *  priority is less than Thread.MIN_PRIORITY or\n     *  more than Thread.MAX_PRIORITY \n     */\n    public synchronized void setThreadPriority(int threadPriority) {\n        if(log.isDebugEnabled())\n            log.debug(getClass().getName() +\n                      \": setPriority(\" + threadPriority + \"): here.\");\n\n      if (threadPriority < Thread.MIN_PRIORITY) {\n        throw new IllegalArgumentException(\"new priority < MIN_PRIORITY\");\n      } else if (threadPriority > Thread.MAX_PRIORITY) {\n        throw new IllegalArgumentException(\"new priority > MAX_PRIORITY\");\n      }\n\n      // Set for future threads\n      this.threadPriority = threadPriority;\n\n      Enumeration<Thread> currentThreads = getThreads();\n      Thread t = null;\n      while(currentThreads.hasMoreElements()) {\n        t = currentThreads.nextElement();\n        t.setPriority(threadPriority);\n      } \n    }","commit_id":"0b66b6a984e234a61e4f82766746748cb637ca25","url":"https://github.com/apache/tomcat"},{"original_method":"public void removeThread( Thread t ) {\n        threads.remove(t);\n        for( int i=0; i<listeners.size(); i++ ) {\n            ThreadPoolListener tpl=(ThreadPoolListener)listeners.elementAt(i);\n            tpl.threadEnd(this, t);\n        }\n    }","id":30071,"modified_method":"public void removeThread( Thread t ) {\n        threads.remove(t);\n        for( int i=0; i<listeners.size(); i++ ) {\n            ThreadPoolListener tpl = listeners.elementAt(i);\n            tpl.threadEnd(this, t);\n        }\n    }","commit_id":"0b66b6a984e234a61e4f82766746748cb637ca25","url":"https://github.com/apache/tomcat"},{"original_method":"void notifyViewChange(View v) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).viewChange(v);\n    }","id":30072,"modified_method":"void notifyViewChange(View v) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).viewChange(v);\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"private Node(String child_name, String fqn, Node parent, String key, Object value) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data == null) data=new HashMap();\n            data.put(key, value);\n        }","id":30073,"modified_method":"private Node(String child_name, String fqn, Node parent, String key, Object value) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data == null) data=new HashMap<String,Object>();\n            data.put(key, value);\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a channel with the given properties. Connects to the channel, then creates a PullPushAdapter\n     * and starts it\n     */\n    public ReplicatedTree(String groupname, String props, long state_fetch_timeout) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.connect(this.groupname);\n        start();\n    }","id":30074,"modified_method":"/**\n     * Creates a channel with the given properties. Connects to the channel, then creates a PullPushAdapter\n     * and starts it\n     */\n    public ReplicatedTree(String groupname, String props, long state_fetch_timeout) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.setReceiver(this);\n        channel.connect(this.groupname);\n        start();\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"public final void start() throws Exception {\n        if(request_handler == null) {\n            request_handler=new Thread(this, \"ReplicatedTree.RequestHandler thread\");\n            request_handler.setDaemon(true);\n            request_handler.start();\n        }\n        adapter=new PullPushAdapter(channel, this, this);\n        adapter.setListener(this);\n        boolean rc=channel.getState(null, state_fetch_timeout);\n\n        if(log.isInfoEnabled()) {\n            if(rc)\n                log.info(\"state was retrieved successfully\");\n            else\n                log.info(\"state could not be retrieved (first member)\");\n        }\n    }","id":30075,"modified_method":"public final void start() throws Exception {\n        boolean rc=channel.getState(null, state_fetch_timeout);\n        if(log.isInfoEnabled()) {\n            if(rc)\n                log.info(\"state was retrieved successfully\");\n            else\n                log.info(\"state could not be retrieved (first member)\");\n        }\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"void print(StringBuilder sb, int indent) {\n            printIndent(sb, indent);\n            sb.append(SEPARATOR).append(name);\n            if(children != null && children.size() > 0) {\n                Collection values=children.values();\n                for(Iterator it=values.iterator(); it.hasNext();) {\n                    sb.append('\\n');\n                    ((Node)it.next()).print(sb, indent + INDENT);\n                }\n            }\n        }","id":30076,"modified_method":"void print(StringBuilder sb, int indent) {\n            printIndent(sb, indent);\n            sb.append(SEPARATOR).append(name);\n            if(children != null && !children.isEmpty()) {\n                Collection values=children.values();\n                for(Iterator it=values.iterator(); it.hasNext();) {\n                    sb.append('\\n');\n                    ((Node)it.next()).print(sb, indent + INDENT);\n                }\n            }\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void viewAccepted(View new_view) {\n        Vector new_mbrs=new_view.getMembers();\n\n        // todo: if MergeView, fetch and reconcile state from coordinator\n        // actually maybe this is best left up to the application ? we just notify them and let\n        // the appl handle it ?\n\n        if(new_mbrs != null) {\n            notifyViewChange(new_view);\n            members.removeAllElements();\n            for(int i=0; i < new_mbrs.size(); i++)\n                members.addElement(new_mbrs.elementAt(i));\n        }\n\t\t//if size is bigger than one, there are more peers in the group\n\t\t//otherwise there is only one server.\n        send_message=members.size() > 1;\n    }","id":30077,"modified_method":"public void viewAccepted(View new_view) {\n        Vector<Address> new_mbrs=new_view.getMembers();\n\n        // todo: if MergeView, fetch and reconcile state from coordinator\n        // actually maybe this is best left up to the application ? we just notify them and let the appl handle it ?\n\n        if(new_mbrs != null) {\n            notifyViewChange(new_view);\n            members.removeAllElements();\n            for(int i=0; i < new_mbrs.size(); i++)\n                members.addElement(new_mbrs.elementAt(i));\n        }\n\t\t//if size is bigger than one, there are more peers in the group\n\t\t//otherwise there is only one server.\n        send_message=members.size() > 1;\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        if(request_handler != null && request_handler.isAlive()) {\n            request_queue.close(true);\n            request_handler=null;\n        }\n\n        request_handler=null;\n        if(channel != null) {\n            channel.close();\n        }\n        if(adapter != null) {\n            adapter.stop();\n            adapter=null;\n        }\n        channel=null;\n    }","id":30078,"modified_method":"public void stop() {\n        Util.close(channel);\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Callback. Process the contents of the message; typically an _add() or _set() request */\n    public void receive(Message msg) {\n        Request req=null;\n\n        if(msg == null || msg.getLength() == 0)\n            return;\n        try {\n            req=(Request)msg.getObject();\n            request_queue.add(req);\n        }\n        catch(QueueClosedException queue_closed_ex) {\n            if(log.isErrorEnabled()) log.error(\"request queue is null\");\n        }\n        catch(Exception ex) {\n            if(log.isErrorEnabled()) log.error(\"failed unmarshalling request: \" + ex);\n        }\n    }","id":30079,"modified_method":"/** Callback. Process the contents of the message; typically an _add() or _set() request */\n    public void receive(Message msg) {\n        Request req=null;\n\n        if(msg == null || msg.getLength() == 0)\n            return;\n        try {\n            req=(Request)msg.getObject();\n\n            String fqn=req.fqn;\n            switch(req.type) {\n                case Request.PUT:\n                    if(req.key != null && req.value != null)\n                        _put(fqn, req.key, req.value);\n                    else\n                        _put(fqn, req.data);\n                    break;\n                case Request.REMOVE:\n                    if(req.key != null)\n                        _remove(fqn, req.key);\n                    else\n                        _remove(fqn);\n                    break;\n                default:\n                    if(log.isErrorEnabled()) log.error(\"type \" + req.type + \" unknown\");\n                    break;\n            }\n        }\n        catch(Exception ex) {\n            if(log.isErrorEnabled()) log.error(\"failed unmarshalling request: \" + ex);\n        }\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"void setData(Map data) {\n            if(data == null) return;\n            if(this.data == null)\n                this.data=new HashMap();\n            this.data.putAll(data);\n        }","id":30080,"modified_method":"void setData(Map data) {\n            if(data == null) return;\n            if(this.data == null)\n                this.data=new HashMap<String,Object>();\n            this.data.putAll(data);\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"void setData(String key, Object value) {\n            if(this.data == null)\n                this.data=new HashMap();\n            this.data.put(key, value);\n        }","id":30081,"modified_method":"void setData(String key, Object value) {\n            if(this.data == null)\n                this.data=new HashMap<String,Object>();\n            this.data.put(key, value);\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Expects an already connected channel. Creates a PullPushAdapter and starts it\n     */\n    public ReplicatedTree(JChannel channel) throws Exception {\n        this.channel=channel;\n        start();\n    }","id":30082,"modified_method":"/**\n     * Expects an already connected channel. Creates a PullPushAdapter and starts it\n     */\n    public ReplicatedTree(JChannel channel) throws Exception {\n        this.channel=channel;\n        channel.setReceiver(this);\n        start();\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyNodeRemoved(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).nodeRemoved(fqn);\n    }","id":30083,"modified_method":"void notifyNodeRemoved(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).nodeRemoved(fqn);\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"public ReplicatedTree(String groupname, String props, long state_fetch_timeout, boolean jmx) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.jmx=jmx;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.connect(this.groupname);\n        if(jmx) {\n            MBeanServer server=Util.getMBeanServer();\n            if(server == null)\n                throw new Exception(\"No MBeanServers found; need to run with an MBeanServer present, or inside JDK 5\");\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName() , true);\n        }\n        start();\n    }","id":30084,"modified_method":"public ReplicatedTree(String groupname, String props, long state_fetch_timeout, boolean jmx) throws Exception {\n        if(groupname != null)\n            this.groupname=groupname;\n        if(props != null)\n            this.props=props;\n        this.jmx=jmx;\n        this.state_fetch_timeout=state_fetch_timeout;\n        channel=new JChannel(this.props);\n        channel.setReceiver(this);\n        channel.connect(this.groupname);\n\n        if(jmx) {\n            MBeanServer server=Util.getMBeanServer();\n            if(server == null)\n                throw new Exception(\"No MBeanServers found; need to run with an MBeanServer present, or inside JDK 5\");\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName() , true);\n        }\n        start();\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"private Node(String child_name, String fqn, Node parent, HashMap data) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data != null) this.data=(HashMap)data.clone();\n        }","id":30085,"modified_method":"private Node(String child_name, String fqn, Node parent, Map<String,Object> data) {\n            name=child_name;\n            this.fqn=fqn;\n            this.parent=parent;\n            if(data != null) this.data=(HashMap<String,Object>)((HashMap)data).clone();\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"Node createChild(String child_name, String fqn, Node parent, HashMap data) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap();\n            child=(Node)children.get(child_name);\n            if(child != null)\n                child.setData(data);\n            else {\n                child=new Node(child_name, fqn, parent, data);\n                children.put(child_name, child);\n            }\n            return child;\n        }","id":30086,"modified_method":"Node createChild(String child_name, String fqn, Node parent, HashMap<String,Object> data) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap<String,Node>();\n            child=children.get(child_name);\n            if(child != null)\n                child.setData(data);\n            else {\n                child=new Node(child_name, fqn, parent, data);\n                children.put(child_name, child);\n            }\n            return child;\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyNodeModified(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).nodeModified(fqn);\n    }","id":30087,"modified_method":"void notifyNodeModified(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).nodeModified(fqn);\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"Node createChild(String child_name, String fqn, Node parent, String key, Object value) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap();\n            child=(Node)children.get(child_name);\n            if(child != null)\n                child.setData(key, value);\n            else {\n                child=new Node(child_name, fqn, parent, key, value);\n                children.put(child_name, child);\n            }\n            return child;\n        }","id":30088,"modified_method":"Node createChild(String child_name, String fqn, Node parent, String key, Object value) {\n            Node child=null;\n\n            if(child_name == null) return null;\n            if(children == null) children=new TreeMap<String,Node>();\n            child=(Node)children.get(child_name);\n            if(child != null)\n                child.setData(key, value);\n            else {\n                child=new Node(child_name, fqn, parent, key, value);\n                children.put(child_name, child);\n            }\n            return child;\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"boolean childExists(String child_name) {\n            if(child_name == null) return false;\n            return children != null && children.containsKey(child_name);\n        }","id":30089,"modified_method":"boolean childExists(String child_name) {\n            return child_name != null && children != null && children.containsKey(child_name);\n        }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyNodeAdded(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            ((ReplicatedTreeListener)listeners.elementAt(i)).nodeAdded(fqn);\n    }","id":30090,"modified_method":"void notifyNodeAdded(String fqn) {\n        for(int i=0; i < listeners.size(); i++)\n            listeners.elementAt(i).nodeAdded(fqn);\n    }","commit_id":"d065d23308a9f67c871c18e8585959a70e3fd54b","url":"https://github.com/belaban/JGroups"},{"original_method":"void stop() {\n               is_it_running=false;\n               if(send_queue != null)\n                   send_queue.clear();\n               if(senderThread != null) {\n                   Thread tmp=senderThread;\n                   senderThread=null;\n                   tmp.interrupt();\n                   try {\n                       tmp.join(MAX_JOIN_TIMEOUT);\n                   }\n                   catch(InterruptedException e) {\n                       Thread.currentThread().interrupt(); // set interrupt flag again\n                   }\n                   if(tmp.isAlive()) {\n                       if(log.isWarnEnabled())\n                           log.warn(\"sender thread was interrupted, but is still alive: \" + tmp);\n                   }\n               }\n           }","id":30091,"modified_method":"void stop() {\n               is_it_running=false;\n               if(send_queue != null)\n                   send_queue.clear();\n               if(senderThread != null) {\n                   Thread tmp=senderThread;\n                   senderThread=null;\n                   Util.interruptAndWaitToDie(tmp);\n               }\n           }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n       StringBuilder ret=new StringBuilder();\n       Address key;\n       Connection val;\n       Map.Entry entry;\n       HashMap copy;\n\n       synchronized(conns) {\n           copy=new HashMap(conns);\n       }\n       ret.append(\"local_addr=\" + local_addr).append(\"\\n\");\n       ret.append(\"connections (\" + copy.size() + \"):\\n\");\n       for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n           entry=(Map.Entry)it.next();\n           key=(Address)entry.getKey();\n           val=(Connection)entry.getValue();\n           ret.append(\"key: \" + key + \": \" + val + '\\n');\n       }\n       ret.append('\\n');\n       return ret.toString();\n   }","id":30092,"modified_method":"public String toString() {\n       StringBuilder ret=new StringBuilder();\n       Address key;\n       Connection val;\n       Map.Entry entry;\n       HashMap<Address,Connection> copy;\n\n       synchronized(conns) {\n           copy=new HashMap<Address,Connection>(conns);\n       }\n       ret.append(\"local_addr=\" + local_addr).append(\"\\n\");\n       ret.append(\"connections (\" + copy.size() + \"):\\n\");\n       for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n           entry=(Map.Entry)it.next();\n           key=(Address)entry.getKey();\n           val=(Connection)entry.getValue();\n           ret.append(\"key: \" + key + \": \" + val + '\\n');\n       }\n       ret.append('\\n');\n       return ret.toString();\n   }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n       * Removes all connections from ConnectionTable which are not in current_mbrs\n       * @param current_mbrs\n       */\n      public void retainAll(Collection current_mbrs) {\n          if(current_mbrs == null) return;\n          HashMap copy;\n          synchronized(conns) {\n              copy=new HashMap(conns);\n              conns.keySet().retainAll(current_mbrs);\n          }\n\n          // All of the connections that were not retained must be destroyed\n          // so that their resources are cleaned up.\n          Map.Entry entry;\n          for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n              entry=(Map.Entry)it.next();\n              Object oKey=entry.getKey();\n              if(!current_mbrs.contains(oKey)) {    // This connection NOT in the resultant connection set\n                  Connection conn=(Connection)entry.getValue();\n                  if(null != conn) {    // Destroy this connection\n                      if(log.isTraceEnabled())\n                          log.trace(\"Destroy this orphaned connection: \" + conn);\n                      conn.destroy();\n                  }\n              }\n          }\n          copy.clear();\n      }","id":30093,"modified_method":"/**\n       * Removes all connections from ConnectionTable which are not in current_mbrs\n       * @param current_mbrs\n       */\n      public void retainAll(Collection current_mbrs) {\n          if(current_mbrs == null) return;\n          HashMap<Address,Connection> copy;\n          synchronized(conns) {\n              copy=new HashMap<Address,Connection>(conns);\n              conns.keySet().retainAll(current_mbrs);\n          }\n\n          // All of the connections that were not retained must be destroyed\n          // so that their resources are cleaned up.\n          Map.Entry entry;\n          for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n              entry=(Map.Entry)it.next();\n              Object oKey=entry.getKey();\n              if(!current_mbrs.contains(oKey)) {    // This connection NOT in the resultant connection set\n                  Connection conn=(Connection)entry.getValue();\n                  if(null != conn) {    // Destroy this connection\n                      if(log.isTraceEnabled())\n                          log.trace(\"Destroy this orphaned connection: \" + conn);\n                      conn.destroy();\n                  }\n              }\n          }\n          copy.clear();\n      }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyConnectionOpened(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           ((ConnectionListener)conn_listeners.elementAt(i)).connectionOpened(peer);\n   }","id":30094,"modified_method":"void notifyConnectionOpened(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           conn_listeners.elementAt(i).connectionOpened(peer);\n   }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n           Thread tmp=t;\n           if(t != null)\n               t=null;\n           if(tmp != null) {\n               tmp.interrupt(); // interrupts the sleep()\n               try {\n                   tmp.join(MAX_JOIN_TIMEOUT);\n               }\n               catch(InterruptedException e) {\n                   Thread.currentThread().interrupt(); // set interrupt flag again\n               }\n               if(tmp.isAlive()) {\n                   if(log.isWarnEnabled())\n                       log.warn(\"reaper thread was interrupted, but is still alive: \" + tmp);\n               }\n           }\n       }","id":30095,"modified_method":"public void stop() {\n           Thread tmp=t;\n           if(t != null)\n               t=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n       }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    Remove <code>addr<\/code>from connection table. This is typically triggered when a member is suspected.\n    */\n   public void remove(Address addr) {\n       Connection conn;\n\n       synchronized(conns) {\n           conn=(Connection)conns.remove(addr);\n       }\n\n       if(conn != null) {\n           try {\n               conn.destroy();  // won't do anything if already destroyed\n           }\n           catch(Exception e) {\n           }\n       }\n       if(log.isTraceEnabled()) log.trace(\"removed \" + addr + \", connections are \" + toString());\n   }","id":30096,"modified_method":"/**\n    Remove <code>addr<\/code>from connection table. This is typically triggered when a member is suspected.\n    */\n   public void remove(Address addr) {\n       Connection conn;\n\n       synchronized(conns) {\n           conn=conns.remove(addr);\n       }\n\n       if(conn != null) {\n           try {\n               conn.destroy();  // won't do anything if already destroyed\n           }\n           catch(Exception e) {\n           }\n       }\n       if(log.isTraceEnabled()) log.trace(\"removed \" + addr + \", connections are \" + toString());\n   }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyConnectionClosed(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           ((ConnectionListener)conn_listeners.elementAt(i)).connectionClosed(peer);\n   }","id":30097,"modified_method":"void notifyConnectionClosed(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           conn_listeners.elementAt(i).connectionClosed(peer);\n   }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               try {\n                   tmp.interrupt();\n                   tmp.join(MAX_JOIN_TIMEOUT);\n               }\n               catch(InterruptedException e) {\n                   Thread.currentThread().interrupt(); // set interrupt flag again\n               }\n               if(tmp.isAlive()) {\n                   if(log.isWarnEnabled())\n                   log.warn(\"stopped receiver thread, but thread (\" + tmp + \") is still alive !\");\n               }\n           }\n       }","id":30098,"modified_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n       }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Closes all open sockets, the server socket and all threads waiting for incoming messages */\n    public void stop() {\n        super.stop();\n\n        // 1. Stop the reaper\n        if(reaper != null)\n            reaper.stop();\n\n        // 2. close the server socket (this also stops the acceptor thread)\n        if(srv_sock != null) {\n            try {\n                ServerSocket tmp=srv_sock;\n                srv_sock=null;\n                tmp.close();\n            }\n            catch(Exception e) {\n            }\n        }\n\n        // 3. then close the connections\n        Connection conn;\n        Collection tmp=null;\n        synchronized(conns) {\n            tmp=new LinkedList(conns.values());\n            conns.clear();\n        }\n        if(tmp != null) {\n            for(Iterator it=tmp.iterator(); it.hasNext();) {\n                conn=(Connection)it.next();\n                conn.destroy();\n            }\n            tmp.clear();\n        }\n        local_addr=null;\n    }","id":30099,"modified_method":"/** Closes all open sockets, the server socket and all threads waiting for incoming messages */\n    public void stop() {\n        super.stop();\n\n        // 1. Stop the reaper\n        if(reaper != null)\n            reaper.stop();\n\n        // 2. close the server socket (this also stops the acceptor thread)\n        if(srv_sock != null) {\n            try {\n                ServerSocket tmp=srv_sock;\n                srv_sock=null;\n                tmp.close();\n                if(acceptor != null)\n                \tUtil.interruptAndWaitToDie(acceptor);\n            }\n            catch(Exception e) {\n            }\n        }\n\n        // 3. then close the connections       \n        Collection<Connection> connsCopy=null;\n        synchronized(conns) {\n            connsCopy=new LinkedList<Connection>(conns.values());\n            conns.clear();\n        }        \n        for(Connection conn:connsCopy) {                \n            conn.destroy();\n        }\n        connsCopy.clear();        \n        local_addr=null;\n    }","commit_id":"c9f576988c28c9091e7c4d53ef17e7f22f3ddde1","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast\n     * or unicast message. No need to acquire mutex (must already be held when this method is called)\n     * @param dest\n     * @param credits\n     * @return The lowest number of credits left, or -1 if a unicast member was not found\n     */\n    private long decrementCredit(Map<Address, Long> m, Address dest, long credits) {\n        boolean multicast=dest == null || dest.isMulticastAddress();\n        long lowest=max_credits, new_credit;\n        Long val;\n\n        if(multicast) {\n            if(m.isEmpty())\n                return -1;\n            for(Map.Entry<Address, Long> entry: m.entrySet()) {\n                val=entry.getValue();\n                new_credit=val - credits;\n                entry.setValue(new_credit);\n                lowest=Math.min(new_credit, lowest);\n            }\n            return lowest;\n        }\n        else {\n            val=m.get(dest);\n            if(val != null) {\n                lowest=val;\n                lowest-=credits;\n                m.put(dest, lowest);\n                return lowest;\n            }\n        }\n        return -1;\n    }","id":30100,"modified_method":"/**\n     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast\n     * or unicast message. No need to acquire mutex (must already be held when this method is called)\n     * @param dest\n     * @param credits\n     * @return The lowest number of credits left, or -1 if a unicast member was not found\n     */\n    private long decrementCredit(Map<Address, Long> m, Address dest, long credits) {\n        boolean multicast=dest == null || dest.isMulticastAddress();\n        long lowest=max_credits, new_credit;\n        Long val;\n\n        if(multicast) {\n            if(m.isEmpty())\n                return -1;\n            for(Map.Entry<Address, Long> entry: m.entrySet()) {\n                val=entry.getValue();\n                new_credit=val - credits;\n                entry.setValue(new_credit);\n                lowest=Math.min(new_credit, lowest);\n            }\n            return lowest;\n        }\n        else {\n            val=m.get(dest);\n            if(val != null) {\n                lowest=val;\n                lowest-=credits;\n                m.put(dest, lowest);\n                if(log.isTraceEnabled())\n                \tlog.trace(\"sender \" + dest + \" minus \" + credits\n\t\t\t\t\t\t\t+ \" credits, \" + lowest + \" remaining\");\n                return lowest;\n            }\n        }\n        return -1;\n    }","commit_id":"63178d534ddbda9632cb437c8f0e29eda9f716b3","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                return handleDownMessage(evt);\n            case Event.INFO:\n                handleInfo((Map<String,Object>)evt.getArg());\n                return null;\n        }\n        return down_prot.down(evt); // this could potentially use the lower protocol's thread which may block\n    }","id":30101,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                return handleDownMessage(evt);\n            case Event.INFO:\n                handleInfo((Map<String,Object>)evt.getArg());\n                return null;\n            case Event.VIEW_CHANGE:\n                handleViewChange(((View)evt.getArg()).getMembers());\n                break;\n        }\n        return down_prot.down(evt); // this could potentially use the lower protocol's thread which may block\n    }","commit_id":"63178d534ddbda9632cb437c8f0e29eda9f716b3","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendCredit(Address dest, long credit) {\n        Number number;\n        if(credit < Integer.MAX_VALUE)\n            number=(int)credit;\n        else\n            number=credit;\n        Message msg=new Message(dest, null, number);\n        msg.setFlag(Message.OOB);\n        msg.putHeader(name, REPLENISH_HDR);\n        down_prot.down(new Event(Event.MSG, msg));\n        num_credit_responses_sent++;\n    }","id":30102,"modified_method":"private void sendCredit(Address dest, long credit) {\n        if(log.isTraceEnabled())\n            log.trace(\"replentished \" + dest + \" with \" + credit\n\t\t\t\t\t+ \" credits\");\n        Number number;\n        if(credit < Integer.MAX_VALUE)\n            number=(int)credit;\n        else\n            number=credit;\n        Message msg=new Message(dest, null, number);\n        msg.setFlag(Message.OOB);\n        msg.putHeader(name, REPLENISH_HDR);\n        down_prot.down(new Event(Event.MSG, msg));\n        num_credit_responses_sent++;\n    }","commit_id":"63178d534ddbda9632cb437c8f0e29eda9f716b3","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether sender has enough credits left. If not, send him some more\n     * @param map The hashmap to use\n     * @param lock The lock which can be used to lock map\n     * @param sender The address of the sender\n     * @param length The number of bytes received by this message. We don't care about the size of the headers for\n     * the purpose of flow control\n     * @return long Number of credits to be sent. Greater than 0 if credits needs to be sent, 0 otherwise\n     */\n    private long adjustCredit(Map<Address,Long> map, final Lock lock, Address sender, int length) {\n        if(sender == null) {\n            if(log.isErrorEnabled()) log.error(\"src is null\");\n            return 0;\n        }\n\n        if(length == 0)\n            return 0; // no effect\n\n        lock.lock();\n        try {\n            long remaining_cred=decrementCredit(map, sender, length);\n            if(remaining_cred == -1)\n                return 0;\n            long credit_response=max_credits - remaining_cred;\n            if(credit_response >= min_credits) {\n                map.put(sender, max_credits);\n                return credit_response; // this will trigger sending of new credits as we have received more than min_credits bytes from src\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        return 0;\n    }","id":30103,"modified_method":"/**\n     * Check whether sender has enough credits left. If not, send him some more\n     * @param map The hashmap to use\n     * @param lock The lock which can be used to lock map\n     * @param sender The address of the sender\n     * @param length The number of bytes received by this message. We don't care about the size of the headers for\n     * the purpose of flow control\n     * @return long Number of credits to be sent. Greater than 0 if credits needs to be sent, 0 otherwise\n     */\n    private long adjustCredit(Map<Address,Long> map, final Lock lock, Address sender, int length) {\n        if(sender == null) {\n            if(log.isErrorEnabled()) log.error(\"src is null\");\n            return 0;\n        }\n\n        if(length == 0)\n            return 0; // no effect\n\n        lock.lock();\n        try {\n            long remaining_cred=decrementCredit(map, sender, length);\n            if(log.isTraceEnabled())\n                log.trace(\"sender \" + sender + \" minus \" + length\n\t\t\t\t\t\t+ \" credits, \" + remaining_cred + \" remaining\");\n            if(remaining_cred == -1)\n                return 0;\n            long credit_response=max_credits - remaining_cred;\n            if(credit_response >= min_credits) {\n                map.put(sender, max_credits);\n                return credit_response; // this will trigger sending of new credits as we have received more than min_credits bytes from src\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        return 0;\n    }","commit_id":"63178d534ddbda9632cb437c8f0e29eda9f716b3","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(Vector mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n\n        sent_lock.lock();\n        received_lock.lock();\n        try {\n            // add members not in membership to received and sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address)mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, max_credits);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, max_credits);\n            }\n            // remove members that left\n            for(Iterator it=received.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n\n            // remove members that left\n            for(Iterator it=sent.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n            // remove all creditors which are not in the new view\n            for(Address creditor: creditors) {\n                if(!mbrs.contains(creditor))\n                    creditors.remove(creditor);\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are \" + creditors);\n            if(creditors.isEmpty()) {\n                lowest_credit=computeLowestCredit(sent);\n                credits_available.signalAll();\n            }\n        }\n        finally {\n            sent_lock.unlock();\n            received_lock.unlock();\n        }\n    }","id":30104,"modified_method":"private void handleViewChange(Vector<Address> mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n\n        sent_lock.lock();\n        received_lock.lock();\n        try {\n            // add members not in membership to received and sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, max_credits);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, max_credits);\n            }\n            // remove members that left\n            for(Iterator<Address> it=received.keySet().iterator(); it.hasNext();) {\n                addr=it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n\n            // remove members that left\n            for(Iterator<Address> it=sent.keySet().iterator(); it.hasNext();) {\n                addr=it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n            // remove all creditors which are not in the new view\n            for(Address creditor: creditors) {\n                if(!mbrs.contains(creditor))\n                    creditors.remove(creditor);\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are \" + creditors);\n            if(creditors.isEmpty()) {\n                lowest_credit=computeLowestCredit(sent);\n                credits_available.signalAll();\n            }\n        }\n        finally {\n            sent_lock.unlock();\n            received_lock.unlock();\n        }\n    }","commit_id":"63178d534ddbda9632cb437c8f0e29eda9f716b3","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Called by the GMS when a VIEW is received.\n     * @param new_view The view to be installed\n     * @param digest   If view is a MergeView, digest contains the seqno digest of all members and has to\n     *                 be set by GMS\n     */\n    public void handleViewChange(View new_view, Digest digest) {\n        Vector mbrs=new_view.getMembers();\n        if(log.isDebugEnabled()) {\n            if(digest != null)\n                log.debug(\"view=\" + new_view + \", digest=\" + digest);\n            else\n                log.debug(\"view=\" + new_view);\n        }\n\n        if(leaving && !mbrs.contains(gms.local_addr))\n            return;\n        gms.installView(new_view, digest);\n    }","id":30105,"modified_method":"/**\n     * Called by the GMS when a VIEW is received.\n     * @param new_view The view to be installed\n     * @param digest   If view is a MergeView, digest contains the seqno digest of all members and has to\n     *                 be set by GMS\n     */\n    public void handleViewChange(View new_view, Digest digest) {\n        Vector<Address> mbrs=new_view.getMembers();\n        if(log.isDebugEnabled()) {\n            if(digest != null)\n                log.debug(\"view=\" + new_view + \", digest=\" + digest);\n            else\n                log.debug(\"view=\" + new_view);\n        }\n\n        if(leaving && !mbrs.contains(gms.local_addr))\n            return;\n        gms.installView(new_view, digest);\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Merge all digests into one. For each sender, the new value is min(low_seqno), max(high_seqno),\n     * max(high_seqno_seen). This method has a lock on merge_rsps\n     */\n    private Digest consolidateDigests(Vector<MergeData> merge_rsps, int num_mbrs) {\n        MergeData data;\n        Digest tmp_digest;\n        MutableDigest retval=new MutableDigest(num_mbrs);\n\n        for(int i=0; i < merge_rsps.size(); i++) {\n            data=merge_rsps.elementAt(i);\n            tmp_digest=data.getDigest();\n            if(tmp_digest == null) {\n                if(log.isErrorEnabled()) log.error(\"tmp_digest == null; skipping\");\n                continue;\n            }\n            retval.merge(tmp_digest);\n        }\n        return retval.copy();\n    }","id":30106,"modified_method":"/**\n     * Merge all digests into one. For each sender, the new value is min(low_seqno), max(high_seqno),\n     * max(high_seqno_seen). This method has a lock on merge_rsps\n     */\n    private Digest consolidateDigests(Vector<MergeData> merge_rsps, int num_mbrs) {               \n        MutableDigest retval=new MutableDigest(num_mbrs);\n\n        for(MergeData data:merge_rsps) {            \n            Digest tmp_digest=data.getDigest();\n            if(tmp_digest == null) {\n                if(log.isErrorEnabled()) log.error(\"tmp_digest == null; skipping\");\n                continue;\n            }\n            retval.merge(tmp_digest);\n        }\n        return retval.copy();\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * Runs the merge protocol as a leader\n         */\n        public void run() {\n            if(merging == true) {\n                if(log.isWarnEnabled()) log.warn(\"merge is already in progress, terminating\");\n                return;\n            }\n\n            if(log.isDebugEnabled()) log.debug(\"merge task started, coordinators are \" + this.coords);\n            try {\n\n                /* 1. Generate a merge_id that uniquely identifies the merge in progress */\n                setMergeId(generateMergeId());\n\n                /* 2. Fetch the current Views/Digests from all subgroup coordinators */\n                getMergeDataFromSubgroupCoordinators(coords, gms.merge_timeout);\n\n                /* 3. Remove rejected MergeData elements from merge_rsp and coords (so we'll send the new view only\n                   to members who accepted the merge request) */\n                MergeData combined_merge_data=null;\n                boolean abort_merge=false;\n                synchronized(merge_rsps) {\n                    removeRejectedMergeRequests(coords);\n                    if(merge_rsps.size() <= 1) {\n                        if(log.isWarnEnabled())\n                            log.warn(\"merge responses from subgroup coordinators <= 1 (\" + merge_rsps + \"). Cancelling merge\");\n                        abort_merge=true;\n                    }\n                    else {\n                        /* 4. Combine all views and digests into 1 View/1 Digest */\n                        combined_merge_data=consolidateMergeData(merge_rsps);\n                        if(combined_merge_data == null) {\n                            if(log.isErrorEnabled()) log.error(\"combined_merge_data == null\");\n                            abort_merge=true;\n                        }\n                    }\n                }\n\n                if(abort_merge) {\n                    sendMergeCancelledMessage(coords, merge_id);\n                    return;\n                }\n\n                /* 5. Don't allow JOINs or LEAVEs until we are done with the merge. Suspend() will clear the\n                      view handler queue, so no requests beyond this current MERGE request will be processed */\n                gms.getViewHandler().suspend(merge_id);\n\n                /* 6. Send the new View/Digest to all coordinators (including myself). On reception, they will\n                   install the digest and view in all of their subgroup members */\n                sendMergeView(coords, combined_merge_data);\n            }\n            catch(Throwable ex) {                \n                if(log.isErrorEnabled()) log.error(\"exception while merging\", ex);\n                sendMergeCancelledMessage(coords, merge_id);\n            }\n            finally {               \n                stopMergeCanceller(); // this is probably not necessary\n                merging=false;\n                merge_leader=null;\n                if(log.isDebugEnabled()) log.debug(\"merge task terminated\");\n                t=null;\n            }\n        }","id":30107,"modified_method":"/**\n         * Runs the merge protocol as a leader\n         */\n        public void run() {\n            if(merging == true) {\n                if(log.isWarnEnabled()) log.warn(\"merge is already in progress, terminating\");\n                return;\n            }\n            \n            if(coords == null || coords.size() <= 1) {\n                if(log.isErrorEnabled()) log.error(\"coords == null or size <= 1\");\n                return;\n            }\n\n            if(log.isDebugEnabled()) log.debug(\"merge task started, coordinators are \" + this.coords);\n            try {\n\n                /* 1. Generate a merge_id that uniquely identifies the merge in progress */\n                setMergeId(generateMergeId());\n\n                /* 2. Fetch the current Views/Digests from all subgroup coordinators */\n                getMergeDataFromSubgroupCoordinators(coords, gms.merge_timeout);\n\n                /* 3. Remove rejected MergeData elements from merge_rsp and coords (so we'll send the new view only\n                   to members who accepted the merge request) */\n                MergeData combined_merge_data=null;\n                boolean abort_merge=false;\n                synchronized(merge_rsps) {\n                    removeRejectedMergeRequests(coords);\n                    if(merge_rsps.size() <= 1) {\n                        if(log.isWarnEnabled())\n                            log.warn(\"merge responses from subgroup coordinators <= 1 (\" + merge_rsps + \"). Cancelling merge\");\n                        abort_merge=true;\n                    }\n                    else {\n                        /* 4. Combine all views and digests into 1 View/1 Digest */\n                        combined_merge_data=consolidateMergeData(merge_rsps);\n                        if(combined_merge_data == null) {\n                            if(log.isErrorEnabled()) log.error(\"combined_merge_data == null\");\n                            abort_merge=true;\n                        }\n                    }\n                }\n\n                if(abort_merge) {\n                    sendMergeCancelledMessage(coords, merge_id);\n                    return;\n                }\n\n                /* 5. Don't allow JOINs or LEAVEs until we are done with the merge. Suspend() will clear the\n                      view handler queue, so no requests beyond this current MERGE request will be processed */\n                gms.getViewHandler().suspend(merge_id);\n\n                /* 6. Send the new View/Digest to all coordinators (including myself). On reception, they will\n                   install the digest and view in all of their subgroup members */\n                sendMergeView(coords, combined_merge_data);\n            }\n            catch(Throwable ex) {                \n                if(log.isErrorEnabled()) log.error(\"exception while merging\", ex);\n                sendMergeCancelledMessage(coords, merge_id);\n            }\n            finally {               \n                stopMergeCanceller(); // this is probably not necessary\n                merging=false;\n                merge_leader=null;\n                if(log.isDebugEnabled()) log.debug(\"merge task terminated\");\n                t=null;\n            }\n        }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a MERGE_REQ to all coords and populates a list of MergeData (in merge_rsps). Returns after coords.size()\n     * response have been received, or timeout msecs have elapsed (whichever is first).<p>\n     * If a subgroup coordinator rejects the MERGE_REQ (e.g. because of participation in a different merge),\n     * <em>that member will be removed from coords !<\/em>\n     * @param coords A list of Addresses of subgroup coordinators (inluding myself)\n     * @param timeout Max number of msecs to wait for the merge responses from the subgroup coords\n     */\n    private void getMergeDataFromSubgroupCoordinators(Vector coords, long timeout) {\n        Message msg;\n        GMS.GmsHeader hdr;\n\n        long curr_time, time_to_wait, end_time, start, stop;\n        int num_rsps_expected;\n\n        if(coords == null || coords.size() <= 1) {\n            if(log.isErrorEnabled()) log.error(\"coords == null or size <= 1\");\n            return;\n        }\n\n        start=System.currentTimeMillis();\n        MergeData tmp;\n        synchronized(merge_rsps) {\n            merge_rsps.removeAllElements();\n            if(log.isDebugEnabled()) log.debug(\"sending MERGE_REQ to \" + coords);\n            Address coord;\n            for(int i=0; i < coords.size(); i++) {\n                coord=(Address)coords.elementAt(i);\n                \n                // this allows UNICAST to remove coord from previous_members in case of a merge\n                gms.getDownProtocol().down(new Event(Event.ENABLE_UNICASTS_TO, coord));\n\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_REQ);\n                hdr.mbr=gms.local_addr;\n                hdr.merge_id=merge_id;\n                msg.putHeader(gms.getName(), hdr);\n                gms.getDownProtocol().down(new Event(Event.MSG, msg));\n            }\n\n            // wait until num_rsps_expected >= num_rsps or timeout elapsed\n            num_rsps_expected=coords.size();\n            curr_time=System.currentTimeMillis();\n            end_time=curr_time + timeout;\n            while(end_time > curr_time) {\n                time_to_wait=end_time - curr_time;\n                if(log.isDebugEnabled()) log.debug(\"waiting \" + time_to_wait + \" msecs for merge responses\");\n                if(merge_rsps.size() < num_rsps_expected) {\n                    try {\n                        merge_rsps.wait(time_to_wait);\n                    }\n                    catch(Exception ex) {\n                    }\n                }\n                if(log.isDebugEnabled())\n                    log.debug(\"num_rsps_expected=\" + num_rsps_expected + \", actual responses=\" + merge_rsps.size());\n\n                if(merge_rsps.size() >= num_rsps_expected)\n                    break;\n                curr_time=System.currentTimeMillis();\n            }\n            stop=System.currentTimeMillis();\n            if(log.isTraceEnabled())\n                log.trace(\"collected \" + merge_rsps.size() + \" merge response(s) in \" + (stop-start) + \"ms\");\n        }\n    }","id":30108,"modified_method":"/**\n     * Sends a MERGE_REQ to all coords and populates a list of MergeData (in merge_rsps). Returns after coords.size()\n     * response have been received, or timeout msecs have elapsed (whichever is first).<p>\n     * If a subgroup coordinator rejects the MERGE_REQ (e.g. because of participation in a different merge),\n     * <em>that member will be removed from coords !<\/em>\n     * @param coords A list of Addresses of subgroup coordinators (inluding myself)\n     * @param timeout Max number of msecs to wait for the merge responses from the subgroup coords\n     */\n    private void getMergeDataFromSubgroupCoordinators(Vector<Address> coords, long timeout) {\n        Message msg;\n        GMS.GmsHeader hdr;\n\n        long curr_time, time_to_wait, end_time, start, stop;\n        int num_rsps_expected;        \n\n        start=System.currentTimeMillis();        \n        synchronized(merge_rsps) {\n            merge_rsps.removeAllElements();\n            if(log.isDebugEnabled()) log.debug(\"sending MERGE_REQ to \" + coords);            \n            for(Address coord:coords) {               \n                // this allows UNICAST to remove coord from previous_members in case of a merge\n                gms.getDownProtocol().down(new Event(Event.ENABLE_UNICASTS_TO, coord));\n\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_REQ);\n                hdr.mbr=gms.local_addr;\n                hdr.merge_id=merge_id;\n                msg.putHeader(gms.getName(), hdr);\n                gms.getDownProtocol().down(new Event(Event.MSG, msg));\n            }\n\n            // wait until num_rsps_expected >= num_rsps or timeout elapsed\n            num_rsps_expected=coords.size();\n            curr_time=System.currentTimeMillis();\n            end_time=curr_time + timeout;\n            while(end_time > curr_time) {\n                time_to_wait=end_time - curr_time;\n                if(log.isDebugEnabled()) log.debug(\"waiting \" + time_to_wait + \" msecs for merge responses\");\n                if(merge_rsps.size() < num_rsps_expected) {\n                    try {\n                        merge_rsps.wait(time_to_wait);\n                    }\n                    catch(Exception ex) {\n                    }\n                }\n                if(log.isDebugEnabled())\n                    log.debug(\"num_rsps_expected=\" + num_rsps_expected + \", actual responses=\" + merge_rsps.size());\n\n                if(merge_rsps.size() >= num_rsps_expected)\n                    break;\n                curr_time=System.currentTimeMillis();\n            }\n            stop=System.currentTimeMillis();\n            if(log.isTraceEnabled())\n                log.trace(\"collected \" + merge_rsps.size() + \" merge response(s) in \" + (stop-start) + \"ms\");\n        }\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Merge all MergeData. All MergeData elements should be disjunct (both views and digests). However,\n     * this method is prepared to resolve duplicate entries (for the same member). Resolution strategy for\n     * views is to merge only 1 of the duplicate members. Resolution strategy for digests is to take the higher\n     * seqnos for duplicate digests.<p>\n     * After merging all members into a Membership and subsequent sorting, the first member of the sorted membership\n     * will be the new coordinator. This method has a lock on merge_rsps.\n     * @param merge_rsps A list of MergeData items. Elements with merge_rejected=true were removed before. Is guaranteed\n     *          not to be null and to contain at least 1 member.\n     */\n    private MergeData consolidateMergeData(Vector<MergeData> merge_rsps) {\n        MergeData ret;\n        MergeData tmp_data;\n        long logical_time=0; // for new_vid\n        ViewId new_vid, tmp_vid;\n        MergeView new_view;\n        View tmp_view;\n        Membership new_mbrs=new Membership();\n        int num_mbrs;\n        Address new_coord;\n        Vector<View> subgroups=new Vector<View>(11);\n        // contains a list of Views, each View is a subgroup\n\n        for(int i=0; i < merge_rsps.size(); i++) {\n            tmp_data=merge_rsps.elementAt(i);\n            if(log.isDebugEnabled()) log.debug(\"merge data is \" + tmp_data);\n            tmp_view=tmp_data.getView();\n            if(tmp_view != null) {\n                tmp_vid=tmp_view.getVid();\n                if(tmp_vid != null) {\n                    // compute the new view id (max of all vids +1)\n                    logical_time=Math.max(logical_time, tmp_vid.getId());\n                }\n                // merge all membership lists into one (prevent duplicates)\n                new_mbrs.add(tmp_view.getMembers());\n                subgroups.addElement((View)tmp_view.clone());\n            }\n        }\n\n        // the new coordinator is the first member of the consolidated & sorted membership list\n        new_mbrs.sort();\n        num_mbrs=new_mbrs.size();\n        new_coord=num_mbrs > 0? (Address)new_mbrs.elementAt(0) : null;\n        if(new_coord == null) {\n            if(log.isErrorEnabled()) log.error(\"new_coord == null\");\n            return null;\n        }\n        // should be the highest view ID seen up to now plus 1\n        new_vid=new ViewId(new_coord, logical_time + 1);\n\n        // determine the new view\n        new_view=new MergeView(new_vid, new_mbrs.getMembers(), subgroups);\n        if(log.isDebugEnabled()) log.debug(\"new merged view will be \" + new_view);\n\n        // determine the new digest\n        Digest new_digest=consolidateDigests(merge_rsps, num_mbrs);\n        if(new_digest == null) {\n            if(log.isErrorEnabled()) log.error(\"digest could not be consolidated\");\n            return null;\n        }\n        if(log.isDebugEnabled()) log.debug(\"consolidated digest=\" + new_digest);\n        ret=new MergeData(gms.local_addr, new_view, new_digest);\n        return ret;\n    }","id":30109,"modified_method":"/**\n     * Merge all MergeData. All MergeData elements should be disjunct (both views and digests). However,\n     * this method is prepared to resolve duplicate entries (for the same member). Resolution strategy for\n     * views is to merge only 1 of the duplicate members. Resolution strategy for digests is to take the higher\n     * seqnos for duplicate digests.<p>\n     * After merging all members into a Membership and subsequent sorting, the first member of the sorted membership\n     * will be the new coordinator. This method has a lock on merge_rsps.\n     * @param merge_rsps A list of MergeData items. Elements with merge_rejected=true were removed before. Is guaranteed\n     *          not to be null and to contain at least 1 member.\n     */\n    private MergeData consolidateMergeData(Vector<MergeData> merge_rsps) {\n        MergeData ret;       \n        long logical_time=0; // for new_vid\n        ViewId new_vid, tmp_vid;\n        MergeView new_view;\n        View tmp_view;\n        Membership new_mbrs=new Membership();       \n        Address new_coord;\n        Vector<View> subgroups=new Vector<View>(11);\n        // contains a list of Views, each View is a subgroup\n\n        for(MergeData tmp_data:merge_rsps) {           \n            if(log.isDebugEnabled()) log.debug(\"merge data is \" + tmp_data);\n            tmp_view=tmp_data.getView();\n            if(tmp_view != null) {\n                tmp_vid=tmp_view.getVid();\n                if(tmp_vid != null) {\n                    // compute the new view id (max of all vids +1)\n                    logical_time=Math.max(logical_time, tmp_vid.getId());\n                }\n                // merge all membership lists into one (prevent duplicates)\n                new_mbrs.add(tmp_view.getMembers());\n                subgroups.addElement((View)tmp_view.clone());\n            }\n        }\n\n        // the new coordinator is the first member of the consolidated & sorted membership list\n        new_mbrs.sort();       \n        new_coord = new_mbrs.size() > 0 ? new_mbrs.elementAt(0) : null;\n        if(new_coord == null) {\n            if(log.isErrorEnabled()) log.error(\"new_coord == null\");\n            return null;\n        }\n        // should be the highest view ID seen up to now plus 1\n        new_vid=new ViewId(new_coord, logical_time + 1);\n\n        // determine the new view\n        new_view=new MergeView(new_vid, new_mbrs.getMembers(), subgroups);\n        if(log.isDebugEnabled()) log.debug(\"new merged view will be \" + new_view);\n\n        // determine the new digest\n        Digest new_digest=consolidateDigests(merge_rsps, new_mbrs.size());\n        if(new_digest == null) {\n            if(log.isErrorEnabled()) log.error(\"digest could not be consolidated\");\n            return null;\n        }\n        if(log.isDebugEnabled()) log.debug(\"consolidated digest=\" + new_digest);\n        ret=new MergeData(gms.local_addr, new_view, new_digest);\n        return ret;\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendMergeCancelledMessage(Vector coords, ViewId merge_id) {\n        Message msg;\n        GMS.GmsHeader hdr;\n        Address coord;\n\n        if(coords == null || merge_id == null) {\n            if(log.isErrorEnabled()) log.error(\"coords or merge_id == null\");\n            return;\n        }\n        for(int i=0; i < coords.size(); i++) {\n            coord=(Address)coords.elementAt(i);\n            msg=new Message(coord, null, null);\n            // msg.setFlag(Message.OOB);\n            hdr=new GMS.GmsHeader(GMS.GmsHeader.CANCEL_MERGE);\n            hdr.merge_id=merge_id;\n            msg.putHeader(gms.getName(), hdr);\n            gms.getDownProtocol().down(new Event(Event.MSG, msg));\n        }\n    }","id":30110,"modified_method":"public void start(Vector<Address> groupCoord) {\n            this.coords = groupCoord != null ? new Vector<Address>(groupCoord) : null;\n            if(!isRunning()) {              \n                t=gms.getProtocolStack().getThreadFactory().newThread(this, \"MergeTask\");               \n                t.setDaemon(true);\n                t.start();\n            }\n        }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Removed rejected merge requests from merge_rsps and coords. This method has a lock on merge_rsps */\n    private void removeRejectedMergeRequests(Vector coords) {\n        MergeData data;\n        for(Iterator it=merge_rsps.iterator(); it.hasNext();) {\n            data=(MergeData)it.next();\n            if(data.merge_rejected) {\n                if(data.getSender() != null && coords != null)\n                    coords.removeElement(data.getSender());\n                it.remove();\n                if(log.isDebugEnabled()) log.debug(\"removed element \" + data);\n            }\n        }\n    }","id":30111,"modified_method":"/** Removed rejected merge requests from merge_rsps and coords. This method has a lock on merge_rsps */\n    private void removeRejectedMergeRequests(Vector<Address> coords) {        \n        for(Iterator<MergeData> it=merge_rsps.iterator(); it.hasNext();) {\n            MergeData data=it.next();\n            if(data.merge_rejected) {\n                if(data.getSender() != null && coords != null)\n                    coords.removeElement(data.getSender());\n                it.remove();\n                if(log.isDebugEnabled()) log.debug(\"removed element \" + data);\n            }\n        }\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends the new view and digest to all subgroup coordinors in coords. Each coord will in turn\n     * <ol>\n     * <li>cast the new view and digest to all the members of its subgroup (MergeView)\n     * <li>on reception of the view, if it is a MergeView, each member will set the digest and install\n     *     the new view\n     * <\/ol>\n     */\n    private void sendMergeView(Vector coords, MergeData combined_merge_data) {\n        Message msg;\n        GMS.GmsHeader hdr;\n        Address coord;\n        View v;\n        Digest d;\n\n        if(coords == null || combined_merge_data == null)\n            return;\n\n        v=combined_merge_data.view;\n        d=combined_merge_data.digest;\n        if(v == null || d == null) {\n            if(log.isErrorEnabled()) log.error(\"view or digest is null, cannot send consolidated merge view/digest\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"sending merge view \" + v.getVid() + \" to coordinators \" + coords);\n\n        for(int i=0; i < coords.size(); i++) {\n            coord=(Address)coords.elementAt(i);\n            msg=new Message(coord, null, null);\n            hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW);\n            hdr.view=v;\n            hdr.my_digest=d;\n            hdr.merge_id=merge_id;\n            msg.putHeader(gms.getName(), hdr);\n            gms.getDownProtocol().down(new Event(Event.MSG, msg));\n        }\n    }","id":30112,"modified_method":"/**\n     * Sends the new view and digest to all subgroup coordinors in coords. Each coord will in turn\n     * <ol>\n     * <li>cast the new view and digest to all the members of its subgroup (MergeView)\n     * <li>on reception of the view, if it is a MergeView, each member will set the digest and install\n     *     the new view\n     * <\/ol>\n     */\n    private void sendMergeView(Vector<Address> coords, MergeData combined_merge_data) {                      \n        View v;\n        Digest d;\n\n        if(coords == null || combined_merge_data == null)\n            return;\n\n        v=combined_merge_data.view;\n        d=combined_merge_data.digest;\n        if(v == null || d == null) {\n            if(log.isErrorEnabled()) log.error(\"view or digest is null, cannot send consolidated merge view/digest\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"sending merge view \" + v.getVid() + \" to coordinators \" + coords);\n\n        for(Address coord:coords) {            \n            Message msg=new Message(coord, null, null);\n            GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW);\n            hdr.view=v;\n            hdr.my_digest=d;\n            hdr.merge_id=merge_id;\n            msg.putHeader(gms.getName(), hdr);\n            gms.getDownProtocol().down(new Event(Event.MSG, msg));\n        }\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the component at the specified index\n     *\n     * @param index - 0..size()-1\n     * @throws ArrayIndexOutOfBoundsException - if the index is negative or not less than the current size of this Membership object.\n     * @see java.util.Vector#elementAt\n     */\n\n    public Object elementAt(int index) {\n        synchronized(members) {\n            return members.get(index);\n        }\n    }","id":30113,"modified_method":"/**\n     * Returns the component at the specified index\n     *\n     * @param index - 0..size()-1\n     * @throws ArrayIndexOutOfBoundsException - if the index is negative or not less than the current size of this Membership object.\n     * @see java.util.Vector#elementAt\n     */\n\n    public Address elementAt(int index) {\n        synchronized(members) {\n            return members.get(index);\n        }\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a list of members to this membership\n     *\n     * @param v - a vector containing Address objects\n     * @throws ClassCastException if v contains objects that don't implement the Address interface\n     * @see #add\n     */\n    public final void add(Collection v) {\n        if(v != null) {\n            for(Iterator it=v.iterator(); it.hasNext();) {\n                Address addr=(Address)it.next();\n                add(addr);\n            }\n        }\n    }","id":30114,"modified_method":"/**\n     * Adds a list of members to this membership\n     *\n     * @param v - a vector containing Address objects\n     * @throws ClassCastException if v contains objects that don't implement the Address interface\n     * @see #add\n     */\n    public final void add(Collection<Address> v) {\n        if(v != null) {\n            for(Iterator<Address> it=v.iterator(); it.hasNext();) {\n                Address addr=it.next();\n                add(addr);\n            }\n        }\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * merges membership with the new members and removes suspects\n     * The Merge method will remove all the suspects and add in the new members.\n     * It will do it in the order\n     * 1. Remove suspects\n     * 2. Add new members\n     * the order is very important to notice.\n     *\n     * @param new_mems - a vector containing a list of members (Address) to be added to this membership\n     * @param suspects - a vector containing a list of members (Address) to be removed from this membership\n     */\n    public void merge(Collection new_mems, Collection suspects) {\n        remove(suspects);\n        add(new_mems);\n    }","id":30115,"modified_method":"/**\n     * merges membership with the new members and removes suspects\n     * The Merge method will remove all the suspects and add in the new members.\n     * It will do it in the order\n     * 1. Remove suspects\n     * 2. Add new members\n     * the order is very important to notice.\n     *\n     * @param new_mems - a vector containing a list of members (Address) to be added to this membership\n     * @param suspects - a vector containing a list of members (Address) to be removed from this membership\n     */\n    public void merge(Collection<Address> new_mems, Collection<Address> suspects) {\n        remove(suspects);\n        add(new_mems);\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Clear the membership and adds all members of v\n     * This method will clear out all the old members of this membership by\n     * invoking the <code>Clear<\/code> method.\n     * Then it will add all the all members provided in the vector v\n     *\n     * @param v - a vector containing all the members this membership will contain\n     */\n    public void set(Collection v) {\n        clear();\n        if(v != null) {\n            add(v);\n        }\n    }","id":30116,"modified_method":"/**\n     * Clear the membership and adds all members of v\n     * This method will clear out all the old members of this membership by\n     * invoking the <code>Clear<\/code> method.\n     * Then it will add all the all members provided in the vector v\n     *\n     * @param v - a vector containing all the members this membership will contain\n     */\n    public void set(Collection<Address> v) {\n        clear();\n        if(v != null) {\n            add(v);\n        }\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Creates a member ship object with the initial members.\n     * The Address references are copied out of the vector, so that the\n     * vector passed in as parameters is not the same reference as the vector\n     * that the membership class is using\n     *\n     * @param initial_members - a list of members that belong to this membership\n     */\n    public Membership(Collection initial_members) {\n        if(initial_members != null)\n            add(initial_members);\n    }","id":30117,"modified_method":"/**\n     * Creates a member ship object with the initial members.\n     * The Address references are copied out of the vector, so that the\n     * vector passed in as parameters is not the same reference as the vector\n     * that the membership class is using\n     *\n     * @param initial_members - a list of members that belong to this membership\n     */\n    public Membership(Collection<Address> initial_members) {\n        if(initial_members != null)\n            add(initial_members);\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * removes all the members contained in v from this membership\n     *\n     * @param v - a vector containing all the members to be removed\n     */\n    public void remove(Collection v) {\n        if(v != null) {\n            synchronized(members) {\n                members.removeAll(v);\n            }\n        }\n    }","id":30118,"modified_method":"/**\n     * removes all the members contained in v from this membership\n     *\n     * @param v - a vector containing all the members to be removed\n     */\n    public void remove(Collection<Address> v) {\n        if(v != null) {\n            synchronized(members) {\n                members.removeAll(v);\n            }\n        }\n    }","commit_id":"a24172a6851079e272255366980a871cebbeb34b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether sender has enough credits left. If not, send him some more\n     * @param map The hashmap to use\n     * @param lock The lock which can be used to lock map\n     * @param sender The address of the sender\n     * @param length The number of bytes received by this message. We don't care about the size of the headers for\n     * the purpose of flow control\n     * @return long Number of credits to be sent. Greater than 0 if credits needs to be sent, 0 otherwise\n     */\n    private long adjustCredit(Map<Address,Long> map, final Lock lock, Address sender, int length) {\n        if(sender == null) {\n            if(log.isErrorEnabled()) log.error(\"src is null\");\n            return 0;\n        }\n\n        if(length == 0)\n            return 0; // no effect\n\n        lock.lock();\n        try {\n            long remaining_cred=decrementCredit(map, sender, length);\n            if(remaining_cred == -1)\n                return 0;\n            long credit_response=max_credits - remaining_cred;\n            if(credit_response >= min_credits) {\n                map.put(sender, max_credits);\n                return credit_response; // this will trigger sending of new credits as we have received more than min_credits bytes from src\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        return 0;\n    }","id":30119,"modified_method":"/**\n     * Check whether sender has enough credits left. If not, send him some more\n     * @param map The hashmap to use\n     * @param lock The lock which can be used to lock map\n     * @param sender The address of the sender\n     * @param length The number of bytes received by this message. We don't care about the size of the headers for\n     * the purpose of flow control\n     * @return long Number of credits to be sent. Greater than 0 if credits needs to be sent, 0 otherwise\n     */\n    private long adjustCredit(Map<Address,Long> map, final Lock lock, Address sender, int length) {\n        if(sender == null) {\n            if(log.isErrorEnabled()) log.error(\"src is null\");\n            return 0;\n        }\n\n        if(length == 0)\n            return 0; // no effect\n\n        lock.lock();\n        try {\n            long remaining_cred=decrementCredit(map, sender, length);\n            if(log.isTraceEnabled())\n                log.trace(\"sender \" + sender + \" minus \" + length\n\t\t\t\t\t\t+ \" credits, \" + remaining_cred + \" remaining\");\n            if(remaining_cred == -1)\n                return 0;\n            long credit_response=max_credits - remaining_cred;\n            if(credit_response >= min_credits) {\n                map.put(sender, max_credits);\n                return credit_response; // this will trigger sending of new credits as we have received more than min_credits bytes from src\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n        return 0;\n    }","commit_id":"70ad05a9fb41c2ed424a7602356dac2494738c1b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendCredit(Address dest, long credit) {\n        Number number;\n        if(credit < Integer.MAX_VALUE)\n            number=(int)credit;\n        else\n            number=credit;\n        Message msg=new Message(dest, null, number);\n        msg.setFlag(Message.OOB);\n        msg.putHeader(name, REPLENISH_HDR);\n        down_prot.down(new Event(Event.MSG, msg));\n        num_credit_responses_sent++;\n    }","id":30120,"modified_method":"private void sendCredit(Address dest, long credit) {\n        if(log.isTraceEnabled())\n            log.trace(\"replentished \" + dest + \" with \" + credit\n\t\t\t\t\t+ \" credits\");\n        Number number;\n        if(credit < Integer.MAX_VALUE)\n            number=(int)credit;\n        else\n            number=credit;\n        Message msg=new Message(dest, null, number);\n        msg.setFlag(Message.OOB);\n        msg.putHeader(name, REPLENISH_HDR);\n        down_prot.down(new Event(Event.MSG, msg));\n        num_credit_responses_sent++;\n    }","commit_id":"70ad05a9fb41c2ed424a7602356dac2494738c1b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast\n     * or unicast message. No need to acquire mutex (must already be held when this method is called)\n     * @param dest\n     * @param credits\n     * @return The lowest number of credits left, or -1 if a unicast member was not found\n     */\n    private long decrementCredit(Map<Address, Long> m, Address dest, long credits) {\n        boolean multicast=dest == null || dest.isMulticastAddress();\n        long lowest=max_credits, new_credit;\n        Long val;\n\n        if(multicast) {\n            if(m.isEmpty())\n                return -1;\n            for(Map.Entry<Address, Long> entry: m.entrySet()) {\n                val=entry.getValue();\n                new_credit=val - credits;\n                entry.setValue(new_credit);\n                lowest=Math.min(new_credit, lowest);\n            }\n            return lowest;\n        }\n        else {\n            val=m.get(dest);\n            if(val != null) {\n                lowest=val;\n                lowest-=credits;\n                m.put(dest, lowest);\n                return lowest;\n            }\n        }\n        return -1;\n    }","id":30121,"modified_method":"/**\n     * Decrements credits from a single member, or all members in sent_msgs, depending on whether it is a multicast\n     * or unicast message. No need to acquire mutex (must already be held when this method is called)\n     * @param dest\n     * @param credits\n     * @return The lowest number of credits left, or -1 if a unicast member was not found\n     */\n    private long decrementCredit(Map<Address, Long> m, Address dest, long credits) {\n        boolean multicast=dest == null || dest.isMulticastAddress();\n        long lowest=max_credits, new_credit;\n        Long val;\n\n        if(multicast) {\n            if(m.isEmpty())\n                return -1;\n            for(Map.Entry<Address, Long> entry: m.entrySet()) {\n                val=entry.getValue();\n                new_credit=val - credits;\n                entry.setValue(new_credit);\n                lowest=Math.min(new_credit, lowest);\n            }\n            return lowest;\n        }\n        else {\n            val=m.get(dest);\n            if(val != null) {\n                lowest=val;\n                lowest-=credits;\n                m.put(dest, lowest);\n                if(log.isTraceEnabled())\n                \tlog.trace(\"sender \" + dest + \" minus \" + credits\n\t\t\t\t\t\t\t+ \" credits, \" + lowest + \" remaining\");\n                return lowest;\n            }\n        }\n        return -1;\n    }","commit_id":"70ad05a9fb41c2ed424a7602356dac2494738c1b","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                return handleDownMessage(evt);\n            case Event.INFO:\n                handleInfo((Map<String,Object>)evt.getArg());\n                return null;\n        }\n        return down_prot.down(evt); // this could potentially use the lower protocol's thread which may block\n    }","id":30122,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n            case Event.MSG:\n                return handleDownMessage(evt);\n            case Event.INFO:\n                handleInfo((Map<String,Object>)evt.getArg());\n                return null;\n            case Event.VIEW_CHANGE:\n                handleViewChange(((View)evt.getArg()).getMembers());\n                break;\n        }\n        return down_prot.down(evt); // this could potentially use the lower protocol's thread which may block\n    }","commit_id":"70ad05a9fb41c2ed424a7602356dac2494738c1b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(Vector mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n\n        sent_lock.lock();\n        received_lock.lock();\n        try {\n            // add members not in membership to received and sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=(Address)mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, max_credits);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, max_credits);\n            }\n            // remove members that left\n            for(Iterator it=received.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n\n            // remove members that left\n            for(Iterator it=sent.keySet().iterator(); it.hasNext();) {\n                addr=(Address)it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n            // remove all creditors which are not in the new view\n            for(Address creditor: creditors) {\n                if(!mbrs.contains(creditor))\n                    creditors.remove(creditor);\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are \" + creditors);\n            if(creditors.isEmpty()) {\n                lowest_credit=computeLowestCredit(sent);\n                credits_available.signalAll();\n            }\n        }\n        finally {\n            sent_lock.unlock();\n            received_lock.unlock();\n        }\n    }","id":30123,"modified_method":"private void handleViewChange(Vector<Address> mbrs) {\n        Address addr;\n        if(mbrs == null) return;\n        if(log.isTraceEnabled()) log.trace(\"new membership: \" + mbrs);\n\n        sent_lock.lock();\n        received_lock.lock();\n        try {\n            // add members not in membership to received and sent hashmap (with full credits)\n            for(int i=0; i < mbrs.size(); i++) {\n                addr=mbrs.elementAt(i);\n                if(!received.containsKey(addr))\n                    received.put(addr, max_credits);\n                if(!sent.containsKey(addr))\n                    sent.put(addr, max_credits);\n            }\n            // remove members that left\n            for(Iterator<Address> it=received.keySet().iterator(); it.hasNext();) {\n                addr=it.next();\n                if(!mbrs.contains(addr))\n                    it.remove();\n            }\n\n            // remove members that left\n            for(Iterator<Address> it=sent.keySet().iterator(); it.hasNext();) {\n                addr=it.next();\n                if(!mbrs.contains(addr))\n                    it.remove(); // modified the underlying map\n            }\n\n            // remove all creditors which are not in the new view\n            for(Address creditor: creditors) {\n                if(!mbrs.contains(creditor))\n                    creditors.remove(creditor);\n            }\n\n            if(log.isTraceEnabled()) log.trace(\"creditors are \" + creditors);\n            if(creditors.isEmpty()) {\n                lowest_credit=computeLowestCredit(sent);\n                credits_available.signalAll();\n            }\n        }\n        finally {\n            sent_lock.unlock();\n            received_lock.unlock();\n        }\n    }","commit_id":"70ad05a9fb41c2ed424a7602356dac2494738c1b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Compute the canonical name from a Class instance.  Note that a\n     * simple replacment of '$' with '.' of a binary name would not work,\n     * as '$' is a legal Java Identifier character.\n     * @param c A instance of java.lang.Class\n     * @return  The canonical name of c.\n     */\n    public static String getCanonicalName(Class c) {\n\n        String binaryName = c.getName();\n        c = c.getDeclaringClass();\n\n        if (c == null) {\n            return binaryName;\n        }\n\n        StringBuffer buf = new StringBuffer(binaryName);\n        do {\n            buf.setCharAt(c.getName().length(), '.');\n            c = c.getDeclaringClass();\n        } while ( c != null);\n\n        return buf.toString();\n    }","id":30124,"modified_method":"/**\n     * Compute the canonical name from a Class instance. Note that a simple\n     * replacment of '$' with '.' of a binary name would not work, as '$' is a\n     * legal Java Identifier character.\n     * \n     * @param c\n     *            A instance of java.lang.Class\n     * @return The canonical name of c.\n     */\n    public static String getCanonicalName(Class<?> c) {\n\n        String binaryName = c.getName();\n        c = c.getDeclaringClass();\n\n        if (c == null) {\n            return binaryName;\n        }\n\n        StringBuffer buf = new StringBuffer(binaryName);\n        do {\n            buf.setCharAt(c.getName().length(), '.');\n            c = c.getDeclaringClass();\n        } while (c != null);\n\n        return buf.toString();\n    }","commit_id":"ac7d79ca4f46f6050812360bef5b3a5cf5c9c7f6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Checks if the token is a runtime expression.\n     * In standard JSP syntax, a runtime expression starts with '<%' and\n     * ends with '%>'. When the JSP document is in XML syntax, a runtime\n     * expression starts with '%=' and ends with '%'.\n     *\n     * @param token The token to be checked\n     * return whether the token is a runtime expression or not.\n     */\n    public static boolean isExpression(String token, boolean isXml) {\n    String openExpr;\n    String closeExpr;\n    if (isXml) {\n        openExpr = OPEN_EXPR_XML;\n        closeExpr = CLOSE_EXPR_XML;\n    } else {\n        openExpr = OPEN_EXPR;\n        closeExpr = CLOSE_EXPR;\n    }\n    if (token.startsWith(openExpr) && token.endsWith(closeExpr)) {\n        return true;\n    } else {\n        return false;\n    }\n    }","id":30125,"modified_method":"/**\n     * Checks if the token is a runtime expression. In standard JSP syntax, a\n     * runtime expression starts with '<%' and ends with '%>'. When the JSP\n     * document is in XML syntax, a runtime expression starts with '%=' and ends\n     * with '%'.\n     * \n     * @param token The token to be checked\n     * @return whether the token is a runtime expression or not.\n     */\n    public static boolean isExpression(String token, boolean isXml) {\n        String openExpr;\n        String closeExpr;\n        if (isXml) {\n            openExpr = OPEN_EXPR_XML;\n            closeExpr = CLOSE_EXPR_XML;\n        } else {\n            openExpr = OPEN_EXPR;\n            closeExpr = CLOSE_EXPR;\n        }\n        if (token.startsWith(openExpr) && token.endsWith(closeExpr)) {\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"ac7d79ca4f46f6050812360bef5b3a5cf5c9c7f6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Returns the <tt>Class<\/tt> object associated with the class or\n     * interface with the given string name.\n     *\n     * <p> The <tt>Class<\/tt> object is determined by passing the given string\n     * name to the <tt>Class.forName()<\/tt> method, unless the given string\n     * name represents a primitive type, in which case it is converted to a\n     * <tt>Class<\/tt> object by appending \".class\" to it (e.g., \"int.class\").\n     */\n    public static Class toClass(String type, ClassLoader loader)\n        throws ClassNotFoundException {\n\n    Class c = null;\n    int i0 = type.indexOf('[');\n    int dims = 0;\n    if (i0 > 0) {\n        // This is an array.  Count the dimensions\n        for (int i = 0; i < type.length(); i++) {\n        if (type.charAt(i) == '[')\n            dims++;\n        }\n        type = type.substring(0, i0);\n    }\n\n    if (\"boolean\".equals(type))\n        c = boolean.class;\n    else if (\"char\".equals(type))\n        c = char.class;\n    else if (\"byte\".equals(type))\n        c =  byte.class;\n    else if (\"short\".equals(type))\n        c = short.class;\n    else if (\"int\".equals(type))\n        c = int.class;\n    else if (\"long\".equals(type))\n        c = long.class;\n    else if (\"float\".equals(type))\n        c = float.class;\n    else if (\"double\".equals(type))\n        c = double.class;\n    else if (type.indexOf('[') < 0)\n        c = loader.loadClass(type);\n\n    if (dims == 0)\n        return c;\n\n    if (dims == 1)\n        return java.lang.reflect.Array.newInstance(c, 1).getClass();\n\n    // Array of more than i dimension\n    return java.lang.reflect.Array.newInstance(c, new int[dims]).getClass();\n    }","id":30126,"modified_method":"/**\n     * Returns the <tt>Class<\/tt> object associated with the class or\n     * interface with the given string name.\n     * \n     * <p>\n     * The <tt>Class<\/tt> object is determined by passing the given string\n     * name to the <tt>Class.forName()<\/tt> method, unless the given string\n     * name represents a primitive type, in which case it is converted to a\n     * <tt>Class<\/tt> object by appending \".class\" to it (e.g., \"int.class\").\n     */\n    public static Class<?> toClass(String type, ClassLoader loader)\n            throws ClassNotFoundException {\n\n        Class<?> c = null;\n        int i0 = type.indexOf('[');\n        int dims = 0;\n        if (i0 > 0) {\n            // This is an array. Count the dimensions\n            for (int i = 0; i < type.length(); i++) {\n                if (type.charAt(i) == '[')\n                    dims++;\n            }\n            type = type.substring(0, i0);\n        }\n\n        if (\"boolean\".equals(type))\n            c = boolean.class;\n        else if (\"char\".equals(type))\n            c = char.class;\n        else if (\"byte\".equals(type))\n            c = byte.class;\n        else if (\"short\".equals(type))\n            c = short.class;\n        else if (\"int\".equals(type))\n            c = int.class;\n        else if (\"long\".equals(type))\n            c = long.class;\n        else if (\"float\".equals(type))\n            c = float.class;\n        else if (\"double\".equals(type))\n            c = double.class;\n        else if (type.indexOf('[') < 0)\n            c = loader.loadClass(type);\n\n        if (dims == 0)\n            return c;\n\n        if (dims == 1)\n            return java.lang.reflect.Array.newInstance(c, 1).getClass();\n\n        // Array of more than i dimension\n        return java.lang.reflect.Array.newInstance(c, new int[dims]).getClass();\n    }","commit_id":"ac7d79ca4f46f6050812360bef5b3a5cf5c9c7f6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Splits a string into it's components.\n     * @param path String to split\n     * @param pat Pattern to split at\n     * @return the components of the path\n     */\n    private static final String [] split(String path, String pat) {\n        Vector comps = new Vector();\n        int pos = path.indexOf(pat);\n        int start = 0;\n        while( pos >= 0 ) {\n            if(pos > start ) {\n                String comp = path.substring(start,pos);\n                comps.add(comp);\n            }\n            start = pos + pat.length();\n            pos = path.indexOf(pat,start);\n        }\n        if( start < path.length()) {\n            comps.add(path.substring(start));\n        }\n        String [] result = new String[comps.size()];\n        for(int i=0; i < comps.size(); i++) {\n            result[i] = (String)comps.elementAt(i);\n        }\n        return result;\n    }","id":30127,"modified_method":"/**\n     * Splits a string into it's components.\n     * \n     * @param path\n     *            String to split\n     * @param pat\n     *            Pattern to split at\n     * @return the components of the path\n     */\n    private static final String[] split(String path, String pat) {\n        Vector<String> comps = new Vector<String>();\n        int pos = path.indexOf(pat);\n        int start = 0;\n        while (pos >= 0) {\n            if (pos > start) {\n                String comp = path.substring(start, pos);\n                comps.add(comp);\n            }\n            start = pos + pat.length();\n            pos = path.indexOf(pat, start);\n        }\n        if (start < path.length()) {\n            comps.add(path.substring(start));\n        }\n        String[] result = new String[comps.size()];\n        for (int i = 0; i < comps.size(); i++) {\n            result[i] = comps.elementAt(i);\n        }\n        return result;\n    }","commit_id":"ac7d79ca4f46f6050812360bef5b3a5cf5c9c7f6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Produces a String representing a call to the EL interpreter.\n     * @param expression a String containing zero or more \"${}\" expressions\n     * @param expectedType the expected type of the interpreted result\n     * @param fnmapvar Variable pointing to a function map.\n     * @param XmlEscape True if the result should do XML escaping\n     * @return a String representing a call to the EL interpreter.\n     */\n    public static String interpreterCall(boolean isTagFile,\n                     String expression,\n                                         Class expectedType,\n                                         String fnmapvar,\n                                         boolean XmlEscape ) \n    {\n        /*\n         * Determine which context object to use.\n         */\n    String jspCtxt = null;\n    if (isTagFile)\n        jspCtxt = \"this.getJspContext()\";\n    else\n        jspCtxt = \"_jspx_page_context\";\n\n    /*\n         * Determine whether to use the expected type's textual name\n     * or, if it's a primitive, the name of its correspondent boxed\n     * type.\n         */\n    String targetType = expectedType.getName();\n    String primitiveConverterMethod = null;\n    if (expectedType.isPrimitive()) {\n        if (expectedType.equals(Boolean.TYPE)) {\n        targetType = Boolean.class.getName();\n        primitiveConverterMethod = \"booleanValue\";\n        } else if (expectedType.equals(Byte.TYPE)) {\n        targetType = Byte.class.getName();\n        primitiveConverterMethod = \"byteValue\";\n        } else if (expectedType.equals(Character.TYPE)) {\n        targetType = Character.class.getName();\n        primitiveConverterMethod = \"charValue\";\n        } else if (expectedType.equals(Short.TYPE)) {\n        targetType = Short.class.getName();\n        primitiveConverterMethod = \"shortValue\";\n        } else if (expectedType.equals(Integer.TYPE)) {\n        targetType = Integer.class.getName();\n        primitiveConverterMethod = \"intValue\";\n        } else if (expectedType.equals(Long.TYPE)) {\n        targetType = Long.class.getName();\n        primitiveConverterMethod = \"longValue\";\n        } else if (expectedType.equals(Float.TYPE)) {\n        targetType = Float.class.getName();\n        primitiveConverterMethod = \"floatValue\";\n        } else if (expectedType.equals(Double.TYPE)) { \n        targetType = Double.class.getName();\n        primitiveConverterMethod = \"doubleValue\";\n        }\n    }\n \n    if (primitiveConverterMethod != null) {\n        XmlEscape = false;\n    }\n\n    /*\n         * Build up the base call to the interpreter.\n         */\n        // XXX - We use a proprietary call to the interpreter for now\n        // as the current standard machinery is inefficient and requires\n        // lots of wrappers and adapters.  This should all clear up once\n        // the EL interpreter moves out of JSTL and into its own project.\n        // In the future, this should be replaced by code that calls\n        // ExpressionEvaluator.parseExpression() and then cache the resulting\n        // expression objects.  The interpreterCall would simply select\n        // one of the pre-cached expressions and evaluate it.\n        // Note that PageContextImpl implements VariableResolver and\n        // the generated Servlet/SimpleTag implements FunctionMapper, so\n        // that machinery is already in place (mroth).\n    targetType = toJavaSourceType(targetType);\n    StringBuffer call = new StringBuffer(\n             \"(\" + targetType + \") \"\n               + \"org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate\"\n               + \"(\" + Generator.quote(expression) + \", \"\n               +       targetType + \".class, \"\n           +       \"(PageContext)\" + jspCtxt \n               +       \", \" + fnmapvar\n           + \", \" + XmlEscape\n               + \")\");\n \n    /*\n         * Add the primitive converter method if we need to.\n         */\n    if (primitiveConverterMethod != null) {\n        call.insert(0, \"(\");\n        call.append(\").\" + primitiveConverterMethod + \"()\");\n    }\n \n    return call.toString();\n    }","id":30128,"modified_method":"/**\n     * Produces a String representing a call to the EL interpreter.\n     * \n     * @param expression\n     *            a String containing zero or more \"${}\" expressions\n     * @param expectedType\n     *            the expected type of the interpreted result\n     * @param fnmapvar\n     *            Variable pointing to a function map.\n     * @param XmlEscape\n     *            True if the result should do XML escaping\n     * @return a String representing a call to the EL interpreter.\n     */\n    public static String interpreterCall(boolean isTagFile, String expression,\n            Class<?> expectedType, String fnmapvar, boolean XmlEscape) {\n        /*\n         * Determine which context object to use.\n         */\n        String jspCtxt = null;\n        if (isTagFile)\n            jspCtxt = \"this.getJspContext()\";\n        else\n            jspCtxt = \"_jspx_page_context\";\n\n        /*\n         * Determine whether to use the expected type's textual name or, if it's\n         * a primitive, the name of its correspondent boxed type.\n         */\n        String targetType = expectedType.getName();\n        String primitiveConverterMethod = null;\n        if (expectedType.isPrimitive()) {\n            if (expectedType.equals(Boolean.TYPE)) {\n                targetType = Boolean.class.getName();\n                primitiveConverterMethod = \"booleanValue\";\n            } else if (expectedType.equals(Byte.TYPE)) {\n                targetType = Byte.class.getName();\n                primitiveConverterMethod = \"byteValue\";\n            } else if (expectedType.equals(Character.TYPE)) {\n                targetType = Character.class.getName();\n                primitiveConverterMethod = \"charValue\";\n            } else if (expectedType.equals(Short.TYPE)) {\n                targetType = Short.class.getName();\n                primitiveConverterMethod = \"shortValue\";\n            } else if (expectedType.equals(Integer.TYPE)) {\n                targetType = Integer.class.getName();\n                primitiveConverterMethod = \"intValue\";\n            } else if (expectedType.equals(Long.TYPE)) {\n                targetType = Long.class.getName();\n                primitiveConverterMethod = \"longValue\";\n            } else if (expectedType.equals(Float.TYPE)) {\n                targetType = Float.class.getName();\n                primitiveConverterMethod = \"floatValue\";\n            } else if (expectedType.equals(Double.TYPE)) {\n                targetType = Double.class.getName();\n                primitiveConverterMethod = \"doubleValue\";\n            }\n        }\n\n        if (primitiveConverterMethod != null) {\n            XmlEscape = false;\n        }\n\n        /*\n         * Build up the base call to the interpreter.\n         */\n        // XXX - We use a proprietary call to the interpreter for now\n        // as the current standard machinery is inefficient and requires\n        // lots of wrappers and adapters. This should all clear up once\n        // the EL interpreter moves out of JSTL and into its own project.\n        // In the future, this should be replaced by code that calls\n        // ExpressionEvaluator.parseExpression() and then cache the resulting\n        // expression objects. The interpreterCall would simply select\n        // one of the pre-cached expressions and evaluate it.\n        // Note that PageContextImpl implements VariableResolver and\n        // the generated Servlet/SimpleTag implements FunctionMapper, so\n        // that machinery is already in place (mroth).\n        targetType = toJavaSourceType(targetType);\n        StringBuffer call = new StringBuffer(\n                \"(\"\n                        + targetType\n                        + \") \"\n                        + \"org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate\"\n                        + \"(\" + Generator.quote(expression) + \", \" + targetType\n                        + \".class, \" + \"(PageContext)\" + jspCtxt + \", \"\n                        + fnmapvar + \", \" + XmlEscape + \")\");\n\n        /*\n         * Add the primitive converter method if we need to.\n         */\n        if (primitiveConverterMethod != null) {\n            call.insert(0, \"(\");\n            call.append(\").\" + primitiveConverterMethod + \"()\");\n        }\n\n        return call.toString();\n    }","commit_id":"ac7d79ca4f46f6050812360bef5b3a5cf5c9c7f6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Checks if all mandatory attributes are present and if all attributes\n     * present have valid names.  Checks attributes specified as XML-style\n     * attributes as well as attributes specified using the jsp:attribute\n     * standard action. \n     */\n    public static void checkAttributes(String typeOfTag,\n                       Node n,\n                       ValidAttribute[] validAttributes,\n                       ErrorDispatcher err)\n                throws JasperException {\n        Attributes attrs = n.getAttributes();\n        Mark start = n.getStart();\n    boolean valid = true;\n\n        // AttributesImpl.removeAttribute is broken, so we do this...\n        int tempLength = (attrs == null) ? 0 : attrs.getLength();\n    Vector temp = new Vector(tempLength, 1);\n        for (int i = 0; i < tempLength; i++) {\n            String qName = attrs.getQName(i);\n            if ((!qName.equals(\"xmlns\")) && (!qName.startsWith(\"xmlns:\")))\n                temp.addElement(qName);\n        }\n\n        // Add names of attributes specified using jsp:attribute\n        Node.Nodes tagBody = n.getBody();\n        if( tagBody != null ) {\n            int numSubElements = tagBody.size();\n            for( int i = 0; i < numSubElements; i++ ) {\n                Node node = tagBody.getNode( i );\n                if( node instanceof Node.NamedAttribute ) {\n                    String attrName = node.getAttributeValue( \"name\" );\n                    temp.addElement( attrName );\n            // Check if this value appear in the attribute of the node\n            if (n.getAttributeValue(attrName) != null) {\n            err.jspError(n, \"jsp.error.duplicate.name.jspattribute\",\n                    attrName);\n            }\n                }\n                else {\n                    // Nothing can come before jsp:attribute, and only\n                    // jsp:body can come after it.\n                    break;\n                }\n            }\n        }\n\n    /*\n     * First check to see if all the mandatory attributes are present.\n     * If so only then proceed to see if the other attributes are valid\n     * for the particular tag.\n     */\n    String missingAttribute = null;\n\n    for (int i = 0; i < validAttributes.length; i++) {\n        int attrPos;    \n        if (validAttributes[i].mandatory) {\n                attrPos = temp.indexOf(validAttributes[i].name);\n        if (attrPos != -1) {\n            temp.remove(attrPos);\n            valid = true;\n        } else {\n            valid = false;\n            missingAttribute = validAttributes[i].name;\n            break;\n        }\n        }\n    }\n\n    // If mandatory attribute is missing then the exception is thrown\n    if (!valid)\n        err.jspError(start, \"jsp.error.mandatory.attribute\", typeOfTag,\n             missingAttribute);\n\n    // Check to see if there are any more attributes for the specified tag.\n        int attrLeftLength = temp.size();\n    if (attrLeftLength == 0)\n        return;\n\n    // Now check to see if the rest of the attributes are valid too.\n    String attribute = null;\n\n    for (int j = 0; j < attrLeftLength; j++) {\n        valid = false;\n        attribute = (String) temp.elementAt(j);\n        for (int i = 0; i < validAttributes.length; i++) {\n        if (attribute.equals(validAttributes[i].name)) {\n            valid = true;\n            break;\n        }\n        }\n        if (!valid)\n        err.jspError(start, \"jsp.error.invalid.attribute\", typeOfTag,\n                 attribute);\n    }\n    // XXX *could* move EL-syntax validation here... (sb)\n    }","id":30129,"modified_method":"/**\n     * Checks if all mandatory attributes are present and if all attributes\n     * present have valid names. Checks attributes specified as XML-style\n     * attributes as well as attributes specified using the jsp:attribute\n     * standard action.\n     */\n    public static void checkAttributes(String typeOfTag, Node n,\n            ValidAttribute[] validAttributes, ErrorDispatcher err)\n            throws JasperException {\n        Attributes attrs = n.getAttributes();\n        Mark start = n.getStart();\n        boolean valid = true;\n\n        // AttributesImpl.removeAttribute is broken, so we do this...\n        int tempLength = (attrs == null) ? 0 : attrs.getLength();\n        Vector<String> temp = new Vector<String>(tempLength, 1);\n        for (int i = 0; i < tempLength; i++) {\n            String qName = attrs.getQName(i);\n            if ((!qName.equals(\"xmlns\")) && (!qName.startsWith(\"xmlns:\")))\n                temp.addElement(qName);\n        }\n\n        // Add names of attributes specified using jsp:attribute\n        Node.Nodes tagBody = n.getBody();\n        if (tagBody != null) {\n            int numSubElements = tagBody.size();\n            for (int i = 0; i < numSubElements; i++) {\n                Node node = tagBody.getNode(i);\n                if (node instanceof Node.NamedAttribute) {\n                    String attrName = node.getAttributeValue(\"name\");\n                    temp.addElement(attrName);\n                    // Check if this value appear in the attribute of the node\n                    if (n.getAttributeValue(attrName) != null) {\n                        err.jspError(n,\n                                \"jsp.error.duplicate.name.jspattribute\",\n                                attrName);\n                    }\n                } else {\n                    // Nothing can come before jsp:attribute, and only\n                    // jsp:body can come after it.\n                    break;\n                }\n            }\n        }\n\n        /*\n         * First check to see if all the mandatory attributes are present. If so\n         * only then proceed to see if the other attributes are valid for the\n         * particular tag.\n         */\n        String missingAttribute = null;\n\n        for (int i = 0; i < validAttributes.length; i++) {\n            int attrPos;\n            if (validAttributes[i].mandatory) {\n                attrPos = temp.indexOf(validAttributes[i].name);\n                if (attrPos != -1) {\n                    temp.remove(attrPos);\n                    valid = true;\n                } else {\n                    valid = false;\n                    missingAttribute = validAttributes[i].name;\n                    break;\n                }\n            }\n        }\n\n        // If mandatory attribute is missing then the exception is thrown\n        if (!valid)\n            err.jspError(start, \"jsp.error.mandatory.attribute\", typeOfTag,\n                    missingAttribute);\n\n        // Check to see if there are any more attributes for the specified tag.\n        int attrLeftLength = temp.size();\n        if (attrLeftLength == 0)\n            return;\n\n        // Now check to see if the rest of the attributes are valid too.\n        String attribute = null;\n\n        for (int j = 0; j < attrLeftLength; j++) {\n            valid = false;\n            attribute = temp.elementAt(j);\n            for (int i = 0; i < validAttributes.length; i++) {\n                if (attribute.equals(validAttributes[i].name)) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid)\n                err.jspError(start, \"jsp.error.invalid.attribute\", typeOfTag,\n                        attribute);\n        }\n        // XXX *could* move EL-syntax validation here... (sb)\n    }","commit_id":"ac7d79ca4f46f6050812360bef5b3a5cf5c9c7f6","url":"https://github.com/apache/tomcat"},{"original_method":"void stop() {\n               is_it_running=false;\n               if(send_queue != null)\n                   send_queue.clear();\n               if(senderThread != null) {\n                   Thread tmp=senderThread;\n                   senderThread=null;\n                   tmp.interrupt();\n                   try {\n                       tmp.join(MAX_JOIN_TIMEOUT);\n                   }\n                   catch(InterruptedException e) {\n                       Thread.currentThread().interrupt(); // set interrupt flag again\n                   }\n                   if(tmp.isAlive()) {\n                       if(log.isWarnEnabled())\n                           log.warn(\"sender thread was interrupted, but is still alive: \" + tmp);\n                   }\n               }\n           }","id":30130,"modified_method":"void stop() {\n               is_it_running=false;\n               if(send_queue != null)\n                   send_queue.clear();\n               if(senderThread != null) {\n                   Thread tmp=senderThread;\n                   senderThread=null;\n                   Util.interruptAndWaitToDie(tmp);\n               }\n           }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyConnectionClosed(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           ((ConnectionListener)conn_listeners.elementAt(i)).connectionClosed(peer);\n   }","id":30131,"modified_method":"void notifyConnectionClosed(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           conn_listeners.elementAt(i).connectionClosed(peer);\n   }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n           Thread tmp=t;\n           if(t != null)\n               t=null;\n           if(tmp != null) {\n               tmp.interrupt(); // interrupts the sleep()\n               try {\n                   tmp.join(MAX_JOIN_TIMEOUT);\n               }\n               catch(InterruptedException e) {\n                   Thread.currentThread().interrupt(); // set interrupt flag again\n               }\n               if(tmp.isAlive()) {\n                   if(log.isWarnEnabled())\n                       log.warn(\"reaper thread was interrupted, but is still alive: \" + tmp);\n               }\n           }\n       }","id":30132,"modified_method":"public void stop() {\n           Thread tmp=t;\n           if(t != null)\n               t=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n       }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n       StringBuilder ret=new StringBuilder();\n       Address key;\n       Connection val;\n       Map.Entry entry;\n       HashMap copy;\n\n       synchronized(conns) {\n           copy=new HashMap(conns);\n       }\n       ret.append(\"local_addr=\" + local_addr).append(\"\\n\");\n       ret.append(\"connections (\" + copy.size() + \"):\\n\");\n       for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n           entry=(Map.Entry)it.next();\n           key=(Address)entry.getKey();\n           val=(Connection)entry.getValue();\n           ret.append(\"key: \" + key + \": \" + val + '\\n');\n       }\n       ret.append('\\n');\n       return ret.toString();\n   }","id":30133,"modified_method":"public String toString() {\n       StringBuilder ret=new StringBuilder();\n       Address key;\n       Connection val;\n       Map.Entry entry;\n       HashMap<Address,Connection> copy;\n\n       synchronized(conns) {\n           copy=new HashMap<Address,Connection>(conns);\n       }\n       ret.append(\"local_addr=\" + local_addr).append(\"\\n\");\n       ret.append(\"connections (\" + copy.size() + \"):\\n\");\n       for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n           entry=(Map.Entry)it.next();\n           key=(Address)entry.getKey();\n           val=(Connection)entry.getValue();\n           ret.append(\"key: \" + key + \": \" + val + '\\n');\n       }\n       ret.append('\\n');\n       return ret.toString();\n   }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    Remove <code>addr<\/code>from connection table. This is typically triggered when a member is suspected.\n    */\n   public void remove(Address addr) {\n       Connection conn;\n\n       synchronized(conns) {\n           conn=(Connection)conns.remove(addr);\n       }\n\n       if(conn != null) {\n           try {\n               conn.destroy();  // won't do anything if already destroyed\n           }\n           catch(Exception e) {\n           }\n       }\n       if(log.isTraceEnabled()) log.trace(\"removed \" + addr + \", connections are \" + toString());\n   }","id":30134,"modified_method":"/**\n    Remove <code>addr<\/code>from connection table. This is typically triggered when a member is suspected.\n    */\n   public void remove(Address addr) {\n       Connection conn;\n\n       synchronized(conns) {\n           conn=conns.remove(addr);\n       }\n\n       if(conn != null) {\n           try {\n               conn.destroy();  // won't do anything if already destroyed\n           }\n           catch(Exception e) {\n           }\n       }\n       if(log.isTraceEnabled()) log.trace(\"removed \" + addr + \", connections are \" + toString());\n   }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"void notifyConnectionOpened(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           ((ConnectionListener)conn_listeners.elementAt(i)).connectionOpened(peer);\n   }","id":30135,"modified_method":"void notifyConnectionOpened(Address peer) {\n       if(peer == null) return;\n       for(int i=0; i < conn_listeners.size(); i++)\n           conn_listeners.elementAt(i).connectionOpened(peer);\n   }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n       * Removes all connections from ConnectionTable which are not in current_mbrs\n       * @param current_mbrs\n       */\n      public void retainAll(Collection current_mbrs) {\n          if(current_mbrs == null) return;\n          HashMap copy;\n          synchronized(conns) {\n              copy=new HashMap(conns);\n              conns.keySet().retainAll(current_mbrs);\n          }\n\n          // All of the connections that were not retained must be destroyed\n          // so that their resources are cleaned up.\n          Map.Entry entry;\n          for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n              entry=(Map.Entry)it.next();\n              Object oKey=entry.getKey();\n              if(!current_mbrs.contains(oKey)) {    // This connection NOT in the resultant connection set\n                  Connection conn=(Connection)entry.getValue();\n                  if(null != conn) {    // Destroy this connection\n                      if(log.isTraceEnabled())\n                          log.trace(\"Destroy this orphaned connection: \" + conn);\n                      conn.destroy();\n                  }\n              }\n          }\n          copy.clear();\n      }","id":30136,"modified_method":"/**\n       * Removes all connections from ConnectionTable which are not in current_mbrs\n       * @param current_mbrs\n       */\n      public void retainAll(Collection current_mbrs) {\n          if(current_mbrs == null) return;\n          HashMap<Address,Connection> copy;\n          synchronized(conns) {\n              copy=new HashMap<Address,Connection>(conns);\n              conns.keySet().retainAll(current_mbrs);\n          }\n\n          // All of the connections that were not retained must be destroyed\n          // so that their resources are cleaned up.\n          Map.Entry entry;\n          for(Iterator it=copy.entrySet().iterator(); it.hasNext();) {\n              entry=(Map.Entry)it.next();\n              Object oKey=entry.getKey();\n              if(!current_mbrs.contains(oKey)) {    // This connection NOT in the resultant connection set\n                  Connection conn=(Connection)entry.getValue();\n                  if(null != conn) {    // Destroy this connection\n                      if(log.isTraceEnabled())\n                          log.trace(\"Destroy this orphaned connection: \" + conn);\n                      conn.destroy();\n                  }\n              }\n          }\n          copy.clear();\n      }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               try {\n                   tmp.interrupt();\n                   tmp.join(MAX_JOIN_TIMEOUT);\n               }\n               catch(InterruptedException e) {\n                   Thread.currentThread().interrupt(); // set interrupt flag again\n               }\n               if(tmp.isAlive()) {\n                   if(log.isWarnEnabled())\n                   log.warn(\"stopped receiver thread, but thread (\" + tmp + \") is still alive !\");\n               }\n           }\n       }","id":30137,"modified_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n       }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Closes all open sockets, the server socket and all threads waiting for incoming messages */\n    public void stop() {\n        super.stop();\n\n        // 1. Stop the reaper\n        if(reaper != null)\n            reaper.stop();\n\n        // 2. close the server socket (this also stops the acceptor thread)\n        if(srv_sock != null) {\n            try {\n                ServerSocket tmp=srv_sock;\n                srv_sock=null;\n                tmp.close();\n            }\n            catch(Exception e) {\n            }\n        }\n\n        // 3. then close the connections\n        Connection conn;\n        Collection tmp=null;\n        synchronized(conns) {\n            tmp=new LinkedList(conns.values());\n            conns.clear();\n        }\n        if(tmp != null) {\n            for(Iterator it=tmp.iterator(); it.hasNext();) {\n                conn=(Connection)it.next();\n                conn.destroy();\n            }\n            tmp.clear();\n        }\n        local_addr=null;\n    }","id":30138,"modified_method":"/** Closes all open sockets, the server socket and all threads waiting for incoming messages */\n    public void stop() {\n        super.stop();\n\n        // 1. Stop the reaper\n        if(reaper != null)\n            reaper.stop();\n\n        // 2. close the server socket (this also stops the acceptor thread)\n        if(srv_sock != null) {\n            try {\n                ServerSocket tmp=srv_sock;\n                srv_sock=null;\n                tmp.close();\n                if(acceptor != null)\n                \tUtil.interruptAndWaitToDie(acceptor);\n            }\n            catch(Exception e) {\n            }\n        }\n\n        // 3. then close the connections       \n        Collection<Connection> connsCopy=null;\n        synchronized(conns) {\n            connsCopy=new LinkedList<Connection>(conns.values());\n            conns.clear();\n        }        \n        for(Connection conn:connsCopy) {                \n            conn.destroy();\n        }\n        connsCopy.clear();        \n        local_addr=null;\n    }","commit_id":"cd8c8b4f10f3f0dbffa36198df858733a11b9a77","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n            int retval=Global.BYTE_SIZE // type\n                    + Global.LONG_SIZE // id\n                    + Global.BYTE_SIZE; // rsp_expected\n\n            retval+=Global.BYTE_SIZE; // presence for corrName\n            if(corrName != null)\n                retval+=corrName.length() +2; // UTF\n\n            retval+=Global.BYTE_SIZE; // presence\n            if(callStack != null) {\n                retval+=Global.SHORT_SIZE; // number of elements\n                if(!callStack.isEmpty()) {\n                    Address mbr=(Address)callStack.firstElement();\n                    retval+=callStack.size() * (Util.size(mbr));\n                }\n            }\n\n            retval+=Util.size(dest_mbrs);\n            return retval;\n        }","id":30139,"modified_method":"public int size() {\n            int retval=Global.BYTE_SIZE // type\n                    + Global.LONG_SIZE // id\n                    + Global.BYTE_SIZE; // rsp_expected\n\n            retval+=Global.BYTE_SIZE; // presence for corrName\n            if(corrName != null)\n                retval+=corrName.length() +2; // UTF\n\n            retval+=Global.BYTE_SIZE; // presence\n            if(callStack != null) {\n                retval+=Global.SHORT_SIZE; // number of elements\n                if(!callStack.isEmpty()) {\n                    Address mbr=callStack.firstElement();\n                    retval+=callStack.size() * (Util.size(mbr));\n                }\n            }\n\n            retval+=Util.size(dest_mbrs);\n            return retval;\n        }","commit_id":"5d9c5d79a339e3058583a2ef0ce91627c3b9ecef","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(id);\n            out.writeBoolean(rsp_expected);\n\n            if(corrName != null) {\n                out.writeBoolean(true);\n                out.writeUTF(corrName);\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            if(callStack != null) {\n                out.writeBoolean(true);\n                out.writeShort(callStack.size());\n                Address mbr;\n                for(int i=0; i < callStack.size(); i++) {\n                    mbr=(Address)callStack.elementAt(i);\n                    Util.writeAddress(mbr, out);\n                }\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            Util.writeAddresses(dest_mbrs, out);\n        }","id":30140,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(id);\n            out.writeBoolean(rsp_expected);\n\n            if(corrName != null) {\n                out.writeBoolean(true);\n                out.writeUTF(corrName);\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            if(callStack != null) {\n                out.writeBoolean(true);\n                out.writeShort(callStack.size());\n                Address mbr;\n                for(int i=0; i < callStack.size(); i++) {\n                    mbr=callStack.elementAt(i);\n                    Util.writeAddress(mbr, out);\n                }\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            Util.writeAddresses(dest_mbrs, out);\n        }","commit_id":"5d9c5d79a339e3058583a2ef0ce91627c3b9ecef","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\r\n     * \r\n     * @param userName\r\n     * @param viaAddress\r\n     * \r\n     * @return Return the initial local SDP.\r\n     */\r\n    public static SessionDescriptor createInitialSdp(String userName, String viaAddress, \r\n    \t\tint audioPort, int videoPort, String audioCodecsPrecedence) {\r\n        \r\n        SessionDescriptor initialDescriptor = null;\r\n                \r\n        try {            \r\n//            log.debug(\"userName = [\" + userName + \"], viaAddress = [\" + viaAddress + \r\n//                    \"], audioPort = [\" + audioPort + \"], videoPort = [\" + videoPort + \r\n//                    \"], audioCodecsPrecedence = [\" + audioCodecsPrecedence + \"].\" );\r\n            \r\n            int audioCodecsNumber = CodecFactory.getInstance().getAvailableAudioCodecsCount();\r\n            int videoCodecsNumber = CodecFactory.getInstance().getAvailableVideoCodecsCount();\r\n            \r\n            if ((audioCodecsNumber == 0) && (videoCodecsNumber == 0)) {                \r\n                log.debug(\"audioCodecsNumber = [\" + audioCodecsNumber + \r\n                        \"], videoCodecsNumber = [\" + videoCodecsNumber + \"].\");                \r\n                return null;\r\n            }\r\n            \r\n            initialDescriptor = new SessionDescriptor(userName, viaAddress);\r\n            \r\n            if (initialDescriptor == null) {                \r\n                log.error(\"Error instantiating the initialDescriptor!\");                 \r\n                return null;\r\n            }\r\n            \r\n            if (audioCodecsNumber > 0) {                \r\n                Codec[] audioCodecs;\r\n                Vector audioAttributes = new Vector();\r\n                \r\n                if (audioCodecsPrecedence.isEmpty()) {                    \r\n                    audioCodecs = CodecFactory.getInstance().getAvailableAudioCodecs();\r\n                } else {                    \r\n                    audioCodecs = CodecFactory.getInstance().getAvailableAudioCodecsWithPrecedence(audioCodecsPrecedence);\r\n                }\r\n                \r\n                for (int audioIndex = 0; audioIndex < audioCodecsNumber; audioIndex++) {                   \r\n                    String payloadId = String.valueOf(audioCodecs[audioIndex].getCodecId());\r\n                    String rtpmapParamValue = payloadId;\r\n                    rtpmapParamValue += \" \" + audioCodecs[audioIndex].getCodecName();\r\n                    rtpmapParamValue += \"/\" + audioCodecs[audioIndex].getSampleRate() + \"/1\";\r\n                    \r\n//                    log.debug(\"Adding rtpmap for payload [\" + payloadId + \r\n//                            \"] with value = [\" + rtpmapParamValue + \"].\" );\r\n                    \r\n                    audioAttributes.add(new AttributeField(Codec.ATTRIBUTE_RTPMAP, rtpmapParamValue));\r\n                    \r\n                    String[] codecMediaAttributes = audioCodecs[audioIndex].getCodecMediaAttributes();\r\n                    \r\n                    if (codecMediaAttributes != null) {                        \r\n//                        log.debug(\"Adding \" + codecMediaAttributes.length + \r\n//                                \" audio codec media attributes.\" );\r\n                        \r\n                        for (int attribIndex = 0; attribIndex < codecMediaAttributes.length; attribIndex++) {                            \r\n//                            log.debug(\"Adding audio media attribute [\" + \r\n//                                    codecMediaAttributes[attribIndex] + \"].\" );\r\n                            \r\n                            AttributeField newAttribute = parseAttributeField(codecMediaAttributes[attribIndex]);\r\n                            \r\n                            if (newAttribute != null) {                                \r\n                                audioAttributes.add(newAttribute);\r\n                            }\r\n                        }\r\n                    } else {                        \r\n                        log.warn(\"Audio codec has no especific media attributes.\" );\r\n                    }\r\n                }\r\n                \r\n                // Calculate the format list to be used on MediaDescriptor creation.\r\n                String formatList = getFormatList(audioAttributes);\r\n                \r\n                for (Enumeration attributesEnum = audioAttributes.elements(); attributesEnum.hasMoreElements();) {                    \r\n                    AttributeField audioAttribute = (AttributeField) attributesEnum.nextElement();\r\n                    \r\n                    if (initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_AUDIO) == null) {                        \r\n//                        log.debug(\"Creating audio media descriptor.\" );\r\n                        \r\n                    \tMediaField mf = new MediaField(Codec.MEDIA_TYPE_AUDIO, audioPort, 0, \"RTP/AVP\", formatList);\r\n                        initialDescriptor.addMedia(mf, audioAttribute);\r\n                    } else {                        \r\n//                        log.debug(\"Just adding attribute.\");\r\n                        initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_AUDIO).addAttribute(audioAttribute);\r\n                    }\r\n                }\r\n                \r\n                String[] commonAudioMediaAttributes = CodecFactory.getInstance().getCommonAudioMediaAttributes();\r\n                \r\n                if (commonAudioMediaAttributes != null) {                    \r\n//                    log.debug(\"Adding \" + commonAudioMediaAttributes.length + \" common audio media attributes.\" );\r\n                    \r\n                    for (int attribIndex = 0; attribIndex < commonAudioMediaAttributes.length; attribIndex++) {                        \r\n//                        log.debug(\"Adding common audio media attribute [\" + commonAudioMediaAttributes[attribIndex] + \"].\");\r\n                        \r\n                        AttributeField newAttribute = parseAttributeField(commonAudioMediaAttributes[attribIndex]);\r\n                        \r\n                        if (newAttribute != null) {                            \r\n                            initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_AUDIO).addAttribute( newAttribute);\r\n                        }\r\n                    }\r\n                } else {                    \r\n                    log.debug(\"No common audio media attributes.\");\r\n                }\r\n            }\r\n            \r\n            if (videoCodecsNumber > 0) {                \r\n                Codec[] videoCodecs = CodecFactory.getInstance().getAvailableVideoCodecs();\r\n                Vector videoAttributes = new Vector();\r\n                \r\n                for (int videoIndex = 0; videoIndex < audioCodecsNumber; videoIndex++) {                    \r\n                    String payloadId = String.valueOf(videoCodecs[videoIndex].getCodecId());\r\n                    String rtpmapParamValue = payloadId;\r\n                    rtpmapParamValue += \" \" + videoCodecs[videoIndex].getCodecName();\r\n                    rtpmapParamValue += \"/\" + videoCodecs[videoIndex].getSampleRate() + \"/1\";\r\n                    \r\n//                    log.debug(\"Adding rtpmap for payload [\" + payloadId + \"] with value = [\" + rtpmapParamValue + \"].\");\r\n                    \r\n                    videoAttributes.add(new AttributeField(Codec.ATTRIBUTE_RTPMAP, rtpmapParamValue));                    \r\n                    String[] codecMediaAttributes = videoCodecs[videoIndex].getCodecMediaAttributes();\r\n                    \r\n                    if (codecMediaAttributes != null) {                        \r\n//                        log.debug(\"Adding \" + codecMediaAttributes.length + \" video codec media attributes.\");\r\n                        \r\n                        for (int attribIndex = 0; attribIndex < codecMediaAttributes.length; attribIndex++) {                            \r\n//                            log.debug(\"Adding video media attribute [\" + codecMediaAttributes[attribIndex] + \"].\");\r\n                            \r\n                            AttributeField newAttribute = parseAttributeField(codecMediaAttributes[attribIndex]);\r\n                            \r\n                            if (newAttribute != null) {                                \r\n                                videoAttributes.add(newAttribute);\r\n                            }\r\n                        }\r\n                    } else {\r\n                       log.info(\"Video codec has no especific media attributes.\");\r\n                    }\r\n                }\r\n                \r\n                // Calculate the format list to be used on MediaDescriptor creation.\r\n                String formatList = getFormatList(videoAttributes);\r\n                \r\n                for (Enumeration attributesEnum = videoAttributes.elements(); attributesEnum.hasMoreElements();) {                    \r\n                    AttributeField videoAttribute = (AttributeField) attributesEnum.nextElement();\r\n                    \r\n                    if (initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_VIDEO) == null) {    \r\n                    \tMediaField mf = new MediaField(Codec.MEDIA_TYPE_VIDEO, audioPort, 0, \"RTP/AVP\", formatList);\r\n                        initialDescriptor.addMedia(mf, videoAttribute);\r\n                    } else {\r\n                        initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_VIDEO).addAttribute(videoAttribute);\r\n                    }\r\n                }\r\n                \r\n                String[] commonVideoMediaAttributes = CodecFactory.getInstance().getCommonAudioMediaAttributes();\r\n                \r\n                if (commonVideoMediaAttributes != null) {                    \r\n//                    log.debug(\"Adding \" + commonVideoMediaAttributes.length + \" common video media attributes.\");\r\n                    \r\n                    for (int attribIndex = 0; attribIndex < commonVideoMediaAttributes.length; attribIndex++) {                        \r\n//                        log.debug(\"Adding common video media attribute [\" + commonVideoMediaAttributes[attribIndex] + \"].\" );\r\n                        \r\n                        AttributeField newAttribute = parseAttributeField(commonVideoMediaAttributes[attribIndex]);\r\n                        \r\n                        if (newAttribute != null) {                            \r\n                            initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_VIDEO).addAttribute(newAttribute);\r\n                        }\r\n                    }\r\n                } else {                    \r\n                    log.info(\"No common video media attributes.\");\r\n                }\r\n            }\r\n        } catch (Exception exception) {\r\n            log.error(\"Failure creating initial SDP: \" + exception.toString());\r\n        }\r\n        \r\n//        log.debug(\"Created initial SDP\");\r\n        \r\n        return initialDescriptor;\r\n    }","id":30141,"modified_method":"/**\r\n     * \r\n     * @param userName\r\n     * @param viaAddress\r\n     * \r\n     * @return Return the initial local SDP.\r\n     */\r\n    public static SessionDescriptor createInitialSdp(String userName, String viaAddress, \r\n    \t\tint audioPort, int videoPort, String audioCodecsPrecedence) {\r\n        \r\n        SessionDescriptor initialDescriptor = null;\r\n                \r\n        try {            \r\n//            log.debug(\"userName = [\" + userName + \"], viaAddress = [\" + viaAddress + \r\n//                    \"], audioPort = [\" + audioPort + \"], videoPort = [\" + videoPort + \r\n//                    \"], audioCodecsPrecedence = [\" + audioCodecsPrecedence + \"].\" );\r\n            \r\n            int audioCodecsNumber = CodecFactory.getInstance().getAvailableAudioCodecsCount();\r\n            int videoCodecsNumber = CodecFactory.getInstance().getAvailableVideoCodecsCount();\r\n            \r\n            if ((audioCodecsNumber == 0) && (videoCodecsNumber == 0)) {                \r\n                log.debug(\"audioCodecsNumber = [\" + audioCodecsNumber + \r\n                        \"], videoCodecsNumber = [\" + videoCodecsNumber + \"].\");                \r\n                return null;\r\n            }\r\n\r\n            //Bug Session descriptor cannot have spaces.. Username is not forced to be compliant with SIP Spec\r\n            /* RFC 2327 - page 8 of April 1998 Version,\r\n                Origin\r\n\r\n                   o=<username> <session id> <version> <network type> <address type>\r\n                   <address>\r\n\r\n                   The \"o=\" field gives the originator of the session (their username\r\n                   and the address of the user's host) plus a session id and session\r\n                   version number.\r\n\r\n                   <username> is the user's login on the originating host, or it is \"-\"\r\n                   if the originating host does not support the concept of user ids.\r\n                   <username> must not contain spaces.  <session id> is a numeric string\r\n                   such that the tuple of <username>, <session id>, <network type>,\r\n                   <address type> and <address> form a globally unique identifier for\r\n                   the session.\r\n             */\r\n\r\n            String owner = userName.replaceAll(\" \", \"_\");\r\n\r\n            initialDescriptor = new SessionDescriptor(owner, viaAddress);\r\n            \r\n            if (initialDescriptor == null) {                \r\n                log.error(\"Error instantiating the initialDescriptor!\");                 \r\n                return null;\r\n            }\r\n            \r\n            if (audioCodecsNumber > 0) {                \r\n                Codec[] audioCodecs;\r\n                Vector<AttributeField> audioAttributes = new Vector<AttributeField>();\r\n                \r\n                if (audioCodecsPrecedence.isEmpty()) {                    \r\n                    audioCodecs = CodecFactory.getInstance().getAvailableAudioCodecs();\r\n                } else {                    \r\n                    audioCodecs = CodecFactory.getInstance().getAvailableAudioCodecsWithPrecedence(audioCodecsPrecedence);\r\n                }\r\n                \r\n                for (int audioIndex = 0; audioIndex < audioCodecsNumber; audioIndex++) {                   \r\n                    String payloadId = String.valueOf(audioCodecs[audioIndex].getCodecId());\r\n                    String rtpmapParamValue = payloadId;\r\n                    rtpmapParamValue += \" \" + audioCodecs[audioIndex].getCodecName();\r\n                    rtpmapParamValue += \"/\" + audioCodecs[audioIndex].getSampleRate() + \"/1\";\r\n                    \r\n//                    log.debug(\"Adding rtpmap for payload [\" + payloadId + \r\n//                            \"] with value = [\" + rtpmapParamValue + \"].\" );\r\n                    \r\n                    audioAttributes.add(new AttributeField(Codec.ATTRIBUTE_RTPMAP, rtpmapParamValue));\r\n                    \r\n                    String[] codecMediaAttributes = audioCodecs[audioIndex].getCodecMediaAttributes();\r\n                    \r\n                    if (codecMediaAttributes != null) {                        \r\n//                        log.debug(\"Adding \" + codecMediaAttributes.length + \r\n//                                \" audio codec media attributes.\" );\r\n                        \r\n                        for (int attribIndex = 0; attribIndex < codecMediaAttributes.length; attribIndex++) {                            \r\n//                            log.debug(\"Adding audio media attribute [\" + \r\n//                                    codecMediaAttributes[attribIndex] + \"].\" );\r\n                            \r\n                            AttributeField newAttribute = parseAttributeField(codecMediaAttributes[attribIndex]);\r\n                            \r\n                            if (newAttribute != null) {                                \r\n                                audioAttributes.add(newAttribute);\r\n                            }\r\n                        }\r\n                    } else {                        \r\n                        log.warn(\"Audio codec has no especific media attributes.\" );\r\n                    }\r\n                }\r\n                \r\n                // Calculate the format list to be used on MediaDescriptor creation.\r\n                String formatList = getFormatList(audioAttributes);\r\n                \r\n                for (Enumeration attributesEnum = audioAttributes.elements(); attributesEnum.hasMoreElements();) {                    \r\n                    AttributeField audioAttribute = (AttributeField) attributesEnum.nextElement();\r\n                    \r\n                    if (initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_AUDIO) == null) {                        \r\n//                        log.debug(\"Creating audio media descriptor.\" );\r\n                        \r\n                    \tMediaField mf = new MediaField(Codec.MEDIA_TYPE_AUDIO, audioPort, 0, \"RTP/AVP\", formatList);\r\n                        initialDescriptor.addMedia(mf, audioAttribute);\r\n                    } else {                        \r\n//                        log.debug(\"Just adding attribute.\");\r\n                        initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_AUDIO).addAttribute(audioAttribute);\r\n                    }\r\n                }\r\n                \r\n                String[] commonAudioMediaAttributes = CodecFactory.getInstance().getCommonAudioMediaAttributes();\r\n                \r\n                if (commonAudioMediaAttributes != null) {                    \r\n//                    log.debug(\"Adding \" + commonAudioMediaAttributes.length + \" common audio media attributes.\" );\r\n                    \r\n                    for (int attribIndex = 0; attribIndex < commonAudioMediaAttributes.length; attribIndex++) {                        \r\n//                        log.debug(\"Adding common audio media attribute [\" + commonAudioMediaAttributes[attribIndex] + \"].\");\r\n                        \r\n                        AttributeField newAttribute = parseAttributeField(commonAudioMediaAttributes[attribIndex]);\r\n                        \r\n                        if (newAttribute != null) {                            \r\n                            initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_AUDIO).addAttribute( newAttribute);\r\n                        }\r\n                    }\r\n                } else {                    \r\n                    log.debug(\"No common audio media attributes.\");\r\n                }\r\n            }\r\n            \r\n            if (videoCodecsNumber > 0) {                \r\n                Codec[] videoCodecs = CodecFactory.getInstance().getAvailableVideoCodecs();\r\n                Vector<AttributeField> videoAttributes = new Vector<AttributeField>();\r\n                \r\n                for (int videoIndex = 0; videoIndex < audioCodecsNumber; videoIndex++) {                    \r\n                    String payloadId = String.valueOf(videoCodecs[videoIndex].getCodecId());\r\n                    String rtpmapParamValue = payloadId;\r\n                    rtpmapParamValue += \" \" + videoCodecs[videoIndex].getCodecName();\r\n                    rtpmapParamValue += \"/\" + videoCodecs[videoIndex].getSampleRate() + \"/1\";\r\n                    \r\n//                    log.debug(\"Adding rtpmap for payload [\" + payloadId + \"] with value = [\" + rtpmapParamValue + \"].\");\r\n                    \r\n                    videoAttributes.add(new AttributeField(Codec.ATTRIBUTE_RTPMAP, rtpmapParamValue));                    \r\n                    String[] codecMediaAttributes = videoCodecs[videoIndex].getCodecMediaAttributes();\r\n                    \r\n                    if (codecMediaAttributes != null) {                        \r\n//                        log.debug(\"Adding \" + codecMediaAttributes.length + \" video codec media attributes.\");\r\n                        \r\n                        for (int attribIndex = 0; attribIndex < codecMediaAttributes.length; attribIndex++) {                            \r\n//                            log.debug(\"Adding video media attribute [\" + codecMediaAttributes[attribIndex] + \"].\");\r\n                            \r\n                            AttributeField newAttribute = parseAttributeField(codecMediaAttributes[attribIndex]);\r\n                            \r\n                            if (newAttribute != null) {                                \r\n                                videoAttributes.add(newAttribute);\r\n                            }\r\n                        }\r\n                    } else {\r\n                       log.info(\"Video codec has no especific media attributes.\");\r\n                    }\r\n                }\r\n                \r\n                // Calculate the format list to be used on MediaDescriptor creation.\r\n                String formatList = getFormatList(videoAttributes);\r\n                \r\n                for (Enumeration attributesEnum = videoAttributes.elements(); attributesEnum.hasMoreElements();) {                    \r\n                    AttributeField videoAttribute = (AttributeField) attributesEnum.nextElement();\r\n                    \r\n                    if (initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_VIDEO) == null) {    \r\n                    \tMediaField mf = new MediaField(Codec.MEDIA_TYPE_VIDEO, audioPort, 0, \"RTP/AVP\", formatList);\r\n                        initialDescriptor.addMedia(mf, videoAttribute);\r\n                    } else {\r\n                        initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_VIDEO).addAttribute(videoAttribute);\r\n                    }\r\n                }\r\n                \r\n                String[] commonVideoMediaAttributes = CodecFactory.getInstance().getCommonAudioMediaAttributes();\r\n                \r\n                if (commonVideoMediaAttributes != null) {                    \r\n//                    log.debug(\"Adding \" + commonVideoMediaAttributes.length + \" common video media attributes.\");\r\n                    \r\n                    for (int attribIndex = 0; attribIndex < commonVideoMediaAttributes.length; attribIndex++) {                        \r\n//                        log.debug(\"Adding common video media attribute [\" + commonVideoMediaAttributes[attribIndex] + \"].\" );\r\n                        \r\n                        AttributeField newAttribute = parseAttributeField(commonVideoMediaAttributes[attribIndex]);\r\n                        \r\n                        if (newAttribute != null) {                            \r\n                            initialDescriptor.getMediaDescriptor(Codec.MEDIA_TYPE_VIDEO).addAttribute(newAttribute);\r\n                        }\r\n                    }\r\n                } else {                    \r\n                    log.info(\"No common video media attributes.\");\r\n                }\r\n            }\r\n        } catch (Exception exception) {\r\n            log.error(\"Failure creating initial SDP: \" + exception.toString());\r\n        }\r\n        \r\n//        log.debug(\"Created initial SDP\");\r\n        \r\n        return initialDescriptor;\r\n    }","commit_id":"ac764dca994f21c8c1fa457ae446d185144dcc90","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"/** \r\n     * We must validate the existence of all remote \"rtpmap\" attributes \r\n     * on local SDP.\r\n     * If some exist, we add it to newSdp negotiated SDP result.\r\n     * \r\n     * @param localSdp\r\n     * @param remoteSdp\r\n     * \r\n     * @return Returns the new local descriptor as a result of media \r\n     *         payloads negotiation.\r\n     */\r\n    public static SessionDescriptor makeMediaPayloadsNegotiation(SessionDescriptor localSdp, SessionDescriptor remoteSdp) {        \r\n    \tlog.debug(\"makeMediaPayloadsNegotiation\");\r\n    \t\r\n    \tSessionDescriptor newSdp = null;    \r\n        try {            \r\n            newSdp = new SessionDescriptor(remoteSdp.getOrigin(), remoteSdp.getSessionName(),\r\n                    localSdp.getConnection(), localSdp.getTime());\r\n            \r\n            Vector remoteDescriptors = remoteSdp.getMediaDescriptors();\r\n            \r\n            for (Enumeration descriptorsEnum = remoteDescriptors.elements(); descriptorsEnum.hasMoreElements();) {                \r\n                MediaDescriptor remoteDescriptor = (MediaDescriptor) descriptorsEnum.nextElement();\r\n                MediaDescriptor localDescriptor = localSdp.getMediaDescriptor(remoteDescriptor.getMedia().getMedia() );\r\n                \r\n                if (localDescriptor != null) {                    \r\n                    Vector remoteAttributes = remoteDescriptor.getAttributes(Codec.ATTRIBUTE_RTPMAP);\r\n                    Vector newSdpAttributes = new Vector();\r\n                    \r\n                    for (Enumeration attributesEnum = remoteAttributes.elements(); attributesEnum.hasMoreElements();) {                        \r\n                        AttributeField remoteAttribute = (AttributeField) attributesEnum.nextElement();\r\n                        \r\n                        String payloadId = getPayloadIdFromAttribute(remoteAttribute);\r\n                        \r\n                        if (\"\".equals(payloadId)) {                            \r\n                            log.error(\"Payload id not found on attribute: Name = [\" + \r\n                                    remoteAttribute.getAttributeName() + \"], Value = [\" + \r\n                                    remoteAttribute.getAttributeValue() + \"].\" );\r\n                        } else if (findAttributeByPayloadId(remoteAttribute.getAttributeName(), \r\n                        \t\tpayloadId, localDescriptor) != null) {                            \r\n                            newSdpAttributes.add(remoteAttribute);\r\n                        }\r\n                    }\r\n                    \r\n                    // Calculate the format list to be used on MediaDescriptor creation.\r\n                    String formatList = getFormatList(newSdpAttributes);\r\n                    \r\n                    for (Enumeration attributesEnum = newSdpAttributes.elements(); attributesEnum.hasMoreElements();) {                        \r\n                        AttributeField mediaAttribute = (AttributeField) attributesEnum.nextElement();\r\n                        \r\n                        if (newSdp.getMediaDescriptors().size() == 0) {  \r\n                        \tMediaField mf = new MediaField(localDescriptor.getMedia().getMedia(), \r\n                                    \t\t\t\t\t\tlocalDescriptor.getMedia().getPort(), \r\n                                    \t\t\t\t\t\t0, localDescriptor.getMedia().getTransport(), \r\n                                    \t\t\t\t\t\tformatList); \r\n                            newSdp.addMediaDescriptor(new MediaDescriptor(mf, localDescriptor.getConnection()));\r\n                        }\r\n                        \r\n                        newSdp.getMediaDescriptor(localDescriptor.getMedia().getMedia()).addAttribute( mediaAttribute );\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception exception) {            \r\n            log.error(\"Failure creating initial SDP: \" + exception.toString());\r\n        }\r\n        \r\n        return newSdp;\r\n    }","id":30142,"modified_method":"/** \r\n     * We must validate the existence of all remote \"rtpmap\" attributes \r\n     * on local SDP.\r\n     * If some exist, we add it to newSdp negotiated SDP result.\r\n     * \r\n     * @param localSdp\r\n     * @param remoteSdp\r\n     * \r\n     * @return Returns the new local descriptor as a result of media \r\n     *         payloads negotiation.\r\n     */\r\n    public static SessionDescriptor makeMediaPayloadsNegotiation(SessionDescriptor localSdp, SessionDescriptor remoteSdp) {        \r\n    \tlog.debug(\"makeMediaPayloadsNegotiation\");\r\n    \t\r\n    \tSessionDescriptor newSdp = null;    \r\n        try {            \r\n            newSdp = new SessionDescriptor(remoteSdp.getOrigin(), remoteSdp.getSessionName(),\r\n                    localSdp.getConnection(), localSdp.getTime());\r\n            \r\n            Vector remoteDescriptors = remoteSdp.getMediaDescriptors();\r\n            \r\n            for (Enumeration descriptorsEnum = remoteDescriptors.elements(); descriptorsEnum.hasMoreElements();) {                \r\n                MediaDescriptor remoteDescriptor = (MediaDescriptor) descriptorsEnum.nextElement();\r\n                MediaDescriptor localDescriptor = localSdp.getMediaDescriptor(remoteDescriptor.getMedia().getMedia() );\r\n                \r\n                if (localDescriptor != null) {                    \r\n                    Vector remoteAttributes = remoteDescriptor.getAttributes(Codec.ATTRIBUTE_RTPMAP);\r\n                    Vector<AttributeField> newSdpAttributes = new Vector<AttributeField>();\r\n                    \r\n                    for (Enumeration attributesEnum = remoteAttributes.elements(); attributesEnum.hasMoreElements();) {                        \r\n                        AttributeField remoteAttribute = (AttributeField) attributesEnum.nextElement();\r\n                        \r\n                        String payloadId = getPayloadIdFromAttribute(remoteAttribute);\r\n                        \r\n                        if (\"\".equals(payloadId)) {                            \r\n                            log.error(\"Payload id not found on attribute: Name = [\" + \r\n                                    remoteAttribute.getAttributeName() + \"], Value = [\" + \r\n                                    remoteAttribute.getAttributeValue() + \"].\" );\r\n                        } else if (findAttributeByPayloadId(remoteAttribute.getAttributeName(), \r\n                        \t\tpayloadId, localDescriptor) != null) {                            \r\n                            newSdpAttributes.add(remoteAttribute);\r\n                        }\r\n                    }\r\n                    \r\n                    // Calculate the format list to be used on MediaDescriptor creation.\r\n                    String formatList = getFormatList(newSdpAttributes);\r\n                    \r\n                    for (Enumeration attributesEnum = newSdpAttributes.elements(); attributesEnum.hasMoreElements();) {                        \r\n                        AttributeField mediaAttribute = (AttributeField) attributesEnum.nextElement();\r\n                        \r\n                        if (newSdp.getMediaDescriptors().size() == 0) {  \r\n                        \tMediaField mf = new MediaField(localDescriptor.getMedia().getMedia(), \r\n                                    \t\t\t\t\t\tlocalDescriptor.getMedia().getPort(), \r\n                                    \t\t\t\t\t\t0, localDescriptor.getMedia().getTransport(), \r\n                                    \t\t\t\t\t\tformatList); \r\n                            newSdp.addMediaDescriptor(new MediaDescriptor(mf, localDescriptor.getConnection()));\r\n                        }\r\n                        \r\n                        newSdp.getMediaDescriptor(localDescriptor.getMedia().getMedia()).addAttribute( mediaAttribute );\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception exception) {            \r\n            log.error(\"Failure creating initial SDP: \" + exception.toString());\r\n        }\r\n        \r\n        return newSdp;\r\n    }","commit_id":"ac764dca994f21c8c1fa457ae446d185144dcc90","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"/** Gets a Vector of attribute values.\r\n     * @return a Vector of AttributeField */\r\n   public Vector getAttributes()\r\n   {  Vector v=new Vector(av.size());\r\n      for (int i=0; i<av.size(); i++)\r\n         v.addElement((AttributeField)av.elementAt(i));\r\n      return v;\r\n   }","id":30143,"modified_method":"/** Gets a Vector of attribute values.\r\n     * @return a Vector of AttributeField */\r\n   public Vector<AttributeField> getAttributes()\r\n   {  Vector<AttributeField> _v=new Vector<AttributeField>(av.size());\r\n      for (int i=0; i<av.size(); i++)\r\n         _v.addElement(av.elementAt(i));\r\n      return _v;\r\n   }","commit_id":"ac764dca994f21c8c1fa457ae446d185144dcc90","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"/** Gets a Vector of attribute values of a particular attribute name.\r\n     * @param a_name the attribute name\r\n     * @return a Vector of AttributeField */\r\n   public Vector getAttributes(String attribute_name)\r\n   {  Vector v=new Vector(av.size());\r\n      for (int i=0; i<av.size(); i++)\r\n      {  AttributeField a=(AttributeField)av.elementAt(i);\r\n         if (a.getAttributeName().equals(attribute_name)) v.addElement(a);\r\n      }\r\n      return v;\r\n   }","id":30144,"modified_method":"/** Gets a Vector of attribute values of a particular attribute name.\r\n     * @param a_name the attribute name\r\n     * @return a Vector of AttributeField */\r\n   public Vector<AttributeField> getAttributes(String attribute_name)\r\n   {  Vector<AttributeField> _v=new Vector<AttributeField>(av.size());\r\n      for (int i=0; i<av.size(); i++)\r\n      {  AttributeField a=(AttributeField)av.elementAt(i);\r\n         if (a.getAttributeName().equals(attribute_name)) _v.addElement(a);\r\n      }\r\n      return _v;\r\n   }","commit_id":"ac764dca994f21c8c1fa457ae446d185144dcc90","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"/** Creates a new SessionDescriptor from String <i>sdp<\/i>\r\n     * @param sdp the entire SDP */\r\n   public SessionDescriptor(String sdp)\r\n   {  SdpParser par=new SdpParser(sdp);\r\n      // parse mandatory fields\r\n      v=par.parseSdpField('v');\r\n      if (v==null) v=new SdpField('v',\"0\");\r\n      o=par.parseOriginField();\r\n      if (o==null) o=new OriginField(\"unknown\");\r\n      s=par.parseSessionNameField();\r\n      if (s==null) s=new SessionNameField();\r\n      c=par.parseConnectionField();\r\n      if (c==null) c=new ConnectionField(\"IP4\",\"0.0.0.0\");\r\n      t=par.parseTimeField();\r\n      if (t==null) t=new TimeField();\r\n      while (par.hasMore() && (!par.startsWith(\"a=\") && !par.startsWith(\"m=\")))\r\n      {  // skip unknown lines..\r\n         par.goToNextLine();\r\n      } \r\n      // parse session attributes\r\n      av=new Vector();   \r\n      while (par.hasMore() && par.startsWith(\"a=\"))\r\n      {  AttributeField attribute=par.parseAttributeField();\r\n         av.addElement(attribute);\r\n      }    \r\n      // parse media descriptors\r\n      media=new Vector();\r\n      MediaDescriptor md;\r\n      while ((md=par.parseMediaDescriptor())!=null)\r\n      {  addMediaDescriptor(md);\r\n      }\r\n   }","id":30145,"modified_method":"/** Creates a new SessionDescriptor from String <i>sdp<\/i>\r\n     * @param sdp the entire SDP */\r\n   public SessionDescriptor(String sdp)\r\n   {  SdpParser par=new SdpParser(sdp);\r\n      // parse mandatory fields\r\n      v=par.parseSdpField('v');\r\n      if (v==null) v=new SdpField('v',\"0\");\r\n      o=par.parseOriginField();\r\n      if (o==null) o=new OriginField(\"unknown\");\r\n      s=par.parseSessionNameField();\r\n      if (s==null) s=new SessionNameField();\r\n      c=par.parseConnectionField();\r\n      if (c==null) c=new ConnectionField(\"IP4\",\"0.0.0.0\");\r\n      t=par.parseTimeField();\r\n      if (t==null) t=new TimeField();\r\n      while (par.hasMore() && (!par.startsWith(\"a=\") && !par.startsWith(\"m=\")))\r\n      {  // skip unknown lines..\r\n         par.goToNextLine();\r\n      } \r\n      // parse session attributes\r\n      av=new Vector<AttributeField>();\r\n      while (par.hasMore() && par.startsWith(\"a=\"))\r\n      {  AttributeField attribute=par.parseAttributeField();\r\n         av.addElement(attribute);\r\n      }    \r\n      // parse media descriptors\r\n      media=new Vector<MediaDescriptor>();\r\n      MediaDescriptor md;\r\n      while ((md=par.parseMediaDescriptor())!=null)\r\n      {  addMediaDescriptor(md);\r\n      }\r\n   }","commit_id":"ac764dca994f21c8c1fa457ae446d185144dcc90","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"/** Adds a Vector of MediaDescriptors\r\n     * @param media_descs Vector if MediaDescriptor \r\n     * @return this SessionDescriptor */\r\n   public SessionDescriptor addMediaDescriptors(Vector media_descs)\r\n   {  //media.addAll(media_descs); // not supported by J2ME..\r\n      for (int i=0; i<media_descs.size(); i++) media.addElement(media_descs.elementAt(i));\r\n      return this;\r\n   }","id":30146,"modified_method":"/** Adds a Vector of MediaDescriptors\r\n     * @param media_descs Vector if MediaDescriptor \r\n     * @return this SessionDescriptor */\r\n   public SessionDescriptor addMediaDescriptors(Vector<MediaDescriptor> media_descs)\r\n   {  //media.addAll(media_descs); // not supported by J2ME..\r\n      for (int i=0; i<media_descs.size(); i++) media.addElement(media_descs.elementAt(i));\r\n      return this;\r\n   }","commit_id":"ac764dca994f21c8c1fa457ae446d185144dcc90","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"/** Inits the SessionDescriptor. */\r\n   private void init(OriginField origin, SessionNameField session, ConnectionField connection, TimeField time)\r\n   {  v=new SdpField('v',\"0\");\r\n      o=origin;\r\n      s=session;\r\n      c=connection;\r\n      t=time;\r\n      av=new Vector();\r\n      media=new Vector();\r\n   }","id":30147,"modified_method":"/** Inits the SessionDescriptor. */\r\n   private void init(OriginField origin, SessionNameField session, ConnectionField connection, TimeField time)\r\n   {  v=new SdpField('v',\"0\");\r\n      o=origin;\r\n      s=session;\r\n      c=connection;\r\n      t=time;\r\n      av=new Vector<AttributeField>();\r\n      media=new Vector<MediaDescriptor>();\r\n   }","commit_id":"ac764dca994f21c8c1fa457ae446d185144dcc90","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void createClasspathParts() {\n        Path path;\n        if (classpath != null) {\n            path = super.createClasspath();\n            path.setPath(classpath.toString());\n        }\n\n        if (includeAntRuntime) {\n            path = super.createClasspath();\n            path.setPath(System.getProperty(\"java.class.path\"));\n        }\n        String groovyHome = null;\n        final String[] strings = getSysProperties().getVariables();\n        for (int i = 0; i < strings.length; i++) {\n            String string = strings[i];\n            if (string.startsWith(\"-Dgroovy.home=\")) {\n                groovyHome = string.substring(\"-Dgroovy.home=\".length());\n            }\n        }\n        if (groovyHome == null) {\n            groovyHome = System.getProperty(\"groovy.home\");\n        }\n        if (groovyHome == null) {\n            groovyHome = System.getenv(\"GROOVY_HOME\");\n        }\n        if (groovyHome == null) {\n            throw new IllegalStateException(\"Neither ${groovy.home} nor GROOVY_HOME defined.\");\n        }\n        File jarDir = new File(groovyHome, \"embeddable\");\n        if (!jarDir.exists()) {\n            throw new IllegalStateException(\"GROOVY_HOME incorrectly defined. No embeddable directory found in: \" + groovyHome);\n        }\n        final File[] files = jarDir.listFiles();\n        for (int i = 0; i < files.length; i++) {\n            File file = files[i];\n            try {\n                log.debug(\"Adding jar to classpath: \" + file.getCanonicalPath());\n            } catch (IOException e) {\n                // ignore\n            }\n            path = super.createClasspath();\n            path.setLocation(file);\n        }\n    }","id":30148,"modified_method":"private void createClasspathParts() {\n        Path path;\n        if (classpath != null) {\n            path = super.createClasspath();\n            path.setPath(classpath.toString());\n        }\n\n        if (includeAntRuntime) {\n            path = super.createClasspath();\n            path.setPath(System.getProperty(\"java.class.path\"));\n        }\n        String groovyHome = null;\n        final String[] strings = getSysProperties().getVariables();\n        for (String prop : strings) {\n            if (prop.startsWith(\"-Dgroovy.home=\")) {\n                groovyHome = prop.substring(\"-Dgroovy.home=\".length());\n            }\n        }\n        if (groovyHome == null) {\n            groovyHome = System.getProperty(\"groovy.home\");\n        }\n        if (groovyHome == null) {\n            groovyHome = System.getenv(\"GROOVY_HOME\");\n        }\n        if (groovyHome == null) {\n            throw new IllegalStateException(\"Neither ${groovy.home} nor GROOVY_HOME defined.\");\n        }\n        File jarDir = new File(groovyHome, \"embeddable\");\n        if (!jarDir.exists()) {\n            throw new IllegalStateException(\"GROOVY_HOME incorrectly defined. No embeddable directory found in: \" + groovyHome);\n        }\n        final File[] files = jarDir.listFiles();\n        for (File file : files) {\n            try {\n                log.debug(\"Adding jar to classpath: \" + file.getCanonicalPath());\n            } catch (IOException e) {\n                // ignore\n            }\n            path = super.createClasspath();\n            path.setLocation(file);\n        }\n    }","commit_id":"98c21584c70657e25a4627a73164cee9b422327d","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * print any results in the statement.\n     *\n     * @param out the output PrintStream to print to\n     */\n    protected void printResults(PrintStream out) {\n        log.debug(\"printResults()\");\n        StringBuffer line = new StringBuffer();\n        out.println(line);\n        line = new StringBuffer();\n        out.println();\n    }","id":30149,"modified_method":"/**\n     * print any results in the statement.\n     *\n     * @param out the output PrintStream to print to\n     */\n    protected void printResults(PrintStream out) {\n        log.debug(\"printResults()\");\n        StringBuffer line = new StringBuffer();\n        out.println(line);\n        out.println();\n    }","commit_id":"98c21584c70657e25a4627a73164cee9b422327d","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Load the file and then execute it\n     */\n    public void execute() throws BuildException {\n        log.debug(\"execute()\");\n\n        command = command.trim();\n\n        if (srcFile == null && command.length() == 0\n                && filesets.isEmpty()) {\n            throw new BuildException(\"Source file does not exist!\", getLocation());\n        }\n\n        if (srcFile != null && !srcFile.exists()) {\n            throw new BuildException(\"Source file does not exist!\", getLocation());\n        }\n\n        // deal with the filesets\n        for (int i = 0; i < filesets.size(); i++) {\n            FileSet fs = (FileSet) filesets.elementAt(i);\n            DirectoryScanner ds = fs.getDirectoryScanner(getProject());\n            File srcDir = fs.getDir(getProject());\n            String[] srcFiles = ds.getIncludedFiles();\n        }\n\n        try {\n            PrintStream out = System.out;\n            try {\n                if (output != null) {\n                    log.verbose(\"Opening PrintStream to output file \" + output);\n                    out = new PrintStream(\n                            new BufferedOutputStream(\n                                    new FileOutputStream(output.getAbsolutePath(), append)));\n                }\n\n                // if there are no groovy statements between the enclosing Groovy tags\n                // then read groovy statements in from a text file using the src attribute\n                if (command == null || command.trim().length() == 0) {\n                    createClasspath().add(new Path(getProject(), srcFile.getParentFile().getCanonicalPath()));\n                    command = getText(new BufferedReader(new FileReader(srcFile)));\n                }\n\n                if (command != null) {\n                    execGroovy(command, out);\n                } else {\n                    throw new BuildException(\"Source file does not exist!\", getLocation());\n                }\n\n            } finally {\n                if (out != null && out != System.out) {\n                    out.close();\n                }\n            }\n        } catch (IOException e) {\n            throw new BuildException(e, getLocation());\n        }\n\n        log.verbose(\"statements executed successfully\");\n    }","id":30150,"modified_method":"/**\n     * Load the file and then execute it\n     */\n    public void execute() throws BuildException {\n        log.debug(\"execute()\");\n\n        command = command.trim();\n\n        if (srcFile == null && command.length() == 0 && filesets.isEmpty()) {\n            throw new BuildException(\"Source file does not exist!\", getLocation());\n        }\n\n        if (srcFile != null && !srcFile.exists()) {\n            throw new BuildException(\"Source file does not exist!\", getLocation());\n        }\n\n        // TODO: any of this used?\n        // deal with the filesets\n        for (int i = 0; i < filesets.size(); i++) {\n            FileSet fs = filesets.elementAt(i);\n            DirectoryScanner ds = fs.getDirectoryScanner(getProject());\n            File srcDir = fs.getDir(getProject());\n            String[] srcFiles = ds.getIncludedFiles();\n        }\n\n        try {\n            PrintStream out = System.out;\n            try {\n                if (output != null) {\n                    log.verbose(\"Opening PrintStream to output file \" + output);\n                    out = new PrintStream(\n                            new BufferedOutputStream(\n                                    new FileOutputStream(output.getAbsolutePath(), append)));\n                }\n\n                // if there are no groovy statements between the enclosing Groovy tags\n                // then read groovy statements in from a text file using the src attribute\n                if (command == null || command.trim().length() == 0) {\n                    createClasspath().add(new Path(getProject(), srcFile.getParentFile().getCanonicalPath()));\n                    command = getText(new BufferedReader(new FileReader(srcFile)));\n                }\n\n                if (command != null) {\n                    execGroovy(command, out);\n                } else {\n                    throw new BuildException(\"Source file does not exist!\", getLocation());\n                }\n\n            } finally {\n                if (out != null && out != System.out) {\n                    out.close();\n                }\n            }\n        } catch (IOException e) {\n            throw new BuildException(e, getLocation());\n        }\n\n        log.verbose(\"statements executed successfully\");\n    }","commit_id":"98c21584c70657e25a4627a73164cee9b422327d","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Try to build a script name for the script of the groovy task to have an helpful value in stack traces in case of exception\n     *\n     * @return the name to use when compiling the script\n     */\n    private String computeScriptName() {\n        if (srcFile != null) {\n            return srcFile.getAbsolutePath();\n        } else {\n            String name = PREFIX;\n            if (getLocation().getFileName().length() > 0)\n                name += getLocation().getFileName().replaceAll(\"[^\\\\w_\\\\.]\", \"_\");\n            else\n                name += SUFFIX;\n\n            return name;\n        }\n    }","id":30151,"modified_method":"/**\n     * Try to build a script name for the script of the groovy task to have an helpful value in stack traces in case of exception\n     *\n     * @return the name to use when compiling the script\n     */\n    private String computeScriptName() {\n        if (srcFile != null) {\n            return srcFile.getAbsolutePath();\n        } else {\n            String name = PREFIX;\n            if (getLocation().getFileName().length() > 0)\n                name += getLocation().getFileName().replaceAll(\"[^\\\\w_\\\\.]\", \"_\").replaceAll(\"[\\\\.]\", \"_dot_\");\n            else\n                name += SUFFIX;\n\n            return name;\n        }\n    }","commit_id":"98c21584c70657e25a4627a73164cee9b422327d","url":"https://github.com/apache/groovy"},{"original_method":"private void createNewArgs(String txt) throws IOException {\n        final String[] args = cmdline.getCommandline();\n        // Temporary file - delete on exit, create (assured unique name).\n        final File tempFile = FileUtils.getFileUtils().createTempFile(PREFIX, SUFFIX, null, true, true);\n        final String[] commandline = new String[args.length + 1];\n        DefaultGroovyMethods.write(tempFile, txt);\n        commandline[0] = tempFile.getCanonicalPath();\n        System.arraycopy(args, 0, commandline, 1, args.length);\n        super.clearArgs();\n        for (int i = 0; i < commandline.length; i++) {\n            final Commandline.Argument argument = super.createArg();\n            argument.setValue(commandline[i]);\n        }\n    }","id":30152,"modified_method":"private void createNewArgs(String txt) throws IOException {\n        final String[] args = cmdline.getCommandline();\n        // Temporary file - delete on exit, create (assured unique name).\n        final File tempFile = FileUtils.getFileUtils().createTempFile(PREFIX, SUFFIX, null, true, true);\n        final String[] commandline = new String[args.length + 1];\n        DefaultGroovyMethods.write(tempFile, txt);\n        commandline[0] = tempFile.getCanonicalPath();\n        System.arraycopy(args, 0, commandline, 1, args.length);\n        super.clearArgs();\n        for (String arg : commandline) {\n            final Commandline.Argument argument = super.createArg();\n            argument.setValue(arg);\n        }\n    }","commit_id":"98c21584c70657e25a4627a73164cee9b422327d","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Test that helpful \"file name\" appears in the stack trace and not just \"Script1\" \n     */\n    public void testFileNameInStackTrace() {\n    \ttestFileNameInStackTrace(\"groovyErrorMsg\", \"\\\\(embedded_script_in_.*GroovyTest.xml\");\n    \ttestFileNameInStackTrace(\"groovyErrorMsg_ExternalFile\", \"GroovyTest_errorMessage.groovy\");\n    }","id":30153,"modified_method":"/**\n     * Test that helpful \"file name\" appears in the stack trace and not just \"Script1\" \n     */\n    public void testFileNameInStackTrace() {\n    \ttestFileNameInStackTrace(\"groovyErrorMsg\", \"\\\\(embedded_script_in_.*GroovyTest_dot_xml\");\n    \ttestFileNameInStackTrace(\"groovyErrorMsg_ExternalFile\", \"GroovyTest_errorMessage.groovy\");\n    }","commit_id":"98c21584c70657e25a4627a73164cee9b422327d","url":"https://github.com/apache/groovy"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.UNSUSPECT:\n                bcast_task.removeSuspectedMember((Address)evt.getArg());\n                break;\n\n            case Event.CONNECT:\n                Object ret=down_prot.down(evt);\n                group_name=(String)evt.getArg();\n                srv_sock=Util.createServerSocket(bind_addr, start_port); // grab a random unused port above 10000\n                srv_sock_addr=new IpAddress(bind_addr, srv_sock.getLocalPort());\n                startServerSocket();\n                return ret;\n\n            case Event.DISCONNECT:\n                group_name=null;\n                String tmp, prefix=Global.THREAD_PREFIX;\n                int index;\n                tmp=srv_sock_handler != null? srv_sock_handler.getName() : null;\n                if(tmp != null) {\n                    index=tmp.indexOf(prefix);\n                    if(index > -1) {\n                        tmp=tmp.substring(0, index);\n                        srv_sock_handler.setName(tmp);\n                    }\n                }\n                synchronized(pinger_mutex) {\n                    tmp=pinger_thread != null? pinger_thread.getName() : null;\n                    if(tmp != null) {\n                        index=tmp.indexOf(prefix);\n                        if(index > -1) {\n                            tmp=tmp.substring(0, index);\n                            pinger_thread.setName(tmp);\n                        }\n                    }\n                }\n\n                stopServerSocket();\n\n                break;\n\n            case Event.VIEW_CHANGE:\n                View v=(View) evt.getArg();\n                Vector new_mbrs=v.getMembers();\n                down_prot.down(evt);\n\n                synchronized(this) {\n                    members.removeAllElements();\n                    members.addAll(new_mbrs);\n                    bcast_task.adjustSuspectedMembers(members);\n                    pingable_mbrs.removeAllElements();\n                    pingable_mbrs.addAll(members);\n                    if(log.isDebugEnabled()) log.debug(\"VIEW_CHANGE received: \" + members);\n\n                    // 1. Get the addr:pid cache from the coordinator (only if not already fetched)\n                    if(!got_cache_from_coord) {\n                        getCacheFromCoordinator();\n                        got_cache_from_coord=true;\n                    }\n\n                    // 2. Broadcast my own addr:sock to all members so they can update their cache\n                    if(!srv_sock_sent) {\n                        if(srv_sock_addr != null) {\n                            sendIHaveSockMessage(null, // send to all members\n                                    local_addr,\n                                    srv_sock_addr);\n                            srv_sock_sent=true;\n                        }\n                        else\n                            if(warn) log.warn(\"(VIEW_CHANGE): srv_sock_addr == null\");\n                    }\n\n                    // 3. Remove all entries in 'cache' which are not in the new membership\n                    Address mbr;\n                    for(Enumeration e=cache.keys(); e.hasMoreElements();) {\n                        mbr=(Address) e.nextElement();\n                        if(!members.contains(mbr))\n                            cache.remove(mbr);\n                    }\n\n                    if(members.size() > 1) {\n                        synchronized(pinger_mutex) {\n                            if(pinger_thread != null && pinger_thread.isAlive()) {\n                                Address tmp_ping_dest=determinePingDest();\n                                if(ping_dest != null && tmp_ping_dest != null && !ping_dest.equals(tmp_ping_dest)) {\n                                    interruptPingerThread(); // allows the thread to use the new socket\n                                }\n                            }\n                            else\n                                startPingerThread(); // only starts if not yet running\n                        }\n                    }\n                    else {\n                        ping_dest=null;\n                        stopPingerThread();\n                    }\n                }\n                return null; // we already passed down the event above\n\n            default:\n                return down_prot.down(evt);\n        }\n\n        return down_prot.down(evt);\n    }","id":30154,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.UNSUSPECT:\n                bcast_task.removeSuspectedMember((Address)evt.getArg());\n                break;\n\n            case Event.CONNECT:\n                Object ret=down_prot.down(evt);\n                group_name=(String)evt.getArg();\n                srv_sock=Util.createServerSocket(bind_addr, start_port); // grab a random unused port above 10000\n                srv_sock_addr=new IpAddress(bind_addr, srv_sock.getLocalPort());\n                startServerSocket();\n                return ret;\n\n            case Event.DISCONNECT:\n                group_name=null;\n                String tmp, prefix=Global.THREAD_PREFIX;\n                int index;\n                tmp=srv_sock_handler != null? srv_sock_handler.getName() : null;\n                if(tmp != null) {\n                    index=tmp.indexOf(prefix);\n                    if(index > -1) {\n                        tmp=tmp.substring(0, index);\n                        srv_sock_handler.setName(tmp);\n                    }\n                }\n                synchronized(pinger_mutex) {\n                    tmp=pinger_thread != null? pinger_thread.getName() : null;\n                    if(tmp != null) {\n                        index=tmp.indexOf(prefix);\n                        if(index > -1) {\n                            tmp=tmp.substring(0, index);\n                            pinger_thread.setName(tmp);\n                        }\n                    }\n                }\n\n                stopServerSocket();\n\n                break;\n\n            case Event.VIEW_CHANGE:\n                View v=(View) evt.getArg();\n                Vector<Address> new_mbrs=v.getMembers();\n                down_prot.down(evt);\n\n                synchronized(this) {\n                    members.removeAllElements();\n                    members.addAll(new_mbrs);\n                    bcast_task.adjustSuspectedMembers(members);\n                    pingable_mbrs.removeAllElements();\n                    pingable_mbrs.addAll(members);\n                    if(log.isDebugEnabled()) log.debug(\"VIEW_CHANGE received: \" + members);\n\n                    // 1. Get the addr:pid cache from the coordinator (only if not already fetched)\n                    if(!got_cache_from_coord) {\n                        getCacheFromCoordinator();\n                        got_cache_from_coord=true;\n                    }\n\n                    // 2. Broadcast my own addr:sock to all members so they can update their cache\n                    if(!srv_sock_sent) {\n                        if(srv_sock_addr != null) {\n                            sendIHaveSockMessage(null, // send to all members\n                                    local_addr,\n                                    srv_sock_addr);\n                            srv_sock_sent=true;\n                        }\n                        else\n                            if(warn) log.warn(\"(VIEW_CHANGE): srv_sock_addr == null\");\n                    }\n\n                    // 3. Remove all entries in 'cache' which are not in the new membership\n                    Address mbr;\n                    for(Enumeration e=cache.keys(); e.hasMoreElements();) {\n                        mbr=(Address) e.nextElement();\n                        if(!members.contains(mbr))\n                            cache.remove(mbr);\n                    }\n\n                    if(members.size() > 1) {\n                        synchronized(pinger_mutex) {\n                            if(pinger_thread != null && pinger_thread.isAlive()) {\n                                Address tmp_ping_dest=determinePingDest();\n                                if(ping_dest != null && tmp_ping_dest != null && !ping_dest.equals(tmp_ping_dest)) {\n                                    interruptPingerThread(); // allows the thread to use the new socket\n                                }\n                            }\n                            else\n                                startPingerThread(); // only starts if not yet running\n                        }\n                    }\n                    else {\n                        ping_dest=null;\n                        stopPingerThread();\n                    }\n                }\n                return null; // we already passed down the event above\n\n            default:\n                return down_prot.down(evt);\n        }\n\n        return down_prot.down(evt);\n    }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends a SUSPECT message to all group members. Only the coordinator (or the next member in line if the coord\n     * itself is suspected) will react to this message by installing a new view. To overcome the unreliability\n     * of the SUSPECT message (it may be lost because we are not above any retransmission layer), the following scheme\n     * is used: after sending the SUSPECT message, it is also added to the broadcast task, which will periodically\n     * re-send the SUSPECT until a view is received in which the suspected process is not a member anymore. The reason is\n     * that - at one point - either the coordinator or another participant taking over for a crashed coordinator, will\n     * react to the SUSPECT message and issue a new view, at which point the broadcast task stops.\n     */\n    void broadcastSuspectMessage(Address suspected_mbr) {\n        Message suspect_msg;\n        FdHeader hdr;\n\n        if(suspected_mbr == null) return;\n\n        if(trace) log.trace(\"suspecting \" + suspected_mbr + \" (own address is \" + local_addr + ')');\n\n        // 1. Send a SUSPECT message right away; the broadcast task will take some time to send it (sleeps first)\n        hdr=new FdHeader(FdHeader.SUSPECT);\n        hdr.mbrs=new HashSet(1);\n        hdr.mbrs.add(suspected_mbr);\n        suspect_msg=new Message();\n        suspect_msg.setFlag(Message.OOB);\n        suspect_msg.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, suspect_msg));\n\n        // 2. Add to broadcast task and start latter (if not yet running). The task will end when\n        //    suspected members are removed from the membership\n        bcast_task.addSuspectedMember(suspected_mbr);\n        if(stats) {\n            num_suspect_events++;\n            suspect_history.add(suspected_mbr);\n        }\n    }","id":30155,"modified_method":"/**\n     * Sends a SUSPECT message to all group members. Only the coordinator (or the next member in line if the coord\n     * itself is suspected) will react to this message by installing a new view. To overcome the unreliability\n     * of the SUSPECT message (it may be lost because we are not above any retransmission layer), the following scheme\n     * is used: after sending the SUSPECT message, it is also added to the broadcast task, which will periodically\n     * re-send the SUSPECT until a view is received in which the suspected process is not a member anymore. The reason is\n     * that - at one point - either the coordinator or another participant taking over for a crashed coordinator, will\n     * react to the SUSPECT message and issue a new view, at which point the broadcast task stops.\n     */\n    void broadcastSuspectMessage(Address suspected_mbr) {\n        Message suspect_msg;\n        FdHeader hdr;\n\n        if(suspected_mbr == null) return;\n\n        if(trace) log.trace(\"suspecting \" + suspected_mbr + \" (own address is \" + local_addr + ')');\n\n        // 1. Send a SUSPECT message right away; the broadcast task will take some time to send it (sleeps first)\n        hdr=new FdHeader(FdHeader.SUSPECT);\n        hdr.mbrs=new HashSet<Address>(1);\n        hdr.mbrs.add(suspected_mbr);\n        suspect_msg=new Message();\n        suspect_msg.setFlag(Message.OOB);\n        suspect_msg.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, suspect_msg));\n\n        // 2. Add to broadcast task and start latter (if not yet running). The task will end when\n        //    suspected members are removed from the membership\n        bcast_task.addSuspectedMember(suspected_mbr);\n        if(stats) {\n            num_suspect_events++;\n            suspect_history.add(suspected_mbr);\n        }\n    }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"private Address determinePingDest() {\n        Address tmp;\n\n        if(pingable_mbrs == null || pingable_mbrs.size() < 2 || local_addr == null)\n            return null;\n        for(int i=0; i < pingable_mbrs.size(); i++) {\n            tmp=(Address) pingable_mbrs.elementAt(i);\n            if(local_addr.equals(tmp)) {\n                if(i + 1 >= pingable_mbrs.size())\n                    return (Address) pingable_mbrs.elementAt(0);\n                else\n                    return (Address) pingable_mbrs.elementAt(i + 1);\n            }\n        }\n        return null;\n    }","id":30156,"modified_method":"private Address determinePingDest() {\n        Address tmp;\n\n        if(pingable_mbrs == null || pingable_mbrs.size() < 2 || local_addr == null)\n            return null;\n        for(int i=0; i < pingable_mbrs.size(); i++) {\n            tmp=pingable_mbrs.elementAt(i);\n            if(local_addr.equals(tmp)) {\n                if(i + 1 >= pingable_mbrs.size())\n                    return pingable_mbrs.elementAt(0);\n                else\n                    return pingable_mbrs.elementAt(i + 1);\n            }\n        }\n        return null;\n    }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n            int size;\n            type=in.readByte();\n            mbr=Util.readAddress(in);\n            sock_addr=(IpAddress)Util.readStreamable(IpAddress.class, in);\n            size=in.readInt();\n            if(size > 0) {\n                if(cachedAddrs == null)\n                    cachedAddrs=new Hashtable();\n                for(int i=0; i < size; i++) {\n                    Address key=Util.readAddress(in);\n                    IpAddress val=(IpAddress)Util.readStreamable(IpAddress.class, in);\n                    cachedAddrs.put(key, val);\n                }\n            }\n            size=in.readInt();\n            if(size > 0) {\n                if(mbrs == null)\n                    mbrs=new HashSet();\n                for(int i=0; i < size; i++) {\n                    Address addr=Util.readAddress(in);\n                    mbrs.add(addr);\n                }\n            }\n        }","id":30157,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n            int size;\n            type=in.readByte();\n            mbr=Util.readAddress(in);\n            sock_addr=(IpAddress)Util.readStreamable(IpAddress.class, in);\n            size=in.readInt();\n            if(size > 0) {\n                if(cachedAddrs == null)\n                    cachedAddrs=new Hashtable();\n                for(int i=0; i < size; i++) {\n                    Address key=Util.readAddress(in);\n                    IpAddress val=(IpAddress)Util.readStreamable(IpAddress.class, in);\n                    cachedAddrs.put(key, val);\n                }\n            }\n            size=in.readInt();\n            if(size > 0) {\n                if(mbrs == null)\n                    mbrs=new HashSet<Address>();\n                for(int i=0; i < size; i++) {\n                    Address addr=Util.readAddress(in);\n                    mbrs.add(addr);\n                }\n            }\n        }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address) evt.getArg();\n            break;\n\n        case Event.MSG:\n            Message msg=(Message) evt.getArg();\n            FdHeader hdr=(FdHeader) msg.getHeader(name);\n            if(hdr == null)\n                break;  // message did not originate from FD_SOCK layer, just pass up\n\n            switch(hdr.type) {\n\n            case FdHeader.SUSPECT:\n                if(hdr.mbrs != null) {\n                    if(log.isDebugEnabled()) log.debug(\"[SUSPECT] hdr=\" + hdr);\n                    for(Address m: hdr.mbrs) {\n                        if(local_addr != null && m.equals(local_addr)) {\n                            if(warn)\n                                log.warn(\"I was suspected by \" + msg.getSrc() + \"; ignoring the SUSPECT message\");\n                            continue;\n                        }\n                        up_prot.up(new Event(Event.SUSPECT, m));\n                        down_prot.down(new Event(Event.SUSPECT, m));\n                    }\n                }\n                else\n                    if(warn) log.warn(\"[SUSPECT]: hdr.mbrs == null\");\n                break;\n\n                // If I have the sock for 'hdr.mbr', return it. Otherwise look it up in my cache and return it\n            case FdHeader.WHO_HAS_SOCK:\n                if(local_addr != null && local_addr.equals(msg.getSrc()))\n                    return null; // don't reply to WHO_HAS bcasts sent by me !\n\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"hdr.mbr is null\");\n                    return null;\n                }\n\n                if(trace) log.trace(\"who-has-sock \" + hdr.mbr);\n\n                // 1. Try my own address, maybe it's me whose socket is wanted\n                if(local_addr != null && local_addr.equals(hdr.mbr) && srv_sock_addr != null) {\n                    sendIHaveSockMessage(msg.getSrc(), local_addr, srv_sock_addr);  // unicast message to msg.getSrc()\n                    return null;\n                }\n\n                // 2. If I don't have it, maybe it is in the cache\n                if(cache.containsKey(hdr.mbr))\n                    sendIHaveSockMessage(msg.getSrc(), hdr.mbr, (IpAddress) cache.get(hdr.mbr));  // ucast msg\n                break;\n\n\n                // Update the cache with the addr:sock_addr entry (if on the same host)\n            case FdHeader.I_HAVE_SOCK:\n                if(hdr.mbr == null || hdr.sock_addr == null) {\n                    if(log.isErrorEnabled()) log.error(\"[I_HAVE_SOCK]: hdr.mbr is null or hdr.sock_addr == null\");\n                    return null;\n                }\n\n                // if(!cache.containsKey(hdr.mbr))\n                cache.put(hdr.mbr, hdr.sock_addr); // update the cache\n                if(trace) log.trace(\"i-have-sock: \" + hdr.mbr + \" --> \" +\n                                                   hdr.sock_addr + \" (cache is \" + cache + ')');\n\n                if(ping_dest != null && hdr.mbr.equals(ping_dest))\n                    ping_addr_promise.setResult(hdr.sock_addr);\n                break;\n\n                // Return the cache to the sender of this message\n            case FdHeader.GET_CACHE:\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE): hdr.mbr == null\");\n                    return null;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE_RSP);\n                hdr.cachedAddrs=(Hashtable) cache.clone();\n                msg=new Message(hdr.mbr, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                break;\n\n            case FdHeader.GET_CACHE_RSP:\n                if(hdr.cachedAddrs == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE_RSP): cache is null\");\n                    return null;\n                }\n                get_cache_promise.setResult(hdr.cachedAddrs);\n                break;\n            }\n            return null;\n\n            case Event.CONFIG:\n                if(bind_addr == null) {\n                    Map config=(Map)evt.getArg();\n                    bind_addr=(InetAddress)config.get(\"bind_addr\");\n                }\n                break;\n        }\n\n        return up_prot.up(evt);                                        // pass up to the layer above us\n    }","id":30158,"modified_method":"public Object up(Event evt) {\n        switch(evt.getType()) {\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address) evt.getArg();\n            break;\n\n        case Event.MSG:\n            Message msg=(Message) evt.getArg();\n            FdHeader hdr=(FdHeader) msg.getHeader(name);\n            if(hdr == null)\n                break;  // message did not originate from FD_SOCK layer, just pass up\n\n            switch(hdr.type) {\n\n            case FdHeader.SUSPECT:\n                if(hdr.mbrs != null) {\n                    if(log.isDebugEnabled()) log.debug(\"[SUSPECT] hdr=\" + hdr);\n                    for(Address m: hdr.mbrs) {\n                        if(local_addr != null && m.equals(local_addr)) {\n                            if(warn)\n                                log.warn(\"I was suspected by \" + msg.getSrc() + \"; ignoring the SUSPECT message\");\n                            continue;\n                        }\n                        up_prot.up(new Event(Event.SUSPECT, m));\n                        down_prot.down(new Event(Event.SUSPECT, m));\n                    }\n                }\n                else\n                    if(warn) log.warn(\"[SUSPECT]: hdr.mbrs == null\");\n                break;\n\n                // If I have the sock for 'hdr.mbr', return it. Otherwise look it up in my cache and return it\n            case FdHeader.WHO_HAS_SOCK:\n                if(local_addr != null && local_addr.equals(msg.getSrc()))\n                    return null; // don't reply to WHO_HAS bcasts sent by me !\n\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"hdr.mbr is null\");\n                    return null;\n                }\n\n                if(trace) log.trace(\"who-has-sock \" + hdr.mbr);\n\n                // 1. Try my own address, maybe it's me whose socket is wanted\n                if(local_addr != null && local_addr.equals(hdr.mbr) && srv_sock_addr != null) {\n                    sendIHaveSockMessage(msg.getSrc(), local_addr, srv_sock_addr);  // unicast message to msg.getSrc()\n                    return null;\n                }\n\n                // 2. If I don't have it, maybe it is in the cache\n                if(cache.containsKey(hdr.mbr))\n                    sendIHaveSockMessage(msg.getSrc(), hdr.mbr, cache.get(hdr.mbr));  // ucast msg\n                break;\n\n\n                // Update the cache with the addr:sock_addr entry (if on the same host)\n            case FdHeader.I_HAVE_SOCK:\n                if(hdr.mbr == null || hdr.sock_addr == null) {\n                    if(log.isErrorEnabled()) log.error(\"[I_HAVE_SOCK]: hdr.mbr is null or hdr.sock_addr == null\");\n                    return null;\n                }\n\n                // if(!cache.containsKey(hdr.mbr))\n                cache.put(hdr.mbr, hdr.sock_addr); // update the cache\n                if(trace) log.trace(\"i-have-sock: \" + hdr.mbr + \" --> \" +\n                                                   hdr.sock_addr + \" (cache is \" + cache + ')');\n\n                if(ping_dest != null && hdr.mbr.equals(ping_dest))\n                    ping_addr_promise.setResult(hdr.sock_addr);\n                break;\n\n                // Return the cache to the sender of this message\n            case FdHeader.GET_CACHE:\n                if(hdr.mbr == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE): hdr.mbr == null\");\n                    return null;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE_RSP);\n                hdr.cachedAddrs=(Hashtable<Address,IpAddress>)cache.clone();\n                msg=new Message(hdr.mbr, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                break;\n\n            case FdHeader.GET_CACHE_RSP:\n                if(hdr.cachedAddrs == null) {\n                    if(log.isErrorEnabled()) log.error(\"(GET_CACHE_RSP): cache is null\");\n                    return null;\n                }\n                get_cache_promise.setResult(hdr.cachedAddrs);\n                break;\n            }\n            return null;\n\n            case Event.CONFIG:\n                if(bind_addr == null) {\n                    Map config=(Map)evt.getArg();\n                    bind_addr=(InetAddress)config.get(\"bind_addr\");\n                }\n                break;\n        }\n\n        return up_prot.up(evt);                                        // pass up to the layer above us\n    }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"public FdHeader(byte type, Hashtable cachedAddrs) {\n            this.type=type;\n            this.cachedAddrs=cachedAddrs;\n        }","id":30159,"modified_method":"public FdHeader(byte type, Hashtable<Address,IpAddress> cachedAddrs) {\n            this.type=type;\n            this.cachedAddrs=cachedAddrs;\n        }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Attempts to obtain the ping_addr first from the cache, then by unicasting q request to <code>mbr<\/code>,\n     then by multicasting a request to all members.\n     */\n    private IpAddress fetchPingAddress(Address mbr) {\n        IpAddress ret;\n        Message ping_addr_req;\n        FdHeader hdr;\n\n        if(mbr == null) {\n            if(log.isErrorEnabled()) log.error(\"mbr == null\");\n            return null;\n        }\n        // 1. Try to get from cache. Add a little delay so that joining mbrs can send their socket address before\n        //    we ask them to do so\n        ret=(IpAddress)cache.get(mbr);\n        if(ret != null) {\n            return ret;\n        }\n\n        Util.sleep(300);\n        if((ret=(IpAddress)cache.get(mbr)) != null)\n            return ret;\n\n\n        // 2. Try to get from mbr\n        ping_addr_promise.reset();\n        ping_addr_req=new Message(mbr, null, null); // unicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        if(!running) return null;\n        ret=(IpAddress)ping_addr_promise.getResult(3000);\n        if(ret != null) {\n            return ret;\n        }\n\n\n        // 3. Try to get from all members\n        ping_addr_req=new Message(null); // multicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        ret=(IpAddress) ping_addr_promise.getResult(3000);\n        return ret;\n    }","id":30160,"modified_method":"/**\n     Attempts to obtain the ping_addr first from the cache, then by unicasting q request to <code>mbr<\/code>,\n     then by multicasting a request to all members.\n     */\n    private IpAddress fetchPingAddress(Address mbr) {\n        IpAddress ret;\n        Message ping_addr_req;\n        FdHeader hdr;\n\n        if(mbr == null) {\n            if(log.isErrorEnabled()) log.error(\"mbr == null\");\n            return null;\n        }\n        // 1. Try to get from cache. Add a little delay so that joining mbrs can send their socket address before\n        //    we ask them to do so\n        ret=cache.get(mbr);\n        if(ret != null) {\n            return ret;\n        }\n\n        Util.sleep(300);\n        if((ret=cache.get(mbr)) != null)\n            return ret;\n\n\n        // 2. Try to get from mbr\n        ping_addr_promise.reset();\n        ping_addr_req=new Message(mbr, null, null); // unicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        if(!running) return null;\n        ret=(IpAddress)ping_addr_promise.getResult(3000);\n        if(ret != null) {\n            return ret;\n        }\n\n\n        // 3. Try to get from all members\n        ping_addr_req=new Message(null); // multicast\n        ping_addr_req.setFlag(Message.OOB);\n        hdr=new FdHeader(FdHeader.WHO_HAS_SOCK);\n        hdr.mbr=mbr;\n        ping_addr_req.putHeader(name, hdr);\n        down_prot.down(new Event(Event.MSG, ping_addr_req));\n        ret=(IpAddress) ping_addr_promise.getResult(3000);\n        return ret;\n    }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            type=in.readByte();\n            mbr=(Address) in.readObject();\n            sock_addr=(IpAddress) in.readObject();\n            cachedAddrs=(Hashtable) in.readObject();\n            mbrs=(Set)in.readObject();\n        }","id":30161,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            type=in.readByte();\n            mbr=(Address) in.readObject();\n            sock_addr=(IpAddress) in.readObject();\n            cachedAddrs=(Hashtable<Address,IpAddress>) in.readObject();\n            mbrs=(Set<Address>)in.readObject();\n        }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"ClientConnectionHandler(Socket client_sock, List clients) {\n            setName(\"ClientConnectionHandler\");\n            setDaemon(true);\n            this.client_sock=client_sock;\n            this.clients.addAll(clients);\n        }","id":30162,"modified_method":"ClientConnectionHandler(Socket client_sock, List<ClientConnectionHandler> clients) {\n            setName(\"ClientConnectionHandler\");\n            setDaemon(true);\n            this.client_sock=client_sock;\n            this.clients.addAll(clients);\n        }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            Message suspect_msg;\n            FdHeader hdr;\n\n            if(log.isDebugEnabled())\n                log.debug(\"broadcasting SUSPECT message (suspected_mbrs=\" + suspected_mbrs + \") to group\");\n\n            synchronized(suspected_mbrs) {\n                if(suspected_mbrs.isEmpty()) {\n                    stopTask();\n                    if(log.isDebugEnabled()) log.debug(\"task done (no suspected members)\");\n                    return;\n                }\n\n                hdr=new FdHeader(FdHeader.SUSPECT);\n                hdr.mbrs=new HashSet(suspected_mbrs);\n            }\n            suspect_msg=new Message();       // mcast SUSPECT to all members\n            suspect_msg.setFlag(Message.OOB);\n            suspect_msg.putHeader(name, hdr);\n            down_prot.down(new Event(Event.MSG, suspect_msg));\n            if(log.isDebugEnabled()) log.debug(\"task done\");\n        }","id":30163,"modified_method":"public void run() {\n            Message suspect_msg;\n            FdHeader hdr;\n\n            if(log.isDebugEnabled())\n                log.debug(\"broadcasting SUSPECT message (suspected_mbrs=\" + suspected_mbrs + \") to group\");\n\n            synchronized(suspected_mbrs) {\n                if(suspected_mbrs.isEmpty()) {\n                    stopTask();\n                    if(log.isDebugEnabled()) log.debug(\"task done (no suspected members)\");\n                    return;\n                }\n\n                hdr=new FdHeader(FdHeader.SUSPECT);\n                hdr.mbrs=new HashSet<Address>(suspected_mbrs);\n            }\n            suspect_msg=new Message();       // mcast SUSPECT to all members\n            suspect_msg.setFlag(Message.OOB);\n            suspect_msg.putHeader(name, hdr);\n            down_prot.down(new Event(Event.MSG, suspect_msg));\n            if(log.isDebugEnabled()) log.debug(\"task done\");\n        }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Determines coordinator C. If C is null and we are the first member, return. Else loop: send GET_CACHE message\n     * to coordinator and wait for GET_CACHE_RSP response. Loop until valid response has been received.\n     */\n    void getCacheFromCoordinator() {\n        Address coord;\n        int attempts=num_tries;\n        Message msg;\n        FdHeader hdr;\n        Hashtable result;\n\n        get_cache_promise.reset();\n        while(attempts > 0) {\n            if((coord=determineCoordinator()) != null) {\n                if(coord.equals(local_addr)) { // we are the first member --> empty cache\n                    if(log.isDebugEnabled()) log.debug(\"first member; cache is empty\");\n                    return;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE);\n                hdr.mbr=local_addr;\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                result=(Hashtable) get_cache_promise.getResult(get_cache_timeout);\n                if(result != null) {\n                    cache.putAll(result); // replace all entries (there should be none !) in cache with the new values\n                    if(trace) log.trace(\"got cache from \" + coord + \": cache is \" + cache);\n                    return;\n                }\n                else {\n                    if(log.isErrorEnabled()) log.error(\"received null cache; retrying\");\n                }\n            }\n\n            Util.sleep(get_cache_retry_timeout);\n            --attempts;\n        }\n    }","id":30164,"modified_method":"/**\n     * Determines coordinator C. If C is null and we are the first member, return. Else loop: send GET_CACHE message\n     * to coordinator and wait for GET_CACHE_RSP response. Loop until valid response has been received.\n     */\n    void getCacheFromCoordinator() {\n        Address coord;\n        int attempts=num_tries;\n        Message msg;\n        FdHeader hdr;\n        Hashtable<Address,IpAddress> result;\n\n        get_cache_promise.reset();\n        while(attempts > 0) {\n            if((coord=determineCoordinator()) != null) {\n                if(coord.equals(local_addr)) { // we are the first member --> empty cache\n                    if(log.isDebugEnabled()) log.debug(\"first member; cache is empty\");\n                    return;\n                }\n                hdr=new FdHeader(FdHeader.GET_CACHE);\n                hdr.mbr=local_addr;\n                msg=new Message(coord, null, null);\n                msg.setFlag(Message.OOB);\n                msg.putHeader(name, hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                result=(Hashtable<Address,IpAddress>) get_cache_promise.getResult(get_cache_timeout);\n                if(result != null) {\n                    cache.putAll(result); // replace all entries (there should be none !) in cache with the new values\n                    if(trace) log.trace(\"got cache from \" + coord + \": cache is \" + cache);\n                    return;\n                }\n                else {\n                    if(log.isErrorEnabled()) log.error(\"received null cache; retrying\");\n                }\n            }\n\n            Util.sleep(get_cache_retry_timeout);\n            --attempts;\n        }\n    }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"private void startTask() {\n            if(future == null || future.isDone()) {\n                future=timer.scheduleWithFixedDelay(this, suspect_msg_interval, suspect_msg_interval, TimeUnit.MILLISECONDS);\n            }\n        }","id":30165,"modified_method":"private void startTask() {\n            if(future == null || future.isDone()) {\n                try {\n                    future=timer.scheduleWithFixedDelay(this, suspect_msg_interval, suspect_msg_interval, TimeUnit.MILLISECONDS);\n                }\n                catch(RejectedExecutionException e) {\n                    if(warn)\n                        log.warn(\"task \" + this + \" was rejected as timer thread pool is shutting down\");\n                }\n            }\n        }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"Address determineCoordinator() {\n        return !members.isEmpty()? (Address) members.elementAt(0) : null;\n    }","id":30166,"modified_method":"Address determineCoordinator() {\n        return !members.isEmpty()? members.elementAt(0) : null;\n    }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"public FdHeader(byte type, Set mbrs) {\n            this.type=type;\n            this.mbrs=mbrs;\n        }","id":30167,"modified_method":"public FdHeader(byte type, Set<Address> mbrs) {\n            this.type=type;\n            this.mbrs=mbrs;\n        }","commit_id":"65090134548b0e9e00e433b395469e751aedd23d","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(id);\n            out.writeBoolean(rsp_expected);\n\n            if(corrName != null) {\n                out.writeBoolean(true);\n                out.writeUTF(corrName);\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            if(callStack != null) {\n                out.writeBoolean(true);\n                out.writeShort(callStack.size());\n                Address mbr;\n                for(int i=0; i < callStack.size(); i++) {\n                    mbr=(Address)callStack.elementAt(i);\n                    Util.writeAddress(mbr, out);\n                }\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            Util.writeAddresses(dest_mbrs, out);\n        }","id":30168,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n            out.writeByte(type);\n            out.writeLong(id);\n            out.writeBoolean(rsp_expected);\n\n            if(corrName != null) {\n                out.writeBoolean(true);\n                out.writeUTF(corrName);\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            if(callStack != null) {\n                out.writeBoolean(true);\n                out.writeShort(callStack.size());\n                Address mbr;\n                for(int i=0; i < callStack.size(); i++) {\n                    mbr=callStack.elementAt(i);\n                    Util.writeAddress(mbr, out);\n                }\n            }\n            else {\n                out.writeBoolean(false);\n            }\n\n            Util.writeAddresses(dest_mbrs, out);\n        }","commit_id":"691ad76be0406edf73eec93b1a4fc6459f37becb","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n            int retval=Global.BYTE_SIZE // type\n                    + Global.LONG_SIZE // id\n                    + Global.BYTE_SIZE; // rsp_expected\n\n            retval+=Global.BYTE_SIZE; // presence for corrName\n            if(corrName != null)\n                retval+=corrName.length() +2; // UTF\n\n            retval+=Global.BYTE_SIZE; // presence\n            if(callStack != null) {\n                retval+=Global.SHORT_SIZE; // number of elements\n                if(!callStack.isEmpty()) {\n                    Address mbr=(Address)callStack.firstElement();\n                    retval+=callStack.size() * (Util.size(mbr));\n                }\n            }\n\n            retval+=Util.size(dest_mbrs);\n            return retval;\n        }","id":30169,"modified_method":"public int size() {\n            int retval=Global.BYTE_SIZE // type\n                    + Global.LONG_SIZE // id\n                    + Global.BYTE_SIZE; // rsp_expected\n\n            retval+=Global.BYTE_SIZE; // presence for corrName\n            if(corrName != null)\n                retval+=corrName.length() +2; // UTF\n\n            retval+=Global.BYTE_SIZE; // presence\n            if(callStack != null) {\n                retval+=Global.SHORT_SIZE; // number of elements\n                if(!callStack.isEmpty()) {\n                    Address mbr=callStack.firstElement();\n                    retval+=callStack.size() * (Util.size(mbr));\n                }\n            }\n\n            retval+=Util.size(dest_mbrs);\n            return retval;\n        }","commit_id":"691ad76be0406edf73eec93b1a4fc6459f37becb","url":"https://github.com/belaban/JGroups"},{"original_method":"@Test\n\tpublic void testSchedulerFactoryBeanWithApplicationContext() throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tStaticApplicationContext ac = new StaticApplicationContext();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tSchedulerContext schedulerContext = new SchedulerContext();\n\t\tgiven(scheduler.getContext()).willReturn(schedulerContext);\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap schedulerContextMap = new HashMap();\n\t\tschedulerContextMap.put(\"testBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContextMap);\n\t\tschedulerFactoryBean.setApplicationContext(ac);\n\t\tschedulerFactoryBean.setApplicationContextSchedulerContextKey(\"appCtx\");\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t\tScheduler returnedScheduler = schedulerFactoryBean.getObject();\n\t\t\tassertEquals(tb, returnedScheduler.getContext().get(\"testBean\"));\n\t\t\tassertEquals(ac, returnedScheduler.getContext().get(\"appCtx\"));\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","id":30170,"modified_method":"@Test\n\tpublic void testSchedulerFactoryBeanWithApplicationContext() throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tStaticApplicationContext ac = new StaticApplicationContext();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tSchedulerContext schedulerContext = new SchedulerContext();\n\t\tgiven(scheduler.getContext()).willReturn(schedulerContext);\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap<String, Object> schedulerContextMap = new HashMap<String, Object>();\n\t\tschedulerContextMap.put(\"testBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContextMap);\n\t\tschedulerFactoryBean.setApplicationContext(ac);\n\t\tschedulerFactoryBean.setApplicationContextSchedulerContextKey(\"appCtx\");\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t\tScheduler returnedScheduler = schedulerFactoryBean.getObject();\n\t\t\tassertEquals(tb, returnedScheduler.getContext().get(\"testBean\"));\n\t\t\tassertEquals(ac, returnedScheduler.getContext().get(\"appCtx\"));\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testMethodInvokingJobDetailFactoryBeanWithListenerNames() throws Exception {\n\t\tTestMethodInvokingTask task = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\tmijdfb.setName(\"myJob1\");\n\t\tmijdfb.setGroup(Scheduler.DEFAULT_GROUP);\n\t\tmijdfb.setTargetObject(task);\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.setJobListenerNames(names);\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail = mijdfb.getObject();\n\t\tList result = Arrays.asList(jobDetail.getJobListenerNames());\n\t\tassertEquals(Arrays.asList(names), result);\n\t}","id":30171,"modified_method":"@Test\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void testMethodInvokingJobDetailFactoryBeanWithListenerNames() throws Exception {\n\t\tTestMethodInvokingTask task = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\tmijdfb.setName(\"myJob1\");\n\t\tmijdfb.setGroup(Scheduler.DEFAULT_GROUP);\n\t\tmijdfb.setTargetObject(task);\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.setJobListenerNames(names);\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail = mijdfb.getObject();\n\t\tassertArrayEquals(names, jobDetail.getJobListenerNames());\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void doTestSchedulerFactoryBean(boolean explicitJobDetail, boolean prototypeJob) throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tJobDetailBean jobDetail0 = new JobDetailBean();\n\t\tjobDetail0.setJobClass(Job.class);\n\t\tjobDetail0.setBeanName(\"myJob0\");\n\t\tMap jobData = new HashMap();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail0.setJobDataAsMap(jobData);\n\t\tjobDetail0.afterPropertiesSet();\n\t\tassertEquals(tb, jobDetail0.getJobDataMap().get(\"testBean\"));\n\n\t\tCronTriggerBean trigger0 = new CronTriggerBean();\n\t\ttrigger0.setBeanName(\"myTrigger0\");\n\t\ttrigger0.setJobDetail(jobDetail0);\n\t\ttrigger0.setCronExpression(\"0/1 * * * * ?\");\n\t\ttrigger0.afterPropertiesSet();\n\n\t\tTestMethodInvokingTask task1 = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tmijdfb.setBeanName(\"myJob1\");\n\t\tif (prototypeJob) {\n\t\t\tStaticListableBeanFactory beanFactory = new StaticListableBeanFactory();\n\t\t\tbeanFactory.addBean(\"task\", task1);\n\t\t\tmijdfb.setTargetBeanName(\"task\");\n\t\t\tmijdfb.setBeanFactory(beanFactory);\n\t\t}\n\t\telse {\n\t\t\tmijdfb.setTargetObject(task1);\n\t\t}\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail1 = mijdfb.getObject();\n\n\t\tSimpleTriggerBean trigger1 = new SimpleTriggerBean();\n\t\ttrigger1.setBeanName(\"myTrigger1\");\n\t\ttrigger1.setJobDetail(jobDetail1);\n\t\ttrigger1.setStartDelay(0);\n\t\ttrigger1.setRepeatInterval(20);\n\t\ttrigger1.afterPropertiesSet();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tgiven(scheduler.getContext()).willReturn(new SchedulerContext());\n\t\tgiven(scheduler.scheduleJob(trigger0)).willReturn(new Date());\n\t\tgiven(scheduler.scheduleJob(trigger1)).willReturn(new Date());\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap schedulerContext = new HashMap();\n\t\tschedulerContext.put(\"otherTestBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContext);\n\t\tif (explicitJobDetail) {\n\t\t\tschedulerFactoryBean.setJobDetails(new JobDetail[] {jobDetail0});\n\t\t}\n\t\tschedulerFactoryBean.setTriggers(new Trigger[] {trigger0, trigger1});\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).getJobDetail(\"myJob0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getJobDetail(\"myJob1\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).addJob(jobDetail0, true);\n\t\tverify(scheduler).addJob(jobDetail1, true);\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","id":30172,"modified_method":"private void doTestSchedulerFactoryBean(boolean explicitJobDetail, boolean prototypeJob) throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tJobDetailBean jobDetail0 = new JobDetailBean();\n\t\tjobDetail0.setJobClass(Job.class);\n\t\tjobDetail0.setBeanName(\"myJob0\");\n\t\tMap<String, Object> jobData = new HashMap<String, Object>();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail0.setJobDataAsMap(jobData);\n\t\tjobDetail0.afterPropertiesSet();\n\t\tassertEquals(tb, jobDetail0.getJobDataMap().get(\"testBean\"));\n\n\t\tCronTriggerBean trigger0 = new CronTriggerBean();\n\t\ttrigger0.setBeanName(\"myTrigger0\");\n\t\ttrigger0.setJobDetail(jobDetail0);\n\t\ttrigger0.setCronExpression(\"0/1 * * * * ?\");\n\t\ttrigger0.afterPropertiesSet();\n\n\t\tTestMethodInvokingTask task1 = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tmijdfb.setBeanName(\"myJob1\");\n\t\tif (prototypeJob) {\n\t\t\tStaticListableBeanFactory beanFactory = new StaticListableBeanFactory();\n\t\t\tbeanFactory.addBean(\"task\", task1);\n\t\t\tmijdfb.setTargetBeanName(\"task\");\n\t\t\tmijdfb.setBeanFactory(beanFactory);\n\t\t}\n\t\telse {\n\t\t\tmijdfb.setTargetObject(task1);\n\t\t}\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail1 = mijdfb.getObject();\n\n\t\tSimpleTriggerBean trigger1 = new SimpleTriggerBean();\n\t\ttrigger1.setBeanName(\"myTrigger1\");\n\t\ttrigger1.setJobDetail(jobDetail1);\n\t\ttrigger1.setStartDelay(0);\n\t\ttrigger1.setRepeatInterval(20);\n\t\ttrigger1.afterPropertiesSet();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tgiven(scheduler.getContext()).willReturn(new SchedulerContext());\n\t\tgiven(scheduler.scheduleJob(trigger0)).willReturn(new Date());\n\t\tgiven(scheduler.scheduleJob(trigger1)).willReturn(new Date());\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap<String, Object> schedulerContext = new HashMap<String, Object>();\n\t\tschedulerContext.put(\"otherTestBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContext);\n\t\tif (explicitJobDetail) {\n\t\t\tschedulerFactoryBean.setJobDetails(new JobDetail[] {jobDetail0});\n\t\t}\n\t\tschedulerFactoryBean.setTriggers(new Trigger[] {trigger0, trigger1});\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).getJobDetail(\"myJob0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getJobDetail(\"myJob1\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).addJob(jobDetail0, true);\n\t\tverify(scheduler).addJob(jobDetail1, true);\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testSimpleTriggerBeanWithListenerNames() {\n\t\tSimpleTriggerBean trigger = new SimpleTriggerBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\ttrigger.setTriggerListenerNames(names);\n\t\tList result = Arrays.asList(trigger.getTriggerListenerNames());\n\t\tassertEquals(Arrays.asList(names), result);\n\t}","id":30173,"modified_method":"@Test\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void testSimpleTriggerBeanWithListenerNames() {\n\t\tSimpleTriggerBean trigger = new SimpleTriggerBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\ttrigger.setTriggerListenerNames(names);\n\t\tassertArrayEquals(names, trigger.getTriggerListenerNames());\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testJobDetailBeanWithListenerNames() {\n\t\tJobDetailBean jobDetail = new JobDetailBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\tjobDetail.setJobListenerNames(names);\n\t\tList result = Arrays.asList(jobDetail.getJobListenerNames());\n\t\tassertEquals(Arrays.asList(names), result);\n\t}","id":30174,"modified_method":"@Test\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void testJobDetailBeanWithListenerNames() {\n\t\tJobDetailBean jobDetail = new JobDetailBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\tjobDetail.setJobListenerNames(names);\n\t\tassertArrayEquals(names, jobDetail.getJobListenerNames());\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void doTestSchedulerFactoryBeanWithExistingJobs(boolean overwrite) throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tJobDetailBean jobDetail0 = new JobDetailBean();\n\t\tjobDetail0.setJobClass(Job.class);\n\t\tjobDetail0.setBeanName(\"myJob0\");\n\t\tMap jobData = new HashMap();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail0.setJobDataAsMap(jobData);\n\t\tjobDetail0.afterPropertiesSet();\n\t\tassertEquals(tb, jobDetail0.getJobDataMap().get(\"testBean\"));\n\n\t\tCronTriggerBean trigger0 = new CronTriggerBean();\n\t\ttrigger0.setBeanName(\"myTrigger0\");\n\t\ttrigger0.setJobDetail(jobDetail0);\n\t\ttrigger0.setCronExpression(\"0/1 * * * * ?\");\n\t\ttrigger0.afterPropertiesSet();\n\n\t\tTestMethodInvokingTask task1 = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tmijdfb.setBeanName(\"myJob1\");\n\t\tmijdfb.setTargetObject(task1);\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail1 = mijdfb.getObject();\n\n\t\tSimpleTriggerBean trigger1 = new SimpleTriggerBean();\n\t\ttrigger1.setBeanName(\"myTrigger1\");\n\t\ttrigger1.setJobDetail(jobDetail1);\n\t\ttrigger1.setStartDelay(0);\n\t\ttrigger1.setRepeatInterval(20);\n\t\ttrigger1.afterPropertiesSet();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tgiven(scheduler.getContext()).willReturn(new SchedulerContext());\n\t\tgiven(scheduler.rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1)).willReturn(new Date());\n\t\tgiven(scheduler.getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP)).willReturn(new SimpleTrigger());\n\t\tgiven(scheduler.scheduleJob(trigger0)).willReturn(new Date());\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap schedulerContext = new HashMap();\n\t\tschedulerContext.put(\"otherTestBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContext);\n\t\tschedulerFactoryBean.setTriggers(new Trigger[] {trigger0, trigger1});\n\t\tif (overwrite) {\n\t\t\tschedulerFactoryBean.setOverwriteExistingJobs(true);\n\t\t}\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).getTrigger(\"myTrigger0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP);\n\t\tif (overwrite) {\n\t\t\tverify(scheduler).addJob(jobDetail1, true);\n\t\t\tverify(scheduler).rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1);\n\t\t}\n\t\telse {\n\t\t\tverify(scheduler).getJobDetail(\"myJob0\", Scheduler.DEFAULT_GROUP);\n\t\t}\n\t\tverify(scheduler).addJob(jobDetail0, true);\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","id":30175,"modified_method":"private void doTestSchedulerFactoryBeanWithExistingJobs(boolean overwrite) throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tJobDetailBean jobDetail0 = new JobDetailBean();\n\t\tjobDetail0.setJobClass(Job.class);\n\t\tjobDetail0.setBeanName(\"myJob0\");\n\t\tMap<String, Object> jobData = new HashMap<String, Object>();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail0.setJobDataAsMap(jobData);\n\t\tjobDetail0.afterPropertiesSet();\n\t\tassertEquals(tb, jobDetail0.getJobDataMap().get(\"testBean\"));\n\n\t\tCronTriggerBean trigger0 = new CronTriggerBean();\n\t\ttrigger0.setBeanName(\"myTrigger0\");\n\t\ttrigger0.setJobDetail(jobDetail0);\n\t\ttrigger0.setCronExpression(\"0/1 * * * * ?\");\n\t\ttrigger0.afterPropertiesSet();\n\n\t\tTestMethodInvokingTask task1 = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tmijdfb.setBeanName(\"myJob1\");\n\t\tmijdfb.setTargetObject(task1);\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail1 = mijdfb.getObject();\n\n\t\tSimpleTriggerBean trigger1 = new SimpleTriggerBean();\n\t\ttrigger1.setBeanName(\"myTrigger1\");\n\t\ttrigger1.setJobDetail(jobDetail1);\n\t\ttrigger1.setStartDelay(0);\n\t\ttrigger1.setRepeatInterval(20);\n\t\ttrigger1.afterPropertiesSet();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tgiven(scheduler.getContext()).willReturn(new SchedulerContext());\n\t\tgiven(scheduler.rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1)).willReturn(new Date());\n\t\tgiven(scheduler.getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP)).willReturn(new SimpleTrigger());\n\t\tgiven(scheduler.scheduleJob(trigger0)).willReturn(new Date());\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap<String, Object> schedulerContext = new HashMap<String, Object>();\n\t\tschedulerContext.put(\"otherTestBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContext);\n\t\tschedulerFactoryBean.setTriggers(new Trigger[] {trigger0, trigger1});\n\t\tif (overwrite) {\n\t\t\tschedulerFactoryBean.setOverwriteExistingJobs(true);\n\t\t}\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).getTrigger(\"myTrigger0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP);\n\t\tif (overwrite) {\n\t\t\tverify(scheduler).addJob(jobDetail1, true);\n\t\t\tverify(scheduler).rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1);\n\t\t}\n\t\telse {\n\t\t\tverify(scheduler).getJobDetail(\"myJob0\", Scheduler.DEFAULT_GROUP);\n\t\t}\n\t\tverify(scheduler).addJob(jobDetail0, true);\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testCronTriggerBeanWithListenerNames() {\n\t\tCronTriggerBean trigger = new CronTriggerBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\ttrigger.setTriggerListenerNames(names);\n\t\tList result = Arrays.asList(trigger.getTriggerListenerNames());\n\t\tassertEquals(Arrays.asList(names), result);\n\t}","id":30176,"modified_method":"@Test\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void testCronTriggerBeanWithListenerNames() {\n\t\tCronTriggerBean trigger = new CronTriggerBean();\n\t\tString[] names = new String[] {\"test1\", \"test2\"};\n\t\ttrigger.setTriggerListenerNames(names);\n\t\tassertArrayEquals(names, trigger.getTriggerListenerNames());\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testJobDetailBeanWithApplicationContext() throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tStaticApplicationContext ac = new StaticApplicationContext();\n\n\t\tJobDetailBean jobDetail = new JobDetailBean();\n\t\tjobDetail.setJobClass(Job.class);\n\t\tjobDetail.setBeanName(\"myJob0\");\n\t\tMap jobData = new HashMap();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail.setJobDataAsMap(jobData);\n\t\tjobDetail.setApplicationContext(ac);\n\t\tjobDetail.setApplicationContextJobDataKey(\"appCtx\");\n\t\tjobDetail.afterPropertiesSet();\n\n\t\tassertEquals(tb, jobDetail.getJobDataMap().get(\"testBean\"));\n\t\tassertEquals(ac, jobDetail.getJobDataMap().get(\"appCtx\"));\n\t}","id":30177,"modified_method":"@Test\n\tpublic void testJobDetailBeanWithApplicationContext() throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tStaticApplicationContext ac = new StaticApplicationContext();\n\n\t\tJobDetailBean jobDetail = new JobDetailBean();\n\t\tjobDetail.setJobClass(Job.class);\n\t\tjobDetail.setBeanName(\"myJob0\");\n\t\tMap<String, Object> jobData = new HashMap<String, Object>();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail.setJobDataAsMap(jobData);\n\t\tjobDetail.setApplicationContext(ac);\n\t\tjobDetail.setApplicationContextJobDataKey(\"appCtx\");\n\t\tjobDetail.afterPropertiesSet();\n\n\t\tassertEquals(tb, jobDetail.getJobDataMap().get(\"testBean\"));\n\t\tassertEquals(ac, jobDetail.getJobDataMap().get(\"appCtx\"));\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void doTestSchedulerFactoryBeanWithExistingJobsAndRaceCondition(boolean overwrite) throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tJobDetailBean jobDetail0 = new JobDetailBean();\n\t\tjobDetail0.setJobClass(Job.class);\n\t\tjobDetail0.setBeanName(\"myJob0\");\n\t\tMap jobData = new HashMap();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail0.setJobDataAsMap(jobData);\n\t\tjobDetail0.afterPropertiesSet();\n\t\tassertEquals(tb, jobDetail0.getJobDataMap().get(\"testBean\"));\n\n\t\tCronTriggerBean trigger0 = new CronTriggerBean();\n\t\ttrigger0.setBeanName(\"myTrigger0\");\n\t\ttrigger0.setJobDetail(jobDetail0);\n\t\ttrigger0.setCronExpression(\"0/1 * * * * ?\");\n\t\ttrigger0.afterPropertiesSet();\n\n\t\tTestMethodInvokingTask task1 = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tmijdfb.setBeanName(\"myJob1\");\n\t\tmijdfb.setTargetObject(task1);\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail1 = mijdfb.getObject();\n\n\t\tSimpleTriggerBean trigger1 = new SimpleTriggerBean();\n\t\ttrigger1.setBeanName(\"myTrigger1\");\n\t\ttrigger1.setJobDetail(jobDetail1);\n\t\ttrigger1.setStartDelay(0);\n\t\ttrigger1.setRepeatInterval(20);\n\t\ttrigger1.afterPropertiesSet();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tgiven(scheduler.getContext()).willReturn(new SchedulerContext());\n\t\tgiven(scheduler.getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP)).willReturn(new SimpleTrigger());\n\t\tif (overwrite) {\n\t\t\tgiven(scheduler.rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1)).willReturn(new Date());\n\t\t}\n\t\tgiven(scheduler.scheduleJob(trigger0)).willThrow(new ObjectAlreadyExistsException(\"\"));\n\t\tif (overwrite) {\n\t\t\tgiven(scheduler.rescheduleJob(\"myTrigger0\", Scheduler.DEFAULT_GROUP, trigger0)).willReturn(new Date());\n\t\t}\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap schedulerContext = new HashMap();\n\t\tschedulerContext.put(\"otherTestBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContext);\n\t\tschedulerFactoryBean.setTriggers(new Trigger[] {trigger0, trigger1});\n\t\tif (overwrite) {\n\t\t\tschedulerFactoryBean.setOverwriteExistingJobs(true);\n\t\t}\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).getTrigger(\"myTrigger0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP);\n\t\tif (overwrite) {\n\t\t\tverify(scheduler).addJob(jobDetail1, true);\n\t\t\tverify(scheduler).rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1);\n\t\t}\n\t\telse {\n\t\t\tverify(scheduler).getJobDetail(\"myJob0\", Scheduler.DEFAULT_GROUP);\n\t\t}\n\t\tverify(scheduler).addJob(jobDetail0, true);\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","id":30178,"modified_method":"private void doTestSchedulerFactoryBeanWithExistingJobsAndRaceCondition(boolean overwrite) throws Exception {\n\t\tTestBean tb = new TestBean(\"tb\", 99);\n\t\tJobDetailBean jobDetail0 = new JobDetailBean();\n\t\tjobDetail0.setJobClass(Job.class);\n\t\tjobDetail0.setBeanName(\"myJob0\");\n\t\tMap<String, Object> jobData = new HashMap<String, Object>();\n\t\tjobData.put(\"testBean\", tb);\n\t\tjobDetail0.setJobDataAsMap(jobData);\n\t\tjobDetail0.afterPropertiesSet();\n\t\tassertEquals(tb, jobDetail0.getJobDataMap().get(\"testBean\"));\n\n\t\tCronTriggerBean trigger0 = new CronTriggerBean();\n\t\ttrigger0.setBeanName(\"myTrigger0\");\n\t\ttrigger0.setJobDetail(jobDetail0);\n\t\ttrigger0.setCronExpression(\"0/1 * * * * ?\");\n\t\ttrigger0.afterPropertiesSet();\n\n\t\tTestMethodInvokingTask task1 = new TestMethodInvokingTask();\n\t\tMethodInvokingJobDetailFactoryBean mijdfb = new MethodInvokingJobDetailFactoryBean();\n\t\tmijdfb.setBeanName(\"myJob1\");\n\t\tmijdfb.setTargetObject(task1);\n\t\tmijdfb.setTargetMethod(\"doSomething\");\n\t\tmijdfb.afterPropertiesSet();\n\t\tJobDetail jobDetail1 = mijdfb.getObject();\n\n\t\tSimpleTriggerBean trigger1 = new SimpleTriggerBean();\n\t\ttrigger1.setBeanName(\"myTrigger1\");\n\t\ttrigger1.setJobDetail(jobDetail1);\n\t\ttrigger1.setStartDelay(0);\n\t\ttrigger1.setRepeatInterval(20);\n\t\ttrigger1.afterPropertiesSet();\n\n\t\tfinal Scheduler scheduler = mock(Scheduler.class);\n\t\tgiven(scheduler.getContext()).willReturn(new SchedulerContext());\n\t\tgiven(scheduler.getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP)).willReturn(new SimpleTrigger());\n\t\tif (overwrite) {\n\t\t\tgiven(scheduler.rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1)).willReturn(new Date());\n\t\t}\n\t\tgiven(scheduler.scheduleJob(trigger0)).willThrow(new ObjectAlreadyExistsException(\"\"));\n\t\tif (overwrite) {\n\t\t\tgiven(scheduler.rescheduleJob(\"myTrigger0\", Scheduler.DEFAULT_GROUP, trigger0)).willReturn(new Date());\n\t\t}\n\n\t\tSchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean() {\n\t\t\t@Override\n\t\t\tprotected Scheduler createScheduler(SchedulerFactory schedulerFactory, String schedulerName) {\n\t\t\t\treturn scheduler;\n\t\t\t}\n\t\t};\n\t\tschedulerFactoryBean.setJobFactory(null);\n\t\tMap<String, Object> schedulerContext = new HashMap<String, Object>();\n\t\tschedulerContext.put(\"otherTestBean\", tb);\n\t\tschedulerFactoryBean.setSchedulerContextAsMap(schedulerContext);\n\t\tschedulerFactoryBean.setTriggers(new Trigger[] {trigger0, trigger1});\n\t\tif (overwrite) {\n\t\t\tschedulerFactoryBean.setOverwriteExistingJobs(true);\n\t\t}\n\t\ttry {\n\t\t\tschedulerFactoryBean.afterPropertiesSet();\n\t\t\tschedulerFactoryBean.start();\n\t\t}\n\t\tfinally {\n\t\t\tschedulerFactoryBean.destroy();\n\t\t}\n\n\t\tverify(scheduler).getTrigger(\"myTrigger0\", Scheduler.DEFAULT_GROUP);\n\t\tverify(scheduler).getTrigger(\"myTrigger1\", Scheduler.DEFAULT_GROUP);\n\t\tif (overwrite) {\n\t\t\tverify(scheduler).addJob(jobDetail1, true);\n\t\t\tverify(scheduler).rescheduleJob(\"myTrigger1\", Scheduler.DEFAULT_GROUP, trigger1);\n\t\t}\n\t\telse {\n\t\t\tverify(scheduler).getJobDetail(\"myJob0\", Scheduler.DEFAULT_GROUP);\n\t\t}\n\t\tverify(scheduler).addJob(jobDetail0, true);\n\t\tverify(scheduler).start();\n\t\tverify(scheduler).shutdown(false);\n\t}","commit_id":"c8f2e0718231004021c78c65d5378036f943fdc4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@NotNull\n  private Head readHead() {\n    String headContent = RepositoryUtil.tryLoadFile(myHeadFile);\n    headContent = headContent.trim(); // remove possible leading and trailing spaces to clearly match regexps\n\n    Matcher matcher = BRANCH_PATTERN.matcher(headContent);\n    if (matcher.matches()) {\n      return new Head(true, matcher.group(1));\n    }\n\n    if (COMMIT_PATTERN.matcher(headContent).matches()) {\n      return new Head(false, headContent);\n    }\n    matcher = BRANCH_WEAK_PATTERN.matcher(headContent);\n    if (matcher.matches()) {\n      LOG.info(\".git/HEAD has not standard format: [\" + headContent + \"]. We've parsed branch [\" + matcher.group(1) + \"]\");\n      return new Head(true, matcher.group(1));\n    }\n    throw new RepoStateException(\"Invalid format of the .git/HEAD file: \\n\" + headContent);\n  }","id":30179,"modified_method":"@NotNull\n  private Head readHead() {\n    String headContent = RepositoryUtil.tryLoadFile(myHeadFile);\n    Matcher matcher = BRANCH_PATTERN.matcher(headContent);\n    if (matcher.matches()) {\n      return new Head(true, matcher.group(1));\n    }\n\n    if (COMMIT_PATTERN.matcher(headContent).matches()) {\n      return new Head(false, headContent);\n    }\n    matcher = BRANCH_WEAK_PATTERN.matcher(headContent);\n    if (matcher.matches()) {\n      LOG.info(\".git/HEAD has not standard format: [\" + headContent + \"]. We've parsed branch [\" + matcher.group(1) + \"]\");\n      return new Head(true, matcher.group(1));\n    }\n    throw new RepoStateException(\"Invalid format of the .git/HEAD file: \\n\" + headContent);\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static String readBranchFile(@NotNull File branchFile) {\n    String rev = RepositoryUtil.tryLoadFile(branchFile);\n    return rev.trim();\n  }","id":30180,"modified_method":"@NotNull\n  private static String readBranchFile(@NotNull File branchFile) {\n    return RepositoryUtil.tryLoadFile(branchFile);\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Reads {@code .git/rebase-apply/head-name} or {@code .git/rebase-merge/head-name} to find out the branch which is currently being rebased,\n   * and returns the {@link GitBranch} for the branch name written there, or null if these files don't exist.\n   */\n  @Nullable\n  private GitLocalBranch readRebaseBranch(@NonNls String rebaseDirName) {\n    File rebaseDir = new File(myGitDir, rebaseDirName);\n    if (!rebaseDir.exists()) {\n      return null;\n    }\n    final File headName = new File(rebaseDir, \"head-name\");\n    if (!headName.exists()) {\n      return null;\n    }\n    String branchName = RepositoryUtil.tryLoadFile(headName).trim();\n    File branchFile = findBranchFile(branchName);\n    if (!branchFile.exists()) { // can happen when rebasing from detached HEAD: IDEA-93806\n      return null;\n    }\n    Hash hash = Hash.create(readBranchFile(branchFile));\n    if (branchName.startsWith(REFS_HEADS_PREFIX)) {\n      branchName = branchName.substring(REFS_HEADS_PREFIX.length());\n    }\n    return new GitLocalBranch(branchName, hash);\n  }","id":30181,"modified_method":"/**\n   * Reads {@code .git/rebase-apply/head-name} or {@code .git/rebase-merge/head-name} to find out the branch which is currently being rebased,\n   * and returns the {@link GitBranch} for the branch name written there, or null if these files don't exist.\n   */\n  @Nullable\n  private GitLocalBranch readRebaseBranch(@NonNls String rebaseDirName) {\n    File rebaseDir = new File(myGitDir, rebaseDirName);\n    if (!rebaseDir.exists()) {\n      return null;\n    }\n    File headName = new File(rebaseDir, \"head-name\");\n    if (!headName.exists()) {\n      return null;\n    }\n    String branchName = RepositoryUtil.tryLoadFile(headName);\n    File branchFile = findBranchFile(branchName);\n    if (!branchFile.exists()) { // can happen when rebasing from detached HEAD: IDEA-93806\n      return null;\n    }\n    Hash hash = Hash.create(readBranchFile(branchFile));\n    if (branchName.startsWith(REFS_HEADS_PREFIX)) {\n      branchName = branchName.substring(REFS_HEADS_PREFIX.length());\n    }\n    return new GitLocalBranch(branchName, hash);\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static String loadHashFromBranchFile(@NotNull File branchFile) {\n    try {\n      return RepositoryUtil.tryLoadFile(branchFile).trim();\n    }\n    catch (RepoStateException e) {  // notify about error but don't break the process\n      LOG.error(\"Couldn't read \" + branchFile, e);\n    }\n    return null;\n  }","id":30182,"modified_method":"@Nullable\n  private static String loadHashFromBranchFile(@NotNull File branchFile) {\n    try {\n      return RepositoryUtil.tryLoadFile(branchFile);\n    }\n    catch (RepoStateException e) {  // notify about error but don't break the process\n      LOG.error(\"Couldn't read \" + branchFile, e);\n    }\n    return null;\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public List<String> readBranches() {\n    List<String> branches = new ArrayList<String>();\n    if (!checkIsFresh()) {\n      String[] branchesWithHeads = RepositoryUtil.tryLoadFile(myBranchHeadsFile).trim().split(\"\\n\");\n      // first one - is a head revision: head hash + head number;\n      for (int i = 1; i < branchesWithHeads.length; ++i) {\n        Matcher matcher = BRANCH_PATTERN.matcher(branchesWithHeads[i]);\n        if (matcher.matches()) {\n          branches.add(matcher.group(2));\n        }\n      }\n    }\n    return branches;\n  }","id":30183,"modified_method":"@NotNull\n  public List<String> readBranches() {\n    List<String> branches = new ArrayList<String>();\n    if (!checkIsFresh()) {\n      String[] branchesWithHeads = RepositoryUtil.tryLoadFile(myBranchHeadsFile).split(\"\\n\");\n      // first one - is a head revision: head hash + head number;\n      for (int i = 1; i < branchesWithHeads.length; ++i) {\n        Matcher matcher = BRANCH_PATTERN.matcher(branchesWithHeads[i]);\n        if (matcher.matches()) {\n          branches.add(matcher.group(2));\n        }\n      }\n    }\n    return branches;\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Finds current revision value.\n   *\n   * @return The current revision hash, or <b>{@code null}<\/b> if current revision is unknown - it is the initial repository state.\n   */\n  @Nullable\n  public String readCurrentRevision() {\n    if (checkIsFresh()) return null;\n    String[] branchesWithHeads = RepositoryUtil.tryLoadFile(myBranchHeadsFile).trim().split(\"\\n\");\n    String head = branchesWithHeads[0];\n    Matcher matcher = BRANCH_PATTERN.matcher(head);\n    if (matcher.matches()) {\n      return (matcher.group(1));\n    }\n    return null;\n  }","id":30184,"modified_method":"/**\n   * Finds current revision value.\n   *\n   * @return The current revision hash, or <b>{@code null}<\/b> if current revision is unknown - it is the initial repository state.\n   */\n  @Nullable\n  public String readCurrentRevision() {\n    if (checkIsFresh()) return null;\n    String[] branchesWithHeads = RepositoryUtil.tryLoadFile(myBranchHeadsFile).split(\"\\n\");\n    String head = branchesWithHeads[0];\n    Matcher matcher = BRANCH_PATTERN.matcher(head);\n    if (matcher.matches()) {\n      return (matcher.group(1));\n    }\n    return null;\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Repository.State readState() {\n    if (isMergeInProgress()) {\n      return Repository.State.MERGING;\n    }\n    return Repository.State.NORMAL;\n  }","id":30185,"modified_method":"@NotNull\n  public Repository.State readState() {\n    return isMergeInProgress() ? Repository.State.MERGING : Repository.State.NORMAL;\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isMergeInProgress() {\n    File mergeFile = new File(myHgDir, \"merge\");\n    return mergeFile.exists();\n  }","id":30186,"modified_method":"public boolean isMergeInProgress() {\n    return new File(myHgDir, \"merge\").exists();\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Return current branch\n   */\n  @NotNull\n  public String readCurrentBranch() {\n    if (branchExist()) {\n      String rev = RepositoryUtil.tryLoadFile(myCurrentBranch);\n      return rev.trim();\n    }\n    return HgRepository.DEFAULT_BRANCH;\n  }","id":30187,"modified_method":"/**\n   * Return current branch\n   */\n  @NotNull\n  public String readCurrentBranch() {\n    return branchExist() ? RepositoryUtil.tryLoadFile(myCurrentBranch) : HgRepository.DEFAULT_BRANCH;\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Loads the file content.\n   * Tries 3 times, then a {@link RepoStateException} is thrown.\n   *\n   * @param file File to read.\n   * @return file content.\n   */\n  @NotNull\n  public static String tryLoadFile(final File file) {\n    return tryOrThrow(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        return FileUtil.loadFile(file);\n      }\n    }, file);\n  }","id":30188,"modified_method":"/**\n   * Loads the file content.\n   * Tries 3 times, then a {@link RepoStateException} is thrown.\n   * Content is then trimmed and line separators get converted.\n   *\n   * @param file File to read.\n   * @return file content.\n   */\n  @NotNull\n  public static String tryLoadFile(@NotNull final File file) {\n    return tryOrThrow(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        return StringUtil.convertLineSeparators(FileUtil.loadFile(file).trim());\n      }\n    }, file);\n  }","commit_id":"fffa998450b50fbd930410eadaa59a45bfa18de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void heartBeater() {\n        if (!node.joined() || !node.isActive()) return;\n        long now = Clock.currentTimeMillis();\n        final Collection<MemberImpl> members = getMemberList();\n        if (node.isMaster()) {\n            List<Address> deadAddresses = null;\n            for (MemberImpl memberImpl : members) {\n                final Address address = memberImpl.getAddress();\n                if (!thisAddress.equals(address)) {\n                    try {\n                        Connection conn = node.connectionManager.getOrConnect(address);\n                        if (conn != null && conn.live()) {\n                            if ((now - memberImpl.getLastRead()) >= (maxNoHeartbeatMillis)) {\n                                if (deadAddresses == null) {\n                                    deadAddresses = new ArrayList<Address>();\n                                }\n                                logger.log(Level.WARNING, \"Added \" + address + \" to list of dead addresses because of timeout since last read\");\n                                deadAddresses.add(address);\n                            } else if ((now - memberImpl.getLastRead()) >= 5000 && (now - memberImpl.getLastPing()) >= 5000) {\n                                ping(memberImpl);\n                            }\n                            if ((now - memberImpl.getLastWrite()) > 500) {\n                                sendHeartbeat(address);\n                            }\n                            Long lastConfirmation = masterConfirmationTimes.get(memberImpl);\n                            if (lastConfirmation == null ||\n                                (now - lastConfirmation > maxNoMasterConfirmationMillis)) {\n                                if (deadAddresses == null) {\n                                    deadAddresses = new ArrayList<Address>();\n                                }\n                                logger.log(Level.WARNING, \"Added \" + address +\n                                                          \" to list of dead addresses because it has not sent a master confirmation recently\");\n                                deadAddresses.add(address);\n                            }\n                        } else if (conn == null && (now - memberImpl.getLastRead()) > 5000) {\n                            logMissingConnection(address);\n                            memberImpl.didRead();\n                        }\n                    } catch (Exception e) {\n                        logger.log(Level.SEVERE, e.getMessage(), e);\n                    }\n                }\n            }\n            if (deadAddresses != null) {\n                for (Address address : deadAddresses) {\n                    logger.log(Level.FINEST, \"No heartbeat should remove \" + address);\n                    removeAddress(address);\n                }\n            }\n        } else {\n            // send heartbeat to master\n            Address masterAddress = node.getMasterAddress();\n            if (masterAddress != null) {\n                node.connectionManager.getOrConnect(masterAddress);\n                MemberImpl masterMember = getMember(masterAddress);\n                boolean removed = false;\n                if (masterMember != null) {\n                    if ((now - masterMember.getLastRead()) >= (maxNoHeartbeatMillis)) {\n                        logger.log(Level.WARNING, \"Master node has timed out its heartbeat and will be removed\");\n                        removeAddress(masterAddress);\n                        removed = true;\n                    } else if ((now - masterMember.getLastRead()) >= 5000 && (now - masterMember.getLastPing()) >= 5000) {\n                        ping(masterMember);\n                    }\n                }\n                if (!removed) {\n                    sendHeartbeat(masterAddress);\n                }\n            }\n            for (MemberImpl member : members) {\n                if (!member.localMember()) {\n                    Address address = member.getAddress();\n                    Connection conn = node.connectionManager.getOrConnect(address);\n                    if (conn != null) {\n                        sendHeartbeat(address);\n                    } else {\n                        logger.log(Level.FINEST, \"could not connect to \" + address + \" to send heartbeat\");\n                    }\n                }\n            }\n        }\n    }","id":30189,"modified_method":"public final void heartBeater() {\n        if (!node.joined() || !node.isActive()) return;\n        long now = Clock.currentTimeMillis();\n        final Collection<MemberImpl> members = getMemberList();\n        if (node.isMaster()) {\n            List<Address> deadAddresses = null;\n            for (MemberImpl memberImpl : members) {\n                final Address address = memberImpl.getAddress();\n                if (!thisAddress.equals(address)) {\n                    try {\n                        Connection conn = node.connectionManager.getOrConnect(address);\n                        if (conn != null && conn.live()) {\n                            if ((now - memberImpl.getLastRead()) >= (maxNoHeartbeatMillis)) {\n                                if (deadAddresses == null) {\n                                    deadAddresses = new ArrayList<Address>();\n                                }\n                                logger.log(Level.WARNING, \"Added \" + address + \" to list of dead addresses because of timeout since last read\");\n                                deadAddresses.add(address);\n                            } else if ((now - memberImpl.getLastRead()) >= 5000 && (now - memberImpl.getLastPing()) >= 5000) {\n                                ping(memberImpl);\n                            }\n                            if ((now - memberImpl.getLastWrite()) > 500) {\n                                sendHeartbeat(address);\n                            }\n                            Long lastConfirmation = masterConfirmationTimes.get(memberImpl);\n                            if (lastConfirmation == null ||\n                                (now - lastConfirmation > maxNoMasterConfirmationMillis)) {\n                                if (deadAddresses == null) {\n                                    deadAddresses = new ArrayList<Address>();\n                                }\n                                logger.log(Level.WARNING, \"Added \" + address +\n                                                          \" to list of dead addresses because it has not sent a master confirmation recently\");\n                                deadAddresses.add(address);\n                            }\n                        } else if (conn == null && (now - memberImpl.getLastRead()) > 5000) {\n                            logMissingConnection(address);\n                            memberImpl.didRead();\n                        }\n                    } catch (Exception e) {\n                        logger.log(Level.SEVERE, e.getMessage(), e);\n                    }\n                }\n            }\n            if (deadAddresses != null) {\n                for (Address address : deadAddresses) {\n                    logger.log(Level.FINEST, \"No heartbeat should remove \" + address);\n                    removeAddress(address);\n                }\n            }\n        } else {\n            // send heartbeat to master\n            Address masterAddress = node.getMasterAddress();\n            if (masterAddress != null) {\n                node.connectionManager.getOrConnect(masterAddress);\n                MemberImpl masterMember = getMember(masterAddress);\n                boolean removed = false;\n                if (masterMember != null) {\n                    if ((now - masterMember.getLastRead()) >= (maxNoHeartbeatMillis)) {\n                        logger.log(Level.WARNING, \"Master node has timed out its heartbeat and will be removed\");\n                        removeAddress(masterAddress);\n                        removed = true;\n                    } else if ((now - masterMember.getLastRead()) >= 5000 && (now - masterMember.getLastPing()) >= 5000) {\n                        ping(masterMember);\n                    }\n                }\n                if (!removed) {\n                    sendHeartbeat(masterAddress);\n                }\n            }\n            for (MemberImpl member : members) {\n                if (!member.localMember()) {\n                    Address address = member.getAddress();\n                    Connection conn = node.connectionManager.getOrConnect(address);\n                    if (conn != null) {\n                        sendHeartbeat(address);\n                    } else {\n                        logger.log(Level.FINEST, \"Could not connect to \" + address + \" to send heartbeat\");\n                    }\n                }\n            }\n        }\n    }","commit_id":"5d21a75f3fc91d3b57973dfe73dd56da99911207","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Future invokeClusterOperation(Operation op, Address target) {\n        return nodeService.createInvocationBuilder(SERVICE_NAME, op, NodeService.EXECUTOR_THREAD_ID)\n                .setTarget(target).setTryCount(1).build().invoke();\n    }","id":30190,"modified_method":"Future invokeClusterOperation(Operation op, Address target) {\n        return nodeService.createInvocationBuilder(SERVICE_NAME, op, NodeService.EXECUTOR_THREAD_ID)\n                .setTarget(target).setTryCount(1).build().invoke();\n    }","commit_id":"5d21a75f3fc91d3b57973dfe73dd56da99911207","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void acceptMasterConfirmation(Address endpoint) {\n        MemberImpl member = getMember(endpoint);\n        if (member != null) {\n            if (logger.isLoggable(Level.FINEST)) {\n                logger.log(Level.FINEST, \"MasterConfirmation has been received from \" + member);\n            }\n            masterConfirmationTimes.put(member, Clock.currentTimeMillis());\n        } else {\n            logger.log(Level.WARNING, \"MasterConfirmation has been received from \" + endpoint +\n                    \", but it is not a member of this cluster!\");\n        }\n    }","id":30191,"modified_method":"void acceptMasterConfirmation(MemberImpl member) {\n        if (member != null) {\n            if (logger.isLoggable(Level.FINEST)) {\n                logger.log(Level.FINEST, \"MasterConfirmation has been received from \" + member);\n            }\n            masterConfirmationTimes.put(member, Clock.currentTimeMillis());\n        }\n    }","commit_id":"5d21a75f3fc91d3b57973dfe73dd56da99911207","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n        Address endpoint = getCaller();\n        if (endpoint == null) {\n            return;\n        }\n        ClusterService clusterService = getService();\n        if (!clusterService.isMaster()) {\n            final ILogger logger = getNodeService().getLogger(MasterConfirmationOperation.class.getName());\n            logger.log(Level.WARNING, endpoint + \" has sent MasterConfirmation, but this node is not master!\");\n            return;\n        }\n        clusterService.acceptMasterConfirmation(endpoint);\n    }","id":30192,"modified_method":"public void run() {\n        final Address endpoint = getCaller();\n        if (endpoint == null) {\n            return;\n        }\n        final ClusterService clusterService = getService();\n        final ILogger logger = getNodeService().getLogger(MasterConfirmationOperation.class.getName());\n        final MemberImpl member = clusterService.getMember(endpoint);\n        if (member != null) {\n            if (clusterService.isMaster()) {\n                clusterService.acceptMasterConfirmation(member);\n            } else {\n                logger.log(Level.WARNING, endpoint + \" has sent MasterConfirmation, but this node is not master!\");\n            }\n        } else {\n            logger.log(Level.WARNING, \"MasterConfirmation has been received from \" + endpoint\n                                      + \", but it is not a member of this cluster!\");\n            clusterService.invokeClusterOperation(new MemberRemoveOperation(clusterService.getThisAddress()), endpoint);\n        }\n    }","commit_id":"5d21a75f3fc91d3b57973dfe73dd56da99911207","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n\tpublic BackgroundTaskStatus getBackgroundTaskStatus(long backgroundTaskId) {\n\t\tif (ClusterMasterExecutorUtil.isMaster()) {\n\t\t\tLock lock = _readWriteLock.readLock();\n\n\t\t\tlock.lock();\n\n\t\t\ttry {\n\t\t\t\treturn _backgroundTaskStatuses.get(backgroundTaskId);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\n\t\treturn executeGetBackgroundTaskStatusOnMaster(backgroundTaskId);\n\t}","id":30193,"modified_method":"@Override\n\tpublic BackgroundTaskStatus getBackgroundTaskStatus(long backgroundTaskId) {\n\t\tif (!ClusterMasterExecutorUtil.isMaster()) {\n\t\t\treturn getBackgroundTaskStatusOnMaster(backgroundTaskId);\n\t\t}\n\n\t\tLock lock = _readWriteLock.readLock();\n\n\t\tlock.lock();\n\n\t\ttry {\n\t\t\treturn _backgroundTaskStatuses.get(backgroundTaskId);\n\t\t}\n\t\tfinally {\n\t\t\tlock.unlock();\n\t\t}\n\t}","commit_id":"10ca06441f59674a144a153da46f198f9226745d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected BackgroundTaskStatus executeGetBackgroundTaskStatusOnMaster(\n\t\tlong backgroundTaskId) {\n\n\t\ttry {\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\tBackgroundTaskStatusRegistryUtil.class.getDeclaredMethod(\n\t\t\t\t\t\"getBackgroundTaskStatus\", long.class),\n\t\t\t\tbackgroundTaskId);\n\n\t\t\tFuture<BackgroundTaskStatus> backgroundTaskStatusFuture =\n\t\t\t\tClusterMasterExecutorUtil.executeOnMaster(methodHandler);\n\n\t\t\treturn backgroundTaskStatusFuture.get();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t_log.error(e);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":30194,"modified_method":"protected BackgroundTaskStatus getBackgroundTaskStatusOnMaster(\n\t\tlong backgroundTaskId) {\n\n\t\ttry {\n\t\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\t\tBackgroundTaskStatusRegistryUtil.class.getDeclaredMethod(\n\t\t\t\t\t\"getBackgroundTaskStatus\", long.class),\n\t\t\t\tbackgroundTaskId);\n\n\t\t\tFuture<BackgroundTaskStatus> backgroundTaskStatusFuture =\n\t\t\t\tClusterMasterExecutorUtil.executeOnMaster(methodHandler);\n\n\t\t\treturn backgroundTaskStatusFuture.get();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t_log.error(\"Error retrieving status from master node\", e);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"10ca06441f59674a144a153da46f198f9226745d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void afterReturning(MethodInvocation methodInvocation, Object result)\n\t\tthrows Throwable {\n\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClusterable clusterable = findAnnotation(methodInvocation);\n\n\t\tif (clusterable == NullClusterable.NULL_CLUSTERABLE) {\n\t\t\treturn;\n\t\t}\n\n\t\tMethodHandler methodHandler =\n\t\t\tClusterableInvokerUtil.createMethodHandler(\n\t\t\t\tclusterable.acceptor(), methodInvocation.getThis(),\n\t\t\t\tmethodInvocation.getMethod(), methodInvocation.getArguments());\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\tmethodHandler, true);\n\n\t\tclusterRequest.setFireAndForget(true);\n\n\t\tClusterExecutorUtil.execute(clusterRequest);\n\t}","id":30195,"modified_method":"@Override\n\tpublic void afterReturning(MethodInvocation methodInvocation, Object result)\n\t\tthrows Throwable {\n\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClusterable clusterable = findAnnotation(methodInvocation);\n\n\t\tif (clusterable == NullClusterable.NULL_CLUSTERABLE) {\n\t\t\treturn;\n\t\t}\n\n\t\tClusterableInvokerUtil.invokeOnCluster(\n\t\t\tclusterable.acceptor(), methodInvocation.getThis(),\n\t\t\tmethodInvocation.getMethod(), methodInvocation.getArguments());\n\t}","commit_id":"7e3d6fa80805b5fe59b287fd6847cd1efc004f23","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Object before(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tClusterable clusterable = findAnnotation(methodInvocation);\n\n\t\tif (clusterable == NullClusterable.NULL_CLUSTERABLE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!clusterable.onMaster()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tClass<?> returnType = method.getReturnType();\n\n\t\tif (ClusterMasterExecutorUtil.isMaster()) {\n\t\t\tObject result = methodInvocation.proceed();\n\n\t\t\tif (returnType == void.class) {\n\t\t\t\tresult = nullResult;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tMethodHandler methodHandler =\n\t\t\tClusterableInvokerUtil.createMethodHandler(\n\t\t\t\tclusterable.acceptor(), methodInvocation.getThis(),\n\t\t\t\tmethodInvocation.getMethod(), methodInvocation.getArguments());\n\n\t\tFuture<Object> futureResult = ClusterMasterExecutorUtil.executeOnMaster(\n\t\t\tmethodHandler);\n\n\t\tObject result = futureResult.get(\n\t\t\tPropsValues.CLUSTERABLE_ADVICE_CALL_MASTER_TIMEOUT,\n\t\t\tTimeUnit.SECONDS);\n\n\t\tif (returnType == void.class) {\n\t\t\tresult = nullResult;\n\t\t}\n\n\t\treturn result;\n\t}","id":30196,"modified_method":"@Override\n\tpublic Object before(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tClusterable clusterable = findAnnotation(methodInvocation);\n\n\t\tif (clusterable == NullClusterable.NULL_CLUSTERABLE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!clusterable.onMaster()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject result = null;\n\n\t\tif (ClusterMasterExecutorUtil.isMaster()) {\n\t\t\tresult = methodInvocation.proceed();\n\t\t}\n\t\telse {\n\t\t\tresult = ClusterableInvokerUtil.invokeOnMaster(\n\t\t\t\tclusterable.acceptor(), methodInvocation.getThis(),\n\t\t\t\tmethodInvocation.getMethod(), methodInvocation.getArguments());\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tClass<?> returnType = method.getReturnType();\n\n\t\tif (returnType == void.class) {\n\t\t\tresult = nullResult;\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"7e3d6fa80805b5fe59b287fd6847cd1efc004f23","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean read(TachyonFileSystem tachyonFileSystem, TachyonURI filePath,\n      TachyonStorageType readType) throws IOException, TachyonException {\n    InStreamOptions clientOptions = new InStreamOptions.Builder(ClientContext.getConf())\n        .setTachyonStorageType(readType).build();\n    TachyonFile file = tachyonFileSystem.open(filePath);\n    DataInputStream input = new DataInputStream(tachyonFileSystem.getInStream(file, clientOptions));\n    boolean passes = true;\n    try {\n      int length = input.readInt();\n      for (int i = 0; i < length; i ++) {\n        passes &= (input.readInt() == i);\n      }\n    } finally {\n      input.close();\n    }\n    return passes;\n  }","id":30197,"modified_method":"private boolean read(TachyonFileSystem tachyonFileSystem, TachyonURI filePath,\n      ReadType readType) throws IOException, TachyonException {\n    InStreamOptions clientOptions = new InStreamOptions.Builder(ClientContext.getConf())\n        .setReadType(readType).build();\n    TachyonFile file = tachyonFileSystem.open(filePath);\n    DataInputStream input = new DataInputStream(tachyonFileSystem.getInStream(file, clientOptions));\n    boolean passes = true;\n    try {\n      int length = input.readInt();\n      for (int i = 0; i < length; i ++) {\n        passes &= (input.readInt() == i);\n      }\n    } finally {\n      input.close();\n    }\n    return passes;\n  }","commit_id":"0c6483aa03cc24c4d42600053849f58331c9a71c","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Boolean call() throws Exception {\n    TachyonConf tachyonConf = ClientContext.getConf();\n    tachyonConf.set(Constants.MASTER_HOSTNAME, mMasterLocation.getHost());\n    tachyonConf.set(Constants.MASTER_PORT, Integer.toString(mMasterLocation.getPort()));\n    ClientContext.reset(tachyonConf);\n    TachyonFileSystem tFS = TachyonFileSystem.TachyonFileSystemFactory.get();\n    write(tFS, mFilePath, mTachyonWriteType, mUfsWriteType, mDeleteIfExists, mLength);\n    return read(tFS, mFilePath, mReadType);\n  }","id":30198,"modified_method":"@Override\n  public Boolean call() throws Exception {\n    TachyonConf tachyonConf = ClientContext.getConf();\n    tachyonConf.set(Constants.MASTER_HOSTNAME, mMasterLocation.getHost());\n    tachyonConf.set(Constants.MASTER_PORT, Integer.toString(mMasterLocation.getPort()));\n    ClientContext.reset(tachyonConf);\n    TachyonFileSystem tFS = TachyonFileSystem.TachyonFileSystemFactory.get();\n    write(tFS, mFilePath, mWriteType, mDeleteIfExists, mLength);\n    return read(tFS, mFilePath, mReadType);\n  }","commit_id":"0c6483aa03cc24c4d42600053849f58331c9a71c","url":"https://github.com/amplab/tachyon"},{"original_method":"private static void usage() {\n    System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \"\n        + BasicNonByteBufferOperations.class.getName() + \" <master address> <file path> \"\n        + \"<tachyon storage type for writes (STORE | NO_STORE)> \"\n        + \"<under storage type for writes (SYNC_PERSIST | NO_PERSIST)> \"\n        + \"<tachyon storage type for reads (STORE | NO_STORE)> <delete file> <number of files>\");\n    System.exit(-1);\n  }","id":30199,"modified_method":"private static void usage() {\n    System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \"\n        + BasicNonByteBufferOperations.class.getName() + \" <master address> <file path> \"\n        + \"<read type (CACHE | NO_CACHE)> <write type (CACHE | CACHE_THROUGH | THROUGH)> \"\n        + \"<delete file> <number of files>\");\n    System.exit(-1);\n  }","commit_id":"0c6483aa03cc24c4d42600053849f58331c9a71c","url":"https://github.com/amplab/tachyon"},{"original_method":"private void write(TachyonFileSystem tachyonFileSystem, TachyonURI filePath,\n      TachyonStorageType tachyonWriteType, UnderStorageType ufsWriteType, boolean deleteIfExists,\n      int length) throws IOException, TachyonException {\n    OutStreamOptions clientOptions = new OutStreamOptions.Builder(ClientContext.getConf())\n        .setTachyonStorageType(tachyonWriteType).setUnderStorageType(ufsWriteType).build();\n    // If the file exists already, we will override it.\n    FileOutStream fileOutStream =\n        getOrCreate(tachyonFileSystem, filePath, deleteIfExists, clientOptions);\n    DataOutputStream os = new DataOutputStream(fileOutStream);\n    try {\n      os.writeInt(length);\n      for (int i = 0; i < length; i ++) {\n        os.writeInt(i);\n      }\n    } finally {\n      os.close();\n    }\n  }","id":30200,"modified_method":"private void write(TachyonFileSystem tachyonFileSystem, TachyonURI filePath, WriteType writeType,\n      boolean deleteIfExists, int length) throws IOException, TachyonException {\n    OutStreamOptions clientOptions =\n        new OutStreamOptions.Builder(ClientContext.getConf()).setWriteType(writeType).build();\n    // If the file exists already, we will override it.\n    FileOutStream fileOutStream =\n        getOrCreate(tachyonFileSystem, filePath, deleteIfExists, clientOptions);\n    DataOutputStream os = new DataOutputStream(fileOutStream);\n    try {\n      os.writeInt(length);\n      for (int i = 0; i < length; i ++) {\n        os.writeInt(i);\n      }\n    } finally {\n      os.close();\n    }\n  }","commit_id":"0c6483aa03cc24c4d42600053849f58331c9a71c","url":"https://github.com/amplab/tachyon"},{"original_method":"public static void main(final String[] args) throws IOException {\n    if (args.length < 2 || args.length > 7) {\n      usage();\n    }\n\n    Utils.runExample(new BasicNonByteBufferOperations(new TachyonURI(args[0]),\n        new TachyonURI(args[1]), Utils.option(args, 2, TachyonStorageType.STORE),\n        Utils.option(args, 3, UnderStorageType.NO_PERSIST),\n        Utils.option(args, 4, TachyonStorageType.NO_STORE), Utils.option(args, 5, true),\n        Utils.option(args, 6, 20)));\n  }","id":30201,"modified_method":"public static void main(final String[] args) throws IOException {\n    if (args.length < 2 || args.length > 6) {\n      usage();\n    }\n\n    Utils.runExample(new BasicNonByteBufferOperations(new TachyonURI(args[0]), new TachyonURI(\n        args[1]), Utils.option(args, 2, ReadType.CACHE), Utils.option(args, 3,\n        WriteType.CACHE_THROUGH), Utils.option(args, 4, true), Utils.option(args, 5, 20)));\n  }","commit_id":"0c6483aa03cc24c4d42600053849f58331c9a71c","url":"https://github.com/amplab/tachyon"},{"original_method":"public BasicNonByteBufferOperations(TachyonURI masterLocation, TachyonURI filePath,\n      TachyonStorageType tachyonWriteType, UnderStorageType ufsWriteType,\n      TachyonStorageType readType, boolean deleteIfExists, int length) {\n    mMasterLocation = masterLocation;\n    mFilePath = filePath;\n    mTachyonWriteType = tachyonWriteType;\n    mUfsWriteType = ufsWriteType;\n    mReadType = readType;\n    mDeleteIfExists = deleteIfExists;\n    mLength = length;\n  }","id":30202,"modified_method":"public BasicNonByteBufferOperations(TachyonURI masterLocation, TachyonURI filePath, ReadType\n      readType, WriteType writeType, boolean deleteIfExists, int length) {\n    mMasterLocation = masterLocation;\n    mFilePath = filePath;\n    mWriteType = writeType;\n    mReadType = readType;\n    mDeleteIfExists = deleteIfExists;\n    mLength = length;\n  }","commit_id":"0c6483aa03cc24c4d42600053849f58331c9a71c","url":"https://github.com/amplab/tachyon"},{"original_method":"private static void usage() {\n    System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \"\n        + BasicNonByteBufferOperations.class.getName() + \" <master address> <file path> \"\n        + \"<read type (CACHE | NO_CACHE)> <write type (CACHE | CACHE_THROUGH | THROUGH)> \"\n        + \"<delete file> <number of files>\");\n    System.exit(-1);\n  }","id":30203,"modified_method":"private static void usage() {\n    System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \"\n        + BasicNonByteBufferOperations.class.getName() + \" <master address> <file path> \"\n        + \" <ReadType (CACHE_PROMOTE | CACHE | NO_CACHE)> <WriteType (MUST_CACHE | CACHE_THROUGH\"\n        + \" | THROUGH)> <delete file> <number of files>\");\n    System.exit(-1);\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"private void writeFile(long fileId) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(mNumbers * 4);\n    buf.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      buf.putInt(k);\n    }\n\n    buf.flip();\n    LOG.debug(\"Writing data...\");\n    buf.flip();\n\n    long startTimeMs = CommonUtils.getCurrentMs();\n    FileOutStream os = new FileOutStream(fileId, mClientOptions);\n    os.write(buf.array());\n    os.close();\n\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"writeFile to file \" + mFilePath));\n  }","id":30204,"modified_method":"private void writeFile(long fileId) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(mNumbers * 4);\n    buf.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      buf.putInt(k);\n    }\n\n    buf.flip();\n    LOG.debug(\"Writing data...\");\n    buf.flip();\n\n    long startTimeMs = CommonUtils.getCurrentMs();\n    FileOutStream os = new FileOutStream(fileId, mWriteOptions);\n    os.write(buf.array());\n    os.close();\n\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"writeFile to file \" + mFilePath));\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"public BasicOperations(TachyonURI masterLocation, TachyonURI filePath,\n      TachyonStorageType tachyonStorageType, UnderStorageType underStorageType) {\n    mMasterLocation = masterLocation;\n    mFilePath = filePath;\n    mClientOptions = new OutStreamOptions.Builder(ClientContext.getConf())\n        .setTachyonStorageType(tachyonStorageType).setUnderStorageType(underStorageType).build();\n  }","id":30205,"modified_method":"public BasicOperations(TachyonURI masterLocation, TachyonURI filePath, ReadType readType,\n      WriteType writeType) {\n    mMasterLocation = masterLocation;\n    mFilePath = filePath;\n    mReadOptions =\n        new InStreamOptions.Builder(ClientContext.getConf()).setReadType(readType).build();\n    mWriteOptions =\n        new OutStreamOptions.Builder(ClientContext.getConf()).setWriteType(writeType).build();\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"private long createFile(TachyonFileSystem tachyonFileSystem)\n      throws IOException, TachyonException {\n    LOG.debug(\"Creating file...\");\n    long startTimeMs = CommonUtils.getCurrentMs();\n    CreateOptions createOptions =\n        (new CreateOptions.Builder(ClientContext.getConf()))\n            .setBlockSizeBytes(mClientOptions.getBlockSizeBytes()).setRecursive(true)\n            .setTTL(mClientOptions.getTTL())\n            .setUnderStorageType(mClientOptions.getUnderStorageType()).build();\n    TachyonFile tFile = tachyonFileSystem.create(mFilePath, createOptions);\n    long fileId = tFile.getFileId();\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"createFile with fileId \" + fileId));\n    return fileId;\n  }","id":30206,"modified_method":"private long createFile(TachyonFileSystem tachyonFileSystem)\n      throws IOException, TachyonException {\n    LOG.debug(\"Creating file...\");\n    long startTimeMs = CommonUtils.getCurrentMs();\n    CreateOptions createOptions =\n        (new CreateOptions.Builder(ClientContext.getConf()))\n            .setBlockSizeBytes(mWriteOptions.getBlockSizeBytes()).setRecursive(true)\n            .setTTL(mWriteOptions.getTTL())\n            .setUnderStorageType(mWriteOptions.getUnderStorageType()).build();\n    TachyonFile tFile = tachyonFileSystem.create(mFilePath, createOptions);\n    long fileId = tFile.getFileId();\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"createFile with fileId \" + fileId));\n    return fileId;\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"public static void main(String[] args) throws IllegalArgumentException {\n    if (args.length != 4) {\n      System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \" + BasicOperations.class.getName()\n          + \" <under storage type for writes (SYNC_PERSIST|NO_PERSIST)>\");\n      System.exit(-1);\n    }\n\n    Utils.runExample(new BasicOperations(new TachyonURI(args[0]), new TachyonURI(args[1]),\n        TachyonStorageType.valueOf(args[2]), UnderStorageType.valueOf(args[3])));\n  }","id":30207,"modified_method":"public static void main(String[] args) throws IllegalArgumentException {\n    if (args.length != 4) {\n      System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \" + BasicOperations.class.getName()\n          + \" <ReadType (CACHE_PROMOTE | CACHE | NO_CACHE)> <WriteType (MUST_CACHE | CACHE_THROUGH\"\n          + \" | THROUGH)>\");\n      System.exit(-1);\n    }\n\n    Utils.runExample(new BasicOperations(new TachyonURI(args[0]), new TachyonURI(args[1]),\n        ReadType.valueOf(args[2]), WriteType.valueOf(args[3])));\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean readFile(TachyonFileSystem tachyonFileSystem, long fileId)\n      throws IOException, TachyonException {\n    boolean pass = true;\n    LOG.debug(\"Reading data...\");\n    TachyonFile file = new TachyonFile(fileId);\n    InStreamOptions clientOptions = new InStreamOptions.Builder(ClientContext.getConf())\n        .setTachyonStorageType(TachyonStorageType.STORE).build();\n    final long startTimeMs = CommonUtils.getCurrentMs();\n    FileInStream is = tachyonFileSystem.getInStream(file, clientOptions);\n    ByteBuffer buf = ByteBuffer.allocate((int) is.remaining());\n    is.read(buf.array());\n    buf.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      pass = pass && (buf.getInt() == k);\n    }\n    is.close();\n\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"readFile file \" + mFilePath));\n    return pass;\n  }","id":30208,"modified_method":"private boolean readFile(TachyonFileSystem tachyonFileSystem, long fileId)\n      throws IOException, TachyonException {\n    boolean pass = true;\n    LOG.debug(\"Reading data...\");\n    TachyonFile file = new TachyonFile(fileId);\n    final long startTimeMs = CommonUtils.getCurrentMs();\n    FileInStream is = tachyonFileSystem.getInStream(file, mReadOptions);\n    ByteBuffer buf = ByteBuffer.allocate((int) is.remaining());\n    is.read(buf.array());\n    buf.order(ByteOrder.nativeOrder());\n    for (int k = 0; k < mNumbers; k ++) {\n      pass = pass && (buf.getInt() == k);\n    }\n    is.close();\n\n    LOG.info(FormatUtils.formatTimeTakenMs(startTimeMs, \"readFile file \" + mFilePath));\n    return pass;\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean read(TachyonFS tachyonClient) throws IOException {\n    boolean pass = true;\n\n    LOG.debug(\"Reading data...\");\n    RawTable rawTable = tachyonClient.getRawTable(mId);\n    ByteBuffer metadata = rawTable.getMetadata();\n    LOG.debug(\"Metadata: \");\n    metadata.order(ByteOrder.nativeOrder());\n    for (int k = -mMetadataLength; k < 0; k ++) {\n      pass = pass && (metadata.getInt() == k);\n    }\n\n    for (int column = 0; column < COLS; column ++) {\n      RawColumn rawColumn = rawTable.getRawColumn(column);\n      TachyonFile tFile = rawColumn.getPartition(0);\n      FileInStream is = tFile.getInStream(ReadType.CACHE);\n      ByteBuffer buf = ByteBuffer.allocate(mDataLength * 4);\n      is.read(buf.array());\n      buf.order(ByteOrder.nativeOrder());\n      for (int k = 0; k < mDataLength; k ++) {\n        pass = pass && (buf.getInt() == k);\n      }\n      is.close();\n    }\n    return pass;\n  }","id":30209,"modified_method":"private boolean read(TachyonFS tachyonClient) throws IOException {\n    boolean pass = true;\n\n    LOG.debug(\"Reading data...\");\n    RawTable rawTable = tachyonClient.getRawTable(mId);\n    ByteBuffer metadata = rawTable.getMetadata();\n    LOG.debug(\"Metadata: \");\n    metadata.order(ByteOrder.nativeOrder());\n    for (int k = -mMetadataLength; k < 0; k ++) {\n      pass = pass && (metadata.getInt() == k);\n    }\n\n    for (int column = 0; column < COLS; column ++) {\n      RawColumn rawColumn = rawTable.getRawColumn(column);\n      TachyonFile tFile = rawColumn.getPartition(0);\n      FileInStream is = tFile.getInStream(mReadType);\n      ByteBuffer buf = ByteBuffer.allocate(mDataLength * 4);\n      is.read(buf.array());\n      buf.order(ByteOrder.nativeOrder());\n      for (int k = 0; k < mDataLength; k ++) {\n        pass = pass && (buf.getInt() == k);\n      }\n      is.close();\n    }\n    return pass;\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"public BasicRawTableOperations(TachyonURI masterAddress, TachyonURI tablePath,\n      TachyonStorageType tachyonWriteType, UnderStorageType ufsWriteType) {\n    mMasterAddress = masterAddress;\n    mTablePath = tablePath;\n    if (tachyonWriteType.isStore()) {\n      mWriteType = ufsWriteType.isSyncPersist() ? WriteType.CACHE_THROUGH : WriteType.MUST_CACHE;\n    } else {\n      mWriteType = WriteType.THROUGH;\n    }\n  }","id":30210,"modified_method":"public BasicRawTableOperations(TachyonURI masterAddress, TachyonURI tablePath,\n      ReadType readType, WriteType writeType) {\n    mMasterAddress = masterAddress;\n    mTablePath = tablePath;\n    mReadType = readType;\n    mWriteType = writeType;\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"public static void main(String[] args) throws IllegalArgumentException {\n    if (args.length != 4) {\n      System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \"\n          + BasicRawTableOperations.class.getName() + \" <master address> <file path> \"\n          + \"<tachyon storage type for writes (STORE|NO_STORE)> \"\n          + \"<under storage type for writes (SYNC_PERSIST|NO_PERSIST)\");\n      System.exit(-1);\n    }\n    Utils.runExample(new BasicRawTableOperations(new TachyonURI(args[0]), new TachyonURI(args[1]),\n        TachyonStorageType.valueOf(args[2]), UnderStorageType.valueOf(args[3])));\n  }","id":30211,"modified_method":"public static void main(String[] args) throws IllegalArgumentException {\n    if (args.length != 4) {\n      System.out.println(\"java -cp \" + Constants.TACHYON_JAR + \" \"\n          + BasicRawTableOperations.class.getName() + \" <master address> <file path> \"\n          + \" <ReadType (CACHE_PROMOTE | CACHE | NO_CACHE)> <WriteType (MUST_CACHE | CACHE_THROUGH\"\n          + \" | THROUGH)>\");\n      System.exit(-1);\n    }\n    Utils.runExample(new BasicRawTableOperations(new TachyonURI(args[0]), new TachyonURI(args[1]),\n        ReadType.valueOf(args[2]), WriteType.valueOf(args[3])));\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"private void write(TachyonFS tachyonClient) throws IOException {\n    RawTable rawTable = tachyonClient.getRawTable(mTablePath);\n\n    LOG.debug(\"Writing data...\");\n    for (int column = 0; column < COLS; column ++) {\n      RawColumn rawColumn = rawTable.getRawColumn(column);\n      if (!rawColumn.createPartition(0)) {\n        throw new IOException(\"Failed to create partition in table \" + mTablePath\n            + \" under column \" + column);\n      }\n\n      ByteBuffer buf = ByteBuffer.allocate(mDataLength * 4);\n      buf.order(ByteOrder.nativeOrder());\n      for (int k = 0; k < mDataLength; k ++) {\n        buf.putInt(k);\n      }\n      buf.flip();\n\n      TachyonFile tFile = rawColumn.getPartition(0);\n      FileOutStream os = tFile.getOutStream();\n      os.write(buf.array());\n      os.close();\n    }\n  }","id":30212,"modified_method":"private void write(TachyonFS tachyonClient) throws IOException {\n    RawTable rawTable = tachyonClient.getRawTable(mTablePath);\n\n    LOG.debug(\"Writing data...\");\n    for (int column = 0; column < COLS; column ++) {\n      RawColumn rawColumn = rawTable.getRawColumn(column);\n      if (!rawColumn.createPartition(0)) {\n        throw new IOException(\"Failed to create partition in table \" + mTablePath\n            + \" under column \" + column);\n      }\n\n      ByteBuffer buf = ByteBuffer.allocate(mDataLength * 4);\n      buf.order(ByteOrder.nativeOrder());\n      for (int k = 0; k < mDataLength; k ++) {\n        buf.putInt(k);\n      }\n      buf.flip();\n\n      TachyonFile tFile = rawColumn.getPartition(0);\n      FileOutStream os = tFile.getOutStream(mWriteType);\n      os.write(buf.array());\n      os.close();\n    }\n  }","commit_id":"9c90c3a3020f7b78ef8baeb47e0ca16ef1ccdb3f","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  @LocalTachyonClusterResource.Config(tachyonConfParams = {Constants.USER_LINEAGE_ENABLED, \"true\"})\n  public void lineageCompleteAndAsyncPersistTest() throws Exception {\n    LineageMasterClient lineageMasterClient = getLineageMasterClient();\n\n    Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n        TimeUnit.SECONDS));\n    Assert.assertTrue(\n        HeartbeatScheduler.await(HeartbeatContext.WORKER_LINEAGE_SYNC, 5, TimeUnit.SECONDS));\n\n    try {\n      lineageMasterClient.createLineage(Lists.<String>newArrayList(), Lists.newArrayList(OUT_FILE),\n          mJob);\n\n      OutStreamOptions options =\n          new OutStreamOptions.Builder(mTestConf).setTachyonStorageType(TachyonStorageType.STORE)\n              .setUnderStorageType(UnderStorageType.NO_PERSIST).setBlockSizeBytes(BLOCK_SIZE_BYTES)\n              .build();\n      TachyonLineageFileSystem tfs =\n          (TachyonLineageFileSystem) mLocalTachyonClusterResource.get().getClient();\n      FileOutStream outputStream = tfs.getOutStream(new TachyonURI(OUT_FILE), options);\n      outputStream.write(1);\n      outputStream.close();\n\n      List<LineageInfo> infos = lineageMasterClient.getLineageInfoList();\n      Assert.assertEquals(LineageFileState.COMPLETED.toString(),\n          infos.get(0).outputFiles.get(0).state);\n\n      // Execute the checkpoint scheduler for async checkpoint\n      HeartbeatScheduler.schedule(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING);\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_LINEAGE_SYNC);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n          TimeUnit.SECONDS));\n      Assert.assertTrue(\n          HeartbeatScheduler.await(HeartbeatContext.WORKER_LINEAGE_SYNC, 5, TimeUnit.SECONDS));\n\n      infos = lineageMasterClient.getLineageInfoList();\n      Assert.assertEquals(LineageFileState.PERSISENCE_REQUESTED.toString(),\n          infos.get(0).outputFiles.get(0).state);\n\n      // sleep and wait for worker to persist the file\n      Thread.sleep(5);\n\n      // worker notifies the master\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_LINEAGE_SYNC);\n      Assert.assertTrue(\n          HeartbeatScheduler.await(HeartbeatContext.WORKER_LINEAGE_SYNC, 5000, TimeUnit.SECONDS));\n\n      infos = lineageMasterClient.getLineageInfoList();\n      Assert.assertEquals(LineageFileState.PERSISTED.toString(),\n          infos.get(0).outputFiles.get(0).state);\n\n    } finally {\n      lineageMasterClient.close();\n    }\n  }","id":30213,"modified_method":"@Test\n  public void lineageCompleteAndAsyncPersistTest() throws Exception {\n    LineageMasterClient lineageMasterClient = getLineageMasterClient();\n\n    Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n        TimeUnit.SECONDS));\n    Assert.assertTrue(\n        HeartbeatScheduler.await(HeartbeatContext.WORKER_LINEAGE_SYNC, 5, TimeUnit.SECONDS));\n\n    try {\n      lineageMasterClient.createLineage(Lists.<String>newArrayList(), Lists.newArrayList(OUT_FILE),\n          mJob);\n\n      OutStreamOptions options = new OutStreamOptions.Builder(mTestConf)\n          .setWriteType(WriteType.MUST_CACHE).setBlockSizeBytes(BLOCK_SIZE_BYTES).build();\n      TachyonLineageFileSystem tfs =\n          (TachyonLineageFileSystem) mLocalTachyonClusterResource.get().getClient();\n      FileOutStream outputStream = tfs.getOutStream(new TachyonURI(OUT_FILE), options);\n      outputStream.write(1);\n      outputStream.close();\n\n      List<LineageInfo> infos = lineageMasterClient.getLineageInfoList();\n      Assert.assertEquals(LineageFileState.COMPLETED.toString(),\n          infos.get(0).outputFiles.get(0).state);\n\n      // Execute the checkpoint scheduler for async checkpoint\n      HeartbeatScheduler.schedule(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING);\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_LINEAGE_SYNC);\n      Assert.assertTrue(HeartbeatScheduler.await(HeartbeatContext.MASTER_CHECKPOINT_SCHEDULING, 5,\n          TimeUnit.SECONDS));\n      Assert.assertTrue(\n          HeartbeatScheduler.await(HeartbeatContext.WORKER_LINEAGE_SYNC, 5, TimeUnit.SECONDS));\n\n      infos = lineageMasterClient.getLineageInfoList();\n      Assert.assertEquals(LineageFileState.PERSISENCE_REQUESTED.toString(),\n          infos.get(0).outputFiles.get(0).state);\n\n      // sleep and wait for worker to persist the file\n      Thread.sleep(5);\n\n      // worker notifies the master\n      HeartbeatScheduler.schedule(HeartbeatContext.WORKER_LINEAGE_SYNC);\n      Assert.assertTrue(\n          HeartbeatScheduler.await(HeartbeatContext.WORKER_LINEAGE_SYNC, 5, TimeUnit.SECONDS));\n\n      infos = lineageMasterClient.getLineageInfoList();\n      Assert.assertEquals(LineageFileState.PERSISTED.toString(),\n          infos.get(0).outputFiles.get(0).state);\n\n    } finally {\n      lineageMasterClient.close();\n    }\n  }","commit_id":"a559f76b6aab6058f935c2765450e8e9683f1fcb","url":"https://github.com/amplab/tachyon"},{"original_method":"public static synchronized TachyonFileSystem get() {\n      if (sTachyonFileSystem == null) {\n        boolean enableLineage = ClientContext.getConf().getBoolean(Constants.USER_LINEAGE_ENABLED);\n        sTachyonFileSystem =\n            enableLineage ? TachyonLineageFileSystem.get() : new TachyonFileSystem();\n      }\n      return sTachyonFileSystem;\n    }","id":30214,"modified_method":"public static synchronized TachyonFileSystem get() {\n      boolean enableLineage = ClientContext.getConf().getBoolean(Constants.USER_LINEAGE_ENABLED);\n      return enableLineage ? TachyonLineageFileSystem.get() : get();\n    }","commit_id":"a559f76b6aab6058f935c2765450e8e9683f1fcb","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n        public KernelServicesBuilder setModelInitializer(ModelInitializer modelInitializer, ModelWriteSanitizer modelWriteSanitizer) {\n            bootOperationBuilder.validateNotAlreadyBuilt();\n            this.modelInitializer = modelInitializer;\n            testParser.setModelWriteSanitizer(modelWriteSanitizer);\n            return this;\n        }","id":30215,"modified_method":"@Override\n        public KernelServicesBuilder setModelInitializer(ModelInitializer modelInitializer, ModelWriteSanitizer modelWriteSanitizer) {\n            bootOperationBuilder.validateNotAlreadyBuilt();\n            this.modelInitializer = modelInitializer;\n            this.modelWriteSanitizer = modelWriteSanitizer;\n            testParser.setModelWriteSanitizer(modelWriteSanitizer);\n            return this;\n        }","commit_id":"662537f514131548670c1682445b86edc958c004","url":"https://github.com/wildfly/wildfly"},{"original_method":"private LegacyControllerKernelServicesProxy install(AbstractKernelServicesImpl mainServices, List<ModelNode> bootOperations) throws Exception {\n            if (testControllerVersion == null) {\n                throw new IllegalStateException();\n            }\n\n            classLoaderBuilder.addParentFirstClassPattern(\"org.jboss.as.core.model.bridge.shared.*\");\n\n            File file = new File(\"target\", \"cached-classloader\" + modelVersion + \"_\" + testControllerVersion);\n            boolean cached = file.exists();\n            ClassLoader legacyCl;\n            if (cached) {\n                classLoaderBuilder.createFromFile(file);\n                legacyCl = classLoaderBuilder.build();\n            } else {\n                String version = LegacyKernelServicesInitializer.VersionLocator.getCurrentVersion();\n                classLoaderBuilder.addMavenResourceURL(\"org.jboss.as:jboss-as-core-model-test-framework:\"+version);\n                classLoaderBuilder.addMavenResourceURL(\"org.jboss.as:jboss-as-model-test:\"+version);\n\n                if (testControllerVersion != TestControllerVersion.MASTER) {\n                    classLoaderBuilder.addRecursiveMavenResourceURL(testControllerVersion.getLegacyControllerMavenGav());\n                    classLoaderBuilder.addMavenResourceURL(\"org.jboss.as:jboss-as-core-model-test-controller-\" + testControllerVersion.getTestControllerVersion() + \":\" +version);\n                }\n                legacyCl = classLoaderBuilder.build(file);\n            }\n\n\n            ScopedKernelServicesBootstrap scopedBootstrap = new ScopedKernelServicesBootstrap(legacyCl);\n            LegacyControllerKernelServicesProxy legacyServices = scopedBootstrap.createKernelServices(bootOperations, validateOperations, modelVersion, modelInitializerEntries);\n\n            return legacyServices;\n        }","id":30216,"modified_method":"private LegacyControllerKernelServicesProxy install(AbstractKernelServicesImpl mainServices, ModelInitializer modelInitializer, ModelWriteSanitizer modelWriteSanitizer, List<String> contentRepositoryContents, List<ModelNode> bootOperations) throws Exception {\n            if (testControllerVersion == null) {\n                throw new IllegalStateException();\n            }\n\n            if (!skipReverseCheck) {\n                bootCurrentVersionWithLegacyBootOperations(bootOperations, modelInitializer, modelWriteSanitizer, contentRepositoryContents, mainServices);\n            }\n\n            classLoaderBuilder.addParentFirstClassPattern(\"org.jboss.as.core.model.bridge.shared.*\");\n\n            File file = new File(\"target\", \"cached-classloader\" + modelVersion + \"_\" + testControllerVersion);\n            boolean cached = file.exists();\n            ClassLoader legacyCl;\n            if (cached) {\n                classLoaderBuilder.createFromFile(file);\n                legacyCl = classLoaderBuilder.build();\n            } else {\n                String version = LegacyKernelServicesInitializer.VersionLocator.getCurrentVersion();\n                classLoaderBuilder.addMavenResourceURL(\"org.jboss.as:jboss-as-core-model-test-framework:\"+version);\n                classLoaderBuilder.addMavenResourceURL(\"org.jboss.as:jboss-as-model-test:\"+version);\n\n                if (testControllerVersion != TestControllerVersion.MASTER) {\n                    classLoaderBuilder.addRecursiveMavenResourceURL(testControllerVersion.getLegacyControllerMavenGav());\n                    classLoaderBuilder.addMavenResourceURL(\"org.jboss.as:jboss-as-core-model-test-controller-\" + testControllerVersion.getTestControllerVersion() + \":\" +version);\n                }\n                legacyCl = classLoaderBuilder.build(file);\n            }\n\n\n            ScopedKernelServicesBootstrap scopedBootstrap = new ScopedKernelServicesBootstrap(legacyCl);\n            LegacyControllerKernelServicesProxy legacyServices = scopedBootstrap.createKernelServices(bootOperations, validateOperations, modelVersion, modelInitializerEntries);\n\n            return legacyServices;\n        }","commit_id":"662537f514131548670c1682445b86edc958c004","url":"https://github.com/wildfly/wildfly"},{"original_method":"public KernelServices build() throws Exception {\n            bootOperationBuilder.validateNotAlreadyBuilt();\n            List<ModelNode> bootOperations = bootOperationBuilder.build();\n            AbstractKernelServicesImpl kernelServices = AbstractKernelServicesImpl.create(processType, runningModeControl, validateOperations, bootOperations, testParser, null, type, modelInitializer, extensionRegistry, contentRepositoryContents);\n            CoreModelTestDelegate.this.kernelServices.add(kernelServices);\n\n            if (validateDescription) {\n                validateDescriptionProviders(type, kernelServices);\n            }\n\n\n            ModelTestUtils.validateModelDescriptions(PathAddress.EMPTY_ADDRESS, kernelServices.getRootRegistration());\n            ModelTestUtils.scanForExpressionFormattedStrings(kernelServices.readWholeModel());\n\n            for (Map.Entry<ModelVersion, LegacyKernelServicesInitializerImpl> entry : legacyControllerInitializers.entrySet()) {\n                LegacyKernelServicesInitializerImpl legacyInitializer = entry.getValue();\n\n                List<ModelNode> transformedBootOperations;\n                if (legacyInitializer.isDontUseBootOperations()) {\n                    transformedBootOperations = Collections.emptyList();\n                } else {\n                    transformedBootOperations = new ArrayList<ModelNode>();\n                    for (ModelNode op : bootOperations) {\n\n                        ModelNode transformed = kernelServices.transformOperation(entry.getKey(), op).getTransformedOperation();\n                        if (transformed != null) {\n                            transformedBootOperations.add(transformed);\n                        }\n                    }\n                }\n\n                LegacyControllerKernelServicesProxy legacyServices = legacyInitializer.install(kernelServices, transformedBootOperations);\n                kernelServices.addLegacyKernelService(entry.getKey(), legacyServices);\n            }\n\n\n            return kernelServices;\n        }","id":30217,"modified_method":"public KernelServices build() throws Exception {\n            bootOperationBuilder.validateNotAlreadyBuilt();\n            List<ModelNode> bootOperations = bootOperationBuilder.build();\n            AbstractKernelServicesImpl kernelServices = AbstractKernelServicesImpl.create(processType, runningModeControl, validateOperations, bootOperations, testParser, null, type, modelInitializer, extensionRegistry, contentRepositoryContents);\n            CoreModelTestDelegate.this.kernelServices.add(kernelServices);\n\n            if (validateDescription) {\n                validateDescriptionProviders(type, kernelServices);\n            }\n\n\n            ModelTestUtils.validateModelDescriptions(PathAddress.EMPTY_ADDRESS, kernelServices.getRootRegistration());\n            ModelTestUtils.scanForExpressionFormattedStrings(kernelServices.readWholeModel());\n\n            for (Map.Entry<ModelVersion, LegacyKernelServicesInitializerImpl> entry : legacyControllerInitializers.entrySet()) {\n                LegacyKernelServicesInitializerImpl legacyInitializer = entry.getValue();\n\n                List<ModelNode> transformedBootOperations;\n                if (legacyInitializer.isDontUseBootOperations()) {\n                    transformedBootOperations = Collections.emptyList();\n                } else {\n                    transformedBootOperations = new ArrayList<ModelNode>();\n                    for (ModelNode op : bootOperations) {\n\n                        ModelNode transformed = kernelServices.transformOperation(entry.getKey(), op).getTransformedOperation();\n                        if (transformed != null) {\n                            transformedBootOperations.add(transformed);\n                        }\n                    }\n                }\n\n                LegacyControllerKernelServicesProxy legacyServices = legacyInitializer.install(kernelServices, modelInitializer, modelWriteSanitizer, contentRepositoryContents, transformedBootOperations);\n                kernelServices.addLegacyKernelService(entry.getKey(), legacyServices);\n            }\n\n\n            return kernelServices;\n        }","commit_id":"662537f514131548670c1682445b86edc958c004","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeploymentOverlaysIgnoredOnOlderVersionGetIgnored() throws Exception {\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() >= 4) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .setXmlResource(\"domain-no-servergroup-overlay.xml\");\n\n        //Start up an empty legacy controller\n        StandardServerGroupInitializers.addServerGroupInitializers(\n                    builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion)\n                )\n                .setDontUseBootOperations();\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        //This should pass since the deployment-overlay resource is ignored, and there is no use of deployment-overlay in server-group\n        mainServices.applyMasterDomainModel(modelVersion, Collections.singletonList(new IgnoreDomainResourceTypeResource(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, new ModelNode(), true)));\n\n        //Check deployment overlays exist in the master model but not in the legacy model\n        ModelNode masterModel = mainServices.readWholeModel();\n        ModelNode legacyModel = legacyServices.readWholeModel();\n        Assert.assertTrue(masterModel.hasDefined(ModelDescriptionConstants.DEPLOYMENT_OVERLAY) && masterModel.get(ModelDescriptionConstants.DEPLOYMENT_OVERLAY).hasDefined(\"test-overlay\"));\n        Assert.assertFalse(legacyModel.hasDefined(ModelDescriptionConstants.DEPLOYMENT_OVERLAY));\n\n        //Compare the transformed and legacy models\n        checkCoreModelTransformation(\n                mainServices,\n                modelVersion,\n                new ModelFixer() {\n                    @Override\n                    public ModelNode fixModel(ModelNode modelNode) {\n                        //This one is just noise due to a different format\n                        //Perhaps this should go into the model comparison itself?\n                        ModelNode socketBindingGroup = modelNode.get(SOCKET_BINDING_GROUP, \"test-sockets\");\n                        if (socketBindingGroup.isDefined()) {\n                            Set<String> names = new HashSet<String>();\n                            for (String key : socketBindingGroup.keys()) {\n                                if (!socketBindingGroup.get(key).isDefined()) {\n                                    names.add(key);\n                                }\n                            }\n                            for(String name : names) {\n                                socketBindingGroup.remove(name);\n                            }\n                            if (socketBindingGroup.keys().size() == 0) {\n                                socketBindingGroup.clear();\n                            }\n                        }\n                        return modelNode;\n                    }\n                },\n                new ModelFixer() {\n                    @Override\n                    public ModelNode fixModel(ModelNode modelNode) {\n                        modelNode.remove(ModelDescriptionConstants.DEPLOYMENT_OVERLAY);\n                        return modelNode;\n                    }\n                });\n    }","id":30218,"modified_method":"@Test\n    public void testDeploymentOverlaysIgnoredOnOlderVersionGetIgnored() throws Exception {\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() >= 4) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .setXmlResource(\"domain-no-servergroup-overlay.xml\");\n\n        //Start up an empty legacy controller\n        StandardServerGroupInitializers.addServerGroupInitializers(\n                    builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion)\n                )\n                .setDontUseBootOperations()\n                //Since the legacy controller does not know about deployment overlays, there will be not boot ops for the reverse check\n                .skipReverseControllerCheck();\n\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        //This should pass since the deployment-overlay resource is ignored, and there is no use of deployment-overlay in server-group\n        mainServices.applyMasterDomainModel(modelVersion, Collections.singletonList(new IgnoreDomainResourceTypeResource(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, new ModelNode(), true)));\n\n        //Check deployment overlays exist in the master model but not in the legacy model\n        ModelNode masterModel = mainServices.readWholeModel();\n        ModelNode legacyModel = legacyServices.readWholeModel();\n        Assert.assertTrue(masterModel.hasDefined(ModelDescriptionConstants.DEPLOYMENT_OVERLAY) && masterModel.get(ModelDescriptionConstants.DEPLOYMENT_OVERLAY).hasDefined(\"test-overlay\"));\n        Assert.assertFalse(legacyModel.hasDefined(ModelDescriptionConstants.DEPLOYMENT_OVERLAY));\n\n        //Compare the transformed and legacy models\n        checkCoreModelTransformation(\n                mainServices,\n                modelVersion,\n                new ModelFixer() {\n                    @Override\n                    public ModelNode fixModel(ModelNode modelNode) {\n                        //This one is just noise due to a different format\n                        //Perhaps this should go into the model comparison itself?\n                        ModelNode socketBindingGroup = modelNode.get(SOCKET_BINDING_GROUP, \"test-sockets\");\n                        if (socketBindingGroup.isDefined()) {\n                            Set<String> names = new HashSet<String>();\n                            for (String key : socketBindingGroup.keys()) {\n                                if (!socketBindingGroup.get(key).isDefined()) {\n                                    names.add(key);\n                                }\n                            }\n                            for(String name : names) {\n                                socketBindingGroup.remove(name);\n                            }\n                            if (socketBindingGroup.keys().size() == 0) {\n                                socketBindingGroup.clear();\n                            }\n                        }\n                        return modelNode;\n                    }\n                },\n                new ModelFixer() {\n                    @Override\n                    public ModelNode fixModel(ModelNode modelNode) {\n                        modelNode.remove(ModelDescriptionConstants.DEPLOYMENT_OVERLAY);\n                        return modelNode;\n                    }\n                });\n    }","commit_id":"662537f514131548670c1682445b86edc958c004","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeploymentOverlaysIgnoredOnOlderVersionGetIgnoredButFailDueToServerGroupEntry() throws Exception {\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() >= 4) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .setXmlResource(\"domain.xml\");\n\n        //Start up an empty legacy controller\n        StandardServerGroupInitializers.addServerGroupInitializers(\n                    builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion)\n                )\n                .setDontUseBootOperations();\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        //Since the server group deployment deployment-overlay is there we should fail\n        try {\n            mainServices.applyMasterDomainModel(modelVersion, null);\n            Assert.fail(\"Should have failed to apply model since server group still has a deployment overlay\");\n        } catch(Exception e) {\n            Assert.assertTrue(e.getMessage(), e.getMessage().contains(\"14738\")); //14738 comes from ControllerMessages.noChildType(String)\n        }\n    }","id":30219,"modified_method":"@Test\n    public void testDeploymentOverlaysIgnoredOnOlderVersionGetIgnoredButFailDueToServerGroupEntry() throws Exception {\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() >= 4) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .setXmlResource(\"domain.xml\");\n\n        //Start up an empty legacy controller\n        StandardServerGroupInitializers.addServerGroupInitializers(\n                    builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion)\n                )\n                .setDontUseBootOperations()\n                //Since the legacy controller does not know about deployment overlays, there will be not boot ops for the reverse check\n                .skipReverseControllerCheck();\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        //Since the server group deployment deployment-overlay is there we should fail\n        try {\n            mainServices.applyMasterDomainModel(modelVersion, null);\n            Assert.fail(\"Should have failed to apply model since server group still has a deployment overlay\");\n        } catch(Exception e) {\n            Assert.assertTrue(e.getMessage(), e.getMessage().contains(\"14738\")); //14738 comes from ControllerMessages.noChildType(String)\n        }\n    }","commit_id":"662537f514131548670c1682445b86edc958c004","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDeploymentOverlaysNotIgnoredOnOlderVersionFails() throws Exception {\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() >= 4) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .setXmlResource(\"domain.xml\");\n\n        //Start up an empty legacy controller\n        StandardServerGroupInitializers.addServerGroupInitializers(\n                    builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion)\n                )\n                .setDontUseBootOperations();\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        //Since we had not set up the ignores the legacy controller cannot have the master model applied\n        try {\n            mainServices.applyMasterDomainModel(modelVersion, null);\n            Assert.fail(\"Should have failed to apply model without deployment-overlay ignored on host\");\n        } catch(Exception e) {\n            Assert.assertTrue(e.getMessage(), e.getMessage().contains(\"14738\")); //14738 comes from ControllerMessages.noChildType(String)\n        }\n    }","id":30220,"modified_method":"@Test\n    public void testDeploymentOverlaysNotIgnoredOnOlderVersionFails() throws Exception {\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() >= 4) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .setXmlResource(\"domain.xml\");\n\n        //Start up an empty legacy controller\n        StandardServerGroupInitializers.addServerGroupInitializers(\n                    builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion)\n                )\n                .setDontUseBootOperations()\n                //Since the legacy controller does not know about deployment overlays, there will be not boot ops for the reverse check\n                .skipReverseControllerCheck();\n\n        KernelServices mainServices = builder.build();\n        Assert.assertTrue(mainServices.isSuccessfulBoot());\n        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);\n        Assert.assertTrue(legacyServices.isSuccessfulBoot());\n\n        //Since we had not set up the ignores the legacy controller cannot have the master model applied\n        try {\n            mainServices.applyMasterDomainModel(modelVersion, null);\n            Assert.fail(\"Should have failed to apply model without deployment-overlay ignored on host\");\n        } catch(Exception e) {\n            Assert.assertTrue(e.getMessage(), e.getMessage().contains(\"14738\")); //14738 comes from ControllerMessages.noChildType(String)\n        }\n    }","commit_id":"662537f514131548670c1682445b86edc958c004","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRejectTransformers71x() throws Exception {\n\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() > 3) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .createContentRepositoryContent(\"09876543210987654321\");\n\n        // Add legacy subsystems\n        LegacyKernelServicesInitializer legacyInitializer =\n                StandardServerGroupInitializers.addServerGroupInitializers(builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion));\n        // The 7.1.x descriptions are inaccurate so we can't validate the add ops against them\n        legacyInitializer.setDontValidateOperations();\n\n        KernelServices mainServices = builder.build();\n\n        List<ModelNode> ops = builder.parseXmlResource(\"servergroup_1_3-with-expressions.xml\");\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, ops, new FailedOperationTransformationConfig()\n                .addFailedAttribute(PathAddress.pathAddress(PathElement.pathElement(SERVER_GROUP)),\n                        new FailedOperationTransformationConfig.RejectExpressionsConfig(\n                                ServerGroupResourceDefinition.MANAGEMENT_SUBSYSTEM_ENDPOINT,\n                                ServerGroupResourceDefinition.SOCKET_BINDING_PORT_OFFSET\n                        ).setReadOnly(ServerGroupResourceDefinition.MANAGEMENT_SUBSYSTEM_ENDPOINT)));\n    }","id":30221,"modified_method":"@Test\n    public void testRejectTransformers71x() throws Exception {\n\n        if (modelVersion.getMajor() > 1 || modelVersion.getMinor() > 3) {\n            return;\n        }\n\n        KernelServicesBuilder builder = createKernelServicesBuilder(TestModelType.DOMAIN)\n                .setModelInitializer(StandardServerGroupInitializers.XML_MODEL_INITIALIZER, StandardServerGroupInitializers.XML_MODEL_WRITE_SANITIZER)\n                .createContentRepositoryContent(\"12345678901234567890\")\n                .createContentRepositoryContent(\"09876543210987654321\");\n\n        // Add legacy subsystems\n        LegacyKernelServicesInitializer legacyInitializer =\n                StandardServerGroupInitializers.addServerGroupInitializers(builder.createLegacyKernelServicesBuilder(modelVersion, testControllerVersion))\n                //The reverse stuff is tested in the other test\n                .skipReverseControllerCheck();\n        // The 7.1.x descriptions are inaccurate so we can't validate the add ops against them\n        legacyInitializer.setDontValidateOperations();\n\n        KernelServices mainServices = builder.build();\n\n        List<ModelNode> ops = builder.parseXmlResource(\"servergroup_1_3-with-expressions.xml\");\n        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, modelVersion, ops, new FailedOperationTransformationConfig()\n                .addFailedAttribute(PathAddress.pathAddress(PathElement.pathElement(SERVER_GROUP)),\n                        new FailedOperationTransformationConfig.RejectExpressionsConfig(\n                                ServerGroupResourceDefinition.MANAGEMENT_SUBSYSTEM_ENDPOINT,\n                                ServerGroupResourceDefinition.SOCKET_BINDING_PORT_OFFSET\n                        ).setReadOnly(ServerGroupResourceDefinition.MANAGEMENT_SUBSYSTEM_ENDPOINT)));\n    }","commit_id":"662537f514131548670c1682445b86edc958c004","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n  public WorkerNetAddress getWorkerForNextBlock(List<BlockWorkerInfo> workerInfoList,\n      long blockSizeBytes) {\n    // first try the local host\n    for (BlockWorkerInfo workerInfo : workerInfoList) {\n      if (workerInfo.getNetAddress().getHost().equals(mLocalHostName)\n          && workerInfo.getCapacityBytes() - workerInfo.getUsedBytes() > blockSizeBytes) {\n        return workerInfo.getNetAddress();\n      }\n    }\n\n    // otherwise randomly pick a worker that has enough availability\n    Collections.shuffle(workerInfoList);\n    for (BlockWorkerInfo workerInfo : workerInfoList) {\n      if (workerInfo.getCapacityBytes() - workerInfo.getUsedBytes() > blockSizeBytes) {\n        return workerInfo.getNetAddress();\n      }\n    }\n    return null;\n  }","id":30222,"modified_method":"@Override\n  public WorkerNetAddress getWorkerForNextBlock(List<BlockWorkerInfo> workerInfoList,\n      long blockSizeBytes) {\n    // first try the local host\n    for (BlockWorkerInfo workerInfo : workerInfoList) {\n      if (workerInfo.getNetAddress().getHost().equals(mLocalHostName)\n          && workerInfo.getCapacityBytes() > blockSizeBytes) {\n        return workerInfo.getNetAddress();\n      }\n    }\n\n    // otherwise randomly pick a worker that has enough availability\n    Collections.shuffle(workerInfoList);\n    for (BlockWorkerInfo workerInfo : workerInfoList) {\n      if (workerInfo.getCapacityBytes() >= blockSizeBytes) {\n        return workerInfo.getNetAddress();\n      }\n    }\n    return null;\n  }","commit_id":"924562829b3fb46e92995ea33a40b4f77c57aa1a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void getOthersWhenNotEnoughSpaceOnLocal() {\n    String localhostName = NetworkAddressUtils.getLocalHostName(ClientContext.getConf());\n    LocalFirstPolicy policy = new LocalFirstPolicy();\n    List<BlockWorkerInfo> workerInfoList = Lists.newArrayList();\n    workerInfoList.add(\n        new BlockWorkerInfo(new WorkerNetAddress(\"worker1\", PORT, PORT, PORT), Constants.GB, 0));\n    workerInfoList.add(new BlockWorkerInfo(new WorkerNetAddress(localhostName, PORT, PORT, PORT),\n        Constants.GB, Constants.GB));\n    Assert.assertEquals(\"worker1\",\n        policy.getWorkerForNextBlock(workerInfoList, Constants.MB).getHost());\n  }","id":30223,"modified_method":"@Test\n  public void getOthersWhenNotEnoughSpaceOnLocal() {\n    String localhostName = NetworkAddressUtils.getLocalHostName(ClientContext.getConf());\n    LocalFirstPolicy policy = new LocalFirstPolicy();\n    List<BlockWorkerInfo> workerInfoList = Lists.newArrayList();\n    workerInfoList.add(\n        new BlockWorkerInfo(new WorkerNetAddress(\"worker1\", PORT, PORT, PORT), Constants.GB, 0));\n    workerInfoList.add(new BlockWorkerInfo(new WorkerNetAddress(localhostName, PORT, PORT, PORT),\n        Constants.MB, Constants.MB));\n    Assert.assertEquals(\"worker1\",\n        policy.getWorkerForNextBlock(workerInfoList, Constants.GB).getHost());\n  }","commit_id":"924562829b3fb46e92995ea33a40b4f77c57aa1a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public WorkerNetAddress getWorkerForNextBlock(List<BlockWorkerInfo> workerInfoList,\n      long blockSizeBytes) {\n    List<BlockWorkerInfo> inputList = Lists.newArrayList(workerInfoList);\n    long mostAvailableBytes = -1;\n    WorkerNetAddress result = null;\n    for (BlockWorkerInfo workerInfo : inputList) {\n      if (workerInfo.getCapacityBytes() - workerInfo.getUsedBytes() > mostAvailableBytes) {\n        mostAvailableBytes = workerInfo.getCapacityBytes() - workerInfo.getUsedBytes();\n        result = workerInfo.getNetAddress();\n      }\n    }\n    if (mostAvailableBytes < blockSizeBytes) {\n      // no worker has enough space\n      return null;\n    }\n    return result;\n  }","id":30224,"modified_method":"@Override\n  public WorkerNetAddress getWorkerForNextBlock(List<BlockWorkerInfo> workerInfoList,\n      long blockSizeBytes) {\n    List<BlockWorkerInfo> inputList = Lists.newArrayList(workerInfoList);\n    long mostAvailableBytes = -1;\n    WorkerNetAddress result = null;\n    for (BlockWorkerInfo workerInfo : inputList) {\n      if (workerInfo.getCapacityBytes() - workerInfo.getUsedBytes() > mostAvailableBytes) {\n        mostAvailableBytes = workerInfo.getCapacityBytes() - workerInfo.getUsedBytes();\n        result = workerInfo.getNetAddress();\n      }\n    }\n    return result;\n  }","commit_id":"924562829b3fb46e92995ea33a40b4f77c57aa1a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public WorkerNetAddress getWorkerForNextBlock(List<BlockWorkerInfo> workerInfoList,\n      long blockSizeBytes) {\n    if (!mInitialized) {\n      mWorkerInfoList = workerInfoList;\n      Collections.shuffle(mWorkerInfoList);\n      mIndex = 0;\n      mInitialized = true;\n    }\n\n    // at most try all the workers\n    for (int i = 0; i < mWorkerInfoList.size(); i ++) {\n      WorkerNetAddress candidate = mWorkerInfoList.get(mIndex).getNetAddress();\n      BlockWorkerInfo workerInfo = findBlockWorkerInfo(workerInfoList, candidate);\n      mIndex = (mIndex + 1) % mWorkerInfoList.size();\n      if (workerInfo == null\n          || workerInfo.getCapacityBytes() - workerInfo.getUsedBytes() < blockSizeBytes) {\n        continue;\n      }\n      return candidate;\n    }\n    return null;\n  }","id":30225,"modified_method":"@Override\n  public WorkerNetAddress getWorkerForNextBlock(List<BlockWorkerInfo> workerInfoList,\n      long blockSizeBytes) {\n    if (!mInitialized) {\n      mWorkerInfoList = workerInfoList;\n      Collections.shuffle(mWorkerInfoList);\n      mIndex = 0;\n      mInitialized = true;\n    }\n\n    // at most try all the workers\n    for (int i = 0; i < mWorkerInfoList.size(); i ++) {\n      WorkerNetAddress candidate = mWorkerInfoList.get(mIndex).getNetAddress();\n      BlockWorkerInfo workerInfo = findBlockWorkerInfo(workerInfoList, candidate);\n      mIndex = (mIndex + 1) % mWorkerInfoList.size();\n      if (workerInfo == null || workerInfo.getCapacityBytes() < blockSizeBytes) {\n        continue;\n      }\n      return candidate;\n    }\n    return null;\n  }","commit_id":"924562829b3fb46e92995ea33a40b4f77c57aa1a","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void needToEvictTest() throws IOException {\n    // Requested space can only be satisfied after evicting some cached blocks\n\n    EvictorTestUtils.randomCache(USER_ID, BLOCK_ID, mMetaManager, mEvictor);\n\n    // find a non-empty dir\n    StorageDir nonEmptyDir = null;\n    boolean found = false;\n    for (StorageTier tier : mMetaManager.getTiers()) {\n      for (StorageDir dir : tier.getStorageDirs()) {\n        if (dir.getAvailableBytes() != dir.getCapacityBytes()) {\n          nonEmptyDir = dir;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n\n    if (nonEmptyDir == null) {\n      // seems like randomCache did not cache any data, so cache data in a random dir\n      nonEmptyDir = EvictorTestUtils.randomDir(mMetaManager);\n      EvictorTestUtils.cache(USER_ID, BLOCK_ID, nonEmptyDir.getCapacityBytes() - 1, nonEmptyDir,\n          mMetaManager, mEvictor);\n    }\n\n    long requestBytes = nonEmptyDir.getCapacityBytes();\n    EvictionPlan plan = mEvictor.freeSpace(requestBytes, nonEmptyDir.toBlockStoreLocation());\n    EvictorTestUtils.assertLegalPlan(requestBytes, plan, mMetaManager);\n  }","id":30226,"modified_method":"@Test\n  public void needToEvictTest() throws IOException {\n    // fill in a dir and request the capacity of the dir, all cached data in the dir should be\n    // evicted.\n    StorageDir dir = mTestDir;\n    long capacityBytes = dir.getCapacityBytes();\n    EvictorTestUtils.cache(USER_ID, BLOCK_ID, capacityBytes, dir, mMetaManager, mEvictor);\n\n    EvictionPlan plan = mEvictor.freeSpace(capacityBytes, dir.toBlockStoreLocation());\n    EvictorTestUtils.assertLegalPlan(capacityBytes, plan, mMetaManager);\n  }","commit_id":"5ddc0ba9a66a0d728bc55cdcad217f707f3d0558","url":"https://github.com/amplab/tachyon"},{"original_method":"@Before\n  public final void before() throws IOException {\n    mTempFolder = Files.createTempDir();\n    mMetaManager = EvictorTestUtils.defaultMetadataManager(mTempFolder.getAbsolutePath());\n    mEvictor = EvictorFactory.create(mEvictorType, mMetaManager);\n  }","id":30227,"modified_method":"@Before\n  public final void before() throws IOException {\n    mTempFolder = Files.createTempDir();\n    mMetaManager = EvictorTestUtils.defaultMetadataManager(mTempFolder.getAbsolutePath());\n    List<StorageTier> tiers = mMetaManager.getTiers();\n    mTestDir = tiers.get(TEST_TIER).getDir(TEST_DIR);\n    mEvictor = EvictorFactory.create(mEvictorType, mMetaManager);\n  }","commit_id":"5ddc0ba9a66a0d728bc55cdcad217f707f3d0558","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void needToEvictAnyDirInTierTest() throws IOException {\n    // cache data with size of \"(capacity - 1)\" in each dir in a tier, request size of \"capacity\" of\n    // a dir in this tier from anyDirInTier(tier)\n    StorageTier tier = mMetaManager.getTiers().get(0);\n    long blockId = BLOCK_ID;\n    List<StorageDir> dirs = tier.getStorageDirs();\n    for (StorageDir dir : dirs) {\n      EvictorTestUtils.cache(USER_ID, blockId, dir.getCapacityBytes() - 1, dir, mMetaManager,\n          mEvictor);\n      blockId ++;\n    }\n\n    long requestBytes = dirs.get(0).getCapacityBytes();\n    EvictionPlan plan =\n        mEvictor.freeSpace(requestBytes, BlockStoreLocation.anyDirInTier(tier.getTierAlias()));\n    EvictorTestUtils.assertLegalPlan(requestBytes, plan, mMetaManager);\n  }","id":30228,"modified_method":"@Test\n  public void needToEvictAnyDirInTierTest() throws IOException {\n    // cache data with size of \"(capacity - 1)\" in each dir in a tier, request size of \"capacity\" of\n    // the last dir(whose capacity is largest) in this tier from anyDirInTier(tier), all blocks\n    // cached in the last dir should be in the eviction plan.\n    StorageTier tier = mMetaManager.getTiers().get(0);\n    long blockId = BLOCK_ID;\n    List<StorageDir> dirs = tier.getStorageDirs();\n    for (StorageDir dir : dirs) {\n      EvictorTestUtils.cache(USER_ID, blockId, dir.getCapacityBytes() - 1, dir, mMetaManager,\n          mEvictor);\n      blockId ++;\n    }\n\n    long requestBytes = dirs.get(dirs.size() - 1).getCapacityBytes();\n    EvictionPlan plan =\n        mEvictor.freeSpace(requestBytes, BlockStoreLocation.anyDirInTier(tier.getTierAlias()));\n    EvictorTestUtils.assertLegalPlan(requestBytes, plan, mMetaManager);\n  }","commit_id":"5ddc0ba9a66a0d728bc55cdcad217f707f3d0558","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void noNeedToEvictTest3() throws IOException {\n    // fill in all dirs except for a random directory in a random tier, then request the capacity of\n    // the directory with anyDirInTier\n    StorageDir dirLeft = EvictorTestUtils.randomDir(mMetaManager);\n    long blockId = BLOCK_ID; // start from BLOCK_ID\n    for (StorageTier tier : mMetaManager.getTiers()) {\n      for (StorageDir dir : tier.getStorageDirs()) {\n        if (dir != dirLeft) {\n          EvictorTestUtils.cache(USER_ID, blockId, dir.getCapacityBytes(), dir, mMetaManager,\n              mEvictor);\n          blockId ++;\n        }\n      }\n    }\n    Assert.assertTrue(mEvictor.freeSpace(dirLeft.getCapacityBytes(),\n        BlockStoreLocation.anyDirInTier(dirLeft.getParentTier().getTierAlias())).isEmpty());\n  }","id":30229,"modified_method":"@Test\n  public void noNeedToEvictTest3() throws IOException {\n    // fill in all dirs except for one directory, then request the capacity of\n    // the directory with anyDirInTier\n    StorageDir dirLeft = mTestDir;\n    long blockId = BLOCK_ID; // start from BLOCK_ID\n    for (StorageTier tier : mMetaManager.getTiers()) {\n      for (StorageDir dir : tier.getStorageDirs()) {\n        if (dir != dirLeft) {\n          EvictorTestUtils.cache(USER_ID, blockId, dir.getCapacityBytes(), dir, mMetaManager,\n              mEvictor);\n          blockId ++;\n        }\n      }\n    }\n    Assert.assertTrue(mEvictor.freeSpace(dirLeft.getCapacityBytes(),\n        BlockStoreLocation.anyDirInTier(dirLeft.getParentTier().getTierAlias())).isEmpty());\n  }","commit_id":"5ddc0ba9a66a0d728bc55cdcad217f707f3d0558","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void requestSpaceLargerThanCapacityTest() throws IOException {\n    long totalCapacity = mMetaManager.getAvailableBytes(BlockStoreLocation.anyTier());\n    StorageDir dir = EvictorTestUtils.randomDir(mMetaManager);\n    BlockStoreLocation dirLocation = dir.toBlockStoreLocation();\n    long dirCapacity = mMetaManager.getAvailableBytes(dirLocation);\n\n    EvictorTestUtils.randomCache(USER_ID, BLOCK_ID, mMetaManager, mEvictor);\n\n    // request space larger than total capacity\n    Assert.assertNull(mEvictor.freeSpace(totalCapacity + 1, BlockStoreLocation.anyTier()));\n    // request space larger than capacity for the random directory\n    Assert.assertNull(mEvictor.freeSpace(dirCapacity + 1, dirLocation));\n  }","id":30230,"modified_method":"@Test\n  public void requestSpaceLargerThanCapacityTest() throws IOException {\n    // cache data in a dir\n    long totalCapacity = mMetaManager.getAvailableBytes(BlockStoreLocation.anyTier());\n    StorageDir dir = mTestDir;\n    BlockStoreLocation dirLocation = dir.toBlockStoreLocation();\n    long dirCapacity = mMetaManager.getAvailableBytes(dirLocation);\n\n    EvictorTestUtils.cache(USER_ID, BLOCK_ID, dirCapacity, dir, mMetaManager, mEvictor);\n\n    // request space larger than total capacity, no eviction plan should be available\n    Assert.assertNull(mEvictor.freeSpace(totalCapacity + 1, BlockStoreLocation.anyTier()));\n    // request space larger than capacity for the random directory, no eviction plan should be\n    // available\n    Assert.assertNull(mEvictor.freeSpace(dirCapacity + 1, dirLocation));\n  }","commit_id":"5ddc0ba9a66a0d728bc55cdcad217f707f3d0558","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void noNeedToEvictTest2() throws IOException {\n    // cache some data in a dir, then request the remaining space from the dir\n    StorageDir dir = EvictorTestUtils.randomDir(mMetaManager);\n    long capacity = dir.getCapacityBytes();\n    long cachedBytes = capacity / 2 + 1;\n    EvictorTestUtils.cache(USER_ID, BLOCK_ID, cachedBytes, dir, mMetaManager, mEvictor);\n    Assert.assertTrue(mEvictor.freeSpace(capacity - cachedBytes, dir.toBlockStoreLocation())\n        .isEmpty());\n  }","id":30231,"modified_method":"@Test\n  public void noNeedToEvictTest2() throws IOException {\n    // cache some data in a dir, then request the remaining space from the dir, the eviction plan\n    // should be empty.\n    StorageDir dir = mTestDir;\n    long capacity = dir.getCapacityBytes();\n    long cachedBytes = capacity / 2 + 1;\n    EvictorTestUtils.cache(USER_ID, BLOCK_ID, cachedBytes, dir, mMetaManager, mEvictor);\n    Assert.assertTrue(mEvictor.freeSpace(capacity - cachedBytes, dir.toBlockStoreLocation())\n        .isEmpty());\n  }","commit_id":"5ddc0ba9a66a0d728bc55cdcad217f707f3d0558","url":"https://github.com/amplab/tachyon"},{"original_method":"public Method getAlternativeIconMethod(ConceptDeclaration concept) {\n    String conceptFqName = concept.getConceptFQName();\n    String fqName = NameUtil.nodeFQName(concept);\n    String namespace = NameUtil.namespaceFromConcept(concept);\n    Language language = GlobalScope.getInstance().getLanguage(namespace);\n    String behaviorClassName = constraintsClassByConceptFqName(fqName);\n    Class behaviorClass = language.getClass(behaviorClassName);\n\n    if (behaviorClass == null) {\n      return null;\n    }\n\n    try {\n      Method method = behaviorClass.getMethod(BehaviorConstants.GET_ALTERNATIVE_ICON_METHOD_NAME, SNode.class);\n      return method;\n    } catch (NoSuchMethodException e) {\n      //it's ok\n    }\n    return null;\n  }","id":30232,"modified_method":"public Method getAlternativeIconMethod(ConceptDeclaration concept) {\n    String fqName = NameUtil.nodeFQName(concept);\n    String namespace = NameUtil.namespaceFromConcept(concept);\n    Language language = GlobalScope.getInstance().getLanguage(namespace);\n    String behaviorClassName = constraintsClassByConceptFqName(fqName);\n    Class behaviorClass = language.getClass(behaviorClassName);\n\n    if (behaviorClass == null) {\n      return null;\n    }\n\n    try {\n      Method method = behaviorClass.getMethod(BehaviorConstants.GET_ALTERNATIVE_ICON_METHOD_NAME, SNode.class);\n      return method;\n    } catch (NoSuchMethodException e) {\n      //it's ok\n    }\n    return null;\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getDefaultConcreteConceptFqName(String fqName, IScope scope) {\n    synchronized (myDefaultConceptNames) {\n      String result = myDefaultConceptNames.get(fqName);\n      if(result != null) {\n        return result;\n      }\n\n      String behaviorClass = constraintsClassByConceptFqName(fqName);\n      String namespace = NameUtil.namespaceFromConceptFQName(fqName);\n      Language language = scope.getLanguage(namespace);\n      if (language != null) {\n        result = fqName;\n        Class cls = language.getClass(behaviorClass);\n        if (cls != null) {\n          try {\n            Method method = cls.getMethod(BehaviorConstants.GET_DEFAULT_CONCRETE_CONCEPT_FQ_NAME);\n            try {\n              result = (String) method.invoke(null);\n            } catch (IllegalAccessException e) {\n              LOG.error(e);\n            } catch (InvocationTargetException e) {\n              LOG.error(e);\n            }\n          } catch (NoSuchMethodException e) {\n            //it's absolutely ok\n          }\n        }\n        myDefaultConceptNames.put(fqName, result);\n      }\n      return result;\n    }\n  }","id":30233,"modified_method":"public String getDefaultConcreteConceptFqName(String fqName, IScope scope) {\n    synchronized (myDefaultConceptNames) {\n      String result = myDefaultConceptNames.get(fqName);\n      if (result != null || myDefaultConceptNames.containsKey(fqName)) {\n        return result;\n      }\n\n      String behaviorClass = constraintsClassByConceptFqName(fqName);\n      String namespace = NameUtil.namespaceFromConceptFQName(fqName);\n      Language language = scope.getLanguage(namespace);\n      if (language != null) {\n        result = fqName;\n        Class cls = language.getClass(behaviorClass);\n        if (cls != null) {\n          try {\n            Method method = cls.getMethod(BehaviorConstants.GET_DEFAULT_CONCRETE_CONCEPT_FQ_NAME);\n            try {\n              result = (String) method.invoke(null);\n            } catch (IllegalAccessException e) {\n              LOG.error(e);\n            } catch (InvocationTargetException e) {\n              LOG.error(e);\n            }\n          } catch (NoSuchMethodException e) {\n            //it's absolutely ok\n          }\n        }\n        myDefaultConceptNames.put(fqName, result);\n      }\n      return result;\n    }\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Method getCanBeChildMethod(String conceptFqName, IOperationContext context) {\n    if (myCanBeChildMethods.containsKey(conceptFqName)) {\n      return myCanBeChildMethods.get(conceptFqName);\n    }\n\n    IScope scope = context.getScope();\n    AbstractConceptDeclaration topConcept = SModelUtil_new.findConceptDeclaration(conceptFqName, scope);\n\n    if (topConcept == null) {\n      myCanBeChildMethods.put(conceptFqName, null);\n      return null;\n    }\n\n    List<AbstractConceptDeclaration> conceptAndSuperConcepts = SModelUtil_new.getConceptAndSuperConcepts(topConcept);\n\n    for (AbstractConceptDeclaration concept : conceptAndSuperConcepts) {\n      String fqName = NameUtil.nodeFQName(concept);\n      String namespace = NameUtil.namespaceFromConcept(concept);\n      Language language = scope.getLanguage(namespace);\n      if (language == null) {\n        continue;\n      }\n\n      String behaviorClassName = constraintsClassByConceptFqName(fqName);\n      Class behaviorClass = language.getClass(behaviorClassName);\n\n      if (behaviorClass == null) {\n        continue;\n      }\n\n      try {\n        Method method = behaviorClass.getMethod(BehaviorConstants.CAN_BE_A_CHILD_METHOD_NAME, IOperationContext.class, CanBeAChildContext.class);\n        myCanBeChildMethods.put(conceptFqName, method);\n        return method;\n      } catch (NoSuchMethodException e) {\n        //it's ok\n      }\n    }\n\n    myCanBeChildMethods.put(conceptFqName, null);\n    return null;\n  }","id":30234,"modified_method":"private Method getCanBeChildMethod(String conceptFqName, IOperationContext context) {\n    synchronized (myCanBeChildMethods) {\n      if (myCanBeChildMethods.containsKey(conceptFqName)) {\n        return myCanBeChildMethods.get(conceptFqName);\n      }\n\n      IScope scope = context.getScope();\n      AbstractConceptDeclaration topConcept = SModelUtil_new.findConceptDeclaration(conceptFqName, scope);\n\n      if (topConcept != null) {\n        List<AbstractConceptDeclaration> conceptAndSuperConcepts = SModelUtil_new.getConceptAndSuperConcepts(topConcept);\n  \n        for (AbstractConceptDeclaration concept : conceptAndSuperConcepts) {\n          String fqName = NameUtil.nodeFQName(concept);\n          Language language = scope.getLanguage(NameUtil.namespaceFromConcept(concept));\n          if (language == null) {\n            continue;\n          }\n\n          Class behaviorClass = language.getClass(constraintsClassByConceptFqName(fqName));\n          if (behaviorClass == null) {\n            continue;\n          }\n\n          try {\n            Method method = behaviorClass.getMethod(BehaviorConstants.CAN_BE_A_CHILD_METHOD_NAME, IOperationContext.class, CanBeAChildContext.class);\n            myCanBeChildMethods.put(conceptFqName, method);\n            return method;\n          } catch (NoSuchMethodException e) {\n            //it's ok\n          }\n        }\n      }\n\n      myCanBeChildMethods.put(conceptFqName, null);\n      return null;\n    }\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Method getCanBeParentMethod(SNode parentNode, IOperationContext context) {\n    IScope scope = context.getScope();\n    String fqName = parentNode.getConceptFqName();\n    String constraintsClass = constraintsClassByConceptFqName(fqName);\n    String namespace = NameUtil.namespaceFromConceptFQName(fqName);\n    Language language = scope.getLanguage(namespace);\n\n    if (language != null) {\n      Class cls = language.getClass(constraintsClass);\n      if (cls != null) {\n        try {\n          Method m;\n          if (myCanBeParentMethods.containsKey(fqName)) {\n            m = myCanBeParentMethods.get(fqName);\n          } else {\n            m = cls.getMethod(BehaviorConstants.CAN_BE_A_PARENT_METHOD_NAME, IOperationContext.class, CanBeAParentContext.class);\n            myCanBeParentMethods.put(fqName, m);\n          }\n\n          return m;\n        } catch (NoSuchMethodException e) {\n          myCanBeParentMethods.put(fqName, null);\n        }\n      }\n    }\n\n    return null;\n  }","id":30235,"modified_method":"private Method getCanBeParentMethod(SNode parentNode, IOperationContext context) {\n    final String fqName = parentNode.getConceptFqName();\n    synchronized (myCanBeParentMethods) {\n      Method result = myCanBeParentMethods.get(fqName);\n      if (result != null || myCanBeParentMethods.containsKey(fqName)) {\n        return result;\n      }\n\n      Language language = context.getScope().getLanguage(NameUtil.namespaceFromConceptFQName(fqName));\n      if (language != null) {\n        Class behaviorClass = language.getClass(constraintsClassByConceptFqName(fqName));\n        if (behaviorClass != null) {\n          try {\n            result = behaviorClass.getMethod(BehaviorConstants.CAN_BE_A_PARENT_METHOD_NAME, IOperationContext.class, CanBeAParentContext.class);\n          } catch (NoSuchMethodException e) {\n            /* ignore */\n          }\n        }\n      }\n\n      myCanBeParentMethods.put(fqName, result);\n      return result;\n    }\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private Method getCanBeRootMethod(String conceptFqName, IOperationContext context) {\n    if (myCanBeRootMethods.containsKey(conceptFqName)) {\n      return myCanBeRootMethods.get(conceptFqName);\n    }\n\n    IScope scope = context.getScope();\n    AbstractConceptDeclaration concept = SModelUtil_new.findConceptDeclaration(conceptFqName, scope);\n\n    if (concept == null) {\n      myCanBeRootMethods.put(conceptFqName, null);\n      return null;\n    }\n\n    String fqName = NameUtil.nodeFQName(concept);\n    String namespace = NameUtil.namespaceFromConcept(concept);\n    Language language = scope.getLanguage(namespace);\n    if (language == null) {\n      myCanBeRootMethods.put(conceptFqName, null);\n      return null;\n    }\n\n    String behaviorClassName = constraintsClassByConceptFqName(fqName);\n    Class behaviorClass = language.getClass(behaviorClassName);\n\n    if (behaviorClass == null) {\n      myCanBeRootMethods.put(conceptFqName, null);\n      return null;\n    }\n\n    try {\n      Method method = behaviorClass.getMethod(BehaviorConstants.CAN_BE_A_ROOT_METHOD_NAME, IOperationContext.class, CanBeARootContext.class);\n      myCanBeRootMethods.put(conceptFqName, method);\n      return method;\n    } catch (NoSuchMethodException e) {\n      //it's ok\n    }\n\n    myCanBeChildMethods.put(conceptFqName, null);\n    return null;\n  }","id":30236,"modified_method":"@Nullable\n  private Method getCanBeRootMethod(String conceptFqName, IOperationContext context) {\n    synchronized (myCanBeRootMethods) {\n      if (myCanBeRootMethods.containsKey(conceptFqName)) {\n        return myCanBeRootMethods.get(conceptFqName);\n      }\n\n      IScope scope = context.getScope();\n      SNode concept = SModelUtil.findConceptDeclaration(conceptFqName, scope);\n\n      if (concept != null) {\n        String fqName = NameUtil.nodeFQName(concept);\n        Language language = scope.getLanguage(NameUtil.namespaceFromConceptFQName(fqName));\n        if (language != null) {\n\n          Class behaviorClass = language.getClass(constraintsClassByConceptFqName(fqName));\n          if (behaviorClass != null) {\n            try {\n              Method method = behaviorClass.getMethod(BehaviorConstants.CAN_BE_A_ROOT_METHOD_NAME, IOperationContext.class, CanBeARootContext.class);\n              myCanBeRootMethods.put(conceptFqName, method);\n              return method;\n            } catch (NoSuchMethodException e) {\n              //it's ok\n            }\n          }\n        }\n      }\n\n      myCanBeRootMethods.put(conceptFqName, null);\n      return null;\n    }\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void reloadAll() {\n    myCanBeChildMethods.clear();\n    myCanBeParentMethods.clear();\n    myCanBeRootMethods.clear();\n    synchronized (myDefaultConceptNames) {\n      myDefaultConceptNames.clear();\n    }\n\n    myNodePropertyGettersMap.clear();\n    myNodePropertySettersMap.clear();\n    myNodeReferentSearchScopeProvidersMap.clear();\n    myNodeReferentSetEventHandlersMap.clear();\n    myNodeDefaultSearchScopeProvidersMap.clear();\n\n    synchronized (myConstraintClassNames) {\n      myConstraintClassNames.clear();\n    }\n\n    synchronized (myAddedLanguageNamespaces) {\n      for (List<IModelConstraints> loadedConstraints : myAddedLanguageNamespaces.values()) {\n        for (IModelConstraints constraints : loadedConstraints) {\n          constraints.unRegisterSelf(this);\n        }\n      }\n      myAddedLanguageNamespaces.clear();\n    }\n  }","id":30237,"modified_method":"private void reloadAll() {\n    synchronized (myCanBeChildMethods) {\n      myCanBeChildMethods.clear();\n    }\n    synchronized (myCanBeParentMethods) {\n      myCanBeParentMethods.clear();\n    }\n    synchronized (myCanBeRootMethods) {\n      myCanBeRootMethods.clear();\n    }\n    synchronized (myDefaultConceptNames) {\n      myDefaultConceptNames.clear();\n    }\n\n    myNodePropertyGettersMap.clear();\n    myNodePropertySettersMap.clear();\n    myNodeReferentSearchScopeProvidersMap.clear();\n    myNodeReferentSetEventHandlersMap.clear();\n    myNodeDefaultSearchScopeProvidersMap.clear();\n\n    synchronized (myConstraintClassNames) {\n      myConstraintClassNames.clear();\n    }\n\n    synchronized (myAddedLanguageNamespaces) {\n      for (List<IModelConstraints> loadedConstraints : myAddedLanguageNamespaces.values()) {\n        for (IModelConstraints constraints : loadedConstraints) {\n          constraints.unRegisterSelf(this);\n        }\n      }\n      myAddedLanguageNamespaces.clear();\n    }\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String conceptFQNameFromNamespaceAndShortName(String namespace, String shortName) {\n    return namespace + \".\" + STRUCTURE + \".\" + shortName;\n  }","id":30238,"modified_method":"public static String conceptFQNameFromNamespaceAndShortName(String namespace, String shortName) {\n    return namespace + DOT_STRUCTURE_DOT + shortName;\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String namespaceFromConceptFQName(String fqName) {\n    if (fqName == null) return null;\n    int offset = fqName.lastIndexOf(\".\" + STRUCTURE + \".\");\n    if (offset > 0) {\n      return fqName.substring(0, offset);\n    }\n    return \"\";\n  }","id":30239,"modified_method":"public static String namespaceFromConceptFQName(String fqName) {\n    if (fqName == null) return null;\n    int offset = fqName.lastIndexOf(DOT_STRUCTURE_DOT);\n    if (offset > 0) {\n      return fqName.substring(0, offset);\n    }\n    return \"\";\n  }","commit_id":"9c3e5bcad0ec2d64bc79c36942b7c2cd9111f814","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SLanguage getLanguage() {\n    ConceptDescriptor cd = getConceptDescriptor();\n    if (cd == null) return new SLanguageAdapterByName(NameUtil.namespaceFromConceptFQName(myFqName));\n\n    return MetaAdapterFactory.getLanguage(cd.getId().getLanguageId(), NameUtil.namespaceFromConceptFQName(myFqName));\n  }","id":30240,"modified_method":"@Override\n  public SLanguage getLanguage() {\n    ConceptDescriptor cd = getConceptDescriptor();\n    if (cd == null) return MetaAdapterFactoryByName.getLanguage(NameUtil.namespaceFromConceptFQName(myFqName));\n\n    return MetaAdapterFactory.getLanguage(cd.getId().getLanguageId(), NameUtil.namespaceFromConceptFQName(myFqName));\n  }","commit_id":"9d0cdb9e312c75b54df1b44fc54e2ce47da5cb0a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SLanguage getLanguage() {\n    return new SLanguageAdapterByName(NameUtil.namespaceFromConceptFQName(myFqName));\n  }","id":30241,"modified_method":"@Override\n  public SLanguage getLanguage() {\n    return MetaAdapterFactoryByName.getLanguage(NameUtil.namespaceFromConceptFQName(myFqName));\n  }","commit_id":"9d0cdb9e312c75b54df1b44fc54e2ce47da5cb0a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void importEvent(PortletDataContext context, CalEvent event)\n\t\tthrows Exception {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean mergeData = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.MERGE_DATA,\n\t\t\t_enableExport.getDefaultState());\n\n\t\tlong plid = context.getPlid();\n\n\t\tDate startDate = event.getStartDate();\n\n\t\tint startDateMonth = 0;\n\t\tint startDateDay = 0;\n\t\tint startDateYear = 0;\n\t\tint startDateHour = 0;\n\t\tint startDateMinute = 0;\n\n\t\tif (startDate != null) {\n\t\t\tCalendar startCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tstartCal.setTime(startDate);\n\n\t\t\tstartDateMonth = startCal.get(Calendar.MONTH);\n\t\t\tstartDateDay = startCal.get(Calendar.DATE);\n\t\t\tstartDateYear = startCal.get(Calendar.YEAR);\n\t\t\tstartDateHour = startCal.get(Calendar.HOUR);\n\t\t\tstartDateMinute = startCal.get(Calendar.MINUTE);\n\t\t}\n\n\t\tDate endDate = event.getEndDate();\n\n\t\tint endDateMonth = 0;\n\t\tint endDateDay = 0;\n\t\tint endDateYear = 0;\n\n\t\tif (endDate != null) {\n\t\t\tCalendar endCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tendCal.setTime(endDate);\n\n\t\t\tendDateMonth = endCal.get(Calendar.MONTH);\n\t\t\tendDateDay = endCal.get(Calendar.DATE);\n\t\t\tendDateYear = endCal.get(Calendar.YEAR);\n\t\t}\n\n\t\tboolean addCommunityPermissions = true;\n\t\tboolean addGuestPermissions = true;\n\n\t\tif (mergeData) {\n\t\t\tCalEvent existingEvent = CalEventUtil.fetchByUUID_G(\n\t\t\t\tevent.getUuid(), context.getGroupId());\n\n\t\t\tif (existingEvent == null) {\n\t\t\t\tCalEventLocalServiceUtil.addEvent(\n\t\t\t\t\tevent.getUuid(), event.getUserId(), plid, event.getTitle(),\n\t\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\t\tevent.getSecondReminder(), addCommunityPermissions,\n\t\t\t\t\taddGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevent.setGroupId(existingEvent.getGroupId());\n\t\t\t\tevent.setPrimaryKey(existingEvent.getPrimaryKey());\n\n\t\t\t\tCalEventUtil.update(event, true);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tCalEventLocalServiceUtil.addEvent(\n\t\t\t\tevent.getUserId(), plid, event.getTitle(),\n\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\tevent.getSecondReminder(), addCommunityPermissions,\n\t\t\t\taddGuestPermissions);\n\t\t}\n\t}","id":30242,"modified_method":"protected void importEvent(\n\t\t\tPortletDataContext context, boolean mergeData, CalEvent event)\n\t\tthrows Exception {\n\n\t\tlong plid = context.getPlid();\n\n\t\tDate startDate = event.getStartDate();\n\n\t\tint startDateMonth = 0;\n\t\tint startDateDay = 0;\n\t\tint startDateYear = 0;\n\t\tint startDateHour = 0;\n\t\tint startDateMinute = 0;\n\n\t\tif (startDate != null) {\n\t\t\tCalendar startCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tstartCal.setTime(startDate);\n\n\t\t\tstartDateMonth = startCal.get(Calendar.MONTH);\n\t\t\tstartDateDay = startCal.get(Calendar.DATE);\n\t\t\tstartDateYear = startCal.get(Calendar.YEAR);\n\t\t\tstartDateHour = startCal.get(Calendar.HOUR);\n\t\t\tstartDateMinute = startCal.get(Calendar.MINUTE);\n\t\t}\n\n\t\tDate endDate = event.getEndDate();\n\n\t\tint endDateMonth = 0;\n\t\tint endDateDay = 0;\n\t\tint endDateYear = 0;\n\n\t\tif (endDate != null) {\n\t\t\tCalendar endCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tendCal.setTime(endDate);\n\n\t\t\tendDateMonth = endCal.get(Calendar.MONTH);\n\t\t\tendDateDay = endCal.get(Calendar.DATE);\n\t\t\tendDateYear = endCal.get(Calendar.YEAR);\n\t\t}\n\n\t\tboolean addCommunityPermissions = true;\n\t\tboolean addGuestPermissions = true;\n\n\t\tCalEvent existingEvent = null;\n\n\t\tif (mergeData) {\n\t\t\texistingEvent = CalEventUtil.fetchByUUID_G(\n\t\t\t\tevent.getUuid(), context.getGroupId());\n\n\t\t\tif (existingEvent == null) {\n\t\t\t\tCalEventLocalServiceUtil.addEvent(\n\t\t\t\t\tevent.getUuid(), event.getUserId(), plid, event.getTitle(),\n\t\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\t\tevent.getSecondReminder(), addCommunityPermissions,\n\t\t\t\t\taddGuestPermissions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCalEventLocalServiceUtil.updateEvent(\n\t\t\t\t\tevent.getUserId(), existingEvent.getEventId(),\n\t\t\t\t\tevent.getTitle(), event.getDescription(), startDateMonth,\n\t\t\t\t\tstartDateDay, startDateYear, startDateHour, startDateMinute,\n\t\t\t\t\tendDateMonth, endDateDay, endDateYear,\n\t\t\t\t\tevent.getDurationHour(), event.getDurationMinute(),\n\t\t\t\t\tevent.getAllDay(), event.getTimeZoneSensitive(),\n\t\t\t\t\tevent.getType(), event.getRepeating(),\n\t\t\t\t\tevent.getRecurrenceObj(), event.getRemindBy(),\n\t\t\t\t\tevent.getFirstReminder(), event.getSecondReminder());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tCalEventLocalServiceUtil.addEvent(\n\t\t\t\tevent.getUserId(), plid, event.getTitle(),\n\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\tevent.getSecondReminder(), addCommunityPermissions,\n\t\t\t\taddGuestPermissions);\n\t\t}\n\t}","commit_id":"abc99b18b81c4c6303923cf201bcae6c2da1443c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_CALENDAR_DATA,\n\t\t\t_enableExport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"calendar-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Events\n\n\t\t\tList events = CalEventUtil.findByGroupId(context.getGroupId());\n\n\t\t\tIterator itr = events.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCalEvent event = (CalEvent) itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tCalEvent.class, event.getPrimaryKeyObj())) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(events);\n\n\t\t\tElement el = root.addElement(\"calendar-events\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":30243,"modified_method":"public String exportData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean exportData = MapUtil.getBoolean(\n\t\t\tparameterMap, _EXPORT_CALENDAR_DATA);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (exportData) {\n\t\t\t\t_log.debug(\"Exporting data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Exporting data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!exportData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = DocumentHelper.createDocument();\n\n\t\t\tElement root = doc.addElement(\"calendar-data\");\n\n\t\t\troot.addAttribute(\"group-id\", String.valueOf(context.getGroupId()));\n\n\t\t\t// Events\n\n\t\t\tList events = CalEventUtil.findByGroupId(context.getGroupId());\n\n\t\t\tIterator itr = events.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCalEvent event = (CalEvent) itr.next();\n\n\t\t\t\tif (context.addPrimaryKey(\n\t\t\t\t\t\tCalEvent.class, event.getPrimaryKeyObj())) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString xml = xStream.toXML(events);\n\n\t\t\tElement el = root.addElement(\"calendar-events\");\n\n\t\t\tDocument tempDoc = reader.read(new StringReader(xml));\n\n\t\t\tel.content().add(tempDoc.getRootElement().createCopy());\n\n\t\t\treturn XMLFormatter.toString(doc);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"abc99b18b81c4c6303923cf201bcae6c2da1443c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_CALENDAR_DATA,\n\t\t\t_enableImport.getDefaultState());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Events\n\n\t\t\tElement el = root.element(\"calendar-events\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList events = (List) xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = events.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCalEvent event = (CalEvent) itr.next();\n\n\t\t\t\timportEvent(context, event);\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","id":30244,"modified_method":"public PortletPreferences importData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences prefs, String data)\n\t\tthrows PortletDataException {\n\n\t\tMap parameterMap = context.getParameterMap();\n\n\t\tboolean importData = MapUtil.getBoolean(\n\t\t\tparameterMap, _IMPORT_CALENDAR_DATA);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (importData) {\n\t\t\t\t_log.debug(\"Importing data is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Importing data is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tif (!importData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean mergeData = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.MERGE_DATA);\n\n\t\ttry {\n\t\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\t\tXStream xStream = new XStream();\n\n\t\t\tDocument doc = reader.read(new StringReader(data));\n\n\t\t\tElement root = doc.getRootElement();\n\n\t\t\t// Events\n\n\t\t\tElement el = root.element(\"calendar-events\").element(\"list\");\n\n\t\t\tDocument tempDoc = DocumentHelper.createDocument();\n\n\t\t\ttempDoc.content().add(el.createCopy());\n\n\t\t\tList events = (List) xStream.fromXML(\n\t\t\t\tXMLFormatter.toString(tempDoc));\n\n\t\t\tIterator itr = events.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCalEvent event = (CalEvent) itr.next();\n\n\t\t\t\timportEvent(context, mergeData, event);\n\t\t\t}\n\n\t\t\t// No special modification to the incoming portlet preferences\n\t\t\t// needed\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PortletDataException(e);\n\t\t}\n\t}","commit_id":"abc99b18b81c4c6303923cf201bcae6c2da1443c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private InjectionMetadata findPersistenceMetadata(final Class<?> clazz) {\n\t\t// Quick check on the concurrent map first, with minimal locking.\n\t\tInjectionMetadata metadata = this.injectionMetadataCache.get(clazz);\n\t\tif (metadata == null) {\n\t\t\tsynchronized (this.injectionMetadataCache) {\n\t\t\t\tmetadata = this.injectionMetadataCache.get(clazz);\n\t\t\t\tif (metadata == null) {\n\t\t\t\t\tLinkedList<InjectionMetadata.InjectedElement> elements = new LinkedList<InjectionMetadata.InjectedElement>();\n\t\t\t\t\tClass<?> targetClass = clazz;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tLinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<InjectionMetadata.InjectedElement>();\n\t\t\t\t\t\tfor (Field field : targetClass.getDeclaredFields()) {\n\t\t\t\t\t\t\tPersistenceContext pc = field.getAnnotation(PersistenceContext.class);\n\t\t\t\t\t\t\tPersistenceUnit pu = field.getAnnotation(PersistenceUnit.class);\n\t\t\t\t\t\t\tif (pc != null || pu != null) {\n\t\t\t\t\t\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"Persistence annotations are not supported on static fields\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrElements.add(new PersistenceElement(field, null));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Method method : targetClass.getDeclaredMethods()) {\n\t\t\t\t\t\t\tPersistenceContext pc = method.getAnnotation(PersistenceContext.class);\n\t\t\t\t\t\t\tPersistenceUnit pu = method.getAnnotation(PersistenceUnit.class);\n\t\t\t\t\t\t\tif (pc != null || pu != null &&\n\t\t\t\t\t\t\t\t\tmethod.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {\n\t\t\t\t\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"Persistence annotations are not supported on static methods\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (method.getParameterTypes().length != 1) {\n\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"Persistence annotation requires a single-arg method: \" + method);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tPropertyDescriptor pd = BeanUtils.findPropertyForMethod(method);\n\t\t\t\t\t\t\t\tcurrElements.add(new PersistenceElement(method, pd));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telements.addAll(0, currElements);\n\t\t\t\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\twhile (targetClass != null && targetClass != Object.class);\n\n\t\t\t\t\tmetadata = new InjectionMetadata(clazz, elements);\n\t\t\t\t\tthis.injectionMetadataCache.put(clazz, metadata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn metadata;\n\t}","id":30245,"modified_method":"private InjectionMetadata findPersistenceMetadata(final Class<?> clazz) {\n\t\t// Quick check on the concurrent map first, with minimal locking.\n\t\tInjectionMetadata metadata = this.injectionMetadataCache.get(clazz);\n\t\tif (metadata == null) {\n\t\t\tsynchronized (this.injectionMetadataCache) {\n\t\t\t\tmetadata = this.injectionMetadataCache.get(clazz);\n\t\t\t\tif (metadata == null) {\n\t\t\t\t\tLinkedList<InjectionMetadata.InjectedElement> elements = new LinkedList<InjectionMetadata.InjectedElement>();\n\t\t\t\t\tClass<?> targetClass = clazz;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tLinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<InjectionMetadata.InjectedElement>();\n\t\t\t\t\t\tfor (Field field : targetClass.getDeclaredFields()) {\n\t\t\t\t\t\t\tPersistenceContext pc = field.getAnnotation(PersistenceContext.class);\n\t\t\t\t\t\t\tPersistenceUnit pu = field.getAnnotation(PersistenceUnit.class);\n\t\t\t\t\t\t\tif (pc != null || pu != null) {\n\t\t\t\t\t\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"Persistence annotations are not supported on static fields\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrElements.add(new PersistenceElement(field, null));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Method method : targetClass.getDeclaredMethods()) {\n\t\t\t\t\t\t\tPersistenceContext pc = method.getAnnotation(PersistenceContext.class);\n\t\t\t\t\t\t\tPersistenceUnit pu = method.getAnnotation(PersistenceUnit.class);\n\t\t\t\t\t\t\tif ((pc != null || pu != null) &&\n\t\t\t\t\t\t\t\t\tmethod.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {\n\t\t\t\t\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"Persistence annotations are not supported on static methods\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (method.getParameterTypes().length != 1) {\n\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"Persistence annotation requires a single-arg method: \" + method);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tPropertyDescriptor pd = BeanUtils.findPropertyForMethod(method);\n\t\t\t\t\t\t\t\tcurrElements.add(new PersistenceElement(method, pd));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telements.addAll(0, currElements);\n\t\t\t\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\twhile (targetClass != null && targetClass != Object.class);\n\n\t\t\t\t\tmetadata = new InjectionMetadata(clazz, elements);\n\t\t\t\t\tthis.injectionMetadataCache.put(clazz, metadata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn metadata;\n\t}","commit_id":"49e61d2680c66e6d59aaa2d483300d4ac76cbc78","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testPublicExtendedPersistenceContextSetter() throws Exception {\n\t\tObject mockEm = (EntityManager) MockControl.createControl(EntityManager.class).getMock();\n\t\tmockEmf.createEntityManager();\n\t\temfMc.setReturnValue(mockEm, 1);\n\t\temfMc.replay();\n\n\t\tGenericApplicationContext gac = new GenericApplicationContext();\n\t\tgac.getDefaultListableBeanFactory().registerSingleton(\"entityManagerFactory\", mockEmf);\n\t\tgac.registerBeanDefinition(\"annotationProcessor\",\n\t\t\t\tnew RootBeanDefinition(PersistenceAnnotationBeanPostProcessor.class));\n\t\tgac.registerBeanDefinition(DefaultPublicPersistenceContextSetter.class.getName(),\n\t\t\t\tnew RootBeanDefinition(DefaultPublicPersistenceContextSetter.class));\n\t\tgac.refresh();\n\n\t\tDefaultPublicPersistenceContextSetter bean = (DefaultPublicPersistenceContextSetter) gac.getBean(\n\t\t\t\tDefaultPublicPersistenceContextSetter.class.getName());\n\t\tassertNotNull(bean.em);\n\t\temfMc.verify();\n\t}","id":30246,"modified_method":"public void testPublicExtendedPersistenceContextSetter() throws Exception {\n\t\tEntityManager mockEm = MockControl.createControl(EntityManager.class).getMock();\n\t\tmockEmf.createEntityManager();\n\t\temfMc.setReturnValue(mockEm, 1);\n\t\temfMc.replay();\n\n\t\tGenericApplicationContext gac = new GenericApplicationContext();\n\t\tgac.getDefaultListableBeanFactory().registerSingleton(\"entityManagerFactory\", mockEmf);\n\t\tgac.registerBeanDefinition(\"annotationProcessor\",\n\t\t\t\tnew RootBeanDefinition(PersistenceAnnotationBeanPostProcessor.class));\n\t\tgac.registerBeanDefinition(DefaultPublicPersistenceContextSetter.class.getName(),\n\t\t\t\tnew RootBeanDefinition(DefaultPublicPersistenceContextSetter.class));\n\t\tgac.refresh();\n\n\t\tDefaultPublicPersistenceContextSetter bean = (DefaultPublicPersistenceContextSetter) gac.getBean(\n\t\t\t\tDefaultPublicPersistenceContextSetter.class.getName());\n\t\tassertNotNull(bean.em);\n\t\temfMc.verify();\n\t}","commit_id":"49e61d2680c66e6d59aaa2d483300d4ac76cbc78","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void setUp() throws Exception {\n\t\tloaderCtrl = MockControl.createControl(InstrumentableClassLoader.class);\n\t\tloader = (InstrumentableClassLoader) loaderCtrl.getMock();\n\t\tloaderCtrl.replay();\n\n\t\tltw = new GlassFishLoadTimeWeaver() {\n\t\t\t@Override\n\t\t\tprotected InstrumentableClassLoader determineClassLoader(ClassLoader cl) {\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t};\n\t}","id":30247,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tloaderCtrl = MockControl.createControl(InstrumentableClassLoader.class);\n\t\tloader = loaderCtrl.getMock();\n\t\tloaderCtrl.replay();\n\n\t\tltw = new GlassFishLoadTimeWeaver() {\n\t\t\t@Override\n\t\t\tprotected InstrumentableClassLoader determineClassLoader(ClassLoader cl) {\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t};\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testAddTransformer() {\n\t\tClassFileTransformer transformer = (ClassFileTransformer) MockControl.createNiceControl(\n\t\t\t\tClassFileTransformer.class).getMock();\n\t\tloaderCtrl.reset();\n\t\tloader.addTransformer(new ClassTransformerAdapter(transformer));\n\t\tloaderCtrl.setMatcher(new ArgumentsMatcher() {\n\n\t\t\tpublic boolean matches(Object[] arg0, Object[] arg1) {\n\t\t\t\tfor (int i = 0; i < arg0.length; i++) {\n\t\t\t\t\tif (arg0 != null && arg0.getClass() != arg1.getClass())\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpublic String toString(Object[] arg0) {\n\t\t\t\treturn Arrays.toString(arg0);\n\t\t\t}\n\n\t\t});\n\n\t\tloaderCtrl.replay();\n\n\t\tltw.addTransformer(transformer);\n\t}","id":30248,"modified_method":"@Test\n\tpublic void testAddTransformer() {\n\t\tClassFileTransformer transformer = MockControl.createNiceControl(\n\t\t\t\tClassFileTransformer.class).getMock();\n\t\tloaderCtrl.reset();\n\t\tloader.addTransformer(new ClassTransformerAdapter(transformer));\n\t\tloaderCtrl.setMatcher(new ArgumentsMatcher() {\n\n\t\t\tpublic boolean matches(Object[] arg0, Object[] arg1) {\n\t\t\t\tfor (int i = 0; i < arg0.length; i++) {\n\t\t\t\t\tif (arg0 != null && arg0.getClass() != arg1.getClass())\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpublic String toString(Object[] arg0) {\n\t\t\t\treturn Arrays.toString(arg0);\n\t\t\t}\n\n\t\t});\n\n\t\tloaderCtrl.replay();\n\n\t\tltw.addTransformer(transformer);\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void tearDown() throws Exception {\n\t\tloaderCtrl.verify();\n\t\tltw = null;\n\t}","id":30249,"modified_method":"@After\n\tpublic void tearDown() throws Exception {\n\t\tloaderCtrl.verify();\n\t\tltw = null;\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testCtorWithNullClassFileTransformer() throws Exception {\n\t\tnew AssertThrows(IllegalArgumentException.class) {\n\t\t\tpublic void test() throws Exception {\n\t\t\t\tnew OC4JClassPreprocessorAdapter(null);\n\t\t\t}\n\t\t}.runTest();\n\t}","id":30250,"modified_method":"@Test(expected=IllegalArgumentException.class)\n\tpublic void testCtorWithNullClassFileTransformer() {\n\t\tnew OC4JClassPreprocessorAdapter(null);\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testClassNameIsUnMangledPriorToTransformation() throws Exception {\n\t\tfinal byte[] classBytes = \"CAFEBABE\".getBytes();\n\t\tfinal ClassLoader classLoader = getClass().getClassLoader();\n\n\t\tMockControl mockTransformer = MockControl.createControl(ClassFileTransformer.class);\n\t\tClassFileTransformer transformer = (ClassFileTransformer) mockTransformer.getMock();\n\n\t\ttransformer.transform(classLoader, \"com/foo/Bar\", null, null, classBytes);\n\t\tmockTransformer.setMatcher(new AbstractMatcher() {\n\t\t\tpublic boolean matches(Object[] expected, Object[] actual) {\n\t\t\t\treturn expected[1].equals(actual[1]);\n\t\t\t}\n\t\t});\n\t\tmockTransformer.setReturnValue(classBytes);\n\n\t\tmockTransformer.replay();\n\n\t\tOC4JClassPreprocessorAdapter processor = new OC4JClassPreprocessorAdapter(transformer);\n\t\tbyte[] bytes = processor.processClass(\"com.foo.Bar\", classBytes, 0, 0, null, classLoader);\n\t\tassertNotNull(bytes);\n\n\t\tmockTransformer.verify();\n\t}","id":30251,"modified_method":"@Test\n\tpublic void testClassNameIsUnMangledPriorToTransformation() throws IllegalClassFormatException {\n\t\tfinal byte[] classBytes = \"CAFEBABE\".getBytes();\n\t\tfinal ClassLoader classLoader = getClass().getClassLoader();\n\n\t\tClassFileTransformer transformer = createMock(ClassFileTransformer.class);\n\n\t\texpect(\n\t\t\t\ttransformer.transform(eq(classLoader), eq(\"com/foo/Bar\"), (Class<?>)isNull(), (ProtectionDomain)isNull(), isA(byte[].class))\n\t\t\t).andReturn(classBytes);\n\t\treplay(transformer);\n\n\t\tOC4JClassPreprocessorAdapter processor = new OC4JClassPreprocessorAdapter(transformer);\n\t\tbyte[] bytes = processor.processClass(\"com.foo.Bar\", classBytes, 0, 0, null, classLoader);\n\t\tassertNotNull(bytes);\n\n\t\tverify(transformer);\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testCtorWithNullClassLoader() throws Exception {\n\t\tnew AssertThrows(IllegalArgumentException.class) {\n\t\t\tpublic void test() throws Exception {\n\t\t\t\tnew OC4JLoadTimeWeaver(null);\n\t\t\t}\n\t\t}.runTest();\n\t}","id":30252,"modified_method":"@Test(expected=IllegalArgumentException.class)\n\tpublic void testCtorWithNullClassLoader() {\n\t\tnew OC4JLoadTimeWeaver(null);\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testAddTransformerWithNullTransformer() throws Exception {\n\t\tnew AssertThrows(IllegalArgumentException.class) {\n\t\t\tpublic void test() throws Exception {\n\t\t\t\tnew OC4JLoadTimeWeaver().addTransformer(null);\n\t\t\t}\n\t\t}.runTest();\n\t}","id":30253,"modified_method":"@Test(expected=IllegalArgumentException.class)\n\tpublic void testAddTransformerWithNullTransformer() {\n\t\t\t\tnew OC4JLoadTimeWeaver().addTransformer(null);\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testCtorWithNullClassLoader() throws Exception {\n\t\tnew AssertThrows(IllegalArgumentException.class) {\n\t\t\tpublic void test() throws Exception {\n\t\t\t\tnew ReflectiveLoadTimeWeaver(null);\n\t\t\t}\n\t\t}.runTest();\n\t}","id":30254,"modified_method":"@Test(expected=IllegalArgumentException.class)\n\tpublic void testCtorWithNullClassLoader() {\n\t\tnew ReflectiveLoadTimeWeaver(null);\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testAddTransformerWithNullTransformer() throws Exception {\n\t\tnew AssertThrows(IllegalArgumentException.class) {\n\t\t\tpublic void test() throws Exception {\n\t\t\t\tnew ReflectiveLoadTimeWeaver(new JustAddTransformerClassLoader()).addTransformer(null);\n\t\t\t}\n\t\t}.runTest();\n\t}","id":30255,"modified_method":"@Test(expected=IllegalArgumentException.class)\n\tpublic void testAddTransformerWithNullTransformer() {\n\t\tnew ReflectiveLoadTimeWeaver(new JustAddTransformerClassLoader()).addTransformer(null);\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testCtorWithClassLoaderThatDoesNotExposeAnAddTransformerMethod() throws Exception {\n\t\tnew AssertThrows(IllegalStateException.class) {\n\t\t\tpublic void test() throws Exception {\n\t\t\t\tnew ReflectiveLoadTimeWeaver(getClass().getClassLoader());\n\t\t\t}\n\t\t}.runTest();\n\t}","id":30256,"modified_method":"@Test(expected=IllegalStateException.class)\n\tpublic void testCtorWithClassLoaderThatDoesNotExposeAnAddTransformerMethod() {\n\t\tnew ReflectiveLoadTimeWeaver(getClass().getClassLoader());\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private int countElements(Enumeration e) {\n\t\tint elts = 0;\n\t\twhile (e.hasMoreElements()) {\n\t\t\te.nextElement();\n\t\t\t++elts;\n\t\t}\n\t\treturn elts;\n\t}","id":30257,"modified_method":"private int countElements(Enumeration<?> e) {\n\t\tint elts = 0;\n\t\twhile (e.hasMoreElements()) {\n\t\t\te.nextElement();\n\t\t\t++elts;\n\t\t}\n\t\treturn elts;\n\t}","commit_id":"9ed180a80d24c04356dcab392a488f18b26987f5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLatestTxId(), info.getSequenceId() ) );\n            if ( info.getLatestTxId() >= highestTxId )\n            {\n                highestTxId = info.getLatestTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master;\n    }","id":30258,"modified_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                highestTxId = info.getLastCommittedTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master;\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        return getMyMachineId();\n    }","id":30259,"modified_method":"public Machine getMasterMachine()\n    {\n        return new Machine( getMyMachineId(), 0, 1, null );\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        return this.masterMachineId;\n    }","id":30260,"modified_method":"public Machine getMasterMachine()\n    {\n        return new Machine( masterMachineId, 0, 1, null );\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void tryToEnsureIAmNotABrokenMachine()\n    {\n//        ClusterManager cluster = null;\n//        MasterClient client = null;\n        try\n        {\n            if ( broker.thisIsMaster() )\n            {\n                return;\n            }\n            \n            // Get the master id I have for my latest commit\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long lastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            int masterForMyLastCommittedTx = nioneoDataSource.getMasterForCommittedTx( lastCommittedTx );\n            \n            // Ask zoo keeper who is master a.t.m.\n//            cluster = new ClusterManager( getZooKeeperServersFromConfig( config ) );\n//            Machine currentMaster = cluster.getMaster();\n            \n            // Ask the master for the master id for my latest commit\n//            client = new MasterClient( currentMaster.getServer().first(),\n//                    currentMaster.getServer().other() );\n            Master master = broker.getMaster();\n            int masterForMastersLastCommittedTx = master.getMasterIdForCommittedTx( lastCommittedTx );\n            \n            // Compare those two, if equal -> good, start up as usual\n            if ( masterForMastersLastCommittedTx == masterForMyLastCommittedTx )\n            {\n                broker.setLastCommittedTxId( lastCommittedTx );\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                msgLog.logMessage( \"Broken store, my last committed tx,machineId[\" + \n                        lastCommittedTx + \",\" + masterForMyLastCommittedTx + \n                        \"] but master says machine id for that txId is \" + masterForMastersLastCommittedTx );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" ); \n//                }\n                throw new RuntimeException( \"I am broken\" );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n//        finally\n//        {\n//            if ( client != null )\n//            {\n//                client.shutdown();\n//            }\n//            if ( cluster != null )\n//            {\n//                cluster.shutdown();\n//            }\n//        }\n    }","id":30261,"modified_method":"private void tryToEnsureIAmNotABrokenMachine()\n    {\n//        ClusterManager cluster = null;\n//        MasterClient client = null;\n        try\n        {\n            if ( broker.thisIsMaster() )\n            {\n                return;\n            }\n            \n            // Get the master id I have for my latest commit\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long lastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long lastCommonTxId = Math.min( lastCommittedTx, broker.getMasterMachine().getLastCommittedTxId() );\n            int masterForMyLastCommittedTx = nioneoDataSource.getMasterForCommittedTx( lastCommonTxId );\n            \n            // Ask zoo keeper who is master a.t.m.\n//            cluster = new ClusterManager( getZooKeeperServersFromConfig( config ) );\n//            Machine currentMaster = cluster.getMaster();\n            \n            // Ask the master for the master id for my latest commit\n//            client = new MasterClient( currentMaster.getServer().first(),\n//                    currentMaster.getServer().other() );\n            Master master = broker.getMaster();\n            int masterForMastersLastCommittedTx = master.getMasterIdForCommittedTx( lastCommonTxId );\n            \n            // Compare those two, if equal -> good, start up as usual\n            if ( masterForMastersLastCommittedTx == masterForMyLastCommittedTx )\n            {\n                broker.setLastCommittedTxId( lastCommittedTx );\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                msgLog.logMessage( \"Broken store, my last committed tx,machineId[\" + \n                        lastCommittedTx + \",\" + masterForMyLastCommittedTx + \n                        \"] but master says machine id for that txId is \" + masterForMastersLastCommittedTx );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" ); \n//                }\n                throw new RuntimeException( \"I am broken\" );\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            shutdown();\n            throw new RuntimeException( e );\n        }\n//        finally\n//        {\n//            if ( client != null )\n//            {\n//                client.shutdown();\n//            }\n//            if ( cluster != null )\n//            {\n//                cluster.shutdown();\n//            }\n//        }\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getLatestTxId()\n    {\n        return latestTxId;\n    }","id":30262,"modified_method":"public long getLastCommittedTxId()\n    {\n        return lastCommittedTxId;\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"Machine( int machineId, int sequenceId, long lastestTxId, String server )\n    {\n        this.machineId = machineId;\n        this.sequenceId = sequenceId;\n        this.latestTxId = lastestTxId;\n        this.server = server != null ? splitIpAndPort( server ) : null;\n    }","id":30263,"modified_method":"public Machine( int machineId, int sequenceId, long lastCommittedTxId, String server )\n    {\n        this.machineId = machineId;\n        this.sequenceId = sequenceId;\n        this.lastCommittedTxId = lastCommittedTxId;\n        this.server = server != null ? splitIpAndPort( server ) : null;\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"MachineInfo[ID:\" + machineId + \", sequence:\" + sequenceId +\n                \", latest tx id:\" + latestTxId + \", server:\" + server + \"]\";\n    }","id":30264,"modified_method":"@Override\n    public String toString()\n    {\n        return \"MachineInfo[ID:\" + machineId + \", sequence:\" + sequenceId +\n                \", last committed tx id:\" + lastCommittedTxId + \", server:\" + server + \"]\";\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        synchronized ( channels )\n        {\n            for ( Channel channel : unusedChannels )\n            {\n                channel.close();\n            }\n            \n            for ( Channel channel : channels.values() )\n            {\n                channel.close();\n            }\n        }\n    }","id":30265,"modified_method":"public void shutdown()\n    {\n        System.out.println( \"MasterClient shutdown\" );\n        synchronized ( channels )\n        {\n            for ( Channel channel : unusedChannels )\n            {\n                channel.close();\n            }\n            \n            for ( Channel channel : channels.values() )\n            {\n                channel.close();\n            }\n        }\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getCurrentMasterId()\n    {\n        return this.broker.getMasterMachineId();\n    }","id":30266,"modified_method":"public int getCurrentMasterId()\n    {\n        return this.broker.getMasterMachine().getMachineId();\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        // Just to make sure it has gotten it\n        getMaster();\n        \n        if ( master == null )\n        {\n            throw new IllegalStateException( \"No master elected\" );\n        }\n        return master.getMachineId();\n    }","id":30267,"modified_method":"public Machine getMasterMachine()\n    {\n        // Just to make sure it has gotten it\n        getMaster();\n        \n        if ( master == null )\n        {\n            throw new IllegalStateException( \"No master elected\" );\n        }\n        return master;\n    }","commit_id":"e43d8a2504e86d5a414560acdeed55c35f6dd142","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLatestTxId(), info.getSequenceId() ) );\n            if ( info.getLatestTxId() >= highestTxId )\n            {\n                highestTxId = info.getLatestTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master;\n    }","id":30268,"modified_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                highestTxId = info.getLastCommittedTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master;\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        return getMyMachineId();\n    }","id":30269,"modified_method":"public Machine getMasterMachine()\n    {\n        return new Machine( getMyMachineId(), 0, 1, null );\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        return this.masterMachineId;\n    }","id":30270,"modified_method":"public Machine getMasterMachine()\n    {\n        return new Machine( masterMachineId, 0, 1, null );\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void tryToEnsureIAmNotABrokenMachine()\n    {\n//        ClusterManager cluster = null;\n//        MasterClient client = null;\n        try\n        {\n            if ( broker.thisIsMaster() )\n            {\n                return;\n            }\n            \n            // Get the master id I have for my latest commit\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long lastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            int masterForMyLastCommittedTx = nioneoDataSource.getMasterForCommittedTx( lastCommittedTx );\n            \n            // Ask zoo keeper who is master a.t.m.\n//            cluster = new ClusterManager( getZooKeeperServersFromConfig( config ) );\n//            Machine currentMaster = cluster.getMaster();\n            \n            // Ask the master for the master id for my latest commit\n//            client = new MasterClient( currentMaster.getServer().first(),\n//                    currentMaster.getServer().other() );\n            Master master = broker.getMaster();\n            int masterForMastersLastCommittedTx = master.getMasterIdForCommittedTx( lastCommittedTx );\n            \n            // Compare those two, if equal -> good, start up as usual\n            if ( masterForMastersLastCommittedTx == masterForMyLastCommittedTx )\n            {\n                broker.setLastCommittedTxId( lastCommittedTx );\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                msgLog.logMessage( \"Broken store, my last committed tx,machineId[\" + \n                        lastCommittedTx + \",\" + masterForMyLastCommittedTx + \n                        \"] but master says machine id for that txId is \" + masterForMastersLastCommittedTx );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" ); \n//                }\n                throw new RuntimeException( \"I am broken\" );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n//        finally\n//        {\n//            if ( client != null )\n//            {\n//                client.shutdown();\n//            }\n//            if ( cluster != null )\n//            {\n//                cluster.shutdown();\n//            }\n//        }\n    }","id":30271,"modified_method":"private void tryToEnsureIAmNotABrokenMachine()\n    {\n//        ClusterManager cluster = null;\n//        MasterClient client = null;\n        try\n        {\n            if ( broker.thisIsMaster() )\n            {\n                return;\n            }\n            \n            // Get the master id I have for my latest commit\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long lastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long lastCommonTxId = Math.min( lastCommittedTx, broker.getMasterMachine().getLastCommittedTxId() );\n            int masterForMyLastCommittedTx = nioneoDataSource.getMasterForCommittedTx( lastCommonTxId );\n            \n            // Ask zoo keeper who is master a.t.m.\n//            cluster = new ClusterManager( getZooKeeperServersFromConfig( config ) );\n//            Machine currentMaster = cluster.getMaster();\n            \n            // Ask the master for the master id for my latest commit\n//            client = new MasterClient( currentMaster.getServer().first(),\n//                    currentMaster.getServer().other() );\n            Master master = broker.getMaster();\n            int masterForMastersLastCommittedTx = master.getMasterIdForCommittedTx( lastCommonTxId );\n            \n            // Compare those two, if equal -> good, start up as usual\n            if ( masterForMastersLastCommittedTx == masterForMyLastCommittedTx )\n            {\n                broker.setLastCommittedTxId( lastCommittedTx );\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                msgLog.logMessage( \"Broken store, my last committed tx,machineId[\" + \n                        lastCommittedTx + \",\" + masterForMyLastCommittedTx + \n                        \"] but master says machine id for that txId is \" + masterForMastersLastCommittedTx );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" ); \n//                }\n                throw new RuntimeException( \"I am broken\" );\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            shutdown();\n            throw new RuntimeException( e );\n        }\n//        finally\n//        {\n//            if ( client != null )\n//            {\n//                client.shutdown();\n//            }\n//            if ( cluster != null )\n//            {\n//                cluster.shutdown();\n//            }\n//        }\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getLatestTxId()\n    {\n        return latestTxId;\n    }","id":30272,"modified_method":"public long getLastCommittedTxId()\n    {\n        return lastCommittedTxId;\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"MachineInfo[ID:\" + machineId + \", sequence:\" + sequenceId +\n                \", latest tx id:\" + latestTxId + \", server:\" + server + \"]\";\n    }","id":30273,"modified_method":"@Override\n    public String toString()\n    {\n        return \"MachineInfo[ID:\" + machineId + \", sequence:\" + sequenceId +\n                \", last committed tx id:\" + lastCommittedTxId + \", server:\" + server + \"]\";\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"Machine( int machineId, int sequenceId, long lastestTxId, String server )\n    {\n        this.machineId = machineId;\n        this.sequenceId = sequenceId;\n        this.latestTxId = lastestTxId;\n        this.server = server != null ? splitIpAndPort( server ) : null;\n    }","id":30274,"modified_method":"public Machine( int machineId, int sequenceId, long lastCommittedTxId, String server )\n    {\n        this.machineId = machineId;\n        this.sequenceId = sequenceId;\n        this.lastCommittedTxId = lastCommittedTxId;\n        this.server = server != null ? splitIpAndPort( server ) : null;\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        synchronized ( channels )\n        {\n            for ( Channel channel : unusedChannels )\n            {\n                channel.close();\n            }\n            \n            for ( Channel channel : channels.values() )\n            {\n                channel.close();\n            }\n        }\n    }","id":30275,"modified_method":"public void shutdown()\n    {\n        System.out.println( \"MasterClient shutdown\" );\n        synchronized ( channels )\n        {\n            for ( Channel channel : unusedChannels )\n            {\n                channel.close();\n            }\n            \n            for ( Channel channel : channels.values() )\n            {\n                channel.close();\n            }\n        }\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getCurrentMasterId()\n    {\n        return this.broker.getMasterMachineId();\n    }","id":30276,"modified_method":"public int getCurrentMasterId()\n    {\n        return this.broker.getMasterMachine().getMachineId();\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        // Just to make sure it has gotten it\n        getMaster();\n        \n        if ( master == null )\n        {\n            throw new IllegalStateException( \"No master elected\" );\n        }\n        return master.getMachineId();\n    }","id":30277,"modified_method":"public Machine getMasterMachine()\n    {\n        // Just to make sure it has gotten it\n        getMaster();\n        \n        if ( master == null )\n        {\n            throw new IllegalStateException( \"No master elected\" );\n        }\n        return master;\n    }","commit_id":"bd276fb92a5c4575afa493836e815b94a6fda6ce","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLatestTxId(), info.getSequenceId() ) );\n            if ( info.getLatestTxId() >= highestTxId )\n            {\n                highestTxId = info.getLatestTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master;\n    }","id":30278,"modified_method":"protected Machine getMasterBasedOn( Collection<Machine> machines )\n    {\n        Collection<Triplet<Integer, Long, Integer>> debugData =\n                new ArrayList<Triplet<Integer,Long,Integer>>();\n        Machine master = null;\n        int lowestSeq = Integer.MAX_VALUE;\n        long highestTxId = -1;\n        for ( Machine info : machines )\n        {\n            debugData.add( new Triplet<Integer,Long,Integer>( info.getMachineId(),\n                    info.getLastCommittedTxId(), info.getSequenceId() ) );\n            if ( info.getLastCommittedTxId() >= highestTxId )\n            {\n                highestTxId = info.getLastCommittedTxId();\n                if ( info.getSequenceId() < lowestSeq )\n                {\n                    master = info;\n                    lowestSeq = info.getSequenceId();\n                }\n            }\n        }\n        System.out.println( \"getMaster \" + (master != null ? master.getMachineId() : \"none\") +\n                \" based on \" + debugData );\n        return master;\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        return getMyMachineId();\n    }","id":30279,"modified_method":"public Machine getMasterMachine()\n    {\n        return new Machine( getMyMachineId(), 0, 1, null );\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        return this.masterMachineId;\n    }","id":30280,"modified_method":"public Machine getMasterMachine()\n    {\n        return new Machine( masterMachineId, 0, 1, null );\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void tryToEnsureIAmNotABrokenMachine()\n    {\n//        ClusterManager cluster = null;\n//        MasterClient client = null;\n        try\n        {\n            if ( broker.thisIsMaster() )\n            {\n                return;\n            }\n            \n            // Get the master id I have for my latest commit\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long lastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            int masterForMyLastCommittedTx = nioneoDataSource.getMasterForCommittedTx( lastCommittedTx );\n            \n            // Ask zoo keeper who is master a.t.m.\n//            cluster = new ClusterManager( getZooKeeperServersFromConfig( config ) );\n//            Machine currentMaster = cluster.getMaster();\n            \n            // Ask the master for the master id for my latest commit\n//            client = new MasterClient( currentMaster.getServer().first(),\n//                    currentMaster.getServer().other() );\n            Master master = broker.getMaster();\n            int masterForMastersLastCommittedTx = master.getMasterIdForCommittedTx( lastCommittedTx );\n            \n            // Compare those two, if equal -> good, start up as usual\n            if ( masterForMastersLastCommittedTx == masterForMyLastCommittedTx )\n            {\n                broker.setLastCommittedTxId( lastCommittedTx );\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                msgLog.logMessage( \"Broken store, my last committed tx,machineId[\" + \n                        lastCommittedTx + \",\" + masterForMyLastCommittedTx + \n                        \"] but master says machine id for that txId is \" + masterForMastersLastCommittedTx );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" ); \n//                }\n                throw new RuntimeException( \"I am broken\" );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n//        finally\n//        {\n//            if ( client != null )\n//            {\n//                client.shutdown();\n//            }\n//            if ( cluster != null )\n//            {\n//                cluster.shutdown();\n//            }\n//        }\n    }","id":30281,"modified_method":"private void tryToEnsureIAmNotABrokenMachine()\n    {\n//        ClusterManager cluster = null;\n//        MasterClient client = null;\n        try\n        {\n            if ( broker.thisIsMaster() )\n            {\n                return;\n            }\n            \n            // Get the master id I have for my latest commit\n            XaDataSource nioneoDataSource = this.localGraph.getConfig().getTxModule()\n                    .getXaDataSourceManager().getXaDataSource( Config.DEFAULT_DATA_SOURCE_NAME );\n            long lastCommittedTx = nioneoDataSource.getLastCommittedTxId();\n            long lastCommonTxId = Math.min( lastCommittedTx, broker.getMasterMachine().getLastCommittedTxId() );\n            int masterForMyLastCommittedTx = nioneoDataSource.getMasterForCommittedTx( lastCommonTxId );\n            \n            // Ask zoo keeper who is master a.t.m.\n//            cluster = new ClusterManager( getZooKeeperServersFromConfig( config ) );\n//            Machine currentMaster = cluster.getMaster();\n            \n            // Ask the master for the master id for my latest commit\n//            client = new MasterClient( currentMaster.getServer().first(),\n//                    currentMaster.getServer().other() );\n            Master master = broker.getMaster();\n            int masterForMastersLastCommittedTx = master.getMasterIdForCommittedTx( lastCommonTxId );\n            \n            // Compare those two, if equal -> good, start up as usual\n            if ( masterForMastersLastCommittedTx == masterForMyLastCommittedTx )\n            {\n                broker.setLastCommittedTxId( lastCommittedTx );\n                return;\n            }\n            // else -> recreate / destroy db\n            else\n            {\n                msgLog.logMessage( \"Broken store, my last committed tx,machineId[\" + \n                        lastCommittedTx + \",\" + masterForMyLastCommittedTx + \n                        \"] but master says machine id for that txId is \" + masterForMastersLastCommittedTx );\n//                if ( !recreateDbSomehow() )\n//                {\n//                    throw new RuntimeException( \"I was master the previous session, \" +\n//                            \"so can't start up in this state (and no method specified how \" +\n//                            \"I should replicate from another DB)\" ); \n//                }\n                throw new RuntimeException( \"I am broken\" );\n            }\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            shutdown();\n            throw new RuntimeException( e );\n        }\n//        finally\n//        {\n//            if ( client != null )\n//            {\n//                client.shutdown();\n//            }\n//            if ( cluster != null )\n//            {\n//                cluster.shutdown();\n//            }\n//        }\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"Machine( int machineId, int sequenceId, long lastestTxId, String server )\n    {\n        this.machineId = machineId;\n        this.sequenceId = sequenceId;\n        this.latestTxId = lastestTxId;\n        this.server = server != null ? splitIpAndPort( server ) : null;\n    }","id":30282,"modified_method":"public Machine( int machineId, int sequenceId, long lastCommittedTxId, String server )\n    {\n        this.machineId = machineId;\n        this.sequenceId = sequenceId;\n        this.lastCommittedTxId = lastCommittedTxId;\n        this.server = server != null ? splitIpAndPort( server ) : null;\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"MachineInfo[ID:\" + machineId + \", sequence:\" + sequenceId +\n                \", latest tx id:\" + latestTxId + \", server:\" + server + \"]\";\n    }","id":30283,"modified_method":"@Override\n    public String toString()\n    {\n        return \"MachineInfo[ID:\" + machineId + \", sequence:\" + sequenceId +\n                \", last committed tx id:\" + lastCommittedTxId + \", server:\" + server + \"]\";\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long getLatestTxId()\n    {\n        return latestTxId;\n    }","id":30284,"modified_method":"public long getLastCommittedTxId()\n    {\n        return lastCommittedTxId;\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        synchronized ( channels )\n        {\n            for ( Channel channel : unusedChannels )\n            {\n                channel.close();\n            }\n            \n            for ( Channel channel : channels.values() )\n            {\n                channel.close();\n            }\n        }\n    }","id":30285,"modified_method":"public void shutdown()\n    {\n        System.out.println( \"MasterClient shutdown\" );\n        synchronized ( channels )\n        {\n            for ( Channel channel : unusedChannels )\n            {\n                channel.close();\n            }\n            \n            for ( Channel channel : channels.values() )\n            {\n                channel.close();\n            }\n        }\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getCurrentMasterId()\n    {\n        return this.broker.getMasterMachineId();\n    }","id":30286,"modified_method":"public int getCurrentMasterId()\n    {\n        return this.broker.getMasterMachine().getMachineId();\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getMasterMachineId()\n    {\n        // Just to make sure it has gotten it\n        getMaster();\n        \n        if ( master == null )\n        {\n            throw new IllegalStateException( \"No master elected\" );\n        }\n        return master.getMachineId();\n    }","id":30287,"modified_method":"public Machine getMasterMachine()\n    {\n        // Just to make sure it has gotten it\n        getMaster();\n        \n        if ( master == null )\n        {\n            throw new IllegalStateException( \"No master elected\" );\n        }\n        return master;\n    }","commit_id":"1baad7fc8f8302b489f30e75d7d866ad0935b67e","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean matches(Collection<PresetType> t, Map<String, String> tags, boolean onlyShowable) {\n        if (onlyShowable && !isShowable()) {\n            return false;\n        } else if (t != null && types != null && !types.containsAll(t)) {\n            return false;\n        }\n        boolean atLeastOnePositiveMatch = false;\n        for (Item item : data) {\n            Boolean m = item.matches(tags);\n            if (m != null && !m) {\n                return false;\n            } else if (m != null) {\n                atLeastOnePositiveMatch = true;\n            }\n        }\n        return atLeastOnePositiveMatch;\n    }","id":30288,"modified_method":"public boolean matches(Collection<PresetType> t, Map<String, String> tags, boolean onlyShowable) {\n        if (onlyShowable && !isShowable()) {\n            return false;\n        } else if (!typeMatches(t)) {\n            return false;\n        }\n        boolean atLeastOnePositiveMatch = false;\n        for (Item item : data) {\n            Boolean m = item.matches(tags);\n            if (m != null && !m) {\n                return false;\n            } else if (m != null) {\n                atLeastOnePositiveMatch = true;\n            }\n        }\n        return atLeastOnePositiveMatch;\n    }","commit_id":"493128685ae8c424ede9c4c9fcbd3f5809234e50","url":"https://github.com/openstreetmap/josm"},{"original_method":"public TaggingPreset findPresetTemplate(OsmPrimitive primitive) {\n\n        for (TaggingPreset t : presetsWithPattern) {\n            if (t.matches(EnumSet.of(PresetType.forPrimitive(primitive)), primitive.getKeys(), false)) {\n                return t;\n            }\n        }\n        return null;\n    }","id":30289,"modified_method":"public TaggingPreset findPresetTemplate(OsmPrimitive primitive) {\n\n        for (TaggingPreset t : presetsWithPattern) {\n            Collection<PresetType> type = Collections.singleton(PresetType.forPrimitive(primitive));\n            if (t.typeMatches(type)) {\n                if (t.nameTemplateFilter != null) {\n                    if (t.nameTemplateFilter.match(primitive))\n                        return t;\n                    else {\n                        continue;\n                    }\n                } else if (t.matches(type, primitive.getKeys(), false)) {\n                    return t;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"493128685ae8c424ede9c4c9fcbd3f5809234e50","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public MandatoryPropertyConstraint mandatoryPropertyConstraintCreate( KernelStatement state, int labelId,\n            int propertyKeyId ) throws AlreadyConstrainedException, CreateConstraintFailureException\n    {\n        PrimitiveLongIterator nodes = nodesGetForLabel( state, labelId );\n        while ( nodes.hasNext() )\n        {\n            try\n            {\n                long nodeId = nodes.next();\n                if ( !nodeHasProperty( state, nodeId, propertyKeyId ) )\n                {\n                    PropertyConstraint constraint = new MandatoryPropertyConstraint( labelId, propertyKeyId );\n\n                    ConstraintVerificationFailedKernelException cause = new ConstraintVerificationFailedKernelException(\n                            constraint, Evidence.ofNodeWithNullProperty( nodeId ) );\n\n                    throw new CreateConstraintFailureException( constraint, cause );\n                }\n            }\n            catch ( EntityNotFoundException e )\n            {\n                PropertyConstraint constraint = new MandatoryPropertyConstraint( labelId, propertyKeyId );\n                throw new CreateConstraintFailureException( constraint, e );\n            }\n        }\n\n        return schemaWriteOperations.mandatoryPropertyConstraintCreate( state, labelId, propertyKeyId );\n    }","id":30290,"modified_method":"@Override\n    public MandatoryPropertyConstraint mandatoryPropertyConstraintCreate( KernelStatement state, int labelId,\n            int propertyKeyId ) throws AlreadyConstrainedException, CreateConstraintFailureException\n    {\n        PrimitiveLongIterator nodes = nodesGetForLabel( state, labelId );\n        while ( nodes.hasNext() )\n        {\n            try\n            {\n                long nodeId = nodes.next();\n                if ( !nodeHasProperty( state, nodeId, propertyKeyId ) )\n                {\n                    MandatoryPropertyConstraint constraint = new MandatoryPropertyConstraint( labelId, propertyKeyId );\n                    throw new CreateConstraintFailureException( constraint,\n                            new MandatoryNodePropertyConstraintVerificationFailedKernelException( constraint, nodeId ) );\n                }\n            }\n            catch ( EntityNotFoundException e )\n            {\n                PropertyConstraint constraint = new MandatoryPropertyConstraint( labelId, propertyKeyId );\n                throw new CreateConstraintFailureException( constraint, e );\n            }\n        }\n\n        return schemaWriteOperations.mandatoryPropertyConstraintCreate( state, labelId, propertyKeyId );\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * You MUST hold a schema write lock before you call this method.\n     */\n    public long createUniquenessConstraintIndex( KernelStatement state, SchemaReadOperations schema,\n            int labelId, int propertyKeyId )\n            throws ConstraintVerificationFailedKernelException, TransactionFailureException,\n                   CreateConstraintFailureException, DropIndexFailureException\n    {\n        IndexDescriptor descriptor = createConstraintIndex( labelId, propertyKeyId );\n        PropertyConstraint constraint = new UniquenessConstraint( labelId, propertyKeyId );\n\n        boolean success = false;\n        try\n        {\n            long indexId = schema.indexGetCommittedId( state, descriptor, SchemaStorage.IndexRuleKind.CONSTRAINT );\n            awaitIndexPopulation( constraint, indexId );\n            success = true;\n            return indexId;\n        }\n        catch ( SchemaRuleNotFoundException e )\n        {\n            throw new IllegalStateException(\n                    String.format( \"Index (%s) that we just created does not exist.\", descriptor ) );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new CreateConstraintFailureException( constraint, e );\n        }\n        finally\n        {\n            if ( !success )\n            {\n                dropUniquenessConstraintIndex( descriptor );\n            }\n        }\n    }","id":30291,"modified_method":"/**\n     * You MUST hold a schema write lock before you call this method.\n     */\n    public long createUniquenessConstraintIndex( KernelStatement state, SchemaReadOperations schema,\n            int labelId, int propertyKeyId )\n            throws ConstraintVerificationFailedKernelException, TransactionFailureException,\n                   CreateConstraintFailureException, DropIndexFailureException\n    {\n        IndexDescriptor descriptor = createConstraintIndex( labelId, propertyKeyId );\n        UniquenessConstraint constraint = new UniquenessConstraint( labelId, propertyKeyId );\n\n        boolean success = false;\n        try\n        {\n            long indexId = schema.indexGetCommittedId( state, descriptor, SchemaStorage.IndexRuleKind.CONSTRAINT );\n            awaitIndexPopulation( constraint, indexId );\n            success = true;\n            return indexId;\n        }\n        catch ( SchemaRuleNotFoundException e )\n        {\n            throw new IllegalStateException(\n                    String.format( \"Index (%s) that we just created does not exist.\", descriptor ) );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new CreateConstraintFailureException( constraint, e );\n        }\n        finally\n        {\n            if ( !success )\n            {\n                dropUniquenessConstraintIndex( descriptor );\n            }\n        }\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void awaitIndexPopulation( PropertyConstraint constraint, long indexId )\n            throws InterruptedException, ConstraintVerificationFailedKernelException\n    {\n        try\n        {\n            indexingService.getIndexProxy( indexId ).awaitStoreScanCompleted();\n        }\n        catch ( IndexNotFoundKernelException e )\n        {\n            throw new IllegalStateException(\n                    String.format( \"Index (indexId=%d) that we just created does not exist.\", indexId ) );\n        }\n        catch ( IndexPopulationFailedKernelException e )\n        {\n            Throwable cause = e.getCause();\n            if ( cause instanceof IndexEntryConflictException )\n            {\n                Evidence evidence = Evidence.of( (IndexEntryConflictException) cause );\n                throw new ConstraintVerificationFailedKernelException( constraint, evidence );\n            }\n            else\n            {\n                throw new ConstraintVerificationFailedKernelException( constraint, cause );\n            }\n        }\n    }","id":30292,"modified_method":"private void awaitIndexPopulation( UniquenessConstraint constraint, long indexId )\n            throws InterruptedException, ConstraintVerificationFailedKernelException\n    {\n        try\n        {\n            indexingService.getIndexProxy( indexId ).awaitStoreScanCompleted();\n        }\n        catch ( IndexNotFoundKernelException e )\n        {\n            throw new IllegalStateException(\n                    String.format( \"Index (indexId=%d) that we just created does not exist.\", indexId ) );\n        }\n        catch ( IndexPopulationFailedKernelException e )\n        {\n            Throwable cause = e.getCause();\n            if ( cause instanceof IndexEntryConflictException )\n            {\n                throw new UniquenessConstraintVerificationFailedKernelException( constraint,\n                        singleton( (IndexEntryConflictException) cause ) );\n            }\n            else\n            {\n                throw new UniquenessConstraintVerificationFailedKernelException( constraint, cause );\n            }\n        }\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String getUserMessage( TokenNameLookup tokenNameLookup )\n    {\n        StringBuilder message = new StringBuilder();\n        for ( Evidence evidenceItem : evidence() )\n        {\n            message.append( evidenceItem.message(\n                    tokenNameLookup.labelGetName( constraint.label() ),\n                    tokenNameLookup.propertyKeyGetName( constraint.propertyKeyId() ) ) );\n        }\n        return message.toString();\n    }","id":30293,"modified_method":"@Override\n    public abstract String getUserMessage( TokenNameLookup tokenNameLookup );","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ConstraintVerificationFailedKernelException( PropertyConstraint constraint, Throwable failure )\n    {\n        super( Status.Schema.ConstraintVerificationFailure, failure, \"Failed to verify constraint %s: %s\", constraint,\n                failure.getMessage() );\n        this.constraint = constraint;\n        this.evidence = null;\n    }","id":30294,"modified_method":"protected ConstraintVerificationFailedKernelException( PropertyConstraint constraint, Throwable failure )\n    {\n        super( Status.Schema.ConstraintVerificationFailure, failure, \"Failed to verify constraint %s: %s\", constraint,\n                failure.getMessage() );\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ConstraintVerificationFailedKernelException( PropertyConstraint constraint, Evidence evidence )\n    {\n        this( constraint, Collections.singleton( evidence ) );\n    }","id":30295,"modified_method":"protected ConstraintVerificationFailedKernelException( PropertyConstraint constraint )\n    {\n        super( Status.Schema.ConstraintVerificationFailure, \"Existing data does not satisfy %s.\", constraint );\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldValidateUniquenessIndexes() throws Exception\n    {\n        // Given\n        NeoStore store = mock( NeoStore.class );\n        IndexingService indexes = mock(IndexingService.class);\n        IntegrityValidator validator = new IntegrityValidator(store, indexes);\n\n        doThrow( new ConstraintVerificationFailedKernelException( null, new RuntimeException() ))\n         .when( indexes ).validateIndex( 2l );\n\n        UniquePropertyConstraintRule record = uniquenessConstraintRule( 1l, 1, 1, 2l );\n\n        // When\n        try\n        {\n            validator.validateSchemaRule( record );\n            fail(\"Should have thrown integrity error.\");\n        }\n        catch(Exception e)\n        {\n            // good \n        }\n    }","id":30296,"modified_method":"@Test\n    public void shouldValidateUniquenessIndexes() throws Exception\n    {\n        // Given\n        NeoStore store = mock( NeoStore.class );\n        IndexingService indexes = mock(IndexingService.class);\n        IntegrityValidator validator = new IntegrityValidator(store, indexes);\n\n        doThrow( new UniquenessConstraintVerificationFailedKernelException( null, new RuntimeException() ) )\n                .when( indexes ).validateIndex( 2l );\n\n        UniquePropertyConstraintRule record = uniquenessConstraintRule( 1l, 1, 1, 2l );\n\n        // When\n        try\n        {\n            validator.validateSchemaRule( record );\n            fail(\"Should have thrown integrity error.\");\n        }\n        catch(Exception e)\n        {\n            // good \n        }\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void validate() throws ConstraintVerificationFailedKernelException\n    {\n        Iterator<IndexEntryConflictException> iterator = failures.iterator();\n        if ( iterator.hasNext() )\n        {\n            Set<Evidence> evidences = new HashSet<>();\n            do\n            {\n                evidences.add( Evidence.of( iterator.next() ) );\n            }\n            while ( iterator.hasNext() );\n\n            IndexDescriptor descriptor = getDescriptor();\n            throw new ConstraintVerificationFailedKernelException(\n                    new UniquenessConstraint( descriptor.getLabelId(), descriptor.getPropertyKeyId() ), evidences );\n        }\n    }","id":30297,"modified_method":"@Override\n    public void validate() throws ConstraintVerificationFailedKernelException\n    {\n        if ( !failures.isEmpty() )\n        {\n            IndexDescriptor descriptor = getDescriptor();\n            throw new UniquenessConstraintVerificationFailedKernelException(\n                    new UniquenessConstraint( descriptor.getLabelId(), descriptor.getPropertyKeyId() ),\n                    new HashSet<>( failures ) );\n        }\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAbortConstraintCreationWhenDuplicatesExist() throws Exception\n    {\n        // given\n        long node1, node2;\n        int foo, name;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            // name is not unique for Foo in the existing data\n\n            foo = statement.labelGetOrCreateForName( \"Foo\" );\n            name = statement.propertyKeyGetOrCreateForName( \"name\" );\n\n            long node = statement.nodeCreate();\n            node1 = node;\n            statement.nodeAddLabel( node, foo );\n            statement.nodeSetProperty( node, Property.stringProperty( name, \"foo\" ) );\n\n            node = statement.nodeCreate();\n            statement.nodeAddLabel( node, foo );\n            node2 = node;\n            statement.nodeSetProperty( node, Property.stringProperty( name, \"foo\" ) );\n            commit();\n        }\n\n        // when\n        try\n        {\n            SchemaWriteOperations statement = schemaWriteOperationsInNewTransaction();\n            statement.uniquePropertyConstraintCreate( foo, name );\n\n            fail( \"expected exception\" );\n        }\n        // then\n        catch ( CreateConstraintFailureException ex )\n        {\n            assertEquals( new UniquenessConstraint( foo, name ), ex.constraint() );\n            Throwable cause = ex.getCause();\n            assertThat( cause, instanceOf( ConstraintVerificationFailedKernelException.class ) );\n            assertEquals(\n                    asSet( Evidence.of( new PreexistingIndexEntryConflictException( \"foo\", node1, node2 ) ) ),\n                    ((ConstraintVerificationFailedKernelException) cause).evidence()\n            );\n        }\n    }","id":30298,"modified_method":"@Test\n    public void shouldAbortConstraintCreationWhenDuplicatesExist() throws Exception\n    {\n        // given\n        long node1, node2;\n        int foo, name;\n        {\n            DataWriteOperations statement = dataWriteOperationsInNewTransaction();\n            // name is not unique for Foo in the existing data\n\n            foo = statement.labelGetOrCreateForName( \"Foo\" );\n            name = statement.propertyKeyGetOrCreateForName( \"name\" );\n\n            long node = statement.nodeCreate();\n            node1 = node;\n            statement.nodeAddLabel( node, foo );\n            statement.nodeSetProperty( node, Property.stringProperty( name, \"foo\" ) );\n\n            node = statement.nodeCreate();\n            statement.nodeAddLabel( node, foo );\n            node2 = node;\n            statement.nodeSetProperty( node, Property.stringProperty( name, \"foo\" ) );\n            commit();\n        }\n\n        // when\n        try\n        {\n            SchemaWriteOperations statement = schemaWriteOperationsInNewTransaction();\n            statement.uniquePropertyConstraintCreate( foo, name );\n\n            fail( \"expected exception\" );\n        }\n        // then\n        catch ( CreateConstraintFailureException ex )\n        {\n            assertEquals( new UniquenessConstraint( foo, name ), ex.constraint() );\n            Throwable cause = ex.getCause();\n            assertThat( cause, instanceOf( ConstraintVerificationFailedKernelException.class ) );\n\n            String expectedMessage = format(\n                    \"Multiple nodes with label `%s` have property `%s` = '%s':%n  node(%d)%n  node(%d)\", \"Foo\",\n                    \"name\", \"foo\", node1, node2 );\n            String actualMessage = userMessage( (ConstraintVerificationFailedKernelException) cause );\n            assertEquals( expectedMessage, actualMessage );\n        }\n    }","commit_id":"4cbebabdb84283f158aea35ca2e10d4c45dc1a1b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the location at which this element was declared\n     * @param namespace\n     */\n    protected AbstractAuthenticationProviderElement(final Location location, final String namespace) {\n        super(location, namespace);\n    }","id":30299,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the location at which this element was declared\n     * @param elementName the element name\n     */\n    protected AbstractAuthenticationProviderElement(final Location location, final QName elementName) {\n        super(location, elementName);\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this model\n     * @param namespace the namespace in which the root element was created\n     */\n    protected AbstractModel(final Location location, final String namespace) {\n        super(location, namespace);\n    }","id":30300,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this model\n     * @param elementName the root element name\n     */\n    protected AbstractModel(final Location location, final QName elementName) {\n        super(location, elementName);\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get an exception reporting a missing, required XML attribute.\n     *\n     * @param reader the stream reader\n     * @param required a set of enums whose toString method returns the attribute name\n     * @return the exception\n     */\n    protected static XMLStreamException missingRequired(final XMLExtendedStreamReader reader, final Set<? extends Enum<?>> required) {\n        final StringBuilder b = new StringBuilder();\n        Iterator<? extends Enum<?>> iterator = required.iterator();\n        while (iterator.hasNext()) {\n            final Enum<?> anEnum = iterator.next();\n            b.append(anEnum.toString());\n            if (iterator.hasNext()) {\n                b.append(\", \");\n            }\n        }\n        return new XMLStreamException(\"Missing required attribute(s): \" + b, reader.getLocation());\n    }","id":30301,"modified_method":"/**\n     * Get an exception reporting a missing, required XML attribute.\n     *\n     * @param reader the stream reader\n     * @param required a set of enums whose toString method returns the attribute name\n     * @return the exception\n     */\n    protected static XMLStreamException missingRequired(final XMLExtendedStreamReader reader, final Set<?> required) {\n        final StringBuilder b = new StringBuilder();\n        Iterator<?> iterator = required.iterator();\n        while (iterator.hasNext()) {\n            final Object o = iterator.next();\n            b.append(o.toString());\n            if (iterator.hasNext()) {\n                b.append(\", \");\n            }\n        }\n        return new XMLStreamException(\"Missing required attribute(s): \" + b, reader.getLocation());\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the name of this root element.\n     *\n     * @return the name\n     */\n    protected abstract QName getElementName();","id":30302,"modified_method":"/**\n     * Get the name of this root element.\n     *\n     * @return the name\n     */\n    public final QName getElementName() {\n        return elementName;\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this model root element\n     * @param namespace\n     */\n    protected AbstractModelRootElement(final Location location, final String namespace) {\n        super(location);\n        this.namespace = namespace;\n    }","id":30303,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this model root element\n     * @param elementName the element name\n     */\n    protected AbstractModelRootElement(final Location location, final QName elementName) {\n        super(location);\n        this.elementName = elementName;\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected AbstractModelRootElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        namespace = reader.getNamespaceURI();\n    }","id":30304,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param reader the reader from which to build this element\n     * @throws XMLStreamException if an error occurs\n     */\n    protected AbstractModelRootElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        assert reader.getEventType() == START_ELEMENT;\n        elementName = reader.getName();\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this element\n     * @param namespace the namespace of the subsystem element\n     */\n    protected AbstractSubsystemElement(final Location location, final String namespace) {\n        super(location, namespace);\n    }","id":30305,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this element\n     * @param elementName the element name\n     */\n    protected AbstractSubsystemElement(final Location location, final QName elementName) {\n        super(location, elementName);\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ConnectorElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        // Handle attributes\n        String name = null;\n        String socketBinding = null;\n        final EnumSet<Attribute> required = EnumSet.of(Attribute.NAME, Attribute.SOCKET_BINDING);\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                reader.handleAttribute(this, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        name = value;\n                        break;\n                    }\n                    case SOCKET_BINDING: {\n                        socketBinding = value;\n                        break;\n                    }\n                    default: throw unexpectedAttribute(reader, i);\n                }\n                required.remove(attribute);\n            }\n        }\n        if (! required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n        assert name != null;\n        assert socketBinding != null;\n        this.name = name;\n        this.socketBinding = socketBinding;\n        // Handle nested elements.\n        final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    // should mean we're done, so ignore it.\n                    break;\n                }\n                case START_ELEMENT: {\n                    if (RemotingSubsystemElement.NAMESPACES.contains(reader.getNamespaceURI())) {\n                        final Element element = Element.forName(reader.getLocalName());\n                        if (visited.contains(element)) {\n                            throw unexpectedElement(reader);\n                        }\n                        visited.add(element);\n                        switch (element) {\n                            case SASL: {\n                                saslElement = new SaslElement(reader);\n                                break;\n                            }\n                            // todo: auth provider, properties.\n                            default: throw unexpectedElement(reader);\n                        }\n                    } else {\n                        throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default: throw new IllegalStateException();\n            }\n        }\n    }","id":30306,"modified_method":"public ConnectorElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        // Handle attributes\n        String name = null;\n        String socketBinding = null;\n        final EnumSet<Attribute> required = EnumSet.of(Attribute.NAME, Attribute.SOCKET_BINDING);\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case NAME: {\n                        name = value;\n                        break;\n                    }\n                    case SOCKET_BINDING: {\n                        socketBinding = value;\n                        break;\n                    }\n                    default: throw unexpectedAttribute(reader, i);\n                }\n                required.remove(attribute);\n            }\n        }\n        if (! required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n        assert name != null;\n        assert socketBinding != null;\n        this.name = name;\n        this.socketBinding = socketBinding;\n        // Handle nested elements.\n        final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n        while (reader.hasNext()) {\n            if (reader.nextTag() == START_ELEMENT) {\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case REMOTING_1_0: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        if (visited.contains(element)) {\n                            throw unexpectedElement(reader);\n                        }\n                        visited.add(element);\n                        switch (element) {\n                            case SASL: {\n                                saslElement = new SaslElement(reader);\n                                break;\n                            }\n                            case PROPERTIES: {\n                                connectorProperties = new PropertiesElement(reader);\n                                break;\n                            }\n                            default: throw unexpectedElement(reader);\n                        }\n                        break;\n                    }\n                    default: throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public long elementHash() {\n        long hash = 0L;\n        hash = calculateElementHashOf(extensions.values(), hash);\n        hash = calculateElementHashOf(serverGroups.values(), hash);\n        hash = calculateElementHashOf(deployments.values(), hash);\n        hash = Long.rotateLeft(hash, 1) ^ systemProperties.elementHash();\n        return hash;\n    }","id":30307,"modified_method":"/** {@inheritDoc} */\n    public long elementHash() {\n        long hash = 0L;\n        hash = calculateElementHashOf(extensions.values(), hash);\n        hash = calculateElementHashOf(serverGroups.values(), hash);\n        hash = calculateElementHashOf(deployments.values(), hash);\n        if (systemProperties != null) hash = Long.rotateLeft(hash, 1) ^ systemProperties.elementHash();\n        return hash;\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of the domain element\n     */\n    public Domain(final Location location) {\n        super(location, NAMESPACE);\n    }","id":30308,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of the domain element\n     * @param elementName the element name of this domain element\n     */\n    public Domain(final Location location, final QName elementName) {\n        super(location, elementName);\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void readElement(final XMLExtendedStreamReader reader, final ParseResult<Domain> value) throws XMLStreamException {\n        // read attributes first\n        // no required attributes\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            if (reader.getAttributeNamespace(i) != null) {\n                reader.handleAttribute(value, i);\n            } else {\n                switch (Attribute.forName(reader.getAttributeLocalName(i))) {\n                    default: throw unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        // construct our new domain!\n        final Domain domain = new Domain(null);\n        // next, elements\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    // should mean we're done, so ignore it.\n                    break;\n                }\n                case START_ELEMENT: {\n                    if (Domain.NAMESPACES.contains(reader.getNamespaceURI())) {\n                        switch (Element.forName(reader.getLocalName())) {\n                            case SERVER_GROUPS: {\n                                readServerGroupsElement(reader, domain);\n                                break;\n                            }\n                            default: throw unexpectedElement(reader);\n                        }\n                    } else {\n                        // handle foreign root elements\n                        reader.handleAny(domain);\n                    }\n                    break;\n                }\n                default: throw new IllegalStateException();\n            }\n        }\n\n        // return the result\n        value.setResult(domain);\n    }","id":30309,"modified_method":"/** {@inheritDoc} */\n    public void readElement(final XMLExtendedStreamReader reader, final ParseResult<Domain> value) throws XMLStreamException {\n        value.setResult(new Domain(reader));\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of the host element\n     */\n    public Host(final Location location) {\n        super(location, Domain.NAMESPACE);\n    }","id":30310,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of the host element\n     * @param elementName the name of this host element\n     */\n    public Host(final Location location, final QName elementName) {\n        super(location, elementName);\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public PolicyElement(final XMLExtendedStreamReader reader) {\n        super(reader);\n    }","id":30311,"modified_method":"public PolicyElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        if (reader.getAttributeCount() > 0) {\n            throw unexpectedAttribute(reader, 0);\n        }\n        // Handle nested elements.\n        final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n        while (reader.hasNext()) {\n            if (reader.nextTag() == START_ELEMENT) {\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case REMOTING_1_0: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        if (visited.contains(element)) {\n                            throw unexpectedElement(reader);\n                        }\n                        visited.add(element);\n                        switch (element) {\n                            case FORWARD_SECRECY: {\n                                forwardSecrecy = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            case NO_ACTIVE: {\n                                noActive = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            case NO_ANONYMOUS: {\n                                noAnonymous = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            case NO_DICTIONARY: {\n                                noDictionary = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            case NO_PLAINTEXT: {\n                                noPlainText = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            case PASS_CREDENTIALS: {\n                                passCredentials = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            default: throw unexpectedElement(reader);\n                        }\n                        break;\n                    }\n                    default: throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public PropertiesElement(final Location location) {\n        super(location);\n    }","id":30312,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the location at which this element was declared\n     */\n    public PropertiesElement(final Location location) {\n        super(location);\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param reader the reader from which the subsystem element should be read\n     */\n    public RemotingSubsystemElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        // Handle attributes\n        String threadPoolName = null;\n        final EnumSet<Attribute> required = EnumSet.of(Attribute.THREAD_POOL_NAME);\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                reader.handleAttribute(this, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case THREAD_POOL_NAME: {\n                        threadPoolName = value;\n                        break;\n                    }\n                    default: throw unexpectedAttribute(reader, i);\n                }\n                required.remove(attribute);\n            }\n        }\n        if (! required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n        this.threadPoolName = threadPoolName;\n        // Handle elements\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    // should mean we're done, so ignore it.\n                    break;\n                }\n                case START_ELEMENT: {\n                    if (RemotingSubsystemElement.NAMESPACES.contains(reader.getNamespaceURI())) {\n                        final Element element = Element.forName(reader.getLocalName());\n                        switch (element) {\n                            case CONNECTOR: {\n                                final ConnectorElement connector = new ConnectorElement(reader);\n                                connectors.put(connector.getName(), connector);\n                                break;\n                            }\n                            // todo: auth provider, properties.\n                            default: throw unexpectedElement(reader);\n                        }\n                    } else {\n                        throw unexpectedElement(reader);\n                    }\n                    break;\n                }\n                default: throw new IllegalStateException();\n            }\n        }\n    }","id":30313,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param reader the reader from which the subsystem element should be read\n     */\n    public RemotingSubsystemElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        // Handle attributes\n        String threadPoolName = null;\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (reader.getAttributeNamespace(i) != null) {\n                throw unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                switch (attribute) {\n                    case THREAD_POOL_NAME: {\n                        threadPoolName = value;\n                        break;\n                    }\n                    default: throw unexpectedAttribute(reader, i);\n                }\n            }\n        }\n        if (threadPoolName == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.THREAD_POOL_NAME));\n        }\n        this.threadPoolName = threadPoolName;\n        // Handle elements\n        while (reader.hasNext()) {\n            if (reader.nextTag() == START_ELEMENT) {\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case REMOTING_1_0: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        switch (element) {\n                            case CONNECTOR: {\n                                final ConnectorElement connector = new ConnectorElement(reader);\n                                connectors.put(connector.getName(), connector);\n                                break;\n                            }\n                            default: throw unexpectedElement(reader);\n                        }\n                        break;\n                    }\n                    default: throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this element\n     * @param threadPoolName\n     */\n    public RemotingSubsystemElement(final Location location, final String threadPoolName) {\n        super(location, NAMESPACE);\n        if (threadPoolName == null) {\n            throw new IllegalArgumentException(\"threadPoolName is null\");\n        }\n        this.threadPoolName = threadPoolName;\n    }","id":30314,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this element\n     * @param threadPoolName the name of the thread pool for the remoting subsystem\n     * @param elementName the name of the subsystem element\n     */\n    public RemotingSubsystemElement(final Location location, final String threadPoolName, final QName elementName) {\n        super(location, elementName);\n        if (threadPoolName == null) {\n            throw new IllegalArgumentException(\"threadPoolName is null\");\n        }\n        this.threadPoolName = threadPoolName;\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Apply this configuration to an option map.\n     *\n     * @param builder the option map builder\n     */\n    public void applyTo(OptionMap.Builder builder) {\n        // todo: properties element\n        if (policy != null) {\n            policy.applyTo(builder);\n        }\n        if (includeMechanisms != null) {\n            builder.set(Options.SASL_MECHANISMS, Sequence.of(includeMechanisms));\n        }\n        if (qop != null) {\n            builder.set(Options.SASL_QOP, Sequence.of(qop));\n        }\n        if (strength != null) {\n            builder.set(Options.SASL_STRENGTH, strength);\n        }\n        if (reuseSession != null) {\n            builder.set(Options.SASL_REUSE, reuseSession);\n        }\n        if (serverAuth != null) {\n            builder.set(Options.SASL_SERVER_AUTH, serverAuth);\n        }\n    }","id":30315,"modified_method":"/**\n     * Apply this configuration to an option map.\n     *\n     * @param builder the option map builder\n     */\n    public void applyTo(OptionMap.Builder builder) {\n        // todo: properties element\n        if (policy != null) {\n            policy.applyTo(builder);\n        }\n        if (includeMechanisms != null) {\n            builder.set(Options.SASL_MECHANISMS, Sequence.of(includeMechanisms));\n        }\n        if (qop != null) {\n            builder.set(Options.SASL_QOP, Sequence.of(qop));\n        }\n        if (strength != null) {\n            // todo - fix this in XNIO\n//            builder.set(Options.SASL_STRENGTH, Sequence.of(strength));\n        }\n        if (reuseSession != null) {\n            builder.set(Options.SASL_REUSE, reuseSession);\n        }\n        if (serverAuth != null) {\n            builder.set(Options.SASL_SERVER_AUTH, serverAuth);\n        }\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public long elementHash() {\n        long hash = 0L;\n        if (properties != null) hash ^= properties.elementHash();\n        if (policy != null) hash = Long.rotateLeft(hash, 1) ^ policy.elementHash();\n        if (includeMechanisms != null) hash = calculateElementHashOf(includeMechanisms, hash);\n        if (qop != null) hash = calculateElementHashOf(qop, hash);\n        if (strength != null) hash = Long.rotateLeft(hash, 1) ^ (long)strength.ordinal();\n        if (reuseSession != null) hash = Long.rotateLeft(hash, 1) ^ reuseSession.hashCode();\n        if (serverAuth != null) hash = Long.rotateLeft(hash, 1) ^ serverAuth.hashCode();\n        return hash;\n    }","id":30316,"modified_method":"/** {@inheritDoc} */\n    public long elementHash() {\n        long hash = 0L;\n        if (properties != null) hash ^= properties.elementHash();\n        if (policy != null) hash = Long.rotateLeft(hash, 1) ^ policy.elementHash();\n        if (includeMechanisms != null) hash = calculateElementHashOf(includeMechanisms, hash);\n        if (qop != null) hash = calculateElementHashOf(qop, hash);\n        if (strength != null) hash = calculateElementHashOf(strength, hash);\n        if (reuseSession != null) hash = Long.rotateLeft(hash, 1) ^ reuseSession.hashCode();\n        if (serverAuth != null) hash = Long.rotateLeft(hash, 1) ^ serverAuth.hashCode();\n        return hash;\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public SaslElement(final XMLExtendedStreamReader reader) {\n        super(reader);\n        \n    }","id":30317,"modified_method":"public SaslElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        // No attributes\n        final int count = reader.getAttributeCount();\n        if (count > 0) {\n            throw unexpectedAttribute(reader, 0);\n        }\n        // Nested elements\n        final EnumSet<Element> visited = EnumSet.noneOf(Element.class);\n        while (reader.hasNext()) {\n            if (reader.nextTag() == START_ELEMENT) {\n                switch (Namespace.forUri(reader.getNamespaceURI())) {\n                    case REMOTING_1_0: {\n                        final Element element = Element.forName(reader.getLocalName());\n                        if (visited.contains(element)) {\n                            throw unexpectedElement(reader);\n                        }\n                        visited.add(element);\n                        switch (element) {\n                            case INCLUDE_MECHANISMS: {\n                                includeMechanisms = readArrayAttributeElement(reader, \"value\", String.class);\n                                break;\n                            }\n                            case POLICY: {\n                                policy = new PolicyElement(reader);\n                                break;\n                            }\n                            case PROPERTIES: {\n                                properties = new PropertiesElement(reader);\n                                break;\n                            }\n                            case QOP: {\n                                qop = readArrayAttributeElement(reader, \"value\", SaslQop.class);\n                                break;\n                            }\n                            case REUSE_SESSION: {\n                                reuseSession = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            case SERVER_AUTH: {\n                                serverAuth = Boolean.valueOf(readBooleanAttributeElement(reader, \"value\"));\n                                break;\n                            }\n                            case STRENGTH: {\n                                strength = readArrayAttributeElement(reader, \"value\", SaslStrength.class);\n                                break;\n                            }\n                            default: throw unexpectedElement(reader);\n                        }\n                        break;\n                    }\n                    default: throw unexpectedElement(reader);\n                }\n            }\n        }\n\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this standalone element\n     */\n    protected Standalone(final Location location) {\n        super(location, Domain.NAMESPACE);\n    }","id":30318,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param location the declaration location of this standalone element\n     * @param elementName the element name of this standalone element\n     */\n    protected Standalone(final Location location, final QName elementName) {\n        super(location, elementName);\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Assemble a standalone server configuration from the domain/host model.\n     *\n     * @param domain the domain\n     * @param host the host\n     * @param serverName the name of the server to initialize\n     * @return the standalone server model\n     */\n    public static Standalone assemble(Domain domain, Host host, String serverName) {\n        if (domain == null) {\n            throw new IllegalArgumentException(\"domain is null\");\n        }\n        if (host == null) {\n            throw new IllegalArgumentException(\"host is null\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"serverName is null\");\n        }\n        final Standalone standalone = new Standalone(null);\n\n        return standalone;\n    }","id":30319,"modified_method":"/**\n     * Assemble a standalone server configuration from the domain/host model.\n     *\n     * @param domain the domain\n     * @param host the host\n     * @param serverName the name of the server to initialize\n     * @return the standalone server model\n     */\n    public static Standalone assemble(Domain domain, Host host, String serverName) {\n        if (domain == null) {\n            throw new IllegalArgumentException(\"domain is null\");\n        }\n        if (host == null) {\n            throw new IllegalArgumentException(\"host is null\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"serverName is null\");\n        }\n        final Standalone standalone = new Standalone(null, null);\n\n        return standalone;\n    }","commit_id":"5015415eecc95cedf57d6292775b0536af9e521f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Instantiates a new evaluate persister factory.\n     *\n     * @param dumpFreq the dump frequency\n     * @param registry the metric registry\n     */\n    @Inject\n    public EvaluatePersisterFactory(@Named(\"evaluate.dump_stats_frequency\") Integer dumpFreq, MetricRegistry registry) {\n        Preconditions.checkArgument(dumpFreq > 0, \"dumpFreq must be positive\");\n        Preconditions.checkNotNull(registry, \"metric registry\");\n\n        stats = new EvaluateStats(registry);\n\n        Logging.withPrefix(LOGGING_PREFFIX, () -> {\n            final Slf4jReporter reporter = Slf4jReporter.forRegistry(registry)\n                    .outputTo(LoggerFactory.getLogger(LOGGING_PREFFIX))\n                    .convertRatesTo(TimeUnit.SECONDS)\n                    .convertDurationsTo(TimeUnit.MILLISECONDS)\n                    .build();\n            reporter.start(dumpFreq, TimeUnit.MINUTES);\n        });\n    }","id":30320,"modified_method":"/**\n     * Instantiates a new evaluate persister factory.\n     *\n     * @param registry the metric registry\n     * @param dumpFreq the dump frequency\n     */\n    public EvaluatePersisterFactory(MetricRegistry registry, Integer dumpFreq) {\n        Assert.notNull(registry, \"MetricRegistry is required\");\n        Assert.notNull(dumpFreq, \"Dump frequency is required\");\n        Assert.isTrue(dumpFreq > 0, \"Dump frequency must be positive\");\n\n        stats = new EvaluateStats(registry);\n\n        Logging.withPrefix(LOGGING_PREFFIX, () -> {\n            final Slf4jReporter reporter = Slf4jReporter.forRegistry(registry)\n                    .outputTo(LoggerFactory.getLogger(LOGGING_PREFFIX))\n                    .convertRatesTo(TimeUnit.SECONDS)\n                    .convertDurationsTo(TimeUnit.MILLISECONDS)\n                    .build();\n            reporter.start(dumpFreq, TimeUnit.MINUTES);\n        });\n    }","commit_id":"a0d43fc5f2f8e0dd2b008a8b37fc60130fecfd2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Instantiates a new evaluate statistics.\n     *\n     * @param registry the registry\n     */\n    public EvaluateStats(MetricRegistry registry) {\n        Gauge<Integer> resources = () -> { return resourceMap.size(); };\n        registry.register(MetricRegistry.name(\"evaluate\", \"resources\"), resources);\n\n        Gauge<Integer> metrics = () -> { return metricsMap.size(); };\n        registry.register(MetricRegistry.name(\"evaluate\", \"metrics\"), metrics);\n\n        Gauge<Integer> groups = () -> { return groupMap.size(); };\n        registry.register(MetricRegistry.name(\"evaluate\", \"groups\"), groups);\n\n        registry.register(MetricRegistry.name(\"evaluate\", \"meter\", \"collections\"), collectionsMeter);\n        registry.register(MetricRegistry.name(\"evaluate\", \"meter\", \"resources\"), resourcesMeter);\n        registry.register(MetricRegistry.name(\"evaluate\", \"meter\", \"groups\"), metricsMeter);\n        registry.register(MetricRegistry.name(\"evaluate\", \"meter\", \"metrics\"), groupsMeter);\n    }","id":30321,"modified_method":"/**\n     * Instantiates a new evaluate statistics.\n     *\n     * @param registry the registry\n     */\n    public EvaluateStats(MetricRegistry registry) {\n        final Gauge<Integer> resources = () -> { return resourceMap.size(); };\n        registry.register(MetricRegistry.name(\"evaluate\", \"resources\"), resources);\n\n        final Gauge<Integer> metrics = () -> { return metricsMap.size(); };\n        registry.register(MetricRegistry.name(\"evaluate\", \"metrics\"), metrics);\n\n        final Gauge<Integer> groups = () -> { return groupMap.size(); };\n        registry.register(MetricRegistry.name(\"evaluate\", \"groups\"), groups);\n\n        collectionsMeter = registry.meter(MetricRegistry.name(\"evaluate\", \"meter\", \"collections\"));\n        resourcesMeter = registry.meter(MetricRegistry.name(\"evaluate\", \"meter\", \"resources\"));\n        metricsMeter = registry.meter(MetricRegistry.name(\"evaluate\", \"meter\", \"groups\"));\n        groupsMeter = registry.meter(MetricRegistry.name(\"evaluate\", \"meter\", \"metrics\"));\n    }","commit_id":"a0d43fc5f2f8e0dd2b008a8b37fc60130fecfd2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected OnDiskAtom computeNext()\n    {\n        while (true)\n        {\n            OnDiskAtom column = blockColumns.poll();\n            if (column == null)\n            {\n                if (!fetcher.fetchMoreData())\n                    return endOfData();\n            }\n            else\n            {\n                return column;\n            }\n        }\n    }","id":30322,"modified_method":"protected OnDiskAtom computeNext()\n    {\n        while (true)\n        {\n            if (reversed)\n            {\n                // Return all tombstone for the block first (see addColumn() below)\n                OnDiskAtom column = rangeTombstonesReversed.poll();\n                if (column != null)\n                    return column;\n            }\n\n            OnDiskAtom column = blockColumns.poll();\n            if (column == null)\n            {\n                if (!fetcher.fetchMoreData())\n                    return endOfData();\n            }\n            else\n            {\n                return column;\n            }\n        }\n    }","commit_id":"1a8f7230a1b56d8e58c33ef2922f4460e7b6f913","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * This slice reader assumes that slices are sorted correctly, e.g. that for forward lookup slices are in\n     * lexicographic order of start elements and that for reverse lookup they are in reverse lexicographic order of\n     * finish (reverse start) elements. i.e. forward: [a,b],[d,e],[g,h] reverse: [h,g],[e,d],[b,a]. This reader also\n     * assumes that validation has been performed in terms of intervals (no overlapping intervals).\n     */\n    public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileDataInput input, ColumnSlice[] slices, boolean reversed)\n    {\n        Tracing.trace(\"Seeking to partition indexed section in data file\");\n        this.sstable = sstable;\n        this.originalInput = input;\n        this.reversed = reversed;\n        this.slices = slices;\n        this.comparator = sstable.metadata.comparator;\n\n        try\n        {\n            Descriptor.Version version = sstable.descriptor.version;\n            if (version.hasPromotedIndexes)\n            {\n                this.indexes = indexEntry.columnsIndex();\n                if (indexes.isEmpty())\n                {\n                    setToRowStart(sstable, indexEntry, input);\n                    this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);\n                    emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));\n                    fetcher = new SimpleBlockFetcher();\n                }\n                else\n                {\n                    this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);\n                    emptyColumnFamily.delete(indexEntry.deletionTime());\n                    fetcher = new IndexedBlockFetcher(indexEntry.position);\n                }\n            }\n            else\n            {\n                setToRowStart(sstable, indexEntry, input);\n                IndexHelper.skipBloomFilter(file);\n                this.indexes = IndexHelper.deserializeIndex(file);\n                this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);\n                emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));\n                fetcher = indexes.isEmpty()\n                        ? new SimpleBlockFetcher()\n                        : new IndexedBlockFetcher(file.getFilePointer() + 4); // We still have the column count to\n                                                                              // skip to get the basePosition\n            }\n        }\n        catch (IOException e)\n        {\n            sstable.markSuspect();\n            throw new CorruptSSTableException(e, file.getPath());\n        }\n    }","id":30323,"modified_method":"/**\n     * This slice reader assumes that slices are sorted correctly, e.g. that for forward lookup slices are in\n     * lexicographic order of start elements and that for reverse lookup they are in reverse lexicographic order of\n     * finish (reverse start) elements. i.e. forward: [a,b],[d,e],[g,h] reverse: [h,g],[e,d],[b,a]. This reader also\n     * assumes that validation has been performed in terms of intervals (no overlapping intervals).\n     */\n    public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileDataInput input, ColumnSlice[] slices, boolean reversed)\n    {\n        Tracing.trace(\"Seeking to partition indexed section in data file\");\n        this.sstable = sstable;\n        this.originalInput = input;\n        this.reversed = reversed;\n        this.slices = slices;\n        this.comparator = sstable.metadata.comparator;\n        this.rangeTombstonesReversed = reversed ? new ArrayDeque<OnDiskAtom>() : null;\n\n        try\n        {\n            Descriptor.Version version = sstable.descriptor.version;\n            if (version.hasPromotedIndexes)\n            {\n                this.indexes = indexEntry.columnsIndex();\n                if (indexes.isEmpty())\n                {\n                    setToRowStart(sstable, indexEntry, input);\n                    this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);\n                    emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));\n                    fetcher = new SimpleBlockFetcher();\n                }\n                else\n                {\n                    this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);\n                    emptyColumnFamily.delete(indexEntry.deletionTime());\n                    fetcher = new IndexedBlockFetcher(indexEntry.position);\n                }\n            }\n            else\n            {\n                setToRowStart(sstable, indexEntry, input);\n                IndexHelper.skipBloomFilter(file);\n                this.indexes = IndexHelper.deserializeIndex(file);\n                this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);\n                emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));\n                fetcher = indexes.isEmpty()\n                        ? new SimpleBlockFetcher()\n                        : new IndexedBlockFetcher(file.getFilePointer() + 4); // We still have the column count to\n                                                                              // skip to get the basePosition\n            }\n        }\n        catch (IOException e)\n        {\n            sstable.markSuspect();\n            throw new CorruptSSTableException(e, file.getPath());\n        }\n    }","commit_id":"1a8f7230a1b56d8e58c33ef2922f4460e7b6f913","url":"https://github.com/apache/cassandra"},{"original_method":"protected void addColumn(OnDiskAtom col)\n    {\n        if (reversed)\n            blockColumns.addFirst(col);\n        else\n            blockColumns.addLast(col);\n    }","id":30324,"modified_method":"protected void addColumn(OnDiskAtom col)\n    {\n        if (reversed)\n        {\n            /*\n             * We put range tomstone markers at the beginning of the range they delete. But for reversed queries,\n             * the caller still need to know about a RangeTombstone before it sees any column that it covers.\n             * To make that simple, we keep said tombstones separate and return them all before any column for\n             * a given block.\n             */\n            if (col instanceof RangeTombstone)\n                rangeTombstonesReversed.addFirst(col);\n            else\n                blockColumns.addFirst(col);\n        }\n        else\n        {\n            blockColumns.addLast(col);\n        }\n    }","commit_id":"1a8f7230a1b56d8e58c33ef2922f4460e7b6f913","url":"https://github.com/apache/cassandra"},{"original_method":"public synchronized Object findValid(PipelineContext context, CacheKey key, Object validity) {\n\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        if (entry != null && lowerOrEqual(validity, entry.validity)) {\n            // Place in first position and return\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementHitsCount();\n            if (linkedList.getFirst() != entry) {\n                linkedList.remove(entry);\n                linkedList.addFirst(entry);\n            }\n            return entry.object;\n        } else {\n            // Not latest validity\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementMissCount();\n            return null;\n        }\n    }","id":30325,"modified_method":"public synchronized Object findValid(PipelineContext context, CacheKey key, Object validity) {\n\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        if (entry != null && lowerOrEqual(validity, entry.validity)) {\n            // Place in first position and return\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementHitsCount();\n            if (linkedList.getFirst() != entry) {\n                linkedList.remove(entry.listEntry);\n                entry.listEntry = linkedList.addFirst(entry);\n            }\n            return entry.object;\n        } else {\n            // Not latest validity\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementMissCount();\n            return null;\n        }\n    }","commit_id":"ee659892b48b2a5be79a19be2f513137a542babf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public synchronized void remove(PipelineContext context, CacheKey key) {\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        keyToEntryMap.remove(key);\n        linkedList.remove(entry);\n        currentSize--;\n    }","id":30326,"modified_method":"public synchronized void remove(PipelineContext context, CacheKey key) {\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        keyToEntryMap.remove(key);\n        linkedList.remove(entry.listEntry);\n        currentSize--;\n    }","commit_id":"ee659892b48b2a5be79a19be2f513137a542babf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public synchronized Object findValidWithExpiration(PipelineContext context, CacheKey key, long expiration) {\n\n        Object result = null;\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        if (entry != null && entry.validity instanceof Long) {\n            if (expiration == EXPIRATION_NO_EXPIRATION) {\n                // Cache hit whatever the last modified date was\n                result = entry.object;\n            } else if (expiration != EXPIRATION_NO_CACHE) {\n                // Get last modified date\n                long lastModified = ((Long) entry.validity).longValue();\n                if (System.currentTimeMillis() < lastModified + expiration)\n                    result = entry.object;\n            }\n        }\n\n        if (result != null) {\n            // Place in first position and return\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementHitsCount();\n            if (linkedList.getFirst() != entry) {\n                linkedList.remove(entry);\n                linkedList.addFirst(entry);\n            }\n        } else {\n            // Cache miss\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementMissCount();\n        }\n        return result;\n    }","id":30327,"modified_method":"public synchronized Object findValidWithExpiration(PipelineContext context, CacheKey key, long expiration) {\n\n        Object result = null;\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        if (entry != null && entry.validity instanceof Long) {\n            if (expiration == EXPIRATION_NO_EXPIRATION) {\n                // Cache hit whatever the last modified date was\n                result = entry.object;\n            } else if (expiration != EXPIRATION_NO_CACHE) {\n                // Get last modified date\n                long lastModified = ((Long) entry.validity).longValue();\n                if (System.currentTimeMillis() < lastModified + expiration)\n                    result = entry.object;\n            }\n        }\n\n        if (result != null) {\n            // Place in first position and return\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementHitsCount();\n            if (linkedList.getFirst() != entry) {\n                linkedList.remove(entry.listEntry);\n                entry.listEntry = linkedList.addFirst(entry);\n            }\n        } else {\n            // Cache miss\n            if (context != null)\n                ((Statistics) getStatistics(context)).incrementMissCount();\n        }\n        return result;\n    }","commit_id":"ee659892b48b2a5be79a19be2f513137a542babf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public synchronized void add(PipelineContext context, CacheKey key, Object validity, Object object) {\n        if (key == null || validity == null) return;\n        if (context != null)\n            ((Statistics) getStatistics(context)).incrementAddCount();\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        if (entry == null) {\n            // No existing entry found\n            if (currentSize == maxSize) {\n                entry = (CacheEntry) linkedList.getLast();\n                keyToEntryMap.remove(entry.key);\n                linkedList.removeLast();\n            } else {\n                currentSize++;\n                entry = new CacheEntry();\n            }\n            entry.key = key;\n            entry.validity = validity;\n            entry.object = object;\n            keyToEntryMap.put(key, entry);\n            linkedList.addFirst(entry);\n        } else {\n            // Update validity and move to the front\n            entry.validity = validity;\n            entry.object = object;\n            linkedList.remove(entry);\n            linkedList.addFirst(entry);\n        }\n    }","id":30328,"modified_method":"public synchronized void add(PipelineContext context, CacheKey key, Object validity, Object object) {\n        if (key == null || validity == null) return;\n        if (context != null)\n            ((Statistics) getStatistics(context)).incrementAddCount();\n        CacheEntry entry = (CacheEntry) keyToEntryMap.get(key);\n        if (entry == null) {\n            // No existing entry found\n            if (currentSize == maxSize) {\n                entry = (CacheEntry) linkedList.getLast();\n                keyToEntryMap.remove(entry.key);\n                linkedList.removeLast();\n            } else {\n                currentSize++;\n                entry = new CacheEntry();\n            }\n            entry.key = key;\n            entry.validity = validity;\n            entry.object = object;\n            keyToEntryMap.put(key, entry);\n            entry.listEntry = linkedList.addFirst(entry);\n        } else {\n            // Update validity and move to the front\n            entry.validity = validity;\n            entry.object = object;\n            linkedList.remove(entry.listEntry);\n            entry.listEntry = linkedList.addFirst(entry);\n        }\n    }","commit_id":"ee659892b48b2a5be79a19be2f513137a542babf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public synchronized static Cache instance() {\n        return impl;\n    }","id":30329,"modified_method":"public static Cache instance() {\n        return impl;\n    }","commit_id":"ee659892b48b2a5be79a19be2f513137a542babf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           List contextNodeSet, int contextPosition,\n                                                           String xpathExpressionString,\n                                                           Map prefixToURIMap,\n                                                           Map variableToValueMap,\n                                                           FunctionLibrary functionLibrary,\n                                                           String baseURI) {\n        try {\n            // Find pool from cache\n            final Long validity = new Long(0);\n            final Cache cache = ObjectCache.instance();\n            String cacheKeyString = xpathExpressionString;\n            {\n                if (functionLibrary != null)// This is ok\n                    cacheKeyString = cacheKeyString + functionLibrary.hashCode();\n            }\n\n            // Get or create pool\n            final InternalCacheKey cacheKey = new InternalCacheKey(\"XPath Expression2\", cacheKeyString);\n            ObjectPool pool = (ObjectPool) cache.findValid(pipelineContext, cacheKey, validity);\n            if (pool == null) {\n                pool = createXPathPool(xpathExpressionString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI);\n                cache.add(pipelineContext, cacheKey, validity, pool);\n            }\n\n            // Get object from pool\n            final Object o = pool.borrowObject();\n            final PooledXPathExpression expr = (PooledXPathExpression) o;\n\n            // Set context node and position\n            expr.setContextNodeSet(contextNodeSet, contextPosition);\n\n            // Set variables\n            expr.setVariables(variableToValueMap);\n\n            return expr;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":30330,"modified_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           List contextNodeSet, int contextPosition,\n                                                           String xpathExpressionString,\n                                                           Map prefixToURIMap,\n                                                           Map variableToValueMap,\n                                                           FunctionLibrary functionLibrary,\n                                                           String baseURI) {\n        try {\n            // Find pool from cache\n            final Long validity = new Long(0);\n            final Cache cache = ObjectCache.instance(\"xpath\");\n            String cacheKeyString = xpathExpressionString;\n            {\n                if (functionLibrary != null)// This is ok\n                    cacheKeyString = cacheKeyString + functionLibrary.hashCode();\n            }\n\n            // Get or create pool\n            final InternalCacheKey cacheKey = new InternalCacheKey(\"XPath Expression2\", cacheKeyString);\n            ObjectPool pool = (ObjectPool) cache.findValid(pipelineContext, cacheKey, validity);\n            if (pool == null) {\n                pool = createXPathPool(xpathExpressionString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI);\n                cache.add(pipelineContext, cacheKey, validity, pool);\n            }\n\n            // Get object from pool\n            final Object o = pool.borrowObject();\n            final PooledXPathExpression expr = (PooledXPathExpression) o;\n\n            // Set context node and position\n            expr.setContextNodeSet(contextNodeSet, contextPosition);\n\n            // Set variables\n            expr.setVariables(variableToValueMap);\n\n            return expr;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"ee659892b48b2a5be79a19be2f513137a542babf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Adds the search specified by the settings in <code>s<\/code> to the\n     * search history and performs the search.\n     *\n     * @param s\n     */\n    public static void searchWithHistory(SearchSetting s) {\n        searchHistory.addFirst(s);\n        while (searchHistory.size() > SEARCH_HISTORY_SIZE)\n            searchHistory.removeLast();\n        lastSearch = s;\n        search(s.text, s.mode, s.caseSensitive, s.regexSearch);\n    }","id":30331,"modified_method":"/**\n     * Adds the search specified by the settings in <code>s<\/code> to the\n     * search history and performs the search.\n     *\n     * @param s\n     */\n    public static void searchWithHistory(SearchSetting s) {\n        if(searchHistory.isEmpty() || !s.equals(searchHistory.getFirst()))\n            searchHistory.addFirst(s);\n        while (searchHistory.size() > SEARCH_HISTORY_SIZE)\n            searchHistory.removeLast();\n        lastSearch = s;\n        search(s.text, s.mode, s.caseSensitive, s.regexSearch);\n    }","commit_id":"31d26733e7c2be98e324066f2c067b0d5af87f14","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Nullable\n  private FileContent doTake() {\n    FileContent result = null;\n\n    while (result == null) {\n      if (ourAllowParallelFileReading) {\n        result = myLoadedContentsQueue.poll();\n        if (result == null) {\n          VirtualFile virtualFileToLoad = myFilesToLoadQueue.poll();\n          while (virtualFileToLoad != null) {\n            if (isValidFile(virtualFileToLoad)) {\n              FileContent content = new FileContent(virtualFileToLoad);\n              try {\n                content.getBytes();\n                return content;\n              } catch (Throwable t) {\n                if (t instanceof IOException || t instanceof InvalidVirtualFileAccessException) {\n                  LOG.info(t);\n                } else {\n                  LOG.error(t);\n                }\n              }\n            }\n            virtualFileToLoad = myFilesToLoadQueue.poll();\n          }\n        }\n      } else {\n        try {\n          result = myLoadedContentsQueue.poll(300, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n      if (result == null && myContentLoadingThreadTerminated) {\n        return null;\n      }\n    }\n\n    final VirtualFile file = result.getVirtualFile();\n    if (file == null) {\n      try {\n        myLoadedContentsQueue.put(result); // put it back to notify the others\n      }\n      catch (InterruptedException ignore) {\n        // should not happen\n      }\n      return null;\n    }\n\n    synchronized (myProceedWithLoadingLock) {\n      myLoadedBytesInQueue -= result.getLength();\n      myProceedWithLoadingLock.notifyAll(); // we actually ask only content loading thread to proceed, so there should not be much difference with plain notify\n    }\n\n    return result;\n  }","id":30332,"modified_method":"@Nullable\n  private FileContent doTake() {\n    FileContent result = null;\n\n    while (result == null) {\n      if (ourAllowParallelFileReading) {\n        result = myLoadedContentsQueue.poll();\n        if (result == null) {\n          VirtualFile virtualFileToLoad = myFilesToLoadQueue.poll();\n          while (virtualFileToLoad != null) {\n            if (isValidFile(virtualFileToLoad)) {\n              FileContent content = new FileContent(virtualFileToLoad);\n              try {\n                content.getBytes();\n                return content;\n              } catch (Throwable t) {\n                if (t instanceof IOException || t instanceof InvalidVirtualFileAccessException) {\n                  LOG.info(t);\n                } else {\n                  LOG.error(t);\n                }\n              }\n            }\n            virtualFileToLoad = myFilesToLoadQueue.poll();\n          }\n\n          // take last content which is loaded by another thread\n          while(!myContentLoadingThreadTerminated) {\n            try {\n              result = myLoadedContentsQueue.poll(300, TimeUnit.MILLISECONDS);\n              if (result != null) break;\n            } catch (InterruptedException ex) {\n              throw new RuntimeException(ex);\n            }\n          }\n        }\n      } else {\n        try {\n          result = myLoadedContentsQueue.poll(300, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException ex) {\n          throw new RuntimeException(ex);\n        }\n      }\n      if (result == null && myContentLoadingThreadTerminated) {\n        return null;\n      }\n    }\n\n    final VirtualFile file = result.getVirtualFile();\n    if (file == null) {\n      try {\n        myLoadedContentsQueue.put(result); // put it back to notify the others\n      }\n      catch (InterruptedException ignore) {\n        // should not happen\n      }\n      return null;\n    }\n\n    synchronized (myProceedWithLoadingLock) {\n      myLoadedBytesInQueue -= result.getLength();\n      myProceedWithLoadingLock.notifyAll(); // we actually ask only content loading thread to proceed, so there should not be much difference with plain notify\n    }\n\n    return result;\n  }","commit_id":"467ba5fcb86699f998a5824b14ea78b673cd2455","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void pushback(@NotNull FileContent content) {\n    myLoadedContentsQueue.addFirst(content);\n  }","id":30333,"modified_method":"public void pushback(@NotNull FileContent content) {\n    synchronized (myProceedWithLoadingLock) {\n      myLoadedBytesInQueue += content.getLength();\n      myLoadedContentsQueue.addFirst(content);\n    }\n  }","commit_id":"467ba5fcb86699f998a5824b14ea78b673cd2455","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void queue(final Collection<VirtualFile> files, @NotNull final ProgressIndicator indicator) {\n    myFilesToLoadQueue.addAll(files);\n    final Runnable contentLoadingRunnable = new Runnable() {\n      public void run() {\n        try {\n          VirtualFile file = myFilesToLoadQueue.poll();\n          while( file != null) {\n            indicator.checkCanceled();\n            addLast(file, indicator);\n            file = myFilesToLoadQueue.poll();\n          }\n\n          synchronized (myProceedWithProcessingLock) {\n            while (myBytesBeingProcessed > 0) myProceedWithProcessingLock.wait();\n          }\n          // put end-of-queue marker only if not canceled\n          try {\n            myLoadedContentsQueue.put(new FileContent(null));\n          }\n          catch (InterruptedException e) {\n            LOG.error(e);\n          }\n        }\n        catch (ProcessCanceledException e) {\n          // Do nothing, exit the thread.\n        }\n        catch (InterruptedException e) {\n          LOG.error(e);\n        }\n        finally {\n          myContentLoadingThreadTerminated = true;\n        }\n      }\n    };\n\n    ApplicationManager.getApplication().executeOnPooledThread(contentLoadingRunnable);\n  }","id":30334,"modified_method":"public void queue(final Collection<VirtualFile> files, @NotNull final ProgressIndicator indicator) {\n    myFilesToLoadQueue.addAll(files);\n    final Runnable contentLoadingRunnable = new Runnable() {\n      public void run() {\n        try {\n          VirtualFile file = myFilesToLoadQueue.poll();\n          while( file != null) {\n            indicator.checkCanceled();\n            addLast(file, indicator);\n            file = myFilesToLoadQueue.poll();\n          }\n\n          // put end-of-queue marker only if not canceled\n          try {\n            myLoadedContentsQueue.put(new FileContent(null));\n          }\n          catch (InterruptedException e) {\n            LOG.error(e);\n          }\n        }\n        catch (ProcessCanceledException e) {\n          // Do nothing, exit the thread.\n        }\n        catch (InterruptedException e) {\n          LOG.error(e);\n        }\n        finally {\n          myContentLoadingThreadTerminated = true;\n        }\n      }\n    };\n\n    ApplicationManager.getApplication().executeOnPooledThread(contentLoadingRunnable);\n  }","commit_id":"467ba5fcb86699f998a5824b14ea78b673cd2455","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void installTableActions(final PluginTable pluginTable) {\n    super.installTableActions(pluginTable);\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        if (pluginTable.columnAtPoint(e.getPoint()) < 0) return false;\n        if (pluginTable.rowAtPoint(e.getPoint()) < 0) return false;\n        IdeaPluginDescriptor[] selection = pluginTable.getSelectedObjects();\n        if (selection != null) {\n          boolean enabled = true;\n          for (IdeaPluginDescriptor descr : selection) {\n            if (descr instanceof PluginNode) {\n              enabled &= !PluginManagerColumnInfo.isDownloaded((PluginNode)descr);\n              if (((PluginNode)descr).getStatus() == PluginNode.STATUS_INSTALLED) {\n                enabled &= InstalledPluginsTableModel.hasNewerVersion(descr.getPluginId());\n              }\n            }\n            else if (descr instanceof IdeaPluginDescriptorImpl) {\n              PluginId id = descr.getPluginId();\n              enabled &= InstalledPluginsTableModel.hasNewerVersion(id);\n            }\n          }\n          if (enabled) {\n            new ActionInstallPlugin(AvailablePluginsManagerMain.this, installed).install();\n          }\n          return true;\n        }\n        return false;\n      }\n    }.installOn(pluginTable);\n  }","id":30335,"modified_method":"@Override\n  protected void installTableActions(final PluginTable pluginTable) {\n    super.installTableActions(pluginTable);\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        if (pluginTable.columnAtPoint(e.getPoint()) < 0) return false;\n        if (pluginTable.rowAtPoint(e.getPoint()) < 0) return false;\n        return installSelected(pluginTable);\n      }\n    }.installOn(pluginTable);\n    \n    pluginTable.registerKeyboardAction(\n      new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          installSelected(pluginTable);\n        }\n      },\n      KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0),\n      JComponent.WHEN_FOCUSED\n    );\n  }","commit_id":"93d580fb8105fb6b4762b305b18de756f0dc361e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n      myUsageRenderer.clear();\n      myFileAndLineNumber.clear();\n      setBackground(isSelected && hasFocus ? UIUtil.getTableSelectionBackground() : UIUtil.getTableBackground());\n\n      if (value instanceof UsageInfo2UsageAdapter) {\n        UsageInfo2UsageAdapter usageAdapter = (UsageInfo2UsageAdapter)value;\n        UsagePresentation presentation = usageAdapter.getPresentation();\n        TextChunk[] text = presentation.getText();\n\n        // put line number / file info at the right\n        for (int i = 1; i < text.length; ++i) {\n          TextChunk textChunk = text[i];\n          SimpleTextAttributes simples = textChunk.getSimpleAttributesIgnoreBackground();\n          myUsageRenderer.append(textChunk.getText(), simples);\n        }\n\n        myFileAndLineNumber.append(usageAdapter.getFile().getName() + \" \" + text[0].getText(),\n                                    SimpleTextAttributes.GRAYED_ITALIC_ATTRIBUTES);\n      }\n      return this;\n    }","id":30336,"modified_method":"@Override\n    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n      setBackground(UIUtil.getTableBackground(isSelected));\n      myUsageRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n      myFileAndLineNumber.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n\n      return this;\n    }","commit_id":"2300591f46220e96d094598e969b21bfb0cdc88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent createCenterPanel() {\n    JPanel optionsPanel = new JPanel();\n    optionsPanel.setLayout(new GridBagLayout());\n\n    GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.weightx = 1;\n    gbConstraints.weighty = 1;\n    gbConstraints.fill = GridBagConstraints.BOTH;\n    gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n\n    JPanel topOptionsPanel = new JPanel();\n    topOptionsPanel.setLayout(new GridLayout(1, 2, UIUtil.DEFAULT_HGAP, 0));\n    topOptionsPanel.add(createFindOptionsPanel());\n    optionsPanel.add(topOptionsPanel, gbConstraints);\n    \n    JPanel resultsOptionPanel = null;\n    \n    if (myModel.isMultipleFiles()) {\n      optionsPanel.add(createGlobalScopePanel(), gbConstraints);\n      gbConstraints.weightx = 1;\n      gbConstraints.weighty = 1;\n      gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n      gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n      optionsPanel.add(createFilterPanel(),gbConstraints);\n\n      myCbToSkipResultsWhenOneUsage = createCheckbox(FindSettings.getInstance().isSkipResultsWithOneUsage(), FindBundle.message(\"find.options.skip.results.tab.with.one.occurrence.checkbox\"));\n      resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToSkipResultsWhenOneUsage);\n\n      myCbToSkipResultsWhenOneUsage.setVisible(!myModel.isReplaceState());\n\n      if (haveResultsPreview()) {\n        final JBTable table = new JBTable() {\n          @Override\n          public Dimension getPreferredSize() {\n            return new Dimension(myInputComboBox.getWidth(), super.getPreferredSize().height);\n          }\n        };\n        table.setShowColumns(false);\n        new NavigateToSourceListener().installOn(table);\n        myResultsPreviewTable = table;\n      }\n    }\n    else {\n      JPanel leftOptionsPanel = new JPanel();\n      leftOptionsPanel.setLayout(new GridLayout(3, 1, 0, 4));\n\n      leftOptionsPanel.add(createDirectionPanel());\n      leftOptionsPanel.add(createOriginPanel());\n      leftOptionsPanel.add(createScopePanel());\n      topOptionsPanel.add(leftOptionsPanel);\n    }\n\n    if (myModel.isOpenInNewTabVisible()){\n      myCbToOpenInNewTab = new JCheckBox(FindBundle.message(\"find.open.in.new.tab.checkbox\"));\n      myCbToOpenInNewTab.setFocusable(false);\n      myCbToOpenInNewTab.setSelected(myModel.isOpenInNewTab());\n      myCbToOpenInNewTab.setEnabled(myModel.isOpenInNewTabEnabled());\n\n      if (resultsOptionPanel == null) resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToOpenInNewTab);\n    }\n\n    if (myResultsPreviewTable != null) {\n      TabbedPane pane = new TabbedPaneImpl(SwingConstants.TOP);\n      pane.insertTab(\"Options\", null, optionsPanel, null, 0);\n      pane.insertTab(\"Preview\", null, new JBScrollPane(myResultsPreviewTable), null, RESULTS_PREVIEW_TAB_INDEX);\n      myContent = pane;\n      if (myPreviewResultsTabWasSelected) myContent.setSelectedIndex(RESULTS_PREVIEW_TAB_INDEX);\n\n      return pane.getComponent();\n    }\n\n    return optionsPanel;\n  }","id":30337,"modified_method":"@Override\n  public JComponent createCenterPanel() {\n    JPanel optionsPanel = new JPanel();\n    optionsPanel.setLayout(new GridBagLayout());\n\n    GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.weightx = 1;\n    gbConstraints.weighty = 1;\n    gbConstraints.fill = GridBagConstraints.BOTH;\n    gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n\n    JPanel topOptionsPanel = new JPanel();\n    topOptionsPanel.setLayout(new GridLayout(1, 2, UIUtil.DEFAULT_HGAP, 0));\n    topOptionsPanel.add(createFindOptionsPanel());\n    optionsPanel.add(topOptionsPanel, gbConstraints);\n    \n    JPanel resultsOptionPanel = null;\n    \n    if (myModel.isMultipleFiles()) {\n      optionsPanel.add(createGlobalScopePanel(), gbConstraints);\n      gbConstraints.weightx = 1;\n      gbConstraints.weighty = 1;\n      gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n\n      gbConstraints.gridwidth = GridBagConstraints.REMAINDER;\n      optionsPanel.add(createFilterPanel(),gbConstraints);\n\n      myCbToSkipResultsWhenOneUsage = createCheckbox(FindSettings.getInstance().isSkipResultsWithOneUsage(), FindBundle.message(\"find.options.skip.results.tab.with.one.occurrence.checkbox\"));\n      resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToSkipResultsWhenOneUsage);\n\n      myCbToSkipResultsWhenOneUsage.setVisible(!myModel.isReplaceState());\n\n      if (haveResultsPreview()) {\n        final JBTable table = new JBTable() {\n          @Override\n          public Dimension getPreferredSize() {\n            return new Dimension(myInputComboBox.getWidth(), super.getPreferredSize().height);\n          }\n        };\n        table.setShowColumns(false);\n        table.setShowGrid(false);\n        new NavigateToSourceListener().installOn(table);\n\n        Splitter previewSplitter = new Splitter(true, 0.5f, 0.1f, 0.9f);\n        myUsagePreviewPanel = new UsagePreviewPanel(myProject, new UsageViewPresentation());\n        myResultsPreviewTable = table;\n        myResultsPreviewTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n          @Override\n          public void valueChanged(ListSelectionEvent e) {\n            if (e.getValueIsAdjusting()) return;\n            int index = myResultsPreviewTable.getSelectionModel().getLeadSelectionIndex();\n            if (index != -1) {\n              UsageInfo usageInfo = ((UsageInfo2UsageAdapter)myResultsPreviewTable.getModel().getValueAt(index, 0)).getUsageInfo();\n              myUsagePreviewPanel.updateLayout(Collections.singletonList(usageInfo));\n            }\n            else {\n              myUsagePreviewPanel.updateLayout(null);\n            }\n          }\n        });\n        previewSplitter.setFirstComponent(new JBScrollPane(myResultsPreviewTable));\n        previewSplitter.setSecondComponent(myUsagePreviewPanel.createComponent());\n        myPreviewSplitter = previewSplitter;\n      }\n    }\n    else {\n      JPanel leftOptionsPanel = new JPanel();\n      leftOptionsPanel.setLayout(new GridLayout(3, 1, 0, 4));\n\n      leftOptionsPanel.add(createDirectionPanel());\n      leftOptionsPanel.add(createOriginPanel());\n      leftOptionsPanel.add(createScopePanel());\n      topOptionsPanel.add(leftOptionsPanel);\n    }\n\n    if (myModel.isOpenInNewTabVisible()){\n      myCbToOpenInNewTab = new JCheckBox(FindBundle.message(\"find.open.in.new.tab.checkbox\"));\n      myCbToOpenInNewTab.setFocusable(false);\n      myCbToOpenInNewTab.setSelected(myModel.isOpenInNewTab());\n      myCbToOpenInNewTab.setEnabled(myModel.isOpenInNewTabEnabled());\n\n      if (resultsOptionPanel == null) resultsOptionPanel = createResultsOptionPanel(optionsPanel, gbConstraints);\n      resultsOptionPanel.add(myCbToOpenInNewTab);\n    }\n\n    if (myPreviewSplitter != null) {\n      TabbedPane pane = new TabbedPaneImpl(SwingConstants.TOP);\n      pane.insertTab(\"Options\", null, optionsPanel, null, 0);\n      pane.insertTab(\"Preview\", null, myPreviewSplitter, null, RESULTS_PREVIEW_TAB_INDEX);\n      myContent = pane;\n      if (myPreviewResultsTabWasSelected) myContent.setSelectedIndex(RESULTS_PREVIEW_TAB_INDEX);\n\n      return pane.getComponent();\n    }\n\n    return optionsPanel;\n  }","commit_id":"2300591f46220e96d094598e969b21bfb0cdc88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void dispose() {\n    finishPreviousPreviewSearch();\n    for(Map.Entry<EditorTextField, DocumentAdapter> e: myComboBoxListeners.entrySet()) {\n      e.getKey().removeDocumentListener(e.getValue());\n    }\n    myComboBoxListeners.clear();\n    if (myScopePanel != null) myPreviousResultsExpandedState = myScopePanel.isExpanded();\n    if (myResultsPreviewTable != null) myPreviewResultsTabWasSelected = myContent.getSelectedIndex() == RESULTS_PREVIEW_TAB_INDEX;\n    super.dispose();\n  }","id":30338,"modified_method":"@Override\n  protected void dispose() {\n    finishPreviousPreviewSearch();\n    if (myUsagePreviewPanel != null) Disposer.dispose(myUsagePreviewPanel);\n    for(Map.Entry<EditorTextField, DocumentAdapter> e: myComboBoxListeners.entrySet()) {\n      e.getKey().removeDocumentListener(e.getValue());\n    }\n    myComboBoxListeners.clear();\n    if (myScopePanel != null) myPreviousResultsExpandedState = myScopePanel.isExpanded();\n    if (myResultsPreviewTable != null) myPreviewResultsTabWasSelected = myContent.getSelectedIndex() == RESULTS_PREVIEW_TAB_INDEX;\n    super.dispose();\n  }","commit_id":"2300591f46220e96d094598e969b21bfb0cdc88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionNodeInfo(@NotNull final InspectionTree tree,\n                            @NotNull final Project project) {\n    setLayout(new GridBagLayout());\n    setBorder(IdeBorderFactory.createEmptyBorder(11, 0, 0, 0));\n    final InspectionToolWrapper toolWrapper = tree.getSelectedToolWrapper();\n    LOG.assertTrue(toolWrapper != null);\n    InspectionProfileImpl currentProfile =\n      (InspectionProfileImpl)InspectionProjectProfileManager.getInstance(project).getProjectProfileImpl();\n    HighlightDisplayKey key = HighlightDisplayKey.find(toolWrapper.getShortName());\n    JButton button = new JButton();\n    boolean enabled = currentProfile.isToolEnabled(key);\n\n    JPanel titlePanel = new JPanel();\n    titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.LINE_AXIS));\n    JBLabelDecorator label = JBLabelDecorator.createJBLabelDecorator().setBold(true);\n    label.setText(toolWrapper.getDisplayName() + \" inspection\");\n    titlePanel.add(label);\n    titlePanel.add(Box.createHorizontalStrut(JBUI.scale(16)));\n    if (!enabled) {\n      JBLabel enabledLabel = new JBLabel();\n      enabledLabel.setForeground(JBColor.GRAY);\n      enabledLabel.setText(\"Disabled\");\n      titlePanel.add(enabledLabel);\n    }\n\n    add(titlePanel,\n        new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new JBInsets(0, 12, 5, 16),\n                               0, 0));\n\n    JEditorPane description = new JEditorPane();\n    description.setContentType(UIUtil.HTML_MIME);\n    description.setEditable(false);\n    description.setOpaque(false);\n    description.setBackground(UIUtil.getLabelBackground());\n    description.addHyperlinkListener(BrowserHyperlinkListener.INSTANCE);\n    final String toolDescription = toolWrapper.loadDescription();\n    SingleInspectionProfilePanel.readHTML(description, SingleInspectionProfilePanel.toHTML(description, toolDescription == null ? \"\" : toolDescription, false));\n    JScrollPane pane = ScrollPaneFactory.createScrollPane(description, true);\n\n    add(pane,\n        new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.VERTICAL,\n                               new JBInsets(0, 10, 0, 0), getFontMetrics(UIUtil.getLabelFont()).charWidth('f') * 110 - pane.getMinimumSize().width, 0));\n    add(button,\n        new GridBagConstraints(0, 2, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                               new JBInsets(15, 9, 9, 0), 0, 0));\n    button.setText((enabled ? \"Disable\" : \"Enable\") + \" inspection\");\n\n    new ClickListener() {\n      @Override\n      public boolean onClick(@NotNull MouseEvent event, int clickCount) {\n        DisableInspectionToolAction.modifyAndCommitProjectProfile(model -> {\n          final String toolId = key.toString();\n          if (enabled) {\n            model.disableTool(toolId, project);\n          }\n          else {\n            ((InspectionProfileImpl)model).enableTool(toolId, project);\n          }\n        }, project);\n        return true;\n      }\n    }.installOn(button);\n  }","id":30339,"modified_method":"public InspectionNodeInfo(@NotNull final InspectionTree tree,\n                            @NotNull final Project project) {\n    setLayout(new GridBagLayout());\n    setBorder(IdeBorderFactory.createEmptyBorder(11, 0, 0, 0));\n    final InspectionToolWrapper toolWrapper = tree.getSelectedToolWrapper();\n    LOG.assertTrue(toolWrapper != null);\n    InspectionProfileImpl currentProfile =\n      (InspectionProfileImpl)InspectionProjectProfileManager.getInstance(project).getProjectProfileImpl();\n    HighlightDisplayKey key = HighlightDisplayKey.find(toolWrapper.getShortName());\n    boolean enabled = currentProfile.isToolEnabled(key);\n\n    JPanel titlePanel = new JPanel();\n    titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.LINE_AXIS));\n    JBLabelDecorator label = JBLabelDecorator.createJBLabelDecorator().setBold(true);\n    label.setText(toolWrapper.getDisplayName() + \" inspection\");\n    titlePanel.add(label);\n    titlePanel.add(Box.createHorizontalStrut(JBUI.scale(16)));\n    if (!enabled) {\n      JBLabel enabledLabel = new JBLabel();\n      enabledLabel.setForeground(JBColor.GRAY);\n      enabledLabel.setText(\"Disabled\");\n      titlePanel.add(enabledLabel);\n    }\n\n    add(titlePanel,\n        new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new JBInsets(0, 12, 5, 16),\n                               0, 0));\n\n    JEditorPane description = new JEditorPane();\n    description.setContentType(UIUtil.HTML_MIME);\n    description.setEditable(false);\n    description.setOpaque(false);\n    description.setBackground(UIUtil.getLabelBackground());\n    description.addHyperlinkListener(BrowserHyperlinkListener.INSTANCE);\n    final String toolDescription = toolWrapper.loadDescription();\n    SingleInspectionProfilePanel.readHTML(description, SingleInspectionProfilePanel.toHTML(description, toolDescription == null ? \"\" : toolDescription, false));\n    JScrollPane pane = ScrollPaneFactory.createScrollPane(description, true);\n\n    add(pane,\n        new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.VERTICAL,\n                               new JBInsets(0, 10, 0, 0), getFontMetrics(UIUtil.getLabelFont()).charWidth('f') * 110 - pane.getMinimumSize().width, 0));\n    JButton enableButton = new JButton((enabled ? \"Disable\" : \"Enable\") + \" inspection\");\n    new ClickListener() {\n      @Override\n      public boolean onClick(@NotNull MouseEvent event, int clickCount) {\n        DisableInspectionToolAction.modifyAndCommitProjectProfile(model -> {\n          final String toolId = key.toString();\n          if (enabled) {\n            model.disableTool(toolId, project);\n          }\n          else {\n            ((InspectionProfileImpl)model).enableTool(toolId, project);\n          }\n        }, project);\n        return true;\n      }\n    }.installOn(enableButton);\n\n    JButton runInspectionOnButton = new JButton(InspectionsBundle.message(\"run.inspection.on.file.intention.text\"));\n    new ClickListener() {\n      @Override\n      public boolean onClick(@NotNull MouseEvent event, int clickCount) {\n        final AnAction action = ActionManager.getInstance().getAction(\"RunInspectionOn\");\n        action.actionPerformed(AnActionEvent.createFromDataContext(ActionPlaces.UNKNOWN, action.getTemplatePresentation(),\n                                                                   DataManager.getInstance().getDataContext(runInspectionOnButton)));\n        return true;\n      }\n    }.installOn(runInspectionOnButton);\n\n    JPanel buttons = new JPanel();\n    buttons.setLayout(new BoxLayout(buttons, BoxLayout.LINE_AXIS));\n    buttons.add(enableButton);\n    buttons.add(Box.createHorizontalStrut(JBUI.scale(3)));\n    buttons.add(runInspectionOnButton);\n\n    add(buttons,\n        new GridBagConstraints(0, 2, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,\n                               new JBInsets(15, 9, 9, 0), 0, 0));\n\n  }","commit_id":"ceeeb88015e831747188718e3dcdddd13248bcf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"NonStaticInitializer\"})\n  private JComponent createRightActionsToolbar() {\n    DefaultActionGroup specialGroup = new DefaultActionGroup();\n    specialGroup.add(myGlobalInspectionContext.getUIOptions().createGroupBySeverityAction(this));\n    specialGroup.add(myGlobalInspectionContext.getUIOptions().createGroupByDirectoryAction(this));\n    specialGroup.add(myGlobalInspectionContext.getUIOptions().createFilterResolvedItemsAction(this));\n    specialGroup.add(ActionManager.getInstance().getAction(\"EditInspectionSettings\"));\n    specialGroup.add(new InvokeQuickFixAction(this));\n    specialGroup.add(new InspectionsOptionsToolbarAction(this));\n    return createToolbar(specialGroup);\n  }","id":30340,"modified_method":"@SuppressWarnings({\"NonStaticInitializer\"})\n  private JComponent createRightActionsToolbar() {\n    DefaultActionGroup specialGroup = new DefaultActionGroup();\n    specialGroup.add(myGlobalInspectionContext.getUIOptions().createGroupBySeverityAction(this));\n    specialGroup.add(myGlobalInspectionContext.getUIOptions().createGroupByDirectoryAction(this));\n    specialGroup.add(myGlobalInspectionContext.getUIOptions().createFilterResolvedItemsAction(this));\n    specialGroup.add(ActionManager.getInstance().getAction(\"EditInspectionSettings\"));\n    specialGroup.add(new InvokeQuickFixAction(this));\n    return createToolbar(specialGroup);\n  }","commit_id":"ceeeb88015e831747188718e3dcdddd13248bcf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param parent      parent component.\n   * @param filter      filter to be edited.\n   * @param filterIndex index of <code>filter<\/code> in the <code>filters<\/code>. This parameter is\n   *                    needed to not compare filter with itself when validating.\n   * @param filters     all already configured filters. This parameter is used to\n   * @param patterns    all patterns available in this filter.\n   */\n  public FilterDialog(Component parent, TodoFilter filter, int filterIndex, List<TodoFilter> filters, List<TodoPattern> patterns) {\n    super(parent, true);\n    myFilter = filter;\n    myFilterIndex = filterIndex;\n    myFilters = filters;\n    myNameField = new JBTextField(filter.getName());\n    CheckBoxList<TodoPattern> patternsList = new CheckBoxList<TodoPattern>();\n    patternsList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    patternsList.setCheckBoxListListener((int index, boolean value) -> {\n      if (value) {\n        myFilter.addTodoPattern(patternsList.getItemAt(index));\n      }\n      else {\n        myFilter.removeTodoPattern(patternsList.getItemAt(index));\n      }\n    });\n    for (TodoPattern pattern : patterns) {\n      patternsList.addItem(pattern, pattern.getPatternString(), myFilter.contains(pattern));\n    }\n    if (patternsList.getItemsCount() > 0) {\n      patternsList.setSelectedIndex(0);\n    }\n    myPatternsScrollPane = ScrollPaneFactory.createScrollPane(patternsList);\n    myPatternsScrollPane.setMinimumSize(new Dimension(300, -1));\n    init();\n  }","id":30341,"modified_method":"/**\n   * @param parent      parent component.\n   * @param filter      filter to be edited.\n   * @param filterIndex index of <code>filter<\/code> in the <code>filters<\/code>. This parameter is\n   *                    needed to not compare filter with itself when validating.\n   * @param filters     all already configured filters. This parameter is used to\n   * @param patterns    all patterns available in this filter.\n   */\n  public FilterDialog(Component parent, TodoFilter filter, int filterIndex, List<TodoFilter> filters, List<TodoPattern> patterns) {\n    super(parent, true);\n    setTitle(IdeBundle.message(\"title.add.todo.filter\"));\n    myFilter = filter;\n    myFilterIndex = filterIndex;\n    myFilters = filters;\n    myNameField = new JBTextField(filter.getName());\n    CheckBoxList<TodoPattern> patternsList = new CheckBoxList<TodoPattern>();\n    patternsList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    patternsList.setCheckBoxListListener((int index, boolean value) -> {\n      if (value) {\n        myFilter.addTodoPattern(patternsList.getItemAt(index));\n      }\n      else {\n        myFilter.removeTodoPattern(patternsList.getItemAt(index));\n      }\n    });\n    for (TodoPattern pattern : patterns) {\n      patternsList.addItem(pattern, pattern.getPatternString(), myFilter.contains(pattern));\n    }\n    if (patternsList.getItemsCount() > 0) {\n      patternsList.setSelectedIndex(0);\n    }\n    myPatternsScrollPane = ScrollPaneFactory.createScrollPane(patternsList);\n    myPatternsScrollPane.setMinimumSize(new Dimension(300, -1));\n    init();\n  }","commit_id":"eed9c6b0509293a5e56dfb30035d604bed518938","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Object getValueAt(int row,int column){\n    TodoFilter filter=myFilters.get(row);\n    switch(column){\n      case 0:{ // \"Name\" column\n        return filter.getName();\n      }case 1:{\n        StringBuffer sb=new StringBuffer();\n        for(Iterator i=filter.iterator();i.hasNext();){\n          TodoPattern pattern=(TodoPattern)i.next();\n          sb.append(pattern.getPatternString());\n          if(i.hasNext()){\n            sb.append(\" | \");\n          }\n        }\n        return sb.toString();\n      }default:{\n        throw new IllegalArgumentException();\n      }\n    }\n  }","id":30342,"modified_method":"@Override\n  public Object getValueAt(int row, int column) {\n    TodoFilter filter = myFilters.get(row);\n    switch (column) {\n      case 0: { // \"Name\" column\n        return filter.getName();\n      }\n      case 1: {\n        StringBuilder sb = new StringBuilder();\n        for (Iterator i = filter.iterator(); i.hasNext(); ) {\n          TodoPattern pattern = (TodoPattern)i.next();\n          sb.append(pattern.getPatternString());\n          if (i.hasNext()) {\n            sb.append(\" | \");\n          }\n        }\n        return sb.toString();\n      }\n      default: {\n        throw new IllegalArgumentException();\n      }\n    }\n  }","commit_id":"eed9c6b0509293a5e56dfb30035d604bed518938","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent createComponent() {\n    // Panel with patterns\n    PanelWithButtons patternsPanel = new PanelWithButtons() {\n      {\n        initPanel();\n      }\n\n      @Override\n      protected String getLabelText() {\n        return IdeBundle.message(\"label.todo.patterns\");\n      }\n\n      @Override\n      protected JComponent createMainComponent() {\n        // JTable with TodoPaterns\n        myPatternsTable = new Table(myPatternsModel);\n        myPatternsTable.getEmptyText().setText(IdeBundle.message(\"text.todo.no.patterns\"));\n        myPatternsTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n        // Column \"Icon\"\n        JComboBox todoTypeCombo =\n          new JComboBox(new Icon[]{AllIcons.General.TodoDefault, AllIcons.General.TodoQuestion, AllIcons.General.TodoImportant});\n        todoTypeCombo.setRenderer(new TodoTypeListCellRenderer());\n        TableColumn typeColumn = myPatternsTable.getColumnModel().getColumn(0);\n        DefaultCellEditor todoTypeEditor = new DefaultCellEditor(todoTypeCombo);\n        todoTypeEditor.setClickCountToStart(1);\n        typeColumn.setCellEditor(todoTypeEditor);\n        TodoTypeTableCellRenderer todoTypeRenderer = new TodoTypeTableCellRenderer();\n        typeColumn.setCellRenderer(todoTypeRenderer);\n\n        int width = myPatternsTable.getFontMetrics(myPatternsTable.getFont()).stringWidth(myPatternsTable.getColumnName(0)) + 10;\n        typeColumn.setPreferredWidth(width);\n        typeColumn.setMaxWidth(width);\n        typeColumn.setMinWidth(width);\n\n        // Column \"Case Sensitive\"\n        TableColumn todoCaseSensitiveColumn = myPatternsTable.getColumnModel().getColumn(1);\n        width = myPatternsTable.getFontMetrics(myPatternsTable.getFont()).stringWidth(myPatternsTable.getColumnName(1)) + 10;\n        todoCaseSensitiveColumn.setPreferredWidth(width);\n        todoCaseSensitiveColumn.setMaxWidth(width);\n        todoCaseSensitiveColumn.setMinWidth(width);\n\n        // Column \"Pattern\"\n        TodoPatternTableCellRenderer todoPatternRenderer = new TodoPatternTableCellRenderer(myPatterns);\n        TableColumn patternColumn = myPatternsTable.getColumnModel().getColumn(2);\n        patternColumn.setCellRenderer(todoPatternRenderer);\n\n        ((DefaultCellEditor)myPatternsTable.getDefaultEditor(String.class)).setClickCountToStart(2);\n\n        JPanel panel = ToolbarDecorator.createDecorator(myPatternsTable)\n          .setAddAction(new AnActionButtonRunnable() {\n            @Override\n            public void run(AnActionButton button) {\n              stopEditing();\n              TodoPattern pattern = new TodoPattern(TodoAttributesUtil.createDefault());\n              PatternDialog dialog = new PatternDialog(myPanel, pattern);\n              dialog.setTitle(IdeBundle.message(\"title.add.todo.pattern\"));\n              if (!dialog.showAndGet()) {\n                return;\n              }\n              myPatterns.add(pattern);\n              int index = myPatterns.size() - 1;\n              myPatternsModel.fireTableRowsInserted(index, index);\n              myPatternsTable.getSelectionModel().setSelectionInterval(index, index);\n              myPatternsTable.scrollRectToVisible(myPatternsTable.getCellRect(index, 0, true));\n            }\n          }).setEditAction(new AnActionButtonRunnable() {\n            @Override\n            public void run(AnActionButton button) {\n              editSelectedPattern();\n            }\n          }).setRemoveAction(new AnActionButtonRunnable() {\n            @Override\n            public void run(AnActionButton button) {\n              stopEditing();\n              int selectedIndex = myPatternsTable.getSelectedRow();\n              if (selectedIndex < 0 || selectedIndex >= myPatternsModel.getRowCount()) {\n                return;\n              }\n              TodoPattern patternToBeRemoved = myPatterns.get(selectedIndex);\n              TableUtil.removeSelectedItems(myPatternsTable);\n              for (int i = 0; i < myFilters.size(); i++) {\n                TodoFilter filter = myFilters.get(i);\n                if (filter.contains(patternToBeRemoved)) {\n                  filter.removeTodoPattern(patternToBeRemoved);\n                  myFiltersModel.fireTableRowsUpdated(i, i);\n                }\n              }\n            }\n          }).disableUpDownActions().createPanel();\n\n        return panel;\n      }\n\n      @Override\n      protected JButton[] createButtons() {\n        return new JButton[]{};\n      }\n    };\n\n    // double click in \"Patterns\" table should also start editing of selected pattern\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        editSelectedPattern();\n        return true;\n      }\n    }.installOn(myPatternsTable);\n\n    // Panel with filters\n    PanelWithButtons filtersPanel = new PanelWithButtons() {\n      {\n        initPanel();\n      }\n\n      @Override\n      protected String getLabelText() {\n        return IdeBundle.message(\"label.todo.filters\");\n      }\n\n      @Override\n      protected JComponent createMainComponent() {\n        myFiltersTable = new Table(myFiltersModel);\n        myFiltersTable.getEmptyText().setText(IdeBundle.message(\"text.todo.no.filters\"));\n        myFiltersTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n        // Column \"Name\"\n\n        TableColumn nameColumn = myFiltersTable.getColumnModel().getColumn(0);\n        int width = myPatternsTable.getColumnModel().getColumn(0).getPreferredWidth()/*typeColumn*/ +\n                    myPatternsTable.getColumnModel().getColumn(1).getPreferredWidth()/*todoCaseSensitiveColumn*/;\n        nameColumn.setPreferredWidth(width);\n        nameColumn.setMaxWidth(width);\n        nameColumn.setMinWidth(width);\n        nameColumn.setCellRenderer(new MyFilterNameTableCellRenderer());\n\n        JPanel panel = ToolbarDecorator.createDecorator(myFiltersTable)\n          .setAddAction(new AnActionButtonRunnable() {\n            @Override\n            public void run(AnActionButton button) {\n              stopEditing();\n              TodoFilter filter = new TodoFilter();\n              FilterDialog dialog = new FilterDialog(myPanel, filter, -1, myFilters, myPatterns);\n              dialog.setTitle(IdeBundle.message(\"title.add.todo.filter\"));\n              dialog.show();\n              int exitCode = dialog.getExitCode();\n              if (DialogWrapper.OK_EXIT_CODE == exitCode) {\n                myFilters.add(filter);\n                int index = myFilters.size() - 1;\n                myFiltersModel.fireTableRowsInserted(index, index);\n                myFiltersTable.getSelectionModel().setSelectionInterval(index, index);\n                myFiltersTable.scrollRectToVisible(myFiltersTable.getCellRect(index, 0, true));\n              }\n            }\n          }).setEditAction(new AnActionButtonRunnable() {\n            @Override\n            public void run(AnActionButton button) {\n              editSelectedFilter();\n            }\n          }).setRemoveAction(new AnActionButtonRunnable() {\n            @Override\n            public void run(AnActionButton button) {\n              stopEditing();\n              TableUtil.removeSelectedItems(myFiltersTable);\n            }\n          }).disableUpDownActions().createPanel();\n\n        return panel;\n      }\n\n      @Override\n      protected JButton[] createButtons() {\n        return new JButton[]{};\n      }\n    };\n    // double click in \"Filters\" table should also start editing of selected filter\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        editSelectedFilter();\n        return true;\n      }\n    }.installOn(myFiltersTable);\n\n    myPanel = new JPanel(new GridBagLayout());\n    myPanel.add(patternsPanel, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH,\n                                                      new Insets(0,0,0,0), 0, 0));\n    myPanel.add(filtersPanel, new GridBagConstraints(0, 1, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH,\n                                                     new Insets(0,0,0,0), 0, 0));\n\n    return myPanel;\n  }","id":30343,"modified_method":"@Override\n  public JComponent createComponent() {\n    myPatternsTable = new JBTable(myPatternsModel);\n    myPatternsTable.getEmptyText().setText(IdeBundle.message(\"text.todo.no.patterns\"));\n    TableColumn typeColumn = myPatternsTable.getColumnModel().getColumn(0);\n    int width = myPatternsTable.getFontMetrics(myPatternsTable.getFont()).stringWidth(myPatternsTable.getColumnName(0)) + 10;\n    typeColumn.setPreferredWidth(width);\n    typeColumn.setMaxWidth(width);\n    typeColumn.setMinWidth(width);\n    typeColumn.setCellRenderer(new IconTableCellRenderer<Icon>() {\n      @Nullable\n      @Override\n      protected Icon getIcon(@NotNull Icon value, JTable table, int row) {\n        return value;\n      }\n\n      @Override\n      public Component getTableCellRendererComponent(JTable table, Object value, boolean selected, boolean focus, int row, int column) {\n        super.getTableCellRendererComponent(table, value, selected, focus, row, column);\n        setText(\"\");\n        return this;\n      }\n\n      @Override\n      protected boolean isCenterAlignment() {\n        return true;\n      }\n    });\n\n    // Column \"Case Sensitive\"\n    TableColumn todoCaseSensitiveColumn = myPatternsTable.getColumnModel().getColumn(1);\n    width = myPatternsTable.getFontMetrics(myPatternsTable.getFont()).stringWidth(myPatternsTable.getColumnName(1)) + 10;\n    todoCaseSensitiveColumn.setPreferredWidth(width);\n    todoCaseSensitiveColumn.setMaxWidth(width);\n    todoCaseSensitiveColumn.setMinWidth(width);\n    todoCaseSensitiveColumn.setCellRenderer(new BooleanTableCellRenderer());\n    todoCaseSensitiveColumn.setCellEditor(new BooleanTableCellEditor());\n\n    // Column \"Pattern\"\n    TodoPatternTableCellRenderer todoPatternRenderer = new TodoPatternTableCellRenderer(myPatterns);\n    TableColumn patternColumn = myPatternsTable.getColumnModel().getColumn(2);\n    patternColumn.setCellRenderer(todoPatternRenderer);\n\n    JPanel patternsPanel = new JPanel(new BorderLayout());\n    patternsPanel.setBorder(IdeBorderFactory.createTitledBorder(IdeBundle.message(\"label.todo.patterns\"), false));\n    patternsPanel.add(ToolbarDecorator.createDecorator(myPatternsTable)\n                        .setAddAction(new AnActionButtonRunnable() {\n                          @Override\n                          public void run(AnActionButton button) {\n                            stopEditing();\n                            TodoPattern pattern = new TodoPattern(TodoAttributesUtil.createDefault());\n                            PatternDialog dialog = new PatternDialog(myPanel, pattern);\n                            if (!dialog.showAndGet()) {\n                              return;\n                            }\n                            myPatterns.add(pattern);\n                            int index = myPatterns.size() - 1;\n                            myPatternsModel.fireTableRowsInserted(index, index);\n                            myPatternsTable.getSelectionModel().setSelectionInterval(index, index);\n                            myPatternsTable.scrollRectToVisible(myPatternsTable.getCellRect(index, 0, true));\n                          }\n                        })\n                        .setEditAction(new AnActionButtonRunnable() {\n                          @Override\n                          public void run(AnActionButton button) {\n                            editSelectedPattern();\n                          }\n                        })\n                        .setRemoveAction(new AnActionButtonRunnable() {\n                          @Override\n                          public void run(AnActionButton button) {\n                            stopEditing();\n                            int selectedIndex = myPatternsTable.getSelectedRow();\n                            if (selectedIndex < 0 || selectedIndex >= myPatternsModel.getRowCount()) {\n                              return;\n                            }\n                            TodoPattern patternToBeRemoved = myPatterns.get(selectedIndex);\n                            TableUtil.removeSelectedItems(myPatternsTable);\n                            for (int i = 0; i < myFilters.size(); i++) {\n                              TodoFilter filter = myFilters.get(i);\n                              if (filter.contains(patternToBeRemoved)) {\n                                filter.removeTodoPattern(patternToBeRemoved);\n                                myFiltersModel.fireTableRowsUpdated(i, i);\n                              }\n                            }\n                          }\n                        })\n                        .disableUpDownActions().createPanel(), BorderLayout.CENTER);\n\n    // double click in \"Patterns\" table should also start editing of selected pattern\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        editSelectedPattern();\n        return true;\n      }\n    }.installOn(myPatternsTable);\n\n    // Panel with filters\n    myFiltersTable = new JBTable(myFiltersModel);\n    myFiltersTable.getEmptyText().setText(IdeBundle.message(\"text.todo.no.filters\"));\n\n    // Column \"Name\"\n    TableColumn nameColumn = myFiltersTable.getColumnModel().getColumn(0);\n    width = myPatternsTable.getColumnModel().getColumn(0).getPreferredWidth()/*typeColumn*/ +\n            myPatternsTable.getColumnModel().getColumn(1).getPreferredWidth()/*todoCaseSensitiveColumn*/;\n    nameColumn.setPreferredWidth(width);\n    nameColumn.setMaxWidth(width);\n    nameColumn.setMinWidth(width);\n    nameColumn.setCellRenderer(new MyFilterNameTableCellRenderer());\n\n    JPanel filtersPanel = new JPanel(new BorderLayout());\n    filtersPanel.setBorder(IdeBorderFactory.createTitledBorder(IdeBundle.message(\"label.todo.filters\"), false));\n    filtersPanel.add(ToolbarDecorator.createDecorator(myFiltersTable)\n                        .setAddAction(new AnActionButtonRunnable() {\n                          @Override\n                          public void run(AnActionButton button) {\n                            stopEditing();\n                            TodoFilter filter = new TodoFilter();\n                            FilterDialog dialog = new FilterDialog(myPanel, filter, -1, myFilters, myPatterns);\n                            if (dialog.showAndGet()) {\n                              myFilters.add(filter);\n                              int index = myFilters.size() - 1;\n                              myFiltersModel.fireTableRowsInserted(index, index);\n                              myFiltersTable.getSelectionModel().setSelectionInterval(index, index);\n                              myFiltersTable.scrollRectToVisible(myFiltersTable.getCellRect(index, 0, true));\n                            }\n                          }\n                        })\n                        .setEditAction(new AnActionButtonRunnable() {\n                          @Override\n                          public void run(AnActionButton button) {\n                            editSelectedFilter();\n                          }\n                        })\n                        .setRemoveAction(new AnActionButtonRunnable() {\n                          @Override\n                          public void run(AnActionButton button) {\n                            stopEditing();\n                            TableUtil.removeSelectedItems(myFiltersTable);\n                          }\n                        }).disableUpDownActions().createPanel());\n\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        editSelectedFilter();\n        return true;\n      }\n    }.installOn(myFiltersTable);\n\n    myPanel = FormBuilder.createFormBuilder().addComponentFillVertically(patternsPanel, 0)\n      .addComponentFillVertically(filtersPanel, 0).getPanel();\n    return myPanel;\n  }","commit_id":"eed9c6b0509293a5e56dfb30035d604bed518938","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Component getTableCellRendererComponent(\n    JTable table,\n    Object value,\n    boolean isSelected,\n    boolean hasFocus,\n    int row,\n    int column\n  ){\n    super.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);\n    TodoPattern pattern=myPatterns.get(row);\n    if(isSelected){\n      setForeground(UIUtil.getTableSelectionForeground());\n    }else{\n      if(pattern.getPattern()==null){\n        setForeground(JBColor.RED);\n      }else{\n        setForeground(UIUtil.getTableForeground());\n      }\n    }\n    return this;\n  }","id":30344,"modified_method":"@Override\n  public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n    TodoPattern pattern = myPatterns.get(row);\n    if (isSelected) {\n      setForeground(UIUtil.getTableSelectionForeground());\n    }\n    else {\n      setForeground(pattern.getPattern() != null ? UIUtil.getTableForeground() : JBColor.RED);\n    }\n    return this;\n  }","commit_id":"eed9c6b0509293a5e56dfb30035d604bed518938","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n   public void canReplaceText() throws ActionException\n   {\n      TransUnit transUnit = new TransUnit(new TransUnitId(1L), \"1\", new LocaleId(\"en-US\"), true, Lists.newArrayList(\"abc\"), \"comment\", Lists.newArrayList(\"abc\", \"AbC\", \"ABC\"), ContentState.New, null, null, null, 0);\n      ReplaceText action = new ReplaceText(transUnit, \"abc\", \"123\", CASE_INSENSITIVE);\n\n      handler.execute(action, context);\n\n      ArgumentCaptor<UpdateTransUnit> captor = ArgumentCaptor.forClass(UpdateTransUnit.class);\n      verify(mockUpdateTransUnitHandler).execute(captor.capture(), eq(context));\n      MatcherAssert.assertThat(captor.getValue().getContents(), Matchers.equalTo(Lists.newArrayList(\"123\", \"123\", \"123\")));\n   }","id":30345,"modified_method":"@Test\n   public void canReplaceTextCaseSensitively() throws ActionException\n   {\n      TransUnit transUnit = transUnitBuilder.addTargets(\"abc\", \"AbC\", \"ABC\").build();\n      ReplaceText action = new ReplaceText(transUnit, \"abc\", \"123\", CASE_SENSITIVE);\n\n      handler.execute(action, context);\n\n      ArgumentCaptor<UpdateTransUnit> captor = ArgumentCaptor.forClass(UpdateTransUnit.class);\n      verify(mockUpdateTransUnitHandler).execute(captor.capture(), eq(context));\n      MatcherAssert.assertThat(captor.getValue().getContents(), Matchers.equalTo(Lists.newArrayList(\"123\", \"AbC\", \"ABC\")));\n   }","commit_id":"a9640c4a2dcc58ca6aa9d2500b86f88e5ca95681","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void rollback(UpdateTransUnit action, UpdateTransUnitResult result, ExecutionContext context) throws ActionException\n   {\n      LocaleId localeId = action.getWorkspaceId().getLocaleId();\n      log.debug(\"revert TransUnit {0}: locale {1}, state {2}, content '{3}'\", action.getTransUnitId(), localeId, action.getContentState(), action.getContents());\n      TranslationWorkspace workspace = checkSecurityAndGetWorkspace(action);\n\n      HLocale hLocale = localeServiceImpl.getByLocaleId(localeId);\n      //TODO This part of the code is related to undo/redo and it's not functioning so will be commented out. IN fact the whole method seems not being used at the moment(except undo calls it).\n//      HTextFlow hTextFlow = (HTextFlow) session.get(HTextFlow.class, action.getTransUnitId().getValue());\n//      HTextFlowTarget target = hTextFlow.getTargets().get(hLocale);\n//\n//      if (target == null)\n//      {\n//         throw new ActionException(\"Undo Failure due to empty string.\");\n//      }\n//\n//      if (!target.getVersionNum().equals(result.getCurrentVersionNum()))\n//      {\n//         if (!target.getLastModifiedBy().getAccount().getUsername().equals(authenticatedAccount.getUsername()) || textFlowTargetHistoryDAO.findConflictInHistory(target, result.getCurrentVersionNum(), authenticatedAccount.getUsername()))\n//         {\n//            throw new ActionException(\"Find conflict, Undo Failure.\");\n//         }\n//      }\n\n      TranslationService.TranslationResult translationResult = translationServiceImpl.translate(action.getTransUnitId().getValue(), localeId, result.getPrevious().getContentState(), result.getPrevious().getContents());\n      HTextFlow hTextFlow = translationResult.getTextFlow();\n      HTextFlowTarget prevTarget = translationResult.getPreviousTextFlowTarget();\n\n      int wordCount = hTextFlow.getWordCount().intValue();\n      String msgContext = null;\n      if (hTextFlow.getPotEntryData() != null)\n      {\n         msgContext = hTextFlow.getPotEntryData().getContext();\n      }\n\n      int nPlurals = resourceUtils.getNumPlurals(hTextFlow.getDocument(), hLocale);\n      ArrayList<String> sourceContents = GwtRpcUtil.getSourceContents(hTextFlow);\n      ArrayList<String> targetContents = GwtRpcUtil.getTargetContentsWithPadding(hTextFlow, prevTarget, nPlurals);\n      String modifiedBy = null;\n      String lastChanged = null;\n      if (prevTarget != null && prevTarget.getLastModifiedBy() != null && prevTarget.getLastChanged() != null)\n      {\n         modifiedBy = prevTarget.getLastModifiedBy().getName();\n         lastChanged = new SimpleDateFormat().format(prevTarget.getLastChanged());\n      }\n\n      // @formatter:off\n      TransUnit tu = new TransUnit(\n            action.getTransUnitId(), \n            hTextFlow.getResId(),\n            localeId,\n            hTextFlow.isPlural(),\n            sourceContents,\n            CommentsUtil.toString(hTextFlow.getComment()),\n            targetContents, \n            result.getPrevious().getContentState(),\n            modifiedBy,\n            lastChanged, msgContext, hTextFlow.getPos());\n      // @formatter:on\n      TransUnitUpdated event = new TransUnitUpdated(new DocumentId(hTextFlow.getDocument().getId()), wordCount, result.getPrevious().getContentState(), tu, identity.getCredentials().getUsername());\n      workspace.publish(event);\n   }","id":30346,"modified_method":"@Override\n   public void rollback(UpdateTransUnit action, UpdateTransUnitResult result, ExecutionContext context) throws ActionException\n   {\n      LocaleId localeId = action.getWorkspaceId().getLocaleId();\n      log.debug(\"revert TransUnit {0}: locale {1}, state {2}, content '{3}'\", action.getTransUnitId(), localeId, action.getContentState(), action.getContents());\n      TranslationWorkspace workspace = checkSecurityAndGetWorkspace(action);\n\n      HLocale hLocale = localeServiceImpl.getByLocaleId(localeId);\n      //TODO This part of the code is related to undo/redo and it's not functioning so will be commented out. IN fact the whole method seems not being used at the moment(except undo calls it).\n//      HTextFlow hTextFlow = (HTextFlow) session.get(HTextFlow.class, action.getTransUnitId().getValue());\n//      HTextFlowTarget target = hTextFlow.getTargets().get(hLocale);\n//\n//      if (target == null)\n//      {\n//         throw new ActionException(\"Undo Failure due to empty string.\");\n//      }\n//\n//      if (!target.getVersionNum().equals(result.getCurrentVersionNum()))\n//      {\n//         if (!target.getLastModifiedBy().getAccount().getUsername().equals(authenticatedAccount.getUsername()) || textFlowTargetHistoryDAO.findConflictInHistory(target, result.getCurrentVersionNum(), authenticatedAccount.getUsername()))\n//         {\n//            throw new ActionException(\"Find conflict, Undo Failure.\");\n//         }\n//      }\n\n      TranslationService.TranslationResult translationResult = translationServiceImpl.translate(action.getTransUnitId().getValue(), localeId, result.getPrevious().getContentState(), result.getPrevious().getContents());\n      HTextFlow hTextFlow = translationResult.getTextFlow();\n      HTextFlowTarget prevTarget = translationResult.getPreviousTextFlowTarget();\n\n      int wordCount = hTextFlow.getWordCount().intValue();\n      String msgContext = null;\n      if (hTextFlow.getPotEntryData() != null)\n      {\n         msgContext = hTextFlow.getPotEntryData().getContext();\n      }\n\n      int nPlurals = resourceUtils.getNumPlurals(hTextFlow.getDocument(), hLocale);\n      ArrayList<String> sourceContents = GwtRpcUtil.getSourceContents(hTextFlow);\n      ArrayList<String> targetContents = GwtRpcUtil.getTargetContentsWithPadding(hTextFlow, prevTarget, nPlurals);\n      String modifiedBy = \"\";\n      String lastChanged = \"\";\n      if (prevTarget != null && prevTarget.getLastModifiedBy() != null && prevTarget.getLastChanged() != null)\n      {\n         modifiedBy = prevTarget.getLastModifiedBy().getName();\n         lastChanged = new SimpleDateFormat().format(prevTarget.getLastChanged());\n      }\n\n      TransUnit tu = TransUnit.TransUnitBuilder.builder()\n            .setId(action.getTransUnitId())\n            .setResId(hTextFlow.getResId())\n            .setLocaleId(localeId)\n            .setPlural(hTextFlow.isPlural())\n            .setSources(sourceContents)\n            .setSourceComment(CommentsUtil.toString(hTextFlow.getComment()))\n            .setTargets(targetContents)\n            .setStatus(result.getPrevious().getContentState())\n            .setLastModifiedBy(modifiedBy)\n            .setLastModifiedTime(lastChanged)\n            .setMsgContext(msgContext)\n            .setRowIndex(hTextFlow.getPos())\n            .build();\n      TransUnitUpdated event = new TransUnitUpdated(new DocumentId(hTextFlow.getDocument().getId()), wordCount, result.getPrevious().getContentState(), tu, identity.getCredentials().getUsername());\n      workspace.publish(event);\n   }","commit_id":"a9640c4a2dcc58ca6aa9d2500b86f88e5ca95681","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public UpdateTransUnitResult execute(UpdateTransUnit action, ExecutionContext context) throws ActionException\n   {\n      LocaleId localeId = action.getWorkspaceId().getLocaleId();\n      log.debug(\"Updating TransUnit {0}: locale {1}, state {2}, content '{3}'\", action.getTransUnitId(), localeId, action.getContentState(), action.getContents());\n      TranslationWorkspace workspace = checkSecurityAndGetWorkspace(action);\n\n      TranslationService.TranslationResult translationResult;\n      try\n      {\n         translationResult = translationServiceImpl.translate(action.getTransUnitId().getValue(), localeId, action.getContentState(), action.getContents());\n      }\n      catch (Exception e)\n      {\n         throw new ActionException(e.getMessage());\n      }\n\n      HTextFlow hTextFlow = translationResult.getTextFlow();\n      HTextFlowTarget newTarget = translationResult.getNewTextFlowTarget();\n      HTextFlowTarget prevTarget = translationResult.getPreviousTextFlowTarget();\n\n      manageRedo(action, prevTarget);\n\n      UpdateTransUnit previous = new UpdateTransUnit(action.getTransUnitId(), newArrayList(prevTarget.getContents()), prevTarget.getState());\n\n      int wordCount = hTextFlow.getWordCount().intValue();\n      // @formatter:off\n      \n      String msgContext = null;\n      if(hTextFlow.getPotEntryData() != null) \n      {\n         msgContext = hTextFlow.getPotEntryData().getContext();\n      }\n\n      ArrayList<String> sourceContents = GwtRpcUtil.getSourceContents(hTextFlow);\n      TransUnit tu = new TransUnit(\n            action.getTransUnitId(), \n            hTextFlow.getResId(),\n            localeId,\n            hTextFlow.isPlural(),\n            sourceContents,\n            CommentsUtil.toString(hTextFlow.getComment()),\n            action.getContents(), \n            newTarget.getState(),\n            authenticatedAccount.getPerson().getName(),\n            new SimpleDateFormat().format(new Date()), msgContext, hTextFlow.getPos());\n      // @formatter:on\n      TransUnitUpdated event = new TransUnitUpdated(new DocumentId(hTextFlow.getDocument().getId()), wordCount, newTarget.getState(), tu, identity.getCredentials().getUsername());\n\n      workspace.publish(event);\n\n      UpdateTransUnitResult result = new UpdateTransUnitResult(true);\n      result.setPrevious(previous);\n      result.setCurrentVersionNum(newTarget.getVersionNum());\n\n      return result;\n   }","id":30347,"modified_method":"@Override\n   public UpdateTransUnitResult execute(UpdateTransUnit action, ExecutionContext context) throws ActionException\n   {\n      LocaleId localeId = action.getWorkspaceId().getLocaleId();\n      log.debug(\"Updating TransUnit {0}: locale {1}, state {2}, content '{3}'\", action.getTransUnitId(), localeId, action.getContentState(), action.getContents());\n      TranslationWorkspace workspace = checkSecurityAndGetWorkspace(action);\n\n      TranslationService.TranslationResult translationResult;\n      try\n      {\n         translationResult = translationServiceImpl.translate(action.getTransUnitId().getValue(), localeId, action.getContentState(), action.getContents());\n      }\n      catch (Exception e)\n      {\n         throw new ActionException(e.getMessage());\n      }\n\n      HTextFlow hTextFlow = translationResult.getTextFlow();\n      HTextFlowTarget newTarget = translationResult.getNewTextFlowTarget();\n      HTextFlowTarget prevTarget = translationResult.getPreviousTextFlowTarget();\n\n      manageRedo(action, prevTarget);\n\n      UpdateTransUnit previous = new UpdateTransUnit(action.getTransUnitId(), newArrayList(prevTarget.getContents()), prevTarget.getState());\n\n      int wordCount = hTextFlow.getWordCount().intValue();\n\n      String msgContext = null;\n      if(hTextFlow.getPotEntryData() != null) \n      {\n         msgContext = hTextFlow.getPotEntryData().getContext();\n      }\n\n      ArrayList<String> sourceContents = GwtRpcUtil.getSourceContents(hTextFlow);\n      TransUnit tu = TransUnit.TransUnitBuilder.builder()\n            .setId(action.getTransUnitId())\n            .setResId(hTextFlow.getResId())\n            .setLocaleId(localeId)\n            .setPlural(hTextFlow.isPlural())\n            .setSources(sourceContents)\n            .setSourceComment(CommentsUtil.toString(hTextFlow.getComment()))\n            .setTargets(action.getContents())\n            .setStatus(newTarget.getState())\n            .setLastModifiedBy(authenticatedAccount.getPerson().getName())\n            .setLastModifiedTime(new SimpleDateFormat().format(new Date()))\n            .setMsgContext(msgContext)\n            .setRowIndex(hTextFlow.getPos())\n            .build();\n\n      TransUnitUpdated event = new TransUnitUpdated(new DocumentId(hTextFlow.getDocument().getId()), wordCount, newTarget.getState(), tu, identity.getCredentials().getUsername());\n\n      workspace.publish(event);\n\n      UpdateTransUnitResult result = new UpdateTransUnitResult(true);\n      result.setPrevious(previous);\n      result.setCurrentVersionNum(newTarget.getVersionNum());\n\n      return result;\n   }","commit_id":"a9640c4a2dcc58ca6aa9d2500b86f88e5ca95681","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    protected void populateModel(final OperationContext context, final ModelNode operation, final Resource resource)\n            throws OperationFailedException {\n        super.populateModel(context, operation, resource);\n        final ModelNode model = resource.getModel();\n        final boolean adminOnly = context.getRunningMode() == RunningMode.ADMIN_ONLY;\n        final boolean hostController = context.getProcessType().equals(ProcessType.HOST_CONTROLLER);\n        // in case of unsupported configuration parameters:\n        // in admin mode they are all logged as warning to enable fixes before migrate operation\n        // standalone server in normal mode is shutted down with exception as it is unable to run with specified configuration\n        // domain controller in normal mode works normally - it may send old parameters to legacy hosts - such configuration is\n        // valid\n        if (adminOnly || !hostController) {\n            TransformUtils.checkLegacyModel(model, !adminOnly);\n        }\n    }","id":30348,"modified_method":"@Override\n    protected void populateModel(final OperationContext context, final ModelNode operation, final Resource resource)\n            throws OperationFailedException {\n        super.populateModel(context, operation, resource);\n        final ModelNode model = resource.getModel();\n        final boolean adminOnly = context.getRunningMode() == RunningMode.ADMIN_ONLY;\n        final boolean hostController = context.getProcessType().equals(ProcessType.HOST_CONTROLLER);\n        // in case of unsupported configuration parameters:\n        // in admin mode they are all logged as warning to enable fixes before migrate operation\n        // standalone server in normal mode is shutted down with exception as it is unable to run with specified configuration\n        // domain controller in normal mode works normally - it may send old parameters to legacy hosts - such configuration is\n        // valid\n        if (adminOnly || !hostController) {\n            final List<String> unsupportedProperites = TransformUtils.checkLegacyModel(model);\n            if(!unsupportedProperites.isEmpty()) {\n                if (adminOnly) {\n                    final String warning = JacORBLogger.ROOT_LOGGER.cannotEmulatePropertiesWarning(unsupportedProperites);\n                    JacORBLogger.ROOT_LOGGER.warn(warning);\n                } else {\n                    throw JacORBLogger.ROOT_LOGGER.cannotEmulateProperties(unsupportedProperites);\n                }\n            }\n        }\n    }","commit_id":"a1aba5e02080c7af7e1a61878cb1663ca91c2e2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void registerOperation(final ManagementResourceRegistration registry, final ResourceDescriptionResolver resourceDescriptionResolver) {\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(MIGRATE, resourceDescriptionResolver)\n                        .setRuntimeOnly()\n                        .build(),\n                new MigrateOperation(false));\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(DESCRIBE_MIGRATION, resourceDescriptionResolver)\n                        .setRuntimeOnly()\n                        .build(),\n                new MigrateOperation(true));\n\n    }","id":30349,"modified_method":"static void registerOperation(final ManagementResourceRegistration registry, final ResourceDescriptionResolver resourceDescriptionResolver) {\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(MIGRATE, resourceDescriptionResolver)\n                        .setRuntimeOnly()\n                        .setReplyParameters(MIGRATION_ERROR_ATTR)\n                        .build(),\n                new MigrateOperation(false));\n        registry.registerOperationHandler(new SimpleOperationDefinitionBuilder(DESCRIBE_MIGRATION, resourceDescriptionResolver)\n                        .setRuntimeOnly()\n                        .setReplyParameters(MIGRATION_ERROR_ATTR)\n                        .build(),\n                new MigrateOperation(true));\n\n    }","commit_id":"a1aba5e02080c7af7e1a61878cb1663ca91c2e2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        if (context.getRunningMode() != RunningMode.ADMIN_ONLY) {\n            throw new OperationFailedException(\"the iiop migration can be performed when the server is in admin-only mode\");\n        }\n\n        final PathAddress subsystemsAddress = context.getCurrentAddress().getParent();\n\n        if (context.readResourceFromRoot(subsystemsAddress).hasChild(OPENJDK_SUBSYSTEM_ELEMENT)) {\n            throw new OperationFailedException(\"can not migrate: the new iiop-openjdk subsystem is already defined\");\n        }\n\n        final Map<PathAddress, ModelNode> migrateOperations = new LinkedHashMap<>();\n\n        if (!context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS).hasChild(OPENJDK_EXTENSION_ELEMENT)) {\n            addOpenjdkExtension(context, migrateOperations);\n        }\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext operationContext, ModelNode modelNode) throws OperationFailedException {\n                final Resource jacorbResource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n                final ModelNode jacorbModel = Resource.Tools.readModel(jacorbResource).clone();\n\n                TransformUtils.checkLegacyModel(jacorbModel, true);\n\n                final ModelNode openjdkModel = TransformUtils.transformModel(jacorbModel);\n\n                final PathAddress openjdkAddress = subsystemsAddress.append(OPENJDK_SUBSYSTEM_ELEMENT);\n                addOpenjdkSubsystem(openjdkAddress, openjdkModel, migrateOperations);\n\n                final PathAddress jacorbAddress = subsystemsAddress.append(JACORB_SUBSYSTEM_ELEMENT);\n                removeJacorbSubsystem(jacorbAddress, migrateOperations);\n\n                if (describe) {\n                    // :describe-migration operation\n\n                    // for describe-migration operation, do nothing and return the list of operations that would\n                    // be executed in the composite operation\n                    final Collection<ModelNode> values = migrateOperations.values();\n                    ModelNode result = new ModelNode();\n\n                    result.get(MIGRATION_OPERATIONS).set(values);\n\n                    context.getResult().set(result);\n                } else {\n                    // :migrate operation\n                    // invoke an OSH on a composite operation with all the migration operations\n                    final Map<PathAddress, ModelNode> migrateOpResponses = migrateSubsystems(context, migrateOperations);\n\n                    context.completeStep(new OperationContext.ResultHandler() {\n                        @Override\n                        public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                            final ModelNode result = new ModelNode();\n                            if (resultAction == OperationContext.ResultAction.ROLLBACK) {\n                                for (Map.Entry<PathAddress, ModelNode> entry : migrateOpResponses.entrySet()) {\n                                    if (entry.getValue().hasDefined(FAILURE_DESCRIPTION)) {\n                                        //we check for failure description, as every node has 'failed', but one\n                                        //the real error has a failure description\n                                        //we break when we find the first one, as there will only ever be one failure\n                                        //as the op stops after the first failure\n                                        ModelNode desc = new ModelNode();\n                                        desc.get(OP).set(migrateOperations.get(entry.getKey()));\n                                        desc.get(RESULT).set(entry.getValue());\n                                        result.get(MIGRATION_ERROR).set(desc);\n                                        break;\n                                    }\n                                }\n                                context.getFailureDescription().set(new ModelNode(JacORBLogger.ROOT_LOGGER.migrationFailed()));\n                            }\n\n                            context.getResult().set(result);\n                        }\n                    });\n                }\n            }\n        }, MODEL);\n\n\n    }","id":30350,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        if (context.getRunningMode() != RunningMode.ADMIN_ONLY) {\n            throw new OperationFailedException(\"the iiop migration can be performed when the server is in admin-only mode\");\n        }\n\n        final PathAddress subsystemsAddress = context.getCurrentAddress().getParent();\n\n        if (context.readResourceFromRoot(subsystemsAddress).hasChild(OPENJDK_SUBSYSTEM_ELEMENT)) {\n            throw new OperationFailedException(\"can not migrate: the new iiop-openjdk subsystem is already defined\");\n        }\n\n        final Map<PathAddress, ModelNode> migrateOperations = new LinkedHashMap<>();\n\n        if (!context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS).hasChild(OPENJDK_EXTENSION_ELEMENT)) {\n            addOpenjdkExtension(context, migrateOperations);\n        }\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext operationContext, ModelNode modelNode) throws OperationFailedException {\n\n                final Resource jacorbResource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n                final ModelNode jacorbModel = Resource.Tools.readModel(jacorbResource).clone();\n\n                List<String> unsupportedProperties = TransformUtils.checkLegacyModel(jacorbModel);\n                if (!unsupportedProperties.isEmpty()) {\n                    context.setRollbackOnly();\n\n                    ModelNode result = new ModelNode();\n                    final String error =JacORBLogger.ROOT_LOGGER.cannotEmulatePropertiesWarning(unsupportedProperties);\n                    result.get(MIGRATION_ERROR).set(error);\n                    context.getResult().set(result);\n                    return;\n                }\n\n                final ModelNode openjdkModel = TransformUtils.transformModel(jacorbModel);\n\n                final PathAddress openjdkAddress = subsystemsAddress.append(OPENJDK_SUBSYSTEM_ELEMENT);\n                addOpenjdkSubsystem(openjdkAddress, openjdkModel, migrateOperations);\n\n                final PathAddress jacorbAddress = subsystemsAddress.append(JACORB_SUBSYSTEM_ELEMENT);\n                removeJacorbSubsystem(jacorbAddress, migrateOperations);\n\n                if (describe) {\n                    // :describe-migration operation\n\n                    // for describe-migration operation, do nothing and return the list of operations that would\n                    // be executed in the composite operation\n                    final Collection<ModelNode> values = migrateOperations.values();\n                    ModelNode result = new ModelNode();\n\n                    result.get(MIGRATION_OPERATIONS).set(values);\n\n                    context.getResult().set(result);\n                } else {\n                    // :migrate operation\n                    // invoke an OSH on a composite operation with all the migration operations\n                    final Map<PathAddress, ModelNode> migrateOpResponses = migrateSubsystems(context, migrateOperations);\n\n                    context.completeStep(new OperationContext.ResultHandler() {\n                        @Override\n                        public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                            final ModelNode result = new ModelNode();\n                            if (resultAction == OperationContext.ResultAction.ROLLBACK) {\n                                for (Map.Entry<PathAddress, ModelNode> entry : migrateOpResponses.entrySet()) {\n                                    if (entry.getValue().hasDefined(FAILURE_DESCRIPTION)) {\n                                        //we check for failure description, as every node has 'failed', but one\n                                        //the real error has a failure description\n                                        //we break when we find the first one, as there will only ever be one failure\n                                        //as the op stops after the first failure\n                                        ModelNode desc = new ModelNode();\n                                        desc.get(OP).set(migrateOperations.get(entry.getKey()));\n                                        desc.get(RESULT).set(entry.getValue());\n                                        result.get(MIGRATION_ERROR).set(desc);\n                                        break;\n                                    }\n                                }\n                                context.getFailureDescription().set(new ModelNode(JacORBLogger.ROOT_LOGGER.migrationFailed()));\n                            }\n\n                            context.getResult().set(result);\n                        }\n                    });\n                }\n            }\n        }, MODEL);\n\n\n    }","commit_id":"a1aba5e02080c7af7e1a61878cb1663ca91c2e2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"static List<String> checkLegacyModel(final ModelNode model, final boolean failOnErrors) throws OperationFailedException {\n        final List<String> propertiesToReject = new LinkedList<>();\n        for (final AttributeDefinition attribute : JacORBSubsystemDefinitions.ON_OFF_ATTRIBUTES_TO_REJECT) {\n            if (model.hasDefined(attribute.getName())\n                    && model.get(attribute.getName()).equals(JacORBSubsystemDefinitions.DEFAULT_ENABLED_PROPERTY)) {\n                propertiesToReject.add(attribute.getName());\n            }\n        }\n        for (final AttributeDefinition attribute : JacORBSubsystemDefinitions.ATTRIBUTES_TO_REJECT) {\n            if (model.hasDefined(attribute.getName())) {\n                propertiesToReject.add(attribute.getName());\n            }\n        }\n        if (!propertiesToReject.isEmpty()) {\n            if(failOnErrors) {\n                throw JacORBLogger.ROOT_LOGGER.cannotEmulateProperties(propertiesToReject);\n            } else {\n                JacORBLogger.ROOT_LOGGER.cannotEmulatePropertiesWarning(propertiesToReject);\n            }\n        }\n        return propertiesToReject;\n    }","id":30351,"modified_method":"static List<String> checkLegacyModel(final ModelNode model) throws OperationFailedException {\n        final List<String> propertiesToReject = new LinkedList<>();\n        for (final AttributeDefinition attribute : JacORBSubsystemDefinitions.ON_OFF_ATTRIBUTES_TO_REJECT) {\n            if (model.hasDefined(attribute.getName())\n                    && model.get(attribute.getName()).equals(JacORBSubsystemDefinitions.DEFAULT_ENABLED_PROPERTY)) {\n                propertiesToReject.add(attribute.getName());\n            }\n        }\n        for (final AttributeDefinition attribute : JacORBSubsystemDefinitions.ATTRIBUTES_TO_REJECT) {\n            if (model.hasDefined(attribute.getName())) {\n                propertiesToReject.add(attribute.getName());\n            }\n        }\n        return propertiesToReject;\n    }","commit_id":"a1aba5e02080c7af7e1a61878cb1663ca91c2e2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test(expected = OperationFailedException.class)\n    public void testRejectedOnOffAttribute() throws Exception {\n        ModelNode model = new ModelNode();\n        model.get(\"iona\").set(\"on\");\n        TransformUtils.checkLegacyModel(model, true);\n    }","id":30352,"modified_method":"@Test\n    public void testRejectedOnOffAttribute() throws Exception {\n        ModelNode model = new ModelNode();\n        model.get(\"iona\").set(\"on\");\n        List<String> result = TransformUtils.checkLegacyModel(model);\n        Assert.assertFalse(result.isEmpty());\n    }","commit_id":"a1aba5e02080c7af7e1a61878cb1663ca91c2e2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test(expected = OperationFailedException.class)\n    public void testRejectedAttribute() throws Exception {\n        ModelNode model = new ModelNode();\n        model.get(\"queue-min\").set(5);\n        TransformUtils.checkLegacyModel(model, true);\n    }","id":30353,"modified_method":"@Test\n    public void testRejectedAttribute() throws Exception {\n        ModelNode model = new ModelNode();\n        model.get(\"queue-min\").set(5);\n        List<String> result = TransformUtils.checkLegacyModel(model);\n        Assert.assertFalse(result.isEmpty());\n    }","commit_id":"a1aba5e02080c7af7e1a61878cb1663ca91c2e2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRejectedOnOffAttributeTurnedOff() throws Exception {\n        ModelNode model = new ModelNode();\n        model.get(\"iona\").set(\"off\");\n        TransformUtils.checkLegacyModel(model, true);\n    }","id":30354,"modified_method":"@Test\n    public void testRejectedOnOffAttributeTurnedOff() throws Exception {\n        ModelNode model = new ModelNode();\n        model.get(\"iona\").set(\"off\");\n        List<String> result =TransformUtils.checkLegacyModel(model);\n        Assert.assertTrue(result.isEmpty());\n    }","commit_id":"a1aba5e02080c7af7e1a61878cb1663ca91c2e2d","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Pair<VariationCall, List<Genotype>> calculateGenotype(RefMetaDataTracker tracker, char ref, AlignmentContext context, DiploidGenotypePriors priors) {\n\n        // we don't actually want to run EM for single samples\n        if ( samples.size() == 1 ) {\n\n            // split the context (so we can get forward/reverse contexts for free)\n            HashMap<String, AlignmentContextBySample> contexts = splitContextBySample(context);\n            if ( contexts == null )\n                return null;\n\n            // get the context for the sample\n            String sample = samples.iterator().next();\n            AlignmentContextBySample sampleContext = contexts.get(sample);\n\n            // if there were no good bases, the context wouldn't exist\n            if ( sampleContext == null )\n                return null;\n\n            // get the genotype likelihoods\n            Pair<ReadBackedPileup, GenotypeLikelihoods> discoveryGL = getSingleSampleLikelihoods(sampleContext, priors, StratifiedContext.OVERALL);\n\n            // find the index of the best genotype\n            double[] posteriors = discoveryGL.second.getNormalizedPosteriors();\n            Integer sortedPosteriors[] = Utils.SortPermutation(posteriors);\n            int bestIndex = sortedPosteriors[sortedPosteriors.length - 1];\n\n            // flag to determine if ref is the best call (not necessary in genotype mode)\n            boolean bestIsRef = false;\n\n            // calculate the phred-scaled confidence score\n            double phredScaledConfidence;\n            if ( GENOTYPE_MODE ) {\n                phredScaledConfidence = QualityUtils.phredScaleErrorRate(1.0 - posteriors[bestIndex]);\n            } else {\n                int refIndex = DiploidGenotype.createHomGenotype(ref).ordinal();\n                bestIsRef = (refIndex == bestIndex);\n                double pError = (bestIsRef ? 1.0 - posteriors[refIndex] : posteriors[refIndex]);\n                phredScaledConfidence = QualityUtils.phredScaleErrorRate(pError);\n            }\n\n            // are we above the lod threshold for emitting calls (and not in all-bases mode)?\n            if ( !ALL_BASE_MODE && ((!GENOTYPE_MODE && bestIsRef) || phredScaledConfidence < CONFIDENCE_THRESHOLD) )\n                return new Pair<VariationCall, List<Genotype>>(null, null);\n\n            // we can now create the genotype call object\n            GenotypeCall call = GenotypeWriterFactory.createSupportedGenotypeCall(OUTPUT_FORMAT, ref, context.getLocation());\n            call.setVariation(null);\n\n            if ( call instanceof ReadBacked ) {\n                ((ReadBacked)call).setPileup(discoveryGL.first);\n            }\n            if ( call instanceof SampleBacked ) {\n                ((SampleBacked)call).setSampleName(sample);\n            }\n            if ( call instanceof LikelihoodsBacked ) {\n                ((LikelihoodsBacked)call).setLikelihoods(discoveryGL.second.getLikelihoods());\n            }\n            if ( call instanceof PosteriorsBacked ) {\n                ((PosteriorsBacked)call).setPosteriors(discoveryGL.second.getPosteriors());\n            }\n\n            VariationCall locusdata = GenotypeWriterFactory.createSupportedCall(OUTPUT_FORMAT, ref, context.getLocation(), bestIsRef ? Variation.VARIANT_TYPE.REFERENCE : Variation.VARIANT_TYPE.SNP);\n            if ( locusdata != null ) {\n                if ( locusdata instanceof ConfidenceBacked ) {\n                    ((ConfidenceBacked)locusdata).setConfidence(phredScaledConfidence);\n                }\n                if ( locusdata instanceof IDBacked ) {\n                    rodDbSNP dbsnp = getDbSNP(tracker);\n                    if ( dbsnp != null )\n                        ((IDBacked)locusdata).setID(dbsnp.getRS_ID());\n                }\n            }\n\n            return new Pair<VariationCall, List<Genotype>>(locusdata, Arrays.asList((Genotype)call));\n        }\n\n        return super.calculateGenotype(tracker, ref, context, priors);\n    }","id":30355,"modified_method":"public Pair<VariationCall, List<Genotype>> calculateGenotype(RefMetaDataTracker tracker, char ref, AlignmentContext context, DiploidGenotypePriors priors) {\n\n        // we don't actually want to run EM for single samples\n        if ( samples.size() == 1 ) {\n\n            // split the context (so we can get forward/reverse contexts for free)\n            HashMap<String, AlignmentContextBySample> contexts = splitContextBySample(context);\n            if ( contexts == null )\n                return null;\n\n            // get the context for the sample\n            String sample = samples.iterator().next();\n            AlignmentContextBySample sampleContext = contexts.get(sample);\n\n            // if there were no good bases, the context wouldn't exist\n            if ( sampleContext == null )\n                return null;\n\n            // get the genotype likelihoods\n            Pair<ReadBackedPileup, GenotypeLikelihoods> discoveryGL = getSingleSampleLikelihoods(sampleContext, priors, StratifiedContext.OVERALL);\n\n            // find the index of the best genotype\n            double[] posteriors = discoveryGL.second.getNormalizedPosteriors();\n            Integer sortedPosteriors[] = Utils.SortPermutation(posteriors);\n            int bestIndex = sortedPosteriors[sortedPosteriors.length - 1];\n\n            // flag to determine if ref is the best call (not necessary in genotype mode)\n            boolean bestIsRef = false;\n\n            // calculate the phred-scaled confidence score\n            double phredScaledConfidence;\n            if ( GENOTYPE_MODE ) {\n                phredScaledConfidence = QualityUtils.phredScaleErrorRate(1.0 - posteriors[bestIndex]);\n            } else {\n                int refIndex = DiploidGenotype.createHomGenotype(ref).ordinal();\n                bestIsRef = (refIndex == bestIndex);\n                double pError = (bestIsRef ? 1.0 - posteriors[refIndex] : posteriors[refIndex]);\n                phredScaledConfidence = QualityUtils.phredScaleErrorRate(pError);\n            }\n\n            // are we above the lod threshold for emitting calls (and not in all-bases mode)?\n            if ( !ALL_BASE_MODE && ((!GENOTYPE_MODE && bestIsRef) || phredScaledConfidence < CONFIDENCE_THRESHOLD) )\n                return new Pair<VariationCall, List<Genotype>>(null, null);\n\n            // we can now create the genotype call object\n            GenotypeCall call = GenotypeWriterFactory.createSupportedGenotypeCall(OUTPUT_FORMAT, ref, context.getLocation());\n\n            if ( call instanceof ReadBacked ) {\n                ((ReadBacked)call).setPileup(discoveryGL.first);\n            }\n            if ( call instanceof SampleBacked ) {\n                ((SampleBacked)call).setSampleName(sample);\n            }\n            if ( call instanceof LikelihoodsBacked ) {\n                ((LikelihoodsBacked)call).setLikelihoods(discoveryGL.second.getLikelihoods());\n            }\n            if ( call instanceof PosteriorsBacked ) {\n                ((PosteriorsBacked)call).setPosteriors(discoveryGL.second.getPosteriors());\n            }\n\n            VariationCall locusdata = GenotypeWriterFactory.createSupportedCall(OUTPUT_FORMAT, ref, context.getLocation(), bestIsRef ? Variation.VARIANT_TYPE.REFERENCE : Variation.VARIANT_TYPE.SNP);\n            if ( locusdata != null ) {\n                if ( locusdata instanceof ConfidenceBacked ) {\n                    ((ConfidenceBacked)locusdata).setConfidence(phredScaledConfidence);\n                }\n                if ( locusdata instanceof IDBacked ) {\n                    rodDbSNP dbsnp = getDbSNP(tracker);\n                    if ( dbsnp != null )\n                        ((IDBacked)locusdata).setID(dbsnp.getRS_ID());\n                }\n                locusdata.setGenotypeCalls(Arrays.asList((Genotype)call));\n            }\n            \n            call.setVariation(locusdata);\n\n            return new Pair<VariationCall, List<Genotype>>(locusdata, Arrays.asList((Genotype)call));\n        }\n\n        return super.calculateGenotype(tracker, ref, context, priors);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Set<String> getHeaderInfo() {\n        Set<String> headerInfo = new HashSet<String>();\n\n        // this is only applicable to VCF\n        if ( UAC.VAR_FORMAT != GenotypeWriterFactory.GENOTYPE_FORMAT.VCF )\n            return headerInfo;\n\n        // first, the basic info\n        headerInfo.add(\"source=UnifiedGenotyper\");\n        headerInfo.add(\"reference=\" + getToolkit().getArguments().referenceFile.getName());\n\n        // annotation (INFO) fields from VariantAnnotator\n        if ( UAC.ALL_ANNOTATIONS )\n            headerInfo.addAll(VariantAnnotator.getAllVCFAnnotationDescriptions());\n        else\n            headerInfo.addAll(VariantAnnotator.getVCFAnnotationDescriptions());\n\n        // annotation (INFO) fields from UnifiedGenotyper\n        headerInfo.add(\"INFO=AF,1,Float,\\\"Allele Frequency\\\"\");\n        headerInfo.add(\"INFO=NS,1,Integer,\\\"Number of Samples With Data\\\"\");\n        if ( !UAC.NO_SLOD )\n            headerInfo.add(\"INFO=SB,1,Float,\\\"Strand Bias\\\"\");\n\n        if ( UAC.genotypeModel != GenotypeCalculationModel.Model.POOLED )\n            headerInfo.addAll(VCFGenotypeRecord.getSupportedHeaderStrings());\n\n        // TODO -- clean this up\n        headerInfo.add(\"UG_genotype_model=\" + UAC.genotypeModel);\n        headerInfo.add(\"UG_base_model=\" + UAC.baseModel);\n        headerInfo.add(\"UG_heterozygosity=\" + UAC.heterozygosity);\n        headerInfo.add(\"UG_genotype_mode=\" + UAC.GENOTYPE);\n        headerInfo.add(\"UG_all_bases_mode=\" + UAC.ALL_BASES);\n        headerInfo.add(\"UG_min_confidence=\" + UAC.CONFIDENCE_THRESHOLD);\n        headerInfo.add(\"UG_max_deletion_fraction=\" + UAC.MAX_DELETION_FRACTION);\n        headerInfo.add(\"UG_max_coverage=\" + UAC.MAX_READS_IN_PILEUP);\n        if ( UAC.POOLSIZE > 0 )\n            headerInfo.add(\"UG_poolSize=\" + UAC.POOLSIZE);\n        if ( UAC.ASSUME_SINGLE_SAMPLE != null )\n            headerInfo.add(\"UG_single_sample=\" + UAC.ASSUME_SINGLE_SAMPLE);\n        if ( UAC.defaultPlatform != null )\n            headerInfo.add(\"UG_default_platform=\" + UAC.defaultPlatform);\n\n        return headerInfo;\n    }","id":30356,"modified_method":"private Set<String> getHeaderInfo() {\n        Set<String> headerInfo = new HashSet<String>();\n\n        // this is only applicable to VCF\n        if ( UAC.VAR_FORMAT != GenotypeWriterFactory.GENOTYPE_FORMAT.VCF )\n            return headerInfo;\n\n        // first, the basic info\n        headerInfo.add(\"source=UnifiedGenotyper\");\n        headerInfo.add(\"reference=\" + getToolkit().getArguments().referenceFile.getName());\n\n        // annotation (INFO) fields from VariantAnnotator\n        if ( UAC.ALL_ANNOTATIONS )\n            headerInfo.addAll(VariantAnnotator.getAllVCFAnnotationDescriptions());\n        else\n            headerInfo.addAll(VariantAnnotator.getVCFAnnotationDescriptions());\n\n        // annotation (INFO) fields from UnifiedGenotyper\n        headerInfo.add(\"INFO=AF,1,Float,\\\"Allele Frequency\\\"\");\n        headerInfo.add(\"INFO=NS,1,Integer,\\\"Number of Samples With Data\\\"\");\n        if ( !UAC.NO_SLOD )\n            headerInfo.add(\"INFO=SB,1,Float,\\\"Strand Bias\\\"\");\n\n        // FORMAT fields if not in POOLED mode\n        if ( UAC.genotypeModel != GenotypeCalculationModel.Model.POOLED )\n            headerInfo.addAll(VCFGenotypeRecord.getSupportedHeaderStrings());\n\n        // all of the arguments from the argument collection\n        Field[] fields = UAC.getClass().getFields();\n        for ( Field field: fields ) {\n            ArgumentTypeDescriptor atd = ArgumentTypeDescriptor.create(field.getType());\n            List<ArgumentDefinition> adList = atd.createArgumentDefinitions(new ArgumentSource(field.getType(), field));\n            for ( ArgumentDefinition ad : adList )\n                headerInfo.add(\"UG_\" + ad.fullName + \"=\" + JVMUtils.getFieldValue(field, UAC));\n        }\n\n        return headerInfo;\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testGenotypeModeJoint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -genotype -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -varout %s -L 1:10,000,000-10,001,000 -bm empirical -gm JOINT_ESTIMATE -confidence 70\", 1,\n                Arrays.asList(\"6971e0bfa524c0e006b3c3ccef52520a\"));\n        executeTest(\"testGenotypeMode - Joint Estimate\", spec);\n    }","id":30357,"modified_method":"@Test\n    public void testGenotypeModeJoint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -genotype -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -varout %s -L 1:10,000,000-10,001,000 -bm empirical -gm JOINT_ESTIMATE -confidence 70\", 1,\n                Arrays.asList(\"1ac9c9c8be0eb6adee7c67fac7c19c0d\"));\n        executeTest(\"testGenotypeMode - Joint Estimate\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testPooled1() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/low_coverage_CEU.chr1.10k-11k.bam -varout %s -L 1:10,023,000-10,024,000 -bm empirical -gm POOLED -ps 60 -confidence 30\", 1,\n                Arrays.asList(\"d7579207d2521f36648b2b43be805bc4\"));\n        executeTest(\"testPooled1\", spec);\n    }","id":30358,"modified_method":"@Test\n    public void testPooled1() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/low_coverage_CEU.chr1.10k-11k.bam -varout %s -L 1:10,023,000-10,024,000 -bm empirical -gm POOLED -ps 60 -confidence 30\", 1,\n                Arrays.asList(\"4890ce37667379a0b60892cb0b9d8e09\"));\n        executeTest(\"testPooled1\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultiSamplePilot2Joint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/pilot2_daughters.chr20.10k-11k.bam -varout %s -L 20:10,000,000-10,050,000 -bm empirical -gm JOINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"58422eb06214282fc6e9efbf52937e1e\"));\n        executeTest(\"testMultiSamplePilot2 - Joint Estimate\", spec);\n    }","id":30359,"modified_method":"@Test\n    public void testMultiSamplePilot2Joint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/pilot2_daughters.chr20.10k-11k.bam -varout %s -L 20:10,000,000-10,050,000 -bm empirical -gm JOINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"58ddc9426a25d0c3604af8da4eaa8294\"));\n        executeTest(\"testMultiSamplePilot2 - Joint Estimate\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultiSamplePilot2PointEM() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/pilot2_daughters.chr20.10k-11k.bam -varout %s -L 20:10,000,000-10,010,000 -bm empirical -gm EM_POINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"e03b5ac5821dc0e0da3cc8a1f686ec6b\"));\n        executeTest(\"testMultiSamplePilot2 - Point Estimate EM\", spec);\n    }","id":30360,"modified_method":"@Test\n    public void testMultiSamplePilot2PointEM() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/pilot2_daughters.chr20.10k-11k.bam -varout %s -L 20:10,000,000-10,010,000 -bm empirical -gm EM_POINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"65a808f077447f89e001e1cce8433acc\"));\n        executeTest(\"testMultiSamplePilot2 - Point Estimate EM\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testSingleSamplePilot2Joint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -varout %s -L 1:10,000,000-10,100,000 -bm empirical -gm JOINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"27fadaf914ad7fbc83d4f8367f43bc40\"));\n        executeTest(\"testSingleSamplePilot2 - Joint Estimate\", spec);\n    }","id":30361,"modified_method":"@Test\n    public void testSingleSamplePilot2Joint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -varout %s -L 1:10,000,000-10,100,000 -bm empirical -gm JOINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"52e7030fe0968cd1a9b95154d8056b3f\"));\n        executeTest(\"testSingleSamplePilot2 - Joint Estimate\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultiSamplePilot1PointEM() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/low_coverage_CEU.chr1.10k-11k.bam -varout %s -L 1:10,023,400-10,024,000 -bm empirical -gm EM_POINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"c7aec953aac01101f0556db166178590\"));\n        executeTest(\"testMultiSamplePilot1 - Point Estimate EM\", spec);\n    }","id":30362,"modified_method":"@Test\n    public void testMultiSamplePilot1PointEM() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/low_coverage_CEU.chr1.10k-11k.bam -varout %s -L 1:10,023,400-10,024,000 -bm empirical -gm EM_POINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"12d07018d9604b86b854e0c9132b0608\"));\n        executeTest(\"testMultiSamplePilot1 - Point Estimate EM\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testAllBasesModeJoint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -all_bases -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -varout %s -L 1:10,000,000-10,001,000 -bm empirical -gm JOINT_ESTIMATE -confidence 70\", 1,\n                Arrays.asList(\"9f54482c1594bdd1e28b4cf2e51f944f\"));\n        executeTest(\"testAllBasesMode - Joint Estimate\", spec);\n    }","id":30363,"modified_method":"@Test\n    public void testAllBasesModeJoint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -all_bases -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.SLX.bam -varout %s -L 1:10,000,000-10,001,000 -bm empirical -gm JOINT_ESTIMATE -confidence 70\", 1,\n                Arrays.asList(\"37177e194a602749d31e5ecbf80ad309\"));\n        executeTest(\"testAllBasesMode - Joint Estimate\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultiSamplePilot1Joint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/low_coverage_CEU.chr1.10k-11k.bam -varout %s -L 1:10,022,000-10,025,000 -bm empirical -gm JOINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"d1076029884939017817061cfd06d8ff\"));\n        executeTest(\"testMultiSamplePilot1 - Joint Estimate\", spec);\n    }","id":30364,"modified_method":"@Test\n    public void testMultiSamplePilot1Joint() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T UnifiedGenotyper -R /broad/1KG/reference/human_b36_both.fasta -I /humgen/gsa-scr1/GATK_Data/Validation_Data/low_coverage_CEU.chr1.10k-11k.bam -varout %s -L 1:10,022,000-10,025,000 -bm empirical -gm JOINT_ESTIMATE -confidence 30\", 1,\n                Arrays.asList(\"fd5291c7115a558a7a6309ab417d2d57\"));\n        executeTest(\"testMultiSamplePilot1 - Joint Estimate\", spec);\n    }","commit_id":"f7c44ad01916666a8f18717f2362ea57df2341fe","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n   * check that measure has a value (numerical or string) and a metric key\n   */\n  public static void checkMeasure(BatchReport.Measure measure) {\n    if (!measure.hasValueType() || !measure.hasMetricKey()) {\n      throw newIllegalStateException(measure);\n    }\n\n    boolean hasValueOrData = false;\n    switch (measure.getValueType()) {\n      case DOUBLE:\n        hasValueOrData = measure.hasDoubleValue();\n        break;\n      case INT:\n        hasValueOrData = measure.hasIntValue();\n        break;\n      case LONG:\n        hasValueOrData = measure.hasLongValue();\n        break;\n      case STRING:\n        hasValueOrData = measure.hasStringValue();\n        break;\n      case BOOLEAN:\n        hasValueOrData = measure.hasBooleanValue();\n        break;\n    }\n\n    if (!hasValueOrData) {\n      throw newIllegalStateException(measure);\n    }\n  }","id":30365,"modified_method":"/**\n   * check that measure has a value (numerical or string) and a metric key\n   */\n  public static void checkMeasure(BatchReport.Measure measure) {\n    if (!hasValueTypeAndMetricKey(measure)) {\n      throw newIllegalStateException(measure);\n    }\n\n    boolean hasValueOrData;\n    switch (measure.getValueType()) {\n      case DOUBLE:\n        hasValueOrData = measure.hasDoubleValue();\n        break;\n      case INT:\n        hasValueOrData = measure.hasIntValue();\n        break;\n      case LONG:\n        hasValueOrData = measure.hasLongValue();\n        break;\n      case STRING:\n        hasValueOrData = measure.hasStringValue();\n        break;\n      case BOOLEAN:\n        hasValueOrData = measure.hasBooleanValue();\n        break;\n      default:\n        throw newIllegalStateException(measure);\n    }\n\n    if (!hasValueOrData) {\n      throw newIllegalStateException(measure);\n    }\n  }","commit_id":"cbc7731b65c448bef785addcbf5e40a2991cdfc6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  MeasureDto toMeasureDto(BatchReport.Measure in, BatchReport.Component component) {\n    checkMeasure(in);\n\n    MeasureDto out = new MeasureDto()\n      .setTendency(in.hasTendency() ? in.getTendency() : null)\n      .setVariation(1, in.hasVariationValue1() ? in.getVariationValue1() : null)\n      .setVariation(2, in.hasVariationValue2() ? in.getVariationValue2() : null)\n      .setVariation(3, in.hasVariationValue3() ? in.getVariationValue3() : null)\n      .setVariation(4, in.hasVariationValue4() ? in.getVariationValue4() : null)\n      .setVariation(5, in.hasVariationValue5() ? in.getVariationValue5() : null)\n      .setAlertStatus(in.hasAlertStatus() ? in.getAlertStatus() : null)\n      .setAlertText(in.hasAlertText() ? in.getAlertText() : null)\n      .setDescription(in.hasDescription() ? in.getDescription() : null)\n      .setSeverity(in.hasSeverity() ? in.getSeverity().name() : null)\n      .setComponentId(component.getId())\n      .setSnapshotId(component.getSnapshotId())\n      .setMetricId(metricCache.get(in.getMetricKey()).getId())\n      .setRuleId(ruleCache.get(RuleKey.parse(in.getRuleKey())).getId())\n      .setCharacteristicId(in.hasCharactericId() ? in.getCharactericId() : null);\n    out.setValue(valueAsDouble(in));\n    out.setData(in.hasStringValue() ? in.getStringValue() : null);\n    return out;\n  }","id":30366,"modified_method":"@VisibleForTesting\n  MeasureDto toMeasureDto(BatchReport.Measure in, BatchReport.Component component) {\n    checkMeasure(in);\n\n    MeasureDto out = new MeasureDto();\n    out.setTendency(in.hasTendency() ? in.getTendency() : null);\n    out.setVariation(1, in.hasVariationValue1() ? in.getVariationValue1() : null);\n    out.setVariation(2, in.hasVariationValue2() ? in.getVariationValue2() : null);\n    out.setVariation(3, in.hasVariationValue3() ? in.getVariationValue3() : null);\n    out.setVariation(4, in.hasVariationValue4() ? in.getVariationValue4() : null);\n    out.setVariation(5, in.hasVariationValue5() ? in.getVariationValue5() : null);\n    out.setAlertStatus(in.hasAlertStatus() ? in.getAlertStatus() : null);\n    out.setAlertText(in.hasAlertText() ? in.getAlertText() : null);\n    out.setDescription(in.hasDescription() ? in.getDescription() : null);\n    out.setSeverity(in.hasSeverity() ? in.getSeverity().name() : null);\n    out.setComponentId(component.getId());\n    out.setSnapshotId(component.getSnapshotId());\n    out.setMetricId(metricCache.get(in.getMetricKey()).getId());\n    out.setRuleId(ruleCache.get(RuleKey.parse(in.getRuleKey())).getId());\n    out.setCharacteristicId(in.hasCharactericId() ? in.getCharactericId() : null);\n    out.setValue(valueAsDouble(in));\n    setData(in, out);\n    return out;\n  }","commit_id":"cbc7731b65c448bef785addcbf5e40a2991cdfc6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public GitBranch getCurrent() {\n    return myCollection.getCurrentBranch();\n  }","id":30367,"modified_method":"@Override\n  public GitBranch getCurrent() {\n    return myCurrentBranch;\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getCurrentName() {\n    GitBranch branch = myCollection.getCurrentBranch();\n    return branch == null ? null : branch.getName();\n  }","id":30368,"modified_method":"@Override\n  public String getCurrentName() {\n    return myCurrentBranch == null ? null : myCurrentBranch.getName();\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GitBranchesCollection(@Nullable GitBranch currentBranch, @NotNull Collection<GitBranch> localBranches, @NotNull Collection<GitBranch> remoteBranches) {\n    myCurrentBranch = currentBranch;\n    myRemoteBranches = remoteBranches;\n    myLocalBranches = localBranches;\n  }","id":30369,"modified_method":"public GitBranchesCollection(@NotNull Collection<GitBranch> localBranches, @NotNull Collection<GitBranch> remoteBranches) {\n    myRemoteBranches = remoteBranches;\n    myLocalBranches = localBranches;\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Copy constructor. Sets inside are also copied.\n   */\n  public GitBranchesCollection(@NotNull GitBranchesCollection branches) {\n    this(branches.getCurrentBranch(), branches.getLocalBranches(), branches.getRemoteBranches());\n  }","id":30370,"modified_method":"/**\n   * Copy constructor. Sets inside are also copied.\n   */\n  public GitBranchesCollection(@NotNull GitBranchesCollection branches) {\n    this(branches.getLocalBranches(), branches.getRemoteBranches());\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return all branches in this repository. local/remote/active information is stored in branch objects themselves. \n   */\n  GitBranchesCollection readBranches() {\n    Set<GitBranch> localBranches = readUnpackedLocalBranches();\n    Set<GitBranch> remoteBranches = readUnpackedRemoteBranches();\n    GitBranchesCollection packedBranches = readPackedBranches();\n    localBranches.addAll(packedBranches.getLocalBranches());\n    remoteBranches.addAll(packedBranches.getRemoteBranches());\n    \n    // note that even the active branch may be packed. So at first we collect branches, then we find the active.\n    GitBranch currentBranch = readCurrentBranch();\n    markActiveBranch(localBranches, currentBranch);\n\n    return new GitBranchesCollection(currentBranch, localBranches, remoteBranches);\n  }","id":30371,"modified_method":"/**\n   * @return all branches in this repository. local/remote/active information is stored in branch objects themselves. \n   */\n  GitBranchesCollection readBranches() {\n    Set<GitBranch> localBranches = readUnpackedLocalBranches();\n    Set<GitBranch> remoteBranches = readUnpackedRemoteBranches();\n    GitBranchesCollection packedBranches = readPackedBranches();\n    localBranches.addAll(packedBranches.getLocalBranches());\n    remoteBranches.addAll(packedBranches.getRemoteBranches());\n    \n    // note that even the active branch may be packed. So at first we collect branches, then we find the active.\n    GitBranch currentBranch = readCurrentBranch();\n    markActiveBranch(localBranches, currentBranch);\n\n    return new GitBranchesCollection(localBranches, remoteBranches);\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return list of local and remote branches from packed-refs. Active branch is not marked as active.\n   */\n  @NotNull\n  private GitBranchesCollection readPackedBranches() {\n    final Set<GitBranch> localBranches = new HashSet<GitBranch>();\n    final Set<GitBranch> remoteBranches = new HashSet<GitBranch>();\n    if (!myPackedRefsFile.exists()) {\n      return GitBranchesCollection.EMPTY;\n    }\n    final String content = tryLoadFile(myPackedRefsFile, calcEncoding(myPackedRefsFile));\n    \n    for (String line : content.split(\"\\n\")) {\n      parsePackedRefsLine(line, new PackedRefsLineResultHandler() {\n        @Override public void handleResult(@Nullable String hash, @Nullable String branchName) {\n          if (hash == null || branchName == null) {\n            return;\n          }\n          if (branchName.startsWith(REFS_HEADS_PREFIX)) {\n            localBranches.add(new GitBranch(branchName.substring(REFS_HEADS_PREFIX.length()), hash, false, false));\n          } else if (branchName.startsWith(REFS_REMOTES_PREFIX)) {\n            remoteBranches.add(new GitBranch(branchName.substring(REFS_REMOTES_PREFIX.length()), hash, false, true));\n          }\n        }\n      });\n    }\n    return new GitBranchesCollection(null, localBranches, remoteBranches);\n  }","id":30372,"modified_method":"/**\n   * @return list of local and remote branches from packed-refs. Active branch is not marked as active.\n   */\n  @NotNull\n  private GitBranchesCollection readPackedBranches() {\n    final Set<GitBranch> localBranches = new HashSet<GitBranch>();\n    final Set<GitBranch> remoteBranches = new HashSet<GitBranch>();\n    if (!myPackedRefsFile.exists()) {\n      return GitBranchesCollection.EMPTY;\n    }\n    final String content = tryLoadFile(myPackedRefsFile, calcEncoding(myPackedRefsFile));\n    \n    for (String line : content.split(\"\\n\")) {\n      parsePackedRefsLine(line, new PackedRefsLineResultHandler() {\n        @Override public void handleResult(@Nullable String hash, @Nullable String branchName) {\n          if (hash == null || branchName == null) {\n            return;\n          }\n          if (branchName.startsWith(REFS_HEADS_PREFIX)) {\n            localBranches.add(new GitBranch(branchName.substring(REFS_HEADS_PREFIX.length()), hash, false, false));\n          } else if (branchName.startsWith(REFS_REMOTES_PREFIX)) {\n            remoteBranches.add(new GitBranch(branchName.substring(REFS_REMOTES_PREFIX.length()), hash, false, true));\n          }\n        }\n      });\n    }\n    return new GitBranchesCollection(localBranches, remoteBranches);\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testBranches(){\n    GitBranchesCollection branchesCollection = myRepositoryReader.readBranches();\n    GitBranch currentBranch = branchesCollection.getCurrentBranch();\n    Collection<GitBranch> localBranches = branchesCollection.getLocalBranches();\n    Collection<GitBranch> remoteBranches = branchesCollection.getRemoteBranches();\n    \n    assertBranch(currentBranch, new GitTestBranch(\"master\", \"0e1d130689bc52f140c5c374aa9cc2b8916c0ad7\"));\n    assertBranches(localBranches, myLocalBranches);\n    assertBranches(remoteBranches, myRemoteBranches);\n  }","id":30373,"modified_method":"public void testBranches(){\n    GitBranchesCollection branchesCollection = myRepositoryReader.readBranches();\n    GitBranch currentBranch = myRepositoryReader.readCurrentBranch();\n    Collection<GitBranch> localBranches = branchesCollection.getLocalBranches();\n    Collection<GitBranch> remoteBranches = branchesCollection.getRemoteBranches();\n    \n    assertBranch(currentBranch, new GitTestBranch(\"master\", \"0e1d130689bc52f140c5c374aa9cc2b8916c0ad7\"));\n    assertBranches(localBranches, myLocalBranches);\n    assertBranches(remoteBranches, myRemoteBranches);\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CachedRefs getRefs() throws VcsException {\n    final CachedRefs refs = new CachedRefs();\n    final GitRepository repositoryForRoot = GitUtil.getRepositoryManager(myProject).getRepositoryForRoot(myRoot);\n    final GitBranchesCollection branches;\n    if (repositoryForRoot != null) {\n      branches = repositoryForRoot.getBranches();\n    } else {\n      final File child = new File(myRoot.getPath(), \".git\");\n      if (! child.exists()) {\n        throw new VcsException(\"No git repository in \" + myRoot.getPath());\n      }\n      GitRepository repository = GitRepository.getLightInstance(myRoot, myProject, myProject);\n      repository.getBranches();\n      branches = repository.getBranches();\n    }\n    refs.setCollection(branches);\n    final GitBranch current = branches.getCurrentBranch();\n    if (current != null) {\n      GitBranch tracked = current.tracked(myProject, myRoot);\n      String fullName = tracked == null ? null : tracked.getFullName();\n      fullName = fullName != null && fullName.startsWith(GitBranch.REFS_REMOTES_PREFIX) ? fullName.substring(GitBranch.REFS_REMOTES_PREFIX.length()) : fullName;\n      refs.setTrackedRemoteName(fullName);\n    }\n    refs.setUsername(GitConfigUtil.getValue(myProject, myRoot, GitConfigUtil.USER_NAME));\n    final VcsRevisionNumber head = GitHistoryUtils.getCurrentRevision(myProject, new FilePathImpl(myRoot), \"HEAD\", true);\n    refs.setHeadHash(AbstractHash.create(head.asString()));\n    return refs;\n  }","id":30374,"modified_method":"public CachedRefs getRefs() throws VcsException {\n    final CachedRefs refs = new CachedRefs();\n    GitRepository repository = GitUtil.getRepositoryManager(myProject).getRepositoryForRoot(myRoot);\n    if (repository == null) {\n      final File child = new File(myRoot.getPath(), \".git\");\n      if (! child.exists()) {\n        throw new VcsException(\"No git repository in \" + myRoot.getPath());\n      }\n      repository = GitRepository.getLightInstance(myRoot, myProject, myProject);\n      repository.getBranches();\n    }\n    GitBranchesCollection branches = repository.getBranches();\n    refs.setCollection(branches);\n    final GitBranch current = repository.getCurrentBranch();\n    refs.setCurrentBranch(current);\n    if (current != null) {\n      GitBranch tracked = current.tracked(myProject, myRoot);\n      String fullName = tracked == null ? null : tracked.getFullName();\n      fullName = fullName != null && fullName.startsWith(GitBranch.REFS_REMOTES_PREFIX) ? fullName.substring(GitBranch.REFS_REMOTES_PREFIX.length()) : fullName;\n      refs.setTrackedRemoteName(fullName);\n    }\n    refs.setUsername(GitConfigUtil.getValue(myProject, myRoot, GitConfigUtil.USER_NAME));\n    final VcsRevisionNumber head = GitHistoryUtils.getCurrentRevision(myProject, new FilePathImpl(myRoot), \"HEAD\", true);\n    refs.setHeadHash(AbstractHash.create(head.asString()));\n    return refs;\n  }","commit_id":"dde1f42a7ab24b2ead2f949b3bea3856ec9ce345","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean noBranchesToCompare(@NotNull HgRepository repository) {\n    final Map<String, Set<Hash>> branches = repository.getBranches();\n    assert !branches.isEmpty();\n    String currentRevision = repository.getCurrentRevision();\n    assert currentRevision != null : \"Compare With Branch couldn't be performed for newly created repository\";\n    if (branches.keySet().size() > 1) return false;\n    String branchName = branches.keySet().iterator().next();\n    return branches.get(branchName).contains(HashImpl.build(repository.getCurrentRevision()));\n  }","id":30375,"modified_method":"@Override\n  protected boolean noBranchesToCompare(@NotNull HgRepository repository) {\n    final Map<String, LinkedHashSet<Hash>> branches = repository.getBranches();\n    if (branches.size() > 1) return false;\n    final Hash currentRevisionHash = getCurrentHash(repository);\n    final Collection<HgNameWithHashInfo> other_bookmarks = getOtherBookmarks(repository, currentRevisionHash);\n    if (!other_bookmarks.isEmpty()) return false;\n    // if only one heavy branch and no other bookmarks -> check that current revision is no \"main\" branch head\n    return getBranchMainHash(repository, repository.getCurrentBranch()).equals(currentRevisionHash);\n  }","commit_id":"5da7ca52e1fdbff6980b4966e2358cbafbe6fbca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected List<String> getBranchNamesExceptCurrent(@NotNull HgRepository repository) {\n    final Map<String, Set<Hash>> branches = repository.getBranches();\n    return new ArrayList<String>(branches.keySet());\n  }","id":30376,"modified_method":"@NotNull\n  @Override\n  protected List<String> getBranchNamesExceptCurrent(@NotNull HgRepository repository) {\n    final List<String> namesToCompare = new ArrayList<String>(repository.getBranches().keySet());\n    final String currentBranchName = repository.getCurrentBranchName();\n    assert currentBranchName != null;\n    Hash currentBranchHash = getBranchMainHash(repository, currentBranchName);\n    if (currentBranchHash.equals(getCurrentHash(repository))) {\n      namesToCompare.remove(currentBranchName);\n    }\n    namesToCompare.addAll(HgUtil.getNamesWithoutHashes(getOtherBookmarks(repository, currentBranchHash)));\n    return namesToCompare;\n  }","commit_id":"5da7ca52e1fdbff6980b4966e2358cbafbe6fbca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void showDiffWithBranch(@NotNull Project project,\n                                    @NotNull VirtualFile file,\n                                    @NotNull String head,\n                                    @NotNull String branchToCompare) throws VcsException {\n    HgRepository repository = getRepositoryManager(project).getRepositoryForFile(file);\n    if (repository == null) {\n      LOG.error(\"Couldn't find repository for \" + file.getName());\n      return;\n    }\n    final HgVcs hgVcs = HgVcs.getInstance(project);\n    assert hgVcs != null;\n    final HgVersion version = hgVcs.getVersion();\n    String[] templates = HgBaseLogParser.constructFullTemplateArgument(true, version);\n    final VirtualFile repositoryRoot = repository.getRoot();\n    HgCommandResult result = HgHistoryUtil\n      .getLogResult(project, repositoryRoot, version, 1, Arrays.asList(\"-r\", branchToCompare), HgChangesetUtil.makeTemplate(templates));\n    List<HgFileRevision> hgRevisions = HgHistoryUtil\n      .getCommitRecords(project, result,\n                        new HgFileRevisionLogParser(project, HgHistoryUtil.getOriginalHgFile(project, repositoryRoot), version), true);\n    if (hgRevisions.isEmpty()) {\n      fileDoesntExistInBranchError(project, file, branchToCompare);\n      return;\n    }\n    CurrentRevision currentRevision = new CurrentRevision(file, HgRevisionNumber.getInstance(\"\", head));\n    new HgDiffFromHistoryHandler(project).showDiffForTwo(project, VcsUtil.getFilePath(file), hgRevisions.get(0), currentRevision);\n  }","id":30377,"modified_method":"@Override\n  protected void showDiffWithBranch(@NotNull Project project,\n                                    @NotNull VirtualFile file,\n                                    @NotNull String head,\n                                    @NotNull String branchToCompare) throws VcsException {\n    HgRepository repository = getRepositoryManager(project).getRepositoryForFile(file);\n    if (repository == null) {\n      LOG.error(\"Couldn't find repository for \" + file.getName());\n      return;\n    }\n    final FilePath filePath = VcsUtil.getFilePath(file);\n    final HgVcs hgVcs = HgVcs.getInstance(project);\n    assert hgVcs != null;\n    final HgVersion version = hgVcs.getVersion();\n    String[] templates = HgBaseLogParser.constructFullTemplateArgument(true, version);\n    final VirtualFile repositoryRoot = repository.getRoot();\n    HgCommandResult result = HgHistoryUtil\n      .getLogResult(project, repositoryRoot, version, 1, Arrays.asList(\"-r\", branchToCompare), HgChangesetUtil.makeTemplate(templates));\n    FilePath originalFileName = HgUtil.getOriginalFileName(filePath, ChangeListManager.getInstance(project));\n    final HgFile hgFile = new HgFile(repositoryRoot, originalFileName);\n    List<HgFileRevision> hgRevisions =\n      HgHistoryUtil.getCommitRecords(project, result, new HgFileRevisionLogParser(project, hgFile, version), true);\n    if (hgRevisions.isEmpty()) {\n      fileDoesntExistInBranchError(project, file, branchToCompare);\n      return;\n    }\n    CurrentRevision currentRevision =\n      new CurrentRevision(file, HgRevisionNumber.getInstance(head, ObjectUtils.assertNotNull(repository.getCurrentRevision())));\n    new HgDiffFromHistoryHandler(project).showDiffForTwo(project, filePath, hgRevisions.get(0), currentRevision);\n  }","commit_id":"5da7ca52e1fdbff6980b4966e2358cbafbe6fbca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public Collection<String> getBranches() {\n      return myBranches;\n    }","id":30378,"modified_method":"@NotNull\n    public List<String> getBranches() {\n      return myBranches;\n    }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<String> loadAvailableBranches(@NotNull final Project project,\n                                                    @NotNull final GithubAuthData auth,\n                                                    @NotNull final GithubRepoDetailed repo,\n                                                    @Nullable final GithubFullPath upstreamPath) {\n    List<String> result = new ArrayList<String>();\n    try {\n      final GithubRepo parent = repo.getParent();\n      final GithubRepo source = repo.getSource();\n\n      result.addAll(getBranches(auth, repo.getUserName(), repo.getName()));\n\n      if (parent != null) {\n        result.addAll(getBranches(auth, parent.getUserName(), parent.getName()));\n      }\n\n      if (source != null && !equals(source, parent)) {\n        result.addAll(getBranches(auth, source.getUserName(), source.getName()));\n      }\n\n      if (upstreamPath != null && !equals(upstreamPath, repo) && !equals(upstreamPath, parent) && !equals(upstreamPath, source)) {\n        result.addAll(getBranches(auth, upstreamPath.getUser(), upstreamPath.getRepository()));\n      }\n    }\n    catch (IOException e) {\n      GithubNotifications.showError(project, \"Can't load available branches\", e);\n    }\n    return result;\n  }","id":30379,"modified_method":"private static List<String> loadAvailableBranches(@NotNull final Project project,\n                                                    @NotNull final GithubAuthData auth,\n                                                    @NotNull final GithubRepoDetailed repo,\n                                                    @Nullable final GithubFullPath upstreamPath) {\n    List<String> result = new ArrayList<String>();\n    try {\n      final GithubRepo parent = repo.getParent();\n      final GithubRepo source = repo.getSource();\n\n      if (parent != null) {\n        result.addAll(getBranches(auth, parent.getUserName(), parent.getName()));\n      }\n\n      result.addAll(getBranches(auth, repo.getUserName(), repo.getName()));\n\n      if (source != null && !equals(source, parent)) {\n        result.addAll(getBranches(auth, source.getUserName(), source.getName()));\n      }\n\n      if (upstreamPath != null && !equals(upstreamPath, repo) && !equals(upstreamPath, parent) && !equals(upstreamPath, source)) {\n        result.addAll(getBranches(auth, upstreamPath.getUser(), upstreamPath.getRepository()));\n      }\n    }\n    catch (IOException e) {\n      GithubNotifications.showError(project, \"Can't load available branches\", e);\n    }\n    return result;\n  }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void createPullRequest(@NotNull final Project project, @Nullable final VirtualFile file) {\n    final Git git = ServiceManager.getService(Git.class);\n\n    final GitRepository repository = GithubUtil.getGitRepository(project, file);\n    if (repository == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Can't find git repository\");\n      return;\n    }\n\n    final Pair<GitRemote, String> remote = GithubUtil.findGithubRemote(repository);\n    if (remote == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Can't find GitHub remote\");\n      return;\n    }\n    final String remoteUrl = remote.getSecond();\n    final String remoteName = remote.getFirst().getName();\n    String upstreamUrl = GithubUtil.findUpstreamRemote(repository);\n    final GithubFullPath upstreamUserAndRepo =\n      upstreamUrl == null || !GithubUrlUtil.isGithubUrl(upstreamUrl) ? null : GithubUrlUtil.getUserAndRepositoryFromRemoteUrl(upstreamUrl);\n\n    final GithubFullPath userAndRepo = GithubUrlUtil.getUserAndRepositoryFromRemoteUrl(remoteUrl);\n    if (userAndRepo == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Can't process remote: \" + remoteUrl);\n      return;\n    }\n\n    final GitLocalBranch currentBranch = repository.getCurrentBranch();\n    if (currentBranch == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"No current branch\");\n      return;\n    }\n\n    final GithubInfo info = loadGithubInfoWithModal(project, userAndRepo, upstreamUserAndRepo);\n    if (info == null) {\n      return;\n    }\n\n    final GithubCreatePullRequestDialog dialog = new GithubCreatePullRequestDialog(project);\n    dialog.addBranches(info.getBranches());\n    DialogManager.show(dialog);\n    if (!dialog.isOK()) {\n      return;\n    }\n\n    new Task.Backgroundable(project, \"Creating pull request...\") {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        LOG.info(\"Pushing current branch\");\n        indicator.setText(\"Pushing current branch...\");\n        GitCommandResult result = git.push(repository, remoteName, remoteUrl, currentBranch.getName(), true);\n        if (!result.success()) {\n          GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Push failed:<br/>\" + result.getErrorOutputAsHtmlString());\n          return;\n        }\n\n        LOG.info(\"Performing create request\");\n        indicator.setText(\"Performing create request...\");\n        GithubPullRequest request = createPullRequest(project, info, dialog, currentBranch.getName(), upstreamUserAndRepo);\n        if (request == null) {\n          return;\n        }\n\n        GithubNotifications\n          .showInfoURL(project, \"Successfully created pull request\", \"Pull Request #\" + request.getNumber(), request.getHtmlUrl());\n      }\n    }.queue();\n  }","id":30380,"modified_method":"static void createPullRequest(@NotNull final Project project, @Nullable final VirtualFile file) {\n    final Git git = ServiceManager.getService(Git.class);\n\n    final GitRepository repository = GithubUtil.getGitRepository(project, file);\n    if (repository == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Can't find git repository\");\n      return;\n    }\n\n    final Pair<GitRemote, String> remote = GithubUtil.findGithubRemote(repository);\n    if (remote == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Can't find GitHub remote\");\n      return;\n    }\n    final String remoteUrl = remote.getSecond();\n    final String remoteName = remote.getFirst().getName();\n    String upstreamUrl = GithubUtil.findUpstreamRemote(repository);\n    final GithubFullPath upstreamUserAndRepo =\n      upstreamUrl == null || !GithubUrlUtil.isGithubUrl(upstreamUrl) ? null : GithubUrlUtil.getUserAndRepositoryFromRemoteUrl(upstreamUrl);\n\n    final GithubFullPath userAndRepo = GithubUrlUtil.getUserAndRepositoryFromRemoteUrl(remoteUrl);\n    if (userAndRepo == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Can't process remote: \" + remoteUrl);\n      return;\n    }\n\n    final GitLocalBranch currentBranch = repository.getCurrentBranch();\n    if (currentBranch == null) {\n      GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"No current branch\");\n      return;\n    }\n\n    final GithubInfo info = loadGithubInfoWithModal(project, userAndRepo, upstreamUserAndRepo);\n    if (info == null) {\n      return;\n    }\n\n    String suggestedBranch = info.getRepo().getParent() == null ? null : info.getRepo().getParent().getUserName() + \":master\";\n    final GithubCreatePullRequestDialog dialog = new GithubCreatePullRequestDialog(project, info.getBranches(), suggestedBranch);\n    DialogManager.show(dialog);\n    if (!dialog.isOK()) {\n      return;\n    }\n\n    new Task.Backgroundable(project, \"Creating pull request...\") {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        LOG.info(\"Pushing current branch\");\n        indicator.setText(\"Pushing current branch...\");\n        GitCommandResult result = git.push(repository, remoteName, remoteUrl, currentBranch.getName(), true);\n        if (!result.success()) {\n          GithubNotifications.showError(project, CANNOT_CREATE_PULL_REQUEST, \"Push failed:<br/>\" + result.getErrorOutputAsHtmlString());\n          return;\n        }\n\n        LOG.info(\"Performing create request\");\n        indicator.setText(\"Performing create request...\");\n        GithubPullRequest request = createPullRequest(project, info, dialog, currentBranch.getName(), upstreamUserAndRepo);\n        if (request == null) {\n          return;\n        }\n\n        GithubNotifications\n          .showInfoURL(project, \"Successfully created pull request\", \"Pull Request #\" + request.getNumber(), request.getHtmlUrl());\n      }\n    }.queue();\n  }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GithubInfo(@NotNull GithubAuthData authData, @NotNull GithubRepoDetailed repo, @NotNull Collection<String> branches) {\n      myAuthData = authData;\n      myRepo = repo;\n      myBranches = branches;\n    }","id":30381,"modified_method":"private GithubInfo(@NotNull GithubAuthData authData, @NotNull GithubRepoDetailed repo, @NotNull List<String> branches) {\n      myAuthData = authData;\n      myRepo = repo;\n      myBranches = branches;\n    }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@TestOnly\n  public void setBranch(String branch) {\n    myGithubCreatePullRequestPanel.setBranch(branch);\n  }","id":30382,"modified_method":"@TestOnly\n  public void setBranch(String branch) {\n    myGithubCreatePullRequestPanel.setSelectedBranch(branch);\n  }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GithubCreatePullRequestDialog(@NotNull final Project project) {\n    super(project, true);\n    myGithubCreatePullRequestPanel = new GithubCreatePullRequestPanel();\n\n    myGithubCreatePullRequestPanel.setBranch(GithubSettings.getInstance().getCreatePullRequestDefaultBranch());\n\n    setTitle(\"Create Pull Request\");\n    init();\n  }","id":30383,"modified_method":"public GithubCreatePullRequestDialog(@NotNull final Project project, @NotNull List<String> branches, @Nullable String suggestedBranch) {\n    super(project, true);\n    myGithubCreatePullRequestPanel = new GithubCreatePullRequestPanel();\n\n    myGithubCreatePullRequestPanel.setBranches(branches);\n\n    String configBranch = GithubSettings.getInstance().getCreatePullRequestDefaultBranch();\n    myGithubCreatePullRequestPanel.setSelectedBranch(configBranch != null ? configBranch : suggestedBranch);\n\n    setTitle(\"Create Pull Request\");\n    init();\n  }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addBranches(@NotNull Collection<String> branches) {\n    HashSet<Object> set = new HashSet<Object>(branches);\n    for (int i = 0; i < myBranchComboBox.getItemCount(); i++) {\n      set.remove(myBranchComboBox.getItemAt(i));\n    }\n    for (Object element : set) {\n      myBranchComboBox.addItem(element);\n    }\n  }","id":30384,"modified_method":"public void setBranches(@NotNull Collection<String> branches) {\n    myBranchModel.clear();\n    myBranchModel.addAll(branches);\n  }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GithubCreatePullRequestPanel() {\n    myDescriptionTextArea.setBorder(BorderFactory.createEtchedBorder());\n  }","id":30385,"modified_method":"public GithubCreatePullRequestPanel() {\n    myDescriptionTextArea.setBorder(BorderFactory.createEtchedBorder());\n    myBranchModel = new SortedComboBoxModel<String>(new Comparator<String>() {\n      @Override\n      public int compare(String o1, String o2) {\n        return StringUtil.naturalCompare(o1, o2);\n      }\n    });\n    myBranchComboBox.setModel(myBranchModel);\n  }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setBranch(@NotNull String branch) {\n    if (StringUtil.isEmptyOrSpaces(branch)) {\n      return;\n    }\n    for (int i = 0; i < myBranchComboBox.getItemCount(); i++) {\n      Object element = myBranchComboBox.getItemAt(i);\n      if (branch.equals(element)) {\n        myBranchComboBox.setSelectedItem(element);\n        return;\n      }\n    }\n\n    myBranchComboBox.addItem(branch);\n    myBranchComboBox.setSelectedItem(branch);\n  }","id":30386,"modified_method":"public void setSelectedBranch(@Nullable String branch) {\n    if (StringUtil.isEmptyOrSpaces(branch)) {\n      myBranchComboBox.setSelectedItem(\"\");\n      return;\n    }\n\n    if (myBranchModel.indexOf(branch) == -1) {\n      myBranchModel.add(branch);\n    }\n    myBranchComboBox.setSelectedItem(branch);\n  }","commit_id":"c1bc0d0cee5b0d848de0e128f43bb47604df3042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void onTestStart(TestResultMessage trm) {\n        console.addTestResult(trm);\n    }","id":30387,"modified_method":"public void onTestStart(TestResultMessage trm) {\n        //console.addTestResult(trm);\n    }","commit_id":"06b3cccdb608ac0695190f107b2a7df3f07611e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addTestResult(TestResultMessage result, List<Printable> output, int exceptionMark) {\n\n        // TODO This should be an action button which rebuilds the tree when toggled.\n        boolean flattenPackages = true;\n\n        TestProxy classNode;\n        if (flattenPackages) {\n            classNode = getPackageClassNodeFor(result);\n        } else {\n            classNode = getClassNodeFor(result);\n        }\n        //test started or failed to start\n        if (!started.containsKey(result)) {\n            TestProxy proxy = new TestProxy();\n            started.put(result, proxy);\n            proxy.setParent(classNode);\n            proxy.setResultMessage(result);\n            animator.setCurrentTestCase(proxy);\n            treeBuilder.addItem(classNode, proxy);\n            treeBuilder.repaintWithParents(proxy);\n            count++;\n            if (count > total) total = count;\n            if (TestNGConsoleProperties.TRACK_RUNNING_TEST.value(consoleProperties)) {\n                selectTest(proxy);\n            }\n        }\n        final TestProxy testCase = started.get(result);\n        if (testCase != null) {\n            testCase.setResultMessage(result);\n            testCase.setOutput(output);\n            testCase.setExceptionMark(exceptionMark);\n        }\n\n        if (result.getResult() != MessageHelper.TEST_STARTED) {\n            model.addTestResult(result);\n        }\n\n        if (result.getResult() == MessageHelper.PASSED_TEST) {\n            //passed++;\n        } else if (result.getResult() == MessageHelper.FAILED_TEST) {\n            failed.add(started.get(result));\n            progress.setColor(ColorProgressBar.RED);\n        }\n        progress.setFraction((double) count / total);\n        updateLabel(statusLabel);\n    }","id":30388,"modified_method":"public void addTestResult(TestResultMessage result, List<Printable> output, int exceptionMark) {\n\n        // TODO This should be an action button which rebuilds the tree when toggled.\n        boolean flattenPackages = true;\n\n        TestProxy classNode;\n        if (flattenPackages) {\n            classNode = getPackageClassNodeFor(result);\n        } else {\n            classNode = getClassNodeFor(result);\n        }\n        //test started or failed to start\n        //if (!started.containsKey(result)) {\n            TestProxy proxy = new TestProxy();\n            started.put(result, proxy);\n            proxy.setParent(classNode);\n            proxy.setResultMessage(result);\n            animator.setCurrentTestCase(proxy);\n            treeBuilder.addItem(classNode, proxy);\n            treeBuilder.repaintWithParents(proxy);\n            count++;\n            if (count > total) total = count;\n            if (TestNGConsoleProperties.TRACK_RUNNING_TEST.value(consoleProperties)) {\n                selectTest(proxy);\n            }\n        //}\n        final TestProxy testCase = started.get(result);\n        if (testCase != null) {\n            testCase.setResultMessage(result);\n            testCase.setOutput(output);\n            testCase.setExceptionMark(exceptionMark);\n        }\n\n        if (result.getResult() != MessageHelper.TEST_STARTED) {\n            model.addTestResult(result);\n        }\n\n        if (result.getResult() == MessageHelper.PASSED_TEST) {\n            //passed++;\n        } else if (result.getResult() == MessageHelper.FAILED_TEST) {\n            failed.add(started.get(result));\n            progress.setColor(ColorProgressBar.RED);\n        }\n        progress.setFraction((double) count / total);\n        updateLabel(statusLabel);\n    }","commit_id":"06b3cccdb608ac0695190f107b2a7df3f07611e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addTestResult(TestResultMessage result) {\n      if (testNGResults != null) {\n        int exceptionMark = 0;\n        final String stackTrace = result.getStackTrace();\n        if (stackTrace != null && stackTrace.length() > 10) {\n          //trim useless crud from stacktrace\n          String trimmed = trimStackTrace(stackTrace);\n          List<Printable> printables = getPrintables(result, trimmed);\n          for (Printable printable : printables) {\n            printable.print(console); //enable for root element\n          }\n          synchronized (currentTestOutput) {\n            exceptionMark = currentTestOutput.size();\n            currentTestOutput.addAll(printables);\n          }\n        }\n        testNGResults.addTestResult(result, new ArrayList<Printable>(currentTestOutput), exceptionMark);\n\n        synchronized (currentTestOutput) {\n          currentTestOutput.clear();\n        }\n      }\n    }","id":30389,"modified_method":"public void addTestResult(TestResultMessage result) {\n      if (testNGResults != null) {\n        if (!testNGResults.wasTestStarted(result)) {\n          flushOutput();\n        }\n        int exceptionMark = 0;\n        final String stackTrace = result.getStackTrace();\n        if (stackTrace != null && stackTrace.length() > 10) {\n          //trim useless crud from stacktrace\n          String trimmed = trimStackTrace(stackTrace);\n          List<Printable> printables = getPrintables(result, trimmed);\n          for (Printable printable : printables) {\n            printable.print(console); //enable for root element\n          }\n          synchronized (currentTestOutput) {\n            exceptionMark = currentTestOutput.size();\n            currentTestOutput.addAll(printables);\n          }\n        }\n        testNGResults.addTestResult(result, new ArrayList<Printable>(currentTestOutput), exceptionMark);\n\n        synchronized (currentTestOutput) {\n          currentTestOutput.clear();\n        }\n      }\n    }","commit_id":"03c6958a4d96028a4a7fc0f431cc3d5243762959","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testStarted(TestResultMessage result) {\n      if (testNGResults != null) {\n        synchronized (currentTestOutput) {\n          if (!currentTestOutput.isEmpty()) { //non empty for first test only\n            nonTestOutput.addAll(currentTestOutput);\n            currentTestOutput.clear();\n          }\n        }\n        testNGResults.testStarted(result);\n      }\n    }","id":30390,"modified_method":"public void testStarted(TestResultMessage result) {\n      if (testNGResults != null) {\n        flushOutput();\n        testNGResults.testStarted(result);\n      }\n    }","commit_id":"03c6958a4d96028a4a7fc0f431cc3d5243762959","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void onFinish(SuiteMessage suiteMessage) {\n      final TestNGResults view = console.getResultsView();\n      if (view != null) {\n        view.finish();\n      }\n    }","id":30391,"modified_method":"public void onFinish(SuiteMessage suiteMessage) {\n      console.flush();\n      final TestNGResults view = console.getResultsView();\n      if (view != null) {\n        view.finish();\n      }\n    }","commit_id":"03c6958a4d96028a4a7fc0f431cc3d5243762959","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addTestResult(TestResultMessage result, List<Printable> output, int exceptionMark) {\n        final TestProxy testCase = started.get(result);\n        if (testCase != null) {\n            testCase.setResultMessage(result);\n            testCase.setOutput(output);\n            testCase.setExceptionMark(exceptionMark);\n        }\n\n        model.addTestResult(result);\n\n\n        if (result.getResult() == MessageHelper.PASSED_TEST) {\n            //passed++;\n        } else if (result.getResult() == MessageHelper.FAILED_TEST) {\n            failed.add(started.get(result));\n            progress.setColor(ColorProgressBar.RED);\n        }\n        progress.setFraction((double) count / total);\n        updateLabel(statusLabel);\n    }","id":30392,"modified_method":"public void addTestResult(TestResultMessage result, List<Printable> output, int exceptionMark) {\n        TestProxy testCase = started.get(result);\n        if (testCase != null) {\n          if (failedToStart != null) {\n            output.addAll(failedToStart.getOutput());\n            exceptionMark += failedToStart.getExceptionMark();\n          }\n          testCase.setResultMessage(result);\n          failedToStart = null;\n        } else {\n          failedToStart = new TestProxy(); //do not remember testresultmessage: test hierarchy is not set\n          testCase = failedToStart;\n        }\n\n        testCase.setOutput(output);\n        testCase.setExceptionMark(exceptionMark);\n\n        model.addTestResult(result);\n\n\n        if (result.getResult() == MessageHelper.FAILED_TEST) {\n            failed.add(testCase);\n            progress.setColor(ColorProgressBar.RED);\n        }\n        progress.setFraction((double) count / total);\n        updateLabel(statusLabel);\n    }","commit_id":"03c6958a4d96028a4a7fc0f431cc3d5243762959","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addTestResult(TestResultMessage result) {\n        if (testNGResults != null) {\n            List<Printable> list = null;\n            int exceptionMark = 0;\n            if (result.getResult() == MessageHelper.TEST_STARTED) {\n                mark();\n            } else {\n                String stackTrace = result.getStackTrace();\n                if (stackTrace != null && stackTrace.length() > 10) {\n                    //trim useless crud from stacktrace\n                  exceptionMark = allOutput.size() - mark;\n                  String trimmed = trimStackTrace(stackTrace);\n                  List<Printable> printables = getPrintables(result, trimmed);\n                  synchronized (allOutput) {\n                        allOutput.addAll(printables);\n                    }\n                }\n                list = getPrintablesSinceMark();\n            }\n\n            testNGResults.addTestResult(result, list, exceptionMark);\n        }\n    }","id":30393,"modified_method":"public void addTestResult(TestResultMessage result) {\n        if (testNGResults != null) {\n            List<Printable> list = null;\n            int exceptionMark = 0;\n            if (result.getResult() == MessageHelper.TEST_STARTED) {\n                mark();\n            } else {\n                String stackTrace = result.getStackTrace();\n                if (stackTrace != null && stackTrace.length() > 10) {\n                    //trim useless crud from stacktrace\n                  String trimmed = trimStackTrace(stackTrace);\n                  List<Printable> printables = getPrintables(result, trimmed);\n                  for (Printable printable : printables) {\n                      printable.print(console); //enable for root element\n                  }\n                  synchronized (allOutput) {\n                       exceptionMark = allOutput.size() - mark;\n                       allOutput.addAll(printables);\n                  }\n                }\n                list = getPrintablesSinceMark();\n            }\n\n            testNGResults.addTestResult(result, list, exceptionMark);\n        }\n    }","commit_id":"244eed8e11f4d4277f3d76de3fb8b14e95bd400e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void mark() {\n        mark = allOutput.size();\n    }","id":30394,"modified_method":"public void mark() {\n    synchronized (allOutput) {\n      mark = allOutput.size();\n    }\n  }","commit_id":"244eed8e11f4d4277f3d76de3fb8b14e95bd400e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateLabel(JLabel label) {\n        StringBuffer sb = new StringBuffer();\n        if (end == 0) {\n            sb.append(\"Running: \");\n        } else {\n            sb.append(\"Done: \");\n        }\n        sb.append(count).append(\" of \").append(total);\n        if (failed > 0)\n            sb.append(\"   Failed: \").append(failed).append(' ');\n        if (end != 0) {\n            sb.append(\" (\").append(Formatters.printTime(end - start)).append(\")  \");\n        }\n        label.setText(sb.toString());\n    }","id":30395,"modified_method":"private void updateLabel(JLabel label) {\n        StringBuffer sb = new StringBuffer();\n        if (end == 0) {\n            sb.append(\"Running: \");\n        } else {\n            sb.append(\"Done: \");\n        }\n        sb.append(count).append(\" of \").append(total);\n        if (failed.size() > 0)\n            sb.append(\"   Failed: \").append(failed.size()).append(' ');\n        if (end != 0) {\n            sb.append(\" (\").append(Formatters.printTime(end - start)).append(\")  \");\n        }\n        label.setText(sb.toString());\n    }","commit_id":"244eed8e11f4d4277f3d76de3fb8b14e95bd400e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addTestResult(TestResultMessage result, List<Printable> output, int exceptionMark) {\n\n        // TODO This should be an action button which rebuilds the tree when toggled.\n        boolean flattenPackages = true;\n\n        TestProxy classNode;\n        if (flattenPackages) {\n            classNode = getPackageClassNodeFor(result);\n        } else {\n            classNode = getClassNodeFor(result);\n        }\n        if (result.getResult() == MessageHelper.TEST_STARTED) {\n            TestProxy proxy = new TestProxy();\n            proxy.setParent(classNode);\n            proxy.setResultMessage(result);\n            animator.setCurrentTestCase(proxy);\n            treeBuilder.addItem(classNode, proxy);\n            treeBuilder.repaintWithParents(proxy);\n            count++;\n            if (count > total) total = count;\n            if (TestNGConsoleProperties.TRACK_RUNNING_TEST.value(consoleProperties)) {\n                selectTest(proxy);\n            }\n        } else {\n            model.addTestResult(result);\n            final TestProxy testCase = animator.getCurrentTestCase();\n            if (testCase != null) {\n              testCase.setResultMessage(result);\n            }\n            animator.setCurrentTestCase(null);\n            Object[] children = treeBuilder.getTreeStructure().getChildElements(classNode);\n            for (Object child : children) {\n                TestProxy proxy = (TestProxy) child;\n                if (result.equals(proxy.getResultMessage())) {\n                    proxy.setResultMessage(result);\n                    proxy.setOutput(output);\n                    proxy.setExceptionMark(exceptionMark);\n                    treeBuilder.repaintWithParents(proxy);\n                }\n            }\n        }\n\n        if (result.getResult() == MessageHelper.PASSED_TEST) {\n            //passed++;\n        } else if (result.getResult() == MessageHelper.FAILED_TEST) {\n            failed++;\n            progress.setColor(ColorProgressBar.RED);\n        }\n        progress.setFraction((double) count / total);\n        updateLabel(statusLabel);\n    }","id":30396,"modified_method":"public void addTestResult(TestResultMessage result, List<Printable> output, int exceptionMark) {\n\n        // TODO This should be an action button which rebuilds the tree when toggled.\n        boolean flattenPackages = true;\n\n        TestProxy classNode;\n        if (flattenPackages) {\n            classNode = getPackageClassNodeFor(result);\n        } else {\n            classNode = getClassNodeFor(result);\n        }\n        if (result.getResult() == MessageHelper.TEST_STARTED) {\n            TestProxy proxy = new TestProxy();\n            proxy.setParent(classNode);\n            proxy.setResultMessage(result);\n            animator.setCurrentTestCase(proxy);\n            treeBuilder.addItem(classNode, proxy);\n            treeBuilder.repaintWithParents(proxy);\n            count++;\n            if (count > total) total = count;\n            if (TestNGConsoleProperties.TRACK_RUNNING_TEST.value(consoleProperties)) {\n                selectTest(proxy);\n            }\n        } else {\n            model.addTestResult(result);\n            final TestProxy testCase = animator.getCurrentTestCase();\n            if (testCase != null) {\n              testCase.setResultMessage(result);\n              testCase.setOutput(output);\n              testCase.setExceptionMark(exceptionMark);\n            }\n        }\n\n        if (result.getResult() == MessageHelper.PASSED_TEST) {\n            //passed++;\n        } else if (result.getResult() == MessageHelper.FAILED_TEST) {\n            failed.add(animator.getCurrentTestCase());\n            progress.setColor(ColorProgressBar.RED);\n        }\n        progress.setFraction((double) count / total);\n        updateLabel(statusLabel);\n    }","commit_id":"244eed8e11f4d4277f3d76de3fb8b14e95bd400e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setResultMessage(final TestResultMessage resultMessage) {\n    //if we have a result, then our parent is a class, so we can look up our method\n    //this is a bit fragile as it assumes parent is set first and correctly\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        PsiClass psiClass = (PsiClass)getParent().getPsiElement();\n        PsiMethod[] methods = psiClass.getMethods();\n        for (PsiMethod method : methods) {\n          if (method.getName().equals(resultMessage.getMethod())) {\n            psiElement = method;\n            break;\n          }\n        }\n      }\n    });\n    this.resultMessage = resultMessage;\n    TestProxy current = this;\n    while (current != null) {\n      current.inProgress = resultMessage.getResult() == MessageHelper.TEST_STARTED;\n      current = current.getParent();\n    }\n    this.name = resultMessage.toDisplayString();\n  }","id":30397,"modified_method":"public void setResultMessage(final TestResultMessage resultMessage) {\n    //if we have a result, then our parent is a class, so we can look up our method\n    //this is a bit fragile as it assumes parent is set first and correctly\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        PsiClass psiClass = (PsiClass)getParent().getPsiElement();\n        PsiMethod[] methods = psiClass.getMethods();\n        for (PsiMethod method : methods) {\n          if (method.getName().equals(resultMessage.getMethod())) {\n            psiElement = method;\n            break;\n          }\n        }\n      }\n    });\n\n    TestProxy current = this;\n    while (current != null) {\n      current.inProgress = resultMessage.getResult() == MessageHelper.TEST_STARTED;\n      current = current.getParent();\n    }\n    if (this.resultMessage == null || this.resultMessage.getResult() == MessageHelper.TEST_STARTED) {\n      this.resultMessage = resultMessage;\n      this.name = resultMessage.toDisplayString();\n    }\n  }","commit_id":"244eed8e11f4d4277f3d76de3fb8b14e95bd400e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<Printable> getOutput() {\n    if (output != null) return output;\n    List<Printable> total = new ArrayList<Printable>();\n    for (TestProxy child : results) {\n      total.addAll(child.getOutput());\n    }\n    return total;\n  }","id":30398,"modified_method":"public List<Printable> getOutput() {\n    if (output != null) return output;\n    List<Printable> total = new ArrayList<Printable>();\n    for (TestProxy child : results) {\n      final List<Printable> out = child.getOutput();\n      if (total.size() > 0 && out.size() > 0) {\n        total.add(new TestNGConsoleView.Chunk(\"\\n===============================================\\n\\n\", ConsoleViewContentType.NORMAL_OUTPUT));\n      }\n      total.addAll(out);\n    }\n    return total;\n  }","commit_id":"244eed8e11f4d4277f3d76de3fb8b14e95bd400e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fillInLanguages() {\n    myUsedLanguages = new HashSet<Language>();\n    myUsedLanguages.addAll(getInitialUsedLanguages());\n    for (DevKit dk : myUsedDevkits) {\n      myUsedLanguages.addAll(dk.getAllExportedLanguages());\n    }\n    for (Language l : new ArrayList<Language>(myUsedLanguages)) {\n      myUsedLanguages.addAll(l.getDependenciesManager().getAllExtendedLanguages());\n    }\n  }","id":30399,"modified_method":"private void fillInLanguages() {\n    myUsedLanguages = new HashSet<Language>();\n    myUsedLanguages.addAll(getInitialUsedLanguages());\n    for (DevKit dk : myUsedDevkits) {\n      myUsedLanguages.addAll(dk.getAllExportedLanguages());\n    }\n    for (Language l : new ArrayList<Language>(myUsedLanguages)) {\n      l.getDependenciesManager().collectAllExtendedLanguages(myUsedLanguages);\n    }\n  }","commit_id":"4ca8af0b9610d9eff2da667eab2eceebe47dedf3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<String> getErrors() {\n    List<String> errors = new ArrayList<String>(super.getErrors());\n    for (ModuleReference gen : myModule.getModuleDescriptor().getDepGenerators()) {\n      if (MPSModuleRepository.getInstance().getModule(gen) == null) {\n        errors.add(\"Can't find generator dependency: \" + gen.getModuleFqName());\n      }\n    }\n    Set<String> usedLanguages = new HashSet<String>();\n    for (SModelDescriptor model : myModule.getOwnTemplateModels()) {\n      if(SModelStereotype.isGeneratorModel(model)) {\n        usedLanguages.addAll(ModelContentUtil.getUsedLanguageNamespacesInTemplateModel(model.getSModel()));\n      }\n    }\n    Set<String> extendedLanguages = new HashSet<String>();\n    Language sourceLanguage = myModule.getSourceLanguage();\n    usedLanguages.remove(sourceLanguage.getModuleFqName());\n    for(Language language : sourceLanguage.getDependenciesManager().getAllExtendedLanguages()){\n      extendedLanguages.add(language.getModuleFqName());\n    }\n\n    for (String lang : usedLanguages) {\n      Language language = ModuleRepositoryFacade.getInstance().getModule(lang, Language.class);\n      if(language == null) continue;\n\n      if (!extendedLanguages.contains(lang) && !language.getRuntimeModulesReferences().isEmpty()) {\n        errors.add(sourceLanguage + \" should extend \" + lang);\n      }\n    }\n    return errors;\n  }","id":30400,"modified_method":"public List<String> getErrors() {\n    List<String> errors = new ArrayList<String>(super.getErrors());\n    for (ModuleReference gen : myModule.getModuleDescriptor().getDepGenerators()) {\n      if (MPSModuleRepository.getInstance().getModule(gen) == null) {\n        errors.add(\"Can't find generator dependency: \" + gen.getModuleFqName());\n      }\n    }\n    Set<String> usedLanguages = new HashSet<String>();\n    for (SModelDescriptor model : myModule.getOwnTemplateModels()) {\n      if(SModelStereotype.isGeneratorModel(model)) {\n        usedLanguages.addAll(ModelContentUtil.getUsedLanguageNamespacesInTemplateModel(model.getSModel()));\n      }\n    }\n    Set<String> extendedLanguages = new HashSet<String>();\n    Language sourceLanguage = myModule.getSourceLanguage();\n    usedLanguages.remove(sourceLanguage.getModuleFqName());\n\n    Set<Language> ext = new LinkedHashSet<Language>();\n    sourceLanguage.getDependenciesManager().collectAllExtendedLanguages(ext);\n\n    for(Language language : ext){\n      extendedLanguages.add(language.getModuleFqName());\n    }\n\n    for (String lang : usedLanguages) {\n      Language language = ModuleRepositoryFacade.getInstance().getModule(lang, Language.class);\n      if(language == null) continue;\n\n      if (!extendedLanguages.contains(lang) && !language.getRuntimeModulesReferences().isEmpty()) {\n        errors.add(sourceLanguage + \" should extend \" + lang);\n      }\n    }\n    return errors;\n  }","commit_id":"4ca8af0b9610d9eff2da667eab2eceebe47dedf3","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * @return List of pairs keymap/ownerCell\n   */\n  private static List<Pair<EditorCellKeyMap, EditorCell>> getRegisteredKeymaps(EditorCell selectedCell, EditorContext editorContext) {\n    Set<Class> addedKeymaps = new HashSet<Class>(); // don't duplicate keymaps\n    List<Pair<EditorCellKeyMap, EditorCell>> keyMapsAndCells = new ArrayList<Pair<EditorCellKeyMap, EditorCell>>();\n\n    EditorCell keymapOwnerCell = selectedCell;\n    while (keymapOwnerCell != null) {\n      EditorCellKeyMap keymap = keymapOwnerCell.getKeyMap();\n      if (keymap != null && !addedKeymaps.contains(keymap.getClass())) {\n        keyMapsAndCells.add(new Pair<EditorCellKeyMap, EditorCell>(keymap, keymapOwnerCell));\n        addedKeymaps.add(keymap.getClass());\n      }\n      keymapOwnerCell = keymapOwnerCell.getParent();\n    }\n    SNode node = editorContext.getNodeEditorComponent().getEditedNode();\n    if (node != null) {\n      SModel model = node.getModel();\n\n      Set<ModuleReference> importedAndExtendedLanguages = new HashSet<ModuleReference>();\n      for (ModuleReference langRef : SModelOperations.getAllImportedLanguages(model)) {\n        importedAndExtendedLanguages.add(langRef);\n        Language l = ModuleRepositoryFacade.getInstance().getModule(langRef, Language.class);\n        if (l != null) {\n          for (Language le : l.getDependenciesManager().getAllExtendedLanguages()) {\n            importedAndExtendedLanguages.add(le.getModuleReference());\n          }\n        }\n      }\n\n      for (ModuleReference ref : importedAndExtendedLanguages) {\n        Language language = editorContext.getScope().getLanguage(ref);\n        if (language == null) {\n          continue;\n        }\n        List<EditorCellKeyMap> keyMapsForNamespace = LanguagesKeymapManager.getInstance().getKeyMapsForLanguage(language);\n        if (keyMapsForNamespace != null) {\n          for (EditorCellKeyMap keymap : keyMapsForNamespace) {\n            if (!addedKeymaps.contains(keymap.getClass())) {\n              keyMapsAndCells.add(new Pair<EditorCellKeyMap, EditorCell>(keymap, selectedCell));\n              addedKeymaps.add(keymap.getClass());\n            }\n          }\n        }\n      }\n    }\n\n    return keyMapsAndCells;\n  }","id":30401,"modified_method":"/**\n   * @return List of pairs keymap/ownerCell\n   */\n  private static List<Pair<EditorCellKeyMap, EditorCell>> getRegisteredKeymaps(EditorCell selectedCell, EditorContext editorContext) {\n    Set<Class> addedKeymaps = new HashSet<Class>(); // don't duplicate keymaps\n    List<Pair<EditorCellKeyMap, EditorCell>> keyMapsAndCells = new ArrayList<Pair<EditorCellKeyMap, EditorCell>>();\n\n    EditorCell keymapOwnerCell = selectedCell;\n    while (keymapOwnerCell != null) {\n      EditorCellKeyMap keymap = keymapOwnerCell.getKeyMap();\n      if (keymap != null && !addedKeymaps.contains(keymap.getClass())) {\n        keyMapsAndCells.add(new Pair<EditorCellKeyMap, EditorCell>(keymap, keymapOwnerCell));\n        addedKeymaps.add(keymap.getClass());\n      }\n      keymapOwnerCell = keymapOwnerCell.getParent();\n    }\n    SNode node = editorContext.getNodeEditorComponent().getEditedNode();\n    if (node != null) {\n      SModel model = node.getModel();\n\n      Set<ModuleReference> importedAndExtendedLanguages = new HashSet<ModuleReference>();\n      for (ModuleReference langRef : SModelOperations.getAllImportedLanguages(model)) {\n        importedAndExtendedLanguages.add(langRef);\n        Language l = ModuleRepositoryFacade.getInstance().getModule(langRef, Language.class);\n        if (l == null) continue;\n\n        Set<Language> ext = new LinkedHashSet<Language>();\n        l.getDependenciesManager().collectAllExtendedLanguages(ext);\n\n        for (Language le : ext) {\n          importedAndExtendedLanguages.add(le.getModuleReference());\n        }\n      }\n\n      for (ModuleReference ref : importedAndExtendedLanguages) {\n        Language language = editorContext.getScope().getLanguage(ref);\n        if (language == null) {\n          continue;\n        }\n        List<EditorCellKeyMap> keyMapsForNamespace = LanguagesKeymapManager.getInstance().getKeyMapsForLanguage(language);\n        if (keyMapsForNamespace != null) {\n          for (EditorCellKeyMap keymap : keyMapsForNamespace) {\n            if (!addedKeymaps.contains(keymap.getClass())) {\n              keyMapsAndCells.add(new Pair<EditorCellKeyMap, EditorCell>(keymap, selectedCell));\n              addedKeymaps.add(keymap.getClass());\n            }\n          }\n        }\n      }\n    }\n\n    return keyMapsAndCells;\n  }","commit_id":"4ca8af0b9610d9eff2da667eab2eceebe47dedf3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectAllExtendedLanguages(Set<Language> result) {\n    if (result.contains(myModule)) return;\n\n    result.add(myModule);\n\n    for (Language l : ModuleUtil.refsToLanguages(myModule.getExtendedLanguageRefs())) {\n      l.getDependenciesManager().collectAllExtendedLanguages(result);\n    }\n  }","id":30402,"modified_method":"public void collectAllExtendedLanguages(Set<Language> result) {\n    if (result.contains(myModule)) return;\n\n    result.add(myModule);\n\n    for (Language l : ModuleUtil.refsToLanguages(myModule.getExtendedLanguageRefs())) {\n      l.getDependenciesManager().collectAllExtendedLanguages(result);\n    }\n  }","commit_id":"4ca8af0b9610d9eff2da667eab2eceebe47dedf3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void checkBehaviorAspectPresence(Language lang, List<String> errors) {\n    for (Language language : lang.getDependenciesManager().getAllExtendedLanguages()) {\n      EditableSModelDescriptor descriptor = LanguageAspect.BEHAVIOR.get(language);\n      if (descriptor == null) {\n        if (lang == language)\n          errors.add(\"Behavior aspect is absent\");\n        else\n          errors.add(\"Cannot extend language without behavior aspect: \" + language.getModuleFqName());\n      }\n    }\n  }","id":30403,"modified_method":"public static void checkBehaviorAspectPresence(Language lang, List<String> errors) {\n    Set<Language> ext = new LinkedHashSet<Language>();\n    lang.getDependenciesManager().collectAllExtendedLanguages(ext);\n\n    for (Language language : ext) {\n      EditableSModelDescriptor descriptor = LanguageAspect.BEHAVIOR.get(language);\n      if (descriptor == null) {\n        if (lang == language)\n          errors.add(\"Behavior aspect is absent\");\n        else\n          errors.add(\"Cannot extend language without behavior aspect: \" + language.getModuleFqName());\n      }\n    }\n  }","commit_id":"4ca8af0b9610d9eff2da667eab2eceebe47dedf3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public final Set<Language> getAllUsedLanguages() {\n    Set<Language> result = new LinkedHashSet<Language>();\n    result.addAll(ModuleUtil.refsToLanguages(myModule.getUsedLanguagesReferences()));\n    for (DevKit dk : ModuleUtil.refsToDevkits(myModule.getUsedDevkitReferences())) {\n      //todo why extended are not included\n      result.addAll(dk.getAllExportedLanguages());\n    }\n    for (Language l : new HashSet<Language>(result)) {\n      result.addAll(l.getDependenciesManager().getAllExtendedLanguages());\n    }\n    return result;\n  }","id":30404,"modified_method":"public final Set<Language> getAllUsedLanguages() {\n    Set<Language> result = new LinkedHashSet<Language>();\n    result.addAll(ModuleUtil.refsToLanguages(myModule.getUsedLanguagesReferences()));\n    for (DevKit dk : ModuleUtil.refsToDevkits(myModule.getUsedDevkitReferences())) {\n      //todo why extended are not included\n      result.addAll(dk.getAllExportedLanguages());\n    }\n    for (Language l : new HashSet<Language>(result)) {\n      l.getDependenciesManager().collectAllExtendedLanguages(result);\n    }\n    return result;\n  }","commit_id":"4ca8af0b9610d9eff2da667eab2eceebe47dedf3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static List<Language> getLanguages(SModel model, @NotNull IScope scope) {\n    Set<Language> languages = new LinkedHashSet<Language>();\n\n    for (ModuleReference lang : model.importedLanguages()) {\n      Language language = scope.getLanguage(lang);\n\n      if (language != null) {\n        languages.add(language);\n        languages.addAll(language.getDependenciesManager().getAllExtendedLanguages());\n      }\n    }\n\n    for (ModuleReference dk : model.importedDevkits()) {\n      DevKit devKit = scope.getDevKit(dk);\n      if (devKit != null) {\n        for (Language l : devKit.getAllExportedLanguages()) {\n          if (languages.add(l)) {\n            languages.addAll(l.getDependenciesManager().getAllExtendedLanguages());\n          }\n        }\n      }\n    }\n\n    if (model.getModelDescriptor() != null && model.getModelDescriptor().getModule() != null) {\n      IModule module = model.getModelDescriptor().getModule();\n      languages.addAll(module.getImplicitlyImportedLanguages(model.getModelDescriptor()));\n    }\n\n    return new ArrayList<Language>(languages);\n  }","id":30405,"modified_method":"@NotNull\n  public static List<Language> getLanguages(SModel model, @NotNull IScope scope) {\n    Set<Language> languages = new LinkedHashSet<Language>();\n\n    for (ModuleReference lang : model.importedLanguages()) {\n      Language language = scope.getLanguage(lang);\n\n      if (language != null) {\n        languages.add(language);\n        language.getDependenciesManager().collectAllExtendedLanguages(languages);\n      }\n    }\n\n    for (ModuleReference dk : model.importedDevkits()) {\n      DevKit devKit = scope.getDevKit(dk);\n      if (devKit != null) {\n        for (Language l : devKit.getAllExportedLanguages()) {\n          if (languages.add(l)) {\n            l.getDependenciesManager().collectAllExtendedLanguages(languages);\n          }\n        }\n      }\n    }\n\n    if (model.getModelDescriptor() != null && model.getModelDescriptor().getModule() != null) {\n      IModule module = model.getModelDescriptor().getModule();\n      languages.addAll(module.getImplicitlyImportedLanguages(model.getModelDescriptor()));\n    }\n\n    return new ArrayList<Language>(languages);\n  }","commit_id":"4ca8af0b9610d9eff2da667eab2eceebe47dedf3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void save() throws IOException {\n    CachedXmlDocumentSet fileSet = EclipseClasspathStorageProvider.getFileCache(module);\n\n    AccessToken token = ApplicationManager.getApplication().acquireWriteActionLock(DocumentRunnable.IgnoreDocumentRunnable.class);\n    try {\n      for (String key : modifiedContent.keySet()) {\n        Element content = modifiedContent.get(key);\n        Writer writer = new OutputStreamWriter(StorageUtil.getOrCreateVirtualFile(this, new File(fileSet.getParent(key), key)).getOutputStream(this), CharsetToolkit.UTF8_CHARSET);\n        try {\n          EclipseJDOMUtil.output(content, writer, module.getProject());\n        }\n        finally {\n          writer.close();\n        }\n      }\n\n      if (deletedContent.isEmpty()) {\n        return;\n      }\n\n      for (String deleted : deletedContent) {\n        VirtualFile file = fileSet.getFile(deleted, false);\n        if (file != null) {\n          try {\n            file.delete(this);\n          }\n          catch (IOException ignore) {\n          }\n        }\n      }\n      deletedContent.clear();\n    }\n    finally {\n      token.finish();\n    }\n  }","id":30406,"modified_method":"@Override\n  public void save() throws IOException {\n    CachedXmlDocumentSet fileSet = EclipseClasspathStorageProvider.getFileCache(module);\n\n    AccessToken token = ApplicationManager.getApplication().acquireWriteActionLock(DocumentRunnable.IgnoreDocumentRunnable.class);\n    try {\n      for (String key : modifiedContent.keySet()) {\n        Element content = modifiedContent.get(key);\n        Writer writer = new OutputStreamWriter(StorageUtil.getOrCreateVirtualFile(this, fileSet.getParent(key) + '/' + key).getOutputStream(this), CharsetToolkit.UTF8_CHARSET);\n        try {\n          EclipseJDOMUtil.output(content, writer, module.getProject());\n        }\n        finally {\n          writer.close();\n        }\n      }\n\n      if (deletedContent.isEmpty()) {\n        return;\n      }\n\n      for (String deleted : deletedContent) {\n        VirtualFile file = fileSet.getFile(deleted, false);\n        if (file != null) {\n          try {\n            file.delete(this);\n          }\n          catch (IOException ignore) {\n          }\n        }\n      }\n      deletedContent.clear();\n    }\n    finally {\n      token.finish();\n    }\n  }","commit_id":"7856ed277191626facb72e0070f319d54e6efdf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getModuleDir(@NotNull Module module) {\n    return PathUtil.getParentPath(module.getModuleFilePath());\n  }","id":30407,"modified_method":"@NotNull\n  public static String getModuleDir(@NotNull Module module) {\n    return PathUtil.getParentPath(FileUtilRt.toSystemIndependentName(module.getModuleFilePath()));\n  }","commit_id":"7856ed277191626facb72e0070f319d54e6efdf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getStorageRootFromOptions(@NotNull Module module) {\n    String moduleRoot = getModuleDir(module);\n    String storageRef = module.getOptionValue(JpsProjectLoader.CLASSPATH_DIR_ATTRIBUTE);\n    if (storageRef == null) {\n      return moduleRoot;\n    }\n\n    storageRef = FileUtil.toSystemIndependentName(storageRef);\n    return storageRef.charAt(0) == '/' ? storageRef : moduleRoot + '/' + storageRef;\n  }","id":30408,"modified_method":"@NotNull\n  public static String getStorageRootFromOptions(@NotNull Module module) {\n    String moduleRoot = getModuleDir(module);\n    String storageRef = module.getOptionValue(JpsProjectLoader.CLASSPATH_DIR_ATTRIBUTE);\n    if (storageRef == null) {\n      return moduleRoot;\n    }\n\n    storageRef = FileUtil.toSystemIndependentName(storageRef);\n    if (SystemInfo.isWindows ? FileUtil.isAbsolutePlatformIndependent(storageRef) : FileUtil.isUnixAbsolutePath(storageRef)) {\n      return storageRef;\n    }\n    else {\n      return moduleRoot + '/' + storageRef;\n    }\n  }","commit_id":"7856ed277191626facb72e0070f319d54e6efdf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static VirtualFile writeFile(@Nullable File file,\n                                      @NotNull Object requestor,\n                                      @Nullable VirtualFile virtualFile,\n                                      @NotNull BufferExposingByteArrayOutputStream content,\n                                      @Nullable LineSeparator lineSeparatorIfPrependXmlProlog) throws IOException {\n    final VirtualFile result;\n    if (file != null && (virtualFile == null || !virtualFile.isValid())) {\n      result = getOrCreateVirtualFile(requestor, file);\n    }\n    else {\n      result = virtualFile;\n      assert result != null;\n    }\n\n    boolean equals = isEqualContent(result, lineSeparatorIfPrependXmlProlog, content);\n    if (equals) {\n      LOG.warn(\"Content equals, but it must be handled not on this level \u2014 \" + result.getName());\n      return result;\n    }\n    else {\n      doWrite(requestor, result, virtualFile, content, lineSeparatorIfPrependXmlProlog);\n      return result;\n    }\n  }","id":30409,"modified_method":"@NotNull\n  public static VirtualFile writeFile(@Nullable File file,\n                                      @NotNull Object requestor,\n                                      @Nullable VirtualFile virtualFile,\n                                      @NotNull BufferExposingByteArrayOutputStream content,\n                                      @Nullable LineSeparator lineSeparatorIfPrependXmlProlog) throws IOException {\n    final VirtualFile result;\n    if (file != null && (virtualFile == null || !virtualFile.isValid())) {\n      result = getOrCreateVirtualFile(requestor, file.getAbsolutePath());\n    }\n    else {\n      result = virtualFile;\n      assert result != null;\n    }\n\n    boolean equals = isEqualContent(result, lineSeparatorIfPrependXmlProlog, content);\n    if (equals) {\n      LOG.warn(\"Content equals, but it must be handled not on this level \u2014 \" + result.getName());\n      return result;\n    }\n    else {\n      doWrite(requestor, result, virtualFile, content, lineSeparatorIfPrependXmlProlog);\n      return result;\n    }\n  }","commit_id":"7856ed277191626facb72e0070f319d54e6efdf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static VirtualFile getOrCreateVirtualFile(@Nullable final Object requestor, @NotNull final File ioFile) throws IOException {\n    VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(ioFile);\n    if (virtualFile == null) {\n      File parentFile = ioFile.getParentFile();\n      // need refresh if the directory has just been created\n      final VirtualFile parentVirtualFile = parentFile == null ? null : LocalFileSystem.getInstance().refreshAndFindFileByIoFile(parentFile);\n      if (parentVirtualFile == null) {\n        throw new IOException(ProjectBundle.message(\"project.configuration.save.file.not.found\", parentFile == null ? \"\" : parentFile.getPath()));\n      }\n      boolean underWriteAction = ApplicationManager.getApplication().isWriteAccessAllowed();\n      virtualFile = underWriteAction ? parentVirtualFile.createChildData(requestor, ioFile.getName()) :\n                    ApplicationManager.getApplication().runWriteAction(new ThrowableComputable<VirtualFile, IOException>() {\n                      @Override\n                      public VirtualFile compute() throws IOException {\n                        return parentVirtualFile.createChildData(requestor, ioFile.getName());\n                      }\n                    });\n    }\n    return virtualFile;\n  }","id":30410,"modified_method":"@NotNull\n  public static VirtualFile getOrCreateVirtualFile(@Nullable Object requestor, @NotNull String path) throws IOException {\n    VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);\n    if (virtualFile != null) {\n      return virtualFile;\n    }\n\n    String parentFile = PathUtilRt.getParentPath(path);\n    // need refresh if the directory has just been created\n    VirtualFile parentVirtualFile = StringUtil.isEmpty(parentFile) ? null : LocalFileSystem.getInstance().refreshAndFindFileByPath(parentFile);\n    if (parentVirtualFile == null) {\n      throw new IOException(ProjectBundle.message(\"project.configuration.save.file.not.found\", parentFile));\n    }\n\n    if (ApplicationManager.getApplication().isWriteAccessAllowed()) {\n      return parentVirtualFile.createChildData(requestor, PathUtilRt.getFileName(path));\n    }\n    else {\n      AccessToken token = WriteAction.start();\n      try {\n        return parentVirtualFile.createChildData(requestor, PathUtilRt.getFileName(path));\n      }\n      finally {\n        token.finish();\n      }\n    }\n  }","commit_id":"7856ed277191626facb72e0070f319d54e6efdf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"String getPassedTests(Process p) {\n      InputStream testOutput = p.getInputStream();\n      BufferedReader testOutputReader = new BufferedReader(new InputStreamReader(testOutput));\n      String line;\n      try {\n        while ((line = testOutputReader.readLine()) != null) {\n          if (line.equals(TEST_OK)) {\n            myTestPassed++;\n          }\n          if (line.contains(TEST_FAILED)) {\n             return line.substring(TEST_FAILED.length(), line.length());\n          }\n        }\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n      finally {\n        StudyUtils.closeSilently(testOutputReader);\n      }\n      return null;\n    }","id":30411,"modified_method":"String getPassedTests(Process p) {\n      InputStream testOutput = p.getInputStream();\n      BufferedReader testOutputReader = new BufferedReader(new InputStreamReader(testOutput));\n      String line;\n      try {\n        while ((line = testOutputReader.readLine()) != null) {\n          if (line.contains(TEST_FAILED)) {\n             return line.substring(TEST_FAILED.length(), line.length());\n          }\n        }\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n      finally {\n        StudyUtils.closeSilently(testOutputReader);\n      }\n      return StudyTestRunner.TEST_OK;\n    }","commit_id":"8fdfff1339dea3f2568dfcbce5cb5dc07d9220a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void check(Project project,\n                     TaskWindow taskWindow,\n                     VirtualFile answerFile,\n                     TaskFile answerTaskFile,\n                     TaskFile usersTaskFile,\n                     Document usersDocument,\n                     StudyTestRunner testRunner) {\n\n    try {\n      VirtualFile windowCopy = answerFile.copy(this, answerFile.getParent(), \"window\" + taskWindow.getIndex() + \".py\");\n      final FileDocumentManager documentManager = FileDocumentManager.getInstance();\n      final Document windowDocument = documentManager.getDocument(windowCopy);\n      if (windowDocument != null) {\n        TaskFile windowTaskFile = new TaskFile();\n        TaskFile.copy(answerTaskFile, windowTaskFile);\n        StudyDocumentListener listener = new StudyDocumentListener(windowTaskFile);\n        windowDocument.addDocumentListener(listener);\n        int start = taskWindow.getRealStartOffset(windowDocument);\n        int end = start + taskWindow.getLength();\n        TaskWindow userTaskWindow = usersTaskFile.getTaskWindows().get(taskWindow.getIndex());\n        int userStart = userTaskWindow.getRealStartOffset(usersDocument);\n        int userEnd = userStart + userTaskWindow.getLength();\n        String text = usersDocument.getText(new TextRange(userStart, userEnd));\n        windowDocument.replaceString(start, end, text);\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            documentManager.saveDocument(windowDocument);\n          }\n        });\n        Process smartTestProcess = testRunner.launchTests(project, windowCopy.getPath());\n        boolean res = testRunner.testsPassed(smartTestProcess);\n        userTaskWindow.setStatus(res ? StudyStatus.Solved : StudyStatus.Failed);\n        windowCopy.delete(this);\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n    catch (ExecutionException e) {\n      e.printStackTrace();\n    }\n  }","id":30412,"modified_method":"private void check(Project project,\n                     TaskWindow taskWindow,\n                     VirtualFile answerFile,\n                     TaskFile answerTaskFile,\n                     TaskFile usersTaskFile,\n                     Document usersDocument,\n                     StudyTestRunner testRunner,\n                     VirtualFile openedFile) {\n\n    try {\n      VirtualFile windowCopy = answerFile.copy(this, answerFile.getParent(), \"window\" + taskWindow.getIndex() + \".py\");\n      final FileDocumentManager documentManager = FileDocumentManager.getInstance();\n      final Document windowDocument = documentManager.getDocument(windowCopy);\n      if (windowDocument != null) {\n        StudyTaskManager taskManager = StudyTaskManager.getInstance(project);\n        Course course = taskManager.getCourse();\n        Task task = usersTaskFile.getTask();\n        int taskNum = task.getIndex() + 1;\n        int lessonNum = task.getLesson().getIndex() + 1;\n        assert course != null;\n        String pathToResource = FileUtil.join(new File(course.getResourcePath()).getParent(), Lesson.LESSON_DIR + lessonNum,  Task.TASK_DIR + taskNum);\n        File resourceFile = new File(pathToResource, windowCopy.getName());\n        FileUtil.copy(new File(pathToResource, openedFile.getName()), resourceFile);\n        TaskFile windowTaskFile = new TaskFile();\n        TaskFile.copy(answerTaskFile, windowTaskFile);\n        StudyDocumentListener listener = new StudyDocumentListener(windowTaskFile);\n        windowDocument.addDocumentListener(listener);\n        int start = taskWindow.getRealStartOffset(windowDocument);\n        int end = start + taskWindow.getLength();\n        TaskWindow userTaskWindow = usersTaskFile.getTaskWindows().get(taskWindow.getIndex());\n        int userStart = userTaskWindow.getRealStartOffset(usersDocument);\n        int userEnd = userStart + userTaskWindow.getLength();\n        String text = usersDocument.getText(new TextRange(userStart, userEnd));\n        windowDocument.replaceString(start, end, text);\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            documentManager.saveDocument(windowDocument);\n          }\n        });\n        VirtualFile fileWindows = StudyUtils.flushWindows(windowDocument, windowTaskFile, windowCopy);\n        Process smartTestProcess = testRunner.launchTests(project, windowCopy.getPath());\n        boolean res = testRunner.getPassedTests(smartTestProcess).equals(StudyTestRunner.TEST_OK);\n        userTaskWindow.setStatus(res ? StudyStatus.Solved : StudyStatus.Failed);\n        windowCopy.delete(this);\n        fileWindows.delete(this);\n        if (!resourceFile.delete()) {\n          LOG.error(\"failed to delete\", resourceFile.getPath());\n        }\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n    catch (ExecutionException e) {\n      e.printStackTrace();\n    }\n  }","commit_id":"8fdfff1339dea3f2568dfcbce5cb5dc07d9220a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void check(@NotNull final Project project) {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          @Override\n          public void run() {\n            final Editor selectedEditor = StudyEditor.getSelectedEditor(project);\n            if (selectedEditor != null) {\n              final FileDocumentManager fileDocumentManager = FileDocumentManager.getInstance();\n              final VirtualFile openedFile = fileDocumentManager.getFile(selectedEditor.getDocument());\n              if (openedFile != null) {\n                StudyTaskManager taskManager = StudyTaskManager.getInstance(project);\n                final TaskFile selectedTaskFile = taskManager.getTaskFile(openedFile);\n                if (selectedTaskFile != null) {\n                  StudyUtils.flushWindows(selectedEditor.getDocument(),selectedTaskFile, openedFile);\n                  FileDocumentManager.getInstance().saveAllDocuments();\n                  final VirtualFile taskDir = openedFile.getParent();\n                  Task currentTask = selectedTaskFile.getTask();\n                  StudyRunAction runAction = (StudyRunAction)ActionManager.getInstance().getAction(StudyRunAction.ACTION_ID);\n                  if (runAction != null) {\n                    runAction.run(project);\n                  }\n                  final StudyTestRunner testRunner = new StudyTestRunner(currentTask, taskDir);\n                  Process testProcess = null;\n                  try {\n                    testProcess = testRunner.launchTests(project, openedFile.getPath());\n                  }\n                  catch (ExecutionException e) {\n                    LOG.error(e);\n                  }\n                  if (testProcess != null) {\n                    final int testNum = currentTask.getTestNum();\n                    String failedMessage = testRunner.getPassedTests(testProcess);\n                    final int testPassed = testRunner.getTestPassed();\n                    if (testPassed !=0 && failedMessage == null) {\n                      currentTask.setStatus(StudyStatus.Solved);\n                      StudyUtils.updateStudyToolWindow(project);\n                      selectedTaskFile.drawAllWindows(selectedEditor);\n                      ProjectView.getInstance(project).refresh();\n                      createTestResultPopUp(\"Congratulations!\", JBColor.GREEN, project);\n                      return;\n                    }\n\n                    final TaskFile taskFileCopy = new TaskFile();\n                    final VirtualFile copyWithAnswers = getCopyWithAnswers(taskDir, openedFile, selectedTaskFile, taskFileCopy);\n                    for (final TaskWindow taskWindow : taskFileCopy.getTaskWindows()) {\n                      check(project, taskWindow, copyWithAnswers, taskFileCopy, selectedTaskFile, selectedEditor.getDocument(), testRunner);\n                    }\n                    try {\n                      copyWithAnswers.delete(this);\n                    }\n                    catch (IOException e) {\n                      LOG.error(e);\n                    }\n\n                    if (failedMessage == null) {\n                      failedMessage = \"\";\n                    }\n                    selectedTaskFile.drawAllWindows(selectedEditor);\n                    String result = String.format(\"%d from %d tests failed\\n %s\", testNum - testPassed, testNum, failedMessage);\n                    createTestResultPopUp(result, JBColor.RED, project);\n                  }\n                }\n              }\n            }\n          }\n        }, null, null);\n      }\n    });\n  }","id":30413,"modified_method":"public void check(@NotNull final Project project) {\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          @Override\n          public void run() {\n            final Editor selectedEditor = StudyEditor.getSelectedEditor(project);\n            if (selectedEditor != null) {\n              final FileDocumentManager fileDocumentManager = FileDocumentManager.getInstance();\n              final VirtualFile openedFile = fileDocumentManager.getFile(selectedEditor.getDocument());\n              if (openedFile != null) {\n                StudyTaskManager taskManager = StudyTaskManager.getInstance(project);\n                final TaskFile selectedTaskFile = taskManager.getTaskFile(openedFile);\n                if (selectedTaskFile != null) {\n                  StudyUtils.flushWindows(selectedEditor.getDocument(),selectedTaskFile, openedFile);\n                  FileDocumentManager.getInstance().saveAllDocuments();\n                  final VirtualFile taskDir = openedFile.getParent();\n                  Task currentTask = selectedTaskFile.getTask();\n                  StudyRunAction runAction = (StudyRunAction)ActionManager.getInstance().getAction(StudyRunAction.ACTION_ID);\n                  if (runAction != null) {\n                    runAction.run(project);\n                  }\n                  final StudyTestRunner testRunner = new StudyTestRunner(currentTask, taskDir);\n                  Process testProcess = null;\n                  try {\n                    testProcess = testRunner.launchTests(project, openedFile.getPath());\n                  }\n                  catch (ExecutionException e) {\n                    LOG.error(e);\n                  }\n                  if (testProcess != null) {\n                    String failedMessage = testRunner.getPassedTests(testProcess);\n                    if (failedMessage == StudyTestRunner.TEST_OK) {\n                      currentTask.setStatus(StudyStatus.Solved);\n                      StudyUtils.updateStudyToolWindow(project);\n                      selectedTaskFile.drawAllWindows(selectedEditor);\n                      ProjectView.getInstance(project).refresh();\n                      createTestResultPopUp(\"Congratulations!\", JBColor.GREEN, project);\n                      return;\n                    }\n\n                    final TaskFile taskFileCopy = new TaskFile();\n                    final VirtualFile copyWithAnswers = getCopyWithAnswers(taskDir, openedFile, selectedTaskFile, taskFileCopy);\n                    for (final TaskWindow taskWindow : taskFileCopy.getTaskWindows()) {\n                      check(project, taskWindow, copyWithAnswers, taskFileCopy, selectedTaskFile, selectedEditor.getDocument(), testRunner, openedFile);\n                    }\n                    try {\n                      copyWithAnswers.delete(this);\n                    }\n                    catch (IOException e) {\n                      LOG.error(e);\n                    }\n                    selectedTaskFile.drawAllWindows(selectedEditor);\n                    createTestResultPopUp(failedMessage, JBColor.RED, project);\n                  }\n                }\n              }\n            }\n          }\n        }, null, null);\n      }\n    });\n  }","commit_id":"8fdfff1339dea3f2568dfcbce5cb5dc07d9220a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void flushWindows(Document document, TaskFile taskFile, VirtualFile file) {\n    VirtualFile taskDir = file.getParent();\n    if (taskDir != null) {\n      String name = file.getNameWithoutExtension() + \"_windows\";\n      PrintWriter printWriter = null;\n      try {\n        VirtualFile file_windows = taskDir.createChildData(taskFile, name);\n        printWriter = new PrintWriter(new FileOutputStream(file_windows.getPath()));\n        for (TaskWindow taskWindow : taskFile.getTaskWindows()) {\n          int start = taskWindow.getRealStartOffset(document);\n          String windowDescription = document.getText(new TextRange(start, start + taskWindow.getLength()));\n          printWriter.println(\"#study_plugin_window = \" + windowDescription);\n        }\n      }\n      catch (IOException e) {\n        e.printStackTrace();\n      }\n      finally {\n        closeSilently(printWriter);\n        StudyUtils.synchronize();\n      }\n    }\n  }","id":30414,"modified_method":"public static VirtualFile flushWindows(Document document, TaskFile taskFile, VirtualFile file) {\n    VirtualFile taskDir = file.getParent();\n    VirtualFile file_windows = null;\n    if (taskDir != null) {\n      String name = file.getNameWithoutExtension() + \"_windows\";\n      PrintWriter printWriter = null;\n      try {\n\n        file_windows = taskDir.createChildData(taskFile, name);\n        printWriter = new PrintWriter(new FileOutputStream(file_windows.getPath()));\n        for (TaskWindow taskWindow : taskFile.getTaskWindows()) {\n          int start = taskWindow.getRealStartOffset(document);\n          String windowDescription = document.getText(new TextRange(start, start + taskWindow.getLength()));\n          printWriter.println(\"#study_plugin_window = \" + windowDescription);\n        }\n      }\n      catch (IOException e) {\n        e.printStackTrace();\n      }\n      finally {\n        closeSilently(printWriter);\n        StudyUtils.synchronize();\n      }\n    }\n    return file_windows;\n  }","commit_id":"8fdfff1339dea3f2568dfcbce5cb5dc07d9220a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadState(AppEngineFacetConfiguration state) {\n    //todo[nik] remove toSystemIndependentName call later. It is needed only to fix incorrect config files\n    mySdkHomePath = FileUtil.toSystemIndependentName(state.getSdkHomePath());\n    myRunEnhancerOnMake = state.isRunEnhancerOnMake();\n    myFilesToEnhance = state.getFilesToEnhance();\n  }","id":30415,"modified_method":"public void loadState(AppEngineFacetConfiguration state) {\n    //todo[nik] remove toSystemIndependentName call later. It is needed only to fix incorrect config files\n    mySdkHomePath = FileUtil.toSystemIndependentName(state.getSdkHomePath());\n    myRunEnhancerOnMake = state.isRunEnhancerOnMake();\n    myFilesToEnhance = state.getFilesToEnhance();\n    myPersistenceApi = state.getPersistenceApi();\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void apply() throws ConfigurationException {\n    myFacetConfiguration.setSdkHomePath(mySdkEditor.getPath());\n    myFacetConfiguration.setRunEnhancerOnMake(myRunEnhancerOnMakeCheckBox.isSelected());\n    myFacetConfiguration.setFilesToEnhance(getConfiguredFiles());\n  }","id":30416,"modified_method":"public void apply() throws ConfigurationException {\n    myFacetConfiguration.setSdkHomePath(mySdkEditor.getPath());\n    myFacetConfiguration.setRunEnhancerOnMake(myRunEnhancerOnMakeCheckBox.isSelected());\n    myFacetConfiguration.setFilesToEnhance(getConfiguredFiles());\n    myFacetConfiguration.setPersistenceApi(PersistenceApiComboboxUtil.getSelectedApi(myPersistenceApiComboBox));\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isModified() {\n    return myRunEnhancerOnMakeCheckBox.isSelected() != myFacetConfiguration.isRunEnhancerOnMake()\n           || !mySdkEditor.getPath().equals(myFacetConfiguration.getSdkHomePath())\n           || !getConfiguredFiles().equals(myFacetConfiguration.getFilesToEnhance());\n  }","id":30417,"modified_method":"public boolean isModified() {\n    return myRunEnhancerOnMakeCheckBox.isSelected() != myFacetConfiguration.isRunEnhancerOnMake()\n           || !mySdkEditor.getPath().equals(myFacetConfiguration.getSdkHomePath())\n           || !getConfiguredFiles().equals(myFacetConfiguration.getFilesToEnhance())\n           || PersistenceApiComboboxUtil.getSelectedApi(myPersistenceApiComboBox) != myFacetConfiguration.getPersistenceApi();\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n    mySdkEditor.setPath(myFacetConfiguration.getSdkHomePath());\n    if (myContext.isNewFacet() && myFacetConfiguration.getSdkHomePath().length() == 0) {\n      mySdkEditor.setDefaultPath();\n    }\n    myFilesListModel.removeAllElements();\n    fillFilesList(myFacetConfiguration.getFilesToEnhance());\n    myRunEnhancerOnMakeCheckBox.setSelected(myFacetConfiguration.isRunEnhancerOnMake());\n  }","id":30418,"modified_method":"public void reset() {\n    mySdkEditor.setPath(myFacetConfiguration.getSdkHomePath());\n    if (myContext.isNewFacet() && myFacetConfiguration.getSdkHomePath().length() == 0) {\n      mySdkEditor.setDefaultPath();\n    }\n    myFilesListModel.removeAllElements();\n    fillFilesList(myFacetConfiguration.getFilesToEnhance());\n    myRunEnhancerOnMakeCheckBox.setSelected(myFacetConfiguration.isRunEnhancerOnMake());\n    myPersistenceApiComboBox.setSelectedItem(myFacetConfiguration.getPersistenceApi().getName());\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AppEngineFacetEditor(AppEngineFacetConfiguration facetConfiguration, FacetEditorContext context, FacetValidatorsManager validatorsManager) {\n    myFacetConfiguration = facetConfiguration;\n    myContext = context;\n    mySdkEditor = new AppEngineSdkEditor(myContext.getProject(), false);\n    validatorsManager.registerValidator(new FacetEditorValidator() {\n      @Override\n      public ValidationResult check() {\n        return AppEngineSdkImpl.checkPath(mySdkEditor.getPath());\n      }\n    }, mySdkEditor.getComboBox());\n\n    myRunEnhancerOnMakeCheckBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        GuiUtils.enableChildren(myRunEnhancerOnMakeCheckBox.isSelected(), myFilesToEnhancePanel);\n        if (myRunEnhancerOnMakeCheckBox.isSelected() && myFilesListModel.isEmpty()) {\n          fillFilesList(AppEngineUtil.getDefaultSourceRootsToEnhance(myContext.getRootModel()));\n        }\n      }\n    });\n    myFilesListModel = new DefaultListModel();\n    myFilesList.setCellRenderer(new FilesListCellRenderer());\n    myFilesList.setModel(myFilesListModel);\n    myFilesList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateButtons();\n      }\n    });\n    myAddButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        doAdd();\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        ListUtil.removeSelectedItems(myFilesList);\n        updateButtons();\n      }\n    });\n    updateButtons();\n  }","id":30419,"modified_method":"public AppEngineFacetEditor(AppEngineFacetConfiguration facetConfiguration, FacetEditorContext context, FacetValidatorsManager validatorsManager) {\n    myFacetConfiguration = facetConfiguration;\n    myContext = context;\n    mySdkEditor = new AppEngineSdkEditor(myContext.getProject(), false);\n    validatorsManager.registerValidator(new FacetEditorValidator() {\n      @Override\n      public ValidationResult check() {\n        return AppEngineSdkImpl.checkPath(mySdkEditor.getPath());\n      }\n    }, mySdkEditor.getComboBox());\n\n    myRunEnhancerOnMakeCheckBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        GuiUtils.enableChildren(myRunEnhancerOnMakeCheckBox.isSelected(), myFilesToEnhancePanel);\n        if (myRunEnhancerOnMakeCheckBox.isSelected() && myFilesListModel.isEmpty()) {\n          fillFilesList(AppEngineUtil.getDefaultSourceRootsToEnhance(myContext.getRootModel()));\n        }\n      }\n    });\n    myFilesListModel = new DefaultListModel();\n    myFilesList.setCellRenderer(new FilesListCellRenderer());\n    myFilesList.setModel(myFilesListModel);\n    myFilesList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        updateButtons();\n      }\n    });\n    myAddButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        doAdd();\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        ListUtil.removeSelectedItems(myFilesList);\n        updateButtons();\n      }\n    });\n    PersistenceApiComboboxUtil.setComboboxModel(myPersistenceApiComboBox, false);\n    updateButtons();\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doAdd() {\n    final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, false, false, false, true);\n    descriptor.getRoots().clear();\n    final ModuleRootModel rootModel = myContext.getRootModel();\n    if (rootModel != null) {\n      for (VirtualFile file : rootModel.getSourceRoots()) {\n        descriptor.addRoot(file);\n      }\n    }\n    final VirtualFile[] files =\n        FileChooserFactory.getInstance().createFileChooser(descriptor, myContext.getProject()).choose(null, myContext.getProject());\n    for (VirtualFile file : files) {\n      myFilesListModel.addElement(file.getPath());\n    }\n    updateButtons();\n  }","id":30420,"modified_method":"private void doAdd() {\n    final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, false, false, false, true);\n    descriptor.getRoots().clear();\n    final ModuleRootModel rootModel = myContext.getRootModel();\n    for (VirtualFile file : rootModel.getSourceRoots()) {\n      descriptor.addRoot(file);\n    }\n    final VirtualFile[] files =\n        FileChooserFactory.getInstance().createFileChooser(descriptor, myContext.getProject()).choose(null, myContext.getProject());\n    for (VirtualFile file : files) {\n      myFilesListModel.addElement(file.getPath());\n    }\n    updateButtons();\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createFileFromTemplate(final String templateName, final VirtualFile parent, final String fileName) {\n    final FileTemplate template = FileTemplateManager.getInstance().getJ2eeTemplate(templateName);\n    try {\n      final String text = template.getText(FileTemplateManager.getInstance().getDefaultProperties());\n      final VirtualFile file = parent.createChildData(this, fileName);\n      VfsUtil.saveText(file, text);\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":30421,"modified_method":"@Nullable\n  private VirtualFile createFileFromTemplate(final String templateName, final VirtualFile parent, final String fileName) {\n    final FileTemplate template = FileTemplateManager.getInstance().getJ2eeTemplate(templateName);\n    try {\n      final String text = template.getText(FileTemplateManager.getInstance().getDefaultProperties());\n      VirtualFile file = parent.findChild(fileName);\n      if (file == null) {\n        file = parent.createChildData(this, fileName);\n      }\n      VfsUtil.saveText(file, text);\n      return file;\n    }\n    catch (IOException e) {\n      LOG.error(e);\n      return null;\n    }\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addSupport(final Module module, final ModifiableRootModel rootModel, String sdkPath, boolean addJdoSupport) {\n    super.addSupport(module, rootModel, null, null);\n    final AppEngineFacet appEngineFacet = FacetManager.getInstance(module).getFacetByType(AppEngineFacet.ID);\n    LOG.assertTrue(appEngineFacet != null);\n    final AppEngineFacetConfiguration facetConfiguration = appEngineFacet.getConfiguration();\n    facetConfiguration.setSdkHomePath(sdkPath);\n    final AppEngineSdk sdk = appEngineFacet.getSdk();\n    final ApplicationServer appServer = sdk.getOrCreateAppServer();\n    if (appServer != null) {\n      final ConfigurationFactory type = AppEngineServerConfigurationType.getInstance().getConfigurationFactories()[0];\n      final RunManagerEx runManager = RunManagerEx.getInstanceEx(module.getProject());\n      final RunnerAndConfigurationSettingsImpl runSettings = (RunnerAndConfigurationSettingsImpl)runManager.createRunConfiguration(\"AppEngine Dev\", type);\n\n      final CommonStrategy configuration = (CommonStrategy)runSettings.getConfiguration();\n      configuration.setApplicationServer(appServer);\n      configuration.setUrlToOpenInBrowser(configuration.getDefaultUrlForBrowser());\n      ((AppEngineServerModel)configuration.getServerModel()).setWebFacet(appEngineFacet.getWebFacet());\n\n      runManager.addConfiguration(runSettings, false);\n      runManager.setActiveConfiguration(runSettings);\n    }\n\n    final Library apiJar = addProjectLibrary(module, \"AppEngine API\", sdk.getLibUserDirectoryPath(), VirtualFile.EMPTY_ARRAY);\n    rootModel.addLibraryEntry(apiJar);\n    if (addJdoSupport) {\n      facetConfiguration.setRunEnhancerOnMake(true);\n      facetConfiguration.getFilesToEnhance().addAll(AppEngineUtil.getDefaultSourceRootsToEnhance(rootModel));\n      try {\n        final VirtualFile[] sourceRoots = rootModel.getSourceRoots();\n        final VirtualFile sourceRoot;\n        if (sourceRoots.length > 0) {\n          sourceRoot = sourceRoots[0];\n        }\n        else {\n          sourceRoot = findOrCreateChildDirectory(rootModel.getContentRoots()[0], \"src\");\n        }\n        VirtualFile metaInf = findOrCreateChildDirectory(sourceRoot, \"META-INF\");\n        createFileFromTemplate(AppEngineTemplateGroupDescriptorFactory.APP_ENGINE_JDO_CONFIG_TEMPLATE, metaInf, AppEngineUtil.JDO_CONFIG_XML_NAME);\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n      final Library library = addProjectLibrary(module, \"AppEngine ORM\", sdk.getOrmLibDirectoryPath(), sdk.getOrmLibSources());\n      rootModel.addLibraryEntry(library);\n      final JavaeePackagingConfiguration configuration = appEngineFacet.getWebFacet().getPackagingConfiguration();\n      configuration.addLibraryLink(library);\n      configuration.addLibraryLink(apiJar);\n    }\n  }","id":30422,"modified_method":"private void addSupport(final Module module, final ModifiableRootModel rootModel, String sdkPath, @Nullable PersistenceApi persistenceApi) {\n    super.addSupport(module, rootModel, null, null);\n    final AppEngineFacet appEngineFacet = FacetManager.getInstance(module).getFacetByType(AppEngineFacet.ID);\n    LOG.assertTrue(appEngineFacet != null);\n    final AppEngineFacetConfiguration facetConfiguration = appEngineFacet.getConfiguration();\n    facetConfiguration.setSdkHomePath(sdkPath);\n    final AppEngineSdk sdk = appEngineFacet.getSdk();\n    final ApplicationServer appServer = sdk.getOrCreateAppServer();\n    if (appServer != null) {\n      final ConfigurationFactory type = AppEngineServerConfigurationType.getInstance().getConfigurationFactories()[0];\n      final RunManagerEx runManager = RunManagerEx.getInstanceEx(module.getProject());\n      final RunnerAndConfigurationSettingsImpl runSettings = (RunnerAndConfigurationSettingsImpl)runManager.createRunConfiguration(\"AppEngine Dev\", type);\n\n      final CommonStrategy configuration = (CommonStrategy)runSettings.getConfiguration();\n      configuration.setApplicationServer(appServer);\n      configuration.setUrlToOpenInBrowser(configuration.getDefaultUrlForBrowser());\n      ((AppEngineServerModel)configuration.getServerModel()).setWebFacet(appEngineFacet.getWebFacet());\n\n      runManager.addConfiguration(runSettings, false);\n      runManager.setActiveConfiguration(runSettings);\n    }\n\n    final Library apiJar = addProjectLibrary(module, \"AppEngine API\", sdk.getLibUserDirectoryPath(), VirtualFile.EMPTY_ARRAY);\n    rootModel.addLibraryEntry(apiJar);\n    if (persistenceApi != null) {\n      facetConfiguration.setRunEnhancerOnMake(true);\n      facetConfiguration.getFilesToEnhance().addAll(AppEngineUtil.getDefaultSourceRootsToEnhance(rootModel));\n      try {\n        final VirtualFile[] sourceRoots = rootModel.getSourceRoots();\n        final VirtualFile sourceRoot;\n        if (sourceRoots.length > 0) {\n          sourceRoot = sourceRoots[0];\n        }\n        else {\n          sourceRoot = findOrCreateChildDirectory(rootModel.getContentRoots()[0], \"src\");\n        }\n        VirtualFile metaInf = findOrCreateChildDirectory(sourceRoot, \"META-INF\");\n        if (persistenceApi == PersistenceApi.JDO) {\n          createFileFromTemplate(AppEngineTemplateGroupDescriptorFactory.APP_ENGINE_JDO_CONFIG_TEMPLATE, metaInf, AppEngineUtil.JDO_CONFIG_XML_NAME);\n        }\n        else {\n          final VirtualFile file = createFileFromTemplate(AppEngineTemplateGroupDescriptorFactory.APP_ENGINE_JPA_CONFIG_TEMPLATE, metaInf, AppEngineUtil.JPA_CONFIG_XML_NAME);\n          if (file != null) {\n            JpaFacet facet = FacetManager.getInstance(module).getFacetByType(JpaFacet.ID);\n            if (facet == null) {\n              final JpaFacet jpaFacet = FacetManager.getInstance(module).addFacet(JpaFacetType.INSTANCE, JpaFacetType.INSTANCE.getDefaultFacetName(), null);\n              jpaFacet.getDescriptorsContainer().getConfiguration().replaceConfigFile(JavaeePersistenceDescriptorsConstants.PERSISTENCE_XML_META_DATA, file.getUrl());\n            }\n          }\n        }\n      }\n      catch (IOException e) {\n        LOG.error(e);\n      }\n      final Library library = addProjectLibrary(module, \"AppEngine ORM\", sdk.getOrmLibDirectoryPath(), sdk.getOrmLibSources());\n      rootModel.addLibraryEntry(library);\n      final JavaeePackagingConfiguration configuration = appEngineFacet.getWebFacet().getPackagingConfiguration();\n      configuration.addLibraryLink(library);\n      configuration.addLibraryLink(apiJar);\n    }\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private AppEngineSupportConfigurable() {\n      super(AppEngineSupportProvider.this, ArrayUtil.EMPTY_STRING_ARRAY, null);\n      mySdkEditor = new AppEngineSdkEditor(null, true);\n      myMainPanel = new JPanel(new BorderLayout());\n      myMainPanel.add(mySdkEditor.getMainComponent(), BorderLayout.CENTER);\n      myJdoCheckBox = new JCheckBox(\"JDO persistence\");\n      myMainPanel.add(myJdoCheckBox, BorderLayout.SOUTH);\n    }","id":30423,"modified_method":"private AppEngineSupportConfigurable() {\n      super(AppEngineSupportProvider.this, ArrayUtil.EMPTY_STRING_ARRAY, null);\n      mySdkEditor = new AppEngineSdkEditor(null, true);\n      myMainPanel = new JPanel(new BorderLayout());\n      myMainPanel.add(mySdkEditor.getMainComponent(), BorderLayout.CENTER);\n      myMainPanel.add(myOptionsPanel, BorderLayout.SOUTH);\n      PersistenceApiComboboxUtil.setComboboxModel(myPersistenceApiComboBox, true);\n    }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void addSupport(Module module, ModifiableRootModel rootModel, @Nullable Library library) {\n      AppEngineSupportProvider.this.addSupport(module, rootModel, mySdkEditor.getPath(), myJdoCheckBox.isSelected());\n    }","id":30424,"modified_method":"@Override\n    public void addSupport(Module module, ModifiableRootModel rootModel, @Nullable Library library) {\n      AppEngineSupportProvider.this.addSupport(module, rootModel, mySdkEditor.getPath(), PersistenceApiComboboxUtil.getSelectedApi(myPersistenceApiComboBox));\n    }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileTemplateGroupDescriptor getFileTemplatesDescriptor() {\n    final FileTemplateDescriptor appEngineXml = new FileTemplateDescriptor(APP_ENGINE_WEB_XML_TEMPLATE, StdFileTypes.XML.getIcon());\n    final FileTemplateDescriptor jdoConfigXml = new FileTemplateDescriptor(APP_ENGINE_JDO_CONFIG_TEMPLATE, StdFileTypes.XML.getIcon());\n    return new FileTemplateGroupDescriptor(\"Google App Engine\", AppEngineUtil.APP_ENGINE_ICON, appEngineXml, jdoConfigXml);\n  }","id":30425,"modified_method":"public FileTemplateGroupDescriptor getFileTemplatesDescriptor() {\n    final FileTemplateDescriptor appEngineXml = new FileTemplateDescriptor(APP_ENGINE_WEB_XML_TEMPLATE, StdFileTypes.XML.getIcon());\n    final FileTemplateDescriptor jdoConfigXml = new FileTemplateDescriptor(APP_ENGINE_JDO_CONFIG_TEMPLATE, StdFileTypes.XML.getIcon());\n    final FileTemplateDescriptor jpaConfigXml = new FileTemplateDescriptor(APP_ENGINE_JPA_CONFIG_TEMPLATE, StdFileTypes.XML.getIcon());\n    return new FileTemplateGroupDescriptor(\"Google App Engine\", AppEngineUtil.APP_ENGINE_ICON, appEngineXml, jdoConfigXml, jpaConfigXml);\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean runEnhancer(final AppEngineFacet facet, final Collection<ClassFileItem> items, final CompileContext context) {\n    try {\n      final AppEngineSdk sdk = facet.getSdk();\n      if (!sdk.isValid()) {\n        throw new CantRunException(\"Valid App Engine SDK isn't specified for '\" + facet.getName() + \"' facet (module '\" + facet.getModule() + \"')\");\n      }\n\n      final JavaParameters javaParameters = new JavaParameters();\n      new ReadAction() {\n        protected void run(final Result result) throws Throwable {\n          context.getProgressIndicator().setText2(\"'\" + facet.getModule().getName() + \"' module, '\" + facet.getWebFacet().getName() + \"' facet, processing \" + items.size() + \" classes...\");\n          javaParameters.configureByModule(facet.getModule(), JavaParameters.JDK_AND_CLASSES);\n          javaParameters.getClassPath().addFirst(sdk.getToolsApiJarFile().getAbsolutePath());\n\n          final ParametersList vmParameters = javaParameters.getVMParametersList();\n          vmParameters.add(\"-Xmx256m\");\n\n          final ParametersList programParameters = javaParameters.getProgramParametersList();\n          programParameters.add(\"-v\");\n          for (ClassFileItem item : items) {\n            programParameters.add(FileUtil.toSystemDependentName(item.getFile().getPath()));\n          }\n\n          javaParameters.setMainClass(\"com.google.appengine.tools.enhancer.Enhance\");\n        }\n      }.execute().throwException();\n\n\n      final GeneralCommandLine commandLine = CommandLineBuilder.createFromJavaParameters(javaParameters);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"starting enchancer: \" + commandLine.getCommandLineString());\n      }\n      final Process process = commandLine.createProcess();\n      EnhancerProcessHandler handler = new EnhancerProcessHandler(process, commandLine.getCommandLineString(), context);\n      handler.startNotify();\n      handler.waitFor();\n    }\n    catch (ProcessCanceledException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      context.addMessage(CompilerMessageCategory.ERROR, e.getMessage(), null, -1, -1);\n      LOG.info(e);\n    }\n    return context.getMessageCount(CompilerMessageCategory.ERROR) == 0;\n  }","id":30426,"modified_method":"private static boolean runEnhancer(final AppEngineFacet facet, final Collection<ClassFileItem> items, final CompileContext context) {\n    try {\n      final AppEngineSdk sdk = facet.getSdk();\n      if (!sdk.isValid()) {\n        throw new CantRunException(\"Valid App Engine SDK isn't specified for '\" + facet.getName() + \"' facet (module '\" + facet.getModule() + \"')\");\n      }\n\n      final JavaParameters javaParameters = new JavaParameters();\n      new ReadAction() {\n        protected void run(final Result result) throws Throwable {\n          final JavaParameters tempJavaParameters = new JavaParameters();\n          context.getProgressIndicator().setText2(\"'\" + facet.getModule().getName() + \"' module, '\" + facet.getWebFacet().getName() + \"' facet, processing \" + items.size() + \" classes...\");\n          tempJavaParameters.configureByModule(facet.getModule(), JavaParameters.JDK_AND_CLASSES);\n          final PathsList classPath = tempJavaParameters.getClassPath();\n          classPath.addFirst(sdk.getToolsApiJarFile().getAbsolutePath());\n          clearClasspath(classPath, javaParameters.getClassPath());\n\n          final ParametersList vmParameters = javaParameters.getVMParametersList();\n          vmParameters.add(\"-Xmx256m\");\n\n          final ParametersList programParameters = javaParameters.getProgramParametersList();\n          programParameters.add(\"-api\");\n          programParameters.add(facet.getConfiguration().getPersistenceApi().getName());\n          programParameters.add(\"-v\");\n          for (ClassFileItem item : items) {\n            programParameters.add(FileUtil.toSystemDependentName(item.getFile().getPath()));\n          }\n\n          javaParameters.setMainClass(\"com.google.appengine.tools.enhancer.Enhance\");\n\n          javaParameters.setCharset(tempJavaParameters.getCharset());\n          javaParameters.setEnv(tempJavaParameters.getEnv());\n          javaParameters.setJdk(tempJavaParameters.getJdk());\n        }\n      }.execute().throwException();\n\n\n      final GeneralCommandLine commandLine = CommandLineBuilder.createFromJavaParameters(javaParameters);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"starting enhancer: \" + commandLine.getCommandLineString());\n      }\n      final Process process = commandLine.createProcess();\n      EnhancerProcessHandler handler = new EnhancerProcessHandler(process, commandLine.getCommandLineString(), context);\n      handler.startNotify();\n      handler.waitFor();\n    }\n    catch (ProcessCanceledException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      context.addMessage(CompilerMessageCategory.ERROR, e.getMessage(), null, -1, -1);\n      LOG.info(e);\n    }\n    return context.getMessageCount(CompilerMessageCategory.ERROR) == 0;\n  }","commit_id":"d6c5419d3833c0c970dd3e501ed9fd0abdef2fe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String generate(final String pathname, final List<String> generators, final URL generatorJarPath) throws Exception {\n    final MavenProject project = maven.readProject(new File(pathname));\n    session.setCurrentProject(project);\n\n    MojoExecution flexmojosMojoExecution = null;\n    MojoExecution flexmojosGeneratorMojoExecution = null;\n    final String compileGoal = \"compile-\" + project.getPackaging();\n    try {\n      for (Plugin plugin : project.getBuildPlugins()) {\n        if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\")) {\n          if (flexmojosMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n            flexmojosMojoExecution = maven.createMojoExecution(plugin, compileGoal, project);\n          }\n          else if (flexmojosGeneratorMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-generator-mojo\")) {\n            flexmojosGeneratorMojoExecution = maven.createMojoExecution(plugin, \"generate\", project);\n          }\n\n          if (flexmojosMojoExecution != null && flexmojosGeneratorMojoExecution != null) {\n            break;\n          }\n        }\n      }\n\n      assert flexmojosMojoExecution != null;\n      final ClassRealm flexmojosPluginRealm = maven.getPluginRealm(flexmojosMojoExecution);\n      flexmojosPluginRealm.addURL(generatorJarPath);\n\n      final Mojo mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n      try {\n        //for (String configuratorClassName : generators) {\n          Class configuratorClass = flexmojosPluginRealm.loadClass(generators.get(0));\n          FlexConfigGenerator configurator = (FlexConfigGenerator)configuratorClass.getConstructor(MavenSession.class, File.class)\n                                                                                   .newInstance(session, generatorOutputDirectory);\n          configurator.preGenerate(project, Flexmojos.getClassifier(mojo), flexmojosGeneratorMojoExecution);\n          if (\"swc\".equals(project.getPackaging())) {\n            configurator.generate(mojo);\n          }\n          else {\n            configurator.generate(mojo, Flexmojos.getSourceFileForSwf(mojo));\n          }\n          return configurator.postGenerate(project);\n        //}\n      }\n      finally {\n        plexusContainer.release(mojo);\n      }\n    }\n    finally {\n      session.setCurrentProject(null);\n      if (flexmojosMojoExecution != null) {\n        maven.releaseMojoExecution(compileGoal, flexmojosMojoExecution);\n      }\n      if (flexmojosGeneratorMojoExecution != null) {\n        maven.releaseMojoExecution(\"generate\", flexmojosGeneratorMojoExecution);\n      }\n    }\n  }","id":30427,"modified_method":"private String generate(final String pathname, final List<String> generators, final URL generatorJarPath) throws Exception {\n    final MavenProject project = maven.readProject(new File(pathname));\n    session.setCurrentProject(project);\n\n    MojoExecution flexmojosMojoExecution = null;\n    final List<MojoExecution> sourceProviderMojoExecutions = new ArrayList<MojoExecution>(2);\n    try {\n      boolean flexmojosGeneratorFound = false;\n      boolean buildHelperFound = false;\n      for (Plugin plugin : project.getBuildPlugins()) {\n        if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\")) {\n          if (flexmojosMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n            flexmojosMojoExecution = maven.createMojoExecution(plugin, \"compile-\" + project.getPackaging(), project);\n          }\n          else if (!flexmojosGeneratorFound && plugin.getArtifactId().equals(\"flexmojos-generator-mojo\")) {\n            sourceProviderMojoExecutions.add(maven.createMojoExecution(plugin, \"generate\", project));\n            flexmojosGeneratorFound = true;\n          }\n        }\n        else if (!buildHelperFound && plugin.getArtifactId().equals(\"build-helper-maven-plugin\") && plugin.getGroupId().equals(\"org.codehaus.mojo\")) {\n          sourceProviderMojoExecutions.add(maven.createMojoExecution(plugin, \"add-source\", project));\n          buildHelperFound = true;\n        }\n\n        if (flexmojosMojoExecution != null && sourceProviderMojoExecutions.size() == 2) {\n          break;\n        }\n      }\n\n      assert flexmojosMojoExecution != null;\n      final ClassRealm flexmojosPluginRealm = maven.getPluginRealm(flexmojosMojoExecution);\n      flexmojosPluginRealm.addURL(generatorJarPath);\n\n      final AdditionalSourcePathProvider additionalSourcePathProvider = sourceProviderMojoExecutions.isEmpty() ? null : new AdditionalSourcePathProvider(sourceProviderMojoExecutions);\n      final Mojo mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n      try {\n        //for (String configuratorClassName : generators) {\n          Class configuratorClass = flexmojosPluginRealm.loadClass(generators.get(0));\n          FlexConfigGenerator configurator = (FlexConfigGenerator)configuratorClass.getConstructor(MavenSession.class, File.class).newInstance(session, generatorOutputDirectory);\n          configurator.preGenerate(project, Flexmojos.getClassifier(mojo), additionalSourcePathProvider);\n          if (\"swc\".equals(project.getPackaging())) {\n            configurator.generate(mojo);\n          }\n          else {\n            configurator.generate(mojo, Flexmojos.getSourceFileForSwf(mojo));\n          }\n          return configurator.postGenerate(project);\n        //}\n      }\n      finally {\n        plexusContainer.release(mojo);\n      }\n    }\n    finally {\n      session.setCurrentProject(null);\n      if (flexmojosMojoExecution != null) {\n        maven.releaseMojoExecution(flexmojosMojoExecution);\n      }\n      for (MojoExecution sourceProviderMojoExecution : sourceProviderMojoExecutions) {\n        maven.releaseMojoExecution(sourceProviderMojoExecution);\n      }\n    }\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void resolveOutputs(WorkspaceReaderImpl.ArtifactData data) throws Exception {\n    final MavenProject project = maven.readProject(data.file);\n    final MavenProject oldProject = session.getCurrentProject();\n    final String compileGoal = \"compile-\" + project.getPackaging();\n    MojoExecution flexmojosMojoExecution = null;\n    try {\n      session.setCurrentProject(project);\n      for (Plugin plugin : project.getBuildPlugins()) {\n        if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\") && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n          flexmojosMojoExecution = maven.createMojoExecution(plugin, compileGoal, project);\n          break;\n        }\n      }\n\n      if (flexmojosMojoExecution == null) {\n        return;\n      }\n\n      // getPluginRealm creates plugin realm and populates pluginDescriptor.classRealm field\n      maven.getPluginRealm(flexmojosMojoExecution);\n\n      Mojo mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n      try {\n        data.outputFile = new File(Flexmojos.getOutput(mojo));\n        String[] localesRuntime = (String[])Flexmojos.invokePublicMethod(mojo, \"getLocalesRuntime\");\n        if (localesRuntime != null && localesRuntime.length > 0) {\n          final Class<?> superclass = mojo.getClass().getSuperclass();\n          mojo = (Mojo)Flexmojos.invokePublicMethod(mojo, \"clone\");\n          \n          final Method m = superclass.getDeclaredMethod(\"configureResourceBundle\", String.class, superclass);\n          m.setAccessible(true);\n          String firstLocale = localesRuntime[0];\n          m.invoke(mojo, firstLocale, mojo);\n\n          //noinspection unchecked\n          ((Map)Flexmojos.invokePublicMethod(mojo, \"getCache\")).put(\"getProjectType\", \"rb.swc\");\n\n          data.localeOutputFilepathPattern = Flexmojos.getOutput(mojo).replace(firstLocale, \"{_locale_}\");\n        }\n      }\n      finally {\n        plexusContainer.release(mojo);\n      }\n    }\n    finally {\n      session.setCurrentProject(oldProject);\n      if (flexmojosMojoExecution != null) {\n        maven.releaseMojoExecution(compileGoal, flexmojosMojoExecution);\n      }\n    }\n  }","id":30428,"modified_method":"public void resolveOutputs(WorkspaceReaderImpl.ArtifactData data) throws Exception {\n    final MavenProject project = maven.readProject(data.file);\n    final MavenProject oldProject = session.getCurrentProject();\n    MojoExecution flexmojosMojoExecution = null;\n    try {\n      session.setCurrentProject(project);\n      for (Plugin plugin : project.getBuildPlugins()) {\n        if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\") && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n          flexmojosMojoExecution = maven.createMojoExecution(plugin, \"compile-\" + project.getPackaging(), project);\n          break;\n        }\n      }\n\n      if (flexmojosMojoExecution == null) {\n        return;\n      }\n\n      // getPluginRealm creates plugin realm and populates pluginDescriptor.classRealm field\n      maven.getPluginRealm(flexmojosMojoExecution);\n\n      Mojo mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n      try {\n        data.outputFile = new File(Flexmojos.getOutput(mojo));\n        String[] localesRuntime = (String[])Flexmojos.invokePublicMethod(mojo, \"getLocalesRuntime\");\n        if (localesRuntime != null && localesRuntime.length > 0) {\n          final Class<?> superclass = mojo.getClass().getSuperclass();\n          mojo = (Mojo)Flexmojos.invokePublicMethod(mojo, \"clone\");\n          \n          final Method m = superclass.getDeclaredMethod(\"configureResourceBundle\", String.class, superclass);\n          m.setAccessible(true);\n          String firstLocale = localesRuntime[0];\n          m.invoke(mojo, firstLocale, mojo);\n\n          //noinspection unchecked\n          ((Map)Flexmojos.invokePublicMethod(mojo, \"getCache\")).put(\"getProjectType\", \"rb.swc\");\n\n          data.localeOutputFilepathPattern = Flexmojos.getOutput(mojo).replace(firstLocale, \"{_locale_}\");\n        }\n      }\n      finally {\n        plexusContainer.release(mojo);\n      }\n    }\n    finally {\n      session.setCurrentProject(oldProject);\n      if (flexmojosMojoExecution != null) {\n        maven.releaseMojoExecution(flexmojosMojoExecution);\n      }\n    }\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void generateForProject(MavenProject project, List<String> configurators) throws Exception {\n    MojoExecution flexmojosMojoExecution = null;\n    MojoExecution flexmojosGeneratorMojoExecution = null;\n    for (Plugin plugin : project.getBuildPlugins()) {\n      if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\")) {\n        if (flexmojosMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n          flexmojosMojoExecution = createMojoExecution(plugin, \"compile-\" + project.getPackaging(), project);\n        }\n        else if (flexmojosGeneratorMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-generator-mojo\")) {\n          flexmojosGeneratorMojoExecution = createMojoExecution(plugin, \"generate\", project);\n        }\n\n        if (flexmojosMojoExecution != null && flexmojosGeneratorMojoExecution != null) {\n          break;\n        }\n      }\n    }\n\n    if (flexmojosMojoExecution == null) {\n      return;\n    }\n\n    ClassRealm flexmojosPluginRealm = pluginManager.getPluginRealm(session,\n                                                                   flexmojosMojoExecution.getMojoDescriptor().getPluginDescriptor());\n\n    final ClassLoader classLoader = getClass().getClassLoader();\n    flexmojosPluginRealm.addURL(new URL(session.getLocalRepository().getUrl() + \"com/intellij/flex/maven/idea-configurator/1.5.1/idea-configurator-1.5.1.jar\"));\n    flexmojosPluginRealm.importFrom(classLoader, \"com.intellij.flex.maven.FlexConfigGenerator\");\n    flexmojosPluginRealm.importFrom(classLoader, \"com.intellij.flex.maven.Utils\");\n    Mojo mojo = null;\n    try {\n      mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n\n      for (String configuratorClassName : configurators) {\n        Class configuratorClass = flexmojosPluginRealm.loadClass(configuratorClassName);\n        FlexConfigGenerator configurator = (FlexConfigGenerator)configuratorClass.getConstructor(MavenSession.class, File.class).newInstance(session, null);\n        configurator.preGenerate(project, getClassifier(mojo), flexmojosGeneratorMojoExecution);\n        if (\"swc\".equals(project.getPackaging())) {\n          configurator.generate(mojo);\n        }\n        else {\n          configurator.generate(mojo, getSourceFileForSwf(mojo));\n        }\n        configurator.postGenerate(project);\n      }\n    }\n    finally {\n      mavenPluginManager.releaseMojo(mojo, mojoExecution);\n    }\n  }","id":30429,"modified_method":"private void generateForProject(MavenProject project, List<String> configurators) throws Exception {\n    MojoExecution flexmojosMojoExecution = null;\n    MojoExecution flexmojosGeneratorMojoExecution = null;\n    for (Plugin plugin : project.getBuildPlugins()) {\n      if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\")) {\n        if (flexmojosMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n          flexmojosMojoExecution = createMojoExecution(plugin, \"compile-\" + project.getPackaging(), project);\n        }\n        else if (flexmojosGeneratorMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-generator-mojo\")) {\n          flexmojosGeneratorMojoExecution = createMojoExecution(plugin, \"generate\", project);\n        }\n\n        if (flexmojosMojoExecution != null && flexmojosGeneratorMojoExecution != null) {\n          break;\n        }\n      }\n    }\n\n    if (flexmojosMojoExecution == null) {\n      return;\n    }\n\n    ClassRealm flexmojosPluginRealm = pluginManager.getPluginRealm(session,\n                                                                   flexmojosMojoExecution.getMojoDescriptor().getPluginDescriptor());\n\n    final ClassLoader classLoader = getClass().getClassLoader();\n    flexmojosPluginRealm.addURL(new URL(session.getLocalRepository().getUrl() + \"com/intellij/flex/maven/idea-configurator/1.5.1/idea-configurator-1.5.1.jar\"));\n    flexmojosPluginRealm.importFrom(classLoader, \"com.intellij.flex.maven.FlexConfigGenerator\");\n    flexmojosPluginRealm.importFrom(classLoader, \"com.intellij.flex.maven.Utils\");\n    Mojo mojo = null;\n    try {\n      mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n\n      for (String configuratorClassName : configurators) {\n        Class configuratorClass = flexmojosPluginRealm.loadClass(configuratorClassName);\n        FlexConfigGenerator configurator = (FlexConfigGenerator)configuratorClass.getConstructor(MavenSession.class, File.class).newInstance(session, null);\n        configurator.preGenerate(project, getClassifier(mojo), flexmojosGeneratorMojoExecution, buildHelperMojoExecution);\n        if (\"swc\".equals(project.getPackaging())) {\n          configurator.generate(mojo);\n        }\n        else {\n          configurator.generate(mojo, getSourceFileForSwf(mojo));\n        }\n        configurator.postGenerate(project);\n      }\n    }\n    finally {\n      mavenPluginManager.releaseMojo(mojo, mojoExecution);\n    }\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void addGeneratedSources(File[] existing, String indent) throws IOException {\n    final List<File> existingList;\n    if (flexmojosGeneratorMojoExecution == null) {\n      existingList = Arrays.asList(existing);\n    }\n    else {\n      existingList = new ArrayList<File>();\n      Collections.addAll(existingList, existing);\n\n      PlexusConfiguration configuration = new XmlPlexusConfiguration(flexmojosGeneratorMojoExecution.getConfiguration());\n      writeGeneratedSource(configuration, \"baseOutputDirectory\", existingList, indent);\n      writeGeneratedSource(configuration, \"outputDirectory\", existingList, indent);\n    }\n\n    File generatedSources = new File(build.getDirectory(), \"/generated-sources\");\n    if (!generatedSources.isDirectory()) {\n      return;\n    }\n\n    for (File file : generatedSources.listFiles()) {\n      writeGeneratedSource(file, existingList, indent);\n    }\n  }","id":30430,"modified_method":"private void processSourcePaths(File[] existing, String indent) throws IOException, ExpressionEvaluationException {\n    final List<File> paths = additionalSourcePathsProvider == null ? Arrays.asList(existing) : additionalSourcePathsProvider.merge(existing, session);\n    for (File file : paths) {\n      writeSourcePath(file, indent);\n    }\n\n    File generatedSources = new File(build.getDirectory(), \"/generated-sources\");\n    if (generatedSources.isDirectory()) {\n      for (File file : generatedSources.listFiles()) {\n        if (file.isDirectory() && !file.isHidden() && !paths.contains(file)) {\n          writeSourcePath(file, indent);\n        }\n      }\n    }\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@SuppressWarnings({\"ConstantConditions\"})\n  private <E> void build(E configuration, Class configClass, String indent, String configurationName) throws Exception {\n    boolean parentTagWritten = configurationName == null;\n\n    final Method[] methods = configClass.getMethods();\n    Arrays.sort(methods, new Comparator<Method>() {\n      @Override\n      public int compare(Method o1, Method o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n\n    for (Method method : methods) {\n      method.setAccessible(true);\n      if (method.getParameterTypes().length != 0) {\n        continue;\n      }\n\n      final String methodName = method.getName();\n      if (methodName.equals(\"getLoadConfig\") || methodName.equals(\"getDumpConfig\") || (\"metadata\".equals(configurationName) && methodName.equals(\"getDate\"))) {\n        continue;\n      }\n\n      final Object value = method.invoke(configuration);\n      if (value == null) {\n        continue;\n      }\n\n      if ((methodName.equals(\"getFixedLiteralVector\") || methodName.equals(\"getHeadlessServer\")) && !((Boolean)value)) {\n        continue;\n      }\n\n      if (!parentTagWritten) {\n        parentTagWritten = true;\n        out.append(indent, 0, indent.length() - 1).append('<').append(configurationName).append('>');\n      }\n\n      final Class<?> returnType = method.getReturnType();\n      final String name = camelCaseToSnake(methodName);\n\n      if (value instanceof IFlexConfiguration) {\n        build(value, returnType, indent + \"\\t\", name.substring(0, name.length() - 14));\n      }\n      else if (configuration instanceof IASDocConfiguration && \"footer\".equals(name)) {\n        // todo\n        throw new UnsupportedOperationException();\n      }\n      else if (value instanceof IRuntimeSharedLibraryPath || value instanceof IRuntimeSharedLibraryPath[]) {\n        final IRuntimeSharedLibraryPath[] values;\n        if (returnType.isArray()) {\n          //noinspection ConstantConditions\n          values = (IRuntimeSharedLibraryPath[])value;\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IRuntimeSharedLibraryPath[]{(IRuntimeSharedLibraryPath)value};\n        }\n\n        for (IRuntimeSharedLibraryPath arg : values) {\n          out.append(\"\\n\\t<\").append(name).append(\">\\n\\t\\t<path-element>\").append(arg.pathElement()).append(\"<\/path-element>\");\n\n          //noinspection unchecked\n          for (Map.Entry<String, String> entry : (Set<Map.Entry<String, String>>)arg.rslUrl().entrySet()) {\n            out.append(\"\\n\\t\\t<rsl-url>\").append(entry.getKey()).append(\"<\/rsl-url>\");\n\n            if (entry.getValue() != null) {\n              out.append(\"\\n\\t\\t<policy-file-url>\").append(entry.getValue()).append(\"<\/policy-file-url>\");\n            }\n          }\n\n          out.append(\"\\n\\t<\/\").append(name).append('>');\n        }\n      }\n      else if (value instanceof IFlexArgument || value instanceof IFlexArgument[]) {\n        IFlexArgument[] values;\n        Class<?> type = returnType;\n        if (type.isArray()) {\n          //noinspection ConstantConditions\n          values = (IFlexArgument[])value;\n          type = returnType.getComponentType();\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IFlexArgument[]{(IFlexArgument)value};\n          type = returnType;\n        }\n\n        Field orderField = type.getField(\"ORDER\");\n        orderField.setAccessible(true);\n        String[] order = (String[])type.getField(\"ORDER\").get(returnType);\n\n        for (IFlexArgument iFlexArgument : values) {\n          out.append(indent).append('<').append(name).append('>');\n\n          for (String argMethodName : order) {\n            Object argValue = type.getDeclaredMethod(argMethodName).invoke(iFlexArgument);\n            if (argValue == null) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Collection<?> || argValue.getClass().isArray()) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Map<?, ?>) {\n              throw new UnsupportedOperationException();\n//              Map<?, ?> map = ((Map<?, ?>) argValue);\n//              for (Object argValue1 : map.entrySet()) {\n//                @SuppressWarnings({\"unchecked\"}) Map.Entry<String, ?> entry = (Map.Entry<String, ?>) argValue1;\n//                out.append(indent).append(\"\\t<\").append(entry.getKey()).append('>').append(entry.getValue().toString()).append(\"<\/\").append(entry.getKey()).append('>');\n//              }\n            }\n            else {\n              writeTag(indent, argMethodName.equals(\"serialNumber\") ? \"serial-number\" : argMethodName, (String)argValue, name);\n            }\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (configuration instanceof IMetadataConfiguration &&\n               (name.equals(\"language\") || name.equals(\"creator\") || name.equals(\"publisher\"))) {\n        for (String v : (String[])value) {\n          out.append(indent).append(\"<\").append(name).append(\">\").append(v).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (returnType.isArray() || value instanceof Collection<?>) {\n        Object[] values;\n        if (returnType.isArray()) {\n          values = (Object[])value;\n        }\n        else {\n          values = ((Collection<?>)value).toArray();\n        }\n\n        out.append(indent).append('<').append(name);\n\n        // fucking adobe, ability to compile pure AS3 project without fucking themes \u2014 node must be present, but empty (relevant only for \"theme\", but we are ready for adobe surprises)\n        if (values.length == 0) {\n          out.append(\"/>\");\n        }\n        else {\n          out.append('>');\n\n          String childTagName = Utils.CHILD_TAG_NAME_MAP.get(name);\n          if (childTagName == null) {\n            childTagName = PATH_ELEMENT;\n          }\n\n          for (Object v : values) {\n            writeTag(indent, childTagName, v.toString(), name);\n          }\n\n          if (name.equals(SOURCE_PATH) && \"compiler\".equals(configurationName)) {\n            addGeneratedSources((File[])values, indent);\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else {\n        out.append(indent).append('<').append(name).append('>');\n        processValue(value.toString(), name);\n        out.append(\"<\/\").append(name).append('>');\n      }\n    }\n\n    if (parentTagWritten && configurationName != null) {\n      out.append(indent, 0, indent.length() - 1).append(\"<\/\").append(configurationName).append('>');\n    }\n  }","id":30431,"modified_method":"@SuppressWarnings({\"ConstantConditions\"})\n  private <E> void build(E configuration, Class configClass, String indent, String configurationName) throws Exception {\n    boolean parentTagWritten = configurationName == null;\n\n    final Method[] methods = configClass.getMethods();\n    Arrays.sort(methods, new Comparator<Method>() {\n      @Override\n      public int compare(Method o1, Method o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n\n    for (Method method : methods) {\n      method.setAccessible(true);\n      if (method.getParameterTypes().length != 0) {\n        continue;\n      }\n\n      final String methodName = method.getName();\n      if (methodName.equals(\"getLoadConfig\") || methodName.equals(\"getDumpConfig\") || (\"metadata\".equals(configurationName) && methodName.equals(\"getDate\"))) {\n        continue;\n      }\n\n      final Object value = method.invoke(configuration);\n      if (value == null) {\n        continue;\n      }\n\n      if ((methodName.equals(\"getFixedLiteralVector\") || methodName.equals(\"getHeadlessServer\")) && !((Boolean)value)) {\n        continue;\n      }\n\n      if (!parentTagWritten) {\n        parentTagWritten = true;\n        out.append(indent, 0, indent.length() - 1).append('<').append(configurationName).append('>');\n      }\n\n      final Class<?> returnType = method.getReturnType();\n      final String name = camelCaseToSnake(methodName);\n\n      if (value instanceof IFlexConfiguration) {\n        build(value, returnType, indent + \"\\t\", name.substring(0, name.length() - 14));\n      }\n      else if (configuration instanceof IASDocConfiguration && \"footer\".equals(name)) {\n        // todo\n        throw new UnsupportedOperationException();\n      }\n      else if (value instanceof IRuntimeSharedLibraryPath || value instanceof IRuntimeSharedLibraryPath[]) {\n        final IRuntimeSharedLibraryPath[] values;\n        if (returnType.isArray()) {\n          //noinspection ConstantConditions\n          values = (IRuntimeSharedLibraryPath[])value;\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IRuntimeSharedLibraryPath[]{(IRuntimeSharedLibraryPath)value};\n        }\n\n        for (IRuntimeSharedLibraryPath arg : values) {\n          out.append(\"\\n\\t<\").append(name).append(\">\\n\\t\\t<path-element>\").append(arg.pathElement()).append(\"<\/path-element>\");\n\n          //noinspection unchecked\n          for (Map.Entry<String, String> entry : (Set<Map.Entry<String, String>>)arg.rslUrl().entrySet()) {\n            out.append(\"\\n\\t\\t<rsl-url>\").append(entry.getKey()).append(\"<\/rsl-url>\");\n\n            if (entry.getValue() != null) {\n              out.append(\"\\n\\t\\t<policy-file-url>\").append(entry.getValue()).append(\"<\/policy-file-url>\");\n            }\n          }\n\n          out.append(\"\\n\\t<\/\").append(name).append('>');\n        }\n      }\n      else if (value instanceof IFlexArgument || value instanceof IFlexArgument[]) {\n        IFlexArgument[] values;\n        Class<?> type = returnType;\n        if (type.isArray()) {\n          //noinspection ConstantConditions\n          values = (IFlexArgument[])value;\n          type = returnType.getComponentType();\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IFlexArgument[]{(IFlexArgument)value};\n          type = returnType;\n        }\n\n        Field orderField = type.getField(\"ORDER\");\n        orderField.setAccessible(true);\n        String[] order = (String[])type.getField(\"ORDER\").get(returnType);\n\n        for (IFlexArgument iFlexArgument : values) {\n          out.append(indent).append('<').append(name).append('>');\n\n          for (String argMethodName : order) {\n            Object argValue = type.getDeclaredMethod(argMethodName).invoke(iFlexArgument);\n            if (argValue == null) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Collection<?> || argValue.getClass().isArray()) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Map<?, ?>) {\n              throw new UnsupportedOperationException();\n//              Map<?, ?> map = ((Map<?, ?>) argValue);\n//              for (Object argValue1 : map.entrySet()) {\n//                @SuppressWarnings({\"unchecked\"}) Map.Entry<String, ?> entry = (Map.Entry<String, ?>) argValue1;\n//                out.append(indent).append(\"\\t<\").append(entry.getKey()).append('>').append(entry.getValue().toString()).append(\"<\/\").append(entry.getKey()).append('>');\n//              }\n            }\n            else {\n              writeTag(indent, argMethodName.equals(\"serialNumber\") ? \"serial-number\" : argMethodName, (String)argValue, name);\n            }\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (configuration instanceof IMetadataConfiguration &&\n               (name.equals(\"language\") || name.equals(\"creator\") || name.equals(\"publisher\"))) {\n        for (String v : (String[])value) {\n          out.append(indent).append(\"<\").append(name).append(\">\").append(v).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (returnType.isArray() || value instanceof Collection<?>) {\n        Object[] values;\n        if (returnType.isArray()) {\n          values = (Object[])value;\n        }\n        else {\n          values = ((Collection<?>)value).toArray();\n        }\n\n        out.append(indent).append('<').append(name);\n\n        // ability to compile pure AS3 project without themes \u2014 node must be present, but empty (relevant only for \"theme\", but we are ready for adobe surprises)\n        if (values.length == 0) {\n          out.append(\"/>\");\n        }\n        else {\n          out.append('>');\n\n          String childTagName = Utils.CHILD_TAG_NAME_MAP.get(name);\n          if (childTagName == null) {\n            childTagName = PATH_ELEMENT;\n          }\n\n          if (name.equals(SOURCE_PATH) && \"compiler\".equals(configurationName)) {\n            processSourcePaths((File[])values, indent);\n          }\n          else {\n            for (Object v : values) {\n              if (v == null) {\n                System.out.print('\\n' + childTagName + \" child value for \" + name + \" is null\\n\");\n              }\n              if (v != null) {\n                writeTag(indent, childTagName, v.toString(), name);\n              }\n            }\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else {\n        out.append(indent).append('<').append(name).append('>');\n        processValue(value.toString(), name);\n        out.append(\"<\/\").append(name).append('>');\n      }\n    }\n\n    if (parentTagWritten && configurationName != null) {\n      out.append(indent, 0, indent.length() - 1).append(\"<\/\").append(configurationName).append('>');\n    }\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void writeGeneratedSource(File file, List<File> existingList, String indent) throws IOException {\n    if (file.isDirectory() && !file.isHidden() && !existingList.contains(file)) {\n      writeTag(indent, PATH_ELEMENT, file.getAbsolutePath(), SOURCE_PATH);\n    }\n  }","id":30432,"modified_method":"private void writeSourcePath(File file, String indent) throws IOException {\n    writeTag(indent, PATH_ELEMENT, file.getAbsolutePath(), SOURCE_PATH);\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void preGenerate(MavenProject project, String classifier, MojoExecution flexmojosGeneratorMojoExecution) throws IOException {\n    this.classifier = classifier;\n    this.flexmojosGeneratorMojoExecution = flexmojosGeneratorMojoExecution;\n    build = project.getBuild();\n  }","id":30433,"modified_method":"@Override\n  public void preGenerate(MavenProject project, String classifier, AdditionalSourcePathProvider additionalSourcePathProvider) throws IOException {\n    this.classifier = classifier;\n    this.additionalSourcePathsProvider = additionalSourcePathProvider;\n    build = project.getBuild();\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public MojoExecution createMojoExecution(Plugin plugin, String goal, MavenProject project) throws Exception {\n    MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor(plugin, goal, project.getRemotePluginRepositories(), session.getRepositorySession());\n    MojoExecution mojoExecution = new MojoExecution(mojoDescriptor, \"default-cli\", MojoExecution.Source.CLI);\n    plexusContainer.lookup(LifecycleExecutionPlanCalculator.class).setupMojoExecution(session, project, mojoExecution);\n    return mojoExecution;\n  }","id":30434,"modified_method":"public MojoExecution createMojoExecution(Plugin plugin, String goal, MavenProject project) throws Exception {\n    MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor(plugin, goal, project.getRemotePluginRepositories(), session.getRepositorySession());\n    List<PluginExecution> executions = plugin.getExecutions();\n    MojoExecution mojoExecution = new MojoExecution(mojoDescriptor, executions.isEmpty() ? null : executions.get(executions.size() - 1).getId(), MojoExecution.Source.CLI);\n    plexusContainer.lookup(LifecycleExecutionPlanCalculator.class).setupMojoExecution(session, project, mojoExecution);\n    return mojoExecution;\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@SuppressWarnings(\"UnusedParameters\")\n  public synchronized void releaseMojoExecution(String goal, MojoExecution mojoExecution) throws Exception {\n  }","id":30435,"modified_method":"@SuppressWarnings(\"UnusedParameters\")\n  public synchronized void releaseMojoExecution(MojoExecution mojoExecution) throws Exception {\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void preGenerate(MavenProject project, String classifier, MojoExecution flexmojosGeneratorMojoExecution) throws IOException {\n    super.preGenerate(project, classifier, flexmojosGeneratorMojoExecution);\n\n    baseDir = project.getBasedir().getPath();\n\n    localRepositoryBasedir = session.getLocalRepository().getBasedir();\n    localRepositoryBasedirLength = localRepositoryBasedir.length();\n\n    if (!listForGantGenerated) {\n      listForGantGenerated = true;\n\n      StringBuilder s = new StringBuilder(8192);\n      s.append(\"def List<SwfDescriptor> getList() {\\n\\treturn [\");\n\n      boolean isFirst = true;\n      final int absPathPrefixLength = session.getTopLevelProject().getBasedir().getPath().length();\n      for (MavenProject p : session.getProjects()) {\n        if (p.getPackaging().equals(\"swf\") || p.getPackaging().equals(\"swc\")) {\n          if (!isFirst) {\n            s.append(\", \");\n          }\n          else {\n            isFirst = false;\n          }\n\n          s.append(\"\\n\\t\\tnew SwfDescriptor(\\\"\").append(p.getArtifactId()).append(\".xml\\\", \\\"\");\n          final String pBaseDir = p.getBasedir().getPath();\n          if (session.getTopLevelProject() != p) {\n            s.append(pBaseDir.substring(absPathPrefixLength + 1));\n          }\n          else {\n            s.append(pBaseDir);\n          }\n          s.append(\"\\\", \").append(p.getPackaging().equals(\"swc\") ? \"true\" : \"false\").append(')');\n        }\n      }\n\n      s.append(\"\\n\\t];\\n}\");\n      Utils.write(s, new File(\"build-gant/flex_ui_designer_swfs_build.gant\"));\n    }\n  }","id":30436,"modified_method":"@Override\n  public void preGenerate(MavenProject project, String classifier, AdditionalSourcePathProvider additionalSourcePathProvider) throws IOException {\n    super.preGenerate(project, classifier, additionalSourcePathProvider);\n\n    baseDir = project.getBasedir().getPath();\n\n    localRepositoryBasedir = session.getLocalRepository().getBasedir();\n    localRepositoryBasedirLength = localRepositoryBasedir.length();\n\n    if (!listForGantGenerated) {\n      listForGantGenerated = true;\n\n      StringBuilder s = new StringBuilder(8192);\n      s.append(\"def List<SwfDescriptor> getList() {\\n\\treturn [\");\n\n      boolean isFirst = true;\n      final int absPathPrefixLength = session.getTopLevelProject().getBasedir().getPath().length();\n      for (MavenProject p : session.getProjects()) {\n        if (p.getPackaging().equals(\"swf\") || p.getPackaging().equals(\"swc\")) {\n          if (!isFirst) {\n            s.append(\", \");\n          }\n          else {\n            isFirst = false;\n          }\n\n          s.append(\"\\n\\t\\tnew SwfDescriptor(\\\"\").append(p.getArtifactId()).append(\".xml\\\", \\\"\");\n          final String pBaseDir = p.getBasedir().getPath();\n          if (session.getTopLevelProject() != p) {\n            s.append(pBaseDir.substring(absPathPrefixLength + 1));\n          }\n          else {\n            s.append(pBaseDir);\n          }\n          s.append(\"\\\", \").append(p.getPackaging().equals(\"swc\") ? \"true\" : \"false\").append(')');\n        }\n      }\n\n      s.append(\"\\n\\t];\\n}\");\n      Utils.write(s, new File(\"build-gant/flex_ui_designer_swfs_build.gant\"));\n    }\n  }","commit_id":"700d9737d0e8832456beddd4cfb58627d65a47de","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private MavenExecutionRequest createExecutionRequest(String[] args)\n    throws ComponentLookupException, SettingsBuildingException, MavenExecutionRequestPopulationException, IOException,\n           InvalidRepositoryException {\n    MavenExecutionRequest request = new DefaultMavenExecutionRequest();\n    request.setGlobalSettingsFile(new File(args[0]));\n    if (!args[1].equals(\" \")) {\n      request.setUserSettingsFile(new File(args[1]));\n    }\n    request.setLocalRepository(plexusContainer.lookup(RepositorySystem.class).createLocalRepository(new File(args[2])));\n    request.setSystemProperties(System.getProperties());\n\n    request.setOffline(args[3].equals(\"t\")).setUpdateSnapshots(false).setCacheNotFound(true).setCacheTransferError(true);\n\n    plexusContainer.lookup(MavenExecutionRequestPopulator.class).populateFromSettings(request, createSettings(request));\n    \n    // IDEA-76662\n    final List<String> activeProfiles = request.getActiveProfiles();\n    int profilesLength = in.readShort();\n    if (profilesLength > 0) {\n      while (profilesLength-- > 0) {\n        activeProfiles.add(in.readUTF());\n      }\n    }\n\n    request.setWorkspaceReader(new WorkspaceReaderImpl(in, this));\n    return request;\n  }","id":30437,"modified_method":"private MavenExecutionRequest createExecutionRequest(String[] args)\n    throws ComponentLookupException, SettingsBuildingException, MavenExecutionRequestPopulationException, IOException,\n           InvalidRepositoryException {\n    MavenExecutionRequest request = new DefaultMavenExecutionRequest();\n    request.setGlobalSettingsFile(new File(args[0]));\n    if (!args[1].equals(\" \")) {\n      request.setUserSettingsFile(new File(args[1]));\n    }\n    request.setLocalRepository(plexusContainer.lookup(RepositorySystem.class).createLocalRepository(new File(args[2])));\n\n    Properties systemProperties = new Properties();\n    EnvironmentUtils.addEnvVars(systemProperties);\n    systemProperties.putAll(System.getProperties());\n    request.setSystemProperties(systemProperties);\n\n    request.setOffline(args[3].equals(\"t\")).setUpdateSnapshots(false).setCacheNotFound(true).setCacheTransferError(true);\n\n    plexusContainer.lookup(MavenExecutionRequestPopulator.class).populateFromSettings(request, createSettings(request));\n    \n    // IDEA-76662\n    final List<String> activeProfiles = request.getActiveProfiles();\n    int profilesLength = in.readShort();\n    if (profilesLength > 0) {\n      while (profilesLength-- > 0) {\n        activeProfiles.add(in.readUTF());\n      }\n    }\n\n    request.setWorkspaceReader(new WorkspaceReaderImpl(in, this));\n    return request;\n  }","commit_id":"d3eb217cf0321c1818594371769eee4f1b08213c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private String generate(final String pathname, final List<String> generators, final URL generatorJarPath) throws Exception {\n    final MavenProject project = maven.readProject(new File(pathname));\n    session.setCurrentProject(project);\n\n    MojoExecution flexmojosMojoExecution = null;\n    final List<MojoExecution> sourceProviderMojoExecutions = new ArrayList<MojoExecution>(2);\n    try {\n      boolean flexmojosGeneratorFound = false;\n      boolean buildHelperFound = false;\n      for (Plugin plugin : project.getBuildPlugins()) {\n        if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\")) {\n          if (flexmojosMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n            flexmojosMojoExecution = maven.createMojoExecution(plugin, \"compile-\" + project.getPackaging(), project);\n          }\n          else if (!flexmojosGeneratorFound && plugin.getArtifactId().equals(\"flexmojos-generator-mojo\")) {\n            sourceProviderMojoExecutions.add(maven.createMojoExecution(plugin, \"generate\", project));\n            flexmojosGeneratorFound = true;\n          }\n        }\n        else if (!buildHelperFound && plugin.getArtifactId().equals(\"build-helper-maven-plugin\") && plugin.getGroupId().equals(\"org.codehaus.mojo\")) {\n          sourceProviderMojoExecutions.add(maven.createMojoExecution(plugin, \"add-source\", project));\n          buildHelperFound = true;\n        }\n\n        if (flexmojosMojoExecution != null && sourceProviderMojoExecutions.size() == 2) {\n          break;\n        }\n      }\n\n      assert flexmojosMojoExecution != null;\n      final ClassRealm flexmojosPluginRealm = maven.getPluginRealm(flexmojosMojoExecution);\n      flexmojosPluginRealm.addURL(generatorJarPath);\n\n      final AdditionalSourcePathProvider additionalSourcePathProvider = sourceProviderMojoExecutions.isEmpty() ? null : new AdditionalSourcePathProvider(sourceProviderMojoExecutions);\n      final Mojo mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n      try {\n        //for (String configuratorClassName : generators) {\n          Class configuratorClass = flexmojosPluginRealm.loadClass(generators.get(0));\n          FlexConfigGenerator configurator = (FlexConfigGenerator)configuratorClass.getConstructor(MavenSession.class, File.class).newInstance(session, generatorOutputDirectory);\n          configurator.preGenerate(project, Flexmojos.getClassifier(mojo), additionalSourcePathProvider);\n          if (\"swc\".equals(project.getPackaging())) {\n            configurator.generate(mojo);\n          }\n          else {\n            configurator.generate(mojo, Flexmojos.getSourceFileForSwf(mojo));\n          }\n          return configurator.postGenerate(project);\n        //}\n      }\n      finally {\n        plexusContainer.release(mojo);\n      }\n    }\n    finally {\n      session.setCurrentProject(null);\n      if (flexmojosMojoExecution != null) {\n        maven.releaseMojoExecution(flexmojosMojoExecution);\n      }\n      for (MojoExecution sourceProviderMojoExecution : sourceProviderMojoExecutions) {\n        maven.releaseMojoExecution(sourceProviderMojoExecution);\n      }\n    }\n  }","id":30438,"modified_method":"private String generate(final String pathname, final List<String> generators, final URL generatorJarPath) throws Exception {\n    final MavenProject project = maven.readProject(new File(pathname));\n    session.setCurrentProject(project);\n\n    MojoExecution flexmojosMojoExecution = null;\n    try {\n      boolean flexmojosGeneratorFound = false;\n      boolean buildHelperFound = false;\n      for (Plugin plugin : project.getBuildPlugins()) {\n        if (plugin.getGroupId().equals(\"org.sonatype.flexmojos\")) {\n          if (flexmojosMojoExecution == null && plugin.getArtifactId().equals(\"flexmojos-maven-plugin\")) {\n            flexmojosMojoExecution = maven.createMojoExecution(plugin, \"compile-\" + project.getPackaging(), project);\n          }\n          else if (!flexmojosGeneratorFound && plugin.getArtifactId().equals(\"flexmojos-generator-mojo\")) {\n            AdditionalSourceRootUtil.addByGeneratorMojo(maven.createMojoExecution(plugin, \"generate\", project), session, project, getLogger());\n            flexmojosGeneratorFound = true;\n          }\n        }\n        else if (!buildHelperFound && plugin.getArtifactId().equals(\"build-helper-maven-plugin\") && plugin.getGroupId().equals(\"org.codehaus.mojo\")) {\n          AdditionalSourceRootUtil.addByBuildHelper(maven.createMojoExecution(plugin, \"add-source\", project), session, project, getLogger());\n          buildHelperFound = true;\n        }\n\n        if (flexmojosMojoExecution != null && flexmojosGeneratorFound && buildHelperFound) {\n          break;\n        }\n      }\n\n      AdditionalSourceRootUtil.addByUnknownGeneratorMojo(project);\n\n      assert flexmojosMojoExecution != null;\n      final ClassRealm flexmojosPluginRealm = maven.getPluginRealm(flexmojosMojoExecution);\n      flexmojosPluginRealm.addURL(generatorJarPath);\n\n      final Mojo mojo = mavenPluginManager.getConfiguredMojo(Mojo.class, session, flexmojosMojoExecution);\n      try {\n        Class configuratorClass = flexmojosPluginRealm.loadClass(generators.get(0));\n        FlexConfigGenerator configurator = (FlexConfigGenerator)configuratorClass.getConstructor(MavenSession.class, File.class).newInstance(session, generatorOutputDirectory);\n        configurator.preGenerate(project, Flexmojos.getClassifier(mojo));\n        if (\"swc\".equals(project.getPackaging())) {\n          configurator.generate(mojo);\n        }\n        else {\n          configurator.generate(mojo, Flexmojos.getSourceFileForSwf(mojo));\n        }\n        return configurator.postGenerate(project);\n      }\n      finally {\n        plexusContainer.release(mojo);\n      }\n    }\n    finally {\n      session.setCurrentProject(null);\n      if (flexmojosMojoExecution != null) {\n        maven.releaseMojoExecution(flexmojosMojoExecution);\n      }\n    }\n  }","commit_id":"d3eb217cf0321c1818594371769eee4f1b08213c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void preGenerate(MavenProject project, String classifier, AdditionalSourcePathProvider additionalSourcePathProvider) throws IOException {\n    this.classifier = classifier;\n    this.additionalSourcePathsProvider = additionalSourcePathProvider;\n    build = project.getBuild();\n  }","id":30439,"modified_method":"@Override\n  public void preGenerate(MavenProject project, String classifier) throws IOException {\n    this.classifier = classifier;\n    build = project.getBuild();\n  }","commit_id":"d3eb217cf0321c1818594371769eee4f1b08213c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@SuppressWarnings({\"ConstantConditions\"})\n  private <E> void build(E configuration, Class configClass, String indent, String configurationName) throws Exception {\n    boolean parentTagWritten = configurationName == null;\n\n    final Method[] methods = configClass.getMethods();\n    Arrays.sort(methods, new Comparator<Method>() {\n      @Override\n      public int compare(Method o1, Method o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n\n    for (Method method : methods) {\n      method.setAccessible(true);\n      if (method.getParameterTypes().length != 0) {\n        continue;\n      }\n\n      final String methodName = method.getName();\n      if (methodName.equals(\"getLoadConfig\") || methodName.equals(\"getDumpConfig\") || (\"metadata\".equals(configurationName) && methodName.equals(\"getDate\"))) {\n        continue;\n      }\n\n      final Object value = method.invoke(configuration);\n      if (value == null) {\n        continue;\n      }\n\n      if ((methodName.equals(\"getFixedLiteralVector\") || methodName.equals(\"getHeadlessServer\")) && !((Boolean)value)) {\n        continue;\n      }\n\n      if (!parentTagWritten) {\n        parentTagWritten = true;\n        out.append(indent, 0, indent.length() - 1).append('<').append(configurationName).append('>');\n      }\n\n      final Class<?> returnType = method.getReturnType();\n      final String name = camelCaseToSnake(methodName);\n\n      if (value instanceof IFlexConfiguration) {\n        build(value, returnType, indent + \"\\t\", name.substring(0, name.length() - 14));\n      }\n      else if (configuration instanceof IASDocConfiguration && \"footer\".equals(name)) {\n        // todo\n        throw new UnsupportedOperationException();\n      }\n      else if (value instanceof IRuntimeSharedLibraryPath || value instanceof IRuntimeSharedLibraryPath[]) {\n        final IRuntimeSharedLibraryPath[] values;\n        if (returnType.isArray()) {\n          //noinspection ConstantConditions\n          values = (IRuntimeSharedLibraryPath[])value;\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IRuntimeSharedLibraryPath[]{(IRuntimeSharedLibraryPath)value};\n        }\n\n        for (IRuntimeSharedLibraryPath arg : values) {\n          out.append(\"\\n\\t<\").append(name).append(\">\\n\\t\\t<path-element>\").append(arg.pathElement()).append(\"<\/path-element>\");\n\n          //noinspection unchecked\n          for (Map.Entry<String, String> entry : (Set<Map.Entry<String, String>>)arg.rslUrl().entrySet()) {\n            out.append(\"\\n\\t\\t<rsl-url>\").append(entry.getKey()).append(\"<\/rsl-url>\");\n\n            if (entry.getValue() != null) {\n              out.append(\"\\n\\t\\t<policy-file-url>\").append(entry.getValue()).append(\"<\/policy-file-url>\");\n            }\n          }\n\n          out.append(\"\\n\\t<\/\").append(name).append('>');\n        }\n      }\n      else if (value instanceof IFlexArgument || value instanceof IFlexArgument[]) {\n        IFlexArgument[] values;\n        Class<?> type = returnType;\n        if (type.isArray()) {\n          //noinspection ConstantConditions\n          values = (IFlexArgument[])value;\n          type = returnType.getComponentType();\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IFlexArgument[]{(IFlexArgument)value};\n          type = returnType;\n        }\n\n        Field orderField = type.getField(\"ORDER\");\n        orderField.setAccessible(true);\n        String[] order = (String[])type.getField(\"ORDER\").get(returnType);\n\n        for (IFlexArgument iFlexArgument : values) {\n          out.append(indent).append('<').append(name).append('>');\n\n          for (String argMethodName : order) {\n            Object argValue = type.getDeclaredMethod(argMethodName).invoke(iFlexArgument);\n            if (argValue == null) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Collection<?> || argValue.getClass().isArray()) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Map<?, ?>) {\n              throw new UnsupportedOperationException();\n//              Map<?, ?> map = ((Map<?, ?>) argValue);\n//              for (Object argValue1 : map.entrySet()) {\n//                @SuppressWarnings({\"unchecked\"}) Map.Entry<String, ?> entry = (Map.Entry<String, ?>) argValue1;\n//                out.append(indent).append(\"\\t<\").append(entry.getKey()).append('>').append(entry.getValue().toString()).append(\"<\/\").append(entry.getKey()).append('>');\n//              }\n            }\n            else {\n              writeTag(indent, argMethodName.equals(\"serialNumber\") ? \"serial-number\" : argMethodName, (String)argValue, name);\n            }\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (configuration instanceof IMetadataConfiguration &&\n               (name.equals(\"language\") || name.equals(\"creator\") || name.equals(\"publisher\"))) {\n        for (String v : (String[])value) {\n          out.append(indent).append(\"<\").append(name).append(\">\").append(v).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (returnType.isArray() || value instanceof Collection<?>) {\n        Object[] values;\n        if (returnType.isArray()) {\n          values = (Object[])value;\n        }\n        else {\n          values = ((Collection<?>)value).toArray();\n        }\n\n        out.append(indent).append('<').append(name);\n\n        // ability to compile pure AS3 project without themes \u2014 node must be present, but empty (relevant only for \"theme\", but we are ready for adobe surprises)\n        if (values.length == 0) {\n          out.append(\"/>\");\n        }\n        else {\n          out.append('>');\n\n          String childTagName = Utils.CHILD_TAG_NAME_MAP.get(name);\n          if (childTagName == null) {\n            childTagName = PATH_ELEMENT;\n          }\n\n          if (name.equals(SOURCE_PATH) && \"compiler\".equals(configurationName)) {\n            processSourcePaths((File[])values, indent);\n          }\n          else {\n            for (Object v : values) {\n              if (v == null) {\n                System.out.print('\\n' + childTagName + \" child value for \" + name + \" is null\\n\");\n              }\n              if (v != null) {\n                writeTag(indent, childTagName, v.toString(), name);\n              }\n            }\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else {\n        out.append(indent).append('<').append(name).append('>');\n        processValue(value.toString(), name);\n        out.append(\"<\/\").append(name).append('>');\n      }\n    }\n\n    if (parentTagWritten && configurationName != null) {\n      out.append(indent, 0, indent.length() - 1).append(\"<\/\").append(configurationName).append('>');\n    }\n  }","id":30440,"modified_method":"@SuppressWarnings({\"ConstantConditions\"})\n  private <E> void build(E configuration, Class configClass, String indent, String configurationName) throws Exception {\n    boolean parentTagWritten = configurationName == null;\n\n    final Method[] methods = configClass.getMethods();\n    Arrays.sort(methods, new Comparator<Method>() {\n      @Override\n      public int compare(Method o1, Method o2) {\n        return o1.getName().compareTo(o2.getName());\n      }\n    });\n\n    for (Method method : methods) {\n      method.setAccessible(true);\n      if (method.getParameterTypes().length != 0) {\n        continue;\n      }\n\n      final String methodName = method.getName();\n      if (methodName.equals(\"getLoadConfig\") || methodName.equals(\"getDumpConfig\") || (\"metadata\".equals(configurationName) && methodName.equals(\"getDate\"))) {\n        continue;\n      }\n\n      final Object value = method.invoke(configuration);\n      if (value == null) {\n        continue;\n      }\n\n      if ((methodName.equals(\"getFixedLiteralVector\") || methodName.equals(\"getHeadlessServer\")) && !((Boolean)value)) {\n        continue;\n      }\n\n      if (!parentTagWritten) {\n        parentTagWritten = true;\n        out.append(indent, 0, indent.length() - 1).append('<').append(configurationName).append('>');\n      }\n\n      final Class<?> returnType = method.getReturnType();\n      final String name = camelCaseToSnake(methodName);\n\n      if (value instanceof IFlexConfiguration) {\n        build(value, returnType, indent + \"\\t\", name.substring(0, name.length() - 14));\n      }\n      else if (configuration instanceof IASDocConfiguration && \"footer\".equals(name)) {\n        // todo\n        throw new UnsupportedOperationException();\n      }\n      else if (value instanceof IRuntimeSharedLibraryPath || value instanceof IRuntimeSharedLibraryPath[]) {\n        final IRuntimeSharedLibraryPath[] values;\n        if (returnType.isArray()) {\n          //noinspection ConstantConditions\n          values = (IRuntimeSharedLibraryPath[])value;\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IRuntimeSharedLibraryPath[]{(IRuntimeSharedLibraryPath)value};\n        }\n\n        for (IRuntimeSharedLibraryPath arg : values) {\n          out.append(\"\\n\\t<\").append(name).append(\">\\n\\t\\t<path-element>\").append(arg.pathElement()).append(\"<\/path-element>\");\n\n          //noinspection unchecked\n          for (Map.Entry<String, String> entry : (Set<Map.Entry<String, String>>)arg.rslUrl().entrySet()) {\n            out.append(\"\\n\\t\\t<rsl-url>\").append(entry.getKey()).append(\"<\/rsl-url>\");\n\n            if (entry.getValue() != null) {\n              out.append(\"\\n\\t\\t<policy-file-url>\").append(entry.getValue()).append(\"<\/policy-file-url>\");\n            }\n          }\n\n          out.append(\"\\n\\t<\/\").append(name).append('>');\n        }\n      }\n      else if (value instanceof IFlexArgument || value instanceof IFlexArgument[]) {\n        IFlexArgument[] values;\n        Class<?> type = returnType;\n        if (type.isArray()) {\n          //noinspection ConstantConditions\n          values = (IFlexArgument[])value;\n          type = returnType.getComponentType();\n        }\n        else {\n          //noinspection ConstantConditions\n          values = new IFlexArgument[]{(IFlexArgument)value};\n          type = returnType;\n        }\n\n        Field orderField = type.getField(\"ORDER\");\n        orderField.setAccessible(true);\n        String[] order = (String[])type.getField(\"ORDER\").get(returnType);\n\n        for (IFlexArgument iFlexArgument : values) {\n          out.append(indent).append('<').append(name).append('>');\n\n          for (String argMethodName : order) {\n            Object argValue = type.getDeclaredMethod(argMethodName).invoke(iFlexArgument);\n            if (argValue == null) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Collection<?> || argValue.getClass().isArray()) {\n              throw new UnsupportedOperationException();\n            }\n            else if (argValue instanceof Map<?, ?>) {\n              throw new UnsupportedOperationException();\n//              Map<?, ?> map = ((Map<?, ?>) argValue);\n//              for (Object argValue1 : map.entrySet()) {\n//                @SuppressWarnings({\"unchecked\"}) Map.Entry<String, ?> entry = (Map.Entry<String, ?>) argValue1;\n//                out.append(indent).append(\"\\t<\").append(entry.getKey()).append('>').append(entry.getValue().toString()).append(\"<\/\").append(entry.getKey()).append('>');\n//              }\n            }\n            else {\n              writeTag(indent, argMethodName.equals(\"serialNumber\") ? \"serial-number\" : argMethodName, (String)argValue, name);\n            }\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (configuration instanceof IMetadataConfiguration &&\n               (name.equals(\"language\") || name.equals(\"creator\") || name.equals(\"publisher\"))) {\n        for (String v : (String[])value) {\n          out.append(indent).append(\"<\").append(name).append(\">\").append(v).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else if (returnType.isArray() || value instanceof Collection<?>) {\n        Object[] values;\n        if (returnType.isArray()) {\n          values = (Object[])value;\n        }\n        else {\n          values = ((Collection<?>)value).toArray();\n        }\n\n        out.append(indent).append('<').append(name);\n\n        // ability to compile pure AS3 project without themes \u2014 node must be present, but empty (relevant only for \"theme\", but we are ready for adobe surprises)\n        if (values.length == 0) {\n          out.append(\"/>\");\n        }\n        else {\n          out.append('>');\n\n          String childTagName = Utils.CHILD_TAG_NAME_MAP.get(name);\n          if (childTagName == null) {\n            childTagName = PATH_ELEMENT;\n          }\n\n          for (Object v : values) {\n            if (v == null) {\n              System.out.print('\\n' + childTagName + \" child value for \" + name + \" is null\\n\");\n            }\n            if (v != null) {\n              writeTag(indent, childTagName, v.toString(), name);\n            }\n          }\n\n          out.append(indent).append(\"<\/\").append(name).append('>');\n        }\n      }\n      else {\n        out.append(indent).append('<').append(name).append('>');\n        processValue(value.toString(), name);\n        out.append(\"<\/\").append(name).append('>');\n      }\n    }\n\n    if (parentTagWritten && configurationName != null) {\n      out.append(indent, 0, indent.length() - 1).append(\"<\/\").append(configurationName).append('>');\n    }\n  }","commit_id":"d3eb217cf0321c1818594371769eee4f1b08213c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public MojoExecution createMojoExecution(Plugin plugin, String goal, MavenProject project) throws Exception {\n    MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor(plugin, goal, project.getRemotePluginRepositories(), session.getRepositorySession());\n    List<PluginExecution> executions = plugin.getExecutions();\n    MojoExecution mojoExecution = new MojoExecution(mojoDescriptor, executions.isEmpty() ? null : executions.get(executions.size() - 1).getId(), MojoExecution.Source.CLI);\n    plexusContainer.lookup(LifecycleExecutionPlanCalculator.class).setupMojoExecution(session, project, mojoExecution);\n    return mojoExecution;\n  }","id":30441,"modified_method":"public MojoExecution createMojoExecution(Plugin plugin, String goal, MavenProject project) throws Exception {\n    if (plugin.getVersion() == null) {\n      plugin.setVersion(plexusContainer.lookup(PluginVersionResolver.class).resolve(new DefaultPluginVersionRequest(plugin, session)).getVersion());\n    }\n\n    MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor(plugin, goal, project.getRemotePluginRepositories(), session.getRepositorySession());\n    List<PluginExecution> executions = plugin.getExecutions();\n    MojoExecution mojoExecution = new MojoExecution(mojoDescriptor, executions.isEmpty() ? null : executions.get(executions.size() - 1).getId(), MojoExecution.Source.CLI);\n    plexusContainer.lookup(LifecycleExecutionPlanCalculator.class).setupMojoExecution(session, project, mojoExecution);\n    return mojoExecution;\n  }","commit_id":"d3eb217cf0321c1818594371769eee4f1b08213c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void preGenerate(MavenProject project, String classifier, AdditionalSourcePathProvider additionalSourcePathProvider) throws IOException {\n    super.preGenerate(project, classifier, additionalSourcePathProvider);\n\n    baseDir = project.getBasedir().getPath();\n\n    localRepositoryBasedir = session.getLocalRepository().getBasedir();\n    localRepositoryBasedirLength = localRepositoryBasedir.length();\n\n    if (!listForGantGenerated) {\n      listForGantGenerated = true;\n\n      StringBuilder s = new StringBuilder(8192);\n      s.append(\"def List<SwfDescriptor> getList() {\\n\\treturn [\");\n\n      boolean isFirst = true;\n      final int absPathPrefixLength = session.getTopLevelProject().getBasedir().getPath().length();\n      for (MavenProject p : session.getProjects()) {\n        if (p.getPackaging().equals(\"swf\") || p.getPackaging().equals(\"swc\")) {\n          if (!isFirst) {\n            s.append(\", \");\n          }\n          else {\n            isFirst = false;\n          }\n\n          s.append(\"\\n\\t\\tnew SwfDescriptor(\\\"\").append(p.getArtifactId()).append(\".xml\\\", \\\"\");\n          final String pBaseDir = p.getBasedir().getPath();\n          if (session.getTopLevelProject() != p) {\n            s.append(pBaseDir.substring(absPathPrefixLength + 1));\n          }\n          else {\n            s.append(pBaseDir);\n          }\n          s.append(\"\\\", \").append(p.getPackaging().equals(\"swc\") ? \"true\" : \"false\").append(')');\n        }\n      }\n\n      s.append(\"\\n\\t];\\n}\");\n      Utils.write(s, new File(\"build-gant/flex_ui_designer_swfs_build.gant\"));\n    }\n  }","id":30442,"modified_method":"@Override\n  public void preGenerate(MavenProject project, String classifier) throws IOException {\n    super.preGenerate(project, classifier);\n\n    baseDir = project.getBasedir().getPath();\n\n    localRepositoryBasedir = session.getLocalRepository().getBasedir();\n    localRepositoryBasedirLength = localRepositoryBasedir.length();\n\n    if (!listForGantGenerated) {\n      listForGantGenerated = true;\n\n      StringBuilder s = new StringBuilder(8192);\n      s.append(\"def List<SwfDescriptor> getList() {\\n\\treturn [\");\n\n      boolean isFirst = true;\n      final int absPathPrefixLength = session.getTopLevelProject().getBasedir().getPath().length();\n      for (MavenProject p : session.getProjects()) {\n        if (p.getPackaging().equals(\"swf\") || p.getPackaging().equals(\"swc\")) {\n          if (!isFirst) {\n            s.append(\", \");\n          }\n          else {\n            isFirst = false;\n          }\n\n          s.append(\"\\n\\t\\tnew SwfDescriptor(\\\"\").append(p.getArtifactId()).append(\".xml\\\", \\\"\");\n          final String pBaseDir = p.getBasedir().getPath();\n          if (session.getTopLevelProject() != p) {\n            s.append(pBaseDir.substring(absPathPrefixLength + 1));\n          }\n          else {\n            s.append(pBaseDir);\n          }\n          s.append(\"\\\", \").append(p.getPackaging().equals(\"swc\") ? \"true\" : \"false\").append(')');\n        }\n      }\n\n      s.append(\"\\n\\t];\\n}\");\n      Utils.write(s, new File(\"build-gant/flex_ui_designer_swfs_build.gant\"));\n    }\n  }","commit_id":"d3eb217cf0321c1818594371769eee4f1b08213c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n\tpublic void deleteTrashEntry(long classPK) throws PortalException {\n\t\tDLAppLocalServiceUtil.deleteFileEntry(classPK);\n\t}","id":30443,"modified_method":"@Override\n\tpublic void deleteTrashEntry(long classPK) throws PortalException {\n\t\tRepository repository = getRepository(classPK);\n\n\t\tTrashCapability trashCapability = repository.getCapability(\n\t\t\tTrashCapability.class);\n\n\t\ttrashCapability.deleteFileEntry(repository.getFileEntry(classPK));\n\n\t\tDLAppLocalServiceUtil.deleteFileEntry(classPK);\n\t}","commit_id":"f490a17f993a05863f130850a36d1631b5e5956d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void moveTrashEntry(\n\t\t\tlong userId, long classPK, long containerModelId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tRepository repository = getRepository(classPK);\n\n\t\tDLAppHelperLocalServiceUtil.moveFolderFromTrash(\n\t\t\tuserId, repository.getFolder(classPK), containerModelId,\n\t\t\tserviceContext);\n\t}","id":30444,"modified_method":"@Override\n\tpublic void moveTrashEntry(\n\t\t\tlong userId, long classPK, long containerModelId,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tRepository repository = getRepository(classPK);\n\n\t\tTrashCapability trashCapability = repository.getCapability(\n\t\t\tTrashCapability.class);\n\n\t\tFolder folder = repository.getFolder(classPK);\n\n\t\tFolder destinationFolder = repository.getFolder(containerModelId);\n\n\t\ttrashCapability.moveFolderFromTrash(\n\t\t\tuserId, folder, destinationFolder, serviceContext);\n\t}","commit_id":"f490a17f993a05863f130850a36d1631b5e5956d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void deleteTrashEntry(long classPK) throws PortalException {\n\t\tDLFolder dlFolder = DLFolderLocalServiceUtil.getDLFolder(classPK);\n\n\t\tList<DLFileEntry> dlFileEntries =\n\t\t\tDLFileEntryLocalServiceUtil.getGroupFileEntries(\n\t\t\t\tdlFolder.getGroupId(), 0, classPK, QueryUtil.ALL_POS,\n\t\t\t\tQueryUtil.ALL_POS, null);\n\n\t\tfor (DLFileEntry dlFileEntry : dlFileEntries) {\n\t\t\tDLAppHelperLocalServiceUtil.deleteFileEntry(\n\t\t\t\tnew LiferayFileEntry(dlFileEntry));\n\t\t}\n\n\t\tDLAppHelperLocalServiceUtil.deleteFolder(new LiferayFolder(dlFolder));\n\n\t\tDLFolderLocalServiceUtil.deleteFolder(classPK, false);\n\t}","id":30445,"modified_method":"@Override\n\tpublic void deleteTrashEntry(long classPK) throws PortalException {\n\t\tRepository repository = getRepository(classPK);\n\n\t\tTrashCapability trashCapability = repository.getCapability(\n\t\t\tTrashCapability.class);\n\n\t\tDLFolder dlFolder = DLFolderLocalServiceUtil.getDLFolder(classPK);\n\n\t\tList<DLFileEntry> dlFileEntries =\n\t\t\tDLFileEntryLocalServiceUtil.getGroupFileEntries(\n\t\t\t\tdlFolder.getGroupId(), 0, classPK, QueryUtil.ALL_POS,\n\t\t\t\tQueryUtil.ALL_POS, null);\n\n\t\tfor (DLFileEntry dlFileEntry : dlFileEntries) {\n\t\t\tFileEntry fileEntry = new LiferayFileEntry(dlFileEntry);\n\n\t\t\tDLAppHelperLocalServiceUtil.deleteFileEntry(fileEntry);\n\t\t\ttrashCapability.deleteFileEntry(fileEntry);\n\t\t}\n\n\t\tFolder folder = new LiferayFolder(dlFolder);\n\n\t\tDLAppHelperLocalServiceUtil.deleteFolder(folder);\n\t\ttrashCapability.deleteFolder(folder);\n\n\t\tDLFolderLocalServiceUtil.deleteFolder(classPK, false);\n\t}","commit_id":"f490a17f993a05863f130850a36d1631b5e5956d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void restoreTrashEntry(long userId, long classPK)\n\t\tthrows PortalException {\n\n\t\tRepository repository = getRepository(classPK);\n\n\t\tDLAppHelperLocalServiceUtil.restoreFolderFromTrash(\n\t\t\tuserId, repository.getFolder(classPK));\n\t}","id":30446,"modified_method":"@Override\n\tpublic void restoreTrashEntry(long userId, long classPK)\n\t\tthrows PortalException {\n\n\t\tRepository repository = getRepository(classPK);\n\n\t\tTrashCapability trashCapability = repository.getCapability(\n\t\t\tTrashCapability.class);\n\n\t\tFolder folder = repository.getFolder(classPK);\n\n\t\ttrashCapability.restoreFolderFromTrash(userId, folder);\n\t}","commit_id":"f490a17f993a05863f130850a36d1631b5e5956d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Create a new untitled document in a new sketch window.\n   */\n  public void handleNew() {\n    try {\n      String path = createNewUntitled();\n      if (path != null) {\n        Editor editor = handleOpen(path);\n        editor.untitled = true;\n      } else {\n        System.err.println(\"untitled went null...\");\n      }\n\n    } catch (IOException e) {\n      if (activeEditor != null) {\n        activeEditor.statusError(e);\n      } else {\n        e.printStackTrace();\n      }\n    }\n  }","id":30447,"modified_method":"/**\n   * Create a new untitled document in a new sketch window.\n   */\n  public void handleNew() {\n    try {\n      String path = createNewUntitled();\n      if (path != null) {\n        Editor editor = handleOpen(path);\n        editor.untitled = true;\n      } else {\n        // happens when user gets to the end of 26 new sketches for the day\n        //System.err.println(\"untitled went null...\");\n      }\n\n    } catch (IOException e) {\n      if (activeEditor != null) {\n        activeEditor.statusError(e);\n      } else {\n        e.printStackTrace();\n      }\n    }\n  }","commit_id":"0214dba5c0cc74048a481c122bded8ec32bb4d53","url":"https://github.com/processing/processing"},{"original_method":"public boolean handle(Editor editor) throws SketchException, IOException {\n    Sketch sketch = editor.getSketch(); \n    JavaBuild build = new JavaBuild(sketch);    \n    File appletFolder = new File(sketch.getFolder(), \"applet\");\n    return build.exportApplet(appletFolder);\n  }","id":30448,"modified_method":"public boolean handle(Editor editor) throws SketchException, IOException {\n    Sketch sketch = editor.getSketch();\n    File sketchFolder = sketch.getFolder();\n    String sketchPath = sketchFolder.getAbsolutePath();\n    String uniquePath = sketchPath.substring(examplesPath.length());\n    File sketchTarget = new File(outputFolder, uniquePath);\n    \n    // copy the PDE files so that they can be pulled in by the generator script\n//    File[] files = sketchFolder.listFiles();\n//    for (File file : files) {\n//      if (file.getName().endsWith(\".pde\")) {\n//        Base.copyFile(file, new File(sketchTarget, file.getName()));\n//      }\n//    }\n    // no need to do this because the source files will be in 'applet' anyway\n    \n    // build the applet into this folder\n    File appletFolder = new File(sketchTarget, \"applet\");\n    JavaBuild build = new JavaBuild(sketch);\n    boolean result = build.exportApplet(appletFolder);\n    \n    // Just one copy of core.jar into the root\n    File coreTarget = new File(outputFolder, \"core.jar\");\n    File sketchCore = new File(appletFolder, \"core.jar\");\n    if (!coreTarget.exists()) {\n      Base.copyFile(sketchCore, coreTarget);\n    }\n    sketchCore.delete();\n    \n    new File(appletFolder, \"index.html\").delete();\n    new File(appletFolder, \"loading.gif\").delete();\n    new File(appletFolder, sketch.getName() + \".java\").delete();\n\n    return result;\n  }","commit_id":"0214dba5c0cc74048a481c122bded8ec32bb4d53","url":"https://github.com/processing/processing"},{"original_method":"public void handleFolder(File folder) {\n    File pdeFile = new File(folder, folder.getName() + \".pde\");\n    if (pdeFile.exists()) {\n      String pdePath = pdeFile.getAbsolutePath();\n      Editor editor = base.handleOpen(pdePath);\n      if (editor != null) {\n        try {\n//          System.out.println(pdePath);\n          if (handle(editor)) {\n            base.handleClose(editor, false);\n            try {\n              Thread.sleep(20);\n            } catch (InterruptedException e) { }\n          }\n        } catch (Exception e) {\n          //          errors.put(pdePath, e);\n          //          System.err.println(\"Error handling \" + pdePath);\n          //          e.printStackTrace();\n        }\n      }\n    } else {  // recurse into the folder\n      //System.out.println(\"  into \" + folder.getAbsolutePath());\n      File[] sub = folder.listFiles();\n      for (File f : sub) {\n        if (f.isDirectory()) {\n          handleFolder(f);\n        }\n      }\n    }\n  }","id":30449,"modified_method":"public void handleFolder(File folder) {\n    File pdeFile = new File(folder, folder.getName() + \".pde\");\n    if (pdeFile.exists()) {\n      String pdePath = pdeFile.getAbsolutePath();\n      Editor editor = base.handleOpen(pdePath);\n      if (editor != null) {\n        try {\n//          System.out.println(pdePath);\n          if (handle(editor)) {\n            base.handleClose(editor, false);\n            try {\n              Thread.sleep(20);\n            } catch (InterruptedException e) { }\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          //          errors.put(pdePath, e);\n          //          System.err.println(\"Error handling \" + pdePath);\n          //          e.printStackTrace();\n        }\n      }\n    } else {  // recurse into the folder\n      //System.out.println(\"  into \" + folder.getAbsolutePath());\n      File[] sub = folder.listFiles();\n      for (File f : sub) {\n        if (f.isDirectory()) {\n          handleFolder(f);\n        }\n      }\n    }\n  }","commit_id":"0214dba5c0cc74048a481c122bded8ec32bb4d53","url":"https://github.com/processing/processing"},{"original_method":"public void run() {\n    new Thread(new Runnable() { public void run() {\n//    errors = new HashMap<String, Throwable>();\n    boolean delete = Preferences.getBoolean(DELETE_TARGET);\n    Preferences.setBoolean(DELETE_TARGET, false);\n    boolean separate = Preferences.getBoolean(SEPARATE_JAR);\n    Preferences.setBoolean(SEPARATE_JAR, true);\n    \n    for (File folder : folders) {\n      if (!folder.getName().equals(\"Books\")) {\n        handleFolder(folder);\n      }\n    }\n\n    Preferences.setBoolean(DELETE_TARGET, delete);\n    Preferences.setBoolean(SEPARATE_JAR, separate);\n    } }).start();\n\n//    if (errors.size() > 0) {\n//      orig.statusError((errors.size() == 1 ? \"One sketch\" : (errors.size() + \" sketches\")) + \" had errors.\");\n//    } else {\n//      orig.statusNotice(\"Finished exporting examples.\");\n//    }\n//    for (String path : errors.keySet()) {\n//      System.err.println(\"Error: \" \n//    }\n  }","id":30450,"modified_method":"public void run() {\n    new Thread(new Runnable() { public void run() {\n      if (outputFolder.exists()) {\n        Base.showWarning(\"Try Again\", \"Please remove the examples folder from the desktop,\\n\" + \n                         \"because that's where I wanna put things.\", null);\n        return;\n      }\n//    errors = new HashMap<String, Throwable>();\n    boolean delete = Preferences.getBoolean(DELETE_TARGET);\n    Preferences.setBoolean(DELETE_TARGET, false);\n    boolean separate = Preferences.getBoolean(SEPARATE_JAR);\n    Preferences.setBoolean(SEPARATE_JAR, true);\n    \n    for (File folder : folders) {\n      if (!folder.getName().equals(\"Books\")) {\n        handleFolder(folder);\n      }\n    }\n\n    Preferences.setBoolean(DELETE_TARGET, delete);\n    Preferences.setBoolean(SEPARATE_JAR, separate);\n    orig.statusNotice(\"Finished exporting examples.\");\n    } }).start();\n\n//    if (errors.size() > 0) {\n//      orig.statusError((errors.size() == 1 ? \"One sketch\" : (errors.size() + \" sketches\")) + \" had errors.\");\n//    } else {\n//    }\n//    for (String path : errors.keySet()) {\n//      System.err.println(\"Error: \" \n//    }\n  }","commit_id":"0214dba5c0cc74048a481c122bded8ec32bb4d53","url":"https://github.com/processing/processing"},{"original_method":"public void init(Editor editor) {\n//    orig = editor;\n    base = editor.getBase();\n    Mode mode = editor.getMode();\n    folders = mode.getExampleCategoryFolders();\n  }","id":30451,"modified_method":"public void init(Editor editor) {\n    orig = editor;\n    base = editor.getBase();\n    Mode mode = editor.getMode();\n    folders = mode.getExampleCategoryFolders();\n    examplesPath = mode.getExamplesFolder().getAbsolutePath();\n\n    // Not perfect, but will work for Casey and I\n    File desktop = new File(System.getProperty(\"user.home\"), \"Desktop\");\n    outputFolder = new File(desktop, \"examples\"); \n//    webroot = new File(\"/Users/fry/coconut/processing.web\");\n//    templates = new File(webroot, \"templates\");    \n  }","commit_id":"0214dba5c0cc74048a481c122bded8ec32bb4d53","url":"https://github.com/processing/processing"},{"original_method":"public void reset() {\n        kProjectDirty = false;\n        removedKBases = new HashSet<String>();\n        addedKBases = new HashSet<String>();\n\n        removedKSessions = new HashSet<String>();\n        addedKSessions = new HashSet<String>();\n    }","id":30452,"modified_method":"public void reset() {\n        kProjectDirty = false;\n        removedKBases = new HashSet<String>();\n        addedKBases = new HashSet<String>();\n\n        removedKSessions = new HashSet<String>();\n        addedKSessions = new HashSet<String>();\n        \n        kBases = new HashMap<String, KBase>();\n        kSessions = new HashMap<String, KSession>();\n        \n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propertyChange(PropertyChangeEvent evt) {\n        if ( evt.getSource() instanceof KProjectImpl ) {\n            KProject kProject = (KProject) evt.getSource();\n            if ( \"kBases\".equals( evt.getPropertyName() ) ) {\n                Map<String, KBaseImpl> oldKBases = (Map<String, KBaseImpl>) evt.getOldValue();\n                Map<String, KBaseImpl> newKBases = (Map<String, KBaseImpl>) evt.getNewValue();\n                if ( oldKBases.size() < newKBases.size() ) {\n                    // kBase added\n                    for ( Entry<String, KBaseImpl> entry : newKBases.entrySet() ) {\n                        if ( !oldKBases.containsKey( entry.getKey() ) ) {\n                            removedKBases.remove( entry.getKey() );               \n                            addedKBases.add( entry.getKey() );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the new KBase\" );\n                } else if ( oldKBases.size() > newKBases.size() ) {\n                    // kBase removed\n                    for ( Entry<String, KBaseImpl> entry : oldKBases.entrySet() ) {\n                        if ( !newKBases.containsKey( entry.getKey() ) ) {\n                            addedKBases.remove( entry.getKey() );\n                            removedKBases.add( entry.getKey() );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the removed KBase\" );\n                }\n            } else {\n                kProjectDirty = true;\n            }\n\n        } else if ( evt.getSource() instanceof KBaseImpl ) {\n            KBaseImpl kBase = (KBaseImpl) evt.getSource();\n            if ( \"kSessions\".equals( evt.getPropertyName() ) ) {\n                Map<String, KSessionImpl> oldKSession = (Map<String, KSessionImpl>) evt.getOldValue();\n                Map<String, KSessionImpl> newKSession = (Map<String, KSessionImpl>) evt.getNewValue();\n                if ( oldKSession.size() < newKSession.size() ) {\n                    // KSession added\n                    for ( Entry<String, KSessionImpl> entry : newKSession.entrySet() ) {\n                        if ( !oldKSession.containsKey( entry.getKey() ) ) {\n                            removedKSessions.remove( entry.getKey() );\n                            addedKSessions.add( entry.getKey() );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the new KBase\" );\n                } else if ( oldKSession.size() > newKSession.size() ) {\n                    // KSession removed\n                    for ( Entry<String, KSessionImpl> entry : oldKSession.entrySet() ) {\n                        if ( !newKSession.containsKey( entry.getKey() ) ) {\n                            addedKSessions.remove( entry.getKey() ); \n                            removedKSessions.add( entry.getKey() );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the removed KBase\" );\n                }\n            } else if ( \"namespace\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = oldV + \".\" + kBase.getName();\n                String newQName = newV + \".\" + kBase.getName();\n                \n                kBase.getKProject().moveKBase( oldQName, newQName );\n\n                removedKBases.remove( newQName );\n                removedKBases.add( oldQName );\n                addedKBases.remove( oldQName );\n                addedKBases.add( newQName );\n            } else if ( \"name\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = kBase.getNamespace() + \".\" + oldV;\n                String newQName = kBase.getNamespace() + \".\" + newV;\n                \n                kBase.getKProject().moveKBase( oldQName, newQName );\n\n                removedKBases.remove( newQName );                \n                removedKBases.add( oldQName );\n                addedKBases.remove( oldQName );\n                addedKBases.add( newQName );\n            } else {\n                addedKBases.add( kBase.getQName() );\n            }\n\n        } else if ( evt.getSource() instanceof KSessionImpl ) {\n            KSessionImpl kSession = (KSessionImpl) evt.getSource();\n            if ( \"namespace\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = oldV + \".\" + kSession.getName();\n                String newQName = newV + \".\" + kSession.getName();\n                \n                kSession.getKBase().moveKSession( oldQName, newQName );\n\n                removedKSessions.remove( newQName );\n                removedKSessions.add( oldQName );\n                addedKSessions.remove( oldQName );\n                addedKSessions.add( newQName );\n            } else if ( \"name\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = kSession.getNamespace() + \".\" + oldV;\n                String newQName = kSession.getNamespace() + \".\" + newV;\n                \n                kSession.getKBase().moveKSession( oldQName, newQName );\n\n                removedKSessions.remove( newQName );\n                removedKSessions.add( oldQName );\n                addedKSessions.remove( oldQName );\n                addedKSessions.add( newQName );\n            } else {\n                addedKSessions.add( kSession.getQName() );\n            }\n        }\n    }","id":30453,"modified_method":"public void propertyChange(PropertyChangeEvent evt) {\n        if ( evt.getSource() instanceof KProjectImpl ) {\n            KProject kProject = (KProject) evt.getSource();\n            if ( \"kBases\".equals( evt.getPropertyName() ) ) {\n                Map<String, KBaseImpl> oldKBases = (Map<String, KBaseImpl>) evt.getOldValue();\n                Map<String, KBaseImpl> newKBases = (Map<String, KBaseImpl>) evt.getNewValue();\n                if ( oldKBases.size() < newKBases.size() ) {\n                    // kBase added\n                    for ( Entry<String, KBaseImpl> entry : newKBases.entrySet() ) {\n                        if ( !oldKBases.containsKey( entry.getKey() ) ) {\n                            removedKBases.remove( entry.getKey() );               \n                            addedKBases.add( entry.getKey() );\n                            kBases.put( entry.getKey(), newKBases.get( entry.getKey() ) );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the new KBase\" );\n                } else if ( oldKBases.size() > newKBases.size() ) {\n                    // kBase removed\n                    for ( Entry<String, KBaseImpl> entry : oldKBases.entrySet() ) {\n                        if ( !newKBases.containsKey( entry.getKey() ) ) {\n                            addedKBases.remove( entry.getKey() );\n                            removedKBases.add( entry.getKey() );\n                            kBases.put( entry.getKey(), oldKBases.get( entry.getKey() ) );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the removed KBase\" );\n                }\n            } else {\n                kProjectDirty = true;\n            }\n\n        } else if ( evt.getSource() instanceof KBaseImpl ) {\n            KBaseImpl kBase = (KBaseImpl) evt.getSource();\n            if ( \"kSessions\".equals( evt.getPropertyName() ) ) {\n                Map<String, KSessionImpl> oldKSession = (Map<String, KSessionImpl>) evt.getOldValue();\n                Map<String, KSessionImpl> newKSession = (Map<String, KSessionImpl>) evt.getNewValue();\n                if ( oldKSession.size() < newKSession.size() ) {\n                    // KSession added\n                    for ( Entry<String, KSessionImpl> entry : newKSession.entrySet() ) {\n                        if ( !oldKSession.containsKey( entry.getKey() ) ) {\n                            removedKSessions.remove( entry.getKey() );\n                            addedKSessions.add( entry.getKey() );\n                            kSessions.put( entry.getKey(), newKSession.get( entry.getKey() ) );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the new KBase\" );\n                } else if ( oldKSession.size() > newKSession.size() ) {\n                    // KSession removed\n                    for ( Entry<String, KSessionImpl> entry : oldKSession.entrySet() ) {\n                        if ( !newKSession.containsKey( entry.getKey() ) ) {\n                            addedKSessions.remove( entry.getKey() ); \n                            removedKSessions.add( entry.getKey() );\n                            kSessions.put( entry.getKey(), oldKSession.get( entry.getKey() ) );\n                            return;\n                        }\n                    }\n                    throw new IllegalStateException( \"Maps are different sizes, yet we can't find the removed KBase\" );\n                }\n            } else if ( \"namespace\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = oldV + \".\" + kBase.getName();\n                String newQName = newV + \".\" + kBase.getName();\n                \n                kBase.getKProject().moveKBase( oldQName, newQName );\n\n                removedKBases.remove( newQName );\n                removedKBases.add( oldQName );\n                addedKBases.remove( oldQName );\n                addedKBases.add( newQName );\n            } else if ( \"name\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = kBase.getNamespace() + \".\" + oldV;\n                String newQName = kBase.getNamespace() + \".\" + newV;\n                \n                kBase.getKProject().moveKBase( oldQName, newQName );\n\n                removedKBases.remove( newQName );                \n                removedKBases.add( oldQName );\n                addedKBases.remove( oldQName );\n                addedKBases.add( newQName );\n            } else {\n                addedKBases.add( kBase.getQName() );\n            }\n\n        } else if ( evt.getSource() instanceof KSessionImpl ) {\n            KSessionImpl kSession = (KSessionImpl) evt.getSource();\n            if ( \"namespace\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = oldV + \".\" + kSession.getName();\n                String newQName = newV + \".\" + kSession.getName();\n                \n                kSession.getKBase().moveKSession( oldQName, newQName );\n\n                removedKSessions.remove( newQName );\n                removedKSessions.add( oldQName );\n                addedKSessions.remove( oldQName );\n                addedKSessions.add( newQName );\n            } else if ( \"name\".equals( evt.getPropertyName() ) ) {\n                String oldV = (String) evt.getOldValue();\n                String newV = (String) evt.getNewValue();\n\n                String oldQName = kSession.getNamespace() + \".\" + oldV;\n                String newQName = kSession.getNamespace() + \".\" + newV;\n                \n                kSession.getKBase().moveKSession( oldQName, newQName );\n\n                removedKSessions.remove( newQName );\n                removedKSessions.add( oldQName );\n                addedKSessions.remove( oldQName );\n                addedKSessions.add( newQName );\n            } else {\n                addedKSessions.add( kSession.getQName() );\n            }\n        }\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void commitAddedKBase(KBase kbase) {        \n        // create new KBase root folder\n        Folder rootFld = fs.getFolder( kProject.getKBasesPath() + \"/\"  + kbase.getQName() );\n        rootFld.create();\n        \n        // create new KBase folder for CDI Qualifier and Producer\n        Folder namespaceFld = fs.getFolder( rootFld.getPath().toPortableString() + \"/\"  + kbase.getNamespace().replace( '.', '/' ) );\n        namespaceFld.create();\n        \n        // generate KBase root properties file\n        String filesStr = GenerateKBaseProjectFiles.generateKBaseFiles( kProject, kbase, fs );\n        File rootFile = rootFld.getFile( kbase.getQName() + \".files.dat\" );\n        try {\n            if ( !rootFile.exists() ) {\n                rootFile.create( new ByteArrayInputStream( filesStr.getBytes() ) );\n            } else {\n                rootFile.setContents( new ByteArrayInputStream( filesStr.getBytes() ) );\n            }\n        } catch ( IOException e ) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        // generate Qualifiers\n        String qualifierStr = GenerateKBaseProjectFiles.generateQualifier( kbase );\n        File qualifieFile = namespaceFld.getFile( kbase.getName() + \".java\" );\n        try {\n            if ( !qualifieFile.exists() ) {\n                qualifieFile.create( new ByteArrayInputStream( qualifierStr.getBytes() ) );\n            } else {\n                qualifieFile.setContents( new ByteArrayInputStream( qualifierStr.getBytes() ) );\n            }\n        } catch ( IOException e ) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        // generate Producers    \n        String producerStr = GenerateKBaseProjectFiles.generateProducer( kbase );\n        File producerFile = namespaceFld.getFile( kbase.getName() + \"Producer.java\" );\n        try {\n            if ( !producerFile.exists() ) {\n                producerFile.create( new ByteArrayInputStream( producerStr.getBytes() ) );\n            } else {\n                producerFile.setContents( new ByteArrayInputStream( producerStr.getBytes() ) );\n            }\n        } catch ( IOException e ) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }        \n        \n        commitAddedKsessions(rootFld, kbase);\n    }","id":30454,"modified_method":"public void commitAddedKBase(KBase kbase) {\n        // create new KBase root folder\n        Folder rootFld = fs.getFolder( kProject.getKBasesPath() + \"/\" + kbase.getQName() );\n        rootFld.create();\n\n        // create new KBase folder for CDI Qualifier and Producer\n        Folder namespaceFld = fs.getFolder( rootFld.getPath().toPortableString() + \"/\" + kbase.getNamespace().replace( '.', '/' ) );\n        namespaceFld.create();\n\n        // generate KBase root properties file\n        String filesStr = GenerateKBaseProjectFiles.generateKBaseFiles( kProject, kbase, fs );\n        File rootFile = rootFld.getFile( kbase.getQName() + \".files.dat\" );\n        try {\n            if ( !rootFile.exists() ) {\n                rootFile.create( new ByteArrayInputStream( filesStr.getBytes() ) );\n            } else {\n                rootFile.setContents( new ByteArrayInputStream( filesStr.getBytes() ) );\n            }\n        } catch ( IOException e ) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        // generate Qualifiers\n        String qualifierStr = GenerateKBaseProjectFiles.generateQualifier( kbase );\n        File qualifieFile = namespaceFld.getFile( kbase.getName() + \".java\" );\n        try {\n            if ( !qualifieFile.exists() ) {\n                qualifieFile.create( new ByteArrayInputStream( qualifierStr.getBytes() ) );\n            } else {\n                qualifieFile.setContents( new ByteArrayInputStream( qualifierStr.getBytes() ) );\n            }\n        } catch ( IOException e ) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        // generate Producers    \n        String producerStr = GenerateKBaseProjectFiles.generateProducer( kbase );\n        File producerFile = namespaceFld.getFile( kbase.getName() + \"Producer.java\" );\n        try {\n            if ( !producerFile.exists() ) {\n                producerFile.create( new ByteArrayInputStream( producerStr.getBytes() ) );\n            } else {\n                producerFile.setContents( new ByteArrayInputStream( producerStr.getBytes() ) );\n            }\n        } catch ( IOException e ) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        //commitAddedKsessions( rootFld, kbase );\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void commit(KProject kproject, KProjectChangeLog changeLog, FileSystem fs) {\n        KProjectChangeLogCommiter committer = new KProjectChangeLogCommiter(kproject, changeLog, fs);\n        \n        committer.commitAddedKBases();\n    }","id":30455,"modified_method":"public static void commit(KProject kproject,\n                              KProjectChangeLog changeLog,\n                              FileSystem fs) {\n        KProjectChangeLogCommiter committer = new KProjectChangeLogCommiter( kproject, changeLog, fs );\n\n        committer.commitRemovedKBases();\n        committer.commitAddedKBases();\n        \n        committer.commitRemovedKSessions();\n        committer.commitAddedKSessions();        \n\n        changeLog.reset();\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void commitRemovedKBases() {\n        for ( String kBaseQName: changeLog.getRemovedKBases() ) {\n            Folder rootFld = fs.getFolder( kProject.getKBasesPath() + \"/\"  + kBaseQName );\n            //commitRemovedKBase( kProject.getKBases().get( kBaseQName ) );\n        }\n    }","id":30456,"modified_method":"public void commitRemovedKBases() {\n        for ( String kBaseQName : changeLog.getRemovedKBases() ) {\n            commitRemovedKBase( kProject.getKBases().get( kBaseQName ) );\n        }\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void commitAddedKsessions(Folder rootFld, KBase kBase) {\n        for ( KSession kSession : kBase.getKSessions().values() ) {\n            commitAddedKSession( rootFld, kBase, kSession );\n        }\n    }","id":30457,"modified_method":"public void commitRemovedKSession(Folder rootFld,\n                                      KBase kBase,\n                                      KSession kSession) {\n        // @TODO currently leaves nested folders, need to delete, if no nested KSession folders.\n        // get KSession folder for CDI Qualifier and Producer\n        Folder namespaceFld = fs.getFolder( rootFld.getPath().toPortableString() + \"/\" + kSession.getNamespace().replace( '.', '/' ) );\n\n        // generate Qualifiers\n        File qualifieFile = namespaceFld.getFile( kSession.getName() + \".java\" );\n        fs.remove( qualifieFile );\n\n        // generate Producer\n        File producerFile = namespaceFld.getFile( kSession.getName() + \"Producer.java\" );\n        fs.remove( producerFile );\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void test1() throws IOException, ClassNotFoundException, InterruptedException {\n        KProject kproj = new KProjectImpl();       \n        \n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );        \n        \n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n        \n        List<String> files = asList( new String[] { \"org/test1/rule1.drl\", \"org/test1/rule2.drl\" } );\n        \n        KBase kbase1 = kproj.newKBase(\"org.test1\", \"KBase1\");\n        kbase1.setFiles( files );\n        kbase1.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        kbase1.setEqualsBehavior( AssertBehaviorOption.EQUALITY );\n        kbase1.setEventProcessingMode( EventProcessingOption.STREAM );\n        \n        KSession ksession1 = kbase1.newKSession( \"org.test1\", \"KSession1\" );\n        ksession1.setType( \"stateless\" );\n        ksession1.setAnnotations(  asList( \"@ApplicationScoped; @Inject\" ) );\n        ksession1.setClockType( ClockTypeOption.get( \"realtime\" ) );\n        \n\n        KSession ksession2 = kbase1.newKSession( \"org.test1\", \"KSession2\" );\n        ksession2.setType( \"stateful\" );\n        ksession2.setAnnotations(  asList( \"@ApplicationScoped; @Inject\" ) );\n        ksession2.setClockType( ClockTypeOption.get( \"pseudo\" ) );\n        \n        \n        files = asList( new String[] { \"org/test2/rule1.drl\", \"org/test2/rule2.drl\" } );       \n        KBase kbase2 = kproj.newKBase(\"org.test2\", \"KBase2\");\n        kbase2.setFiles( files );\n        \n        kbase2.setAnnotations( asList( \"@ApplicationScoped\" ) );\n        kbase2.setEqualsBehavior( AssertBehaviorOption.IDENTITY );\n        kbase2.setEventProcessingMode( EventProcessingOption.CLOUD );\n        \n        KSession ksession3 = kbase2.newKSession( \"org.test2\", \"KSession3\" );\n        ksession3.setType( \"stateful\" );\n        ksession3.setAnnotations(  asList( \"@ApplicationScoped\" ) );\n        ksession3.setClockType( ClockTypeOption.get( \"pseudo\" ) );  \n        \n        \n//        System.out.println( kproj);\n//        \n//        XStream xstream = new XStream();\n//        String string = xstream.toXML( kproj );\n//        System.out.println( string );\n//      \n//      printFs(  mfs, mfs.getProjectFolder() );\n//                \n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );     \n       \n        String kbase1R1 = getRule( \"org.test1\", \"rule1\" );\n        String kbase1R2 = getRule( \"org.test1\", \"rule2\" );\n        \n        String kbase2R1 = getRule( \"org.test2\", \"rule1\" );\n        String kbase2R2 = getRule( \"org.test2\", \"rule2\" );        \n        \n        String fldKB1 = kproj.getKBasesPath() + \"/\" + kbase1.getQName() + \"/\" + kbase1.getNamespace().replace( '.', '/' );\n        String fldKB2 = kproj.getKBasesPath() + \"/\" + kbase2.getQName() + \"/\" + kbase2.getNamespace().replace( '.', '/' );\n        \n        mfs.getFolder( fldKB1 ).create();\n        mfs.getFolder( fldKB2 ).create();\n        \n        mfs.getFile( fldKB1 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kbase1R1.getBytes() ) );\n        mfs.getFile( fldKB1 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kbase1R2.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kbase2R1.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kbase2R2.getBytes() ) );\n        \n        MemoryFileSystem trgMfs = new MemoryFileSystem();\n        MemoryFileSystem srcMfs = mfs;        \n      \n        \n        Folder fld1 = trgMfs.getFolder( \"org/drools/cdi/test\" );\n        fld1.create();\n        File fle1 = fld1.getFile( \"KProjectTestClassImpl.java\" );        \n        fle1.create( new ByteArrayInputStream( generateKProjectTestClassImpl(kproj).getBytes() ) );        \n  \n        List<String> inputClasses = new ArrayList<String>();\n        inputClasses.add( \"org/drools/cdi/test/KProjectTestClassImpl.java\" );\n        \n        final List<String> classes = compile(kproj, srcMfs, trgMfs, inputClasses);\n        \n        MemoryFileSystemClassLoader classLoader = new MemoryFileSystemClassLoader(trgMfs);\n                       \n        ClassLoader origCl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader( classLoader );\n            \n            Weld weldContainer = new Weld() {\n                @Override\n                protected Deployment createDeployment(ResourceLoader resourceLoader,\n                                                      Bootstrap bootstrap) {\n                    return new TestWeldSEDeployment(resourceLoader, bootstrap, classes); \n                }\n            };\n            WeldContainer weld = weldContainer.initialize();            \n            KProjectTestClass bean = weld.instance().select(KProjectTestClass.class).get();\n          \n            assertNotNull( bean.getKBase1() );\n            assertNotNull( bean.getKBase2() );\n            \n            List<String> list = new ArrayList<String>();\n            \n            StatelessKnowledgeSession stlsKsession = bean.getKBase1Ksession1() ;\n            stlsKsession.setGlobal( \"list\", list );\n            stlsKsession.execute( \"dummy\" );\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n            \n            list.clear();\n            StatefulKnowledgeSession stflKsession = bean.getKBase1Ksession2() ;\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n            \n            \n            list.clear();\n            stflKsession = bean.getKBase2Ksession3() ;\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n            \n            assertTrue( list.contains( \"org.test2:rule1\" ) );\n            assertTrue( list.contains( \"org.test2:rule2\" ) );          \n            \n            weldContainer.shutdown();\n     \n        } finally {\n            Thread.currentThread().setContextClassLoader( origCl );\n        }\n    }","id":30458,"modified_method":"@Test\n    public void test1() throws IOException, ClassNotFoundException, InterruptedException {\n        KProject kproj = new KProjectImpl();       \n        \n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );        \n        \n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n        \n        List<String> files = asList( new String[] { \"org/test1/rule1.drl\", \"org/test1/rule2.drl\" } );\n        \n        KBase kBase1 = kproj.newKBase(\"org.test1\", \"kBase1\");\n        kBase1.setFiles( files );\n        kBase1.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        kBase1.setEqualsBehavior( AssertBehaviorOption.EQUALITY );\n        kBase1.setEventProcessingMode( EventProcessingOption.STREAM );\n        \n        KSession ksession1 = kBase1.newKSession( \"org.test1\", \"KSession1\" );\n        ksession1.setType( \"stateless\" );\n        ksession1.setAnnotations(  asList( \"@ApplicationScoped; @Inject\" ) );\n        ksession1.setClockType( ClockTypeOption.get( \"realtime\" ) );\n        \n\n        KSession ksession2 = kBase1.newKSession( \"org.test1\", \"KSession2\" );\n        ksession2.setType( \"stateful\" );\n        ksession2.setAnnotations(  asList( \"@ApplicationScoped; @Inject\" ) );\n        ksession2.setClockType( ClockTypeOption.get( \"pseudo\" ) );\n        \n        \n        files = asList( new String[] { \"org/test2/rule1.drl\", \"org/test2/rule2.drl\" } );       \n        KBase kbase2 = kproj.newKBase(\"org.test2\", \"KBase2\");\n        kbase2.setFiles( files );\n        \n        kbase2.setAnnotations( asList( \"@ApplicationScoped\" ) );\n        kbase2.setEqualsBehavior( AssertBehaviorOption.IDENTITY );\n        kbase2.setEventProcessingMode( EventProcessingOption.CLOUD );\n        \n        KSession ksession3 = kbase2.newKSession( \"org.test2\", \"KSession3\" );\n        ksession3.setType( \"stateful\" );\n        ksession3.setAnnotations(  asList( \"@ApplicationScoped\" ) );\n        ksession3.setClockType( ClockTypeOption.get( \"pseudo\" ) );  \n        \n        \n//        System.out.println( kproj);\n//        \n//        XStream xstream = new XStream();\n//        String string = xstream.toXML( kproj );\n//        System.out.println( string );\n//      \n//      printFs(  mfs, mfs.getProjectFolder() );\n//                \n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );     \n       \n        String kBase1R1 = getRule( \"org.test1\", \"rule1\" );\n        String kBase1R2 = getRule( \"org.test1\", \"rule2\" );\n        \n        String kbase2R1 = getRule( \"org.test2\", \"rule1\" );\n        String kbase2R2 = getRule( \"org.test2\", \"rule2\" );        \n        \n        String fldKB1 = kproj.getKBasesPath() + \"/\" + kBase1.getQName() + \"/\" + kBase1.getNamespace().replace( '.', '/' );\n        String fldKB2 = kproj.getKBasesPath() + \"/\" + kbase2.getQName() + \"/\" + kbase2.getNamespace().replace( '.', '/' );\n        \n        mfs.getFolder( fldKB1 ).create();\n        mfs.getFolder( fldKB2 ).create();\n        \n        mfs.getFile( fldKB1 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kBase1R1.getBytes() ) );\n        mfs.getFile( fldKB1 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kBase1R2.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule1.drl\" ).create( new ByteArrayInputStream( kbase2R1.getBytes() ) );\n        mfs.getFile( fldKB2 + \"/rule2.drl\" ).create( new ByteArrayInputStream( kbase2R2.getBytes() ) );\n        \n        MemoryFileSystem trgMfs = new MemoryFileSystem();\n        MemoryFileSystem srcMfs = mfs;        \n      \n        \n        Folder fld1 = trgMfs.getFolder( \"org/drools/cdi/test\" );\n        fld1.create();\n        File fle1 = fld1.getFile( \"KProjectTestClassImpl.java\" );        \n        fle1.create( new ByteArrayInputStream( generateKProjectTestClassImpl(kproj).getBytes() ) );        \n  \n        List<String> inputClasses = new ArrayList<String>();\n        inputClasses.add( \"org/drools/cdi/test/KProjectTestClassImpl.java\" );\n        \n        final List<String> classes = compile(kproj, srcMfs, trgMfs, inputClasses);\n        \n        MemoryFileSystemClassLoader classLoader = new MemoryFileSystemClassLoader(trgMfs);\n                       \n        ClassLoader origCl = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader( classLoader );\n            \n            Weld weldContainer = new Weld() {\n                @Override\n                protected Deployment createDeployment(ResourceLoader resourceLoader,\n                                                      Bootstrap bootstrap) {\n                    return new TestWeldSEDeployment(resourceLoader, bootstrap, classes); \n                }\n            };\n            WeldContainer weld = weldContainer.initialize();            \n            KProjectTestClass bean = weld.instance().select(KProjectTestClass.class).get();\n          \n            assertNotNull( bean.getKBase1() );\n            assertNotNull( bean.getKBase2() );\n            \n            List<String> list = new ArrayList<String>();\n            \n            StatelessKnowledgeSession stlsKsession = bean.getKBase1Ksession1() ;\n            stlsKsession.setGlobal( \"list\", list );\n            stlsKsession.execute( \"dummy\" );\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n            \n            list.clear();\n            StatefulKnowledgeSession stflKsession = bean.getKBase1Ksession2() ;\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n            assertTrue( list.contains( \"org.test1:rule1\" ) );\n            assertTrue( list.contains( \"org.test1:rule2\" ) );\n            \n            \n            list.clear();\n            stflKsession = bean.getKBase2Ksession3() ;\n            stflKsession.setGlobal( \"list\", list );\n            stflKsession.fireAllRules();\n            assertEquals( 2, list.size() );\n            \n            assertTrue( list.contains( \"org.test2:rule1\" ) );\n            assertTrue( list.contains( \"org.test2:rule2\" ) );          \n            \n            weldContainer.shutdown();\n     \n        } finally {\n            Thread.currentThread().setContextClassLoader( origCl );\n        }\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String generateKProjectTestClassImpl(KProject kproject) {        \n        String s = \"package org.drools.cdi.test;\\n\" +\n                \"import javax.inject.Named;\\n\" +\n                \"import javax.inject.Inject;\\n\" +\n                \"import javax.inject.Inject;\\n\" +\n                \"import javax.enterprise.event.Observes;\\n\" +\n                \"import org.jboss.weld.environment.se.events.ContainerInitialized;\\n\" +\n                \"import \" + KnowledgeBase.class.getName() + \";\\n\" +\n                \"import \" + StatefulKnowledgeSession.class.getName() + \";\\n\" +\n                \"import \" + StatelessKnowledgeSession.class.getName() + \";\\n\" +\n                \"import org.test1.KBase1;\\n\" +\n                \"import org.test1.KSession1;\\n\" +\n                \"import org.test1.KSession2;\\n\" +\n                \"import org.test2.KSession3;\\n\" +\n                \"import org.test2.KBase2;\\n\" +\n                \n                \"public class KProjectTestClassImpl implements org.drools.kproject.KProjectTestClass {\\n\" +\n                \"    private @Inject @KBase1 KnowledgeBase kBase1; \\n\" +\n                \"    public KnowledgeBase getKBase1() {\\n\" +\n                \"        return kBase1;\\n\" +\n                \"    }\\n\" +\n                \"    private @Inject @KBase2 KnowledgeBase kBase2; \\n\" +\n                \"    public KnowledgeBase getKBase2() {\\n\" +\n                \"        return kBase2;\\n\" +\n                \"    }\\n\" +      \n                \"    private @Inject @KSession1 StatelessKnowledgeSession kBase1kSession1; \\n\" +\n                \"    public StatelessKnowledgeSession getKBase1Ksession1() {\\n\" +\n                \"        return kBase1kSession1;\\n\" +\n                \"    }\\n\" +  \n                \"    private @Inject @KSession2 StatefulKnowledgeSession kBase1kSession2; \\n\" +\n                \"    public StatefulKnowledgeSession getKBase1Ksession2() {\\n\" +\n                \"        return kBase1kSession2;\\n\" +\n                \"    }\\n\" +      \n                \"    private @Inject @KSession3 StatefulKnowledgeSession kBase2kSession3; \\n\" +\n                \"    public StatefulKnowledgeSession getKBase2Ksession3() {\\n\" +\n                \"        return kBase2kSession3;\\n\" +\n                \"    }\\n\" +                   \n                \"}\\n\";\n\n     return s;        \n    }","id":30459,"modified_method":"public String generateKProjectTestClassImpl(KProject kproject) {        \n        String s = \"package org.drools.cdi.test;\\n\" +\n                \"import javax.inject.Named;\\n\" +\n                \"import javax.inject.Inject;\\n\" +\n                \"import javax.inject.Inject;\\n\" +\n                \"import javax.enterprise.event.Observes;\\n\" +\n                \"import org.jboss.weld.environment.se.events.ContainerInitialized;\\n\" +\n                \"import \" + KnowledgeBase.class.getName() + \";\\n\" +\n                \"import \" + StatefulKnowledgeSession.class.getName() + \";\\n\" +\n                \"import \" + StatelessKnowledgeSession.class.getName() + \";\\n\" +\n                \"import org.test1.kBase1;\\n\" +\n                \"import org.test1.KSession1;\\n\" +\n                \"import org.test1.KSession2;\\n\" +\n                \"import org.test2.KSession3;\\n\" +\n                \"import org.test2.KBase2;\\n\" +\n                \n                \"public class KProjectTestClassImpl implements org.drools.kproject.KProjectTestClass {\\n\" +\n                \"    private @Inject @kBase1 KnowledgeBase kBase1; \\n\" +\n                \"    public KnowledgeBase getKBase1() {\\n\" +\n                \"        return kBase1;\\n\" +\n                \"    }\\n\" +\n                \"    private @Inject @KBase2 KnowledgeBase kBase2; \\n\" +\n                \"    public KnowledgeBase getKBase2() {\\n\" +\n                \"        return kBase2;\\n\" +\n                \"    }\\n\" +      \n                \"    private @Inject @KSession1 StatelessKnowledgeSession kBase1kSession1; \\n\" +\n                \"    public StatelessKnowledgeSession getKBase1Ksession1() {\\n\" +\n                \"        return kBase1kSession1;\\n\" +\n                \"    }\\n\" +  \n                \"    private @Inject @KSession2 StatefulKnowledgeSession kBase1kSession2; \\n\" +\n                \"    public StatefulKnowledgeSession getKBase1Ksession2() {\\n\" +\n                \"        return kBase1kSession2;\\n\" +\n                \"    }\\n\" +      \n                \"    private @Inject @KSession3 StatefulKnowledgeSession kBase2kSession3; \\n\" +\n                \"    public StatefulKnowledgeSession getKBase2Ksession3() {\\n\" +\n                \"        return kBase2kSession3;\\n\" +\n                \"    }\\n\" +                   \n                \"}\\n\";\n\n     return s;        \n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testAddRemove() throws IOException, ClassNotFoundException, InterruptedException, InstantiationException, IllegalAccessException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {\n        KProject kproj = new KProjectImpl();       \n        \n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );        \n        \n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n        \n        List<String> files = asList( new String[] {  } );\n        \n        KBase kbase1 = kproj.newKBase(\"org.test1\", \"KBase1\");\n        kbase1.setFiles( files );\n        kbase1.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        kbase1.setEqualsBehavior( AssertBehaviorOption.EQUALITY );\n        kbase1.setEventProcessingMode( EventProcessingOption.STREAM );               \n               \n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n        \n        MemoryFile mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        String s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.STREAM\" ) );\n        \n        kbase1.setEventProcessingMode( EventProcessingOption.CLOUD );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs ); \n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.CLOUD\" ) );\n        \n        kproj.removeKBase( kbase1.getQName() );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.KBase1/org/test1/KBase1Producer.java\" );\n        assertFalse( mf.exists() );\n        \n//        String fldKB1 = kproj.getKBasesPath() + \"/\" + kbase1.getQName() + \"/\" + kbase1.getNamespace().replace( '.', '/' );\n//        mfs.getFolder( fldKB1 ).create();\n//               \n//        MemoryFileSystem srcMfs = mfs;   \n//        MemoryFileSystem trgMfs = new MemoryFileSystem();\n//                          \n//        compile(kproj, srcMfs, trgMfs, new ArrayList<String>());\n//        MemoryFileSystemClassLoader classLoader = new MemoryFileSystemClassLoader(trgMfs);\n//        \n//        ClassLoader origCl = Thread.currentThread().getContextClassLoader();\n//        try {\n//            Thread.currentThread().setContextClassLoader( classLoader );\n//            Class cls1 = classLoader.loadClass( \"org.test1.KBase1Producer\" );\n//            Object o = cls1.newInstance();\n//            \n//            KnowledgeBaseImpl kbase = ( KnowledgeBaseImpl ) o.getClass().getMethod( \"newKnowledgeBase\", new Class[] {}  ).invoke( o, new Object[0] );\n//            assertEquals( EventProcessingOption.STREAM, ((ReteooRuleBase) kbase.getRuleBase()).getConfiguration().getEventProcessingMode() );\n//        } finally {\n//            Thread.currentThread().setContextClassLoader( origCl );\n//        }       \n//        \n//        kbase1.setEventProcessingMode( EventProcessingOption.CLOUD );\n//        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n//        \n//        trgMfs = new MemoryFileSystem();\n//        \n//        compile(kproj, srcMfs, trgMfs, new ArrayList<String>());\n//        classLoader = new MemoryFileSystemClassLoader(trgMfs);\n//        \n//        origCl = Thread.currentThread().getContextClassLoader();\n//        try {\n//            Thread.currentThread().setContextClassLoader( classLoader );\n//            Class cls1 = classLoader.loadClass( \"org.test1.KBase1Producer\" );\n//            Object o = cls1.newInstance();\n//            \n//            KnowledgeBaseImpl kbase = ( KnowledgeBaseImpl ) o.getClass().getMethod( \"newKnowledgeBase\", new Class[] {}  ).invoke( o, new Object[0] );\n//            assertEquals( EventProcessingOption.CLOUD, ((ReteooRuleBase) kbase.getRuleBase()).getConfiguration().getEventProcessingMode() );\n//        } finally {\n//            Thread.currentThread().setContextClassLoader( origCl );\n//        } \n//        \n//        kproj.removeKBase( kbase1.getQName() );\n//        trgMfs = new MemoryFileSystem();\n//        \n//        //printFs(  mfs, mfs.getProjectFolder() );\n//        \n//        compile(kproj, srcMfs, trgMfs, Arrays.asList( new String[] { \"org/test1/KBase1Producer.java\", \"org/test1/KBase1.java\" } ) );\n//        classLoader = new MemoryFileSystemClassLoader(trgMfs);\n//        \n//        origCl = Thread.currentThread().getContextClassLoader();\n//        try {\n//            Thread.currentThread().setContextClassLoader( classLoader );\n//            try {\n//                Class cls1 = classLoader.loadClass( \"org.test1.KBase1Producer\" );\n//                fail( \"Should not find the class\" );\n//            } catch( Exception e ) {\n//                \n//            }\n//        } finally {\n//            Thread.currentThread().setContextClassLoader( origCl );\n//        }         \n    }","id":30460,"modified_method":"@Test\n    public void testAddModifyRemoveKBase() throws IOException, ClassNotFoundException, InterruptedException, InstantiationException, IllegalAccessException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {\n        KProject kproj = new KProjectImpl();       \n        \n        KProjectChangeLog klog = new KProjectChangeLog();\n        kproj.setListener( klog );        \n        \n        kproj.setKProjectPath( \"src/main/resources/\" );\n        kproj.setKBasesPath( \"src/kbases\" );\n        \n        List<String> files = asList( new String[] {  } );\n        \n        // create and add the KBase\n        KBase kBase1 = kproj.newKBase(\"org.test1\", \"kBase1\");\n        kBase1.setFiles( files );\n        kBase1.setAnnotations( asList( \"@ApplicationScoped; @Inject\" ) );\n        kBase1.setEqualsBehavior( AssertBehaviorOption.EQUALITY );\n        kBase1.setEventProcessingMode( EventProcessingOption.STREAM );               \n               \n        MemoryFileSystem mfs = new MemoryFileSystem();\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n                \n        Folder fld = mfs.getFolder( \"src/kbases/org.test1.kBase1\" );\n        assertTrue( fld.exists() );\n        \n        // Modify the KBase\n        MemoryFile mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.kBase1/org/test1/kBase1Producer.java\" );\n        String s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.STREAM\" ) );\n        \n        kBase1.setEventProcessingMode( EventProcessingOption.CLOUD );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs ); \n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.kBase1/org/test1/kBase1Producer.java\" );\n        s = new String( mfs.getBytes( mf.getPath().toPortableString() ) );\n        assertTrue( s.contains( \"EventProcessingOption.CLOUD\" ) );\n        \n        \n        // Remove the KBase\n        kproj.removeKBase( kBase1.getQName() );\n        KProjectChangeLogCommiter.commit( kproj, klog, mfs );\n        \n        fld = mfs.getFolder( \"src/kbases/org.test1.kBase1\" );\n        assertFalse( fld.exists() );\n        mf = (MemoryFile) mfs.getFile( \"src/kbases/org.test1.kBase1/org/test1/kBase1Producer.java\" );\n        assertFalse( mf.exists() );                \n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void remove(Set<Resource> members) {\n        for( Resource res : folder.getMembers() ) {\n            if ( res instanceof Folder ) {\n                remove( folders.remove( res.getPath().toPortableString() ) );\n            } else {\n                remove( (File) res);\n            }\n        }\n    }","id":30461,"modified_method":"public void remove(Set<Resource> members) {\n        for ( Iterator<Resource> it = members.iterator(); it.hasNext(); ) {\n            Resource res = it.next();\n        //for( Resource res : members ) {\n            if ( res instanceof Folder ) {\n                remove( folders.get( res.getPath().toPortableString() ) );\n                //folders.remove( folder.getPath().toPortableString() );\n            } else {\n                fileContents.remove( res.getPath().toPortableString() );\n            }\n            it.remove();\n        }\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean remove(Folder folder) {\n        if ( folder.exists() ) {\n            remove( folders.remove( folder.getPath().toPortableString() ) );\n            return true;\n        } else {\n            return false;\n        }\n    }","id":30462,"modified_method":"public boolean remove(Folder folder) {\n        if ( folder.exists() ) {\n            remove( folders.get( folder.getPath().toPortableString() ) );\n            folders.remove( folder.getPath().toPortableString() );\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testRecursiveFolderCreation() {\n        FileSystem fs = new MemoryFileSystem();\n        \n        Folder mres = fs.getFolder( \"src/main/resources\" );\n        assertFalse( mres.exists() );\n        mres.create();\n        assertTrue( mres.exists() );\n        \n        Folder smain = fs.getFolder( \"src/main\" );\n        assertTrue( smain.exists() );  \n        \n        Folder src = fs.getFolder( \"src\" );\n        assertTrue( src.exists() );         \n    }","id":30463,"modified_method":"@Test\n    public void testRecursiveFolderCreation() {\n        FileSystem fs = new MemoryFileSystem();\n        \n        Folder mres = fs.getFolder( \"src/main/resources\" );\n        assertFalse( mres.exists() );\n        mres.create();\n        assertTrue( mres.exists() );\n        \n        Folder fld = fs.getFolder( \"src/main\" );\n        assertTrue( fld.exists() );  \n        \n        Folder src = fs.getFolder( \"src\" );\n        assertTrue( src.exists() );         \n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testFolderRemoval() throws IOException {\n        FileSystem fs = new MemoryFileSystem();\n        \n        Folder folder = fs.getFolder( \"src/main/resources/org/domain\" );\n        folder.create();\n        \n        Folder smain = fs.getFolder( \"src/main\" );\n        File file = smain.getFile( \"MyClass1.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC1\".getBytes() ) );  \n        file = smain.getFile( \"MyClass2.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC2\".getBytes() ) ); \n        \n        smain = fs.getFolder( \"src/main/reaources/org\" );\n        file = smain.getFile( \"MyClass3.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC3\".getBytes() ) );  \n        file = smain.getFile( \"MyClass3.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC4\".getBytes() ) ); \n          \n        \n        smain = fs.getFolder( \"src/main/reaources/org.domain\" );\n        file = smain.getFile( \"MyClass4.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC5\".getBytes() ) );        \n        \n        \n\n        assertTrue( fs.getFile( \"src/main/MyClass1.java\" ).exists() );\n                 \n    }","id":30464,"modified_method":"@Test\n    public void testFolderRemoval() throws IOException {\n        FileSystem fs = new MemoryFileSystem();\n        \n        Folder fld = fs.getFolder( \"src/main/resources/org/domain\" );\n        fld.create();\n        \n        fld = fs.getFolder( \"src/main\" );\n        File file = fld.getFile( \"MyClass1.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC1\".getBytes() ) );  \n        file = fld.getFile( \"MyClass2.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC2\".getBytes() ) ); \n        \n        fld = fs.getFolder( \"src/main/resources/org\" );\n        file = fld.getFile( \"MyClass3.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC3\".getBytes() ) );  \n        file = fld.getFile( \"MyClass4.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC4\".getBytes() ) ); \n          \n        \n        fld = fs.getFolder( \"src/main/resources/org/domain\" );\n        file = fld.getFile( \"MyClass4.java\" );                \n        file.create( new ByteArrayInputStream( \"ABC5\".getBytes() ) );                        \n\n        assertTrue( fs.getFolder( \"src/main\" ).exists() );\n        assertTrue( fs.getFile( \"src/main/MyClass1.java\" ).exists() );\n        assertTrue( fs.getFile( \"src/main/MyClass2.java\" ).exists() );\n        assertTrue( fs.getFile( \"src/main/resources/org/MyClass3.java\" ).exists() );\n        assertTrue( fs.getFile( \"src/main/resources/org/MyClass4.java\" ).exists() );        \n        assertTrue( fs.getFile( \"src/main/resources/org/domain/MyClass4.java\" ).exists() );\n                \n        fs.remove( fs.getFolder( \"src/main\" ) );\n        \n        assertFalse( fs.getFolder( \"src/main\" ).exists() );\n        assertFalse( fs.getFile( \"src/main/MyClass1.java\" ).exists() );\n        assertFalse( fs.getFile( \"src/main/MyClass2.java\" ).exists() );\n        assertFalse( fs.getFile( \"src/main/resources/org/MyClass3.java\" ).exists() );\n        assertFalse( fs.getFile( \"src/main/resources/org/MyClass4.java\" ).exists() );        \n        assertFalse( fs.getFile( \"src/main/resources/org/domain/MyClass4.java\" ).exists() );\n\n                 \n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void readKBase(Entry<String, String> entry) {\n        Folder folder = fs.getFolder( entry.getValue() );\n        String kbaseQName = entry.getKey();\n        File file = folder.getFile( kbaseQName + \".properties\" );\n        Properties props = null;\n        try {\n            props = loadProperties( file );\n        } catch ( IOException e ) {\n            throw new RuntimeException( e );\n        }\n        \n        String namespace = props.getProperty( \"namespace\" );\n        String name = props.getProperty( \"name\" );\n        String filesStr = props.getProperty( \"files\" );\n        List<String> files = new ArrayList<String>();\n        for ( String str : filesStr.split( \",\" ) ) {\n            if ( StringUtils.isEmpty( str ) ) {\n                continue;\n            }            \n            files.add(  str.trim() );\n        }\n        \n        KBaseImpl kbase = new KBaseImpl( namespace, name, files );\n        \n        kbase.setEventProcessingMode( EventProcessingOption.determineEventProcessingMode(  props.getProperty( \"eventProcessingMode\" ) ) );\n        \n        kbase.setEqualsBehavior( AssertBehaviorOption.valueOf( props.getProperty( \"equalsBehavior\" ) ) );\n        List<String> list = Arrays.asList( props.getProperty( \"annotations\" ).split( \",\" ) );\n        kbase.setAnnotations( list );\n        \n        list = Arrays.asList( props.getProperty( \"ksessions\" ).split( \",\" ) );\n        for ( String ksessionQName : list ) {\n            if ( StringUtils.isEmpty( ksessionQName ) ) {\n                continue;\n            }\n            ksessionQName = ksessionQName.trim();            \n            Map<String, String> map = new HashMap<String, String>();            \n            mapStartsWith( map, props, ksessionQName );\n            readKSession(ksessionQName, map, kbase, kproject);\n        }\n                \n        kproject.getKBases().put( kbaseQName, kbase );\n    }","id":30465,"modified_method":"public void readKBase(Entry<String, String> entry) {\n        Folder folder = fs.getFolder( entry.getValue() );\n        String kbaseQName = entry.getKey();\n        File file = folder.getFile( kbaseQName + \".properties\" );\n        Properties props = null;\n        try {\n            props = loadProperties( file );\n        } catch ( IOException e ) {\n            throw new RuntimeException( e );\n        }\n        \n        String namespace = props.getProperty( \"namespace\" );\n        String name = props.getProperty( \"name\" );\n        String filesStr = props.getProperty( \"files\" );\n        List<String> files = new ArrayList<String>();\n        for ( String str : filesStr.split( \",\" ) ) {\n            if ( StringUtils.isEmpty( str ) ) {\n                continue;\n            }            \n            files.add(  str.trim() );\n        }\n        \n//        KBaseImpl kbase = new KBaseImpl( namespace, name, files );\n//        \n//        kbase.setEventProcessingMode( EventProcessingOption.determineEventProcessingMode(  props.getProperty( \"eventProcessingMode\" ) ) );\n//        \n//        kbase.setEqualsBehavior( AssertBehaviorOption.valueOf( props.getProperty( \"equalsBehavior\" ) ) );\n//        List<String> list = Arrays.asList( props.getProperty( \"annotations\" ).split( \",\" ) );\n//        kbase.setAnnotations( list );\n//        \n//        list = Arrays.asList( props.getProperty( \"ksessions\" ).split( \",\" ) );\n//        for ( String ksessionQName : list ) {\n//            if ( StringUtils.isEmpty( ksessionQName ) ) {\n//                continue;\n//            }\n//            ksessionQName = ksessionQName.trim();            \n//            Map<String, String> map = new HashMap<String, String>();            \n//            mapStartsWith( map, props, ksessionQName );\n//            readKSession(ksessionQName, map, kbase, kproject);\n//        }\n//                \n//        kproject.getKBases().put( kbaseQName, kbase );\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void readKSession(String ksessionQName, Map<String, String> map, KBase kbase, KProject kproject) {\n        KSessionImpl ksession = new KSessionImpl( map.get( \"namespace\" ), map.get( \"name \") );\n        ksession.setType( map.get( \"type\" ) );\n        \n        List<String> list = Arrays.asList( map.get( \"annotations\" ).split( \",\" ) );\n        ksession.setAnnotations( list );\n        \n        ksession.setClockType( ClockTypeOption.get( map.get( \"clockType\" ) ) );\n        kbase.getKSessions().put( ksessionQName, ksession );\n    }","id":30466,"modified_method":"public void readKSession(String ksessionQName, Map<String, String> map, KBase kbase, KProject kproject) {\n//        KSessionImpl ksession = new KSessionImpl( map.get( \"namespace\" ), map.get( \"name \") );\n//        ksession.setType( map.get( \"type\" ) );\n//        \n//        List<String> list = Arrays.asList( map.get( \"annotations\" ).split( \",\" ) );\n//        ksession.setAnnotations( list );\n//        \n//        ksession.setClockType( ClockTypeOption.get( map.get( \"clockType\" ) ) );\n//        kbase.getKSessions().put( ksessionQName, ksession );\n    }","commit_id":"947b4e77afa06f17b24b56183b88be19b1c90199","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * After a mailbox has been opened, search through the retrieved messages\n     * for a matching subject.\n     * \n     * @param mailParms\n     * @param mailFolder\n     * @return a PollStatus indicative of the success of matching a subject or just retieving\n     *         mail folder contents... dependent on configuration.\n     */\n    private PollStatus searchMailSubject(final MailTransportParameters mailParms, final Folder mailFolder) {\n        PollStatus status = PollStatus.unknown();\n        try {\n            String subject = computeMatchingSubject(mailParms);\n            if (mailFolder.isOpen() && subject != null) {\n                Message[] mailMessages = mailFolder.getMessages();\n                SearchTerm searchTerm = new SubjectTerm(subject);\n                log().debug(new StringBuilder(\"searchMailSubject: searching \")\n                  .append(mailMessages.length)\n                  .append(\" messages for subject: \")\n                  .append(subject).toString());\n\n                boolean found = false;\n                \n                for (int i = 1; i <= mailMessages.length; i++) {\n                    Message mailMessage = mailFolder.getMessage(i);\n                    log().debug(\"searchMailSubject: retrieved message subject:\"+mailMessage.getSubject());\n                    \n                    if (!found) {\n                        \n                    \tif (mailMessage.match(searchTerm)) {\n                    \t\tfound = true;\n                    \t\tlog().debug(\"searchMailSubject: message with subject: '\"+subject+\"' found.\");\n\n                    \t\tif (mailParms.isEnd2EndTestInProgress() || mailParms.getReadTest().isDeleteAllMail()) {\n                    \t\t\tmailMessage.setFlag(Flag.DELETED, true);\n                    \t\t\tlog().debug(\"searchMailSubject: flagging message: \"+subject+\" for deletion for end2end test.\");\n                    \t\t}\n                    \t} else {\n                    \t    if (mailParms.getReadTest().isDeleteAllMail()) {\n                                mailMessage.setFlag(Flag.DELETED, true);\n                                log().debug(\"searchMailSubject: Not found and delete all mail flag is set, flagging non-matching message for deletion: \"+mailMessage.getSubject());\n                    \t    }\n                    \t}\n                    \t\n                    } else {\n\n                    \tif (mailParms.getReadTest().isDeleteAllMail()) {\n                    \t    log().debug(\"searchMailSubject: Cleaning mailfolder due to the delete all mail flag being set, flagging non-matching message for deletion: \"+mailMessage.getSubject());\n                    \t    mailMessage.setFlag(Flag.DELETED, true);\n                    \t} else {\n                    \t\tbreak;\n                    \t}\n                    }\n                }\n                \n                if (!found) {\n                    log().debug(\"searchMailSubject: message with subject: '\"+subject+\"' NOT found.\");\n                    status = PollStatus.down(\"searchMailSubject: matching test message: '\"+subject+\"', not found.\");\n                } else {\n                    status = PollStatus.available();\n                }\n            }\n        } catch (MessagingException e) {\n            return PollStatus.down(e.getLocalizedMessage());\n        }\n\n        return status;\n    }","id":30467,"modified_method":"/**\n     * After a mailbox has been opened, search through the retrieved messages\n     * for a matching subject.\n     * \n     * @param mailParms\n     * @param mailFolder\n     * @return a PollStatus indicative of the success of matching a subject or just retieving\n     *         mail folder contents... dependent on configuration.\n     */\n    private PollStatus searchMailSubject(final MailTransportParameters mailParms, final Folder mailFolder) {\n        PollStatus status = PollStatus.unknown();\n        try {\n            String subject = computeMatchingSubject(mailParms);\n            if (mailFolder.isOpen() && subject != null) {\n                Message[] mailMessages = mailFolder.getMessages();\n                SearchTerm searchTerm = new SubjectTerm(subject);\n                log().debug(new StringBuilder(\"searchMailSubject: searching \")\n                  .append(mailMessages.length)\n                  .append(\" messages for subject: \")\n                  .append(subject).toString());\n\n                boolean found = false;\n                for (int i = 1; i <= mailMessages.length; i++) {\n                    Message mailMessage = mailFolder.getMessage(i);\n                    log().debug(\"searchMailSubject: retrieved message subject:\"+mailMessage.getSubject());\n                    \n                    if (!found && mailMessage.match(searchTerm)) {\n                        found = true;\n                        log().debug(\"searchMailSubject: message with subject: '\"+subject+\"' found.\");\n                        \n                        if (mailParms.isEnd2EndTestInProgress()) {\n                            mailMessage.setFlag(Flag.DELETED, true);\n                            log().debug(\"searchMailSubject: flagging message: \"+subject+\" for deletion for end2end test.\");\n                        }\n                    }\n                    \n                    if (found && !mailParms.getReadTest().isDeleteAllMail()) {\n                        break;\n                    } else {\n                        mailMessage.setFlag(Flag.DELETED, true);\n                    }\n                }\n                \n                if (!found) {\n                    log().debug(\"searchMailSubject: message with subject: '\"+subject+\"' NOT found.\");\n                    status = PollStatus.down(\"searchMailSubject: matching test message: '\"+subject+\"', not found.\");\n                } else {\n                    status = PollStatus.available();\n                }\n            }\n        } catch (MessagingException e) {\n            return PollStatus.down(e.getLocalizedMessage());\n        }\n\n        return status;\n    }","commit_id":"29ee8ca53123316384a05578c32e4d0ed44eb9c1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Establish connection with mail store and return the configured mail folder.\n     * \n     * @param mailParms\n     * @param mailStore\n     * @return the folder specified in configuration\n     * @throws MessagingException\n     */\n    private Folder retrieveMailFolder(final MailTransportParameters mailParms, final Store mailStore) throws MessagingException {\n    \tmailStore.connect();\n        //mailStore.connect(mailParms.getReadTestHost(), mailParms.getReadTestPort(), mailParms.getReadTestUserName(), mailParms.getReadTestPassword());\n        //Folder mailFolder = mailStore.getDefaultFolder();\n        Folder mailFolder = mailStore.getFolder(mailParms.getReadTestFolder());\n        return mailFolder;\n    }","id":30468,"modified_method":"/**\n     * Establish connection with mail store and return the configured mail folder.\n     * \n     * @param mailParms\n     * @param mailStore\n     * @return the folder specified in configuration\n     * @throws MessagingException\n     */\n    private Folder retrieveMailFolder(final MailTransportParameters mailParms, final Store mailStore) throws MessagingException {\n        mailStore.connect(mailParms.getReadTestHost(), mailParms.getReadTestPort(), mailParms.getReadTestUserName(), mailParms.getReadTestPassword());\n        Folder mailFolder = mailStore.getDefaultFolder();\n        mailFolder = mailFolder.getFolder(mailParms.getReadTestFolder());\n        return mailFolder;\n    }","commit_id":"29ee8ca53123316384a05578c32e4d0ed44eb9c1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Rule getReverseEdgesRule() throws IntrospectionException,\r\n\t\t\tInvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"reverse_edges\");\r\n\t\trule.setSalience(10);\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\tnew Integer(Stage.DUPLICATE), this.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n        Column lineColumn = new Column( 1, lineType, \"line\" );\r\n\t\trule.addPattern(lineColumn);\r\n\t\tfinal Declaration lineDeclaration = rule.getDeclaration(\"line\");\r\n\r\n\t\tConsequence consequence = new Consequence() {\r\n\r\n\t\t\tpublic void invoke(Activation activation,\r\n\t\t\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tRule rule = activation.getRule();\r\n\t\t\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\t\t\tLine line = (Line) drools.get(lineDeclaration);\r\n\t\t\t\t\tdrools.assertObject(new Edge(line.getP1(), line.getP2(),false, \"\", false));\r\n\t\t\t\t\tdrools.assertObject(new Edge(line.getP2(), line.getP1(),false, \"\", false));\r\n\t\t\t\t\tdrools.retractObject( tuple.get( lineDeclaration ) );\r\n\t\t\t\t\t\r\n\t\t\t\t\tSystem.out.println(\"draw \" + line.getP1() + \" \" + line.getP2());\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\tthrow new ConsequenceException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t};\r\n\t\trule.setConsequence(consequence);\r\n\t\treturn rule;\r\n\t}","id":30469,"modified_method":"private Rule getReverseEdgesRule() throws IntrospectionException,\r\n\t\t\tInvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"reverse_edges\");\r\n\t\trule.setSalience(10);\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\tnew Integer(Stage.DUPLICATE), this.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n\t\tColumn lineColumn = new Column(1, lineType, \"line\");\r\n\t\trule.addPattern(lineColumn);\r\n\t\tfinal Declaration lineDeclaration = rule.getDeclaration(\"line\");\r\n\r\n\t\tConsequence consequence = new Consequence() {\r\n\r\n\t\t\tpublic void invoke(Activation activation,\r\n\t\t\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tRule rule = activation.getRule();\r\n\t\t\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\t\t\tLine line = (Line) drools.get(lineDeclaration);\r\n\t\t\t\t\tdrools.assertObject(new Edge(line.getP1(), line.getP2(),\r\n\t\t\t\t\t\t\tfalse, Edge.NIL, Edge.NIL));\r\n\t\t\t\t\tdrools.assertObject(new Edge(line.getP2(), line.getP1(),\r\n\t\t\t\t\t\t\tfalse, Edge.NIL, Edge.NIL));\r\n\t\t\t\t\tdrools.retractObject(tuple.get(lineDeclaration));\r\n\r\n\t\t\t\t\tSystem.out.println(\"draw \" + line.getP1() + \" \"\r\n\t\t\t\t\t\t\t+ line.getP2());\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\tthrow new ConsequenceException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t};\r\n\t\trule.setConsequence(consequence);\r\n\t\treturn rule;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Rule getMakeLRule() throws IntrospectionException,\r\n\t\t\tInvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"make_L\");\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\tnew Integer(Stage.DETECT_JUNCTIONS), this.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n        Column edgeColumn1 = new Column( 1, edgeType, \"edge1\" );\r\n        edgeColumn1.addConstraint(getLiteralConstraint(edgeColumn1, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n        setFieldDeclaration( edgeColumn1, \"p1\", \"edge1p1\" );\r\n        setFieldDeclaration( edgeColumn1, \"p2\", \"edge1p2\" );\r\n\t\trule.addPattern(edgeColumn1);\r\n\t\tfinal Declaration edge1Declaration = rule.getDeclaration(\"edge1\");\r\n\t\tfinal Declaration edge1P1Declaration = rule.getDeclaration(\"edge1p1\");\r\n\t\tfinal Declaration edge1P2Declaration = rule.getDeclaration(\"edge1p2\");\r\n\r\n\t\tColumn edgeColumn2 = new Column( 2, edgeType, \"edge2\" );\r\n        edgeColumn2.addConstraint(getLiteralConstraint(edgeColumn2, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n        setFieldDeclaration( edgeColumn2, \"p1\", \"edge2p1\" );\r\n        setFieldDeclaration( edgeColumn2, \"p2\", \"edge2p2\" );\r\n\t\trule.addPattern(edgeColumn2);\r\n\t\tfinal Declaration edge2Declaration = rule.getDeclaration(\"edge2\");\r\n\t\tfinal Declaration edge2P1Declaration = rule.getDeclaration(\"edge2p1\");\r\n\t\tfinal Declaration edge2P2Declaration = rule.getDeclaration(\"edge2p2\");\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn1, \"p2\",\r\n\t\t\t\tedge2P2Declaration, integerNotEqualEvaluator));\r\n\r\n\t\tColumn notEdgeColumn = new Column(3, edgeType);\r\n\r\n\t\tnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\t\t\"p1\", edge1P1Declaration, integerEqualEvaluator));\r\n\t\tnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\t\t\"p2\", edge1P2Declaration, integerNotEqualEvaluator));\r\n\t\tnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\t\t\"p2\", edge2P2Declaration, integerNotEqualEvaluator));\r\n\t\tNot notEdge = new Not();\r\n\t\tnotEdge.addChild(notEdgeColumn);\r\n\t\trule.addPattern(notEdge);\r\n\t\t\r\n\t\tConsequence consequence = new Consequence() {\r\n\r\n\t\t\tpublic void invoke(Activation activation,\r\n\t\t\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tRule rule = activation.getRule();\r\n\t\t\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\t\t\tEdge edge1 = (Edge) drools.get(edge1Declaration);\r\n\t\t\t\t\tedge1.setJoined(true);\r\n\t\t\t\t\tEdge edge2 = (Edge) drools.get(edge2Declaration);\r\n\t\t\t\t\tedge2.setJoined(true);\r\n\r\n\t\t\t\t\tdrools.assertObject(new Junction(edge1.getP2(), edge2.getP2(), 0, edge1.getP1(), Junction.L) );\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge1);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge2);\r\n\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\tthrow new ConsequenceException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\trule.setConsequence(consequence);\r\n\r\n\t\treturn rule;\r\n\t}","id":30470,"modified_method":"private Rule getMakeLRule() throws IntrospectionException,\r\n\t\t\tInvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"make_L\");\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn\r\n\t\t\t\t.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\t\t\tnew Integer(Stage.DETECT_JUNCTIONS),\r\n\t\t\t\t\t\tthis.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n\t\tColumn edgeColumn1 = new Column(1, edgeType, \"edge1\");\r\n\t\tedgeColumn1.addConstraint(getLiteralConstraint(edgeColumn1, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n\t\tsetFieldDeclaration(edgeColumn1, \"p1\", \"edge1p1\");\r\n\t\tsetFieldDeclaration(edgeColumn1, \"p2\", \"edge1p2\");\r\n\t\trule.addPattern(edgeColumn1);\r\n\t\tfinal Declaration edge1Declaration = rule.getDeclaration(\"edge1\");\r\n\t\tfinal Declaration edge1P1Declaration = rule.getDeclaration(\"edge1p1\");\r\n\t\tfinal Declaration edge1P2Declaration = rule.getDeclaration(\"edge1p2\");\r\n\r\n\t\tColumn edgeColumn2 = new Column(2, edgeType, \"edge2\");\r\n\t\tedgeColumn2.addConstraint(getLiteralConstraint(edgeColumn2, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n\t\tsetFieldDeclaration(edgeColumn2, \"p2\", \"edge2p2\");\r\n\t\trule.addPattern(edgeColumn2);\r\n\t\tfinal Declaration edge2Declaration = rule.getDeclaration(\"edge2\");\r\n\t\tfinal Declaration edge2P2Declaration = rule.getDeclaration(\"edge2p2\");\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn2, \"p1\",\r\n\t\t\t\tedge1P1Declaration, integerEqualEvaluator));\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn2, \"p2\",\r\n\t\t\t\tedge2P2Declaration, integerNotEqualEvaluator));\r\n\r\n\t\tColumn notEdgeColumn = new Column(3, edgeType);\r\n\t\tnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\t\t\"p1\", edge1P1Declaration, integerEqualEvaluator));\r\n\t\tnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\t\t\"p2\", edge1P2Declaration, integerNotEqualEvaluator));\r\n\t\tnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\t\t\"p2\", edge2P2Declaration, integerNotEqualEvaluator));\r\n\t\tNot notEdge = new Not();\r\n\t\tnotEdge.addChild(notEdgeColumn);\r\n\t\trule.addPattern(notEdge);\r\n\r\n\t\tConsequence consequence = new Consequence() {\r\n\t\t\tpublic void invoke(Activation activation,\r\n\t\t\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tRule rule = activation.getRule();\r\n\t\t\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\t\t\tEdge edge1 = (Edge) drools.get(edge1Declaration);\r\n\t\t\t\t\tedge1.setJoined(true);\r\n\t\t\t\t\tEdge edge2 = (Edge) drools.get(edge2Declaration);\r\n\t\t\t\t\tedge2.setJoined(true);\r\n\r\n\t\t\t\t\tdrools.assertObject(new Junction(edge1.getP2(), edge2\r\n\t\t\t\t\t\t\t.getP2(), 0, edge1.getP1(), Junction.L));\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge1);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge2Declaration), edge2);\r\n\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\tthrow new ConsequenceException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\trule.setConsequence(consequence);\r\n\r\n\t\treturn rule;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Rule getInitialBoundaryJunctionLRule() throws IntrospectionException,\r\n\tInvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"initial_boundary_junction_L\");\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\tnew Integer(Stage.FIND_INITIAL_BOUNDARY),\r\n\t\t\t\tthis.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n\t\tColumn edgeColumn1 = new Column(1, edgeType, \"edge1\");\r\n        setFieldDeclaration( edgeColumn1, \"p1\", \"edge1p1\" );\r\n        setFieldDeclaration( edgeColumn1, \"p2\", \"edge1p2\" );\r\n\t\trule.addPattern(edgeColumn1);\r\n\t\tfinal Declaration edge1Declaration = rule.getDeclaration(\"edge1\");\r\n\t\tfinal Declaration edge1P1Declaration = rule.getDeclaration(\"edge1p1\");\r\n\t\tfinal Declaration edge1P2Declaration = rule.getDeclaration(\"edge1p2\");\r\n\r\n\t\tColumn edgeColumn2 = new Column(2, edgeType, \"edge2\");\r\n        setFieldDeclaration( edgeColumn2, \"p2\", \"edge2p2\" );\r\n\t\trule.addPattern(edgeColumn2);\r\n\t\tfinal Declaration edge2Declaration = rule.getDeclaration(\"edge2\");\r\n\t\tfinal Declaration edge2P2Declaration = rule.getDeclaration(\"edge2p2\");\r\n\r\n        Column junctionColumn = new Column( 1, junctionType );\r\n        junctionColumn.addConstraint(getLiteralConstraint(junctionColumn, \"type\",\r\n\t\t\t\tJunction.L, this.objectEqualEvaluator));\r\n\t\tjunctionColumn.addConstraint(getBoundVariableConstraint(junctionColumn, \"basePoint\",\r\n\t\t\t\tedge1P1Declaration, integerEqualEvaluator));\r\n\t\tjunctionColumn.addConstraint(getBoundVariableConstraint(junctionColumn, \"p1\",\r\n\t\t\t\tedge1P2Declaration, integerEqualEvaluator));\r\n\t\tjunctionColumn.addConstraint(getBoundVariableConstraint(junctionColumn, \"p2\",\r\n\t\t\t\tedge2P2Declaration, integerEqualEvaluator));\r\n\t\trule.addPattern(junctionColumn);\r\n\r\nColumn notEdgeColumn = new Column(3, edgeType);\r\n\r\nnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\"p1\", edge1P1Declaration, integerEqualEvaluator));\r\nnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\"p2\", edge1P2Declaration, integerNotEqualEvaluator));\r\nnotEdgeColumn.addConstraint(getBoundVariableConstraint(notEdgeColumn,\r\n\t\t\"p2\", edge2P2Declaration, integerNotEqualEvaluator));\r\nNot notEdge = new Not();\r\nnotEdge.addChild(notEdgeColumn);\r\nrule.addPattern(notEdge);\r\n\r\nConsequence consequence = new Consequence() {\r\n\r\n\tpublic void invoke(Activation activation,\r\n\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\ttry {\r\n\t\t\tRule rule = activation.getRule();\r\n\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\tEdge edge1 = (Edge) drools.get(edge1Declaration);\r\n\t\t\tedge1.setJoined(true);\r\n\t\t\tEdge edge2 = (Edge) drools.get(edge2Declaration);\r\n\t\t\tedge2.setJoined(true);\r\n\r\n\t\t\tdrools.assertObject(new Junction(edge1.getP2(), edge2.getP2(), 0, edge1.getP1(), Junction.L) );\r\n\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge1);\r\n\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge2);\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tthrow new ConsequenceException(e);\r\n\t\t}\r\n\t}\r\n\r\n};\r\n\r\nrule.setConsequence(consequence);\r\n\r\nreturn rule;\r\n}","id":30471,"modified_method":"private Rule getInitialBoundaryJunctionLRule()\r\n\t\t\tthrows IntrospectionException, InvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"initial_boundary_junction_L\");\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\tnew Integer(Stage.FIND_INITIAL_BOUNDARY),\r\n\t\t\t\tthis.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n\t\tColumn junctionColumn = new Column(1, junctionType);\r\n\t\tjunctionColumn.addConstraint(getLiteralConstraint(junctionColumn,\r\n\t\t\t\t\"type\", Junction.L, this.objectEqualEvaluator));\r\n\t\tsetFieldDeclaration(junctionColumn, \"basePoint\", \"junctionBasePoint\");\r\n\t\tsetFieldDeclaration(junctionColumn, \"p1\", \"junctionP1\");\r\n\t\tsetFieldDeclaration(junctionColumn, \"p2\", \"junctionP2\");\r\n\t\trule.addPattern(junctionColumn);\r\n\t\tfinal Declaration junctionBasePointDeclaration = rule\r\n\t\t\t\t.getDeclaration(\"junctionBasePoint\");\r\n\t\tfinal Declaration junctionP1Declaration = rule\r\n\t\t\t\t.getDeclaration(\"junctionP1\");\r\n\t\tfinal Declaration junctionP2Declaration = rule\r\n\t\t\t\t.getDeclaration(\"junctionP2\");\r\n\r\n\t\tColumn edgeColumn1 = new Column(2, edgeType, \"edge1\");\r\n\t\trule.addPattern(edgeColumn1);\r\n\t\tfinal Declaration edge1Declaration = rule.getDeclaration(\"edge1\");\r\n\t\tedgeColumn1.addConstraint(getBoundVariableConstraint(edgeColumn1, \"p1\",\r\n\t\t\t\tjunctionBasePointDeclaration, integerEqualEvaluator));\r\n\t\tedgeColumn1.addConstraint(getBoundVariableConstraint(edgeColumn1, \"p2\",\r\n\t\t\t\tjunctionP1Declaration, integerEqualEvaluator));\r\n\r\n\t\tColumn edgeColumn2 = new Column(3, edgeType, \"edge2\");\r\n\t\trule.addPattern(edgeColumn2);\r\n\t\tfinal Declaration edge2Declaration = rule.getDeclaration(\"edge2\");\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn2, \"p1\",\r\n\t\t\t\tjunctionBasePointDeclaration, integerEqualEvaluator));\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn2, \"p2\",\r\n\t\t\t\tjunctionP2Declaration, integerEqualEvaluator));\r\n\r\n\t\tColumn notJunctionColumn = new Column(4, junctionType);\r\n\t\tnotJunctionColumn.addConstraint(getBoundVariableConstraint(\r\n\t\t\t\tnotJunctionColumn, \"basePoint\", junctionBasePointDeclaration,\r\n\t\t\t\tintegerGreaterEvaluator));\r\n\t\tNot notJunction = new Not();\r\n\t\tnotJunction.addChild(notJunctionColumn);\r\n\t\trule.addPattern(notJunction);\r\n\r\n\t\tConsequence consequence = new Consequence() {\r\n\t\t\tpublic void invoke(Activation activation,\r\n\t\t\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tRule rule = activation.getRule();\r\n\t\t\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\t\t\tEdge edge1 = (Edge) drools.get(edge1Declaration);\r\n\t\t\t\t\tedge1.setLabel(Edge.B);\r\n\t\t\t\t\tEdge edge2 = (Edge) drools.get(edge2Declaration);\r\n\t\t\t\t\tedge2.setLabel(Edge.B);\r\n\t\t\t\t\tStage stage = (Stage) drools.get(stageDeclaration);\r\n\t\t\t\t\tstage.setValue(Stage.FIND_SECOND_BOUNDARY);\r\n\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(stageDeclaration), stage);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge1);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge2Declaration), edge2);\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\tthrow new ConsequenceException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\trule.setConsequence(consequence);\r\n\t\treturn rule;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void setUp() throws Exception {\r\n\t\t// types\r\n\t\tthis.stageType = new ClassObjectType(Stage.class);\r\n\t\tthis.lineType = new ClassObjectType(Line.class);\r\n\t\tthis.edgeType = new ClassObjectType(Edge.class);\r\n\t\tthis.junctionType = new ClassObjectType(Junction.class);\r\n\t\t// evaluators\r\n\t\tthis.integerEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.INTEGER_TYPE, Evaluator.EQUAL);\r\n\t\tthis.integerNotEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.INTEGER_TYPE, Evaluator.NOT_EQUAL);\r\n\r\n\t\tthis.objectEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.OBJECT_TYPE, Evaluator.EQUAL);\r\n\t\tthis.objectNotEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.OBJECT_TYPE, Evaluator.NOT_EQUAL);\r\n\r\n\t\tthis.booleanEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.BOOLEAN_TYPE, Evaluator.EQUAL);\r\n\t\tthis.booleanNotEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.BOOLEAN_TYPE, Evaluator.NOT_EQUAL);\r\n\r\n\t\t// rules\r\n\t\tthis.pkg = new Package(\"Waltz\");\r\n\t\tthis.pkg.addRule(getBeginRule());\r\n\t\tthis.pkg.addRule(getReverseEdgesRule());\r\n\t\tthis.pkg.addRule(getDoneReversingRule());\r\n\t\tthis.pkg.addRule(getMake3JunctionRule());\r\n\t\tthis.pkg.addRule(getMakeLRule());\r\n\t\tthis.pkg.addRule(getDoneDetectingRule());\r\n\t\tthis.pkg.addRule(getInitialBoundaryJunctionLRule());\r\n\t\tthis.pkg.addRule(getDoneRule());\r\n\t\t\r\n\t}","id":30472,"modified_method":"protected void setUp() throws Exception {\r\n\t\t// types\r\n\t\tthis.stageType = new ClassObjectType(Stage.class);\r\n\t\tthis.lineType = new ClassObjectType(Line.class);\r\n\t\tthis.edgeType = new ClassObjectType(Edge.class);\r\n\t\tthis.junctionType = new ClassObjectType(Junction.class);\r\n\t\t// evaluators\r\n\t\tthis.integerEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.INTEGER_TYPE, Evaluator.EQUAL);\r\n\t\tthis.integerNotEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.INTEGER_TYPE, Evaluator.NOT_EQUAL);\r\n\t\tthis.integerGreaterEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.INTEGER_TYPE, Evaluator.GREATER);\r\n\t\tthis.integerLessEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.INTEGER_TYPE, Evaluator.LESS);\r\n\r\n\t\tthis.objectEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.OBJECT_TYPE, Evaluator.EQUAL);\r\n\t\tthis.objectNotEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.OBJECT_TYPE, Evaluator.NOT_EQUAL);\r\n\r\n\t\tthis.booleanEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.BOOLEAN_TYPE, Evaluator.EQUAL);\r\n\t\tthis.booleanNotEqualEvaluator = EvaluatorFactory.getInstance()\r\n\t\t\t\t.getEvaluator(Evaluator.BOOLEAN_TYPE, Evaluator.NOT_EQUAL);\r\n\r\n\t\t// rules\r\n\t\tthis.pkg = new Package(\"Waltz\");\r\n\t\tthis.pkg.addRule(getBeginRule());\r\n\t\tthis.pkg.addRule(getReverseEdgesRule());\r\n\t\tthis.pkg.addRule(getDoneReversingRule());\r\n\t\tthis.pkg.addRule(getMake3JunctionRule());\r\n\t\tthis.pkg.addRule(getMakeLRule());\r\n\t\tthis.pkg.addRule(getDoneDetectingRule());\r\n\t\tthis.pkg.addRule(getInitialBoundaryJunctionLRule());\r\n\t\tthis.pkg.addRule(getInitialBoundaryJunctionArrowRule());\r\n\t\tthis.pkg.addRule(getSecondBoundaryJunctionLRule());\r\n\t\tthis.pkg.addRule(getSecondBoundaryJunctionArrowRule());\r\n\t\tthis.pkg.addRule(getMatchEdgeRule());\r\n\t\tthis.pkg.addRule(getLabelLRule());\r\n\t\tthis.pkg.addRule(getLabelTeeARule());\r\n\t\tthis.pkg.addRule(getLabelTeeBRule());\r\n\t\tthis.pkg.addRule(getLabelFork1Rule());\r\n\t\tthis.pkg.addRule(getLabelFork2Rule());\r\n\t\tthis.pkg.addRule(getLabelFork3Rule());\r\n\t\tthis.pkg.addRule(getLabelFork4Rule());\r\n\t\tthis.pkg.addRule(getLabelArrow1ARule());\r\n\t\tthis.pkg.addRule(getLabelArrow1BRule());\r\n\t\tthis.pkg.addRule(getLabelArrow2ARule());\r\n\t\tthis.pkg.addRule(getLabelArrow2BRule());\r\n\t\tthis.pkg.addRule(getLabelArrow3ARule());\r\n\t\tthis.pkg.addRule(getLabelArrow3BRule());\r\n\t\tthis.pkg.addRule(getLabelArrow4ARule());\r\n\t\tthis.pkg.addRule(getLabelArrow4BRule());\r\n\t\tthis.pkg.addRule(getLabelArrow5ARule());\r\n\t\tthis.pkg.addRule(getLabelArrow5BRule());\r\n\t\tthis.pkg.addRule(getDoneLabelingRule());\r\n\t\tthis.pkg.addRule(getPlotRemainingRule());\r\n\t\tthis.pkg.addRule(getPlotBoudariesRule());\r\n\t\tthis.pkg.addRule(getDonePlotingRule());\r\n\t\tthis.pkg.addRule(getDoneRule());\r\n\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Rule getMake3JunctionRule() throws IntrospectionException,\r\n\t\t\tInvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"make-3_junction\");\r\n\t\trule.setSalience(10);\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\tnew Integer(Stage.DETECT_JUNCTIONS), this.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n        Column edgeColumn1 = new Column( 1, edgeType, \"edge1\" );\r\n        edgeColumn1.addConstraint(getLiteralConstraint(edgeColumn1, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n        setFieldDeclaration( edgeColumn1, \"p1\", \"edge1p1\" );\r\n        setFieldDeclaration( edgeColumn1, \"p2\", \"edge1p2\" );\r\n\t\trule.addPattern(edgeColumn1);\r\n\t\tfinal Declaration edge1Declaration = rule.getDeclaration(\"edge1\");\r\n\t\tfinal Declaration edge1P1Declaration = rule.getDeclaration(\"edge1p1\");\r\n\t\tfinal Declaration edge1P2Declaration = rule.getDeclaration(\"edge1p2\");\r\n\r\n\t\tColumn edgeColumn2 = new Column( 2, edgeType, \"edge2\" );\r\n        edgeColumn2.addConstraint(getLiteralConstraint(edgeColumn2, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n        setFieldDeclaration( edgeColumn2, \"p1\", \"edge2p1\" );\r\n        setFieldDeclaration( edgeColumn2, \"p2\", \"edge2p2\" );\r\n\t\trule.addPattern(edgeColumn2);\r\n\t\tfinal Declaration edge2Declaration = rule.getDeclaration(\"edge2\");\r\n\t\tfinal Declaration edge2P1Declaration = rule.getDeclaration(\"edge2p1\");\r\n\t\tfinal Declaration edge2P2Declaration = rule.getDeclaration(\"edge2p2\");\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn1, \"p2\",\r\n\t\t\t\tedge2P2Declaration, integerNotEqualEvaluator));\r\n\r\n\t\tColumn edgeColumn3 = new Column(3, edgeType, \"edge3\");\r\n\t\tedgeColumn3.addConstraint(getLiteralConstraint(edgeColumn3, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n\t\tsetFieldDeclaration(edgeColumn3, \"p1\", \"edge3p1\");\r\n\t\tsetFieldDeclaration(edgeColumn3, \"p2\", \"edge3p2\");\r\n\t\trule.addPattern(edgeColumn3);\r\n\t\tfinal Declaration edge3Declaration = rule.getDeclaration(\"edge3\");\r\n\t\tfinal Declaration edge3P1Declaration = rule.getDeclaration(\"edge3p1\");\r\n\t\tfinal Declaration edge3P2Declaration = rule.getDeclaration(\"edge3p2\");\r\n\t\tedgeColumn3.addConstraint(getBoundVariableConstraint(edgeColumn1, \"p2\",\r\n\t\t\t\tedge3P2Declaration, integerNotEqualEvaluator));\r\n\t\tedgeColumn3.addConstraint(getBoundVariableConstraint(edgeColumn2, \"p2\",\r\n\t\t\t\tedge3P2Declaration, integerNotEqualEvaluator));\r\n\r\n\t\tConsequence consequence = new Consequence() {\r\n\r\n\t\t\tpublic void invoke(Activation activation,\r\n\t\t\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tRule rule = activation.getRule();\r\n\t\t\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\t\t\tEdge edge1 = (Edge) drools.get(edge1Declaration);\r\n\t\t\t\t\tedge1.setJoined(true);\r\n\t\t\t\t\tEdge edge2 = (Edge) drools.get(edge2Declaration);\r\n\t\t\t\t\tedge2.setJoined(true);\r\n\t\t\t\t\tEdge edge3 = (Edge) drools.get(edge3Declaration);\r\n\t\t\t\t\tedge3.setJoined(true);\r\n\r\n\t\t\t\t\tdrools.assertObject(WaltzUtil.make_3_junction(edge1.getP1(), edge1.getP2(),\r\n\t\t\t\t\t\t\tedge2.getP2(), edge3.getP2()));\r\n\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge1);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge2);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge3);\r\n\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\tthrow new ConsequenceException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\trule.setConsequence(consequence);\r\n\t\treturn rule;\r\n\t}","id":30473,"modified_method":"private Rule getMake3JunctionRule() throws IntrospectionException,\r\n\t\t\tInvalidRuleException {\r\n\t\tfinal Rule rule = new Rule(\"make-3_junction\");\r\n\t\trule.setSalience(10);\r\n\r\n\t\tColumn stageColumn = new Column(0, stageType, \"stage\");\r\n\t\tstageColumn\r\n\t\t\t\t.addConstraint(getLiteralConstraint(stageColumn, \"value\",\r\n\t\t\t\t\t\tnew Integer(Stage.DETECT_JUNCTIONS),\r\n\t\t\t\t\t\tthis.integerEqualEvaluator));\r\n\t\trule.addPattern(stageColumn);\r\n\t\tfinal Declaration stageDeclaration = rule.getDeclaration(\"stage\");\r\n\r\n\t\tColumn edgeColumn1 = new Column(1, edgeType, \"edge1\");\r\n\t\tedgeColumn1.addConstraint(getLiteralConstraint(edgeColumn1, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n\t\tsetFieldDeclaration(edgeColumn1, \"p1\", \"edge1p1\");\r\n\t\tsetFieldDeclaration(edgeColumn1, \"p2\", \"edge1p2\");\r\n\t\trule.addPattern(edgeColumn1);\r\n\t\tfinal Declaration edge1Declaration = rule.getDeclaration(\"edge1\");\r\n\t\tfinal Declaration edge1P1Declaration = rule.getDeclaration(\"edge1p1\");\r\n\t\tfinal Declaration edge1P2Declaration = rule.getDeclaration(\"edge1p2\");\r\n\r\n\t\tColumn edgeColumn2 = new Column(2, edgeType, \"edge2\");\r\n\t\tedgeColumn2.addConstraint(getLiteralConstraint(edgeColumn2, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n\t\tsetFieldDeclaration(edgeColumn2, \"p2\", \"edge2p2\");\r\n\t\trule.addPattern(edgeColumn2);\r\n\t\tfinal Declaration edge2Declaration = rule.getDeclaration(\"edge2\");\r\n\t\tfinal Declaration edge2P2Declaration = rule.getDeclaration(\"edge2p2\");\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn2, \"p1\",\r\n\t\t\t\tedge1P1Declaration, integerEqualEvaluator));\r\n\t\tedgeColumn2.addConstraint(getBoundVariableConstraint(edgeColumn2, \"p2\",\r\n\t\t\t\tedge1P2Declaration, integerNotEqualEvaluator));\r\n\r\n\t\tColumn edgeColumn3 = new Column(3, edgeType, \"edge3\");\r\n\t\tedgeColumn3.addConstraint(getLiteralConstraint(edgeColumn3, \"joined\",\r\n\t\t\t\tnew Boolean(false), this.booleanEqualEvaluator));\r\n\t\trule.addPattern(edgeColumn3);\r\n\t\tfinal Declaration edge3Declaration = rule.getDeclaration(\"edge3\");\r\n\t\tedgeColumn3.addConstraint(getBoundVariableConstraint(edgeColumn3, \"p1\",\r\n\t\t\t\tedge1P1Declaration, integerEqualEvaluator));\r\n\t\tedgeColumn3.addConstraint(getBoundVariableConstraint(edgeColumn3, \"p2\",\r\n\t\t\t\tedge1P2Declaration, integerNotEqualEvaluator));\r\n\t\tedgeColumn3.addConstraint(getBoundVariableConstraint(edgeColumn3, \"p2\",\r\n\t\t\t\tedge2P2Declaration, integerNotEqualEvaluator));\r\n\r\n\t\tConsequence consequence = new Consequence() {\r\n\r\n\t\t\tpublic void invoke(Activation activation,\r\n\t\t\t\t\tWorkingMemory workingMemory) throws ConsequenceException {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tRule rule = activation.getRule();\r\n\t\t\t\t\tTuple tuple = activation.getTuple();\r\n\t\t\t\t\tKnowledgeHelper drools = new DefaultKnowledgeHelper(rule,\r\n\t\t\t\t\t\t\ttuple, workingMemory);\r\n\r\n\t\t\t\t\tEdge edge1 = (Edge) drools.get(edge1Declaration);\r\n\t\t\t\t\tedge1.setJoined(true);\r\n\t\t\t\t\tEdge edge2 = (Edge) drools.get(edge2Declaration);\r\n\t\t\t\t\tedge2.setJoined(true);\r\n\t\t\t\t\tEdge edge3 = (Edge) drools.get(edge3Declaration);\r\n\t\t\t\t\tedge3.setJoined(true);\r\n\r\n\t\t\t\t\tdrools.assertObject(WaltzUtil.make_3_junction(\r\n\t\t\t\t\t\t\tedge1.getP1(), edge1.getP2(), edge2.getP2(), edge3\r\n\t\t\t\t\t\t\t\t\t.getP2()));\r\n\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge1Declaration), edge1);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge2Declaration), edge2);\r\n\t\t\t\t\tdrools.modifyObject(tuple.get(edge3Declaration), edge3);\r\n\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\tthrow new ConsequenceException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\trule.setConsequence(consequence);\r\n\t\treturn rule;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Edge(int p1, int p2, boolean joined, String label, boolean plotted) {\r\n\t\tthis.p1 = p1;\r\n\t\tthis.p2 = p2;\r\n\t\tthis.joined = joined;\r\n\t\tthis.label = label;\r\n\t\tthis.plotted = plotted;\r\n\t}","id":30474,"modified_method":"public Edge(int p1, int p2, boolean joined, String label, String plotted) {\r\n\t\tthis.p1 = p1;\r\n\t\tthis.p2 = p2;\r\n\t\tthis.joined = joined;\r\n\t\tthis.label = label;\r\n\t\tthis.plotted = plotted;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean isPlotted() {\r\n\t\treturn this.plotted;\r\n\t}","id":30475,"modified_method":"public String getPlotted() {\r\n\t\treturn this.plotted;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testManners() throws DuplicateRuleNameException,\r\n                             InvalidRuleException,\r\n                             IntrospectionException,\r\n                             RuleIntegrationException,\r\n                             PackageIntegrationException,\r\n                             InvalidPatternException,\r\n                             FactException,\r\n                             IOException,\r\n                             InterruptedException {\r\n\r\n        final org.drools.leaps.RuleBaseImpl ruleBase = new org.drools.leaps.RuleBaseImpl();\r\n        ruleBase.addRuleSet( this.pkg );\r\n        WorkingMemory workingMemory = ruleBase.newWorkingMemory();\r\n\r\n        InputStream is = getClass().getResourceAsStream( \"/manners5.dat\" );\r\n        List list = getInputObjects( is );\r\n        for ( Iterator it = list.iterator(); it.hasNext(); ) {\r\n            Object object = it.next();\r\n            workingMemory.assertObject( object );\r\n        }\r\n\r\n        workingMemory.assertObject( new Count( 1 ) );\r\n\r\n        long start = System.currentTimeMillis();\r\n        workingMemory.fireAllRules();\r\n        System.err.println( System.currentTimeMillis() - start );\r\n\r\n        //        final ReteooJungViewer viewer = new ReteooJungViewer(ruleBase); \r\n        //        \r\n        //        javax.swing.SwingUtilities.invokeLater(new Runnable() { \r\n        //        \t\tpublic void run() {\r\n        //        \t\t\tviewer.showGUI();\r\n        //        \t\t}\r\n        //        });\r\n        //        \r\n        //        Thread.sleep( 10000 );\r\n    }","id":30476,"modified_method":"public void testManners() throws DuplicateRuleNameException,\r\n                             InvalidRuleException,\r\n                             IntrospectionException,\r\n                             RuleIntegrationException,\r\n                             PackageIntegrationException,\r\n                             InvalidPatternException,\r\n                             FactException,\r\n                             IOException,\r\n                             InterruptedException {\r\n\r\n        final org.drools.leaps.RuleBaseImpl ruleBase = new org.drools.leaps.RuleBaseImpl();\r\n        ruleBase.addRuleSet( this.pkg );\r\n        WorkingMemory workingMemory = ruleBase.newWorkingMemory();\r\n\r\n        InputStream is = getClass().getResourceAsStream( \"/manners64.dat\" );\r\n        List list = getInputObjects( is );\r\n        for ( Iterator it = list.iterator(); it.hasNext(); ) {\r\n            Object object = it.next();\r\n            workingMemory.assertObject( object );\r\n        }\r\n\r\n        workingMemory.assertObject( new Count( 1 ) );\r\n\r\n        long start = System.currentTimeMillis();\r\n        workingMemory.fireAllRules();\r\n        System.err.println( System.currentTimeMillis() - start );\r\n\r\n        //        final ReteooJungViewer viewer = new ReteooJungViewer(ruleBase); \r\n        //        \r\n        //        javax.swing.SwingUtilities.invokeLater(new Runnable() { \r\n        //        \t\tpublic void run() {\r\n        //        \t\t\tviewer.showGUI();\r\n        //        \t\t}\r\n        //        });\r\n        //        \r\n        //        Thread.sleep( 10000 );\r\n    }","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n\t * @see java.lang.Object\r\n\t */\r\n\tpublic boolean equals(Object object) {\r\n\t\tif (this == object) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (object == null || !(object instanceof LeapsTuple)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tFactHandle[] thatFactHandles = ((LeapsTuple) object).getFactHandles();\r\n\t\tif (thatFactHandles.length != this.factHandles.length) {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < this.factHandles.length; i++) {\r\n\t\t\t\tif (!this.factHandles[i].equals(thatFactHandles[i])) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}","id":30477,"modified_method":"/**\r\n\t * @see java.lang.Object\r\n\t */\r\n\tpublic boolean equals(Object object) {\r\n\t\tif (this == object) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (object == null || !(object instanceof LeapsTuple)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tFactHandle[] thatFactHandles = ((LeapsTuple) object).getFactHandles();\r\n\t\tif (thatFactHandles.length != this.factHandles.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < this.factHandles.length; i++) {\r\n\t\t\tif (!this.factHandles[i].equals(thatFactHandles[i])) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn true;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PendingTuple(LeapsTuple tuple, List existsQualifiers,\r\n\t\t\tPropagationContext context, Rule rule, boolean existsCountRelevant,\r\n\t\t\tint existsCount, boolean notCountRelevant, int notCount) {\r\n\t\tsuper(existsCountRelevant, existsCount, notCountRelevant, notCount);\r\n\t\tthis.tuple = tuple;\r\n\t\tthis.context = context;\r\n\t\tthis.rule = rule;\r\n\t\tthis.existsQualifiers = existsQualifiers;\r\n\t}","id":30478,"modified_method":"public PendingTuple(LeapsTuple tuple, List existsQualifiers,\r\n\t\t\tPropagationContext context, Rule rule, boolean existsCountRelevant,\r\n\t\t\tint existsCount, boolean notCountRelevant, int notCount) {\r\n\t\tthis.valid = true;\r\n\t\tthis.existsCountRelevant = existsCountRelevant;\r\n\t\tthis.existsCount = existsCount;\r\n\t\tthis.notCountRelevant = notCountRelevant;\r\n\t\tthis.notCount = notCount;\r\n\t\tthis.tuple = tuple;\r\n\t\tthis.context = context;\r\n\t\tthis.rule = rule;\r\n\t\tthis.existsQualifiers = existsQualifiers;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected boolean isValid() {\r\n\t\treturn super.isValid() && !this.submited;\r\n\t}","id":30479,"modified_method":"protected boolean isValid() {\r\n\t\tboolean ret = this.valid && !this.submited;\r\n\t\tif (ret && this.notCountRelevant) {\r\n\t\t\tret = (this.notCount == 0);\r\n\t\t}\r\n\t\tif (ret && this.existsCountRelevant) {\r\n\t\t\tret = (this.existsCount > 0);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PostedActivation(AgendaItem agendaItem, boolean existsCountRelevant,\r\n\t\t\tint existsCount, boolean notCountRelevant, int notCount) {\r\n\t\tsuper(existsCountRelevant, existsCount, notCountRelevant, notCount);\r\n\t\tthis.agendaItem = agendaItem;\r\n\t}","id":30480,"modified_method":"public PostedActivation(AgendaItem agendaItem, boolean existsCountRelevant,\r\n\t\t\tint existsCount) {\r\n\t\tthis.valid = true;\r\n\t\tthis.existsCountRelevant = existsCountRelevant;\r\n\t\tthis.existsCount = existsCount;\r\n\t\tthis.agendaItem = agendaItem;\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\tFactHandleImpl h1 = new FactHandleImpl(1, \"one\");\r\n\t\tFactHandleImpl h2 = new FactHandleImpl(2, \"two\");\r\n\t\tFactHandleImpl h3 = new FactHandleImpl(3, \"three\");\r\n\t\tFactHandleImpl h4 = new FactHandleImpl(4, \"four\");\r\n\t\tFactHandleImpl arr[] = { h1, h2, h3, h4 };\r\n\t\tLeapsTuple tuple = new LeapsTuple(arr);\r\n\t\tthis.item = new AgendaItem(0L, tuple, null, null, null);\r\n\t\tthis.postedActivation = new PostedActivation(this.item, false, 1, false, -1);\r\n\t}","id":30481,"modified_method":"protected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\tFactHandleImpl h1 = new FactHandleImpl(1, \"one\");\r\n\t\tFactHandleImpl h2 = new FactHandleImpl(2, \"two\");\r\n\t\tFactHandleImpl h3 = new FactHandleImpl(3, \"three\");\r\n\t\tFactHandleImpl h4 = new FactHandleImpl(4, \"four\");\r\n\t\tFactHandleImpl arr[] = { h1, h2, h3, h4 };\r\n\t\tLeapsTuple tuple = new LeapsTuple(arr);\r\n\t\tthis.item = new AgendaItem(0L, tuple, null, null, null);\r\n\t\tthis.postedActivation = new PostedActivation(this.item, false, 1);\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n\t * Assert a new <code>Tuple<\/code>.\r\n\t * \r\n\t * @param tuple\r\n\t *            The <code>Tuple<\/code> being asserted.\r\n\t * @param workingMemory\r\n\t *            The working memory seesion.\r\n\t * @throws AssertionException\r\n\t *             If an error occurs while asserting.\r\n\t */\r\n\tpublic void assertTuple(LeapsTuple tuple, List blockingFactHandles\r\n\t\t\t, List existsEnablingFactHandles,\r\n\t\t\tPropagationContext context, Rule rule) {\r\n\t\tFactHandleImpl factHandle;\r\n\t\t// if the current Rule is no-loop and the origin rule is the same then\r\n\t\t// return\r\n\t\tif (rule.getNoLoop() && rule.equals(context.getRuleOrigin())) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// see if there are blocking facts and put it on pending activations\r\n\t\t// list without submitting to agenda\r\n\t\tif (blockingFactHandles.size() != 0) {\r\n\t\t\tPendingTuple pendingTuple = new PendingTuple(\r\n\t\t\t\t\ttuple, existsEnablingFactHandles,context, rule,\r\n\t\t\t\t\t(existsEnablingFactHandles != null)\r\n\t\t\t\t\t\t\t&& (existsEnablingFactHandles.size() > 0),\r\n\t\t\t\t\texistsEnablingFactHandles.size(),\r\n\t\t\t\t\t(blockingFactHandles != null)\r\n\t\t\t\t\t\t\t&& (blockingFactHandles.size() > 0),\r\n\t\t\t\t\tblockingFactHandles.size());\r\n\t\t\t// exists qualifiers\r\n\t\t\taddPendingTuple(pendingTuple, existsEnablingFactHandles, blockingFactHandles);\r\n\t\t\t//\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDuration dur = rule.getDuration();\r\n\r\n\t\tActivation agendaItem;\r\n\t\tif (dur != null && dur.getDuration(tuple) > 0) {\r\n\t\t\t agendaItem = new ScheduledAgendaItem(context\r\n\t\t\t\t\t.getPropagationNumber(), tuple, this.agenda, context, rule);\r\n\t\t\tthis.agenda.scheduleItem((ScheduledAgendaItem)agendaItem);\r\n\t\t\ttuple.setActivation(agendaItem);\r\n\t\t\tagendaItem.setActivated(true);\r\n\t\t\tthis.getAgendaEventSupport().fireActivationCreated(agendaItem);\r\n\t\t} else {\r\n\t\t\t// -----------------\r\n\t\t\t// Lazy instantiation and addition to the Agenda of AgendGroup\r\n\t\t\t// implementations\r\n\t\t\t// ----------------\r\n\t\t\tAgendaGroupImpl agendaGroup = null;\r\n\t\t\tif (rule.getAgendaGroup() == null\r\n\t\t\t\t\t|| rule.getAgendaGroup().equals(\"\")\r\n\t\t\t\t\t|| rule.getAgendaGroup().equals(AgendaGroup.MAIN)) {\r\n\t\t\t\t// Is the Rule AgendaGroup undefined? If it is use MAIN, which\r\n\t\t\t\t// is added to the Agenda by default\r\n\t\t\t\tagendaGroup = (AgendaGroupImpl) this.agenda\r\n\t\t\t\t\t\t.getAgendaGroup(AgendaGroup.MAIN);\r\n\t\t\t} else {\r\n\t\t\t\t// AgendaGroup is defined, so try and get the AgendaGroup from\r\n\t\t\t\t// the Agenda\r\n\t\t\t\tagendaGroup = (AgendaGroupImpl) this.agenda.getAgendaGroup(rule\r\n\t\t\t\t\t\t.getAgendaGroup());\r\n\t\t\t}\r\n\r\n\t\t\tif (agendaGroup == null) {\r\n\t\t\t\t// The AgendaGroup is defined but not yet added to the Agenda,\r\n\t\t\t\t// so create the AgendaGroup and add to the Agenda.\r\n\t\t\t\tagendaGroup = new AgendaGroupImpl(rule.getAgendaGroup());\r\n\t\t\t\tthis.agenda.addAgendaGroup(agendaGroup);\r\n\t\t\t}\r\n\r\n\t\t\t// set the focus if rule autoFocus is true\r\n\t\t\tif (rule.getAutoFocus()) {\r\n\t\t\t\tthis.agenda.setFocus(agendaGroup);\r\n\t\t\t}\r\n\r\n\t\t\tActivationQueue queue = agendaGroup.getActivationQueue(rule\r\n\t\t\t\t\t.getSalience());\r\n\t\t\tagendaItem = new AgendaItem(context.getPropagationNumber(),\r\n\t\t\t\t\ttuple, context, rule, queue);\r\n\r\n\t\t\tqueue.add(agendaItem);\r\n\r\n\t\t\t// Makes sure the Lifo is added to the AgendaGroup priority queue\r\n\t\t\t// If the AgendaGroup is already in the priority queue it just\r\n\t\t\t// returns.\r\n\t\t\tagendaGroup.addToAgenda(queue);\r\n\t\t\ttuple.setActivation(agendaItem);\r\n\t\t\tagendaItem.setActivated(true);\r\n\t\t\tthis.getAgendaEventSupport().fireActivationCreated(agendaItem);\r\n\t\t\t// added relationships to use during retract\r\n\t\t\t\r\n\t\t\tPostedActivation postedActivation = new PostedActivation(\r\n\t\t\t\t\t(AgendaItem) agendaItem,\r\n\t\t\t\t\t(existsEnablingFactHandles != null)\r\n\t\t\t\t\t\t\t&& (existsEnablingFactHandles.size() > 0),\r\n\t\t\t\t\t\t\t(existsEnablingFactHandles != null)?existsEnablingFactHandles.size():-1,\r\n\t\t\t\t\t(blockingFactHandles != null)\r\n\t\t\t\t\t\t\t&& (blockingFactHandles.size() > 0),\r\n\t\t\t\t\t\t\t(blockingFactHandles != null)?blockingFactHandles.size():-1);\r\n\t\t\t// to take agendaItem of the agenda on retraction\r\n\t\t\taddPostedActivation(postedActivation, existsEnablingFactHandles, blockingFactHandles);\r\n\t\t}\r\n\t}","id":30482,"modified_method":"/**\r\n\t * Assert a new <code>Tuple<\/code>.\r\n\t * \r\n\t * @param tuple\r\n\t *            The <code>Tuple<\/code> being asserted.\r\n\t * @param workingMemory\r\n\t *            The working memory seesion.\r\n\t * @throws AssertionException\r\n\t *             If an error occurs while asserting.\r\n\t */\r\n\tpublic void assertTuple(LeapsTuple tuple, List blockingFactHandles\r\n\t\t\t, List existsEnablingFactHandles,\r\n\t\t\tPropagationContext context, Rule rule) {\r\n\t\tFactHandleImpl factHandle;\r\n\t\t// if the current Rule is no-loop and the origin rule is the same then\r\n\t\t// return\r\n\t\tif (rule.getNoLoop() && rule.equals(context.getRuleOrigin())) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// see if there are blocking facts and put it on pending activations\r\n\t\t// list without submitting to agenda\r\n\t\tif (blockingFactHandles.size() != 0) {\r\n\t\t\tPendingTuple pendingTuple = new PendingTuple(\r\n\t\t\t\t\ttuple, existsEnablingFactHandles,context, rule,\r\n\t\t\t\t\t(existsEnablingFactHandles != null)\r\n\t\t\t\t\t\t\t&& (existsEnablingFactHandles.size() > 0),\r\n\t\t\t\t\t(existsEnablingFactHandles != null)?existsEnablingFactHandles.size():0,\r\n\t\t\t\t\t(blockingFactHandles != null)\r\n\t\t\t\t\t\t\t&& (blockingFactHandles.size() > 0),\r\n\t\t\t\t\t\t\t(blockingFactHandles != null)?blockingFactHandles.size():0);\r\n\t\t\t// exists qualifiers\r\n\t\t\taddPendingTuple(pendingTuple, existsEnablingFactHandles, blockingFactHandles);\r\n\t\t\t//\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDuration dur = rule.getDuration();\r\n\r\n\t\tActivation agendaItem;\r\n\t\tif (dur != null && dur.getDuration(tuple) > 0) {\r\n\t\t\t agendaItem = new ScheduledAgendaItem(context\r\n\t\t\t\t\t.getPropagationNumber(), tuple, this.agenda, context, rule);\r\n\t\t\tthis.agenda.scheduleItem((ScheduledAgendaItem)agendaItem);\r\n\t\t\ttuple.setActivation(agendaItem);\r\n\t\t\tagendaItem.setActivated(true);\r\n\t\t\tthis.getAgendaEventSupport().fireActivationCreated(agendaItem);\r\n\t\t} else {\r\n\t\t\t// -----------------\r\n\t\t\t// Lazy instantiation and addition to the Agenda of AgendGroup\r\n\t\t\t// implementations\r\n\t\t\t// ----------------\r\n\t\t\tAgendaGroupImpl agendaGroup = null;\r\n\t\t\tif (rule.getAgendaGroup() == null\r\n\t\t\t\t\t|| rule.getAgendaGroup().equals(\"\")\r\n\t\t\t\t\t|| rule.getAgendaGroup().equals(AgendaGroup.MAIN)) {\r\n\t\t\t\t// Is the Rule AgendaGroup undefined? If it is use MAIN, which\r\n\t\t\t\t// is added to the Agenda by default\r\n\t\t\t\tagendaGroup = (AgendaGroupImpl) this.agenda\r\n\t\t\t\t\t\t.getAgendaGroup(AgendaGroup.MAIN);\r\n\t\t\t} else {\r\n\t\t\t\t// AgendaGroup is defined, so try and get the AgendaGroup from\r\n\t\t\t\t// the Agenda\r\n\t\t\t\tagendaGroup = (AgendaGroupImpl) this.agenda.getAgendaGroup(rule\r\n\t\t\t\t\t\t.getAgendaGroup());\r\n\t\t\t}\r\n\r\n\t\t\tif (agendaGroup == null) {\r\n\t\t\t\t// The AgendaGroup is defined but not yet added to the Agenda,\r\n\t\t\t\t// so create the AgendaGroup and add to the Agenda.\r\n\t\t\t\tagendaGroup = new AgendaGroupImpl(rule.getAgendaGroup());\r\n\t\t\t\tthis.agenda.addAgendaGroup(agendaGroup);\r\n\t\t\t}\r\n\r\n\t\t\t// set the focus if rule autoFocus is true\r\n\t\t\tif (rule.getAutoFocus()) {\r\n\t\t\t\tthis.agenda.setFocus(agendaGroup);\r\n\t\t\t}\r\n\r\n\t\t\tActivationQueue queue = agendaGroup.getActivationQueue(rule\r\n\t\t\t\t\t.getSalience());\r\n\t\t\tagendaItem = new AgendaItem(context.getPropagationNumber(),\r\n\t\t\t\t\ttuple, context, rule, queue);\r\n\r\n\t\t\tqueue.add(agendaItem);\r\n\r\n\t\t\t// Makes sure the Lifo is added to the AgendaGroup priority queue\r\n\t\t\t// If the AgendaGroup is already in the priority queue it just\r\n\t\t\t// returns.\r\n\t\t\tagendaGroup.addToAgenda(queue);\r\n\t\t\ttuple.setActivation(agendaItem);\r\n\t\t\tagendaItem.setActivated(true);\r\n\t\t\tthis.getAgendaEventSupport().fireActivationCreated(agendaItem);\r\n\t\t\t// added relationships to use during retract\r\n\t\t\t\r\n\t\t\tPostedActivation postedActivation = new PostedActivation(\r\n\t\t\t\t\t(AgendaItem) agendaItem,\r\n\t\t\t\t\t(existsEnablingFactHandles != null)\r\n\t\t\t\t\t\t\t&& (existsEnablingFactHandles.size() > 0),\r\n\t\t\t\t\t(existsEnablingFactHandles != null) ? existsEnablingFactHandles\r\n\t\t\t\t\t\t\t.size()\r\n\t\t\t\t\t\t\t: -1);\r\n\t\t\t// to take agendaItem of the agenda on retraction\r\n\t\t\taddPostedActivation(postedActivation, existsEnablingFactHandles);\r\n\t\t}\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void addPostedActivation(PostedActivation activation,\r\n\t\t\tList existsFactHandles, List notFactHandles) {\r\n\t\tlong id;\r\n\t\tRetractAssembly assembly;\r\n\t\t// 1. core facts\r\n\t\tFactHandle []factHandles = activation.getAgendaItem().getTuple().getFactHandles();\r\n\t\tfor(int i = 0; i < factHandles.length; i++ ){\r\n\t\t\tid = ((FactHandleImpl)factHandles[i]).getId();\r\n\t\t\tassembly = (RetractAssembly)this.retracts.get(id);\r\n\t\t\tif(assembly == null) {\r\n\t\t\t\tassembly = new RetractAssembly();\r\n\t\t\t\tthis.retracts.put(id, assembly);\r\n\t\t\t}\r\n\t\t\tassembly.addPostedActivation(activation);\r\n\t\t}\r\n\t\t// 2. exists\r\n\t\tif(existsFactHandles != null){\r\n\t\t\tfor(Iterator it = existsFactHandles.iterator(); it.hasNext();){\r\n\t\t\t\tid = ((FactHandleImpl)it.next()).getId();\r\n\t\t\t\tassembly = (RetractAssembly)this.retracts.get(id);\r\n\t\t\t\tif(assembly == null) {\r\n\t\t\t\t\tassembly = new RetractAssembly();\r\n\t\t\t\t\tthis.retracts.put(id, assembly);\r\n\t\t\t\t}\r\n\t\t\t\tassembly.addPostedExist(activation);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 3. exists\r\n\t\tif(notFactHandles != null){\r\n\t\t\tfor(Iterator it = notFactHandles.iterator(); it.hasNext();){\r\n\t\t\t\tid = ((FactHandleImpl)it.next()).getId();\r\n\t\t\t\tassembly = (RetractAssembly)this.retracts.get(id);\r\n\t\t\t\tif(assembly == null) {\r\n\t\t\t\t\tassembly = new RetractAssembly();\r\n\t\t\t\t\tthis.retracts.put(id, assembly);\r\n\t\t\t\t}\r\n\t\t\t\tassembly.addPostedNot(activation);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":30483,"modified_method":"private void addPostedActivation(PostedActivation activation,\r\n\t\t\tList existsFactHandles) {\r\n\t\tlong id;\r\n\t\tRetractAssembly assembly;\r\n\t\t// 1. core facts\r\n\t\tFactHandle []factHandles = activation.getAgendaItem().getTuple().getFactHandles();\r\n\t\tfor(int i = 0; i < factHandles.length; i++ ){\r\n\t\t\tid = ((FactHandleImpl)factHandles[i]).getId();\r\n\t\t\tassembly = (RetractAssembly)this.retracts.get(id);\r\n\t\t\tif(assembly == null) {\r\n\t\t\t\tassembly = new RetractAssembly();\r\n\t\t\t\tthis.retracts.put(id, assembly);\r\n\t\t\t}\r\n\t\t\tassembly.addPostedActivation(activation);\r\n\t\t}\r\n\t\t// 2. exists\r\n\t\tif(existsFactHandles != null){\r\n\t\t\tfor(Iterator it = existsFactHandles.iterator(); it.hasNext();){\r\n\t\t\t\tid = ((FactHandleImpl)it.next()).getId();\r\n\t\t\t\tassembly = (RetractAssembly)this.retracts.get(id);\r\n\t\t\t\tif(assembly == null) {\r\n\t\t\t\t\tassembly = new RetractAssembly();\r\n\t\t\t\t\tthis.retracts.put(id, assembly);\r\n\t\t\t\t}\r\n\t\t\t\tassembly.addPostedExist(activation);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 3. (not is irrelevant for posted activations\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n\t * @see WorkingMemory\r\n\t */\r\n\tpublic void retractObject(FactHandle handle, boolean removeLogical,\r\n\t\t\tboolean updateEqualsMap, Rule rule, Activation activation)\r\n\t\t\tthrows FactException {\r\n\t\tremovePropertyChangeListener(handle);\r\n\t\tPropagationContextImpl context = new PropagationContextImpl(\r\n\t\t\t\t++this.propagationIdCounter, PropagationContext.RETRACTION,\r\n\t\t\t\trule, activation);\r\n\t\t// this.ruleBase.retractObject( handle,\r\n\t\t// propagationContext,\r\n\t\t// this );\r\n\r\n\t\t//\r\n\t\t// leaps specific actions\r\n\t\t//\r\n\t\tIterator it;\r\n\t\tRetractAssembly info = (RetractAssembly) this.retracts\r\n\t\t\t\t.remove(((FactHandleImpl) handle).getId());\r\n\t\tif (info != null) {\r\n\t\t\t// we can have three types of facts being retracted\r\n\t\t\t// 1. part of the tuple\r\n\t\t\t// 2. part of not condition\r\n\t\t\t// 3. part of exists condition\r\n\t\t\t// each of this conditions can apply to pending agendaItem (waiting\r\n\t\t\t// on not facts disappear)\r\n\t\t\t// or posted agendaItem\r\n\r\n\t\t\t// pending agendaItem\r\n\t\t\tPendingTuple pendingTuple;\r\n\t\t\t// first set of iterations to try to invalidate\r\n\t\t\t// 1. part of the tuple\r\n\t\t\t// 2. part of not condition\r\n\t\t\t// 3. part of exists condition\r\n\r\n\t\t\t// first we try invalidate core and exists related tuples\r\n\t\t\tfor (it = info.getPendingTuples(); it.hasNext();) {\r\n\t\t\t\tpendingTuple = (PendingTuple) it.next();\r\n\t\t\t\tif (pendingTuple.isValid()) {\r\n\t\t\t\t\tinvalidatePendingTuple(pendingTuple);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (it = info.getPendingExists(); it.hasNext();) {\r\n\t\t\t\tpendingTuple = (PendingTuple) it.next();\r\n\t\t\t\tif (pendingTuple.isValid()) {\r\n\t\t\t\t\tpendingTuple.decrementExistsCount();\r\n\t\t\t\t\tif (!pendingTuple.isValid()) {\r\n\t\t\t\t\t\tinvalidatePendingTuple(pendingTuple);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// then we decrement not and see if we can submit it\r\n\t\t\tfor (it = info.getPendingNots(); it.hasNext();) {\r\n\t\t\t\tpendingTuple = (PendingTuple) it.next();\r\n\t\t\t\tif (pendingTuple.isValid()) {\r\n\t\t\t\t\tpendingTuple.decrementNotCount();\r\n\t\t\t\t\tif (!pendingTuple.isValid()) {\r\n\t\t\t\t\t\tinvalidatePendingTuple(pendingTuple);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tassertTuple(pendingTuple.getTuple(), new ArrayList(),\r\n\t\t\t\t\t\t\t\tpendingTuple.getExistsQualifiers(),\r\n\t\t\t\t\t\t\t\tpendingTuple.getContext(), pendingTuple\r\n\t\t\t\t\t\t\t\t\t\t.getRule());\r\n\t\t\t\t\t\t// and let everybody know that we submited it\r\n\t\t\t\t\t\tpendingTuple.setSubmited();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// posted agendaItem\r\n\t\t\t// 1. part of the tuple\r\n\t\t\t// 2. part of not condition\r\n\t\t\t// 3. part of exists condition\r\n\t\t\tPostedActivation postedActivation;\r\n\t\t\tfor (it = info.getPostedActivations(); it.hasNext();) {\r\n\t\t\t\tpostedActivation = (PostedActivation) it.next();\r\n\t\t\t\tif (postedActivation.isValid()) {\r\n\t\t\t\t\t// no need to take actions. just invalidate\r\n\t\t\t\t\tinvalidatePostedActivation(postedActivation);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (it = info.getPostedExists(); it.hasNext();) {\r\n\t\t\t\tpostedActivation = (PostedActivation) it.next();\r\n\t\t\t\tif (postedActivation.isValid()) {\r\n\t\t\t\t\tpostedActivation.decrementExistsCount();\r\n\t\t\t\t\tif (!postedActivation.isValid()) {\r\n\t\t\t\t\t\tinvalidatePostedActivation(postedActivation);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (it = info.getPostedNots(); it.hasNext();) {\r\n\t\t\t\tpostedActivation = (PostedActivation) it.next();\r\n\t\t\t\tif (postedActivation.isValid()) {\r\n\t\t\t\t\tpostedActivation.decrementNotCount();\r\n\t\t\t\t\tif (!postedActivation.isValid()) {\r\n\t\t\t\t\t\tinvalidatePostedActivation(postedActivation);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// remove it from stack\r\n\t\tthis.stack.remove(new Token(this, (FactHandleImpl) handle));\r\n\r\n\t\t//\r\n\t\t// end leaps specific actions\r\n\t\t//\r\n\t\tObject oldObject = removeObject(handle);\r\n\r\n\t\t/* check to see if this was a logical asserted object */\r\n\t\tif (removeLogical) {\r\n\t\t\tremoveLogicalDependencies(handle);\r\n\t\t\tthis.equalsMap.remove(oldObject);\r\n\t\t}\r\n\r\n\t\tif (updateEqualsMap) {\r\n\t\t\tthis.equalsMap.remove(oldObject);\r\n\t\t}\r\n\r\n\t\t// not applicable to leaps implementation\r\n\t\t// this.factHandlePool.push( ((FactHandleImpl) handle).getId() );\r\n\r\n\t\tthis.workingMemoryEventSupport.fireObjectRetracted(context, handle,\r\n\t\t\t\toldObject);\r\n\t\t// not applicable to leaps fact handle\r\n\t\t// ((FactHandleImpl) handle).invalidate();\r\n\t}","id":30484,"modified_method":"/**\r\n\t * @see WorkingMemory\r\n\t */\r\n\tpublic void retractObject(FactHandle handle, boolean removeLogical,\r\n\t\t\tboolean updateEqualsMap, Rule rule, Activation activation)\r\n\t\t\tthrows FactException {\r\n\t\tremovePropertyChangeListener(handle);\r\n\t\tPropagationContextImpl context = new PropagationContextImpl(\r\n\t\t\t\t++this.propagationIdCounter, PropagationContext.RETRACTION,\r\n\t\t\t\trule, activation);\r\n\t\t// this.ruleBase.retractObject( handle,\r\n\t\t// propagationContext,\r\n\t\t// this );\r\n\r\n\t\t//\r\n\t\t// leaps specific actions\r\n\t\t//\r\n\t\tIterator it;\r\n\t\tRetractAssembly info = (RetractAssembly) this.retracts\r\n\t\t\t\t.remove(((FactHandleImpl) handle).getId());\r\n\t\tif (info != null) {\r\n\t\t\t// we can have three types of facts being retracted\r\n\t\t\t// 1. part of the tuple\r\n\t\t\t// 2. part of not condition\r\n\t\t\t// 3. part of exists condition\r\n\t\t\t// each of this conditions can apply to pending agendaItem (waiting\r\n\t\t\t// on not facts disappear)\r\n\t\t\t// or posted agendaItem\r\n\r\n\t\t\t// pending agendaItem\r\n\t\t\tPendingTuple pendingTuple;\r\n\t\t\t// first set of iterations to try to invalidate\r\n\t\t\t// 1. part of the tuple\r\n\t\t\t// 2. part of not condition\r\n\t\t\t// 3. part of exists condition\r\n\r\n\t\t\t// first we try invalidate core and exists related tuples\r\n\t\t\tfor (it = info.getPendingTuples(); it.hasNext();) {\r\n\t\t\t\tpendingTuple = (PendingTuple) it.next();\r\n\t\t\t\tif (pendingTuple.isValid()) {\r\n\t\t\t\t\tinvalidatePendingTuple(pendingTuple);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (it = info.getPendingExists(); it.hasNext();) {\r\n\t\t\t\tpendingTuple = (PendingTuple) it.next();\r\n\t\t\t\tif (pendingTuple.isValid()) {\r\n\t\t\t\t\tpendingTuple.decrementExistsCount();\r\n\t\t\t\t\tif (!pendingTuple.isValid()) {\r\n\t\t\t\t\t\tinvalidatePendingTuple(pendingTuple);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// then we decrement not and see if we can submit it\r\n\t\t\tfor (it = info.getPendingNots(); it.hasNext();) {\r\n\t\t\t\tpendingTuple = (PendingTuple) it.next();\r\n\t\t\t\tif (pendingTuple.isValid()) {\r\n\t\t\t\t\tpendingTuple.decrementNotCount();\r\n\t\t\t\t\tif (!pendingTuple.isValid()) {\r\n\t\t\t\t\t\tinvalidatePendingTuple(pendingTuple);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tassertTuple(pendingTuple.getTuple(), new ArrayList(),\r\n\t\t\t\t\t\t\t\tpendingTuple.getExistsQualifiers(),\r\n\t\t\t\t\t\t\t\tpendingTuple.getContext(), pendingTuple\r\n\t\t\t\t\t\t\t\t\t\t.getRule());\r\n\t\t\t\t\t\t// and let everybody know that we submited it\r\n\t\t\t\t\t\tpendingTuple.setSubmited();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// posted agendaItem\r\n\t\t\t// 1. part of the tuple\r\n\t\t\t// 2. part of not condition\r\n\t\t\t// 3. part of exists condition\r\n\t\t\tPostedActivation postedActivation;\r\n\t\t\tfor (it = info.getPostedActivations(); it.hasNext();) {\r\n\t\t\t\tpostedActivation = (PostedActivation) it.next();\r\n\t\t\t\tif (postedActivation.isValid()) {\r\n\t\t\t\t\t// no need to take actions. just invalidate\r\n\t\t\t\t\tinvalidatePostedActivation(postedActivation);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (it = info.getPostedExists(); it.hasNext();) {\r\n\t\t\t\tpostedActivation = (PostedActivation) it.next();\r\n\t\t\t\tif (postedActivation.isValid()) {\r\n\t\t\t\t\tpostedActivation.decrementExistsCount();\r\n\t\t\t\t\tif (!postedActivation.isValid()) {\r\n\t\t\t\t\t\tinvalidatePostedActivation(postedActivation);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// not is irrelevant for posted activations\r\n//\t\t\tfor (it = info.getPostedNots(); it.hasNext();) {\r\n//\t\t\t\tpostedActivation = (PostedActivation) it.next();\r\n//\t\t\t\tif (postedActivation.isValid()) {\r\n//\t\t\t\t\tpostedActivation.decrementNotCount();\r\n//\t\t\t\t\tif (!postedActivation.isValid()) {\r\n//\t\t\t\t\t\tinvalidatePostedActivation(postedActivation);\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n\t\t}\r\n\t\t// remove it from stack\r\n\t\tthis.stack.remove(new Token(this, (FactHandleImpl) handle));\r\n\r\n\t\t//\r\n\t\t// end leaps specific actions\r\n\t\t//\r\n\t\tObject oldObject = removeObject(handle);\r\n\r\n\t\t/* check to see if this was a logical asserted object */\r\n\t\tif (removeLogical) {\r\n\t\t\tremoveLogicalDependencies(handle);\r\n\t\t\tthis.equalsMap.remove(oldObject);\r\n\t\t}\r\n\r\n\t\tif (updateEqualsMap) {\r\n\t\t\tthis.equalsMap.remove(oldObject);\r\n\t\t}\r\n\r\n\t\t// not applicable to leaps implementation\r\n\t\t// this.factHandlePool.push( ((FactHandleImpl) handle).getId() );\r\n\r\n\t\tthis.workingMemoryEventSupport.fireObjectRetracted(context, handle,\r\n\t\t\t\toldObject);\r\n\t\t// not applicable to leaps fact handle\r\n\t\t// ((FactHandleImpl) handle).invalidate();\r\n\t}","commit_id":"48dbe4d64fabd2dad4b6942513c52b13b653a58e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void test1() {\n        KnowledgePackage pkg1 = getKnowledgePackage1();\n        KnowledgePackage pkg2 = getKnowledgePackage1();\n        KnowledgePackage pkg3 = getKnowledgePackage2();\n        \n        Rule rule1 = ((KnowledgePackageImp)pkg1).pkg.getRule( \"rule1\" );\n        Rule rule2 = ((KnowledgePackageImp)pkg2).pkg.getRule( \"rule1\" );\n        Rule rule3 = ((KnowledgePackageImp)pkg3).pkg.getRule( \"rule1\" );\n        \n        // test return value\n        Pattern p1 = ( Pattern ) rule1.getLhs().getChildren().get( 0 );\n        ReturnValueConstraint rvc1 = ( ReturnValueConstraint ) p1.getConstraints().get( 0 );        \n        ReturnValueExpression rve1 = ((ReturnValueRestriction) rvc1.getRestriction()).getExpression();\n        \n        Pattern p2 = ( Pattern ) rule2.getLhs().getChildren().get( 0 );        \n        ReturnValueConstraint rvc2 = ( ReturnValueConstraint ) p2.getConstraints().get( 0 );        \n        ReturnValueExpression rve2 = ((ReturnValueRestriction) rvc2.getRestriction()).getExpression();        \n        \n        assertNotSame( rve1, rve2 );\n        assertEquals( rve1, rve2 );\n        \n        Pattern p3 = ( Pattern ) rule3.getLhs().getChildren().get( 0 );\n        ReturnValueConstraint rvc3 = ( ReturnValueConstraint ) p3.getConstraints().get( 0 );        \n        ReturnValueExpression rve3 = ((ReturnValueRestriction) rvc3.getRestriction()).getExpression();\n        \n        assertNotSame( rve1, rve3 );\n        assertThat(rve1, not( equalTo( rve3 ) ) );\n        \n        // test inline eval\n        PredicateConstraint pc1 = ( PredicateConstraint )  p1.getConstraints().get( 1 );\n        PredicateExpression pe1 = ( PredicateExpression ) pc1.getPredicateExpression();\n\n        PredicateConstraint pc2 = ( PredicateConstraint )  p2.getConstraints().get( 1 );\n        PredicateExpression pe2 = ( PredicateExpression ) pc2.getPredicateExpression();\n        assertNotSame( pe1, pe2 );\n        assertEquals( pe1, pe2 );\n        \n        PredicateConstraint pc3 = ( PredicateConstraint )  p3.getConstraints().get( 1 );\n        PredicateExpression pe3 = ( PredicateExpression ) pc3.getPredicateExpression();\n        assertNotSame( pe1, pe3 );\n        assertThat(pe1, not( equalTo( pe3 ) ) );\n        \n       // test eval\n        EvalCondition ec1 = ( EvalCondition ) rule1.getLhs().getChildren().get( 1 );\n        EvalExpression ee1 =( EvalExpression) ec1.getEvalExpression();\n\n        EvalCondition ec2 = ( EvalCondition ) rule2.getLhs().getChildren().get( 1 );\n        EvalExpression ee2 =( EvalExpression) ec2.getEvalExpression();\n        assertNotSame( ee1, ee2 );\n        assertEquals(ee1, ee2 );\n        \n        EvalCondition ec3 = ( EvalCondition ) rule3.getLhs().getChildren().get( 1 );\n        EvalExpression ee3 =( EvalExpression) ec3.getEvalExpression();\n        assertNotSame( ee1,ee3 );\n        assertThat(ee1, not( equalTo( ee3 ) ) );\n        \n        // test consequence\n        assertNotSame( rule1.getConsequence(), rule2.getConsequence() );\n        assertEquals(rule1.getConsequence(), rule2.getConsequence() );\n        assertNotSame( rule1.getConsequence(), rule3.getConsequence() );\n        assertThat(rule1.getConsequence(), not( equalTo( rule3.getConsequence() ) ) );\n        \n        // check LHS equals\n        assertNotSame(  rule1.getLhs(), rule2.getLhs() );\n        assertEquals( rule1.getLhs(), rule2.getLhs() );\n        \n        assertNotSame( rule1.getLhs(), rule3.getLhs() );\n        assertThat(rule1.getLhs(), not( equalTo( rule3.getLhs() ) ) );\n    }","id":30485,"modified_method":"@Test\n    public void test1() {\n        KnowledgePackage pkg1 = getKnowledgePackage1();\n        KnowledgePackage pkg2 = getKnowledgePackage1();\n        KnowledgePackage pkg3 = getKnowledgePackage2();\n        \n        Rule rule1 = ((KnowledgePackageImp)pkg1).pkg.getRule( \"rule1\" );\n        Rule rule2 = ((KnowledgePackageImp)pkg2).pkg.getRule( \"rule1\" );\n        Rule rule3 = ((KnowledgePackageImp)pkg3).pkg.getRule( \"rule1\" );\n        \n        // test return value\n        Pattern p1 = ( Pattern ) rule1.getLhs().getChildren().get( 0 );\n        VariableConstraint rvc1 = ( VariableConstraint ) p1.getConstraints().get( 0 );        \n        ReturnValueExpression rve1 = ((ReturnValueRestriction) rvc1.getRestriction()).getExpression();\n        \n        Pattern p2 = ( Pattern ) rule2.getLhs().getChildren().get( 0 );        \n        VariableConstraint rvc2 = ( VariableConstraint ) p2.getConstraints().get( 0 );        \n        ReturnValueExpression rve2 = ((ReturnValueRestriction) rvc2.getRestriction()).getExpression();        \n        \n        assertNotSame( rve1, rve2 );\n        assertEquals( rve1, rve2 );\n        \n        Pattern p3 = ( Pattern ) rule3.getLhs().getChildren().get( 0 );\n        VariableConstraint rvc3 = ( VariableConstraint ) p3.getConstraints().get( 0 );        \n        ReturnValueExpression rve3 = ((ReturnValueRestriction) rvc3.getRestriction()).getExpression();\n        \n        assertNotSame( rve1, rve3 );\n        assertThat(rve1, not( equalTo( rve3 ) ) );\n        \n        // test inline eval\n        PredicateConstraint pc1 = ( PredicateConstraint )  p1.getConstraints().get( 1 );\n        PredicateExpression pe1 = ( PredicateExpression ) pc1.getPredicateExpression();\n\n        PredicateConstraint pc2 = ( PredicateConstraint )  p2.getConstraints().get( 1 );\n        PredicateExpression pe2 = ( PredicateExpression ) pc2.getPredicateExpression();\n        assertNotSame( pe1, pe2 );\n        assertEquals( pe1, pe2 );\n        \n        PredicateConstraint pc3 = ( PredicateConstraint )  p3.getConstraints().get( 1 );\n        PredicateExpression pe3 = ( PredicateExpression ) pc3.getPredicateExpression();\n        assertNotSame( pe1, pe3 );\n        assertThat(pe1, not( equalTo( pe3 ) ) );\n        \n       // test eval\n        EvalCondition ec1 = ( EvalCondition ) rule1.getLhs().getChildren().get( 1 );\n        EvalExpression ee1 =( EvalExpression) ec1.getEvalExpression();\n\n        EvalCondition ec2 = ( EvalCondition ) rule2.getLhs().getChildren().get( 1 );\n        EvalExpression ee2 =( EvalExpression) ec2.getEvalExpression();\n        assertNotSame( ee1, ee2 );\n        assertEquals(ee1, ee2 );\n        \n        EvalCondition ec3 = ( EvalCondition ) rule3.getLhs().getChildren().get( 1 );\n        EvalExpression ee3 =( EvalExpression) ec3.getEvalExpression();\n        assertNotSame( ee1,ee3 );\n        assertThat(ee1, not( equalTo( ee3 ) ) );\n        \n        // test consequence\n        assertNotSame( rule1.getConsequence(), rule2.getConsequence() );\n        assertEquals(rule1.getConsequence(), rule2.getConsequence() );\n        assertNotSame( rule1.getConsequence(), rule3.getConsequence() );\n        assertThat(rule1.getConsequence(), not( equalTo( rule3.getConsequence() ) ) );\n        \n        // check LHS equals\n        assertNotSame(  rule1.getLhs(), rule2.getLhs() );\n        assertEquals( rule1.getLhs(), rule2.getLhs() );\n        \n        assertNotSame( rule1.getLhs(), rule3.getLhs() );\n        assertThat(rule1.getLhs(), not( equalTo( rule3.getLhs() ) ) );\n    }","commit_id":"d413b46ee1587e68e4c41c62a5ebd745fe884be0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testEvalDetectionInBetaNode() {\n        // Tests evals are generated and executed with Java dialect\n        \n        String drl = \"\";\n        drl += \"package org.test\\n\";\n        drl += \"import org.drools.Person\\n\";\n        drl += \"global java.util.List list\\n\";\n        drl += \"rule test1\\n\";\n        drl += \"when\\n\";\n        drl += \"   $s  : String()\\n\";\n        drl += \"   $p1 : Person( eval( name \\n != $s ), name == ( new String($s+\\\"xxx\\\") ) )\\n\";\n        drl += \"then\\n\";\n        drl += \"end\\n\";\n\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newReaderResource( new StringReader( drl ) ),\n                      ResourceType.DRL );\n        KnowledgeBuilderErrors errors = kbuilder.getErrors();\n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n        assertFalse( kbuilder.hasErrors() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n        \n        List<ObjectTypeNode> nodes = ((InternalRuleBase)((KnowledgeBaseImpl)kbase).ruleBase).getRete().getObjectTypeNodes();\n        ObjectTypeNode node = null;\n        for ( ObjectTypeNode n : nodes ) {\n            if ( ((ClassObjectType)n.getObjectType()).getClassType() == Person.class ) {\n                node = n;\n                break;\n            }\n        }\n        \n        BetaNode betaanode = (BetaNode) node.getSinkPropagator().getSinks()[0];\n        BetaNodeFieldConstraint[] constraint = ( BetaNodeFieldConstraint[] ) betaanode.getConstraints();\n        PredicateConstraint c = ( PredicateConstraint ) constraint[0];\n        assertTrue( c.getPredicateExpression() instanceof PredicateExpression );\n        assertTrue( c.getPredicateExpression() instanceof CompiledInvoker );\n        assertTrue( !(c.getPredicateExpression() instanceof MVELPredicateExpression ) );\n         \n        ReturnValueRestriction r = ( ReturnValueRestriction ) (( ReturnValueConstraint )constraint[1]).getRestriction();\n        assertTrue( r.getExpression() instanceof ReturnValueExpression );\n        assertTrue( r.getExpression() instanceof CompiledInvoker );\n        assertTrue( !(r.getExpression() instanceof MVELReturnValueExpression ) );        \n    }","id":30486,"modified_method":"@Test\n    public void testEvalDetectionInBetaNode() {\n        // Tests evals are generated and executed with Java dialect\n        \n        String drl = \"\";\n        drl += \"package org.test\\n\";\n        drl += \"import org.drools.Person\\n\";\n        drl += \"global java.util.List list\\n\";\n        drl += \"rule test1\\n\";\n        drl += \"when\\n\";\n        drl += \"   $s  : String()\\n\";\n        drl += \"   $p1 : Person( eval( name \\n != $s ), name == ( new String($s+\\\"xxx\\\") ) )\\n\";\n        drl += \"then\\n\";\n        drl += \"end\\n\";\n\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newReaderResource( new StringReader( drl ) ),\n                      ResourceType.DRL );\n        KnowledgeBuilderErrors errors = kbuilder.getErrors();\n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n        assertFalse( kbuilder.hasErrors() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n        \n        List<ObjectTypeNode> nodes = ((InternalRuleBase)((KnowledgeBaseImpl)kbase).ruleBase).getRete().getObjectTypeNodes();\n        ObjectTypeNode node = null;\n        for ( ObjectTypeNode n : nodes ) {\n            if ( ((ClassObjectType)n.getObjectType()).getClassType() == Person.class ) {\n                node = n;\n                break;\n            }\n        }\n        \n        BetaNode betaanode = (BetaNode) node.getSinkPropagator().getSinks()[0];\n        BetaNodeFieldConstraint[] constraint = ( BetaNodeFieldConstraint[] ) betaanode.getConstraints();\n        PredicateConstraint c = ( PredicateConstraint ) constraint[0];\n        assertTrue( c.getPredicateExpression() instanceof PredicateExpression );\n        assertTrue( c.getPredicateExpression() instanceof CompiledInvoker );\n        assertTrue( !(c.getPredicateExpression() instanceof MVELPredicateExpression ) );\n         \n        ReturnValueRestriction r = ( ReturnValueRestriction ) (( VariableConstraint )constraint[1]).getRestriction();\n        assertTrue( r.getExpression() instanceof ReturnValueExpression );\n        assertTrue( r.getExpression() instanceof CompiledInvoker );\n        assertTrue( !(r.getExpression() instanceof MVELReturnValueExpression ) );        \n    }","commit_id":"d413b46ee1587e68e4c41c62a5ebd745fe884be0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testEvalDetectionInAlphaNode() {\n        // Tests evals are generated and executed with Java dialect\n        String drl = \"\";\n        drl += \"package org.test\\n\";\n        drl += \"import org.drools.Person\\n\";\n        drl += \"global java.util.List list\\n\";\n        drl += \"rule test1\\n\";\n        drl += \"when\\n\";\n        drl += \"   $p1 : Person( eval( name \\n != null ), name == ( new String(\\\"xxx\\\") ) )\\n\";\n        drl += \"then\\n\";\n        drl += \"end\\n\";\n\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newReaderResource( new StringReader( drl ) ),\n                      ResourceType.DRL );\n        KnowledgeBuilderErrors errors = kbuilder.getErrors();\n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n        assertFalse( kbuilder.hasErrors() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n        \n        List<ObjectTypeNode> nodes = ((InternalRuleBase)((KnowledgeBaseImpl)kbase).ruleBase).getRete().getObjectTypeNodes();\n        ObjectTypeNode node = null;\n        for ( ObjectTypeNode n : nodes ) {\n            if ( ((ClassObjectType)n.getObjectType()).getClassType() == Person.class ) {\n                node = n;\n                break;\n            }\n        }\n        \n        AlphaNode alphanode = (AlphaNode) node.getSinkPropagator().getSinks()[0];\n        PredicateConstraint c = ( PredicateConstraint ) alphanode.getConstraint();\n        assertTrue( c.getPredicateExpression() instanceof PredicateExpression );\n        assertTrue( c.getPredicateExpression() instanceof CompiledInvoker );\n        assertTrue( !(c.getPredicateExpression() instanceof MVELPredicateExpression ) );\n        \n        alphanode = (AlphaNode) alphanode.getSinkPropagator().getSinks()[0];\n        ReturnValueRestriction r = (ReturnValueRestriction) (( ReturnValueConstraint ) alphanode.getConstraint()).getRestriction();\n        \n        assertTrue( r.getExpression() instanceof ReturnValueExpression );\n        assertTrue( r.getExpression() instanceof CompiledInvoker );\n        assertTrue( !(r.getExpression() instanceof MVELReturnValueExpression ) );        \n    }","id":30487,"modified_method":"@Test\n    public void testEvalDetectionInAlphaNode() {\n        // Tests evals are generated and executed with Java dialect\n        String drl = \"\";\n        drl += \"package org.test\\n\";\n        drl += \"import org.drools.Person\\n\";\n        drl += \"global java.util.List list\\n\";\n        drl += \"rule test1\\n\";\n        drl += \"when\\n\";\n        drl += \"   $p1 : Person( eval( name \\n != null ), name == ( new String(\\\"xxx\\\") ) )\\n\";\n        drl += \"then\\n\";\n        drl += \"end\\n\";\n\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newReaderResource( new StringReader( drl ) ),\n                      ResourceType.DRL );\n        KnowledgeBuilderErrors errors = kbuilder.getErrors();\n        if ( kbuilder.hasErrors() ) {\n            fail( kbuilder.getErrors().toString() );\n        }\n        assertFalse( kbuilder.hasErrors() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n        \n        List<ObjectTypeNode> nodes = ((InternalRuleBase)((KnowledgeBaseImpl)kbase).ruleBase).getRete().getObjectTypeNodes();\n        ObjectTypeNode node = null;\n        for ( ObjectTypeNode n : nodes ) {\n            if ( ((ClassObjectType)n.getObjectType()).getClassType() == Person.class ) {\n                node = n;\n                break;\n            }\n        }\n        \n        AlphaNode alphanode = (AlphaNode) node.getSinkPropagator().getSinks()[0];\n        PredicateConstraint c = ( PredicateConstraint ) alphanode.getConstraint();\n        assertTrue( c.getPredicateExpression() instanceof PredicateExpression );\n        assertTrue( c.getPredicateExpression() instanceof CompiledInvoker );\n        assertTrue( !(c.getPredicateExpression() instanceof MVELPredicateExpression ) );\n        \n        alphanode = (AlphaNode) alphanode.getSinkPropagator().getSinks()[0];\n        ReturnValueRestriction r = (ReturnValueRestriction) (( VariableConstraint ) alphanode.getConstraint()).getRestriction();\n        \n        assertTrue( r.getExpression() instanceof ReturnValueExpression );\n        assertTrue( r.getExpression() instanceof CompiledInvoker );\n        assertTrue( !(r.getExpression() instanceof MVELReturnValueExpression ) );        \n    }","commit_id":"d413b46ee1587e68e4c41c62a5ebd745fe884be0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testReturnValueMethodCompare() {\n        final PackageBuilder builder1 = new PackageBuilder();\n        final PackageDescr packageDescr1 = new PackageDescr( \"package1\" );\n        createReturnValueRule( packageDescr1,\n                               \" x + y \" );\n        builder1.addPackage( packageDescr1 );\n        if ( builder1.hasErrors() ) {\n            fail( builder1.getErrors().toString() );\n        }\n        final Pattern pattern1 = (Pattern) builder1.getPackage().getRules()[0].getLhs().getChildren().get( 0 );\n        final ReturnValueConstraint returnValue1 = (ReturnValueConstraint) pattern1.getConstraints().get( 0 );\n\n        final PackageBuilder builder2 = new PackageBuilder();\n        final PackageDescr packageDescr2 = new PackageDescr( \"package2\" );\n        createReturnValueRule( packageDescr2,\n                               \" x + y \" );\n        builder2.addPackage( packageDescr2 );\n        final Pattern pattern2 = (Pattern) builder2.getPackage().getRules()[0].getLhs().getChildren().get( 0 );\n        final ReturnValueConstraint returnValue2 = (ReturnValueConstraint) pattern2.getConstraints().get( 0 );\n\n        final PackageBuilder builder3 = new PackageBuilder();\n        final PackageDescr packageDescr3 = new PackageDescr( \"package3\" );\n        createReturnValueRule( packageDescr3,\n                               \" x - y \" );\n        builder3.addPackage( packageDescr3 );\n        final Pattern pattern3 = (Pattern) builder3.getPackage().getRules()[0].getLhs().getChildren().get( 0 );\n        final ReturnValueConstraint returnValue3 = (ReturnValueConstraint) pattern3.getConstraints().get( 0 );\n\n        assertEquals( returnValue1,\n                      returnValue2 );\n        assertFalse( returnValue1.equals( returnValue3 ) );\n        assertFalse( returnValue2.equals( returnValue3 ) );\n    }","id":30488,"modified_method":"@Test\n    public void testReturnValueMethodCompare() {\n        final PackageBuilder builder1 = new PackageBuilder();\n        final PackageDescr packageDescr1 = new PackageDescr( \"package1\" );\n        createReturnValueRule( packageDescr1,\n                               \" x + y \" );\n        builder1.addPackage( packageDescr1 );\n        if ( builder1.hasErrors() ) {\n            fail( builder1.getErrors().toString() );\n        }\n        final Pattern pattern1 = (Pattern) builder1.getPackage().getRules()[0].getLhs().getChildren().get( 0 );\n        final VariableConstraint returnValue1 = (VariableConstraint) pattern1.getConstraints().get( 0 );\n\n        final PackageBuilder builder2 = new PackageBuilder();\n        final PackageDescr packageDescr2 = new PackageDescr( \"package2\" );\n        createReturnValueRule( packageDescr2,\n                               \" x + y \" );\n        builder2.addPackage( packageDescr2 );\n        final Pattern pattern2 = (Pattern) builder2.getPackage().getRules()[0].getLhs().getChildren().get( 0 );\n        final VariableConstraint returnValue2 = (VariableConstraint) pattern2.getConstraints().get( 0 );\n\n        final PackageBuilder builder3 = new PackageBuilder();\n        final PackageDescr packageDescr3 = new PackageDescr( \"package3\" );\n        createReturnValueRule( packageDescr3,\n                               \" x - y \" );\n        builder3.addPackage( packageDescr3 );\n        final Pattern pattern3 = (Pattern) builder3.getPackage().getRules()[0].getLhs().getChildren().get( 0 );\n        final VariableConstraint returnValue3 = (VariableConstraint) pattern3.getConstraints().get( 0 );\n\n        assertEquals( returnValue1,\n                      returnValue2 );\n        assertFalse( returnValue1.equals( returnValue3 ) );\n        assertFalse( returnValue2.equals( returnValue3 ) );\n    }","commit_id":"d413b46ee1587e68e4c41c62a5ebd745fe884be0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void build( RuleBuildContext context,\n                       Pattern pattern,\n                       ExprConstraintDescr descr ) {\n        DrlExprParser parser = new DrlExprParser();\n        ConstraintConnectiveDescr result = parser.parse( descr.getText() );\n        if ( result == null || parser.hasErrors() ) {\n            for ( DroolsParserException error : parser.getErrors() ) {\n                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                              descr,\n                                                              null,\n                                                              \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n            }\n            return;\n        }\n\n        for ( Iterator<BaseDescr> it = result.getDescrs().iterator(); it.hasNext(); ) {\n            BaseDescr d = it.next();\n\n\n            boolean simple = false;\n            MVELDumper.MVELDumperContext mvelCtx = new MVELDumper.MVELDumperContext();\n            String expr = new MVELDumper().dump( d,\n                                                 mvelCtx );\n            Map<String, OperatorDescr> aliases = mvelCtx.getAliases();\n            RelationalExprDescr relDescr = null;\n            if ( d instanceof RelationalExprDescr ) {\n                relDescr = (RelationalExprDescr) d;\n                if ( relDescr.getLeft() instanceof AtomicExprDescr &&\n                      relDescr.getRight() instanceof AtomicExprDescr ) {\n                    simple = true;\n                }\n            }\n\n            if ( d instanceof AtomicExprDescr ) {\n                Matcher m = evalRegexp.matcher( ((AtomicExprDescr)d).getExpression() );                \n                if (m.find()) {  \n                    // MVELDumper already stripped the eval\n                    // this will build the eval using the specified dialect\n                    PredicateDescr pdescr = new PredicateDescr( expr );\n                    buildEval( context,\n                               pattern,\n                               pdescr,\n                               null,\n                               aliases );\n                    continue;\n                }\n            }\n\n            // Either it's a complex expression, so do as predicate\n            // Or it's a Map and we have to treat it as a special case\n            if ( !simple  ||  new ClassObjectType(Map.class).isAssignableFrom( pattern.getObjectType() ) ) {\n                Dialect dialect = context.getDialect();\n                MVELDialect mvelDialect = (MVELDialect) context.getDialect( \"mvel\" );\n                context.setDialect( mvelDialect );\n\n                PredicateDescr pdescr = new PredicateDescr( expr );\n                buildEval( context,\n                           pattern,\n                           pdescr,\n                           null,\n                           aliases );\n\n                // fall back to original dialect\n                context.setDialect( dialect );\n                continue;\n            }\n\n            if ( !(d instanceof RelationalExprDescr) ) {\n                throw new RuntimeException( \"What caused this?: \" + d );\n            }\n\n            RelationalExprDescr exprDescr = (RelationalExprDescr) d;\n\n            AtomicExprDescr rdescr = ((AtomicExprDescr) exprDescr.getRight());\n            String fieldName = ((AtomicExprDescr) exprDescr.getLeft()).getExpression();\n            String value = rdescr.getExpression().trim();\n\n            ExprBindings rightExpr = new ExprBindings();\n            setInputs( context,\n                       rightExpr,\n                       (pattern.getObjectType() instanceof ClassObjectType) ? ((ClassObjectType) pattern.getObjectType()).getClassType() : FactTemplate.class,\n                       value );\n\n            String[] parts = fieldName.split( \"\\\\.\" );\n            if ( parts.length == 2 ) {\n                if ( \"this\".equals( parts[0].trim() ) ) {\n                    // it's a redundant this so trim\n                    fieldName = parts[1];                    \n                } else if ( pattern.getDeclaration() != null && parts[0].trim().equals( pattern.getDeclaration().getIdentifier() ) ) {\n                    // it's a redundant declaration so trim\n                    fieldName = parts[1];\n                }\n            }\n\n            if ( fieldName.indexOf( '.' ) >= 0 || fieldName.indexOf( '[' ) >= 0 || fieldName.indexOf( '(' ) >= 0 ) {\n                // if left has any inputs then we need to rewrite to eval\n                ExprBindings leftExpr = new ExprBindings();\n                setInputs( context,\n                           leftExpr,\n                           ((ClassObjectType) ((Pattern) context.getBuildStack().peek()).getObjectType()).getClassType(),\n                           fieldName );\n                if ( !leftExpr.getRuleBindings().isEmpty() ) {\n                    Dialect dialect = context.getDialect();\n                    MVELDialect mvelDialect = (MVELDialect) context.getDialect( \"mvel\" );\n                    context.setDialect( mvelDialect );\n\n                    PredicateDescr pdescr = new PredicateDescr( expr );\n                    buildEval( context,\n                               pattern,\n                               pdescr,\n                               null,\n                               aliases );\n\n                    // fall back to original dialect\n                    context.setDialect( dialect );\n                    continue;\n                }\n            }\n\n            final InternalReadAccessor extractor = getFieldReadAccessor( context,\n                                                                         d,\n                                                                         pattern.getObjectType(),\n                                                                         fieldName,\n                                                                         null );\n\n            if ( extractor == null ) {\n                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                              d,\n                                                              null,\n                                                              \"Unable to build constraint as  '\" + fieldName + \"' is invalid\" ) );\n                continue;\n            }\n\n            String operator = relDescr.getOperator().trim();\n\n            Restriction restriction = null;\n            // is it a literal? Does not include enums\n            if ( rdescr.isLiteral() ) {\n                restriction = buildLiteralRestriction( context,\n                                                       extractor,\n                                                       new LiteralRestrictionDescr( operator,\n                                                                                    relDescr.isNegated(),\n                                                                                    relDescr.getParameters(),\n                                                                                    value,\n                                                                                    LiteralRestrictionDescr.TYPE_STRING ) ); // default type\n                if ( restriction == null ) {\n                    // otherwise we just get wierd errors after this point on literals\n                    continue;\n                }\n            } else {\n                // is it an enum?\n                int dotPos = value.lastIndexOf( '.' );\n                if ( dotPos >= 0 ) {\n                    final String mainPart = value.substring( 0,\n                                                             dotPos );\n                    String lastPart = value.substring( dotPos + 1 );\n                    try {\n                        final Class< ? > cls = context.getDialect().getTypeResolver().resolveType( mainPart );\n                        if ( lastPart.indexOf( '(' ) < 0 && lastPart.indexOf( '.' ) < 0 && lastPart.indexOf( '[' ) < 0 ) {\n                            restriction = buildLiteralRestriction( context,\n                                                                   extractor,\n                                                                   new LiteralRestrictionDescr( operator,\n                                                                                                relDescr.isNegated(),\n                                                                                                relDescr.getParameters(),\n                                                                                                value,\n                                                                                                LiteralRestrictionDescr.TYPE_STRING ) ); // default type\n                        }\n                    } catch ( ClassNotFoundException e ) {\n                        // do nothing as this is just probing to see if it was a class, which we now know it isn't :)\n                    }\n                }\n            }\n\n            if ( restriction != null ) {\n                pattern.addConstraint( new LiteralConstraint( extractor,\n                                                              (LiteralRestriction) restriction ) );\n                continue;\n            }\n\n            Declaration declr = null;\n            if ( value.indexOf( '(' ) < 0 && value.indexOf( '.' ) < 0 && value.indexOf( '[' ) < 0 ) {\n                declr = context.getDeclarationResolver().getDeclaration( context.getRule(),\n                                                                               value );\n\n                if ( declr == null ) {\n                    // trying to create implicit declaration\n                    final Pattern thisPattern = (Pattern) context.getBuildStack().peek();\n                    declr = this.createDeclarationObject( context,\n                                                          value,\n                                                          thisPattern );\n                    if ( declr == null ) {\n                        context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                      d,\n                                                                      null,\n                                                                      \"Unable to return Declaration for identifier '\" + value + \"'\" ) );\n                        continue;\n                    }\n                }\n            }\n\n            if ( declr == null ) {\n                parts = value.split( \"\\\\.\" );\n                if ( parts.length == 2 ) {\n                    if ( \"this\".equals( parts[0].trim() ) ) {\n                        declr = this.createDeclarationObject( context,\n                                                              parts[1].trim(),\n                                                              (Pattern) context.getBuildStack().peek() );\n                        value = parts[1].trim();\n                    } else {\n                        declr = context.getDeclarationResolver().getDeclaration( context.getRule(),\n                                                                                 parts[0].trim() );\n                        // if a declaration exists, then it may be a variable direct property access\n                        if ( declr != null ) {\n                            if ( declr.isPatternDeclaration() ) {\n                                declr = this.createDeclarationObject( context,\n                                                                      parts[1].trim(),\n                                                                      declr.getPattern() );\n                                value = parts[1].trim();\n\n                            } else {\n                                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                              d,\n                                                                              \"\",\n                                                                              \"Not possible to directly access the property '\" + parts[1] + \"' of declaration '\" + parts[0] + \"' since it is not a pattern\" ) );\n                                continue;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if ( declr != null ) {\n                Target right = getRightTarget( extractor );\n                Target left = (declr.isPatternDeclaration() && !(Date.class.isAssignableFrom( declr.getExtractor().getExtractToClass() ) || Number.class.isAssignableFrom( declr.getExtractor().getExtractToClass() ))) ? Target.HANDLE : Target.FACT;\n                final Evaluator evaluator = getEvaluator( context,\n                                                          d,\n                                                          extractor.getValueType(),\n                                                          operator,\n                                                          relDescr.isNegated(),\n                                                          relDescr.getParametersText(),\n                                                          left,\n                                                          right );\n                if ( evaluator == null ) {\n                    continue;\n                }\n\n                restriction = new VariableRestriction( extractor,\n                                                       declr,\n                                                       evaluator );\n\n                if ( declr.getPattern().getObjectType().equals( new ClassObjectType( DroolsQuery.class ) ) ) {\n                    // declaration is query argument, so allow for unification.\n                    restriction = new UnificationRestriction( (VariableRestriction) restriction );\n                }\n            }\n\n            if ( restriction == null ) {\n                Dialect dialect = context.getDialect();\n                if ( !value.startsWith( \"(\" ) ) {\n                    // it's not a traditional return value, so override the dialect\n                    MVELDialect mvelDialect = (MVELDialect) context.getDialect( \"mvel\" );\n                    context.setDialect( mvelDialect );\n                }\n\n                // execute it as a return value\n                restriction = buildRestriction( context,\n                                                (Pattern) context.getBuildStack().peek(),\n                                                extractor,\n                                                new ReturnValueRestrictionDescr( operator,\n                                                                                 relDescr.isNegated(),\n                                                                                 relDescr.getParametersText(),\n                                                                                 value ),\n                                                aliases );\n                // fall back to original dialect\n                context.setDialect( dialect );\n\n            }\n\n            if ( restriction == null || extractor == null ) {\n                // something failed and an error should already have been reported\n                return;\n            }\n            if( restriction instanceof ReturnValueRestriction ) {\n                pattern.addConstraint( new ReturnValueConstraint( extractor,\n                                                                  (ReturnValueRestriction) restriction ) );\n            } else {\n                pattern.addConstraint( new VariableConstraint( extractor,\n                                                               restriction ) );\n            }\n        }\n    }","id":30489,"modified_method":"public void build( RuleBuildContext context,\n                       Pattern pattern,\n                       ExprConstraintDescr descr ) {\n        DrlExprParser parser = new DrlExprParser();\n        ConstraintConnectiveDescr result = parser.parse( descr.getText() );\n        if ( result == null || parser.hasErrors() ) {\n            for ( DroolsParserException error : parser.getErrors() ) {\n                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                              descr,\n                                                              null,\n                                                              \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n            }\n            return;\n        }\n\n        for ( Iterator<BaseDescr> it = result.getDescrs().iterator(); it.hasNext(); ) {\n            BaseDescr d = it.next();\n\n\n            boolean simple = false;\n            MVELDumper.MVELDumperContext mvelCtx = new MVELDumper.MVELDumperContext();\n            String expr = new MVELDumper().dump( d,\n                                                 mvelCtx );\n            Map<String, OperatorDescr> aliases = mvelCtx.getAliases();\n            RelationalExprDescr relDescr = null;\n            if ( d instanceof RelationalExprDescr ) {\n                relDescr = (RelationalExprDescr) d;\n                if ( relDescr.getLeft() instanceof AtomicExprDescr &&\n                      relDescr.getRight() instanceof AtomicExprDescr ) {\n                    simple = true;\n                }\n            }\n\n            if ( d instanceof AtomicExprDescr ) {\n                Matcher m = evalRegexp.matcher( ((AtomicExprDescr)d).getExpression() );                \n                if (m.find()) {  \n                    // MVELDumper already stripped the eval\n                    // this will build the eval using the specified dialect\n                    PredicateDescr pdescr = new PredicateDescr( expr );\n                    buildEval( context,\n                               pattern,\n                               pdescr,\n                               null,\n                               aliases );\n                    continue;\n                }\n            }\n\n            // Either it's a complex expression, so do as predicate\n            // Or it's a Map and we have to treat it as a special case\n            if ( !simple  ||  new ClassObjectType(Map.class).isAssignableFrom( pattern.getObjectType() ) ) {\n                Dialect dialect = context.getDialect();\n                MVELDialect mvelDialect = (MVELDialect) context.getDialect( \"mvel\" );\n                context.setDialect( mvelDialect );\n\n                PredicateDescr pdescr = new PredicateDescr( expr );\n                buildEval( context,\n                           pattern,\n                           pdescr,\n                           null,\n                           aliases );\n\n                // fall back to original dialect\n                context.setDialect( dialect );\n                continue;\n            }\n\n            if ( !(d instanceof RelationalExprDescr) ) {\n                throw new RuntimeException( \"What caused this?: \" + d );\n            }\n\n            RelationalExprDescr exprDescr = (RelationalExprDescr) d;\n\n            AtomicExprDescr rdescr = ((AtomicExprDescr) exprDescr.getRight());\n            String fieldName = ((AtomicExprDescr) exprDescr.getLeft()).getExpression();\n            String value = rdescr.getExpression().trim();\n\n            ExprBindings rightExpr = new ExprBindings();\n            setInputs( context,\n                       rightExpr,\n                       (pattern.getObjectType() instanceof ClassObjectType) ? ((ClassObjectType) pattern.getObjectType()).getClassType() : FactTemplate.class,\n                       value );\n\n            String[] parts = fieldName.split( \"\\\\.\" );\n            if ( parts.length == 2 ) {\n                if ( \"this\".equals( parts[0].trim() ) ) {\n                    // it's a redundant this so trim\n                    fieldName = parts[1];                    \n                } else if ( pattern.getDeclaration() != null && parts[0].trim().equals( pattern.getDeclaration().getIdentifier() ) ) {\n                    // it's a redundant declaration so trim\n                    fieldName = parts[1];\n                }\n            }\n\n            if ( fieldName.indexOf( '.' ) >= 0 || fieldName.indexOf( '[' ) >= 0 || fieldName.indexOf( '(' ) >= 0 ) {\n                // if left has any inputs then we need to rewrite to eval\n                ExprBindings leftExpr = new ExprBindings();\n                setInputs( context,\n                           leftExpr,\n                           ((ClassObjectType) ((Pattern) context.getBuildStack().peek()).getObjectType()).getClassType(),\n                           fieldName );\n                if ( !leftExpr.getRuleBindings().isEmpty() ) {\n                    Dialect dialect = context.getDialect();\n                    MVELDialect mvelDialect = (MVELDialect) context.getDialect( \"mvel\" );\n                    context.setDialect( mvelDialect );\n\n                    PredicateDescr pdescr = new PredicateDescr( expr );\n                    buildEval( context,\n                               pattern,\n                               pdescr,\n                               null,\n                               aliases );\n\n                    // fall back to original dialect\n                    context.setDialect( dialect );\n                    continue;\n                }\n            }\n\n            final InternalReadAccessor extractor = getFieldReadAccessor( context,\n                                                                         d,\n                                                                         pattern.getObjectType(),\n                                                                         fieldName,\n                                                                         null );\n\n            if ( extractor == null ) {\n                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                              d,\n                                                              null,\n                                                              \"Unable to build constraint as  '\" + fieldName + \"' is invalid\" ) );\n                continue;\n            }\n\n            String operator = relDescr.getOperator().trim();\n\n            Restriction restriction = null;\n            // is it a literal? Does not include enums\n            if ( rdescr.isLiteral() ) {\n                restriction = buildLiteralRestriction( context,\n                                                       extractor,\n                                                       new LiteralRestrictionDescr( operator,\n                                                                                    relDescr.isNegated(),\n                                                                                    relDescr.getParameters(),\n                                                                                    value,\n                                                                                    LiteralRestrictionDescr.TYPE_STRING ) ); // default type\n                if ( restriction == null ) {\n                    // otherwise we just get wierd errors after this point on literals\n                    continue;\n                }\n            } else {\n                // is it an enum?\n                int dotPos = value.lastIndexOf( '.' );\n                if ( dotPos >= 0 ) {\n                    final String mainPart = value.substring( 0,\n                                                             dotPos );\n                    String lastPart = value.substring( dotPos + 1 );\n                    try {\n                        final Class< ? > cls = context.getDialect().getTypeResolver().resolveType( mainPart );\n                        if ( lastPart.indexOf( '(' ) < 0 && lastPart.indexOf( '.' ) < 0 && lastPart.indexOf( '[' ) < 0 ) {\n                            restriction = buildLiteralRestriction( context,\n                                                                   extractor,\n                                                                   new LiteralRestrictionDescr( operator,\n                                                                                                relDescr.isNegated(),\n                                                                                                relDescr.getParameters(),\n                                                                                                value,\n                                                                                                LiteralRestrictionDescr.TYPE_STRING ) ); // default type\n                        }\n                    } catch ( ClassNotFoundException e ) {\n                        // do nothing as this is just probing to see if it was a class, which we now know it isn't :)\n                    }\n                }\n            }\n\n            if ( restriction != null ) {\n                pattern.addConstraint( new LiteralConstraint( extractor,\n                                                              (LiteralRestriction) restriction ) );\n                continue;\n            }\n\n            Declaration declr = null;\n            if ( value.indexOf( '(' ) < 0 && value.indexOf( '.' ) < 0 && value.indexOf( '[' ) < 0 ) {\n                declr = context.getDeclarationResolver().getDeclaration( context.getRule(),\n                                                                               value );\n\n                if ( declr == null ) {\n                    // trying to create implicit declaration\n                    final Pattern thisPattern = (Pattern) context.getBuildStack().peek();\n                    declr = this.createDeclarationObject( context,\n                                                          value,\n                                                          thisPattern );\n                    if ( declr == null ) {\n                        context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                      d,\n                                                                      null,\n                                                                      \"Unable to return Declaration for identifier '\" + value + \"'\" ) );\n                        continue;\n                    }\n                }\n            }\n\n            if ( declr == null ) {\n                parts = value.split( \"\\\\.\" );\n                if ( parts.length == 2 ) {\n                    if ( \"this\".equals( parts[0].trim() ) ) {\n                        declr = this.createDeclarationObject( context,\n                                                              parts[1].trim(),\n                                                              (Pattern) context.getBuildStack().peek() );\n                        value = parts[1].trim();\n                    } else {\n                        declr = context.getDeclarationResolver().getDeclaration( context.getRule(),\n                                                                                 parts[0].trim() );\n                        // if a declaration exists, then it may be a variable direct property access\n                        if ( declr != null ) {\n                            if ( declr.isPatternDeclaration() ) {\n                                declr = this.createDeclarationObject( context,\n                                                                      parts[1].trim(),\n                                                                      declr.getPattern() );\n                                value = parts[1].trim();\n\n                            } else {\n                                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                              d,\n                                                                              \"\",\n                                                                              \"Not possible to directly access the property '\" + parts[1] + \"' of declaration '\" + parts[0] + \"' since it is not a pattern\" ) );\n                                continue;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if ( declr != null ) {\n                Target right = getRightTarget( extractor );\n                Target left = (declr.isPatternDeclaration() && !(Date.class.isAssignableFrom( declr.getExtractor().getExtractToClass() ) || Number.class.isAssignableFrom( declr.getExtractor().getExtractToClass() ))) ? Target.HANDLE : Target.FACT;\n                final Evaluator evaluator = getEvaluator( context,\n                                                          d,\n                                                          extractor.getValueType(),\n                                                          operator,\n                                                          relDescr.isNegated(),\n                                                          relDescr.getParametersText(),\n                                                          left,\n                                                          right );\n                if ( evaluator == null ) {\n                    continue;\n                }\n\n                restriction = new VariableRestriction( extractor,\n                                                       declr,\n                                                       evaluator );\n\n                if ( declr.getPattern().getObjectType().equals( new ClassObjectType( DroolsQuery.class ) ) ) {\n                    // declaration is query argument, so allow for unification.\n                    restriction = new UnificationRestriction( (VariableRestriction) restriction );\n                }\n            }\n\n            if ( restriction == null ) {\n                Dialect dialect = context.getDialect();\n                if ( !value.startsWith( \"(\" ) ) {\n                    // it's not a traditional return value, so override the dialect\n                    MVELDialect mvelDialect = (MVELDialect) context.getDialect( \"mvel\" );\n                    context.setDialect( mvelDialect );\n                }\n\n                // execute it as a return value\n                restriction = buildRestriction( context,\n                                                (Pattern) context.getBuildStack().peek(),\n                                                extractor,\n                                                new ReturnValueRestrictionDescr( operator,\n                                                                                 relDescr.isNegated(),\n                                                                                 relDescr.getParametersText(),\n                                                                                 value ),\n                                                aliases );\n                // fall back to original dialect\n                context.setDialect( dialect );\n\n            }\n\n            if ( restriction == null || extractor == null ) {\n                // something failed and an error should already have been reported\n                return;\n            }\n            pattern.addConstraint( new VariableConstraint( extractor,\n                                                           restriction ) );\n        }\n    }","commit_id":"d413b46ee1587e68e4c41c62a5ebd745fe884be0","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void shoot(final String what, final float x, final float y, final float impulse) {\n\t\t// Shoot a box\n\t\tRay ray = camera.getPickRay(x, y);\n\t\tBulletEntity entity = world.add(what, ray.origin.x, ray.origin.y, ray.origin.z);\n\t\tentity.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\tentity.body.applyCentralImpulse(ray.direction.mul(impulse));\n\t}","id":30490,"modified_method":"public void shoot(final String what, final float x, final float y, final float impulse) {\n\t\t// Shoot a box\n\t\tRay ray = camera.getPickRay(x, y);\n\t\tBulletEntity entity = world.add(what, ray.origin.x, ray.origin.y, ray.origin.z);\n\t\tentity.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\t((btRigidBody)entity.body).applyCentralImpulse(ray.direction.mul(impulse));\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic BulletEntity construct (final Matrix4 transform) {\n\t\treturn new BulletEntity(this, transform);\n\t}","id":30491,"modified_method":"@Override\n\tpublic BulletEntity construct (final Matrix4 transform) {\n\t\tif (bodyInfo == null && shape != null) {\n\t\t\tbtCollisionObject obj = new btCollisionObject();\n\t\t\tobj.setCollisionShape(shape);\n\t\t\treturn new BulletEntity(model, obj, transform);\n\t\t} else\n\t\treturn new BulletEntity(model, bodyInfo, transform);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void create(final Model model, final float mass, final btCollisionShape shape) {\n\t\tthis.model = model;\n\t\tthis.shape = shape;\n\t\t\n\t\tif (shape != null) {\n\t\t\t// Calculate the local inertia, bodies with no mass are static\n\t\t\tVector3 localInertia;\n\t\t\tif (mass == 0)\n\t\t\t\tlocalInertia = Vector3.Zero;\n\t\t\telse {\n\t\t\t\tshape.calculateLocalInertia(mass, Vector3.tmp);\n\t\t\t\tlocalInertia = Vector3.tmp;\n\t\t\t}\n\t\t\t\n\t\t\t// For now just pass null as the motionstate, we'll add that to the body in the entity itself\n\t\t\tbodyInfo = new btRigidBodyConstructionInfo(mass, null, shape, localInertia);\n\t\t}\n\t}","id":30492,"modified_method":"private void create(final Model model, final float mass, final btCollisionShape shape) {\n\t\tthis.model = model;\n\t\tthis.shape = shape;\n\t\t\n\t\tif (shape != null && mass >= 0) {\n\t\t\t// Calculate the local inertia, bodies with no mass are static\n\t\t\tVector3 localInertia;\n\t\t\tif (mass == 0)\n\t\t\t\tlocalInertia = Vector3.Zero;\n\t\t\telse {\n\t\t\t\tshape.calculateLocalInertia(mass, Vector3.tmp);\n\t\t\t\tlocalInertia = Vector3.tmp;\n\t\t\t}\n\t\t\t\n\t\t\t// For now just pass null as the motionstate, we'll add that to the body in the entity itself\n\t\t\tbodyInfo = new btRigidBodyConstructionInfo(mass, null, shape, localInertia);\n\t\t}\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic BulletEntity construct (float x, float y, float z) {\n\t\treturn new BulletEntity(this, x, y, z);\n\t}","id":30493,"modified_method":"@Override\n\tpublic BulletEntity construct (float x, float y, float z) {\n\t\tif (bodyInfo == null && shape != null) {\n\t\t\tbtCollisionObject obj = new btCollisionObject();\n\t\t\tobj.setCollisionShape(shape);\n\t\t\treturn new BulletEntity(model, obj, x, y, z);\n\t\t} else\n\t\t\treturn new BulletEntity(model, bodyInfo, x, y, z);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public BulletEntity (final Model model, final btRigidBodyConstructionInfo bodyInfo, final float x, final float y, final float z) {\n\t\tthis(model, bodyInfo, tmpM.setToTranslation(x, y, z));\n\t}","id":30494,"modified_method":"public BulletEntity (final Model model, final btRigidBodyConstructionInfo bodyInfo, final float x, final float y, final float z) {\n\t\tthis(model, bodyInfo == null ? null : new btRigidBody(bodyInfo), x, y, z);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public BulletEntity (final BulletConstructor constructInfo, final Matrix4 transform) {\n\t\tthis(constructInfo.model, constructInfo.bodyInfo, transform);\n\t}","id":30495,"modified_method":"public BulletEntity (final Model model, final btCollisionObject body, final Matrix4 transform) {\n\t\tthis.model = model;\n\t\tthis.transform.set(transform);\n\t\tthis.body = body;\n\t\t\n\t\tif (body != null) {\n\t\t\tbody.userData = this;\n\t\t\tif (body instanceof btRigidBody) {\n\t\t\t\tthis.motionState = new MotionState(this.transform);\n\t\t\t\t((btRigidBody)this.body).setMotionState(motionState);\n\t\t\t} else\n\t\t\t\tbody.setWorldTransform(transform);\n\t\t}\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public BulletEntity (final Model model, final btRigidBodyConstructionInfo bodyInfo, final Matrix4 transform) {\n\t\tthis.model = model;\n\t\tthis.transform.set(transform);\n\t\t\n\t\tif (bodyInfo != null) {\n\t\t\tthis.motionState = new MotionState(this.transform);\n\t\t\tthis.body = new btRigidBody(bodyInfo);\n\t\t\tthis.body.setMotionState(motionState);\n\t\t}\n\t}","id":30496,"modified_method":"public BulletEntity (final Model model, final btRigidBodyConstructionInfo bodyInfo, final Matrix4 transform) {\n\t\tthis(model, bodyInfo == null ? null : new btRigidBody(bodyInfo), transform);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public BulletEntity (final BulletConstructor constructInfo, final float x, final float y, final float z) {\n\t\tthis(constructInfo.model, constructInfo.bodyInfo, x, y, z);\n\t}","id":30497,"modified_method":"public BulletEntity (final Model model, final btCollisionObject body, final float x, final float y, final float z) {\n\t\tthis(model, body, tmpM.setToTranslation(x, y, z));\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void setDebugMode(final int mode, final Matrix4 projMatrix) {\n\t\tif (mode == btIDebugDraw.DebugDrawModes.DBG_NoDebug && debugDrawer == null)\n\t\t\treturn;\n\t\tif (debugDrawer == null)\n\t\t\tdynamicsWorld.setDebugDrawer(debugDrawer = new DebugDrawer());\n\t\tdebugDrawer.lineRenderer.setProjectionMatrix(projMatrix);\n\t\tdebugDrawer.setDebugMode(mode);\n\t}","id":30498,"modified_method":"public void setDebugMode(final int mode, final Matrix4 projMatrix) {\n\t\tif (mode == btIDebugDraw.DebugDrawModes.DBG_NoDebug && debugDrawer == null)\n\t\t\treturn;\n\t\tif (debugDrawer == null)\n\t\t\tcollisionWorld.setDebugDrawer(debugDrawer = new DebugDrawer());\n\t\tdebugDrawer.lineRenderer.setProjectionMatrix(projMatrix);\n\t\tdebugDrawer.setDebugMode(mode);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public BulletWorld(final btCollisionConfiguration collisionConfiguration, final btCollisionDispatcher dispatcher,\n\t\tfinal btBroadphaseInterface broadphase, final btConstraintSolver solver, final btDynamicsWorld dynamicsWorld) {\n\t\tthis(collisionConfiguration, dispatcher, broadphase, solver, dynamicsWorld, new Vector3(0, -10, 0));\n\t}","id":30499,"modified_method":"public BulletWorld(final btCollisionConfiguration collisionConfiguration, final btCollisionDispatcher dispatcher,\n\t\tfinal btBroadphaseInterface broadphase, final btConstraintSolver solver, final btCollisionWorld world) {\n\t\tthis(collisionConfiguration, dispatcher, broadphase, solver, world, new Vector3(0, -10, 0));\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public BulletWorld(final Vector3 gravity) {\n\t\tcollisionConfiguration = new btDefaultCollisionConfiguration();\n\t\tdispatcher = new btCollisionDispatcher(collisionConfiguration);\n\t\tbroadphase = new btDbvtBroadphase();\n\t\tsolver = new btSequentialImpulseConstraintSolver();\n\t\tdynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);\n\t\tdynamicsWorld.setGravity(gravity);\n\t\tthis.gravity = gravity;\n\t}","id":30500,"modified_method":"public BulletWorld(final Vector3 gravity) {\n\t\tcollisionConfiguration = new btDefaultCollisionConfiguration();\n\t\tdispatcher = new btCollisionDispatcher(collisionConfiguration);\n\t\tbroadphase = new btDbvtBroadphase();\n\t\tsolver = new btSequentialImpulseConstraintSolver();\n\t\tcollisionWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);\n\t\t((btDynamicsWorld)collisionWorld).setGravity(gravity);\n\t\tthis.gravity = gravity;\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public BulletWorld(final btCollisionConfiguration collisionConfiguration, final btCollisionDispatcher dispatcher,\n\t\tfinal btBroadphaseInterface broadphase, final btConstraintSolver solver, final btDynamicsWorld dynamicsWorld,  \n\t\tfinal Vector3 gravity) {\n\t\tthis.collisionConfiguration = collisionConfiguration;\n\t\tthis.dispatcher = dispatcher;\n\t\tthis.broadphase = broadphase;\n\t\tthis.solver = solver;\n\t\tthis.dynamicsWorld = dynamicsWorld;\n\t\tthis.dynamicsWorld.setGravity(gravity);\n\t\tthis.gravity = gravity;\n\t}","id":30501,"modified_method":"public BulletWorld(final btCollisionConfiguration collisionConfiguration, final btCollisionDispatcher dispatcher,\n\t\tfinal btBroadphaseInterface broadphase, final btConstraintSolver solver, final btCollisionWorld world,  \n\t\tfinal Vector3 gravity) {\n\t\tthis.collisionConfiguration = collisionConfiguration;\n\t\tthis.dispatcher = dispatcher;\n\t\tthis.broadphase = broadphase;\n\t\tthis.solver = solver;\n\t\tthis.collisionWorld = world;\n\t\tif (world instanceof btDynamicsWorld)\n\t\t\t((btDynamicsWorld)this.collisionWorld).setGravity(gravity);\n\t\tthis.gravity = gravity;\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void update () {\n\t\tif (performanceCounter != null) {\n\t\tperformanceCounter.tick();\n\t\tperformanceCounter.start();\n\t\t}\n\t\tdynamicsWorld.stepSimulation(Gdx.graphics.getDeltaTime(), maxSubSteps);\n\t\tif (performanceCounter != null)\n\t\t\tperformanceCounter.stop();\n\n\t\tif (debugDrawer != null && debugDrawer.getDebugMode() > 0) {\n\t\t\tdebugDrawer.begin();\n\t\t\tdynamicsWorld.debugDrawWorld();\n\t\t\tdebugDrawer.end();\n\t\t}\n\t\tif (renderMeshes)\n\t\t\tsuper.update();\n\t}","id":30502,"modified_method":"@Override\n\tpublic void update () {\n\t\tif (performanceCounter != null) {\n\t\tperformanceCounter.tick();\n\t\tperformanceCounter.start();\n\t\t}\n\t\tif (collisionWorld instanceof btDynamicsWorld)\n\t\t\t((btDynamicsWorld)collisionWorld).stepSimulation(Gdx.graphics.getDeltaTime(), maxSubSteps);\n\t\tif (performanceCounter != null)\n\t\t\tperformanceCounter.stop();\n\n\t\tif (debugDrawer != null && debugDrawer.getDebugMode() > 0) {\n\t\t\tdebugDrawer.begin();\n\t\t\tcollisionWorld.debugDrawWorld();\n\t\t\tdebugDrawer.end();\n\t\t}\n\t\tif (renderMeshes)\n\t\t\tsuper.update();\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void add(final BulletEntity entity) {\n\t\tsuper.add(entity);\n\t\tif (entity.body != null)\n\t\t\tdynamicsWorld.addRigidBody(entity.body);\n\t}","id":30503,"modified_method":"@Override\n\tpublic void add(final BulletEntity entity) {\n\t\tsuper.add(entity);\n\t\tif (entity.body != null) {\n\t\t\tif (entity.body instanceof btRigidBody)\n\t\t\t\t((btDiscreteDynamicsWorld)collisionWorld).addRigidBody((btRigidBody)entity.body);\n\t\t\telse\n\t\t\t\tcollisionWorld.addCollisionObject(entity.body);\n\t\t}\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void dispose () {\n\t\tfor (int i = 0; i < entities.size; i++) {\n\t\t\tbtRigidBody body = entities.get(i).body;\n\t\t\tif (body != null)\n\t\t\t\tdynamicsWorld.removeRigidBody(body);\n\t\t}\n\t\t\n\t\tsuper.dispose();\n\t\t\n\t\tdynamicsWorld.delete();\n\t\tsolver.delete();\n\t\tbroadphase.delete();\n\t\tdispatcher.delete();\n\t\tcollisionConfiguration.delete();\n\t}","id":30504,"modified_method":"@Override\n\tpublic void dispose () {\n\t\tfor (int i = 0; i < entities.size; i++) {\n\t\t\tbtCollisionObject body = entities.get(i).body;\n\t\t\tif (body != null) {\n\t\t\t\tif (body instanceof btRigidBody)\n\t\t\t\t\t((btDynamicsWorld)collisionWorld).removeRigidBody((btRigidBody)body);\n\t\t\t\telse\n\t\t\t\t\tcollisionWorld.removeCollisionObject(body);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsuper.dispose();\n\t\t\n\t\tcollisionWorld.delete();\n\t\tif (solver != null)\n\t\t\tsolver.delete();\n\t\tif (broadphase != null)\n\t\t\tbroadphase.delete();\n\t\tif (dispatcher != null)\n\t\t\tdispatcher.delete();\n\t\tif (collisionConfiguration != null)\n\t\t\tcollisionConfiguration.delete();\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\n\t\tfinal Mesh barMesh = new Mesh(true, 8, 36, new VertexAttribute(Usage.Position, 3, \"a_position\"));\n\t\tbarMesh.setVertices(new float[] {5f, 0.5f, 0.5f, 5f, 0.5f, -0.5f, -5f, 0.5f, 0.5f, -5f, 0.5f, -0.5f,\n\t\t\t5f, -0.5f, 0.5f, 5f, -0.5f, -0.5f, -5f, -0.5f, 0.5f, -5f, -0.5f, -0.5f});\n\t\tbarMesh.setIndices(new short[] {0, 1, 2, 1, 2, 3, // top\n\t\t\t4, 5, 6, 5, 6, 7, // bottom\n\t\t\t0, 2, 4, 4, 6, 2, // front\n\t\t\t1, 3, 5, 5, 7, 3, // back\n\t\t\t2, 3, 6, 6, 7, 3, // left\n\t\t\t0, 1, 4, 4, 5, 1 // right\n\t\t\t});\n\t\tfinal StillModel barModel = new StillModel(new StillSubMesh(\"bar\", barMesh, GL10.GL_TRIANGLES, new Material()));\n\t\tworld.addConstructor(\"bar\", new BulletConstructor(barModel, 0f)); // mass = 0: static body\n\t\t\n\t\t// Create the entities\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\t\t\n\t\tBulletEntity bar = world.add(\"bar\", 0f, 7f, 0f);\n\t\tbar.color.set(0.75f + 0.25f * (float)Math.random(), 0.75f + 0.25f * (float)Math.random(), 0.75f + 0.25f * (float)Math.random(), 1f);\n\t\t\n\t\tBulletEntity box1 = world.add(\"box\", -4.5f, 6f, 0f);\n\t\tbox1.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\tbtPoint2PointConstraint constraint = new btPoint2PointConstraint(bar.body, box1.body, Vector3.tmp.set(-5, -0.5f, -0.5f), Vector3.tmp2.set(-0.5f, 0.5f, -0.5f));\n\t\tworld.dynamicsWorld.addConstraint(constraint, false);\n\t\tconstraints.add(constraint);\n\t\tBulletEntity box2 = null;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tbox2 = world.add(\"box\", -3.5f + (float)i, 6f, 0f);\n\t\t\t\tbox2.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\t\t\tconstraint = new btPoint2PointConstraint(box1.body, box2.body, Vector3.tmp.set(0.5f, -0.5f, 0.5f), Vector3.tmp2.set(-0.5f, -0.5f, 0.5f));\n\t\t\t} else {\n\t\t\t\tbox1 = world.add(\"box\", -3.5f + (float)i, 6f, 0f);\n\t\t\t\tbox1.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\t\t\tconstraint = new btPoint2PointConstraint(box2.body, box1.body, Vector3.tmp.set(0.5f, 0.5f, -0.5f), Vector3.tmp2.set(-0.5f, 0.5f, -0.5f));\n\t\t\t}\n\t\t\tworld.dynamicsWorld.addConstraint(constraint, false);\n\t\t\tconstraints.add(constraint);\n\t\t}\n\t\tconstraint = new btPoint2PointConstraint(bar.body, box1.body, Vector3.tmp.set(5f, -0.5f, -0.5f), Vector3.tmp2.set(0.5f, 0.5f, -0.5f));\n\t\tworld.dynamicsWorld.addConstraint(constraint, false);\n\t\tconstraints.add(constraint);\n\t}","id":30505,"modified_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\n\t\tfinal Mesh barMesh = new Mesh(true, 8, 36, new VertexAttribute(Usage.Position, 3, \"a_position\"));\n\t\tbarMesh.setVertices(new float[] {5f, 0.5f, 0.5f, 5f, 0.5f, -0.5f, -5f, 0.5f, 0.5f, -5f, 0.5f, -0.5f,\n\t\t\t5f, -0.5f, 0.5f, 5f, -0.5f, -0.5f, -5f, -0.5f, 0.5f, -5f, -0.5f, -0.5f});\n\t\tbarMesh.setIndices(new short[] {0, 1, 2, 1, 2, 3, // top\n\t\t\t4, 5, 6, 5, 6, 7, // bottom\n\t\t\t0, 2, 4, 4, 6, 2, // front\n\t\t\t1, 3, 5, 5, 7, 3, // back\n\t\t\t2, 3, 6, 6, 7, 3, // left\n\t\t\t0, 1, 4, 4, 5, 1 // right\n\t\t\t});\n\t\tfinal StillModel barModel = new StillModel(new StillSubMesh(\"bar\", barMesh, GL10.GL_TRIANGLES, new Material()));\n\t\tworld.addConstructor(\"bar\", new BulletConstructor(barModel, 0f)); // mass = 0: static body\n\t\t\n\t\t// Create the entities\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\t\t\n\t\tBulletEntity bar = world.add(\"bar\", 0f, 7f, 0f);\n\t\tbar.color.set(0.75f + 0.25f * (float)Math.random(), 0.75f + 0.25f * (float)Math.random(), 0.75f + 0.25f * (float)Math.random(), 1f);\n\t\t\n\t\tBulletEntity box1 = world.add(\"box\", -4.5f, 6f, 0f);\n\t\tbox1.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\tbtPoint2PointConstraint constraint = new btPoint2PointConstraint((btRigidBody)bar.body, (btRigidBody)box1.body, Vector3.tmp.set(-5, -0.5f, -0.5f), Vector3.tmp2.set(-0.5f, 0.5f, -0.5f));\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(constraint, false);\n\t\tconstraints.add(constraint);\n\t\tBulletEntity box2 = null;\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tbox2 = world.add(\"box\", -3.5f + (float)i, 6f, 0f);\n\t\t\t\tbox2.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\t\t\tconstraint = new btPoint2PointConstraint((btRigidBody)box1.body, (btRigidBody)box2.body, Vector3.tmp.set(0.5f, -0.5f, 0.5f), Vector3.tmp2.set(-0.5f, -0.5f, 0.5f));\n\t\t\t} else {\n\t\t\t\tbox1 = world.add(\"box\", -3.5f + (float)i, 6f, 0f);\n\t\t\t\tbox1.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\t\t\tconstraint = new btPoint2PointConstraint((btRigidBody)box2.body, (btRigidBody)box1.body, Vector3.tmp.set(0.5f, 0.5f, -0.5f), Vector3.tmp2.set(-0.5f, 0.5f, -0.5f));\n\t\t\t}\n\t\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(constraint, false);\n\t\t\tconstraints.add(constraint);\n\t\t}\n\t\tconstraint = new btPoint2PointConstraint((btRigidBody)bar.body, (btRigidBody)box1.body, Vector3.tmp.set(5f, -0.5f, -0.5f), Vector3.tmp2.set(0.5f, 0.5f, -0.5f));\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(constraint, false);\n\t\tconstraints.add(constraint);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void dispose () {\n\t\tfor (int i = 0; i < constraints.size; i++) {\n\t\t\tworld.dynamicsWorld.removeConstraint(constraints.get(i));\n\t\t\tconstraints.get(i).delete();\n\t\t}\n\t\tconstraints.clear();\n\t\tsuper.dispose();\n\t}","id":30506,"modified_method":"@Override\n\tpublic void dispose () {\n\t\tfor (int i = 0; i < constraints.size; i++) {\n\t\t\t((btDynamicsWorld)world.collisionWorld).removeConstraint(constraints.get(i));\n\t\t\tconstraints.get(i).delete();\n\t\t}\n\t\tconstraints.clear();\n\t\tsuper.dispose();\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\t\t\n\t\tinternalTickCallback = new TestInternalTickCallback(world.dynamicsWorld);\n\n\t\t// Create the entities\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\n\t\tfor (int x = 0; x < BOXCOUNT_X; x++) {\n\t\t\tfor (int y = 0; y < BOXCOUNT_Y; y++) {\n\t\t\t\tfor (int z = 0; z < BOXCOUNT_Z; z++) {\n\t\t\t\t\tworld.add(\"box\", BOXOFFSET_X + x, BOXOFFSET_Y + y, BOXOFFSET_Z + z)\n\t\t\t\t\t\t.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":30507,"modified_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\t\t\n\t\tinternalTickCallback = new TestInternalTickCallback((btDynamicsWorld)world.collisionWorld);\n\n\t\t// Create the entities\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\n\t\tfor (int x = 0; x < BOXCOUNT_X; x++) {\n\t\t\tfor (int y = 0; y < BOXCOUNT_Y; y++) {\n\t\t\t\tfor (int z = 0; z < BOXCOUNT_Z; z++) {\n\t\t\t\t\tworld.add(\"box\", BOXOFFSET_X + x, BOXOFFSET_Y + y, BOXOFFSET_Z + z)\n\t\t\t\t\t\t.color.set(0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 0.5f + 0.5f * (float)Math.random(), 1f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic boolean tap (float x, float y, int count, int button) {\n\t\tRay ray = camera.getPickRay(x, y);\n\t\trayFrom.set(ray.origin);\n\t\trayTo.set(ray.direction).mul(50f).add(rayFrom); // 50 meters max from the origin\n\n\t\t// Because we reuse the ClosestRayResultCallback, we need reset it's values\n\t\trayTestCB.setM_collisionObject(null);\n\t\trayTestCB.setM_closestHitFraction(1f);\n\t\trayTestCB.getM_rayFromWorld().setValue(rayFrom.x, rayFrom.y, rayFrom.z);\n\t\trayTestCB.getM_rayToWorld().setValue(rayTo.x, rayTo.y, rayTo.z);\n\t\t\n\t\tworld.dynamicsWorld.rayTest(rayFrom, rayTo, rayTestCB);\n\t\t\n\t\tif (rayTestCB.hasHit()) {\n\t\t\tfinal btCollisionObject obj = rayTestCB.getM_collisionObject();\n\t\t\tif (!obj.isStaticOrKinematicObject()) {\n\t\t\t\tfinal btRigidBody body = btRigidBody.upcast(obj);\n\t\t\t\tbody.activate();\n\t\t\t\tbody.applyCentralImpulse(Vector3.tmp2.set(ray.direction).mul(20f));\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":30508,"modified_method":"@Override\n\tpublic boolean tap (float x, float y, int count, int button) {\n\t\tRay ray = camera.getPickRay(x, y);\n\t\trayFrom.set(ray.origin);\n\t\trayTo.set(ray.direction).mul(50f).add(rayFrom); // 50 meters max from the origin\n\n\t\t// Because we reuse the ClosestRayResultCallback, we need reset it's values\n\t\trayTestCB.setM_collisionObject(null);\n\t\trayTestCB.setM_closestHitFraction(1f);\n\t\trayTestCB.getM_rayFromWorld().setValue(rayFrom.x, rayFrom.y, rayFrom.z);\n\t\trayTestCB.getM_rayToWorld().setValue(rayTo.x, rayTo.y, rayTo.z);\n\t\t\n\t\tworld.collisionWorld.rayTest(rayFrom, rayTo, rayTestCB);\n\t\t\n\t\tif (rayTestCB.hasHit()) {\n\t\t\tfinal btCollisionObject obj = rayTestCB.getM_collisionObject();\n\t\t\tif (!obj.isStaticOrKinematicObject()) {\n\t\t\t\tfinal btRigidBody body = btRigidBody.upcast(obj);\n\t\t\t\tbody.activate();\n\t\t\t\tbody.applyCentralImpulse(Vector3.tmp2.set(ray.direction).mul(20f));\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void addRagdoll(final float x, final float y, final float z) {\n\t\tfinal Matrix4 tmpM = new Matrix4();\n\t\tbtRigidBody pelvis = world.add(\"pelvis\", x, y+1, z).body;\n\t\tbtRigidBody spine = world.add(\"spine\", x, y+1.2f, z).body;\n\t\tbtRigidBody head = world.add(\"head\", x, y+1.6f, z).body;\n\t\tbtRigidBody leftupperleg = world.add(\"upperleg\", x-0.18f, y+0.65f, z).body;\n\t\tbtRigidBody leftlowerleg = world.add(\"lowerleg\", x-0.18f, y+0.2f, z).body;\n\t\tbtRigidBody rightupperleg = world.add(\"upperleg\", x+0.18f, y+0.65f, z).body;\n\t\tbtRigidBody rightlowerleg = world.add(\"lowerleg\", x+0.18f, y+0.2f, z).body;\t\t\n\t\tbtRigidBody leftupperarm = world.add(\"upperarm\", tmpM.setFromEulerAngles(PI2, 0, 0).trn(x-0.35f, y+1.45f, z)).body;\n\t\tbtRigidBody leftlowerarm = world.add(\"lowerarm\", tmpM.setFromEulerAngles(PI2, 0, 0).trn(x-0.7f, y+1.45f, z)).body;\n\t\tbtRigidBody rightupperarm = world.add(\"upperarm\", tmpM.setFromEulerAngles(-PI2, 0, 0).trn(x+0.35f, y+1.45f, z)).body;\n\t\tbtRigidBody rightlowerarm = world.add(\"lowerarm\", tmpM.setFromEulerAngles(-PI2, 0, 0).trn(x+0.7f, y+1.45f, z)).body;\n\t\t\n\t\tfinal Matrix4 localA = new Matrix4();\n\t\tfinal Matrix4 localB = new Matrix4();\n\t\tbtHingeConstraint hingeC = null;\n\t\tbtConeTwistConstraint coneC = null;\n\t\t\n\t\t// PelvisSpine\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, 0.15f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, -0.15f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(pelvis, spine, localA, localB));\n\t\thingeC.setLimit(-PI4, PI2);\n\t\tworld.dynamicsWorld.addConstraint(hingeC, true);\n\t\t\n\t\t// SpineHead\n\t\tlocalA.setFromEulerAngles(PI2, 0, 0).trn(0, 0.3f, 0);\n\t\tlocalB.setFromEulerAngles(PI2, 0, 0).trn(0, -0.14f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(spine, head, localA, localB));\n\t\tconeC.setLimit(PI4, PI4, PI2);\n\t\tworld.dynamicsWorld.addConstraint(coneC, true);\n\t\t\n\t\t// LeftHip\n\t\tlocalA.setFromEulerAngles(-PI4*5f, 0, 0).trn(-0.18f, -0.1f, 0);\n\t\tlocalB.setFromEulerAngles(-PI4*5f, 0, 0).trn(0, 0.225f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, leftupperleg, localA, localB));\n\t\tconeC.setLimit(PI4, PI4, 0);\n\t\tworld.dynamicsWorld.addConstraint(coneC, true);\n\t\t\n\t\t// LeftKnee\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, -0.225f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, 0.185f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(leftupperleg, leftlowerleg, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\tworld.dynamicsWorld.addConstraint(hingeC, true);\n\t\t\n\t\t// RightHip\n\t\tlocalA.setFromEulerAngles(-PI4*5f, 0, 0).trn(0.18f, -0.1f, 0);\n\t\tlocalB.setFromEulerAngles(-PI4*5f, 0, 0).trn(0, 0.225f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, rightupperleg, localA, localB));\n\t\tconeC.setLimit(PI4, PI4, 0);\n\t\tworld.dynamicsWorld.addConstraint(coneC, true);\n\t\t\n\t\t// RightKnee\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, -0.225f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, 0.185f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(rightupperleg, rightlowerleg, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\tworld.dynamicsWorld.addConstraint(hingeC, true);\n\t\t\n\t\t// LeftShoulder\n\t\tlocalA.setFromEulerAngles(PI, 0, 0).trn(-0.2f, 0.15f, 0);\n\t\tlocalB.setFromEulerAngles(PI2, 0, 0).trn(0, -0.18f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, leftupperarm, localA, localB));\n\t\tconeC.setLimit(PI2, PI2, 0);\n\t\tworld.dynamicsWorld.addConstraint(coneC, true);\n\t\t\n\t\t// LeftElbow\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, 0.18f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, -0.14f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(leftupperarm, leftlowerarm, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\tworld.dynamicsWorld.addConstraint(hingeC, true);\n\t\t\n\t\t// RightShoulder\n\t\tlocalA.setFromEulerAngles(PI, 0, 0).trn(0.2f, 0.15f, 0);\n\t\tlocalB.setFromEulerAngles(PI2, 0, 0).trn(0, -0.18f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, rightupperarm, localA, localB));\n\t\tconeC.setLimit(PI2, PI2, 0);\n\t\tworld.dynamicsWorld.addConstraint(coneC, true);\n\t\t\n\t\t// RightElbow\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, 0.18f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, -0.14f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(rightupperarm, rightlowerarm, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\tworld.dynamicsWorld.addConstraint(hingeC, true);\n\t}","id":30509,"modified_method":"public void addRagdoll(final float x, final float y, final float z) {\n\t\tfinal Matrix4 tmpM = new Matrix4();\n\t\tbtRigidBody pelvis = (btRigidBody)world.add(\"pelvis\", x, y+1, z).body;\n\t\tbtRigidBody spine = (btRigidBody)world.add(\"spine\", x, y+1.2f, z).body;\n\t\tbtRigidBody head = (btRigidBody)world.add(\"head\", x, y+1.6f, z).body;\n\t\tbtRigidBody leftupperleg = (btRigidBody)world.add(\"upperleg\", x-0.18f, y+0.65f, z).body;\n\t\tbtRigidBody leftlowerleg = (btRigidBody)world.add(\"lowerleg\", x-0.18f, y+0.2f, z).body;\n\t\tbtRigidBody rightupperleg = (btRigidBody)world.add(\"upperleg\", x+0.18f, y+0.65f, z).body;\n\t\tbtRigidBody rightlowerleg = (btRigidBody)world.add(\"lowerleg\", x+0.18f, y+0.2f, z).body;\t\t\n\t\tbtRigidBody leftupperarm = (btRigidBody)world.add(\"upperarm\", tmpM.setFromEulerAngles(PI2, 0, 0).trn(x-0.35f, y+1.45f, z)).body;\n\t\tbtRigidBody leftlowerarm = (btRigidBody)world.add(\"lowerarm\", tmpM.setFromEulerAngles(PI2, 0, 0).trn(x-0.7f, y+1.45f, z)).body;\n\t\tbtRigidBody rightupperarm = (btRigidBody)world.add(\"upperarm\", tmpM.setFromEulerAngles(-PI2, 0, 0).trn(x+0.35f, y+1.45f, z)).body;\n\t\tbtRigidBody rightlowerarm = (btRigidBody)world.add(\"lowerarm\", tmpM.setFromEulerAngles(-PI2, 0, 0).trn(x+0.7f, y+1.45f, z)).body;\n\t\t\n\t\tfinal Matrix4 localA = new Matrix4();\n\t\tfinal Matrix4 localB = new Matrix4();\n\t\tbtHingeConstraint hingeC = null;\n\t\tbtConeTwistConstraint coneC = null;\n\t\t\n\t\t// PelvisSpine\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, 0.15f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, -0.15f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(pelvis, spine, localA, localB));\n\t\thingeC.setLimit(-PI4, PI2);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(hingeC, true);\n\t\t\n\t\t// SpineHead\n\t\tlocalA.setFromEulerAngles(PI2, 0, 0).trn(0, 0.3f, 0);\n\t\tlocalB.setFromEulerAngles(PI2, 0, 0).trn(0, -0.14f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(spine, head, localA, localB));\n\t\tconeC.setLimit(PI4, PI4, PI2);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(coneC, true);\n\t\t\n\t\t// LeftHip\n\t\tlocalA.setFromEulerAngles(-PI4*5f, 0, 0).trn(-0.18f, -0.1f, 0);\n\t\tlocalB.setFromEulerAngles(-PI4*5f, 0, 0).trn(0, 0.225f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, leftupperleg, localA, localB));\n\t\tconeC.setLimit(PI4, PI4, 0);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(coneC, true);\n\t\t\n\t\t// LeftKnee\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, -0.225f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, 0.185f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(leftupperleg, leftlowerleg, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(hingeC, true);\n\t\t\n\t\t// RightHip\n\t\tlocalA.setFromEulerAngles(-PI4*5f, 0, 0).trn(0.18f, -0.1f, 0);\n\t\tlocalB.setFromEulerAngles(-PI4*5f, 0, 0).trn(0, 0.225f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, rightupperleg, localA, localB));\n\t\tconeC.setLimit(PI4, PI4, 0);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(coneC, true);\n\t\t\n\t\t// RightKnee\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, -0.225f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, 0.185f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(rightupperleg, rightlowerleg, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(hingeC, true);\n\t\t\n\t\t// LeftShoulder\n\t\tlocalA.setFromEulerAngles(PI, 0, 0).trn(-0.2f, 0.15f, 0);\n\t\tlocalB.setFromEulerAngles(PI2, 0, 0).trn(0, -0.18f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, leftupperarm, localA, localB));\n\t\tconeC.setLimit(PI2, PI2, 0);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(coneC, true);\n\t\t\n\t\t// LeftElbow\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, 0.18f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, -0.14f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(leftupperarm, leftlowerarm, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(hingeC, true);\n\t\t\n\t\t// RightShoulder\n\t\tlocalA.setFromEulerAngles(PI, 0, 0).trn(0.2f, 0.15f, 0);\n\t\tlocalB.setFromEulerAngles(PI2, 0, 0).trn(0, -0.18f, 0);\n\t\tconstraints.add(coneC = new btConeTwistConstraint(pelvis, rightupperarm, localA, localB));\n\t\tconeC.setLimit(PI2, PI2, 0);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(coneC, true);\n\t\t\n\t\t// RightElbow\n\t\tlocalA.setFromEulerAngles(0, PI2, 0).trn(0, 0.18f, 0);\n\t\tlocalB.setFromEulerAngles(0, PI2, 0).trn(0, -0.14f, 0);\n\t\tconstraints.add(hingeC = new btHingeConstraint(rightupperarm, rightlowerarm, localA, localB));\n\t\thingeC.setLimit(0, PI2);\n\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(hingeC, true);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic boolean touchDown (int screenX, int screenY, int pointer, int button) {\n\t\tboolean result = false;\n\t\tif (button == Buttons.LEFT) {\n\t\t\tRay ray = camera.getPickRay(screenX, screenY);\n\t\t\tVector3.tmp.set(ray.direction).mul(10f).add(ray.origin);\n\t\t\tClosestRayResultCallback cb = new ClosestRayResultCallback(ray.origin, Vector3.tmp);\n\t\t\tworld.dynamicsWorld.rayTest(ray.origin, Vector3.tmp, cb);\n\t\t\tif (cb.hasHit()) {\n\t\t\t\tbtRigidBody body = btRigidBody.upcast(cb.getM_collisionObject());\n\t\t\t\tif (body != null && !body.isStaticObject() && !body.isKinematicObject()) {\n\t\t\t\t\tpickedBody = body;\n\t\t\t\t\tbody.setActivationState(gdxBullet.DISABLE_DEACTIVATION);\n\t\t\t\t\t\n\t\t\t\t\tbtVector3 hitpoint = cb.getM_hitPointWorld();\n\t\t\t\t\tVector3.tmp.set(hitpoint.getX(), hitpoint.getY(), hitpoint.getZ());\n\t\t\t\t\tVector3.tmp.mul(body.getCenterOfMassTransform().inv());\n\t\t\t\t\t\n\t\t\t\t\tpickConstraint = new btPoint2PointConstraint(body,Vector3.tmp);\n\t\t\t\t\tbtConstraintSetting setting = pickConstraint.getM_setting();\n\t\t\t\t\tsetting.setM_impulseClamp(30f);\n\t\t\t\t\tsetting.setM_tau(0.001f);\n\t\t\t\t\tpickConstraint.setM_setting(setting);\n\t\t\t\t\t\n\t\t\t\t\tworld.dynamicsWorld.addConstraint(pickConstraint);\n\t\t\n\t\t\t\t\tpickDistance = Vector3.tmp.sub(camera.position).len();\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb.delete();\n\t\t}\n\t\treturn result ? result : super.touchDown(screenX, screenY, pointer, button);\n\t}","id":30510,"modified_method":"@Override\n\tpublic boolean touchDown (int screenX, int screenY, int pointer, int button) {\n\t\tboolean result = false;\n\t\tif (button == Buttons.LEFT) {\n\t\t\tRay ray = camera.getPickRay(screenX, screenY);\n\t\t\tVector3.tmp.set(ray.direction).mul(10f).add(ray.origin);\n\t\t\tClosestRayResultCallback cb = new ClosestRayResultCallback(ray.origin, Vector3.tmp);\n\t\t\tworld.collisionWorld.rayTest(ray.origin, Vector3.tmp, cb);\n\t\t\tif (cb.hasHit()) {\n\t\t\t\tbtRigidBody body = btRigidBody.upcast(cb.getM_collisionObject());\n\t\t\t\tif (body != null && !body.isStaticObject() && !body.isKinematicObject()) {\n\t\t\t\t\tpickedBody = body;\n\t\t\t\t\tbody.setActivationState(gdxBullet.DISABLE_DEACTIVATION);\n\t\t\t\t\t\n\t\t\t\t\tbtVector3 hitpoint = cb.getM_hitPointWorld();\n\t\t\t\t\tVector3.tmp.set(hitpoint.getX(), hitpoint.getY(), hitpoint.getZ());\n\t\t\t\t\tVector3.tmp.mul(body.getCenterOfMassTransform().inv());\n\t\t\t\t\t\n\t\t\t\t\tpickConstraint = new btPoint2PointConstraint(body,Vector3.tmp);\n\t\t\t\t\tbtConstraintSetting setting = pickConstraint.getM_setting();\n\t\t\t\t\tsetting.setM_impulseClamp(30f);\n\t\t\t\t\tsetting.setM_tau(0.001f);\n\t\t\t\t\tpickConstraint.setM_setting(setting);\n\t\t\t\t\t\n\t\t\t\t\t((btDynamicsWorld)world.collisionWorld).addConstraint(pickConstraint);\n\t\t\n\t\t\t\t\tpickDistance = Vector3.tmp.sub(camera.position).len();\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb.delete();\n\t\t}\n\t\treturn result ? result : super.touchDown(screenX, screenY, pointer, button);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void dispose () {\n\t\tfor (int i = 0; i < constraints.size; i++) {\n\t\t\tworld.dynamicsWorld.removeConstraint(constraints.get(i));\n\t\t\tconstraints.get(i).delete();\n\t\t}\n\t\tconstraints.clear();\n\t\tsuper.dispose();\n\t}","id":30511,"modified_method":"@Override\n\tpublic void dispose () {\n\t\tfor (int i = 0; i < constraints.size; i++) {\n\t\t\t((btDynamicsWorld)world.collisionWorld).removeConstraint(constraints.get(i));\n\t\t\tconstraints.get(i).delete();\n\t\t}\n\t\tconstraints.clear();\n\t\tsuper.dispose();\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic boolean touchUp (int screenX, int screenY, int pointer, int button) {\n\t\tboolean result = false;\n\t\tif (button == Buttons.LEFT) {\n\t\t\tif (pickConstraint != null) {\n\t\t\t\tworld.dynamicsWorld.removeConstraint(pickConstraint);\n\t\t\t\tpickConstraint.delete();\n\t\t\t\tpickConstraint = null;\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tif (pickedBody != null) {\n\t\t\t\tpickedBody.forceActivationState(gdxBullet.ACTIVE_TAG);\n\t\t\t\tpickedBody.setDeactivationTime(0f);\n\t\t\t\tpickedBody = null;\n\t\t\t}\n\t\t}\n\t\treturn result ? result : super.touchUp(screenX, screenY, pointer, button);\n\t}","id":30512,"modified_method":"@Override\n\tpublic boolean touchUp (int screenX, int screenY, int pointer, int button) {\n\t\tboolean result = false;\n\t\tif (button == Buttons.LEFT) {\n\t\t\tif (pickConstraint != null) {\n\t\t\t\t((btDynamicsWorld)world.collisionWorld).removeConstraint(pickConstraint);\n\t\t\t\tpickConstraint.delete();\n\t\t\t\tpickConstraint = null;\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tif (pickedBody != null) {\n\t\t\t\tpickedBody.forceActivationState(gdxBullet.ACTIVE_TAG);\n\t\t\t\tpickedBody.setDeactivationTime(0f);\n\t\t\t\tpickedBody = null;\n\t\t\t}\n\t\t}\n\t\treturn result ? result : super.touchUp(screenX, screenY, pointer, button);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\t\t\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\t\t\n\t\tfloat x0 = -2f, y0 = 6f, z0 = -2f;\n\t\tfloat x1 = 8f, y1 = 6f, z1 = 8f;\n\t\tVector3 patch00 = new Vector3(x0, y0, z0);\n\t\tVector3 patch10 = new Vector3(x1, y1, z0);\n\t\tVector3 patch01 = new Vector3(x0, y0, z1);\n\t\tVector3 patch11 = new Vector3(x1, y1, z1);\n\t\tsoftBody = btSoftBodyHelpers.CreatePatch(worldInfo, patch00, patch10, patch01, patch11, 15, 15, 15, false);\n\t\tsoftBody.takeOwnership();\n\t\tsoftBody.setTotalMass(100f);\n\t\t((btSoftRigidDynamicsWorld)(world.dynamicsWorld)).addSoftBody(softBody);\n\t\t\n\t\tfinal int vertCount = softBody.getNodeCount();\n\t\tfinal int faceCount = softBody.getFaceCount(); \n\t\tmesh = new Mesh(false, vertCount, faceCount*3,  new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + \"0\"));\n\t\tfinal int vertSize = mesh.getVertexSize() / 4;\n\t\tmesh.getVerticesBuffer().position(0);\n\t\tmesh.getVerticesBuffer().limit(vertCount * vertSize);\n\t\tmesh.getIndicesBuffer().position(0);\n\t\tmesh.getIndicesBuffer().limit(faceCount * 3);\n\t\tsoftBody.getVertices(mesh.getVerticesBuffer(), vertCount, mesh.getVertexSize(), 0);\n\t\tsoftBody.getIndices(mesh.getIndicesBuffer(), faceCount);\n\t\t\n\t\tfinal float[] verts = new float[vertCount * vertSize];\n\t\tfinal int uvOffset = mesh.getVertexAttribute(Usage.TextureCoordinates).offset / 4;\n\t\tmesh.getVertices(verts);\n\t\tfor (int i = 0; i < vertCount; i++) {\n\t\t\tverts[i*vertSize+uvOffset] = (verts[i*vertSize] - x0) / (x1 - x0);\n\t\t\tverts[i*vertSize+uvOffset+1] = (verts[i*vertSize+2] - z0) / (z1 - z0);\n\t\t}\n\t\tmesh.setVertices(verts);\n\t\ttexture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"));\n\t}","id":30513,"modified_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\t\t\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\t\t\n\t\tfloat x0 = -2f, y0 = 6f, z0 = -2f;\n\t\tfloat x1 = 8f, y1 = 6f, z1 = 8f;\n\t\tVector3 patch00 = new Vector3(x0, y0, z0);\n\t\tVector3 patch10 = new Vector3(x1, y1, z0);\n\t\tVector3 patch01 = new Vector3(x0, y0, z1);\n\t\tVector3 patch11 = new Vector3(x1, y1, z1);\n\t\tsoftBody = btSoftBodyHelpers.CreatePatch(worldInfo, patch00, patch10, patch01, patch11, 15, 15, 15, false);\n\t\tsoftBody.takeOwnership();\n\t\tsoftBody.setTotalMass(100f);\n\t\t((btSoftRigidDynamicsWorld)(world.collisionWorld)).addSoftBody(softBody);\n\t\t\n\t\tfinal int vertCount = softBody.getNodeCount();\n\t\tfinal int faceCount = softBody.getFaceCount(); \n\t\tmesh = new Mesh(false, vertCount, faceCount*3,  new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + \"0\"));\n\t\tfinal int vertSize = mesh.getVertexSize() / 4;\n\t\tmesh.getVerticesBuffer().position(0);\n\t\tmesh.getVerticesBuffer().limit(vertCount * vertSize);\n\t\tmesh.getIndicesBuffer().position(0);\n\t\tmesh.getIndicesBuffer().limit(faceCount * 3);\n\t\tsoftBody.getVertices(mesh.getVerticesBuffer(), vertCount, mesh.getVertexSize(), 0);\n\t\tsoftBody.getIndices(mesh.getIndicesBuffer(), faceCount);\n\t\t\n\t\tfinal float[] verts = new float[vertCount * vertSize];\n\t\tfinal int uvOffset = mesh.getVertexAttribute(Usage.TextureCoordinates).offset / 4;\n\t\tmesh.getVertices(verts);\n\t\tfor (int i = 0; i < vertCount; i++) {\n\t\t\tverts[i*vertSize+uvOffset] = (verts[i*vertSize] - x0) / (x1 - x0);\n\t\t\tverts[i*vertSize+uvOffset+1] = (verts[i*vertSize+2] - z0) / (z1 - z0);\n\t\t}\n\t\tmesh.setVertices(verts);\n\t\ttexture = new Texture(Gdx.files.internal(\"data/badlogic.jpg\"));\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void dispose () {\n\t\t((btSoftRigidDynamicsWorld)(world.dynamicsWorld)).removeSoftBody(softBody);\n\t\tsoftBody.delete();\n\t\tsoftBody = null;\n\t\t\n\t\tsuper.dispose();\n\t\t\t\t\n\t\tworldInfo.delete();\n\t\tworldInfo = null;\n\t\tmesh.dispose();\n\t\tmesh = null;\n\t\ttexture.dispose();\n\t\ttexture = null;\n\t}","id":30514,"modified_method":"@Override\n\tpublic void dispose () {\n\t\t((btSoftRigidDynamicsWorld)(world.collisionWorld)).removeSoftBody(softBody);\n\t\tsoftBody.delete();\n\t\tsoftBody = null;\n\t\t\n\t\tsuper.dispose();\n\t\t\t\t\n\t\tworldInfo.delete();\n\t\tworldInfo = null;\n\t\tmesh.dispose();\n\t\tmesh = null;\n\t\ttexture.dispose();\n\t\ttexture = null;\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void dispose () {\n\t\t((btSoftRigidDynamicsWorld)(world.dynamicsWorld)).removeSoftBody(softBody);\n\t\tsoftBody.delete();\n\t\tsoftBody = null;\n\t\t\n\t\tsuper.dispose();\n\t\t\n\t\tworldInfo.delete();\n\t\tworldInfo = null;\n\t\tmesh.dispose();\n\t\tmesh = null;\n\t}","id":30515,"modified_method":"@Override\n\tpublic void dispose () {\n\t\t((btSoftRigidDynamicsWorld)(world.collisionWorld)).removeSoftBody(softBody);\n\t\tsoftBody.delete();\n\t\tsoftBody = null;\n\t\t\n\t\tsuper.dispose();\n\t\t\n\t\tworldInfo.delete();\n\t\tworldInfo = null;\n\t\tmesh.dispose();\n\t\tmesh = null;\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\t\t\n\t\tworld.maxSubSteps = 20;\n\t\t\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\t\t\n\t\t// Note: not every model is suitable for a one on one translation with a soft body, a better model might be added later.\n\t\tfinal StillModel model = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/wheel.obj\"));\n\t\tmesh = model.subMeshes[0].getMesh().copy(false, true, new int[] {Usage.Position});\n\t\tmesh.scale(6f, 6f, 6f);\n\n\t\tsoftBody = new btSoftBody(worldInfo, mesh.getVerticesBuffer(), mesh.getNumVertices(), mesh.getVertexSize(), mesh.getVertexAttribute(Usage.Position).offset, mesh.getIndicesBuffer(), mesh.getNumIndices()/3);\n\t\t// Set mass of the first vertex to zero so its unmovable, comment out this line to make it a full dynamic body.\n\t\tsoftBody.setMass(0, 0);\n\t\tMaterial pm = softBody.appendMaterial();\n\t\tpm.setM_kLST(0.2f);\n\t\tpm.setM_flags(0);\n\t\tsoftBody.generateBendingConstraints(2, pm);\n\t\t// Be careful increasing iterations, it decreases performance (but increases accuracy). \n\t\tsoftBody.setConfig_piterations(7);\n\t\tsoftBody.setConfig_kDF(0.2f);\n\t\tsoftBody.randomizeConstraints();\n\t\tsoftBody.setTotalMass(1);\n\t\tsoftBody.translate(Vector3.tmp.set(1, 5, 1));\n\t\t((btSoftRigidDynamicsWorld)(world.dynamicsWorld)).addSoftBody(softBody);\n\t}","id":30516,"modified_method":"@Override\n\tpublic void create () {\n\t\tsuper.create();\n\t\t\n\t\tworld.maxSubSteps = 20;\n\t\t\n\t\tworld.add(\"ground\", 0f, 0f, 0f)\n\t\t.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);\n\t\t\n\t\t// Note: not every model is suitable for a one on one translation with a soft body, a better model might be added later.\n\t\tfinal StillModel model = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/wheel.obj\"));\n\t\tmesh = model.subMeshes[0].getMesh().copy(false, true, new int[] {Usage.Position});\n\t\tmesh.scale(6f, 6f, 6f);\n\n\t\tsoftBody = new btSoftBody(worldInfo, mesh.getVerticesBuffer(), mesh.getNumVertices(), mesh.getVertexSize(), mesh.getVertexAttribute(Usage.Position).offset, mesh.getIndicesBuffer(), mesh.getNumIndices()/3);\n\t\t// Set mass of the first vertex to zero so its unmovable, comment out this line to make it a full dynamic body.\n\t\tsoftBody.setMass(0, 0);\n\t\tMaterial pm = softBody.appendMaterial();\n\t\tpm.setM_kLST(0.2f);\n\t\tpm.setM_flags(0);\n\t\tsoftBody.generateBendingConstraints(2, pm);\n\t\t// Be careful increasing iterations, it decreases performance (but increases accuracy). \n\t\tsoftBody.setConfig_piterations(7);\n\t\tsoftBody.setConfig_kDF(0.2f);\n\t\tsoftBody.randomizeConstraints();\n\t\tsoftBody.setTotalMass(1);\n\t\tsoftBody.translate(Vector3.tmp.set(1, 5, 1));\n\t\t((btSoftRigidDynamicsWorld)(world.collisionWorld)).addSoftBody(softBody);\n\t}","commit_id":"03f73bc55e672144c4439bcce798025207b5023d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Sends an array of ERCMailMessage objects.\n     * @param mailMessages array of messages to send\n     */\n    public void sendMailMessages(NSArray mailMessages) {\n        if (mailMessages.count() > 0) {\n            log.info(\"Sending \" + mailMessages.count() + \" mail message(s).\");\n            for (Enumeration messageEnumerator = mailMessages.objectEnumerator();\n                 messageEnumerator.hasMoreElements();) {\n                ERCMailMessage mailMessage = (ERCMailMessage)messageEnumerator.nextElement();\n\n                if( !mailMessage.isReadyToSendState() ) { //due to the operation of the batch iterator, we may pull records that have already been sent\n                    continue;\n                }\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Sending mail message: \" + mailMessage);\n\n                try {\n                    ERMailDelivery delivery = createMailDeliveryForMailMessage(mailMessage);\n\n                    if (delivery != null) {\n                        mailMessage.setState(ERCMailState.PROCESSING_STATE);\n                        mailMessage.editingContext().saveChanges(); // This will throw if optimistic locking occurs\n                        delivery.sendMail(true);\n\n                        mailMessage.setState(ERCMailState.SENT_STATE);\n                        mailMessage.setDateSent(new NSTimestamp());                            \n                        \n                        if (shouldDeleteSentMail()) {\n                            if (mailMessage.shouldArchiveSentMailAsBoolean()) {\n                                mailMessage.archive();\n                            } \n                            mailMessage.editingContext().deleteObject(mailMessage);\n                        }\n                    } else {\n                        log.warn(\"Unable to create mail delivery for mail message: \" + mailMessage);\n                    }\n                } catch (EOGeneralAdaptorException ge) {\n                    if ( _warnOnGeneralAdaptorExceptionLockingMessage )\n                        log.warn(\"Caught general adaptor exception, reverting context. Might be running multiple mailers\", ge);\n                    mailMessage.editingContext().revert();\n                } catch (Throwable e) {\n                    if (e instanceof NSForwardException)\n                        e = ((NSForwardException)e).originalException();\n                    log.warn(\"Caught exception when sending mail: \" + ERXUtilities.stackTrace(e));\n                    log.warn(\"Message trying to send: \" + mailMessage + \" pk: \" + mailMessage.primaryKey());\n                    \n                    // ENHANCEME: Need to implement a waiting state to retry sending mails.\n                    mailMessage.setState(ERCMailState.EXCEPTION_STATE);\n                    mailMessage.setExceptionReason(e.getMessage());\n                    \n                    // Report the mailing error\n                    ERCoreBusinessLogic.sharedInstance().reportException(e, new NSDictionary(mailMessage.snapshot(),\n                                                                                    \"Mail Message Snapshot\"));\n                } finally {\n                    // The editingcontext will not have any changes if an optimistic error occurred\n                    if (mailMessage.editingContext().hasChanges()) {\n                        try {\n                            mailMessage.editingContext().saveChanges();\n                        } catch (RuntimeException runtime) {\n                            log.error(\"RuntimeException during save changes!\", runtime);\n                            throw runtime;\n                        }\n                    }\n                }\n            }            \n        }\n    }","id":30517,"modified_method":"/**\n     * Sends an array of ERCMailMessage objects.\n     * @param mailMessages array of messages to send\n     */\n    public void sendMailMessages(NSArray mailMessages) {\n        if (mailMessages.count() > 0) {\n            log.info(\"Sending \" + mailMessages.count() + \" mail message(s).\");\n            for (Enumeration messageEnumerator = mailMessages.objectEnumerator();\n                 messageEnumerator.hasMoreElements();) {\n                ERCMailMessage mailMessage = (ERCMailMessage)messageEnumerator.nextElement();\n\n                if( !mailMessage.isReadyToSendState() ) { //due to the operation of the batch iterator, we may pull records that have already been sent\n                    continue;\n                }\n\n                if (log.isDebugEnabled())\n                    log.debug(\"Sending mail message: \" + mailMessage);\n\n                try {\n                    ERMailDelivery delivery = createMailDeliveryForMailMessage(mailMessage);\n\n                    if (delivery != null) {\n                        mailMessage.setState(ERCMailState.PROCESSING_STATE);\n                        mailMessage.editingContext().saveChanges(); // This will throw if optimistic locking occurs\n                        delivery.sendMail(true);\n\n                        mailMessage.setState(ERCMailState.SENT_STATE);\n                        mailMessage.setDateSent(new NSTimestamp());                            \n                        \n                        if (shouldDeleteSentMail()) {\n                            if (mailMessage.shouldArchiveSentMailAsBoolean()) {\n                                mailMessage.archive();\n                            }\n                            // FIXME: Nasty stack overflow bug\n                            if (!mailMessage.hasAttachments()) {\n                              mailMessage.editingContext().deleteObject(mailMessage);\n                            }\n                        }\n                    } else {\n                        log.warn(\"Unable to create mail delivery for mail message: \" + mailMessage);\n                    }\n                } catch (EOGeneralAdaptorException ge) {\n                    if ( _warnOnGeneralAdaptorExceptionLockingMessage )\n                        log.warn(\"Caught general adaptor exception, reverting context. Might be running multiple mailers\", ge);\n                    mailMessage.editingContext().revert();\n                } catch (Throwable e) {\n                    if (e instanceof NSForwardException)\n                        e = ((NSForwardException)e).originalException();\n                    log.warn(\"Caught exception when sending mail: \" + ERXUtilities.stackTrace(e));\n                    log.warn(\"Message trying to send: \" + mailMessage + \" pk: \" + mailMessage.primaryKey());\n                    \n                    // ENHANCEME: Need to implement a waiting state to retry sending mails.\n                    mailMessage.setState(ERCMailState.EXCEPTION_STATE);\n                    mailMessage.setExceptionReason(e.getMessage());\n                    \n                    // Report the mailing error\n                    ERCoreBusinessLogic.sharedInstance().reportException(e, new NSDictionary(mailMessage.snapshot(),\n                                                                                    \"Mail Message Snapshot\"));\n                } finally {\n                    // The editingcontext will not have any changes if an optimistic error occurred\n                    if (mailMessage.editingContext().hasChanges()) {\n                        try {\n                            mailMessage.editingContext().saveChanges();\n                        } catch (RuntimeException runtime) {\n                            log.error(\"RuntimeException during save changes!\", runtime);\n                            throw runtime;\n                        }\n                    }\n                }\n            }            \n        }\n    }","commit_id":"aa885704175c8be08b3b3b4085a9a502ccbe6003","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Creates a ERMailDelivery for a given\n     * MailMessage.\n     * @param message mail message\n     * @return a mail delevery object\n     */\n    // ENHANCEME: Not handling double byte (Japanese) language or file attachments.\n    public ERMailDelivery createMailDeliveryForMailMessage(ERCMailMessage message) throws MessagingException {\n        ERMailDelivery mail = null;\n        if (message.text() != null) {\n            mail = ERMailDeliveryHTML.newMailDelivery();\n            ((ERMailDeliveryHTML)mail).setHTMLContent(message.text());\n\n            if (message.plainText() != null)\n                ((ERMailDeliveryHTML)mail).setHiddenPlainTextContent(message.plainText());            \n        } else {\n            mail = new ERMailDeliveryPlainText();\n            ((ERMailDeliveryPlainText)mail).setTextContent(message.plainText());\n        }\n        \n        // Add all of the addresses\n        mail.setFromAddress(message.fromAddress());\n        if (message.replyToAddress() != null)\n            mail.setReplyToAddress(message.replyToAddress());\n        mail.setToAddresses(message.toAddressesAsArray());\n        if (message.ccAddressesAsArray().count() > 0)\n            mail.setCCAddresses(message.ccAddressesAsArray());\n        if (message.bccAddressesAsArray().count() > 0)\n            mail.setBCCAddresses(message.bccAddressesAsArray());\n\n        // Set the xMailer if one is specified\n        // Note (tuscland): setXMailerHeader has a higher precedence over\n        // System property er.javamail.XMailerHeader\n        if (message.xMailer() != null)\n            mail.setXMailerHeader(message.xMailer());\n\n        // Set the content\n        mail.setSubject(messageTitlePrefix() + message.title());\n        return mail;\n    }","id":30518,"modified_method":"/**\n     * Creates a ERMailDelivery for a given\n     * MailMessage.\n     * @param message mail message\n     * @return a mail delevery object\n     */\n    // ENHANCEME: Not handling double byte (Japanese) language\n    public ERMailDelivery createMailDeliveryForMailMessage(ERCMailMessage message) throws MessagingException {\n        ERMailDelivery mail = null;\n        if (message.text() != null) {\n            mail = ERMailDeliveryHTML.newMailDelivery();\n            ((ERMailDeliveryHTML)mail).setHTMLContent(message.text());\n\n            if (message.plainText() != null)\n                ((ERMailDeliveryHTML)mail).setHiddenPlainTextContent(message.plainText());            \n        } else {\n            mail = new ERMailDeliveryPlainText();\n            ((ERMailDeliveryPlainText)mail).setTextContent(message.plainText());\n        }\n        \n        // Add all of the addresses\n        mail.setFromAddress(message.fromAddress());\n        if (message.replyToAddress() != null)\n            mail.setReplyToAddress(message.replyToAddress());\n        mail.setToAddresses(message.toAddressesAsArray());\n        if (message.ccAddressesAsArray().count() > 0)\n            mail.setCCAddresses(message.ccAddressesAsArray());\n        if (message.bccAddressesAsArray().count() > 0)\n            mail.setBCCAddresses(message.bccAddressesAsArray());\n\n        // Set the xMailer if one is specified\n        // Note (tuscland): setXMailerHeader has a higher precedence over\n        // System property er.javamail.XMailerHeader\n        if (message.xMailer() != null)\n            mail.setXMailerHeader(message.xMailer());\n\n        // Set the content\n        mail.setSubject(messageTitlePrefix() + message.title());\n\n        if (message.hasAttachments()) {\n          for (Enumeration attachmentEnumerator = message.attachments().objectEnumerator(); attachmentEnumerator.hasMoreElements();) {\n            File fileAttachment = ((ERCMessageAttachment)attachmentEnumerator.nextElement()).file();\n            mail.addAttachment(new ERMailFileAttachment(fileAttachment.getName(), null, fileAttachment));\n          }\n        }\n        return mail;\n    }","commit_id":"aa885704175c8be08b3b3b4085a9a502ccbe6003","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void deleteObject(EOEnterpriseObject objectToRemove) {\n        removeObject(objectToRemove);\n        if(objectToRemove.editingContext() != null) {\n            objectToRemove.editingContext().deleteObject(objectToRemove);\n        }\n    }","id":30519,"modified_method":"public void deleteObject(EOEnterpriseObject objectToRemove) {\n        removeObject(objectToRemove);\n        if(objectToRemove.editingContext() != null) {\n            // AK: this is a bit tricky... when we delete and a delete can fail,\n            // WOApp tries to validate the delete at the and\n            // of the current RR loop and this triggers an exception\n            // that can't be caught in the page itself\n            // so what we do here is delete the object, try to validate and\n            // is that fails, restore the EC. This isn't sufficient either -\n            // as reverting deletes doesn't really work well -\n            // but preferable to simply showing up and exception page.\n            try {\n                objectToRemove.editingContext().deleteObject(objectToRemove);\n                objectToRemove.validateForDelete();\n            } catch (NSValidation.ValidationException ex) {\n                validationFailedWithException(ex, objectToRemove, key());\n                object().editingContext().revert();\n             }\n        }\n    }","commit_id":"b3d6897c0977926d7da466708a25a087311fa1d1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent removeFromToManyRelationshipAction() {\n        if(((ERXSession)session()).javaScriptEnabled())\n            updateEOsOrdering();\t   \n        if (browserSelections != null) {\n            for (Enumeration e = browserSelections.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject object=(EOEnterpriseObject)e.nextElement();\n                EOEnterpriseObject _localEoToRremoveFromRelationship =\n                    (EOEnterpriseObject)object.valueForKey(destinationRelationship().name());\n                object.removeObjectFromBothSidesOfRelationshipWithKey(_localEoToRremoveFromRelationship,\n                                                                    destinationRelationship().name());\n                object().removeObjectFromBothSidesOfRelationshipWithKey(object,\n                                                                      relationshipKey());                                                                    \n                editingContext().deleteObject(object);\n            }\n            relationshipDisplayGroup.fetch(); // updateDisplayedObjects is not doing the trick\n            if(isSortedRelationship()){\n                //Now need to reindex the joins if the relationship is sorted\n                int i = 0;\n                for(Enumeration e = relationshipDisplayGroup.displayedObjects().objectEnumerator();\n                    e.hasMoreElements();){\n                    EOEnterpriseObject object = (EOEnterpriseObject)e.nextElement();\n                    object.takeValueForKey(new Integer(i), indexKey());\n                    i++;\n                }\n            }\n        }\n        return null;\n    }","id":30520,"modified_method":"public WOComponent removeFromToManyRelationshipAction() {\n        if(((ERXSession)session()).javaScriptEnabled())\n            updateEOsOrdering();\t   \n        if (browserSelections != null) {\n            for (Enumeration e = browserSelections.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject object=(EOEnterpriseObject)e.nextElement();\n                EOEnterpriseObject _localEoToRremoveFromRelationship =\n                    (EOEnterpriseObject)object.valueForKey(destinationRelationship().name());\n                object.removeObjectFromBothSidesOfRelationshipWithKey(_localEoToRremoveFromRelationship,\n                                                                    destinationRelationship().name());\n                object().removeObjectFromBothSidesOfRelationshipWithKey(object,\n                                                                      relationshipKey());\n                if(object instanceof ERXGuardedObjectInterface){\n                    ((ERXGuardedObjectInterface)object).delete();\n                }else{\n                    editingContext().deleteObject(object);\n                }\n            }\n            relationshipDisplayGroup.fetch(); // updateDisplayedObjects is not doing the trick\n            if(isSortedRelationship()){\n                //Now need to reindex the joins if the relationship is sorted\n                int i = 0;\n                for(Enumeration e = relationshipDisplayGroup.displayedObjects().objectEnumerator();\n                    e.hasMoreElements();){\n                    EOEnterpriseObject object = (EOEnterpriseObject)e.nextElement();\n                    object.takeValueForKey(new Integer(i), indexKey());\n                    i++;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"b4697b1756e858facaa31e07d79c95869d3b32fc","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void run() {\n            m_ensure.step(1);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 2));\n            m_ensure.step(3);\n            m_ensure.waitForStep(5, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 7));\n            m_ensure.step(8);\n            m_ensure.waitForStep(10, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 11));\n        }","id":30521,"modified_method":"public void run() {\n            m_ensure.step(1);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 2));\n            m_ensure.step(3);\n            m_ensure.waitForStep(5, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 7));\n            m_ensure.step(9);\n            m_ensure.waitForStep(11, 2000);\n            m_service.invoke(Ensure.createRunnableStep(m_ensure, 12));\n        }","commit_id":"f8aa5ad9732e958433ff12df7f25401c7c903809","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testDynamicallyAddAndRemoveAspect(BundleContext context) {\n        DependencyManager m = new DependencyManager(context);\n        // helper class that ensures certain steps get executed in sequence\n        Ensure e = new Ensure();\n        // create a service provider and consumer\n        Service sp = m.createService().setImplementation(new ServiceProvider(e)).setInterface(ServiceInterface.class.getName(), null);\n        Service sc = m.createService().setImplementation(new ServiceConsumer(e)).add(m.createServiceDependency().setService(ServiceInterface.class).setRequired(true));\n        Service sa = m.createAspectService(ServiceInterface.class, \"(|(!(\" + Constants.SERVICE_RANKING + \"=*))(\" + Constants.SERVICE_RANKING + \"<=0))\", new ServiceAspect(e), new Properties() {{ put(Constants.SERVICE_RANKING, Integer.valueOf(1)); }} );\n        m.add(sc);\n        m.add(sp);\n        e.waitForStep(3, 2000);\n        m.add(sa);\n        e.waitForStep(4, 2000);\n        e.step(5);\n        e.waitForStep(8, 2000);\n        m.remove(sa);\n        e.waitForStep(9, 2000);\n        e.step(10);\n        e.waitForStep(11, 2000);\n        m.remove(sp);\n        m.remove(sc);\n    }","id":30522,"modified_method":"@Test\n    public void testDynamicallyAddAndRemoveAspect(BundleContext context) {\n        DependencyManager m = new DependencyManager(context);\n        // helper class that ensures certain steps get executed in sequence\n        Ensure e = new Ensure();\n        // create a service provider and consumer\n        Service sp = m.createService().setImplementation(new ServiceProvider(e)).setInterface(ServiceInterface.class.getName(), null);\n        Service sp2 = m.createService().setImplementation(new ServiceProvider2(e)).setInterface(ServiceInterface2.class.getName(), null);\n        Service sc = m.createService().setImplementation(new ServiceConsumer(e)).add(m.createServiceDependency().setService(ServiceInterface.class).setRequired(true));\n        Service sa = m.createAspectService(ServiceInterface.class, \"(|(!(\" + Constants.SERVICE_RANKING + \"=*))(\" + Constants.SERVICE_RANKING + \"<=0))\", new ServiceAspect(e), new Properties() {{ put(Constants.SERVICE_RANKING, Integer.valueOf(1)); }} );\n        m.add(sc);\n        m.add(sp);\n        m.add(sp2);\n        e.waitForStep(3, 2000);\n        m.add(sa);\n        e.waitForStep(4, 2000);\n        e.step(5);\n        e.waitForStep(8, 2000);\n        m.remove(sa);\n        e.waitForStep(10, 2000);\n        e.step(11);\n        e.waitForStep(12, 2000);\n        m.remove(sp2);\n        m.remove(sp);\n        m.remove(sc);\n    }","commit_id":"f8aa5ad9732e958433ff12df7f25401c7c903809","url":"https://github.com/apache/felix"},{"original_method":"public void stop() {\n            m_ensure.step(9);\n        }","id":30523,"modified_method":"public void stop() {\n            m_ensure.step(10);\n        }","commit_id":"f8aa5ad9732e958433ff12df7f25401c7c903809","url":"https://github.com/apache/felix"},{"original_method":"public void invoke(Runnable run) {\n            m_ensure.step(6);\n            m_originalService.invoke(run);\n        }","id":30524,"modified_method":"public void invoke(Runnable run) {\n            m_ensure.step(6);\n            m_originalService.invoke(run);\n            m_injectedService.invoke();\n        }","commit_id":"f8aa5ad9732e958433ff12df7f25401c7c903809","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testComponentLifeCycleWhenAddingAndRemovingDependencies(BundleContext context) throws Exception {\n        DependencyManager m = new DependencyManager(context);\n        // helper class that ensures certain steps get executed in sequence\n        Ensure e = new Ensure();\n        // create a resource provider\n        \n        Component component = m.createComponent().setInterface(MyService2.class.getName(), null).setImplementation(new MyComponent(e));\n        ServiceDependency dependency = m.createServiceDependency().setService(MyService.class).setRequired(true);\n        ServiceDependency dependency2 = m.createServiceDependency().setService(MyService.class).setRequired(true);\n        ServiceTracker st = new ServiceTracker(context, MyService2.class.getName(), null);\n        st.open();\n        Component component2 = m.createComponent().setInterface(MyService.class.getName(), null).setImplementation(MyImpl.class);\n        \n        // add the component: it has no dependencies so it should be activated immediately\n        m.add(component);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n                \n        // add a required dependency that is not available, so the component should be deactivated\n        component.add(dependency);\n        Assert.assertNull(\"service should no longer be available\", st.getService());\n        // remove the dependency again, so the component should be activated again\n        component.remove(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        // make the dependency instance bound\n        dependency.setInstanceBound(true);\n        \n        // add it again, the component was already active so even though the dependency\n        // is required, the component will *NOT* go through the destroy life cycle methods\n        component.add(dependency);\n        Assert.assertNull(\"service should no longer be available\", st.getService());\n        component.remove(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        \n        // make the second dependency instance bound too\n        dependency2.setInstanceBound(true);\n        \n        // activate the service we depend on\n        m.add(component2);\n        \n        component.add(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        component.add(dependency2);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        component.remove(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        \n        e.step(9);\n        \n        // remove the service again\n        m.remove(component2);\n        e.step(11);\n        Assert.assertNull(\"service should no longer be available\", st.getService());\n        component.remove(dependency2);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        m.remove(component);\n        e.step(15);\n    }","id":30525,"modified_method":"@Test\n    public void testComponentLifeCycleWhenAddingAndRemovingDependencies(BundleContext context) throws Exception {\n        DependencyManager m = new DependencyManager(context);\n        // helper class that ensures certain steps get executed in sequence\n        Ensure e = new Ensure();\n        // create a resource provider\n        \n        Component component = m.createComponent().setInterface(MyService2.class.getName(), null).setImplementation(new MyComponent(e));\n        ServiceDependency dependency = m.createServiceDependency().setService(MyService.class).setRequired(true);\n        ServiceDependency dependency2 = m.createServiceDependency().setService(MyService.class).setRequired(true);\n        ServiceTracker st = new ServiceTracker(context, MyService2.class.getName(), null);\n        st.open();\n        Component component2 = m.createComponent().setInterface(MyService.class.getName(), null).setImplementation(new MyImpl(e));\n        \n        // add the component: it has no dependencies so it should be activated immediately\n        m.add(component);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n                \n        // add a required dependency that is not available, so the component should be deactivated\n        component.add(dependency);\n        Assert.assertNull(\"service should no longer be available\", st.getService());\n        // remove the dependency again, so the component should be activated again\n        component.remove(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        // make the dependency instance bound\n        dependency.setInstanceBound(true);\n        \n        // add it again, the component was already active so even though the dependency\n        // is required, the component will *NOT* go through the destroy life cycle methods\n        component.add(dependency);\n        Assert.assertNull(\"service should no longer be available\", st.getService());\n        component.remove(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        \n        // make the second dependency instance bound too\n        dependency2.setInstanceBound(true);\n        \n        // activate the service we depend on\n        m.add(component2);\n        // init and start should be invoked here, so wait for them to complete\n        e.waitForStep(10, 5000);\n        \n        component.add(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        component.add(dependency2);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        component.remove(dependency);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        \n        e.step(11);\n        \n        // remove the service again\n        m.remove(component2);\n        e.step(15);\n        Assert.assertNull(\"service should no longer be available\", st.getService());\n        component.remove(dependency2);\n        Assert.assertNotNull(\"service should be available\", st.getService());\n        m.remove(component);\n        e.step(19);\n    }","commit_id":"555104f6a1c3b2403042f029482875365bdc5ff4","url":"https://github.com/apache/felix"},{"original_method":"@Start\n    void start()\n    {\n        if (m_serviceProvider2 != null)\n        {\n            m_sequencer.step(4);\n        }\n        m_sequencer.step(5);\n    }","id":30526,"modified_method":"@Start\n    void start()\n    {\n        m_serviceProvider2.step(4);\n        m_sequencer.step(5);\n    }","commit_id":"bf5c8132d1849422031309b1b12dc45e6f8659ae","url":"https://github.com/apache/felix"},{"original_method":"public AbstractTreeHasher(FragmentsCollector cb) {\n    myCallBack = cb;\n  }","id":30527,"modified_method":"public AbstractTreeHasher(FragmentsCollector cb, boolean forIndexing) {\n    myCallBack = cb;\n    myForIndexing = forIndexing;\n  }","commit_id":"f9b5c824c9f4e65943a8aa5d38564a2ac23d0eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Computes element hash using children hashes.\n   * Creates only single PsiFragment.\n   */\n  protected TreeHashResult computeElementHash(@NotNull final PsiElement root, final PsiFragment upper, final NodeSpecificHasher hasher) {\n    ProgressManager.checkCanceled();\n    final List<PsiElement> children = hasher.getNodeChildren(root);\n    final int size = children.size();\n    final int[] childHashes = new int[size];\n    final int[] childCosts = new int[size];\n\n    final PsiFragment fragment = new TreePsiFragment(hasher, root, getCost(root));\n\n    if (upper != null) {\n      fragment.setParent(upper);\n    }\n\n    if (size == 0 && !(root instanceof LeafElement)) {\n      return new TreeHashResult(hasher.getNodeHash(root), hasher.getNodeCost(root), fragment);\n    }\n\n    for (int i = 0; i < size; i++) {\n      final TreeHashResult res = hash(children.get(i), fragment, hasher);\n      childHashes[i] = res.getHash();\n      childCosts[i] = res.getCost();\n    }\n\n    final int c = hasher.getNodeCost(root) + AbstractTreeHasher.vector(childCosts);\n    final int h1 = hasher.getNodeHash(root);\n\n    final int discardCost = getDiscardCost(root);\n\n    for (int i = 0; i < size; i++) {\n      if (childCosts[i] <= discardCost && ignoreChildHash(children.get(i))) {\n        childHashes[i] = 0;\n      }\n    }\n    final int h = h1 + AbstractTreeHasher.vector(childHashes);\n\n    if (myCallBack != null) {\n      myCallBack.add(h, c, fragment);\n    }\n\n    return new TreeHashResult(h, c, fragment);\n  }","id":30528,"modified_method":"/**\n   * Computes element hash using children hashes.\n   * Creates only single PsiFragment.\n   */\n  protected TreeHashResult computeElementHash(@NotNull final PsiElement root, final PsiFragment upper, final NodeSpecificHasher hasher) {\n    ProgressManager.checkCanceled();\n    final List<PsiElement> children = hasher.getNodeChildren(root);\n    final int size = children.size();\n    final int[] childHashes = new int[size];\n    final int[] childCosts = new int[size];\n\n    final PsiFragment fragment = buildFragment(hasher, root, getCost(root));\n\n    if (upper != null) {\n      fragment.setParent(upper);\n    }\n\n    if (size == 0 && !(root instanceof LeafElement)) {\n      return new TreeHashResult(hasher.getNodeHash(root), hasher.getNodeCost(root), fragment);\n    }\n\n    for (int i = 0; i < size; i++) {\n      final TreeHashResult res = hash(children.get(i), fragment, hasher);\n      childHashes[i] = res.getHash();\n      childCosts[i] = res.getCost();\n    }\n\n    final int c = hasher.getNodeCost(root) + vector(childCosts);\n    final int h1 = hasher.getNodeHash(root);\n\n    final int discardCost = getDiscardCost(root);\n\n    for (int i = 0; i < size; i++) {\n      if (childCosts[i] <= discardCost && ignoreChildHash(children.get(i))) {\n        childHashes[i] = 0;\n      }\n    }\n    final int h = h1 + vector(childHashes);\n\n    if (myCallBack != null) {\n      myCallBack.add(h, c, fragment);\n    }\n\n    return new TreeHashResult(h, c, fragment);\n  }","commit_id":"f9b5c824c9f4e65943a8aa5d38564a2ac23d0eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiAnchor createAnchor(final PsiElement element) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<PsiAnchor>() {\n      public PsiAnchor compute() {\n        return PsiAnchor.create(element);\n      }\n    });\n  }","id":30529,"modified_method":"protected PsiAnchor createAnchor(final PsiElement element) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<PsiAnchor>() {\n      public PsiAnchor compute() {\n        return PsiAnchor.create(element);\n      }\n    });\n  }","commit_id":"f9b5c824c9f4e65943a8aa5d38564a2ac23d0eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"TreeHasherBase(@Nullable FragmentsCollector callback,\n                 @NotNull DuplicatesProfile profile,\n                 int discardCost, boolean forIndexing) {\n    super(callback);\n    myCallback = callback;\n    myDiscardCost = discardCost;\n    myProfile = profile;\n    myForIndexing = forIndexing;\n  }","id":30530,"modified_method":"TreeHasherBase(@Nullable FragmentsCollector callback,\n                 @NotNull DuplicatesProfile profile,\n                 int discardCost, boolean forIndexing) {\n    super(callback, forIndexing);\n    myCallback = callback;\n    myDiscardCost = discardCost;\n    myProfile = profile;\n  }","commit_id":"f9b5c824c9f4e65943a8aa5d38564a2ac23d0eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected TreeHashResult computeElementHash(@NotNull PsiElement root, PsiFragment upper, NodeSpecificHasher hasher) {\n    final List<PsiElement> children = hasher.getNodeChildren(root);\n    final int size = children.size();\n    final int[] childHashes = new int[size];\n    final int[] childCosts = new int[size];\n\n    final PsiFragment fragment = new TreePsiFragment(hasher, root, getCost(root));\n\n    if (upper != null) {\n      fragment.setParent(upper);\n    }\n\n    if (size == 0 && !(root instanceof LeafElement)) {\n      // contains only whitespaces and other unmeaning children\n      return new TreeHashResult(0, hasher.getNodeCost(root), fragment);\n    }\n\n    for (int i = 0; i < size; i++) {\n      final TreeHashResult res = this.hash(children.get(i), fragment, hasher);\n      childHashes[i] = res.getHash();\n      childCosts[i] = res.getCost();\n    }\n\n    final int c = hasher.getNodeCost(root) + AbstractTreeHasher.vector(childCosts);\n    final int h1 = hasher.getNodeHash(root);\n\n    final int discardCost = getDiscardCost(root);\n\n    for (int i = 0; i < size; i++) {\n      if (childCosts[i] <= discardCost && ignoreChildHash(children.get(i))) {\n        childHashes[i] = 0;\n      }\n    }\n\n    int h = h1 + AbstractTreeHasher.vector(childHashes);\n\n    if (shouldBeAnonymized(root, (NodeSpecificHasherBase)hasher)) {\n      h = 0;\n    }\n\n    if (myCallBack != null) {\n      myCallBack.add(h, c, fragment);\n    }\n\n    return new TreeHashResult(h, c, fragment);\n  }","id":30531,"modified_method":"@Override\n  protected TreeHashResult computeElementHash(@NotNull PsiElement root, PsiFragment upper, NodeSpecificHasher hasher) {\n    final List<PsiElement> children = hasher.getNodeChildren(root);\n    final int size = children.size();\n    final int[] childHashes = new int[size];\n    final int[] childCosts = new int[size];\n\n    final PsiFragment fragment = buildFragment(hasher, root, getCost(root));\n\n    if (upper != null) {\n      fragment.setParent(upper);\n    }\n\n    if (size == 0 && !(root instanceof LeafElement)) {\n      // contains only whitespaces and other unmeaning children\n      return new TreeHashResult(0, hasher.getNodeCost(root), fragment);\n    }\n\n    for (int i = 0; i < size; i++) {\n      final TreeHashResult res = this.hash(children.get(i), fragment, hasher);\n      childHashes[i] = res.getHash();\n      childCosts[i] = res.getCost();\n    }\n\n    final int c = hasher.getNodeCost(root) + AbstractTreeHasher.vector(childCosts);\n    final int h1 = hasher.getNodeHash(root);\n\n    final int discardCost = getDiscardCost(root);\n\n    for (int i = 0; i < size; i++) {\n      if (childCosts[i] <= discardCost && ignoreChildHash(children.get(i))) {\n        childHashes[i] = 0;\n      }\n    }\n\n    int h = h1 + AbstractTreeHasher.vector(childHashes);\n\n    if (shouldBeAnonymized(root, (NodeSpecificHasherBase)hasher)) {\n      h = 0;\n    }\n\n    if (myCallBack != null) {\n      myCallBack.add(h, c, fragment);\n    }\n\n    return new TreeHashResult(h, c, fragment);\n  }","commit_id":"f9b5c824c9f4e65943a8aa5d38564a2ac23d0eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TreeHashResult computeHash(PsiElement element,\n                                     PsiFragment parent,\n                                     EquivalenceDescriptor descriptor,\n                                     NodeSpecificHasher hasher) {\n    final NodeSpecificHasherBase ssrHasher = (NodeSpecificHasherBase)hasher;\n    final PsiElement element2 = DuplocatorUtil.skipNodeIfNeccessary(element, descriptor, ssrHasher.getNodeFilter());\n    final boolean canSkip = element2 != element;\n\n    final PsiFragment fragment = new TreePsiFragment(hasher, element, 0);\n\n    if (parent != null) {\n      fragment.setParent(parent);\n    }\n\n    int hash = canSkip ? 0 : hasher.getNodeHash(element);\n    int cost = hasher.getNodeCost(element);\n\n    for (SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) {\n      final Pair<Integer, Integer> childHashResult = computeHash(childDescriptor, fragment, hasher);\n      hash = hash * 31 + childHashResult.first;\n      cost += childHashResult.second;\n    }\n\n    for (MultiChildDescriptor childDescriptor : descriptor.getMultiChildDescriptors()) {\n      final Pair<Integer, Integer> childHashResult = computeHash(childDescriptor, fragment, hasher);\n      hash = hash * 31 + childHashResult.first;\n      cost += childHashResult.second;\n    }\n\n    for (Object constant : descriptor.getConstants()) {\n      final int constantHash = constant != null ? constant.hashCode() : 0;\n      hash = hash * 31 + constantHash;\n    }\n\n    for (PsiElement[] codeBlock : descriptor.getCodeBlocks()) {\n      final List<PsiElement> filteredBlock = filter(codeBlock, ssrHasher);\n      final TreeHashResult childHashResult = hashCodeBlock(filteredBlock, fragment, hasher);\n      hash = hash * 31 + childHashResult.getHash();\n      cost += childHashResult.getCost();\n    }\n\n    if (myCallback != null) {\n      myCallback.add(hash, cost, fragment);\n    }\n    return new TreeHashResult(hash, cost, fragment);\n  }","id":30532,"modified_method":"private TreeHashResult computeHash(PsiElement element,\n                                     PsiFragment parent,\n                                     EquivalenceDescriptor descriptor,\n                                     NodeSpecificHasher hasher) {\n    final NodeSpecificHasherBase ssrHasher = (NodeSpecificHasherBase)hasher;\n    final PsiElement element2 = DuplocatorUtil.skipNodeIfNeccessary(element, descriptor, ssrHasher.getNodeFilter());\n    final boolean canSkip = element2 != element;\n\n    final PsiFragment fragment = buildFragment(hasher, element, 0);\n\n    if (parent != null) {\n      fragment.setParent(parent);\n    }\n\n    int hash = canSkip ? 0 : hasher.getNodeHash(element);\n    int cost = hasher.getNodeCost(element);\n\n    for (SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) {\n      final Pair<Integer, Integer> childHashResult = computeHash(childDescriptor, fragment, hasher);\n      hash = hash * 31 + childHashResult.first;\n      cost += childHashResult.second;\n    }\n\n    for (MultiChildDescriptor childDescriptor : descriptor.getMultiChildDescriptors()) {\n      final Pair<Integer, Integer> childHashResult = computeHash(childDescriptor, fragment, hasher);\n      hash = hash * 31 + childHashResult.first;\n      cost += childHashResult.second;\n    }\n\n    for (Object constant : descriptor.getConstants()) {\n      final int constantHash = constant != null ? constant.hashCode() : 0;\n      hash = hash * 31 + constantHash;\n    }\n\n    for (PsiElement[] codeBlock : descriptor.getCodeBlocks()) {\n      final List<PsiElement> filteredBlock = filter(codeBlock, ssrHasher);\n      final TreeHashResult childHashResult = hashCodeBlock(filteredBlock, fragment, hasher);\n      hash = hash * 31 + childHashResult.getHash();\n      cost += childHashResult.getCost();\n    }\n\n    if (myCallback != null) {\n      myCallback.add(hash, cost, fragment);\n    }\n    return new TreeHashResult(hash, cost, fragment);\n  }","commit_id":"f9b5c824c9f4e65943a8aa5d38564a2ac23d0eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void run() throws Exception {\n        response = new MapEntrySet();\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n        final RecordStore recordStore = mapService.getRecordStore(getPartitionId(),name);\n        MapEntrySimple entry;\n\n        for(Data key:keys)\n        {\n            if(partitionService.getPartitionId(key) != getPartitionId())\n                continue;\n            Object objectKey = mapService.toObject(key);\n            final Map.Entry<Data, Object> mapEntry = recordStore.getMapEntry(key);\n            final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n            entry = new MapEntrySimple(objectKey,valueBeforeProcess);\n            final Object result = entryProcessor.process(entry);\n            final Object valueAfterProcess = entry.getValue();\n            Data dataValue = null;\n            if (result != null) {\n                dataValue = mapService.toData(result);\n                response.add(new AbstractMap.SimpleImmutableEntry<Data, Data>(key, dataValue));\n            }\n            EntryEventType eventType;\n            if (valueAfterProcess == null) {\n                recordStore.remove(key);\n                eventType = EntryEventType.REMOVED;\n            } else {\n                if (valueBeforeProcess == null) {\n                    eventType = EntryEventType.ADDED;\n                }\n                // take this case as a read so no need to fire an event.\n                else if (!entry.isModified()) {\n                    eventType = __NO_NEED_TO_FIRE_EVENT;\n                } else {\n                    eventType = EntryEventType.UPDATED;\n                }\n                // todo if this is a read only operation, record access operations should be done.\n                if (eventType != __NO_NEED_TO_FIRE_EVENT) {\n                    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data, Object>(key, valueAfterProcess));\n                }\n            }\n\n            if (eventType != __NO_NEED_TO_FIRE_EVENT) {\n                mapService.publishEvent(getCallerAddress(), name, eventType, key, (Data)mapEntry.getValue(), dataValue);\n                if (mapContainer.isNearCacheEnabled()\n                        && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {\n                    mapService.invalidateAllNearCaches(name, key);\n                }\n                if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {\n                    if (EntryEventType.REMOVED.equals(eventType)) {\n                        mapService.publishWanReplicationRemove(name, key, Clock.currentTimeMillis());\n                    } else {\n                        Record r = recordStore.getRecord(key);\n                        SimpleEntryView entryView = new SimpleEntryView(key, mapService.toData(dataValue), r.getStatistics(), r.getCost(), r.getVersion());\n                        mapService.publishWanReplicationUpdate(name, entryView);\n                    }\n                }\n            }\n\n        }\n\n    }","id":30533,"modified_method":"@Override\n    public void run() throws Exception {\n        response = new MapEntrySet();\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n        final RecordStore recordStore = mapService.getRecordStore(getPartitionId(),name);\n        MapEntrySimple entry;\n\n        for(Data key:keys)\n        {\n            if(partitionService.getPartitionId(key) != getPartitionId())\n                continue;\n            Object objectKey = mapService.toObject(key);\n            final Map.Entry<Data, Object> mapEntry = recordStore.getMapEntry(key);\n            final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n            entry = new MapEntrySimple(objectKey,valueBeforeProcess);\n            final Object result = entryProcessor.process(entry);\n            final Object valueAfterProcess = entry.getValue();\n            Data dataValue = null;\n            if (result != null) {\n                dataValue = mapService.toData(result);\n                response.add(new AbstractMap.SimpleImmutableEntry<Data, Data>(key, dataValue));\n            }\n            EntryEventType eventType;\n            if (valueAfterProcess == null) {\n                recordStore.remove(key);\n                eventType = EntryEventType.REMOVED;\n            } else {\n                if (valueBeforeProcess == null) {\n                    eventType = EntryEventType.ADDED;\n                }\n                // take this case as a read so no need to fire an event.\n                else if (!entry.isModified()) {\n                    eventType = __NO_NEED_TO_FIRE_EVENT;\n                } else {\n                    eventType = EntryEventType.UPDATED;\n                }\n                // todo if this is a read only operation, record access operations should be done.\n                if (eventType != __NO_NEED_TO_FIRE_EVENT) {\n                    recordStore.put(new AbstractMap.SimpleImmutableEntry<Data, Object>(key, valueAfterProcess));\n                }\n            }\n\n            if (eventType != __NO_NEED_TO_FIRE_EVENT) {\n                Data dataOldValue = mapService.toData(mapEntry.getValue());\n                mapService.publishEvent(getCallerAddress(), name, eventType, key, dataOldValue, dataValue);\n                if (mapContainer.isNearCacheEnabled()\n                        && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {\n                    mapService.invalidateAllNearCaches(name, key);\n                }\n                if (mapContainer.getWanReplicationPublisher() != null && mapContainer.getWanMergePolicy() != null) {\n                    if (EntryEventType.REMOVED.equals(eventType)) {\n                        mapService.publishWanReplicationRemove(name, key, Clock.currentTimeMillis());\n                    } else {\n                        Record r = recordStore.getRecord(key);\n\n                        Data tempValue = mapService.toData(dataValue);\n                        RecordStatistics statistics = r.getStatistics();\n                        long cost = r.getCost();\n                        long version = r.getVersion();\n\n                        SimpleEntryView entryView = new SimpleEntryView(key, tempValue, statistics, cost, version);\n                        mapService.publishWanReplicationUpdate(name, entryView);\n                    }\n                }\n            }\n\n        }\n\n    }","commit_id":"feaf09c489975852089ed655b830d9e5140b2cb2","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"ChosenRequest removeFirst(int fuzz, RandomSource random, OfferedKeysList[] offeredKeys, RequestStarter starter, ClientRequestSchedulerNonPersistent schedTransient, boolean transientOnly, short maxPrio, int retryCount) {\n\t\tSendableRequest req = removeFirstInner(fuzz, random, offeredKeys, starter, schedTransient, transientOnly, maxPrio, retryCount);\n\t\tObject token = req.chooseKey(this, req.persistent() ? container : null);\n\t\tif(token == null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tKey key;\n\t\t\tif(isInsertScheduler)\n\t\t\t\tkey = null;\n\t\t\telse\n\t\t\t\tkey = ((BaseSendableGet)req).getNodeKey(token, persistent() ? container : null);\n\t\t\tPersistentChosenRequest ret = new PersistentChosenRequest(this, req, token, key);\n\t\t\tif(req.persistent())\n\t\t\t\tcontainer.set(ret);\n\t\t\tif(key != null)\n\t\t\t\tkeysFetching.add(key);\n\t\t\treturn ret;\n\t\t}\n\t}","id":30534,"modified_method":"ChosenRequest removeFirst(int fuzz, RandomSource random, OfferedKeysList[] offeredKeys, RequestStarter starter, ClientRequestSchedulerNonPersistent schedTransient, boolean transientOnly, short maxPrio, int retryCount) {\n\t\tSendableRequest req = removeFirstInner(fuzz, random, offeredKeys, starter, schedTransient, transientOnly, maxPrio, retryCount);\n\t\tObject token = req.chooseKey(this, req.persistent() ? container : null);\n\t\tif(token == null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tKey key;\n\t\t\tif(isInsertScheduler)\n\t\t\t\tkey = null;\n\t\t\telse\n\t\t\t\tkey = ((BaseSendableGet)req).getNodeKey(token, persistent() ? container : null);\n\t\t\tChosenRequest ret;\n\t\t\tif(req.persistent()) {\n\t\t\t\tret = new PersistentChosenRequest(this, req, token, key);\n\t\t\t\tcontainer.set(ret);\n\t\t\t} else {\n\t\t\t\tret = new ChosenRequest(req, token, key);\n\t\t\t}\n\t\t\tif(key != null)\n\t\t\t\tkeysFetching.add(key);\n\t\t\treturn ret;\n\t\t}\n\t}","commit_id":"4abce5a2a55cf0c79d7870ba0466b30c229b771c","url":"https://github.com/freenet/fred"},{"original_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\t\tSingleFileInserter oldSFI;\n\t\t\tClientPutState oldState;\n\t\t\tsynchronized(this) {\n\t\t\t\toldSFI = origSFI;\n\t\t\t\toldState = currentState;\n\t\t\t\toldSFI = null;\n\t\t\t\tcurrentState = null;\n\t\t\t}\n\t\t\tif(oldSFI != null) {\n\t\t\t\tLogger.error(this, \"origSFI is set in removeFrom() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\toldSFI.cancel(container, context);\n\t\t\t\toldSFI.removeFrom(container, context);\n\t\t\t\tif(oldState == oldSFI) oldState = null;\n\t\t\t}\n\t\t\tif(oldState != null) {\n\t\t\t\tLogger.error(this, \"currentState is set in removeFrom() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\toldState.cancel(container, context);\n\t\t\t\toldState.removeFrom(container, context);\n\t\t\t}\n\t\t\tif(cm != null) {\n\t\t\t\tcm.removeFrom(container);\n\t\t\t}\n\t\t\tif(metadata != null) {\n\t\t\t\t// Possible if cancelled\n\t\t\t\tLogger.error(this, \"Metadata is set in removeFrom() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\tmetadata.removeFrom(container);\n\t\t\t}\n\t\t\t// Data is responsibility of original caller (usually ClientPutDir), we don't support freeData atm\n\t\t\tsuper.removeFrom(container, context);\n\t\t}","id":30535,"modified_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\t\tSingleFileInserter oldSFI;\n\t\t\tClientPutState oldState;\n\t\t\tsynchronized(this) {\n\t\t\t\toldSFI = origSFI;\n\t\t\t\toldState = currentState;\n\t\t\t\toldSFI = null;\n\t\t\t\tcurrentState = null;\n\t\t\t}\n\t\t\tif(oldSFI != null) {\n\t\t\t\tLogger.error(this, \"origSFI is set in removeFrom() on \"+this+\" for \"+SimpleManifestPutter.this, new Exception(\"debug\"));\n\t\t\t\toldSFI.cancel(container, context);\n\t\t\t\toldSFI.removeFrom(container, context);\n\t\t\t\tif(oldState == oldSFI) oldState = null;\n\t\t\t}\n\t\t\tif(oldState != null) {\n\t\t\t\tLogger.error(this, \"currentState is set in removeFrom() on \"+this+\" for \"+SimpleManifestPutter.this, new Exception(\"debug\"));\n\t\t\t\toldState.cancel(container, context);\n\t\t\t\toldState.removeFrom(container, context);\n\t\t\t}\n\t\t\tif(cm != null) {\n\t\t\t\tcm.removeFrom(container);\n\t\t\t}\n\t\t\tif(metadata != null) {\n\t\t\t\t// Possible if cancelled\n\t\t\t\tLogger.error(this, \"Metadata is set in removeFrom() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\tmetadata.removeFrom(container);\n\t\t\t}\n\t\t\t// Data is responsibility of original caller (usually ClientPutDir), we don't support freeData atm\n\t\t\tsuper.removeFrom(container, context);\n\t\t}","commit_id":"514b468396f4dae84760732ed66d8bd5ca533c08","url":"https://github.com/freenet/fred"},{"original_method":"private void fail(InsertException e, ObjectContainer container, ClientContext context) {\n\t\t// Cancel all, then call the callback\n\t\tcancelAndFinish(container);\n\t\tif(persistent()) removePutHandlers(container, context);\n\t\t\n\t\tif(persistent())\n\t\t\tcontainer.activate(cb, 1);\n\t\tcb.onFailure(e, this, container);\n\t}","id":30536,"modified_method":"private void fail(InsertException e, ObjectContainer container, ClientContext context) {\n\t\t// Cancel all, then call the callback\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tfinished = true;\n\t\t}\n\t\tcancelAndFinish(container, context);\n\t\tif(persistent()) removePutHandlers(container, context);\n\t\t\n\t\tif(persistent())\n\t\t\tcontainer.activate(cb, 1);\n\t\tcb.onFailure(e, this, container);\n\t}","commit_id":"514b468396f4dae84760732ed66d8bd5ca533c08","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Cancel all running inserters and set finished to true.\n\t */\n\tprivate void cancelAndFinish(ObjectContainer container) {\n\t\tPutHandler[] running;\n\t\tif(persistent())\n\t\t\tcontainer.activate(runningPutHandlers, 2);\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\trunning = (PutHandler[]) runningPutHandlers.toArray(new PutHandler[runningPutHandlers.size()]);\n\t\t\tfinished = true;\n\t\t}\n\t\tif(persistent())\n\t\t\tcontainer.store(this);\n\t\t\n\t\tfor(int i=0;i<running.length;i++) {\n\t\t\trunning[i].cancel();\n\t\t}\n\t}","id":30537,"modified_method":"/**\n\t * Cancel all running inserters and set finished to true.\n\t */\n\tprivate void cancelAndFinish(ObjectContainer container, ClientContext context) {\n\t\tPutHandler[] running;\n\t\tboolean persistent = persistent();\n\t\tif(persistent)\n\t\t\tcontainer.activate(runningPutHandlers, 2);\n\t\tsynchronized(this) {\n\t\t\trunning = (PutHandler[]) runningPutHandlers.toArray(new PutHandler[runningPutHandlers.size()]);\n\t\t}\n\t\tif(persistent())\n\t\t\tcontainer.store(this);\n\t\t\n\t\tfor(int i=0;i<running.length;i++) {\n\t\t\tif(persistent) container.activate(running[i], 1);\n\t\t\trunning[i].cancel(container, context);\n\t\t\tif(persistent) container.activate(this, 1);\n\t\t}\n\t}","commit_id":"514b468396f4dae84760732ed66d8bd5ca533c08","url":"https://github.com/freenet/fred"},{"original_method":"public void start(ObjectContainer container, ClientContext context) throws InsertException {\n\t\tif (logMINOR)\n\t\t\tLogger.minor(this, \"Starting \" + this+\" persistence=\"+persistent());\n\t\tPutHandler[] running;\n\n\t\tif(persistent()) {\n\t\t\tcontainer.activate(runningPutHandlers, 2);\n\t\t}\n\t\tsynchronized (this) {\n\t\t\trunning = (PutHandler[]) runningPutHandlers.toArray(new PutHandler[runningPutHandlers.size()]);\n\t\t}\n\t\ttry {\n\t\t\tboolean persistent = persistent(); // this might get deactivated ...\n\t\t\tfor (int i = 0; i < running.length; i++) {\n\t\t\t\trunning[i].start(container, context);\n\t\t\t\tif(persistent && !container.ext().isActive(this))\n\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\tif (logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Started \" + i + \" of \" + running.length);\n\t\t\t\tif (isFinished()) {\n\t\t\t\t\tif (logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Already finished, killing start() on \" + this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logMINOR)\n\t\t\t\tLogger.minor(this, \"Started \" + running.length + \" PutHandler's for \" + this);\n\t\t\tif (running.length == 0) {\n\t\t\t\tinsertedAllFiles = true;\n\t\t\t\tif(persistent())\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\tgotAllMetadata(container, context);\n\t\t\t}\n\t\t} catch (InsertException e) {\n\t\t\tcancelAndFinish(container);\n\t\t\tthrow e;\n\t\t}\n\t}","id":30538,"modified_method":"public void start(ObjectContainer container, ClientContext context) throws InsertException {\n\t\tif (logMINOR)\n\t\t\tLogger.minor(this, \"Starting \" + this+\" persistence=\"+persistent());\n\t\tPutHandler[] running;\n\n\t\tif(persistent()) {\n\t\t\tcontainer.activate(runningPutHandlers, 2);\n\t\t}\n\t\tsynchronized (this) {\n\t\t\trunning = (PutHandler[]) runningPutHandlers.toArray(new PutHandler[runningPutHandlers.size()]);\n\t\t}\n\t\ttry {\n\t\t\tboolean persistent = persistent(); // this might get deactivated ...\n\t\t\tfor (int i = 0; i < running.length; i++) {\n\t\t\t\trunning[i].start(container, context);\n\t\t\t\tif(persistent && !container.ext().isActive(this))\n\t\t\t\t\tcontainer.activate(this, 1);\n\t\t\t\tif (logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Started \" + i + \" of \" + running.length);\n\t\t\t\tif (isFinished()) {\n\t\t\t\t\tif (logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Already finished, killing start() on \" + this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logMINOR)\n\t\t\t\tLogger.minor(this, \"Started \" + running.length + \" PutHandler's for \" + this);\n\t\t\tif (running.length == 0) {\n\t\t\t\tinsertedAllFiles = true;\n\t\t\t\tif(persistent())\n\t\t\t\t\tcontainer.store(this);\n\t\t\t\tgotAllMetadata(container, context);\n\t\t\t}\n\t\t} catch (InsertException e) {\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t}\n\t\t\tcancelAndFinish(container, context);\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"514b468396f4dae84760732ed66d8bd5ca533c08","url":"https://github.com/freenet/fred"},{"original_method":"public void cancel(ObjectContainer container, ClientContext context) {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Cancelling \"+this, new Exception(\"debug\"));\n\t\t\tClientPutState oldState = null;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(cancelled) return;\n\t\t\t\tif(finished) return;\n\t\t\t\tsuper.cancel();\n\t\t\t\toldState = currentState;\n\t\t\t}\n\t\t\tif(persistent()) {\n\t\t\t\tcontainer.store(this);\n\t\t\t\tif(oldState != null)\n\t\t\t\t\tcontainer.activate(oldState, 1);\n\t\t\t}\n\t\t\tif(oldState != null) oldState.cancel(container, context);\n\t\t\tonFailure(new InsertException(InsertException.CANCELLED), null, container, context);\n\t\t}","id":30539,"modified_method":"public void cancel(ObjectContainer container, ClientContext context) {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Cancelling \"+this, new Exception(\"debug\"));\n\t\t\tClientPutState oldState = null;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(cancelled) return;\n\t\t\t\tsuper.cancel();\n\t\t\t\toldState = currentState;\n\t\t\t}\n\t\t\tif(persistent()) {\n\t\t\t\tcontainer.store(this);\n\t\t\t\tif(oldState != null)\n\t\t\t\t\tcontainer.activate(oldState, 1);\n\t\t\t}\n\t\t\tif(oldState != null) oldState.cancel(container, context);\n\t\t\tonFailure(new InsertException(InsertException.CANCELLED), null, container, context);\n\t\t}","commit_id":"514b468396f4dae84760732ed66d8bd5ca533c08","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(ClientPutState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Completed \"+this);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.activate(SimpleManifestPutter.this, 1);\n\t\t\t\tcontainer.activate(runningPutHandlers, 2);\n\t\t\t}\n\t\t\tSimpleManifestPutter.this.onFetchable(this, container);\n\t\t\tClientPutState oldState;\n\t\t\tboolean insertedAllFiles = true;\n\t\t\tsynchronized(this) {\n\t\t\t\toldState = currentState;\n\t\t\t\tcurrentState = null;\n\t\t\t}\n\t\t\tsynchronized(SimpleManifestPutter.this) {\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\trunningPutHandlers.remove(this);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.ext().store(runningPutHandlers, 2);\n\t\t\t\t\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(putHandlersWaitingForMetadata, 2);\n\t\t\t\tif(putHandlersWaitingForMetadata.contains(this)) {\n\t\t\t\t\tputHandlersWaitingForMetadata.remove(this);\n\t\t\t\t\tcontainer.ext().store(putHandlersWaitingForMetadata, 2);\n\t\t\t\t\tLogger.error(this, \"PutHandler was in waitingForMetadata in onSuccess() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(putHandlersWaitingForMetadata, 1);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(waitingForBlockSets, 2);\n\t\t\t\tif(waitingForBlockSets.contains(this)) {\n\t\t\t\t\twaitingForBlockSets.remove(this);\n\t\t\t\t\tcontainer.store(waitingForBlockSets);\n\t\t\t\t\tLogger.error(this, \"PutHandler was in waitingForBlockSets in onSuccess() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(waitingForBlockSets, 1);\n\t\t\t\t\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(putHandlersWaitingForFetchable, 1);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(putHandlersWaitingForFetchable, 2);\n\t\t\t\tif(putHandlersWaitingForFetchable.contains(this)) {\n\t\t\t\t\tputHandlersWaitingForFetchable.remove(this);\n\t\t\t\t\tcontainer.store(putHandlersWaitingForFetchable);\n\t\t\t\t\t// Not getting an onFetchable is not unusual, just ignore it.\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"PutHandler was in waitingForFetchable in onSuccess() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(putHandlersWaitingForFetchable, 1);\n\t\t\t\t\n\t\t\t\tif(!runningPutHandlers.isEmpty()) {\n\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"Running put handlers: \"+runningPutHandlers.size());\n\t\t\t\t\t\tfor(Object o : runningPutHandlers) {\n\t\t\t\t\t\t\tboolean activated = true;\n\t\t\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\t\t\tactivated = container.ext().isActive(o);\n\t\t\t\t\t\t\t\tif(!activated) container.activate(o, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLogger.minor(this, \"Still running: \"+o);\n\t\t\t\t\t\t\tif(!activated)\n\t\t\t\t\t\t\t\tcontainer.deactivate(o, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinsertedAllFiles = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(oldState != null && oldState != state && persistent) {\n\t\t\t\tcontainer.activate(oldState, 1);\n\t\t\t\toldState.removeFrom(container, context);\n\t\t\t} else if(state != null && persistent) {\n\t\t\t\tstate.removeFrom(container, context);\n\t\t\t}\n\t\t\tif(insertedAllFiles)\n\t\t\t\tinsertedAllFiles(container, context);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(runningPutHandlers, 1);\n\t\t\t\tcontainer.deactivate(SimpleManifestPutter.this, 1);\n\t\t\t}\n\t\t}","id":30540,"modified_method":"public void onSuccess(ClientPutState state, ObjectContainer container, ClientContext context) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Completed \"+this);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.activate(SimpleManifestPutter.this, 1);\n\t\t\t\tcontainer.activate(runningPutHandlers, 2);\n\t\t\t}\n\t\t\tSimpleManifestPutter.this.onFetchable(this, container);\n\t\t\tClientPutState oldState;\n\t\t\tboolean insertedAllFiles = true;\n\t\t\tsynchronized(this) {\n\t\t\t\toldState = currentState;\n\t\t\t\tcurrentState = null;\n\t\t\t}\n\t\t\tsynchronized(SimpleManifestPutter.this) {\n\t\t\t\tif(persistent) container.store(this);\n\t\t\t\trunningPutHandlers.remove(this);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.ext().store(runningPutHandlers, 2);\n\t\t\t\t\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(putHandlersWaitingForMetadata, 2);\n\t\t\t\tif(putHandlersWaitingForMetadata.contains(this)) {\n\t\t\t\t\tputHandlersWaitingForMetadata.remove(this);\n\t\t\t\t\tcontainer.ext().store(putHandlersWaitingForMetadata, 2);\n\t\t\t\t\tLogger.error(this, \"PutHandler was in waitingForMetadata in onSuccess() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(putHandlersWaitingForMetadata, 1);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(waitingForBlockSets, 2);\n\t\t\t\tif(waitingForBlockSets.contains(this)) {\n\t\t\t\t\twaitingForBlockSets.remove(this);\n\t\t\t\t\tcontainer.store(waitingForBlockSets);\n\t\t\t\t\tLogger.error(this, \"PutHandler was in waitingForBlockSets in onSuccess() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(waitingForBlockSets, 1);\n\t\t\t\t\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(putHandlersWaitingForFetchable, 1);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(putHandlersWaitingForFetchable, 2);\n\t\t\t\tif(putHandlersWaitingForFetchable.contains(this)) {\n\t\t\t\t\tputHandlersWaitingForFetchable.remove(this);\n\t\t\t\t\tcontainer.ext().store(putHandlersWaitingForFetchable, 2);\n\t\t\t\t\t// Not getting an onFetchable is not unusual, just ignore it.\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"PutHandler was in waitingForFetchable in onSuccess() on \"+this+\" for \"+SimpleManifestPutter.this);\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(putHandlersWaitingForFetchable, 1);\n\t\t\t\t\n\t\t\t\tif(!runningPutHandlers.isEmpty()) {\n\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"Running put handlers: \"+runningPutHandlers.size());\n\t\t\t\t\t\tfor(Object o : runningPutHandlers) {\n\t\t\t\t\t\t\tboolean activated = true;\n\t\t\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\t\t\tactivated = container.ext().isActive(o);\n\t\t\t\t\t\t\t\tif(!activated) container.activate(o, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLogger.minor(this, \"Still running: \"+o);\n\t\t\t\t\t\t\tif(!activated)\n\t\t\t\t\t\t\t\tcontainer.deactivate(o, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinsertedAllFiles = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(oldState != null && oldState != state && persistent) {\n\t\t\t\tcontainer.activate(oldState, 1);\n\t\t\t\toldState.removeFrom(container, context);\n\t\t\t} else if(state != null && persistent) {\n\t\t\t\tstate.removeFrom(container, context);\n\t\t\t}\n\t\t\tif(insertedAllFiles)\n\t\t\t\tinsertedAllFiles(container, context);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(runningPutHandlers, 1);\n\t\t\t\tcontainer.deactivate(SimpleManifestPutter.this, 1);\n\t\t\t}\n\t\t}","commit_id":"514b468396f4dae84760732ed66d8bd5ca533c08","url":"https://github.com/freenet/fred"},{"original_method":"public void register(final SendableRequest req, boolean onDatabaseThread) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Registering \"+req, new Exception(\"debug\"));\n\t\tif(isInsertScheduler != (req instanceof SendableInsert))\n\t\t\tthrow new IllegalArgumentException(\"Expected a SendableInsert: \"+req);\n\t\tif(req instanceof SendableGet) {\n\t\t\tSendableGet getter = (SendableGet)req;\n\t\t\tif(!getter.ignoreStore()) {\n\t\t\t\tboolean anyValid = false;\n\t\t\t\tObject[] keyTokens = getter.sendableKeys();\n\t\t\t\tfor(int i=0;i<keyTokens.length;i++) {\n\t\t\t\t\tObject tok = keyTokens[i];\n\t\t\t\t\tClientKeyBlock block = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientKey key = getter.getKey(tok);\n\t\t\t\t\t\tif(key == null) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"No key for \"+tok+\" for \"+getter+\" - already finished?\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(getter.getContext().blocks != null)\n\t\t\t\t\t\t\t\tblock = getter.getContext().blocks.get(key);\n\t\t\t\t\t\t\tif(block == null)\n\t\t\t\t\t\t\t\tblock = node.fetchKey(key, getter.dontCache());\n\t\t\t\t\t\t\tif(block == null) {\n\t\t\t\t\t\t\t\taddPendingKey(key, getter);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Got \"+block);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e) {\n\t\t\t\t\t\t// Verify exception, probably bogus at source;\n\t\t\t\t\t\t// verifies at low-level, but not at decode.\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decode failed: \"+e, e);\n\t\t\t\t\t\tgetter.onFailure(new LowLevelGetException(LowLevelGetException.DECODE_FAILED), tok, this);\n\t\t\t\t\t\tcontinue; // other keys might be valid\n\t\t\t\t\t}\n\t\t\t\t\tif(block != null) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Can fulfill \"+req+\" (\"+tok+\") immediately from store\");\n\t\t\t\t\t\tgetter.onSuccess(block, true, tok, this);\n\t\t\t\t\t\t// Even with working thread priorities, we still get very high latency accessing\n\t\t\t\t\t\t// the datastore when background threads are doing it in parallel.\n\t\t\t\t\t\t// So yield() here, unless priority is very high.\n\t\t\t\t\t\tif(req.getPriorityClass() > RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS)\n\t\t\t\t\t\t\tThread.yield();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanyValid = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!anyValid) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No valid keys, returning without registering for \"+req);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(req.persistent()) {\n\t\t\t// Add to the persistent registration queue\n\t\t\tif(onDatabaseThread) {\n\t\t\t\tif(!databaseExecutor.onThread()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not on database thread!\");\n\t\t\t\t}\n\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t} else {\n\t\t\t\tdatabaseExecutor.execute(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t\t\t}\n\t\t\t\t}, NativeThread.NORM_PRIORITY, \"Add persistent job to queue\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Register immediately.\n\t\t\tschedTransient.innerRegister(req, random);\n\t\t\tstarter.wakeUp();\n\t\t}\n\t}","id":30541,"modified_method":"public void register(final SendableRequest req, boolean onDatabaseThread) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Registering \"+req, new Exception(\"debug\"));\n\t\tboolean persistent = req.persistent();\n\t\tVector pending = null;\n\t\tif(isInsertScheduler != (req instanceof SendableInsert))\n\t\t\tthrow new IllegalArgumentException(\"Expected a SendableInsert: \"+req);\n\t\tif(req instanceof SendableGet) {\n\t\t\tSendableGet getter = (SendableGet)req;\n\t\t\tif(!getter.ignoreStore()) {\n\t\t\t\tboolean anyValid = false;\n\t\t\t\tObject[] keyTokens = getter.sendableKeys();\n\t\t\t\tfor(int i=0;i<keyTokens.length;i++) {\n\t\t\t\t\tObject tok = keyTokens[i];\n\t\t\t\t\tClientKeyBlock block = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClientKey key = getter.getKey(tok);\n\t\t\t\t\t\tif(key == null) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"No key for \"+tok+\" for \"+getter+\" - already finished?\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(getter.getContext().blocks != null)\n\t\t\t\t\t\t\t\tblock = getter.getContext().blocks.get(key);\n\t\t\t\t\t\t\tif(block == null)\n\t\t\t\t\t\t\t\tblock = node.fetchKey(key, getter.dontCache());\n\t\t\t\t\t\t\tif(block == null) {\n\t\t\t\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\t\t\t\tif(pending == null)\n\t\t\t\t\t\t\t\t\t\tpending = new Vector(keyTokens.length - i);\n\t\t\t\t\t\t\t\t\tpending.add(key);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tschedTransient.addPendingKey(key, getter);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Got \"+block);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (KeyVerifyException e) {\n\t\t\t\t\t\t// Verify exception, probably bogus at source;\n\t\t\t\t\t\t// verifies at low-level, but not at decode.\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Decode failed: \"+e, e);\n\t\t\t\t\t\tgetter.onFailure(new LowLevelGetException(LowLevelGetException.DECODE_FAILED), tok, this);\n\t\t\t\t\t\tcontinue; // other keys might be valid\n\t\t\t\t\t}\n\t\t\t\t\tif(block != null) {\n\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Can fulfill \"+req+\" (\"+tok+\") immediately from store\");\n\t\t\t\t\t\tgetter.onSuccess(block, true, tok, this);\n\t\t\t\t\t\t// Even with working thread priorities, we still get very high latency accessing\n\t\t\t\t\t\t// the datastore when background threads are doing it in parallel.\n\t\t\t\t\t\t// So yield() here, unless priority is very high.\n\t\t\t\t\t\tif(req.getPriorityClass() > RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS)\n\t\t\t\t\t\t\tThread.yield();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanyValid = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!anyValid) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"No valid keys, returning without registering for \"+req);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent) {\n\t\t\t// Add to the persistent registration queue\n\t\t\tif(onDatabaseThread) {\n\t\t\t\tif(!databaseExecutor.onThread()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not on database thread!\");\n\t\t\t\t}\n\t\t\t\tif(pending != null)\n\t\t\t\t\tschedCore.addPendingKeys(pending, (SendableGet) req);\n\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t} else {\n\t\t\t\tfinal Vector pendingKeys = pending;\n\t\t\t\tif(pending != null)\n\t\t\t\t\tpending.setSize(pending.size());\n\t\t\t\tdatabaseExecutor.execute(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tif(pendingKeys != null)\n\t\t\t\t\t\t\tschedCore.addPendingKeys(pendingKeys, (SendableGet) req);\n\t\t\t\t\t\tschedCore.queueRegister(req, databaseExecutor);\n\t\t\t\t\t}\n\t\t\t\t}, NativeThread.NORM_PRIORITY, \"Add persistent job to queue\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Register immediately.\n\t\t\tschedTransient.innerRegister(req, random);\n\t\t\tstarter.wakeUp();\n\t\t}\n\t}","commit_id":"bec69df452021e771c50f35d94ac98da556bbe4b","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void onResume(ClientContext context) throws ResumeFailedException {\n        super.onResume(context);\n        if(logMINOR) Logger.minor(this, \"Resuming \"+this, new Exception(\"debug\"));\n        tracker = context.persistentFileTracker;\n        tracker.register(getFile());\n    }","id":30542,"modified_method":"@Override\n    protected void innerResume(ClientContext context) throws ResumeFailedException {\n        super.innerResume(context);\n        if(logMINOR) Logger.minor(this, \"Resuming \"+this, new Exception(\"debug\"));\n        tracker = context.persistentFileTracker;\n        tracker.register(getFile());\n    }","commit_id":"29a1c34ab682cf3d2bb05d91cea7952d449a3616","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void onResume(ClientContext context) throws ResumeFailedException {\n        if(persistent()) {\n            generator = context.persistentFG;\n            if(file == null) {\n                // Migrating from old tempfile, possibly db4o era.\n                file = generator.getFilename(filenameID);\n                checkExists(file);\n            } else {\n                // File must exist!\n                if(!file.exists()) {\n                    // Maybe moved after the last checkpoint?\n                    File f = generator.getFilename(filenameID);\n                    if(f.exists()) {\n                        file = f;\n                    }\n                }\n                checkExists(file);\n                file = generator.maybeMove(file, filenameID);\n            }\n        } else {\n            // Plain TempFileBucket's are not persistent.\n            throw new UnsupportedOperationException();\n        }\n        super.onResume(context);\n    }","id":30543,"modified_method":"@Override\n    public final void onResume(ClientContext context) throws ResumeFailedException {\n        if(!persistent()) throw new UnsupportedOperationException();\n        synchronized(this) {\n            if(resumed) return;\n            resumed = true;\n        }\n        super.onResume(context);\n        innerResume(context);\n    }","commit_id":"29a1c34ab682cf3d2bb05d91cea7952d449a3616","url":"https://github.com/freenet/fred"},{"original_method":"SendableRequest removeFirstInner(int fuzz, RandomSource random, OfferedKeysList offeredKeys, RequestStarter starter, ClientRequestSchedulerCore schedCore, ClientRequestSchedulerNonPersistent schedTransient, boolean transientOnly, boolean notTransient, short maxPrio, int retryCount, ClientContext context, ObjectContainer container, long now) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tif(schedCore == null) transientOnly = true;\n\t\tif(transientOnly && notTransient) {\n\t\t\tLogger.error(this, \"Not transient but no core\");\n\t\t\treturn null;\n\t\t}\n\t\tboolean tryOfferedKeys = offeredKeys != null && (!notTransient) && random.nextBoolean();\n\t\tif(tryOfferedKeys) {\n\t\t\tif(offeredKeys.hasValidKeys(this, null, context))\n\t\t\t\treturn offeredKeys;\n\t\t}\n\t\tint choosenPriorityClass = removeFirstAccordingToPriorities(fuzz, random, schedCore, schedTransient, transientOnly, maxPrio, container);\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif((!notTransient) && !tryOfferedKeys) {\n\t\t\t\tif(offeredKeys != null && offeredKeys.hasValidKeys(this, null, context))\n\t\t\t\t\treturn offeredKeys;\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tif(maxPrio >= RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\tmaxPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\nouter:\tfor(;choosenPriorityClass <= maxPrio;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tSectoredRandomGrabArray perm = null;\n\t\t\tif(!transientOnly)\n\t\t\t\tperm = schedCore.newPriorities[choosenPriorityClass];\n\t\t\tSectoredRandomGrabArray trans = null;\n\t\t\tif(!notTransient)\n\t\t\t\ttrans = schedTransient.newPriorities[choosenPriorityClass];\n\t\t\tif(perm == null && trans == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\tboolean triedPerm = false;\n\t\t\tboolean triedTrans = false;\n\t\t\twhile(true) {\n\t\t\t\tSectoredRandomGrabArray chosenTracker = null;\n\t\t\t\t// If we can't find anything on perm (on the previous loop), try trans, and vice versa\n\t\t\t\tif(triedTrans) trans = null;\n\t\t\t\tif(triedPerm) perm = null;\n\t\t\t\tif(perm == null && trans == null) continue outer;\n\t\t\t\telse if(perm == null && trans != null) {\n\t\t\t\t\tchosenTracker = trans;\n\t\t\t\t\ttriedTrans = true;\n\t\t\t\t\tlong cooldownTime = context.cooldownTracker.getCachedWakeup(trans, false, container, now);\n\t\t\t\t\tif(cooldownTime > 0) {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" (transient) is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} else if(perm != null && trans == null) {\n\t\t\t\t\tchosenTracker = perm;\n\t\t\t\t\ttriedPerm = true;\n\t\t\t\t\tlong cooldownTime = context.cooldownTracker.getCachedWakeup(perm, true, container, now);\n\t\t\t\t\tif(cooldownTime > 0) {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" (persistent) is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t\tcontainer.activate(perm, 1);\n\t\t\t\t} else {\n\t\t\t\t\tcontainer.activate(perm, 1);\n\t\t\t\t\tint permSize = perm.size();\n\t\t\t\t\tint transSize = trans.size();\n\t\t\t\t\tboolean choosePerm = random.nextInt(permSize + transSize) > permSize;\n\t\t\t\t\tif(choosePerm) {\n\t\t\t\t\t\tchosenTracker = perm;\n\t\t\t\t\t\ttriedPerm = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchosenTracker = trans;\n\t\t\t\t\t\ttriedTrans = true;\n\t\t\t\t\t}\n\t\t\t\t\tlong cooldownTime = context.cooldownTracker.getCachedWakeup(trans, choosePerm, container, now);\n\t\t\t\t\tif(cooldownTime > 0) {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" (perm=\"+choosePerm+\") is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got priority tracker \"+chosenTracker);\n\t\t\t\tRemoveRandomReturn val = chosenTracker.removeRandom(starter, container, context, now);\n\t\t\t\tSendableRequest req;\n\t\t\t\tif(val == null) {\n\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned null - nothing to schedule, should remove priority\");\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(val.item == null) {\n\t\t\t\t\tif(val.wakeupTime == -1)\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of -1 - nothing to schedule, should remove priority\");\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of \"+(val.wakeupTime - now)+\" = \"+TimeUtil.formatTime(val.wakeupTime - now));\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treq = (SendableRequest) val.item;\n\t\t\t\t}\n\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\tcontainer.activate(req, 1); // FIXME\n\t\t\t\tif(req.persistent() != chosenTracker.persistent()) {\n\t\t\t\t\tLogger.error(this, \"Request.persistent()=\"+req.persistent()+\" but is in the queue for persistent=\"+chosenTracker.persistent()+\" for \"+req);\n\t\t\t\t\t// FIXME fix it\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass(container) != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass(container)+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tSectoredRandomGrabArrayWithObject clientGrabber = (SectoredRandomGrabArrayWithObject) chosenTracker.getGrabber(req.getClient(container));\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\t\tcontainer.activate(clientGrabber, 1);\n\t\t\t\t\t\tRandomGrabArray baseRGA = (RandomGrabArray) clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\t\t\tcontainer.activate(baseRGA, 1);\n\t\t\t\t\t\t\tbaseRGA.remove(req, container, context);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient(container)+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tif(req.persistent())\n\t\t\t\t\t\tschedCore.innerRegister(req, random, container, context, null);\n\t\t\t\t\telse\n\t\t\t\t\t\tschedTransient.innerRegister(req, random, container, context, null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * For transient requests, we keep a list of recently succeeded BaseSendableGet's,\n\t\t\t\t * because transient requests are chosen individually.\n\t\t\t\t * But for persistent requests, we keep a list of RandomGrabArray's, because\n\t\t\t\t * persistent requests are chosen a whole SendableRequest at a time.\n\t\t\t\t * \n\t\t\t\t * FIXME: Only replaces persistent requests with persistent requests (of similar priority and retry count), or transient with transient.\n\t\t\t\t * Probably this is acceptable.\n\t\t\t\t */\n\t\t\t\tif(!req.persistent() && !isInsertScheduler) {\n\t\t\t\t\tList<BaseSendableGet> recent = schedTransient.recentSuccesses;\n\t\t\t\t\tBaseSendableGet altReq = null;\n\t\t\t\t\tsynchronized(recent) {\n\t\t\t\t\t\tif(!recent.isEmpty()) {\n\t\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\t\taltReq = recent.remove(recent.size()-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled(container))) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tlong l;\n\t\t\t\t\tif(altReq != null && (l = altReq.getCooldownTime(container, context, now)) != 0) {\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring recently succeeded item, cooldown time = \"+l+((l > 0) ? \" (\"+TimeUtil.formatTime(l - now)+\")\" : \"\"));\n\t\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (altReq != null && altReq != req) {\n\t\t\t\t\t\tint prio = altReq.getPriorityClass(container);\n\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\t\tsynchronized(recent) {\n\t\t\t\t\t\t\t\trecent.add(altReq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(!isInsertScheduler) {\n\t\t\t\t\tRandomGrabArray altRGA = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!(recentSuccesses.isEmpty() || random.nextBoolean())) {\n\t\t\t\t\t\t\taltRGA = recentSuccesses.remove(recentSuccesses.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altRGA != null) {\n\t\t\t\t\t\tcontainer.activate(altRGA, 1);\n\t\t\t\t\t\tSendableRequest altReq = null;\n\t\t\t\t\t\tif(container.ext().isStored(altRGA) && !altRGA.isEmpty()) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Maybe using recently succeeded item from \"+altRGA);\n\t\t\t\t\t\t\tval = altRGA.removeRandom(starter, container, context, now);\n\t\t\t\t\t\t\tif(val != null) {\n\t\t\t\t\t\t\t\tif(val.item == null) {\n\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Ignoring recently succeeded item, removeRandom returned cooldown time \"+val.wakeupTime+((val.wakeupTime > 0) ? \" (\"+TimeUtil.formatTime(val.wakeupTime - now)+\")\" : \"\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taltReq = (SendableRequest) val.item;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(altReq != null && altReq != req) {\n\t\t\t\t\t\t\t\tcontainer.activate(altReq, 1);\n\t\t\t\t\t\t\t\tint prio = altReq.getPriorityClass(container);\n\t\t\t\t\t\t\t\tboolean useRecent = false;\n\t\t\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t\t\tif(altReq.getCooldownTime(container, context, now) != 0)\n\t\t\t\t\t\t\t\t\t\tuseRecent = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(useRecent) {\n\t\t\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (persistent) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen (persistent) req \"+req+\" is better, reregistering recently succeeded \"+altRGA+\" for \"+altReq);\n\t\t\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\t\t\trecentSuccesses.add(altRGA);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontainer.deactivate(altRGA, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (prio \"+\n\t\t\t\t\t\treq.getPriorityClass(container)+\", retries \"+req.getRetryCount()+\", client \"+req.getClient(container)+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\treturn req;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","id":30544,"modified_method":"SendableRequest removeFirstInner(int fuzz, RandomSource random, OfferedKeysList offeredKeys, RequestStarter starter, ClientRequestSchedulerCore schedCore, ClientRequestSchedulerNonPersistent schedTransient, boolean transientOnly, boolean notTransient, short maxPrio, int retryCount, ClientContext context, ObjectContainer container, long now) {\n\t\t// Priorities start at 0\n\t\tif(logMINOR) Logger.minor(this, \"removeFirst()\");\n\t\tif(schedCore == null) transientOnly = true;\n\t\tif(transientOnly && notTransient) {\n\t\t\tLogger.error(this, \"Not transient but no core\");\n\t\t\treturn null;\n\t\t}\n\t\tboolean tryOfferedKeys = offeredKeys != null && (!notTransient) && random.nextBoolean();\n\t\tif(tryOfferedKeys) {\n\t\t\tif(offeredKeys.hasValidKeys(this, null, context))\n\t\t\t\treturn offeredKeys;\n\t\t}\n\t\tint choosenPriorityClass = removeFirstAccordingToPriorities(fuzz, random, schedCore, schedTransient, transientOnly, maxPrio, container);\n\t\tif(choosenPriorityClass == -1) {\n\t\t\tif((!notTransient) && !tryOfferedKeys) {\n\t\t\t\tif(offeredKeys != null && offeredKeys.hasValidKeys(this, null, context))\n\t\t\t\t\treturn offeredKeys;\n\t\t\t}\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Nothing to do\");\n\t\t\treturn null;\n\t\t}\n\t\tif(maxPrio >= RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\tmaxPrio = RequestStarter.MINIMUM_PRIORITY_CLASS;\nouter:\tfor(;choosenPriorityClass <= maxPrio;choosenPriorityClass++) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Using priority \"+choosenPriorityClass);\n\t\t\tSectoredRandomGrabArray perm = null;\n\t\t\tif(!transientOnly)\n\t\t\t\tperm = schedCore.newPriorities[choosenPriorityClass];\n\t\t\tSectoredRandomGrabArray trans = null;\n\t\t\tif(!notTransient)\n\t\t\t\ttrans = schedTransient.newPriorities[choosenPriorityClass];\n\t\t\tif(perm == null && trans == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No requests to run: chosen priority empty\");\n\t\t\t\tcontinue; // Try next priority\n\t\t\t}\n\t\t\tboolean triedPerm = false;\n\t\t\tboolean triedTrans = false;\n\t\t\twhile(true) {\n\t\t\t\tboolean persistent;\n\t\t\t\tSectoredRandomGrabArray chosenTracker = null;\n\t\t\t\t// If we can't find anything on perm (on the previous loop), try trans, and vice versa\n\t\t\t\tif(triedTrans) trans = null;\n\t\t\t\tif(triedPerm) perm = null;\n\t\t\t\tif(perm == null && trans == null) continue outer;\n\t\t\t\telse if(perm == null && trans != null) {\n\t\t\t\t\tchosenTracker = trans;\n\t\t\t\t\ttriedTrans = true;\n\t\t\t\t\tlong cooldownTime = context.cooldownTracker.getCachedWakeup(trans, false, container, now);\n\t\t\t\t\tif(cooldownTime > 0) {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" (transient) is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t\tpersistent = false;\n\t\t\t\t} else if(perm != null && trans == null) {\n\t\t\t\t\tchosenTracker = perm;\n\t\t\t\t\ttriedPerm = true;\n\t\t\t\t\tlong cooldownTime = context.cooldownTracker.getCachedWakeup(perm, true, container, now);\n\t\t\t\t\tif(cooldownTime > 0) {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" (persistent) is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t\tcontainer.activate(perm, 1);\n\t\t\t\t\tpersistent = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontainer.activate(perm, 1);\n\t\t\t\t\tint permSize = perm.size();\n\t\t\t\t\tint transSize = trans.size();\n\t\t\t\t\tboolean choosePerm = random.nextInt(permSize + transSize) > permSize;\n\t\t\t\t\tif(choosePerm) {\n\t\t\t\t\t\tchosenTracker = perm;\n\t\t\t\t\t\ttriedPerm = true;\n\t\t\t\t\t\tpersistent = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchosenTracker = trans;\n\t\t\t\t\t\ttriedTrans = true;\n\t\t\t\t\t\tpersistent = false;\n\t\t\t\t\t}\n\t\t\t\t\tlong cooldownTime = context.cooldownTracker.getCachedWakeup(trans, choosePerm, container, now);\n\t\t\t\t\tif(cooldownTime > 0) {\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" (perm=\"+choosePerm+\") is in cooldown for another \"+(cooldownTime - now)+\" \"+TimeUtil.formatTime(cooldownTime - now));\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Got priority tracker \"+chosenTracker);\n\t\t\t\tRemoveRandomReturn val = chosenTracker.removeRandom(starter, persistent ? container : null, context, now);\n\t\t\t\tSendableRequest req;\n\t\t\t\tif(val == null) {\n\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned null - nothing to schedule, should remove priority\");\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(val.item == null) {\n\t\t\t\t\tif(val.wakeupTime == -1)\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of -1 - nothing to schedule, should remove priority\");\n\t\t\t\t\telse\n\t\t\t\t\t\tLogger.normal(this, \"Priority \"+choosenPriorityClass+\" returned cooldown time of \"+(val.wakeupTime - now)+\" = \"+TimeUtil.formatTime(val.wakeupTime - now));\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treq = (SendableRequest) val.item;\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(req, 1); // FIXME\n\t\t\t\tif(chosenTracker.persistent() != persistent) {\n\t\t\t\t\tLogger.error(this, \"Tracker.persistent()=\"+chosenTracker.persistent()+\" but is in the queue for persistent=\"+persistent+\" for \"+chosenTracker);\n\t\t\t\t\t// FIXME fix it\n\t\t\t\t}\n\t\t\t\tif(req.persistent() != persistent) {\n\t\t\t\t\tLogger.error(this, \"Request.persistent()=\"+req.persistent()+\" but is in the queue for persistent=\"+chosenTracker.persistent()+\" for \"+req);\n\t\t\t\t\t// FIXME fix it\n\t\t\t\t}\n\t\t\t\tif(req.getPriorityClass(container) != choosenPriorityClass) {\n\t\t\t\t\t// Reinsert it : shouldn't happen if we are calling reregisterAll,\n\t\t\t\t\t// maybe we should ask people to report that error if seen\n\t\t\t\t\tLogger.normal(this, \"In wrong priority class: \"+req+\" (req.prio=\"+req.getPriorityClass(container)+\" but chosen=\"+choosenPriorityClass+ ')');\n\t\t\t\t\t// Remove it.\n\t\t\t\t\tSectoredRandomGrabArrayWithObject clientGrabber = (SectoredRandomGrabArrayWithObject) chosenTracker.getGrabber(req.getClient(container));\n\t\t\t\t\tif(clientGrabber != null) {\n\t\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\t\tcontainer.activate(clientGrabber, 1);\n\t\t\t\t\t\tRandomGrabArray baseRGA = (RandomGrabArray) clientGrabber.getGrabber(req.getClientRequest());\n\t\t\t\t\t\tif(baseRGA != null) {\n\t\t\t\t\t\t\tif(chosenTracker.persistent())\n\t\t\t\t\t\t\t\tcontainer.activate(baseRGA, 1);\n\t\t\t\t\t\t\tbaseRGA.remove(req, container, context);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Okay, it's been removed already. Cool.\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.error(this, \"Could not find client grabber for client \"+req.getClient(container)+\" from \"+chosenTracker);\n\t\t\t\t\t}\n\t\t\t\t\tif(req.persistent())\n\t\t\t\t\t\tschedCore.innerRegister(req, random, container, context, null);\n\t\t\t\t\telse\n\t\t\t\t\t\tschedTransient.innerRegister(req, random, container, context, null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check recentSuccesses\n\t\t\t\t/** Choose a recently succeeded request.\n\t\t\t\t * 50% chance of using a recently succeeded request, if there is one.\n\t\t\t\t * For transient requests, we keep a list of recently succeeded BaseSendableGet's,\n\t\t\t\t * because transient requests are chosen individually.\n\t\t\t\t * But for persistent requests, we keep a list of RandomGrabArray's, because\n\t\t\t\t * persistent requests are chosen a whole SendableRequest at a time.\n\t\t\t\t * \n\t\t\t\t * FIXME: Only replaces persistent requests with persistent requests (of similar priority and retry count), or transient with transient.\n\t\t\t\t * Probably this is acceptable.\n\t\t\t\t */\n\t\t\t\tif(!req.persistent() && !isInsertScheduler) {\n\t\t\t\t\tList<BaseSendableGet> recent = schedTransient.recentSuccesses;\n\t\t\t\t\tBaseSendableGet altReq = null;\n\t\t\t\t\tsynchronized(recent) {\n\t\t\t\t\t\tif(!recent.isEmpty()) {\n\t\t\t\t\t\t\tif(random.nextBoolean()) {\n\t\t\t\t\t\t\t\taltReq = recent.remove(recent.size()-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altReq != null && (altReq.isCancelled(container))) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring cancelled recently succeeded item \"+altReq);\n\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t}\n\t\t\t\t\tlong l;\n\t\t\t\t\tif(altReq != null && (l = altReq.getCooldownTime(container, context, now)) != 0) {\n\t\t\t\t\t\tif(logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"Ignoring recently succeeded item, cooldown time = \"+l+((l > 0) ? \" (\"+TimeUtil.formatTime(l - now)+\")\" : \"\"));\n\t\t\t\t\t\t\taltReq = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (altReq != null && altReq != req) {\n\t\t\t\t\t\tint prio = altReq.getPriorityClass(container);\n\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (transient) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Don't use the recent one\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen req \"+req+\" is better, reregistering recently succeeded \"+altReq);\n\t\t\t\t\t\t\tsynchronized(recent) {\n\t\t\t\t\t\t\t\trecent.add(altReq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(!isInsertScheduler) {\n\t\t\t\t\tRandomGrabArray altRGA = null;\n\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\tif(!(recentSuccesses.isEmpty() || random.nextBoolean())) {\n\t\t\t\t\t\t\taltRGA = recentSuccesses.remove(recentSuccesses.size()-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(altRGA != null) {\n\t\t\t\t\t\tcontainer.activate(altRGA, 1);\n\t\t\t\t\t\tSendableRequest altReq = null;\n\t\t\t\t\t\tif(container.ext().isStored(altRGA) && !altRGA.isEmpty()) {\n\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\tLogger.minor(this, \"Maybe using recently succeeded item from \"+altRGA);\n\t\t\t\t\t\t\tval = altRGA.removeRandom(starter, container, context, now);\n\t\t\t\t\t\t\tif(val != null) {\n\t\t\t\t\t\t\t\tif(val.item == null) {\n\t\t\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Ignoring recently succeeded item, removeRandom returned cooldown time \"+val.wakeupTime+((val.wakeupTime > 0) ? \" (\"+TimeUtil.formatTime(val.wakeupTime - now)+\")\" : \"\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taltReq = (SendableRequest) val.item;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(altReq != null && altReq != req) {\n\t\t\t\t\t\t\t\tcontainer.activate(altReq, 1);\n\t\t\t\t\t\t\t\tint prio = altReq.getPriorityClass(container);\n\t\t\t\t\t\t\t\tboolean useRecent = false;\n\t\t\t\t\t\t\t\tif(prio <= choosenPriorityClass) {\n\t\t\t\t\t\t\t\t\tif(altReq.getCooldownTime(container, context, now) != 0)\n\t\t\t\t\t\t\t\t\t\tuseRecent = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(useRecent) {\n\t\t\t\t\t\t\t\t\t// Use the recent one instead\n\t\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Recently succeeded (persistent) req \"+altReq+\" (prio=\"+altReq.getPriorityClass(container)+\" retry count \"+altReq.getRetryCount()+\") is better than \"+req+\" (prio=\"+req.getPriorityClass(container)+\" retry \"+req.getRetryCount()+\"), using that\");\n\t\t\t\t\t\t\t\t\t// Don't need to reregister, because removeRandom doesn't actually remove!\n\t\t\t\t\t\t\t\t\treq = altReq;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\t\t\t\tLogger.minor(this, \"Chosen (persistent) req \"+req+\" is better, reregistering recently succeeded \"+altRGA+\" for \"+altReq);\n\t\t\t\t\t\t\t\t\tsynchronized(recentSuccesses) {\n\t\t\t\t\t\t\t\t\t\trecentSuccesses.add(altRGA);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontainer.deactivate(altRGA, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now we have chosen a request.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" (prio \"+\n\t\t\t\t\t\treq.getPriorityClass(container)+\", retries \"+req.getRetryCount()+\", client \"+req.getClient(container)+\", client-req \"+req.getClientRequest()+ ')');\n\t\t\t\tif(logMINOR) Logger.minor(this, \"removeFirst() returning \"+req+\" of \"+req.getClientRequest());\n\t\t\t\treturn req;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"No requests to run\");\n\t\treturn null;\n\t}","commit_id":"939efe443cc5d23ed464ab52392f8b8c652b0870","url":"https://github.com/freenet/fred"},{"original_method":"protected boolean isStartUriMatched(UriInfo ui, String absoluteRequestUri) {\n        if (startUri.equals(WILDCARD) && (completeUri == null || !absoluteRequestUri.endsWith(completeUri))) {\n            return true;\n        }\n        if (!absoluteRequestUri.endsWith(startUri)) {\n            return false;\n        }\n        if (startUri.equals(completeUri)) {\n            MultivaluedMap<String, String> queries = ui.getQueryParameters();\n            if (queries.containsKey(OAuthConstants.AUTHORIZATION_CODE_VALUE) \n                || queries.containsKey(OAuthConstants.ERROR_KEY)) {\n                return false;\n            }\n        }\n        return true;\n    }","id":30545,"modified_method":"protected boolean isStartUriMatched(UriInfo ui, String absoluteRequestUri) {\n        // If all request URIs can initiate a code flow then it is a match \n        // unless the current request URI matches a non-null completeUri \n        if (startUri == null && completeUri != null && !absoluteRequestUri.endsWith(completeUri)) {\n            return true;\n        }\n        // If completeUri is null or startUri equals to it then check the code flow\n        // response properties, if code parameters are set then it is the end of the flow\n        if (completeUri == null || startUri != null && startUri.equals(completeUri)) {\n            MultivaluedMap<String, String> queries = ui.getQueryParameters();\n            if (codeResponseQueryParamsAvailable(queries)) {\n                return false;\n            }\n        }\n        // Finally compare start URI with the request URI\n        return startUri == null || absoluteRequestUri.endsWith(startUri);\n    }","commit_id":"79ce1f4ca105b045f538c72b58e66747ca289f41","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void filter(ContainerRequestContext rc) throws IOException {\n        checkSecurityContextStart(rc);\n        UriInfo ui = rc.getUriInfo();\n        String absoluteRequestUri = ui.getAbsolutePath().toString();\n        \n        boolean sameUriRedirect = false;\n        if (completeUri == null) {\n            String referer = rc.getHeaderString(\"Referer\");\n            if (referer != null && referer.startsWith(authorizationServiceUri)) {\n                completeUri = absoluteRequestUri;\n                sameUriRedirect = true;\n            } \n        }\n        \n        if (!sameUriRedirect && isStartUriMatched(ui, absoluteRequestUri)) {\n            ClientTokenContext request = getClientTokenContext(rc);\n            if (request != null) {\n                setClientCodeRequest(request);\n                if (completeUri != null) {\n                    rc.setRequestUri(URI.create(completeUri));\n                }\n                return;\n            }\n            Response codeResponse = createCodeResponse(rc,  ui);\n            rc.abortWith(codeResponse);\n        } else if (completeUri == null) {\n            LOG.warning(\"Complete URI is not initialized, authentication flow can not be completed\");\n            rc.abortWith(Response.status(500).build());\n            return;\n        } else if (absoluteRequestUri.endsWith(completeUri)) {\n            MultivaluedMap<String, String> requestParams = toRequestState(rc, ui);\n            processCodeResponse(rc, ui, requestParams);\n            checkSecurityContextEnd(rc, requestParams);\n        } else {\n            rc.abortWith(Response.status(401).build());\n        }\n    }","id":30546,"modified_method":"@Override\n    public void filter(ContainerRequestContext rc) throws IOException {\n        checkSecurityContextStart(rc);\n        UriInfo ui = rc.getUriInfo();\n        String absoluteRequestUri = ui.getAbsolutePath().toString();\n        \n        if (completeUri == null) {\n            String referer = rc.getHeaderString(\"Referer\");\n            if (referer != null && referer.startsWith(authorizationServiceUri)) {\n                completeUri = absoluteRequestUri;\n            } \n        }\n        \n        if (isStartUriMatched(ui, absoluteRequestUri)) {\n            ClientTokenContext request = getClientTokenContext(rc);\n            if (request != null) {\n                setClientCodeRequest(request);\n                if (completeUri != null) {\n                    rc.setRequestUri(URI.create(completeUri));\n                }\n                // let the request continue if the token context is already available\n                return;\n            }\n            // start the code flow\n            Response codeResponse = createCodeResponse(rc, ui);\n            rc.abortWith(codeResponse);\n            return;\n        } else {\n            // complete the code flow if possible\n            MultivaluedMap<String, String> requestParams = toRequestState(rc, ui);\n            if (codeResponseQueryParamsAvailable(requestParams)\n                && (completeUri == null || absoluteRequestUri.endsWith(completeUri))) {\n                processCodeResponse(rc, ui, requestParams);\n                checkSecurityContextEnd(rc, requestParams);\n                // let the request continue\n                return;\n            }\n        } \n        // neither the start nor the end of the flow \n        rc.abortWith(Response.status(401).build());\n    }","commit_id":"79ce1f4ca105b045f538c72b58e66747ca289f41","url":"https://github.com/apache/cxf"},{"original_method":"@GET\n    @Path(\"/complete\")\n    @Produces(\"text/html\")\n    public BigQueryResponse completeBigQuery(@Context OidcClientTokenContext context) {\n        \n        ClientAccessToken accessToken = context.getToken();\n        \n        MultivaluedMap<String, String> state = context.getState();\n        \n        String searchWord = state.getFirst(\"word\");\n        String maxResults = state.getFirst(\"maxResults\");\n        \n        BigQueryResponse bigQueryResponse = new BigQueryResponse(context.getUserInfo().getName(),\n                                                                 searchWord);\n        bigQueryResponse.setTexts(getMatchingTexts(bigQueryClient, accessToken, searchWord, maxResults));\n        return bigQueryResponse;\n    }","id":30547,"modified_method":"@GET\n    @Path(\"/complete\")\n    @Produces(\"text/html\")\n    public BigQueryResponse completeBigQueryGet(@Context OidcClientTokenContext context) {\n        \n        ClientAccessToken accessToken = context.getToken();\n        \n        MultivaluedMap<String, String> state = context.getState();\n        \n        String searchWord = state.getFirst(\"word\");\n        String maxResults = state.getFirst(\"maxResults\");\n        \n        BigQueryResponse bigQueryResponse = new BigQueryResponse(context.getUserInfo().getName(),\n                                                                 searchWord);\n        bigQueryResponse.setTexts(getMatchingTexts(bigQueryClient, accessToken, searchWord, maxResults));\n        return bigQueryResponse;\n    }","commit_id":"8c22c4cee5ab1b31a4c8e843601627b3445da312","url":"https://github.com/apache/cxf"},{"original_method":"protected boolean checkSecurityContext(ContainerRequestContext rc) {\n        Map<String, Cookie> cookies = rc.getCookies();\n        \n        Cookie securityContextCookie = cookies.get(\"org.apache.cxf.websso.context\");\n        if (securityContextCookie == null) {\n            return false;\n        }\n        String contextKey = securityContextCookie.getValue();\n        \n        OidcClientTokenContext tokenContext = stateManager.getTokenContext(contextKey);\n        \n        if (tokenContext == null) {\n            return false;\n        }\n        rc.setSecurityContext(new OidcSecurityContext(tokenContext));\n        return true;\n    }","id":30548,"modified_method":"protected boolean checkSecurityContext(ContainerRequestContext rc) {\n        Map<String, Cookie> cookies = rc.getCookies();\n        \n        Cookie securityContextCookie = cookies.get(\"org.apache.cxf.websso.context\");\n        if (securityContextCookie == null) {\n            return false;\n        }\n        String contextKey = securityContextCookie.getValue();\n        \n        OidcClientTokenContext tokenContext = stateManager.getTokenContext(contextKey);\n        if (tokenContext == null) {\n            return false;\n        }\n        OidcClientTokenContextImpl newTokenContext = new OidcClientTokenContextImpl();\n        newTokenContext.setToken(tokenContext.getToken());\n        newTokenContext.setIdToken(tokenContext.getIdToken());\n        newTokenContext.setUserInfo(tokenContext.getUserInfo());\n        newTokenContext.setState(toRequestState(rc));\n        JAXRSUtils.getCurrentMessage().setContent(ClientTokenContext.class, newTokenContext);\n        rc.setSecurityContext(new OidcSecurityContext(newTokenContext));\n        return true;\n    }","commit_id":"8c22c4cee5ab1b31a4c8e843601627b3445da312","url":"https://github.com/apache/cxf"},{"original_method":"public void filter(ContainerRequestContext rc) {\n        if (checkSecurityContext(rc)) {\n            return;\n        } else {\n            String token = OAuthUtils.generateRandomTokenKey();\n            MultivaluedMap<String, String> state = toRequestState(rc);\n            stateManager.setRequestState(token, state);\n            UriBuilder ub = rc.getUriInfo().getBaseUriBuilder().path(rpServiceAddress);\n            ub.queryParam(\"state\", token);\n            rc.abortWith(Response.seeOther(ub.build())\n                           .header(HttpHeaders.CACHE_CONTROL, \"no-cache, no-store\")\n                           .header(\"Pragma\", \"no-cache\") \n                           .build());\n        }\n    }","id":30549,"modified_method":"public void filter(ContainerRequestContext rc) {\n        if (checkSecurityContext(rc)) {\n            return;\n        } else {\n            UriBuilder ub = rc.getUriInfo().getBaseUriBuilder().path(rpServiceAddress);\n            rc.abortWith(Response.seeOther(ub.build())\n                           .header(HttpHeaders.CACHE_CONTROL, \"no-cache, no-store\")\n                           .header(\"Pragma\", \"no-cache\") \n                           .build());\n        }\n    }","commit_id":"8c22c4cee5ab1b31a4c8e843601627b3445da312","url":"https://github.com/apache/cxf"},{"original_method":"private MultivaluedMap<String, String> toRequestState(ContainerRequestContext rc) {\n        MultivaluedMap<String, String> requestState = new MetadataMap<String, String>();\n        requestState.putAll(rc.getUriInfo().getQueryParameters(true));\n        if (MediaType.APPLICATION_FORM_URLENCODED_TYPE.isCompatible(rc.getMediaType())) {\n            String body = FormUtils.readBody(rc.getEntityStream(), \"UTF-8\");\n            FormUtils.populateMapFromString(requestState, JAXRSUtils.getCurrentMessage(), body, \n                                            \"UTF-8\", true);\n        }\n        requestState.putSingle(\"location\", rc.getUriInfo().getRequestUri().toString());\n        return requestState;\n    }","id":30550,"modified_method":"private MultivaluedMap<String, String> toRequestState(ContainerRequestContext rc) {\n        MultivaluedMap<String, String> requestState = new MetadataMap<String, String>();\n        requestState.putAll(rc.getUriInfo().getQueryParameters(true));\n        if (MediaType.APPLICATION_FORM_URLENCODED_TYPE.isCompatible(rc.getMediaType())) {\n            String body = FormUtils.readBody(rc.getEntityStream(), \"UTF-8\");\n            FormUtils.populateMapFromString(requestState, JAXRSUtils.getCurrentMessage(), body, \n                                            \"UTF-8\", true);\n        }\n        return requestState;\n    }","commit_id":"8c22c4cee5ab1b31a4c8e843601627b3445da312","url":"https://github.com/apache/cxf"},{"original_method":"@GET\n    @Path(\"complete\")\n    public Response completeAuthentication(@Context OidcClientTokenContext context,\n                                           @Context MessageContext mc) {\n        String key = OAuthUtils.generateRandomTokenKey();\n        stateManager.setTokenContext(key, context);\n        URI redirectUri = null;\n        String location = context.getState().getFirst(\"location\");\n        if (location == null) {\n            String basePath = (String)mc.get(\"http.base.path\");\n            redirectUri = UriBuilder.fromUri(basePath).path(defaultLocation).build();\n        } else {\n            redirectUri = URI.create(location);\n        }\n        return Response.seeOther(redirectUri).header(\"Set-Cookie\", \n                                                     \"org.apache.cxf.websso.context=\" + key + \";Path=/\").build();\n    }","id":30551,"modified_method":"@GET\n    @Path(\"complete\")\n    public Response completeAuthentication(@Context OidcClientTokenContext context,\n                                           @Context MessageContext mc) {\n        String key = OAuthUtils.generateRandomTokenKey();\n        stateManager.setTokenContext(key, context);\n        URI redirectUri = null;\n        String location = context.getState().getFirst(\"state\");\n        if (location == null) {\n            String basePath = (String)mc.get(\"http.base.path\");\n            redirectUri = UriBuilder.fromUri(basePath).path(defaultLocation).build();\n        } else {\n            redirectUri = URI.create(location);\n        }\n        return Response.seeOther(redirectUri).header(\"Set-Cookie\", \n                                                     \"org.apache.cxf.websso.context=\" + key + \";Path=/\").build();\n    }","commit_id":"8c22c4cee5ab1b31a4c8e843601627b3445da312","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n        public void filter(ContainerRequestContext requestContext) throws IOException {\n            UriInfo ui = mc.getUriInfo();\n            if (ui.getPath().endsWith(APIDOCS_LISTING_PATH_JSON)) {\n                Response r = getListingJson(null, mc.getServletConfig(), mc.getHttpHeaders(), ui);\n                requestContext.abortWith(r);\n            } else if (ui.getPath().endsWith(APIDOCS_LISTING_PATH_YAML)) {\n                Response r = getListingYaml(null, mc.getServletConfig(), mc.getHttpHeaders(), ui);\n                requestContext.abortWith(r);\n            }\n        }","id":30552,"modified_method":"@Override\n        public void filter(ContainerRequestContext requestContext) throws IOException {\n            UriInfo ui = mc.getUriInfo();\n            List<MediaType> mediaTypes = mc.getHttpHeaders().getAcceptableMediaTypes();\n\n            Response response = null;\n            if ((ui.getPath().endsWith(APIDOCS_LISTING_PATH)\n                    && !JAXRSUtils.intersectMimeTypes(mediaTypes, MediaType.APPLICATION_JSON_TYPE).isEmpty())\n                    || ui.getPath().endsWith(APIDOCS_LISTING_PATH_JSON)) {\n\n                response = getListingJsonResponse(\n                        null, mc.getServletContext(), mc.getServletConfig(), mc.getHttpHeaders(), ui);\n            } else if ((ui.getPath().endsWith(APIDOCS_LISTING_PATH)\n                    && !JAXRSUtils.intersectMimeTypes(mediaTypes, APPLICATION_YAML_TYPE).isEmpty())\n                    || ui.getPath().endsWith(APIDOCS_LISTING_PATH_YAML)) {\n\n                response = getListingYamlResponse(\n                        null, mc.getServletContext(), mc.getServletConfig(), mc.getHttpHeaders(), ui);\n            }\n\n            if (response != null) {\n                requestContext.abortWith(response);\n            }\n        }","commit_id":"7098ccba6b70f911fa7056979b94324fe6104522","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void addSwaggerResource(Server server) {\n        List<ClassResourceInfo> cris = Collections.emptyList();\n        if (!runAsFilter) {\n            List<Object> serviceBeans = new ArrayList<>();\n            ApiListingResource apiListingResource = new ApiListingResource();\n            serviceBeans.add(apiListingResource);\n            JAXRSServiceFactoryBean sfb =\n                    (JAXRSServiceFactoryBean) server.getEndpoint().get(JAXRSServiceFactoryBean.class.getName());\n            sfb.setResourceClassesFromBeans(serviceBeans);\n            cris = sfb.getClassResourceInfo();\n            for (ClassResourceInfo cri : cris) {\n                if (ApiListingResource.class == cri.getResourceClass()) {\n                    InjectionUtils.injectContextProxiesAndApplication(cri, apiListingResource, null);\n                }\n            }\n        }\n        List<Object> providers = new ArrayList<>();\n        if (runAsFilter) {\n            providers.add(new SwaggerContainerRequestFilter());\n        }\n        providers.add(new Swagger2Serializers(dynamicBasePath, replaceTags, javadocProvider, cris));\n        providers.add(new ReaderConfigFilter());\n        ((ServerProviderFactory) server.getEndpoint().get(\n                ServerProviderFactory.class.getName())).setUserProviders(providers);\n\n        BeanConfig beanConfig = new BeanConfig();\n        beanConfig.setResourcePackage(getResourcePackage());\n        beanConfig.setVersion(getVersion());\n        beanConfig.setBasePath(getBasePath());\n        beanConfig.setHost(getHost());\n        beanConfig.setSchemes(getSchemes());\n        beanConfig.setTitle(getTitle());\n        beanConfig.setDescription(getDescription());\n        beanConfig.setContact(getContact());\n        beanConfig.setLicense(getLicense());\n        beanConfig.setLicenseUrl(getLicenseUrl());\n        beanConfig.setTermsOfServiceUrl(getTermsOfServiceUrl());\n        beanConfig.setScan(isScan());\n        beanConfig.setPrettyPrint(isPrettyPrint());\n        beanConfig.setFilterClass(getFilterClass());\n    }","id":30553,"modified_method":"@Override\n    protected void addSwaggerResource(Server server) {\n        ApiListingResource apiListingResource = new ApiListingResource();\n        JAXRSServiceFactoryBean sfb =\n                (JAXRSServiceFactoryBean) server.getEndpoint().get(JAXRSServiceFactoryBean.class.getName());\n        sfb.setResourceClassesFromBeans(Collections.<Object>singletonList(apiListingResource));\n        List<ClassResourceInfo> cris = sfb.getClassResourceInfo();\n\n        List<Object> providers = new ArrayList<>();\n        if (runAsFilter) {\n            providers.add(new SwaggerContainerRequestFilter());\n        } else {\n            for (ClassResourceInfo cri : cris) {\n                if (ApiListingResource.class == cri.getResourceClass()) {\n                    InjectionUtils.injectContextProxies(cri, apiListingResource);\n                }\n            }\n        }\n        providers.add(new Swagger2Serializers(dynamicBasePath, replaceTags, javadocProvider, cris));\n        providers.add(new ReaderConfigFilter());\n        ((ServerProviderFactory) server.getEndpoint().get(\n                ServerProviderFactory.class.getName())).setUserProviders(providers);\n\n        BeanConfig beanConfig = new BeanConfig();\n        beanConfig.setResourcePackage(getResourcePackage());\n        beanConfig.setVersion(getVersion());\n        beanConfig.setBasePath(getBasePath());\n        beanConfig.setHost(getHost());\n        beanConfig.setSchemes(getSchemes());\n        beanConfig.setTitle(getTitle());\n        beanConfig.setDescription(getDescription());\n        beanConfig.setContact(getContact());\n        beanConfig.setLicense(getLicense());\n        beanConfig.setLicenseUrl(getLicenseUrl());\n        beanConfig.setTermsOfServiceUrl(getTermsOfServiceUrl());\n        beanConfig.setScan(isScan());\n        beanConfig.setPrettyPrint(isPrettyPrint());\n        beanConfig.setFilterClass(getFilterClass());\n    }","commit_id":"7098ccba6b70f911fa7056979b94324fe6104522","url":"https://github.com/apache/cxf"},{"original_method":"private void addReaderConfig(String ignoreRoutesParam) {\n            DefaultReaderConfig rc = new DefaultReaderConfig();\n            rc.setScanAllResources(true);\n            if (ignoreRoutesParam != null) {\n                Set<String> routes = new LinkedHashSet<>();\n                for (String route : StringUtils.split(ignoreRoutesParam, \",\")) {\n                    routes.add(route.trim());\n                }\n                rc.setIgnoredRoutes(routes);\n            }\n            mc.getServletContext().setAttribute(ReaderConfig.class.getName(), rc);\n        }","id":30554,"modified_method":"protected void addReaderConfig(String ignoreRoutesParam) {\n            DefaultReaderConfig rc = new DefaultReaderConfig();\n            rc.setScanAllResources(true);\n            if (ignoreRoutesParam != null) {\n                Set<String> routes = new LinkedHashSet<>();\n                for (String route : StringUtils.split(ignoreRoutesParam, \",\")) {\n                    routes.add(route.trim());\n                }\n                rc.setIgnoredRoutes(routes);\n            }\n            mc.getServletContext().setAttribute(ReaderConfig.class.getName(), rc);\n        }","commit_id":"7098ccba6b70f911fa7056979b94324fe6104522","url":"https://github.com/apache/cxf"},{"original_method":"private String getNormalizedPath(String classResourcePath, String operationResourcePath) {\n        StringBuilder normalizedPath = new StringBuilder();\n\n        String[] segments = StringUtils.split(classResourcePath + operationResourcePath, \"/\");\n        for (String segment : segments) {\n            if (!StringUtils.isEmpty(segment)) {\n                normalizedPath.append(\"/\").append(segment);\n            }\n        }\n        // Adapt to Swagger's path expression\n        if (normalizedPath.toString().endsWith(\":.*}\")) {\n            normalizedPath.setLength(normalizedPath.length() - 4);\n            normalizedPath.append('}');\n        }\n        return StringUtils.EMPTY.equals(normalizedPath.toString()) ? \"/\" : normalizedPath.toString();\n    }","id":30555,"modified_method":"protected String getNormalizedPath(String classResourcePath, String operationResourcePath) {\n        StringBuilder normalizedPath = new StringBuilder();\n\n        String[] segments = StringUtils.split(classResourcePath + operationResourcePath, \"/\");\n        for (String segment : segments) {\n            if (!StringUtils.isEmpty(segment)) {\n                normalizedPath.append(\"/\").append(segment);\n            }\n        }\n        // Adapt to Swagger's path expression\n        if (normalizedPath.toString().endsWith(\":.*}\")) {\n            normalizedPath.setLength(normalizedPath.length() - 4);\n            normalizedPath.append('}');\n        }\n        return StringUtils.EMPTY.equals(normalizedPath.toString()) ? \"/\" : normalizedPath.toString();\n    }","commit_id":"7098ccba6b70f911fa7056979b94324fe6104522","url":"https://github.com/apache/cxf"},{"original_method":"public void service(HttpServletRequest request,\n                        HttpServletResponse response,\n                        boolean precompile)\n\t    throws ServletException, IOException, FileNotFoundException {\n\n        try {\n\n            if (ctxt.isRemoved()) {\n                throw new FileNotFoundException(jspUri);\n            }\n\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                if (available > System.currentTimeMillis()) {\n                    response.setDateHeader(\"Retry-After\", available);\n                    response.sendError\n                        (HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         Localizer.getMessage(\"jsp.error.unavailable\"));\n                    return;\n                }\n                // Wait period has expired. Reset.\n                available = 0;\n            }\n\n            /*\n             * (1) Compile\n             */\n            if (firstTime || this.lastModificationTest == 0 ) {\n                synchronized (this) {\n                    if (firstTime || this.lastModificationTest == 0 ) {\n                        // The following sets reload to true, if necessary\n                        ctxt.compile();\n                        this.lastModificationTest = System.currentTimeMillis();\n                        firstTime = false;\n                    } else if ( compileException != null ) {\n                        // Throw cached compilation exception\n                        throw compileException;\n\n                    }\n                }\n            } else if (compileException != null) {\n                // Throw cached compilation exception\n                throw compileException;\n            }\n\n            /*\n             * (2) (Re)load servlet class file\n             */\n            getServlet();\n\n            // If a page is to be precompiled only, return.\n            if (precompile) {\n                return;\n            }\n\n        } catch (FileNotFoundException ex) {\n            ctxt.incrementRemoved();\n            String includeRequestUri = (String)\n                request.getAttribute(\"javax.servlet.include.request_uri\");\n            if (includeRequestUri != null) {\n                // This file was included. Throw an exception as\n                // a response.sendError() will be ignored by the\n                // servlet engine.\n                throw new ServletException(ex);\n            }\n            try {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                  ex.getMessage());\n            } catch (IllegalStateException ise) {\n                log.error(Localizer.getMessage(\"jsp.error.file.not.found\",\n                       ex.getMessage()),\n              ex);\n            }\n            return;\n        } catch (ServletException ex) {\n            throw handleJspException(ex);\n        } catch (IOException ex) {\n            throw handleJspException(ex);\n        } catch (IllegalStateException ex) {\n            throw handleJspException(ex);\n        } catch (Exception ex) {\n            throw handleJspException(ex);\n        }\n\n        try {\n\n            /*\n             * (3) Service request\n             */\n            if (theServlet instanceof SingleThreadModel) {\n               // sync on the wrapper so that the freshness\n               // of the page is determined right before servicing\n               synchronized (this) {\n                   theServlet.service(request, response);\n                }\n            } else {\n                theServlet.service(request, response);\n            }\n\n        } catch (UnavailableException ex) {\n            String includeRequestUri = (String)\n                request.getAttribute(\"javax.servlet.include.request_uri\");\n            if (includeRequestUri != null) {\n                // This file was included. Throw an exception as\n                // a response.sendError() will be ignored by the\n                // servlet engine.\n                throw ex;\n            }\n            int unavailableSeconds = ex.getUnavailableSeconds();\n            if (unavailableSeconds <= 0) {\n                unavailableSeconds = 60;        // Arbitrary default\n            }\n            available = System.currentTimeMillis() +\n                (unavailableSeconds * 1000L);\n            response.sendError\n                (HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                 ex.getMessage());\n            return;\n        } catch (ServletException ex) {\n            throw handleJspException(ex);\n        } catch (IOException ex) {\n            throw handleJspException(ex);\n        } catch (IllegalStateException ex) {\n            throw handleJspException(ex);\n        } catch (Exception ex) {\n            throw handleJspException(ex);\n        }\n    }","id":30556,"modified_method":"public void service(HttpServletRequest request,\n                        HttpServletResponse response,\n                        boolean precompile)\n\t    throws ServletException, IOException, FileNotFoundException {\n\n        try {\n\n            if (ctxt.isRemoved()) {\n                throw new FileNotFoundException(jspUri);\n            }\n\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                if (available > System.currentTimeMillis()) {\n                    response.setDateHeader(\"Retry-After\", available);\n                    response.sendError\n                        (HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         Localizer.getMessage(\"jsp.error.unavailable\"));\n                    return;\n                }\n                // Wait period has expired. Reset.\n                available = 0;\n            }\n\n            /*\n             * (1) Compile\n             */\n            if (firstTime || this.lastModificationTest == 0 ) {\n                synchronized (this) {\n                    if (firstTime || this.lastModificationTest == 0 ) {\n                        // The following sets reload to true, if necessary\n                        ctxt.compile();\n                        this.lastModificationTest = System.currentTimeMillis();\n                        firstTime = false;\n                    } else if ( compileException != null ) {\n                        // Throw cached compilation exception\n                        throw compileException;\n\n                    }\n                }\n            } else if (compileException != null) {\n                // Throw cached compilation exception\n                throw compileException;\n            }\n\n            /*\n             * (2) (Re)load servlet class file\n             */\n            getServlet();\n\n            // If a page is to be precompiled only, return.\n            if (precompile) {\n                return;\n            }\n\n        } catch (FileNotFoundException ex) {\n            ctxt.incrementRemoved();\n            String includeRequestUri = (String)\n                request.getAttribute(\"javax.servlet.include.request_uri\");\n            if (includeRequestUri != null) {\n                // This file was included. Throw an exception as\n                // a response.sendError() will be ignored by the\n                // servlet engine.\n                throw new ServletException(ex);\n            }\n            try {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                  ex.getMessage());\n            } catch (IllegalStateException ise) {\n                log.error(Localizer.getMessage(\"jsp.error.file.not.found\",\n                       ex.getMessage()),\n              ex);\n            }\n            return;\n        } catch (ServletException ex) {\n            handleJspException(ex);\n        } catch (IOException ex) {\n            handleJspException(ex);\n        } catch (IllegalStateException ex) {\n            handleJspException(ex);\n        } catch (Exception ex) {\n            handleJspException(ex);\n        }\n\n        try {\n\n            /*\n             * (3) Service request\n             */\n            if (theServlet instanceof SingleThreadModel) {\n               // sync on the wrapper so that the freshness\n               // of the page is determined right before servicing\n               synchronized (this) {\n                   theServlet.service(request, response);\n                }\n            } else {\n                theServlet.service(request, response);\n            }\n\n        } catch (UnavailableException ex) {\n            String includeRequestUri = (String)\n                request.getAttribute(\"javax.servlet.include.request_uri\");\n            if (includeRequestUri != null) {\n                // This file was included. Throw an exception as\n                // a response.sendError() will be ignored by the\n                // servlet engine.\n                throw ex;\n            }\n            int unavailableSeconds = ex.getUnavailableSeconds();\n            if (unavailableSeconds <= 0) {\n                unavailableSeconds = 60;        // Arbitrary default\n            }\n            available = System.currentTimeMillis() +\n                (unavailableSeconds * 1000L);\n            response.sendError\n                (HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                 ex.getMessage());\n            return;\n        } catch (ServletException ex) {\n            handleJspException(ex);\n        } catch (IOException ex) {\n            handleJspException(ex);\n        } catch (IllegalStateException ex) {\n            handleJspException(ex);\n        } catch (Exception ex) {\n            handleJspException(ex);\n        }\n    }","commit_id":"37ca97b4d1974063baf820d953acdd8f654613d6","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * <p>Attempts to construct a JasperException that contains helpful information\n     * about what went wrong. Uses the JSP compiler system to translate the line\n     * number in the generated servlet that originated the exception to a line\n     * number in the JSP.  Then constructs an exception containing that\n     * information, and a snippet of the JSP to help debugging.\n     * Please see http://issues.apache.org/bugzilla/show_bug.cgi?id=37062 and\n     * http://www.tfenne.com/jasper/ for more details.\n     *<\/p>\n     *\n     * @param ex the exception that was the cause of the problem.\n     * @return a JasperException with more detailed information\n     */\n    protected JasperException handleJspException(Exception ex) {\n        Throwable realException = ex;\n        String exMessage = \"\";\n        if (ex instanceof ServletException) {\n            realException = ((ServletException) ex).getRootCause();\n            // root cause might be null (eg. for a JasperException ex)\n            if (realException == null) {\n                realException = ex;\n            } else {\n                exMessage = ex.toString();\n            }\n        }\n\n        // avoid nested ScriptEvaluationExceptions (eg. in nested jsp includes)\n        while (realException instanceof ScriptEvaluationException) {\n            realException = realException.getCause();\n        }\n\n        try {\n            // First identify the stack frame in the trace that represents the JSP\n            StackTraceElement[] frames = realException.getStackTrace();\n            StackTraceElement jspFrame = null;\n\n            for (int i=0; i<frames.length; ++i) {\n                if ( frames[i].getClassName().equals(this.getServlet().getClass().getName()) ) {\n                    jspFrame = frames[i];\n                    break;\n                }\n            }\n\n            if (jspFrame == null) {\n                // If we couldn't find a frame in the stack trace corresponding\n                // to the generated servlet class, we can't really add anything\n                return new JasperException(exMessage, realException);\n            }\n            int javaLineNumber = jspFrame.getLineNumber();\n            JavacErrorDetail detail = ErrorDispatcher.createJavacError(\n                    jspFrame.getMethodName(),\n                    this.ctxt.getCompiler().getPageNodes(),\n                    null,\n                    javaLineNumber,\n                    ctxt);\n\n            // If the line number is less than one we couldn't find out\n            // where in the JSP things went wrong\n            int jspLineNumber = detail.getJspBeginLineNumber();\n            if (jspLineNumber < 1) {\n                return new JasperException(exMessage, realException);\n            }\n\n            if (options.getDisplaySourceFragment()) {\n                return new JasperException(Localizer.getMessage\n                        (\"jsp.exception\", detail.getJspFileName(),\n                                \"\" + jspLineNumber) +\n                                \"\\n\\n\" + detail.getJspExtract() +\n                                \"\\n\", realException);\n\n            }\n            return new JasperException(Localizer.getMessage\n                    (\"jsp.exception\", detail.getJspFileName(),\n                            \"\" + jspLineNumber), realException);\n        } catch (Exception je) {\n            // If anything goes wrong, just revert to the original behaviour\n            if (realException instanceof JasperException) {\n                return (JasperException) realException;\n            }\n            return new JasperException(exMessage, realException);\n        }\n    }","id":30557,"modified_method":"/**\n     * <p>Attempts to construct a JasperException that contains helpful information\n     * about what went wrong. Uses the JSP compiler system to translate the line\n     * number in the generated servlet that originated the exception to a line\n     * number in the JSP.  Then constructs an exception containing that\n     * information, and a snippet of the JSP to help debugging.\n     * Please see http://issues.apache.org/bugzilla/show_bug.cgi?id=37062 and\n     * http://www.tfenne.com/jasper/ for more details.\n     *<\/p>\n     *\n     * @param ex the exception that was the cause of the problem.\n     * @throws a ServletException with more detailed information\n     */\n    protected void handleJspException(Exception ex)\n    throws ServletException {\n        final Exception jspEx = handleJspExceptionInternal(ex);\n        if ( jspEx instanceof ServletException ) {\n            throw (ServletException)jspEx;\n        }\n        throw (SlingException)jspEx;\n    }","commit_id":"37ca97b4d1974063baf820d953acdd8f654613d6","url":"https://github.com/apache/sling"},{"original_method":"/**\n    * Extract contents of a PO file and convert to a TranslationsResource.\n    * NB: If the file contains the gettext header Content-Type, it must be\n    * set to ASCII, CHARSET, UTF8 or UTF-8, or an exception will occur.\n    * @param inputSource PO file to be extracted\n    * @param srcDoc source language document\n    * @return converted PO file as TranslationsResource\n    */\n   public TranslationsResource extractTarget(InputSource inputSource, Resource srcDoc)\n   {\n      TranslationsResource document = new TranslationsResource();\n      MessageStreamParser messageParser = createParser(inputSource);\n\n      boolean headerFound = false;\n      while (messageParser.hasNext())\n      {\n         Message message = messageParser.next();\n\n         if (message.isHeader())\n         {\n            if (headerFound)\n               throw new IllegalStateException(\"found a second header!\");\n            headerFound = true;\n\n            // add target header data\n            PoTargetHeader poHeader = new PoTargetHeader();\n            extractPoHeader(message, poHeader);\n            document.getExtensions(true).add(poHeader);\n         }\n         else if (message.isObsolete())\n         {\n            // TODO append obsolete\n         }\n         else if (message.isPlural())\n         {\n            // TODO skip for now\n         }\n         else\n         {\n            String id = createId(message);\n            // add the target content (msgstr)\n            TextFlowTarget tfTarget = new TextFlowTarget();\n            tfTarget.setResId(id);\n            tfTarget.setDescription(ShortString.shorten(message.getMsgid()));\n\n            if (message.isPlural())\n            {\n               tfTarget.setContents(message.getMsgstrPlural());\n            }\n            else\n            {\n               tfTarget.setContents(message.getMsgstr());\n            }\n\n            tfTarget.setState(getContentState(message));\n\n            // add the PO comment\n            tfTarget.getExtensions(true).add(new SimpleComment(StringUtils.join(message.getComments(), \"\\n\")));\n            document.getTextFlowTargets().add(tfTarget);\n         }\n      }\n      return document;\n   }","id":30558,"modified_method":"/**\n    * Extract contents of a PO file and convert to a TranslationsResource.\n    * NB: If the file contains the gettext header Content-Type, it must be\n    * set to ASCII, CHARSET, UTF8 or UTF-8, or an exception will occur.\n    * @param inputSource PO file to be extracted\n    * @param srcDoc source language document\n    * @return converted PO file as TranslationsResource\n    */\n   public TranslationsResource extractTarget(InputSource inputSource, Resource srcDoc)\n   {\n      TranslationsResource document = new TranslationsResource();\n      MessageStreamParser messageParser = createParser(inputSource);\n\n      boolean headerFound = false;\n      while (messageParser.hasNext())\n      {\n         Message message = messageParser.next();\n\n         if (message.isHeader())\n         {\n            if (headerFound)\n               throw new IllegalStateException(\"found a second header!\");\n            headerFound = true;\n\n            // add target header data\n            PoTargetHeader poHeader = new PoTargetHeader();\n            extractPoHeader(message, poHeader);\n            document.getExtensions(true).add(poHeader);\n         }\n         else if (message.isObsolete())\n         {\n            // TODO append obsolete\n         }\n         else\n         {\n            String id = createId(message);\n            // add the target content (msgstr)\n            TextFlowTarget tfTarget = new TextFlowTarget();\n            tfTarget.setResId(id);\n            tfTarget.setDescription(ShortString.shorten(message.getMsgid()));\n\n            if (message.isPlural())\n            {\n               tfTarget.setContents(message.getMsgstrPlural());\n            }\n            else\n            {\n               tfTarget.setContents(message.getMsgstr());\n            }\n\n            tfTarget.setState(getContentState(message));\n\n            // add the PO comment\n            tfTarget.getExtensions(true).add(new SimpleComment(StringUtils.join(message.getComments(), \"\\n\")));\n            document.getTextFlowTargets().add(tfTarget);\n         }\n      }\n      return document;\n   }","commit_id":"166a871427f06d9075c08af7d65a04a454683c8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Extract contents of a POT file and convert to a Resource.\n    * NB: If the file contains the gettext header Content-Type, it must be\n    * set to ASCII, CHARSET, UTF8 or UTF-8, or an exception will occur.\n    * @param inputSource POT file to be extracted\n    * @param sourceLocaleId locale of POT, used to set metadata fields\n    * @param docName name of POT file (minus .pot extension) used to set metadata fields\n    * @return converted POT file as Resource\n    */\n   public Resource extractTemplate(InputSource inputSource, LocaleId sourceLocaleId, String docName)\n   {\n      Resource document = new Resource(docName);\n      MessageStreamParser messageParser = createParser(inputSource);\n\n      document.setLang(sourceLocaleId);\n      document.setContentType(PO_CONTENT_TYPE);\n      List<TextFlow> resources = document.getTextFlows();\n\n      boolean headerFound = false;\n      while (messageParser.hasNext())\n      {\n         Message message = messageParser.next();\n\n         if (message.isHeader())\n         {\n            if (headerFound)\n               throw new IllegalStateException(\"found a second header!\");\n            headerFound = true;\n\n            // store POT data\n            PoHeader potHeader = new PoHeader();\n            extractPotHeader(message, potHeader);\n            document.getExtensions(true).add(potHeader);\n\n         }\n         else if (message.isObsolete())\n         {\n            // TODO append obsolete\n         }\n         else if (message.isPlural())\n         {\n            // TODO skip for now\n         }\n         else\n         {\n            String id = createId(message);\n            // add the content (msgid)\n            TextFlow tf = new TextFlow(id, sourceLocaleId);\n            if (message.isPlural())\n            {\n               tf.setContents(message.getMsgid(), message.getMsgidPlural());\n            }\n            else\n            {\n               tf.setContents(message.getMsgid());\n            }\n            resources.add(tf);\n\n            // add the entry header POT fields\n            tf.getExtensions(true).add(createPotEntryHeader(message));\n            tf.getExtensions().add(createSimpleComment(message));\n         }\n      }\n      return document;\n   }","id":30559,"modified_method":"/**\n    * Extract contents of a POT file and convert to a Resource.\n    * NB: If the file contains the gettext header Content-Type, it must be\n    * set to ASCII, CHARSET, UTF8 or UTF-8, or an exception will occur.\n    * @param inputSource POT file to be extracted\n    * @param sourceLocaleId locale of POT, used to set metadata fields\n    * @param docName name of POT file (minus .pot extension) used to set metadata fields\n    * @return converted POT file as Resource\n    */\n   public Resource extractTemplate(InputSource inputSource, LocaleId sourceLocaleId, String docName)\n   {\n      Resource document = new Resource(docName);\n      MessageStreamParser messageParser = createParser(inputSource);\n\n      document.setLang(sourceLocaleId);\n      document.setContentType(PO_CONTENT_TYPE);\n      List<TextFlow> resources = document.getTextFlows();\n\n      boolean headerFound = false;\n      while (messageParser.hasNext())\n      {\n         Message message = messageParser.next();\n\n         if (message.isHeader())\n         {\n            if (headerFound)\n               throw new IllegalStateException(\"found a second header!\");\n            headerFound = true;\n\n            // store POT data\n            PoHeader potHeader = new PoHeader();\n            extractPotHeader(message, potHeader);\n            document.getExtensions(true).add(potHeader);\n\n         }\n         else if (message.isObsolete())\n         {\n            // TODO append obsolete\n         }\n         else\n         {\n            String id = createId(message);\n            // add the content (msgid)\n            TextFlow tf = new TextFlow(id, sourceLocaleId);\n            tf.setPlural(message.isPlural());\n            if (message.isPlural())\n            {\n               tf.setContents(message.getMsgid(), message.getMsgidPlural());\n            }\n            else\n            {\n               tf.setContents(message.getMsgid());\n            }\n            resources.add(tf);\n\n            // add the entry header POT fields\n            tf.getExtensions(true).add(createPotEntryHeader(message));\n            tf.getExtensions().add(createSimpleComment(message));\n         }\n      }\n      return document;\n   }","commit_id":"166a871427f06d9075c08af7d65a04a454683c8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Generates a pot or po file from a Resource and/or TranslationsResource,\n    * using the publican directory layout. If targetDoc is non-null, a po file\n    * will be generated from Resource+TranslationsResource, otherwise a pot file\n    * will be generated from the Resource only.\n    * \n    * @param writer\n    * @param document\n    * @param targetDoc\n    * @throws IOException\n    */\n   private void write(Writer writer, String charset, Resource document, TranslationsResource targetDoc) throws IOException\n   {\n      PoHeader poHeader = document.getExtensions(true).findByType(PoHeader.class);\n      HeaderFields hf = new HeaderFields();\n      if (poHeader == null)\n      {\n         log.warn(\"No PO header in document named \" + document.getName());\n      }\n      else\n      {\n         copyToHeaderFields(hf, poHeader.getEntries());\n      }\n      setEncodingHeaderFields(hf, charset);\n      Message headerMessage = null;\n      if (targetDoc != null)\n      {\n         PoTargetHeader poTargetHeader = targetDoc.getExtensions(true).findByType(PoTargetHeader.class);\n         if (poTargetHeader != null)\n         {\n            copyToHeaderFields(hf, poTargetHeader.getEntries());\n            headerMessage = hf.unwrap();\n            headerMessage.setFuzzy(false); // By default, header message unwraps as fuzzy, so avoid it\n            copyTargetHeaderComments(headerMessage, poTargetHeader);\n         }\n      }\n      if (headerMessage == null)\n      {\n         headerMessage = hf.unwrap();\n      }\n      poWriter.write(headerMessage, writer);\n      writer.write(\"\\n\");\n      Map<String, TextFlowTarget> targets = null;\n      if (targetDoc != null)\n      {\n         targets = new HashMap<String, TextFlowTarget>();\n         for (TextFlowTarget target : targetDoc.getTextFlowTargets())\n         {\n            targets.put(target.getResId(), target);\n         }\n      }\n\n      // first write header\n      for (TextFlow textFlow : document.getTextFlows())\n      {\n\n         PotEntryHeader entryData = textFlow.getExtensions(true).findByType(PotEntryHeader.class);\n         SimpleComment srcComment = textFlow.getExtensions().findByType(SimpleComment.class);\n         Message message = new Message();\n         List<String> tfContents = textFlow.getContents();\n         switch (tfContents.size())\n         {\n         case 2:\n            message.setMsgidPlural(tfContents.get(1));\n            // fall through...\n         case 1:\n            message.setMsgid(tfContents.get(0));\n            break;\n         default:\n            throw new RuntimeException(\"POT format only supports 2 plural forms: resId=\" + textFlow.getId());\n         }\n\n         message.setMsgstr(\"\");\n         if (targetDoc != null)\n         {\n            TextFlowTarget tfTarget = targets.get(textFlow.getId());\n            if (tfTarget != null)\n            {\n               if (entryData == null)\n               {\n                  log.warn(\"Missing POT entry for text-flow ID \" + textFlow.getId());\n               }\n               else if (!tfTarget.getResId().equals(textFlow.getId()))\n               {\n                  throw new RuntimeException(\"ID from target doesn't match text-flow ID\");\n               }\n               List<String> tftContents = tfTarget.getContents();\n\n               if (message.isPlural())\n               {\n                  for (int i = 0; i < tftContents.size(); i++)\n                  {\n                     message.addMsgstrPlural(tftContents.get(i), i);\n                  }\n               }\n               else\n               {\n                  if (tftContents.size() != 0)\n                  {\n                     message.setMsgstr(tftContents.get(0));\n                     if (tftContents.size() > 1)\n                     {\n                        throw new RuntimeException(\"plural forms not enabled for this text flow: resId=\" + textFlow.getId());\n                     }\n                  }\n               }\n\n               SimpleComment poComment = tfTarget.getExtensions().findByType(SimpleComment.class);\n               if (poComment != null)\n               {\n                  String[] comments = poComment.getValue().split(\"\\n\");\n                  if (comments.length == 1 && comments[0].isEmpty())\n                  {\n                     // nothing\n                  }\n                  else\n                  {\n                     for (String comment : comments)\n                     {\n                        message.getComments().add(comment);\n                     }\n                  }\n               }\n               if (tfTarget.getState() == ContentState.NeedReview)\n               {\n                  message.setFuzzy(true);\n               }\n            }\n         }\n\n         if (entryData != null)\n            copyToMessage(entryData, srcComment, message);\n\n         poWriter.write(message, writer);\n         writer.write(\"\\n\");\n      }\n   }","id":30560,"modified_method":"/**\n    * Generates a pot or po file from a Resource and/or TranslationsResource,\n    * using the publican directory layout. If targetDoc is non-null, a po file\n    * will be generated from Resource+TranslationsResource, otherwise a pot file\n    * will be generated from the Resource only.\n    * \n    * @param writer\n    * @param document\n    * @param targetDoc\n    * @throws IOException\n    */\n   private void write(Writer writer, String charset, Resource document, TranslationsResource targetDoc) throws IOException\n   {\n      PoHeader poHeader = document.getExtensions(true).findByType(PoHeader.class);\n      HeaderFields hf = new HeaderFields();\n      if (poHeader == null)\n      {\n         log.warn(\"No PO header in document named \" + document.getName());\n      }\n      else\n      {\n         copyToHeaderFields(hf, poHeader.getEntries());\n      }\n      setEncodingHeaderFields(hf, charset);\n      Message headerMessage = null;\n      if (targetDoc != null)\n      {\n         PoTargetHeader poTargetHeader = targetDoc.getExtensions(true).findByType(PoTargetHeader.class);\n         if (poTargetHeader != null)\n         {\n            copyToHeaderFields(hf, poTargetHeader.getEntries());\n            headerMessage = hf.unwrap();\n            headerMessage.setFuzzy(false); // By default, header message unwraps as fuzzy, so avoid it\n            copyTargetHeaderComments(headerMessage, poTargetHeader);\n         }\n      }\n      if (headerMessage == null)\n      {\n         headerMessage = hf.unwrap();\n      }\n      poWriter.write(headerMessage, writer);\n      writer.write(\"\\n\");\n      Map<String, TextFlowTarget> targets = null;\n      if (targetDoc != null)\n      {\n         targets = new HashMap<String, TextFlowTarget>();\n         for (TextFlowTarget target : targetDoc.getTextFlowTargets())\n         {\n            targets.put(target.getResId(), target);\n         }\n      }\n\n      // first write header\n      for (TextFlow textFlow : document.getTextFlows())\n      {\n\n         PotEntryHeader entryData = textFlow.getExtensions(true).findByType(PotEntryHeader.class);\n         SimpleComment srcComment = textFlow.getExtensions().findByType(SimpleComment.class);\n         List<String> tfContents = textFlow.getContents();\n         Message message = new Message();\n         message.setMsgid(tfContents.get(0));\n\n         if (textFlow.isPlural())\n         {\n            if (tfContents.size() < 1)\n            {\n               throw new RuntimeException(\"textflow has plural flag but only has one form: resId=\" + textFlow.getId());\n            }\n            message.setMsgidPlural(tfContents.get(1));\n         }\n\n         if (tfContents.size() > 2)\n         {\n            throw new RuntimeException(\"POT format only supports 2 plural forms: resId=\" + textFlow.getId());\n         }\n\n         message.setMsgstr(\"\");\n         if (targetDoc != null)\n         {\n            TextFlowTarget tfTarget = targets.get(textFlow.getId());\n            if (tfTarget != null)\n            {\n               if (entryData == null)\n               {\n                  log.warn(\"Missing POT entry for text-flow ID \" + textFlow.getId());\n               }\n               else if (!tfTarget.getResId().equals(textFlow.getId()))\n               {\n                  throw new RuntimeException(\"ID from target doesn't match text-flow ID\");\n               }\n               List<String> tftContents = tfTarget.getContents();\n\n               if (message.isPlural())\n               {\n                  for (int i = 0; i < tftContents.size(); i++)\n                  {\n                     message.addMsgstrPlural(tftContents.get(i), i);\n                  }\n               }\n               else\n               {\n                  if (tftContents.size() != 0)\n                  {\n                     message.setMsgstr(tftContents.get(0));\n                     if (tftContents.size() > 1)\n                     {\n                        throw new RuntimeException(\"plural forms not enabled for this text flow: resId=\" + textFlow.getId());\n                     }\n                  }\n               }\n\n               SimpleComment poComment = tfTarget.getExtensions().findByType(SimpleComment.class);\n               if (poComment != null)\n               {\n                  String[] comments = poComment.getValue().split(\"\\n\");\n                  if (comments.length == 1 && comments[0].isEmpty())\n                  {\n                     // nothing\n                  }\n                  else\n                  {\n                     for (String comment : comments)\n                     {\n                        message.getComments().add(comment);\n                     }\n                  }\n               }\n               if (tfTarget.getState() == ContentState.NeedReview)\n               {\n                  message.setFuzzy(true);\n               }\n            }\n         }\n\n         if (entryData != null)\n            copyToMessage(entryData, srcComment, message);\n\n         poWriter.write(message, writer);\n         writer.write(\"\\n\");\n      }\n   }","commit_id":"166a871427f06d9075c08af7d65a04a454683c8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void testWriteSingular() throws JsonGenerationException, JsonMappingException, IOException\n   {\n      TextFlow tf = new TextFlow();\n      tf.setContents(\"abc\");\n\n      String expectedXML =\n            \"<TextFlow xmlns:ns2=\\\"http://zanata.org/namespace/api/gettext/\\\">\\n\" +\n                  \"    <content>abc<\/content>\\n\" +\n                  \"<\/TextFlow>\";\n      assertEquals(tf.toString(), expectedXML);\n      String expectedJSON =\n            \"{\\\"content\\\":\\\"abc\\\"}\";\n      assertEquals(om.writeValueAsString(tf), expectedJSON);\n   }","id":30561,"modified_method":"@Test\n   public void testWriteSingular() throws JsonGenerationException, JsonMappingException, IOException\n   {\n      TextFlow tf = new TextFlow();\n      tf.setContents(\"abc\");\n\n      String expectedXML =\n            \"<TextFlow xmlns:ns2=\\\"http://zanata.org/namespace/api/gettext/\\\">\\n\" +\n                  \"    <content>abc<\/content>\\n\" +\n                  \"    <plural>false<\/plural>\\n\" +\n                  \"<\/TextFlow>\";\n      assertEquals(tf.toString(), expectedXML);\n      String expectedJSON =\n            \"{\\\"content\\\":\\\"abc\\\",\\\"plural\\\":false}\";\n      assertEquals(om.writeValueAsString(tf), expectedJSON);\n   }","commit_id":"166a871427f06d9075c08af7d65a04a454683c8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void testWritePlural() throws JsonGenerationException, JsonMappingException, IOException\n   {\n      TextFlow tf = new TextFlow();\n      tf.setContents(\"abc\", \"def\");\n\n      String expectedXML =\n            \"<TextFlow xmlns:ns2=\\\"http://zanata.org/namespace/api/gettext/\\\">\\n\" +\n                  \"    <contents>\\n\" +\n                  \"        <content>abc<\/content>\\n\" +\n                  \"        <content>def<\/content>\\n\" +\n                  \"    <\/contents>\\n\" +\n                  \"<\/TextFlow>\";\n\n      assertEquals(tf.toString(), expectedXML);\n\n      String expectedJSON =\n            \"{\\\"content\\\":\\\"\\\",\\\"contents\\\":[\\\"abc\\\",\\\"def\\\"]}\";\n      assertEquals(om.writeValueAsString(tf), expectedJSON);\n   }","id":30562,"modified_method":"@Test\n   public void testWritePlural() throws JsonGenerationException, JsonMappingException, IOException\n   {\n      TextFlow tf = new TextFlow();\n      tf.setContents(\"abc\", \"def\");\n      tf.setPlural(true);\n\n      String expectedXML =\n            \"<TextFlow xmlns:ns2=\\\"http://zanata.org/namespace/api/gettext/\\\">\\n\" +\n                  \"    <contents>\\n\" +\n                  \"        <content>abc<\/content>\\n\" +\n                  \"        <content>def<\/content>\\n\" +\n                  \"    <\/contents>\\n\" +\n                  \"    <plural>true<\/plural>\\n\" +\n                  \"<\/TextFlow>\";\n\n      assertEquals(tf.toString(), expectedXML);\n\n      String expectedJSON =\n            \"{\\\"content\\\":\\\"\\\",\\\"contents\\\":[\\\"abc\\\",\\\"def\\\"],\\\"plural\\\":true}\";\n      assertEquals(om.writeValueAsString(tf), expectedJSON);\n   }","commit_id":"166a871427f06d9075c08af7d65a04a454683c8c","url":"https://github.com/zanata/zanata-server"},{"original_method":"@DB\n    @Override\n    public DataStore createLocalStorage(Host host, StoragePoolInfo pInfo) throws ConnectionException {\n\n        DataCenterVO dc = _dcDao.findById(host.getDataCenterId());\n        if (dc == null || !dc.isLocalStorageEnabled()) {\n            return null;\n        }\n        DataStore store = null;\n        try {\n            StoragePoolVO pool = _storagePoolDao.findPoolByHostPath(host.getDataCenterId(), host.getPodId(), pInfo.getHost(), pInfo.getHostPath(),\n                    pInfo.getUuid());\n            if (pool == null && host.getHypervisorType() == HypervisorType.VMware) {\n                // perform run-time upgrade. In versions prior to 2.2.12, there\n                // is a bug that we don't save local datastore info (host path\n                // is empty), this will cause us\n                // not able to distinguish multiple local datastores that may be\n                // available on the host, to support smooth migration, we\n                // need to perform runtime upgrade here\n                if (pInfo.getHostPath().length() > 0) {\n                    pool = _storagePoolDao.findPoolByHostPath(host.getDataCenterId(), host.getPodId(), pInfo.getHost(), \"\", pInfo.getUuid());\n                }\n            }\n            DataStoreProvider provider = this.dataStoreProviderMgr.getDefaultPrimaryDataStoreProvider();\n            DataStoreLifeCycle lifeCycle = provider.getDataStoreLifeCycle();\n            if (pool == null) {\n                Map<String, Object> params = new HashMap<String, Object>();\n                String name = (host.getName() + \" Local Storage\");\n                params.put(\"zoneId\", host.getDataCenterId());\n                params.put(\"clusterId\", host.getClusterId());\n                params.put(\"podId\", host.getPodId());\n                params.put(\"url\", pInfo.getPoolType().toString() + \"://\" + pInfo.getHost() + \"/\" + pInfo.getHostPath());\n                params.put(\"name\", name);\n                params.put(\"localStorage\", true);\n                params.put(\"details\", pInfo.getDetails());\n                params.put(\"uuid\", pInfo.getUuid());\n                params.put(\"providerName\", provider.getName());\n\n                store = lifeCycle.initialize(params);\n            } else {\n                store = (DataStore) dataStoreMgr.getDataStore(pool.getId(), DataStoreRole.Primary);\n            }\n\n            HostScope scope = new HostScope(host.getId(), host.getDataCenterId());\n            lifeCycle.attachHost(store, scope, pInfo);\n        } catch (Exception e) {\n            s_logger.warn(\"Unable to setup the local storage pool for \" + host, e);\n            throw new ConnectionException(true, \"Unable to setup the local storage pool for \" + host, e);\n        }\n\n        return (DataStore) dataStoreMgr.getDataStore(store.getId(), DataStoreRole.Primary);\n    }","id":30563,"modified_method":"@DB\n    @Override\n    public DataStore createLocalStorage(Host host, StoragePoolInfo pInfo) throws ConnectionException {\n\n        DataCenterVO dc = _dcDao.findById(host.getDataCenterId());\n        if (dc == null || !dc.isLocalStorageEnabled()) {\n            return null;\n        }\n        DataStore store = null;\n        try {\n            StoragePoolVO pool = _storagePoolDao.findPoolByHostPath(host.getDataCenterId(), host.getPodId(), pInfo.getHost(), pInfo.getHostPath(),\n                    pInfo.getUuid());\n            if (pool == null && host.getHypervisorType() == HypervisorType.VMware) {\n                // perform run-time upgrade. In versions prior to 2.2.12, there\n                // is a bug that we don't save local datastore info (host path\n                // is empty), this will cause us\n                // not able to distinguish multiple local datastores that may be\n                // available on the host, to support smooth migration, we\n                // need to perform runtime upgrade here\n                if (pInfo.getHostPath().length() > 0) {\n                    pool = _storagePoolDao.findPoolByHostPath(host.getDataCenterId(), host.getPodId(), pInfo.getHost(), \"\", pInfo.getUuid());\n                }\n            }\n            DataStoreProvider provider = this.dataStoreProviderMgr.getDefaultPrimaryDataStoreProvider();\n            DataStoreLifeCycle lifeCycle = provider.getDataStoreLifeCycle();\n            if (pool == null) {\n                Map<String, Object> params = new HashMap<String, Object>();\n                String name = (host.getName() + \" Local Storage\");\n                params.put(\"zoneId\", host.getDataCenterId());\n                params.put(\"clusterId\", host.getClusterId());\n                params.put(\"podId\", host.getPodId());\n                params.put(\"url\", pInfo.getPoolType().toString() + \"://\" + pInfo.getHost() + \"/\" + pInfo.getHostPath());\n                params.put(\"name\", name);\n                params.put(\"localStorage\", true);\n                params.put(\"details\", pInfo.getDetails());\n                params.put(\"uuid\", pInfo.getUuid());\n                params.put(\"providerName\", provider.getName());\n\n                store = lifeCycle.initialize(params);\n            } else {\n                store = dataStoreMgr.getDataStore(pool.getId(), DataStoreRole.Primary);\n            }\n\n            HostScope scope = new HostScope(host.getId(), host.getDataCenterId());\n            lifeCycle.attachHost(store, scope, pInfo);\n        } catch (Exception e) {\n            s_logger.warn(\"Unable to setup the local storage pool for \" + host, e);\n            throw new ConnectionException(true, \"Unable to setup the local storage pool for \" + host, e);\n        }\n\n        return dataStoreMgr.getDataStore(store.getId(), DataStoreRole.Primary);\n    }","commit_id":"2c31f38c05c16d661812cb89317eb2d4e6c8faf3","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public void cleanupSecondaryStorage(boolean recurring) {\n        try {\n            // Cleanup templates in secondary storage hosts\n            List<DataStore> imageStores = this.dataStoreMgr.getImageStoresByScope(new ZoneScope(null));\n            for (DataStore store : imageStores) {\n                try {\n                    long storeId = store.getId();\n                    List<TemplateDataStoreVO> destroyedTemplateStoreVOs = this._templateStoreDao.listDestroyed(storeId);\n                    s_logger.debug(\"Secondary storage garbage collector found \" + destroyedTemplateStoreVOs.size()\n                            + \" templates to cleanup on secondary storage host: \" + store.getName());\n                    for (TemplateDataStoreVO destroyedTemplateStoreVO : destroyedTemplateStoreVOs) {\n                        if (!_tmpltMgr.templateIsDeleteable(destroyedTemplateStoreVO.getTemplateId())) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Not deleting template at: \" + destroyedTemplateStoreVO);\n                            }\n                            continue;\n                        }\n\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Deleting template store: \" + destroyedTemplateStoreVO);\n                        }\n\n                        VMTemplateVO destroyedTemplate = this._vmTemplateDao.findById(destroyedTemplateStoreVO.getTemplateId());\n                        if (destroyedTemplate == null) {\n                            s_logger.error(\"Cannot find template : \" + destroyedTemplateStoreVO.getTemplateId() + \" from template table\");\n                            throw new CloudRuntimeException(\"Template \" + destroyedTemplateStoreVO.getTemplateId()\n                                    + \" is found in secondary storage, but not found in template table\");\n                        }\n                        String installPath = destroyedTemplateStoreVO.getInstallPath();\n\n                        TemplateInfo tmpl = tmplFactory.getTemplate(destroyedTemplateStoreVO.getTemplateId(), store);\n                        if (installPath != null) {\n                            EndPoint ep = _epSelector.select(store);\n                            Command cmd = new DeleteCommand(tmpl.getTO());\n                            Answer answer = ep.sendMessage(cmd);\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.debug(\"Failed to delete \" + destroyedTemplateStoreVO + \" due to \"\n                                        + ((answer == null) ? \"answer is null\" : answer.getDetails()));\n                            } else {\n                                _templateStoreDao.remove(destroyedTemplateStoreVO.getId());\n                                s_logger.debug(\"Deleted template at: \" + destroyedTemplateStoreVO.getInstallPath());\n                            }\n                        } else {\n                            _templateStoreDao.remove(destroyedTemplateStoreVO.getId());\n                        }\n                    }\n                } catch (Exception e) {\n                    s_logger.warn(\"problem cleaning up templates in secondary storage store \" + store.getName(), e);\n                }\n            }\n\n            // CleanUp snapshots on Secondary Storage.\n            for (DataStore store : imageStores) {\n                try {\n                    List<SnapshotDataStoreVO> destroyedSnapshotStoreVOs = _snapshotStoreDao.listDestroyed(store.getId());\n                    s_logger.debug(\"Secondary storage garbage collector found \" + destroyedSnapshotStoreVOs.size()\n                            + \" snapshots to cleanup on secondary storage host: \" + store.getName());\n                    for (SnapshotDataStoreVO destroyedSnapshotStoreVO : destroyedSnapshotStoreVOs) {\n                        // check if this snapshot has child\n                        SnapshotInfo snap = snapshotFactory.getSnapshot(destroyedSnapshotStoreVO.getSnapshotId(), store);\n                        if ( snap.getChild() != null ){\n                            s_logger.debug(\"Skip snapshot on store: \" + destroyedSnapshotStoreVO + \" , because it has child\");\n                            continue;\n                        }\n\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Deleting snapshot on store: \" + destroyedSnapshotStoreVO);\n                        }\n\n                        String installPath = destroyedSnapshotStoreVO.getInstallPath();\n\n                        if (installPath != null) {\n                            EndPoint ep = _epSelector.select(store);\n                            DeleteCommand cmd = new DeleteCommand(snap.getTO());\n                            Answer answer = ep.sendMessage(cmd);\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.debug(\"Failed to delete \" + destroyedSnapshotStoreVO + \" due to \"\n                                        + ((answer == null) ? \"answer is null\" : answer.getDetails()));\n                            } else {\n                                _volumeStoreDao.remove(destroyedSnapshotStoreVO.getId());\n                                s_logger.debug(\"Deleted snapshot at: \" + destroyedSnapshotStoreVO.getInstallPath());\n                            }\n                        } else {\n                            _snapshotStoreDao.remove(destroyedSnapshotStoreVO.getId());\n                        }\n                    }\n\n                } catch (Exception e2) {\n                    s_logger.warn(\"problem cleaning up snapshots in secondary storage store \" + store.getName(), e2);\n                }\n\n            }\n\n            // CleanUp volumes on Secondary Storage.\n            for (DataStore store : imageStores) {\n                try {\n                    List<VolumeDataStoreVO> destroyedStoreVOs = _volumeStoreDao.listDestroyed(store.getId());\n                    s_logger.debug(\"Secondary storage garbage collector found \" + destroyedStoreVOs.size()\n                            + \" volumes to cleanup on secondary storage host: \" + store.getName());\n                    for (VolumeDataStoreVO destroyedStoreVO : destroyedStoreVOs) {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Deleting volume on store: \" + destroyedStoreVO);\n                        }\n\n                        String installPath = destroyedStoreVO.getInstallPath();\n\n                        VolumeInfo vol = this.volFactory.getVolume(destroyedStoreVO.getVolumeId(), store);\n\n                        if (installPath != null) {\n                            EndPoint ep = _epSelector.select(store);\n                            DeleteCommand cmd = new DeleteCommand(vol.getTO());\n                            Answer answer = ep.sendMessage(cmd);\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.debug(\"Failed to delete \" + destroyedStoreVO + \" due to \"\n                                        + ((answer == null) ? \"answer is null\" : answer.getDetails()));\n                            } else {\n                                _volumeStoreDao.remove(destroyedStoreVO.getId());\n                                s_logger.debug(\"Deleted volume at: \" + destroyedStoreVO.getInstallPath());\n                            }\n                        } else {\n                            _volumeStoreDao.remove(destroyedStoreVO.getId());\n                        }\n                    }\n\n                } catch (Exception e2) {\n                    s_logger.warn(\"problem cleaning up volumes in secondary storage store \" + store.getName(), e2);\n                }\n            }\n        } catch (Exception e3) {\n            s_logger.warn(\"problem cleaning up secondary storage \", e3);\n        }\n    }","id":30564,"modified_method":"@Override\n    @DB\n    public void cleanupSecondaryStorage(boolean recurring) {\n        // NOTE that object_store refactor will immediately delete the object from secondary storage when deleteTemplate etc api is issued.\n        // so here we don't need to issue DeleteCommand to resource anymore, only need to remove db entry.\n        try {\n            // Cleanup templates in template_store_ref\n            List<DataStore> imageStores = this.dataStoreMgr.getImageStoresByScope(new ZoneScope(null));\n            for (DataStore store : imageStores) {\n                try {\n                    long storeId = store.getId();\n                    List<TemplateDataStoreVO> destroyedTemplateStoreVOs = this._templateStoreDao.listDestroyed(storeId);\n                    s_logger.debug(\"Secondary storage garbage collector found \" + destroyedTemplateStoreVOs.size()\n                            + \" templates to cleanup on template_store_ref for store: \" + store.getName());\n                    for (TemplateDataStoreVO destroyedTemplateStoreVO : destroyedTemplateStoreVOs) {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Deleting template store DB entry: \" + destroyedTemplateStoreVO);\n                        }\n                        _templateStoreDao.remove(destroyedTemplateStoreVO.getId());\n                    }\n                } catch (Exception e) {\n                    s_logger.warn(\"problem cleaning up templates in template_store_ref for store: \" + store.getName(), e);\n                }\n            }\n\n            // CleanUp snapshots on snapshot_store_ref\n            for (DataStore store : imageStores) {\n                try {\n                    List<SnapshotDataStoreVO> destroyedSnapshotStoreVOs = _snapshotStoreDao.listDestroyed(store.getId());\n                    s_logger.debug(\"Secondary storage garbage collector found \" + destroyedSnapshotStoreVOs.size()\n                            + \" snapshots to cleanup on snapshot_store_ref for store: \" + store.getName());\n                    for (SnapshotDataStoreVO destroyedSnapshotStoreVO : destroyedSnapshotStoreVOs) {\n                        // check if this snapshot has child\n                        SnapshotInfo snap = snapshotFactory.getSnapshot(destroyedSnapshotStoreVO.getSnapshotId(), store);\n                        if ( snap.getChild() != null ){\n                            s_logger.debug(\"Skip snapshot on store: \" + destroyedSnapshotStoreVO + \" , because it has child\");\n                            continue;\n                        }\n\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Deleting snapshot store DB entry: \" + destroyedSnapshotStoreVO);\n                        }\n\n                        _snapshotStoreDao.remove(destroyedSnapshotStoreVO.getId());\n                    }\n\n                } catch (Exception e2) {\n                    s_logger.warn(\"problem cleaning up snapshots in snapshot_store_ref for store: \" + store.getName(), e2);\n                }\n\n            }\n\n            // CleanUp volumes on volume_store_ref\n            for (DataStore store : imageStores) {\n                try {\n                    List<VolumeDataStoreVO> destroyedStoreVOs = _volumeStoreDao.listDestroyed(store.getId());\n                    s_logger.debug(\"Secondary storage garbage collector found \" + destroyedStoreVOs.size()\n                            + \" volumes to cleanup on volume_store_ref for store: \" + store.getName());\n                    for (VolumeDataStoreVO destroyedStoreVO : destroyedStoreVOs) {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Deleting volume store DB entry: \" + destroyedStoreVO);\n                        }\n                        _volumeStoreDao.remove(destroyedStoreVO.getId());\n                    }\n\n                } catch (Exception e2) {\n                    s_logger.warn(\"problem cleaning up volumes in volume_store_ref for store: \" + store.getName(), e2);\n                }\n            }\n        } catch (Exception e3) {\n            s_logger.warn(\"problem cleaning up secondary storage DB entries. \", e3);\n        }\n    }","commit_id":"2c31f38c05c16d661812cb89317eb2d4e6c8faf3","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Answer cloneVolume(DataObject template, DataObject volume) {\n        CopyCommand cmd = new CopyCommand(template.getTO(), volume.getTO(), 0);\n        StoragePool pool = (StoragePool)volume.getDataStore();\n\n        try {\n            Answer answer = storageMgr.sendToPool(pool, null, cmd);\n            return answer;\n        } catch (StorageUnavailableException e) {\n            s_logger.debug(\"Failed to send to storage pool\", e);\n            throw new CloudRuntimeException(\"Failed to send to storage pool\", e);\n        }\n    }","id":30565,"modified_method":"protected Answer cloneVolume(DataObject template, DataObject volume) {\n        CopyCommand cmd = new CopyCommand(template.getTO(), volume.getTO(), 0);\n        try {\n            EndPoint ep = this.selector.select(volume.getDataStore());\n            Answer answer = ep.sendMessage(cmd);\n            return answer;\n        } catch (Exception e) {\n            s_logger.debug(\"Failed to send to storage pool\", e);\n            throw new CloudRuntimeException(\"Failed to send to storage pool\", e);\n        }\n    }","commit_id":"acafccfbc68d46362fd952107bd298be0d2cfc3e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Void copyAsync(DataObject srcData, DataObject destData,\n            AsyncCompletionCallback<CopyCommandResult> callback) {\n        Answer answer = null;\n        String errMsg = null;\n        try {\n            if (destData.getType() == DataObjectType.VOLUME\n                    && srcData.getType() == DataObjectType.VOLUME && srcData.getDataStore().getRole() == DataStoreRole.Image) {\n            \tanswer = copyVolumeFromImage(srcData, destData);\n            } else if (destData.getType() == DataObjectType.TEMPLATE\n                    && srcData.getType() == DataObjectType.TEMPLATE) {\n            \tanswer = copyTemplate(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.SNAPSHOT\n                    && destData.getType() == DataObjectType.VOLUME) {\n            \tanswer = copyVolumeFromSnapshot(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.SNAPSHOT\n                    && destData.getType() == DataObjectType.TEMPLATE) {\n            \tanswer = createTemplateFromSnapshot(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.VOLUME\n                    && destData.getType() == DataObjectType.TEMPLATE) {\n            \tanswer = createTemplateFromVolume(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.TEMPLATE\n                    && destData.getType() == DataObjectType.VOLUME) {\n            \tanswer = cloneVolume(srcData, destData);\n            } else if (destData.getType() == DataObjectType.VOLUME\n                    && srcData.getType() == DataObjectType.VOLUME && srcData.getDataStore().getRole() == DataStoreRole.Primary) {\n            \tanswer = copyVolumeBetweenPools(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.SNAPSHOT &&\n            \t\tdestData.getType() == DataObjectType.SNAPSHOT) {\n            \tanswer = copySnapshot(srcData, destData);\n            }\n        } catch (Exception e) {\n            s_logger.debug(\"copy failed\", e);\n            errMsg = e.toString();\n        }\n        CopyCommandResult result = new CopyCommandResult(null, answer);\n        if (!answer.getResult()) {\n            result.setResult(answer.getDetails());\n        }\n        callback.complete(result);\n\n        return null;\n    }","id":30566,"modified_method":"@Override\n    public Void copyAsync(DataObject srcData, DataObject destData,\n            AsyncCompletionCallback<CopyCommandResult> callback) {\n        Answer answer = null;\n        String errMsg = null;\n        try {\n            if (destData.getType() == DataObjectType.VOLUME\n                    && srcData.getType() == DataObjectType.VOLUME && srcData.getDataStore().getRole() == DataStoreRole.Image) {\n            \tanswer = copyVolumeFromImage(srcData, destData);\n            } else if (destData.getType() == DataObjectType.TEMPLATE\n                    && srcData.getType() == DataObjectType.TEMPLATE) {\n            \tanswer = copyTemplate(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.SNAPSHOT\n                    && destData.getType() == DataObjectType.VOLUME) {\n            \tanswer = copyVolumeFromSnapshot(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.SNAPSHOT\n                    && destData.getType() == DataObjectType.TEMPLATE) {\n            \tanswer = createTemplateFromSnapshot(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.VOLUME\n                    && destData.getType() == DataObjectType.TEMPLATE) {\n            \tanswer = createTemplateFromVolume(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.TEMPLATE\n                    && destData.getType() == DataObjectType.VOLUME) {\n            \tanswer = cloneVolume(srcData, destData);\n            } else if (destData.getType() == DataObjectType.VOLUME\n                    && srcData.getType() == DataObjectType.VOLUME && srcData.getDataStore().getRole() == DataStoreRole.Primary) {\n            \tanswer = copyVolumeBetweenPools(srcData, destData);\n            } else if (srcData.getType() == DataObjectType.SNAPSHOT &&\n            \t\tdestData.getType() == DataObjectType.SNAPSHOT) {\n            \tanswer = copySnapshot(srcData, destData);\n            }\n            \n            if (answer != null && !answer.getResult()) {\n                errMsg = answer.getDetails();\n            }\n        } catch (Exception e) {\n            s_logger.debug(\"copy failed\", e);\n            errMsg = e.toString();\n        }\n        CopyCommandResult result = new CopyCommandResult(null, answer);\n        result.setResult(errMsg);\n        callback.complete(result);\n        return null;\n    }","commit_id":"acafccfbc68d46362fd952107bd298be0d2cfc3e","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    protected void createVolumeFromBaseImageAsync(VolumeInfo volume, DataObject templateOnPrimaryStore, PrimaryDataStore pd, AsyncCallFuture<VolumeApiResult> future) {\n        VolumeObject vo = (VolumeObject)volume;\n        CreateVolumeFromBaseImageContext<VolumeApiResult> context = new CreateVolumeFromBaseImageContext<VolumeApiResult>(null, vo, pd, templateOnPrimaryStore, future, null);\n        AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller =  AsyncCallbackDispatcher.create(this);\n        caller.setCallback(caller.getTarget().createVolumeFromBaseImageCallBack(null, null))\n        .setContext(context);\n\n        DataObject volumeOnPrimaryStorage = pd.create(volume);\n        volume.processEvent(Event.CreateOnlyRequested);\n\n        motionSrv.copyAsync(context.templateOnStore, volumeOnPrimaryStorage, caller);\n        return;\n    }","id":30567,"modified_method":"@DB\n    protected void createVolumeFromBaseImageAsync(VolumeInfo volume, DataObject templateOnPrimaryStore, PrimaryDataStore pd, AsyncCallFuture<VolumeApiResult> future) {\n        DataObject volumeOnPrimaryStorage = pd.create(volume);\n        volumeOnPrimaryStorage.processEvent(Event.CreateOnlyRequested);\n        \n        CreateVolumeFromBaseImageContext<VolumeApiResult> context = new CreateVolumeFromBaseImageContext<VolumeApiResult>(null, volumeOnPrimaryStorage, pd, templateOnPrimaryStore, future, null);\n        AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller =  AsyncCallbackDispatcher.create(this);\n        caller.setCallback(caller.getTarget().createVolumeFromBaseImageCallBack(null, null));\n        caller.setContext(context);\n\n        motionSrv.copyAsync(context.templateOnStore, volumeOnPrimaryStorage, caller);\n        return;\n    }","commit_id":"acafccfbc68d46362fd952107bd298be0d2cfc3e","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Void createVolumeFromSnapshotCallback(AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> callback,\n    \t\tCreateVolumeFromBaseImageContext<VolumeApiResult> context) {\n    \tCopyCommandResult result = callback.getResult();\n    \tVolumeInfo volume = context.vo;\n    \tSnapshotInfo snapshot = context.snapshot;\n    \tVolumeApiResult apiResult = new VolumeApiResult(volume);\n    \tEvent event = null;\n    \tif (result.isFailed()) {\n    \t\tapiResult.setResult(result.getResult());\n    \t\tevent = Event.OperationFailed;\n    \t} else {\n    \t\tevent = Event.OperationSuccessed;\n    \t}\n\n    \ttry {\n    \t\tvolume.processEvent(event);\n    \t\tsnapshot.processEvent(event);\n    \t} catch (Exception e) {\n    \t\ts_logger.debug(\"create volume from snapshot failed\", e);\n    \t\tapiResult.setResult(e.toString());\n    \t}\n\n    \tAsyncCallFuture<VolumeApiResult> future = context.future;\n    \tfuture.complete(apiResult);\n    \treturn null;\n    }","id":30568,"modified_method":"protected Void createVolumeFromSnapshotCallback(AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> callback,\n    \t\tCreateVolumeFromBaseImageContext<VolumeApiResult> context) {\n    \tCopyCommandResult result = callback.getResult();\n    \tVolumeInfo volume = (VolumeInfo)context.vo;\n    \tSnapshotInfo snapshot = context.snapshot;\n    \tVolumeApiResult apiResult = new VolumeApiResult(volume);\n    \tEvent event = null;\n    \tif (result.isFailed()) {\n    \t\tapiResult.setResult(result.getResult());\n    \t\tevent = Event.OperationFailed;\n    \t} else {\n    \t\tevent = Event.OperationSuccessed;\n    \t}\n\n    \ttry {\n    \t\tvolume.processEvent(event);\n    \t\tsnapshot.processEvent(event);\n    \t} catch (Exception e) {\n    \t\ts_logger.debug(\"create volume from snapshot failed\", e);\n    \t\tapiResult.setResult(e.toString());\n    \t}\n\n    \tAsyncCallFuture<VolumeApiResult> future = context.future;\n    \tfuture.complete(apiResult);\n    \treturn null;\n    }","commit_id":"acafccfbc68d46362fd952107bd298be0d2cfc3e","url":"https://github.com/apache/cloudstack"},{"original_method":"public CreateVolumeFromBaseImageContext(AsyncCompletionCallback<T> callback, VolumeObject vo,\n                DataStore primaryStore,\n                DataObject templateOnStore,\n                AsyncCallFuture<VolumeApiResult> future, SnapshotInfo snapshot) {\n            super(callback);\n            this.vo = vo;\n            this.future = future;\n            this.primaryStore = primaryStore;\n            this.templateOnStore = templateOnStore;\n            this.snapshot = snapshot;\n        }","id":30569,"modified_method":"public CreateVolumeFromBaseImageContext(AsyncCompletionCallback<T> callback, DataObject vo,\n                DataStore primaryStore,\n                DataObject templateOnStore,\n                AsyncCallFuture<VolumeApiResult> future, SnapshotInfo snapshot) {\n            super(callback);\n            this.vo = vo;\n            this.future = future;\n            this.primaryStore = primaryStore;\n            this.templateOnStore = templateOnStore;\n            this.snapshot = snapshot;\n        }","commit_id":"acafccfbc68d46362fd952107bd298be0d2cfc3e","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    protected Void createVolumeFromBaseImageCallBack(AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> callback, CreateVolumeFromBaseImageContext<VolumeApiResult> context) {\n        VolumeObject vo = context.vo;\n        CopyCommandResult result = callback.getResult();\n        VolumeApiResult volResult = new VolumeApiResult(vo);\n\n        if (result.isSuccess()) {\n            vo.processEvent(Event.OperationSuccessed, result.getAnswer());\n        } else {\n            vo.processEvent(Event.OperationFailed);\n            volResult.setResult(result.getResult());\n        }\n\n        AsyncCallFuture<VolumeApiResult> future = context.getFuture();\n        future.complete(volResult);\n        return null;\n    }","id":30570,"modified_method":"@DB\n    protected Void createVolumeFromBaseImageCallBack(AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> callback, CreateVolumeFromBaseImageContext<VolumeApiResult> context) {\n        DataObject vo = context.vo;\n        CopyCommandResult result = callback.getResult();\n        VolumeApiResult volResult = new VolumeApiResult((VolumeObject)vo);\n\n        if (result.isSuccess()) {\n            vo.processEvent(Event.OperationSuccessed, result.getAnswer());\n        } else {\n            vo.processEvent(Event.OperationFailed);\n            volResult.setResult(result.getResult());\n        }\n\n        AsyncCallFuture<VolumeApiResult> future = context.getFuture();\n        future.complete(volResult);\n        return null;\n    }","commit_id":"acafccfbc68d46362fd952107bd298be0d2cfc3e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type) Mockito.any(), Mockito.anyLong(), Mockito.anyLong(), Mockito.anyLong())).thenReturn(hosts);\n        Mockito.when(epSelector.select(Mockito.any(DataObject.class))).thenReturn(new LocalHostEndpoint());\n        RemoteHostEndPoint ep = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host.getId(), this.host.getPrivateIpAddress());\n        Mockito.when(epSelector.select(Mockito.any(DataObject.class), Mockito.any(DataObject.class))).thenReturn(ep);\n    }","id":30571,"modified_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type) Mockito.any(), Mockito.anyLong(), Mockito.anyLong(), Mockito.anyLong())).thenReturn(hosts);\n        \n        RemoteHostEndPoint ep = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host.getId(), this.host.getPrivateIpAddress());\n        Mockito.when(epSelector.select(Mockito.any(DataObject.class), Mockito.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Mockito.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Mockito.any(DataStore.class))).thenReturn(ep);\n    }","commit_id":"acafccfbc68d46362fd952107bd298be0d2cfc3e","url":"https://github.com/apache/cloudstack"},{"original_method":"private boolean supportedByHypervisor(VolumeInfo volume) {\n    \tStoragePool storagePool = (StoragePool)volume.getDataStore();\n        ClusterVO cluster = _clusterDao.findById(storagePool.getClusterId());\n        if (cluster != null && cluster.getHypervisorType() == HypervisorType.Ovm) {\n            throw new InvalidParameterValueException(\"Ovm won't support taking snapshot\");\n        }\n\n\t\tif (volume.getHypervisorType().equals(HypervisorType.KVM)) {\n\t\t\tList<HostVO> hosts = _resourceMgr.listAllHostsInCluster(cluster.getId());\n\t\t\tif (hosts != null && !hosts.isEmpty()) {\n\t\t\t\tHostVO host = hosts.get(0);\n\t\t\t\tif (!hostSupportSnapsthot(host)) {\n\t\t\t\t\tthrow new CloudRuntimeException(\"KVM Snapshot is not supported on cluster: \" + host.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if volume is attached to a vm in destroyed or expunging state; disallow\n\t\tif (volume.getInstanceId() != null) {\n\t\t\tUserVmVO userVm = _vmDao.findById(volume.getInstanceId());\n\t\t\tif (userVm != null) {\n                if (userVm.getState().equals(State.Destroyed) || userVm.getState().equals(State.Expunging)) {\n                    throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volume.getId()\n                            + \" is associated with vm:\" + userVm.getInstanceName() + \" is in \"\n                            + userVm.getState().toString() + \" state\");\n                }\n\n                if (userVm.getHypervisorType() == HypervisorType.VMware\n                        || userVm.getHypervisorType() == HypervisorType.KVM) {\n                    List<SnapshotVO> activeSnapshots = _snapshotDao.listByInstanceId(volume.getInstanceId(),\n                            Snapshot.State.Creating, Snapshot.State.CreatedOnPrimary, Snapshot.State.BackingUp);\n                    if (activeSnapshots.size() > 1) {\n                        throw new CloudRuntimeException(\n                                \"There is other active snapshot tasks on the instance to which the volume is attached, please try again later\");\n                    }\n                }\n\n                List<VMSnapshotVO> activeVMSnapshots = _vmSnapshotDao.listByInstanceId(userVm.getId(),\n                        VMSnapshot.State.Creating, VMSnapshot.State.Reverting, VMSnapshot.State.Expunging);\n                if (activeVMSnapshots.size() > 0) {\n                    throw new CloudRuntimeException(\n                            \"There is other active vm snapshot tasks on the instance to which the volume is attached, please try again later\");\n                }\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","id":30572,"modified_method":"private boolean supportedByHypervisor(VolumeInfo volume) {\n        HypervisorType hypervisorType;\n        StoragePoolVO storagePool = _storagePoolDao.findById(volume.getDataStore().getId());\n        ScopeType scope = storagePool.getScope();\n        if (scope.equals(ScopeType.ZONE)) {\n            hypervisorType = storagePool.getHypervisor();\n        } else {\n            hypervisorType = volume.getHypervisorType();\n        }\n\n        if (hypervisorType.equals(HypervisorType.Ovm)) {\n            throw new InvalidParameterValueException(\"Ovm won't support taking snapshot\");\n        }\n\n        if (hypervisorType.equals(HypervisorType.KVM)) {\n            List<HostVO> hosts = null;\n            if(scope.equals(ScopeType.CLUSTER)){\n                ClusterVO cluster = _clusterDao.findById(storagePool.getClusterId());\n                hosts = _resourceMgr.listAllHostsInCluster(cluster.getId());\n            } else if (scope.equals(ScopeType.ZONE)){\n                hosts = _resourceMgr.listAllUpAndEnabledHostsInOneZoneByHypervisor(hypervisorType, volume.getDataCenterId());\n            }\n            if (hosts != null && !hosts.isEmpty()) {\n                HostVO host = hosts.get(0);\n                if (!hostSupportSnapsthot(host)) {\n                    throw new CloudRuntimeException(\"KVM Snapshot is not supported: \" + host.getId());\n                }\n            }\n        }\n\n\t\t// if volume is attached to a vm in destroyed or expunging state; disallow\n\t\tif (volume.getInstanceId() != null) {\n\t\t\tUserVmVO userVm = _vmDao.findById(volume.getInstanceId());\n\t\t\tif (userVm != null) {\n                if (userVm.getState().equals(State.Destroyed) || userVm.getState().equals(State.Expunging)) {\n                    throw new CloudRuntimeException(\"Creating snapshot failed due to volume:\" + volume.getId()\n                            + \" is associated with vm:\" + userVm.getInstanceName() + \" is in \"\n                            + userVm.getState().toString() + \" state\");\n                }\n\n                if (userVm.getHypervisorType() == HypervisorType.VMware\n                        || userVm.getHypervisorType() == HypervisorType.KVM) {\n                    List<SnapshotVO> activeSnapshots = _snapshotDao.listByInstanceId(volume.getInstanceId(),\n                            Snapshot.State.Creating, Snapshot.State.CreatedOnPrimary, Snapshot.State.BackingUp);\n                    if (activeSnapshots.size() > 1) {\n                        throw new CloudRuntimeException(\n                                \"There is other active snapshot tasks on the instance to which the volume is attached, please try again later\");\n                    }\n                }\n\n                List<VMSnapshotVO> activeVMSnapshots = _vmSnapshotDao.listByInstanceId(userVm.getId(),\n                        VMSnapshot.State.Creating, VMSnapshot.State.Reverting, VMSnapshot.State.Expunging);\n                if (activeVMSnapshots.size() > 0) {\n                    throw new CloudRuntimeException(\n                            \"There is other active vm snapshot tasks on the instance to which the volume is attached, please try again later\");\n                }\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"536fd0e8a1d215d9a6fcb460cf946558d00bfe44","url":"https://github.com/apache/cloudstack"},{"original_method":"/** {@inheritDoc} */\n    public void initialize(NewExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(NewLoggingSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, ADD_INSTANCE, NewLoggingSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(\"set-root-logger\", NewRootLoggerAdd.INSTANCE, NewLoggingSubsystemProviders.SET_ROOT_LOGGER, false);\n        registration.registerOperationHandler(\"remove-root-logger\", NewRootLoggerRemove.INSTANCE, NewLoggingSubsystemProviders.SET_ROOT_LOGGER, false);\n        // loggers\n        final ModelNodeRegistration loggers = registration.registerSubModel(loggersPath, NewLoggingSubsystemProviders.LOGGER);\n        loggers.registerOperationHandler(ADD, NewLoggerAdd.INSTANCE, NewLoggingSubsystemProviders.LOGGER_ADD, false);\n        loggers.registerOperationHandler(REMOVE, NewLoggerRemove.INSTANCE, NewLoggingSubsystemProviders.LOGGER_REMOVE, false);\n        // handlers\n        final ModelNodeRegistration handlers = registration.registerSubModel(handlersPath, NewLoggingSubsystemProviders.HANDLERS);\n        handlers.registerOperationHandler(ADD, NewLoggerHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.HANDLER_ADD, false);\n        handlers.registerOperationHandler(REMOVE, NewLoggerHandlerRemove.INSTANCE, NewLoggingSubsystemProviders.HANDLER_REMOVE, false);\n        handlers.registerOperationHandler(\"add-async-handler\", NewAsyncHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.ASYNC_HANDLER_ADD, false);\n        handlers.registerOperationHandler(\"add-console-handler\", NewConsoleHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.CONSOLE_HANDLER_ADD, false);\n        handlers.registerOperationHandler(\"add-file-handler\", NewFileHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.FILE_HANDLER_ADD, false);\n        handlers.registerOperationHandler(\"add-periodic-handler\", NewPeriodicFileHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.PERIODIC_HANDLER_ADD, false);\n        handlers.registerOperationHandler(\"add-size-periodic-handler\", NewSizePeriodicFileHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.SIZE_PERIODIC_HANDLER_ADD, false);\n    }","id":30573,"modified_method":"/** {@inheritDoc} */\n    public void initialize(NewExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ModelNodeRegistration registration = subsystem.registerSubsystemModel(NewLoggingSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, ADD_INSTANCE, NewLoggingSubsystemProviders.SUBSYSTEM_ADD, false);\n        registration.registerOperationHandler(\"set-root-logger\", NewRootLoggerAdd.INSTANCE, NewLoggingSubsystemProviders.SET_ROOT_LOGGER, false);\n        registration.registerOperationHandler(\"remove-root-logger\", NewRootLoggerRemove.INSTANCE, NewLoggingSubsystemProviders.SET_ROOT_LOGGER, false);\n        // loggers\n        final ModelNodeRegistration loggers = registration.registerSubModel(loggersPath, NewLoggingSubsystemProviders.LOGGER);\n        loggers.registerOperationHandler(ADD, NewLoggerAdd.INSTANCE, NewLoggingSubsystemProviders.LOGGER_ADD, false);\n        loggers.registerOperationHandler(REMOVE, NewLoggerRemove.INSTANCE, NewLoggingSubsystemProviders.LOGGER_REMOVE, false);\n        // handlers\n        final ModelNodeRegistration handlers = registration.registerSubModel(handlersPath, NewLoggingSubsystemProviders.HANDLERS);\n        handlers.registerOperationHandler(ADD, NewLoggerHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.HANDLER_ADD, false);\n        handlers.registerOperationHandler(REMOVE, NewLoggerHandlerRemove.INSTANCE, NewLoggingSubsystemProviders.HANDLER_REMOVE, false);\n        handlers.registerOperationHandler(\"add-async-handler\", NewAsyncHandlerAdd.INSTANCE, NewAsyncHandlerAdd.INSTANCE, false);\n        handlers.registerOperationHandler(\"add-console-handler\", NewConsoleHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.CONSOLE_HANDLER_ADD, false);\n        handlers.registerOperationHandler(\"add-file-handler\", NewFileHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.FILE_HANDLER_ADD, false);\n        handlers.registerOperationHandler(\"add-periodic-handler\", NewPeriodicFileHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.PERIODIC_HANDLER_ADD, false);\n        handlers.registerOperationHandler(\"add-size-periodic-handler\", NewSizePeriodicFileHandlerAdd.INSTANCE, NewLoggingSubsystemProviders.SIZE_PERIODIC_HANDLER_ADD, false);\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process the security settings.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     */\n    static void processSecuritySettings(final Configuration configuration, final ModelNode params) {\n        if(params.has(SECURITY_SETTING)) {\n            for(final Property property : params.get(SECURITY_SETTING).asPropertyList()) {\n                final String match = property.getName();\n                final ModelNode config = property.getValue();\n                if(config.getType() != ModelType.UNDEFINED) {\n                    final Set<Role> roles = new HashSet<Role>();\n                    for(final Property role : config.asPropertyList()) {\n                        final String name = role.getName();\n                        final ModelNode value = role.getValue();\n                        roles.add(new Role(name, value.get(SEND_NAME).asBoolean(false),\n                                value.get(CONSUME_NAME).asBoolean(false), value.get(CREATEDURABLEQUEUE_NAME).asBoolean(false),\n                                value.get(DELETEDURABLEQUEUE_NAME).asBoolean(false), value.get(CREATE_NON_DURABLE_QUEUE_NAME).asBoolean(false),\n                                value.get(DELETE_NON_DURABLE_QUEUE_NAME).asBoolean(false), value.get(MANAGE_NAME).asBoolean(false)));\n                    }\n                    configuration.getSecurityRoles().put(match, roles);\n                }\n            }\n        }\n    }","id":30574,"modified_method":"/**\n     * Process the security settings.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     */\n    static void processSecuritySettings(final Configuration configuration, final ModelNode params) {\n        if(params.get(SECURITY_SETTING).isDefined()) {\n            for(final Property property : params.get(SECURITY_SETTING).asPropertyList()) {\n                final String match = property.getName();\n                final ModelNode config = property.getValue();\n                if(config.getType() != ModelType.UNDEFINED) {\n                    final Set<Role> roles = new HashSet<Role>();\n                    for(final Property role : config.asPropertyList()) {\n                        final String name = role.getName();\n                        final ModelNode value = role.getValue();\n                        roles.add(new Role(name, value.get(SEND_NAME).asBoolean(false),\n                                value.get(CONSUME_NAME).asBoolean(false), value.get(CREATEDURABLEQUEUE_NAME).asBoolean(false),\n                                value.get(DELETEDURABLEQUEUE_NAME).asBoolean(false), value.get(CREATE_NON_DURABLE_QUEUE_NAME).asBoolean(false),\n                                value.get(DELETE_NON_DURABLE_QUEUE_NAME).asBoolean(false), value.get(MANAGE_NAME).asBoolean(false)));\n                    }\n                    configuration.getSecurityRoles().put(match, roles);\n                }\n            }\n        }\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process the acceptor information.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     * @param bindings the referenced socket bindings\n     */\n    static void processAcceptors(final Configuration configuration, final ModelNode params, final Set<String> bindings) {\n        if(params.has(ACCEPTOR)) {\n            final Map<String, TransportConfiguration> acceptors = new HashMap<String, TransportConfiguration>();\n            for(final Property property : params.get(ACCEPTOR).asPropertyList()) {\n                final String acceptorName = property.getName();\n                final ModelNode config = property.getValue();\n                final Map<String, Object> parameters = new HashMap<String, Object>();\n                if(config.has(PARAM) && config.get(PARAM).getType() != ModelType.UNDEFINED) {\n                    for(final Property parameter : config.get(PARAM).asPropertyList()) {\n                        parameters.put(parameter.getName(), parameter.getValue().asString());\n                    }\n                }\n                final TransportConfigType type = TransportConfigType.valueOf(config.get(TYPE).asString());\n                final String clazz;\n                switch(type) {\n                    case Remote: {\n                        clazz = NettyAcceptorFactory.class.getName();\n                        final String binding = config.get(SOCKET_BINDING).asString();\n                        parameters.put(SOCKET_BINDING, binding);\n                        bindings.add(binding);\n                        break;\n                    } case InVM: {\n                        clazz = InVMAcceptorFactory.class.getName();\n                        parameters.put(SERVER_ID, config.get(SERVER_ID).asInt());\n                        break;\n                    } case Generic: {\n                        clazz = config.get(FACTORY_CLASS).asString();\n                        break;\n                    } default: {\n                        clazz = null;\n                        break;\n                    }\n                }\n                acceptors.put(acceptorName, new TransportConfiguration(clazz, parameters, acceptorName));\n            }\n            configuration.setAcceptorConfigurations(new HashSet<TransportConfiguration>(acceptors.values()));\n        }\n    }","id":30575,"modified_method":"/**\n     * Process the acceptor information.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     * @param bindings the referenced socket bindings\n     */\n    static void processAcceptors(final Configuration configuration, final ModelNode params, final Set<String> bindings) {\n        if(params.has(ACCEPTOR)) {\n            final Map<String, TransportConfiguration> acceptors = new HashMap<String, TransportConfiguration>();\n            for(final Property property : params.get(ACCEPTOR).asPropertyList()) {\n                final String acceptorName = property.getName();\n                final ModelNode config = property.getValue();\n                final Map<String, Object> parameters = new HashMap<String, Object>();\n                if(config.get(PARAM).isDefined()) {\n                    for(final Property parameter : config.get(PARAM).asPropertyList()) {\n                        parameters.put(parameter.getName(), parameter.getValue().asString());\n                    }\n                }\n                final TransportConfigType type = TransportConfigType.valueOf(config.get(TYPE).asString());\n                final String clazz;\n                switch(type) {\n                    case Remote: {\n                        clazz = NettyAcceptorFactory.class.getName();\n                        final String binding = config.get(SOCKET_BINDING).asString();\n                        parameters.put(SOCKET_BINDING, binding);\n                        bindings.add(binding);\n                        break;\n                    } case InVM: {\n                        clazz = InVMAcceptorFactory.class.getName();\n                        parameters.put(SERVER_ID, config.get(SERVER_ID).asInt());\n                        break;\n                    } case Generic: {\n                        clazz = config.get(FACTORY_CLASS).asString();\n                        break;\n                    } default: {\n                        clazz = null;\n                        break;\n                    }\n                }\n                acceptors.put(acceptorName, new TransportConfiguration(clazz, parameters, acceptorName));\n            }\n            configuration.setAcceptorConfigurations(new HashSet<TransportConfiguration>(acceptors.values()));\n        }\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process the address settings.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     */\n    static void processAddressSettings(final Configuration configuration, final ModelNode params) {\n        if(params.has(ADDRESS_SETTING)) {\n            for(final Property property : params.get(ADDRESS_SETTING).asPropertyList()) {\n                final String match = property.getName();\n                final ModelNode config = property.getValue();\n\n                final AddressSettings settings = new AddressSettings();\n                final AddressFullMessagePolicy addressPolicy = config.has(ADDRESS_FULL_MESSAGE_POLICY) ?\n                        AddressFullMessagePolicy.valueOf(config.get(ADDRESS_FULL_MESSAGE_POLICY).asString()) : AddressSettings.DEFAULT_ADDRESS_FULL_MESSAGE_POLICY;\n                settings.setAddressFullMessagePolicy(addressPolicy);\n                settings.setDeadLetterAddress(asSimpleString(config.get(DEAD_LETTER_ADDRESS), null));\n                settings.setLastValueQueue(config.get(LVQ).asBoolean(AddressSettings.DEFAULT_LAST_VALUE_QUEUE));\n                settings.setMaxDeliveryAttempts(config.get(MAX_DELIVERY_ATTEMPTS).asInt(AddressSettings.DEFAULT_MAX_DELIVERY_ATTEMPTS));\n                settings.setMaxSizeBytes(config.get(MAX_SIZE_BYTES_NODE_NAME).asInt((int) AddressSettings.DEFAULT_MAX_SIZE_BYTES));\n                settings.setMessageCounterHistoryDayLimit(config.get(MESSAGE_COUNTER_HISTORY_DAY_LIMIT).asInt(AddressSettings.DEFAULT_MESSAGE_COUNTER_HISTORY_DAY_LIMIT));\n                settings.setExpiryAddress(asSimpleString(config.get(EXPIRY_ADDRESS), null));\n                settings.setRedeliveryDelay(config.get(REDELIVERY_DELAY).asInt((int) AddressSettings.DEFAULT_REDELIVER_DELAY));\n                settings.setRedistributionDelay(config.get(REDISTRIBUTION_DELAY).asInt((int) AddressSettings.DEFAULT_REDISTRIBUTION_DELAY));\n                settings.setPageSizeBytes(config.get(PAGE_SIZE_BYTES_NODE_NAME).asInt((int) AddressSettings.DEFAULT_PAGE_SIZE));\n                settings.setSendToDLAOnNoRoute(config.get(SEND_TO_DLA_ON_NO_ROUTE).asBoolean(AddressSettings.DEFAULT_SEND_TO_DLA_ON_NO_ROUTE));\n\n                configuration.getAddressesSettings().put(match, settings);\n            }\n        }\n    }","id":30576,"modified_method":"/**\n     * Process the address settings.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     */\n    static void processAddressSettings(final Configuration configuration, final ModelNode params) {\n        if(params.get(ADDRESS_SETTING).isDefined()) {\n            for(final Property property : params.get(ADDRESS_SETTING).asPropertyList()) {\n                final String match = property.getName();\n                final ModelNode config = property.getValue();\n\n                final AddressSettings settings = new AddressSettings();\n                final AddressFullMessagePolicy addressPolicy = config.has(ADDRESS_FULL_MESSAGE_POLICY) ?\n                        AddressFullMessagePolicy.valueOf(config.get(ADDRESS_FULL_MESSAGE_POLICY).asString()) : AddressSettings.DEFAULT_ADDRESS_FULL_MESSAGE_POLICY;\n                settings.setAddressFullMessagePolicy(addressPolicy);\n                settings.setDeadLetterAddress(asSimpleString(config.get(DEAD_LETTER_ADDRESS), null));\n                settings.setLastValueQueue(config.get(LVQ).asBoolean(AddressSettings.DEFAULT_LAST_VALUE_QUEUE));\n                settings.setMaxDeliveryAttempts(config.get(MAX_DELIVERY_ATTEMPTS).asInt(AddressSettings.DEFAULT_MAX_DELIVERY_ATTEMPTS));\n                settings.setMaxSizeBytes(config.get(MAX_SIZE_BYTES_NODE_NAME).asInt((int) AddressSettings.DEFAULT_MAX_SIZE_BYTES));\n                settings.setMessageCounterHistoryDayLimit(config.get(MESSAGE_COUNTER_HISTORY_DAY_LIMIT).asInt(AddressSettings.DEFAULT_MESSAGE_COUNTER_HISTORY_DAY_LIMIT));\n                settings.setExpiryAddress(asSimpleString(config.get(EXPIRY_ADDRESS), null));\n                settings.setRedeliveryDelay(config.get(REDELIVERY_DELAY).asInt((int) AddressSettings.DEFAULT_REDELIVER_DELAY));\n                settings.setRedistributionDelay(config.get(REDISTRIBUTION_DELAY).asInt((int) AddressSettings.DEFAULT_REDISTRIBUTION_DELAY));\n                settings.setPageSizeBytes(config.get(PAGE_SIZE_BYTES_NODE_NAME).asInt((int) AddressSettings.DEFAULT_PAGE_SIZE));\n                settings.setSendToDLAOnNoRoute(config.get(SEND_TO_DLA_ON_NO_ROUTE).asBoolean(AddressSettings.DEFAULT_SEND_TO_DLA_ON_NO_ROUTE));\n\n                configuration.getAddressesSettings().put(match, settings);\n            }\n        }\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process the HornetQ core queues.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     */\n    static void processCoreQueues(final Configuration configuration, final ModelNode params) {\n        if(params.has(QUEUE)) {\n            final List<CoreQueueConfiguration> queues = new ArrayList<CoreQueueConfiguration>();\n            for(final Property property : params.get(QUEUE).asPropertyList()) {\n                final String queueName = property.getName();\n                final ModelNode config = property.getValue();\n                final CoreQueueConfiguration queue = new CoreQueueConfiguration(config.get(CommonAttributes.ADDRESS).asString(), queueName,\n                        config.get(FILTER).asString(), config.get(DURABLE).asBoolean());\n                queues.add(queue);\n            }\n            configuration.setQueueConfigurations(queues);\n        }\n    }","id":30577,"modified_method":"/**\n     * Process the HornetQ core queues.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     */\n    static void processCoreQueues(final Configuration configuration, final ModelNode params) {\n        if(params.get(QUEUE).isDefined()) {\n            final List<CoreQueueConfiguration> queues = new ArrayList<CoreQueueConfiguration>();\n            for(final Property property : params.get(QUEUE).asPropertyList()) {\n                final String queueName = property.getName();\n                final ModelNode config = property.getValue();\n                final CoreQueueConfiguration queue = new CoreQueueConfiguration(config.get(CommonAttributes.ADDRESS).asString(), queueName,\n                        config.get(FILTER).asString(), config.get(DURABLE).asBoolean());\n                queues.add(queue);\n            }\n            configuration.setQueueConfigurations(queues);\n        }\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext context, ModelNode operation, ResultHandler resultHandler) {\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        if(context instanceof NewRuntimeOperationContext) {\n            final NewRuntimeOperationContext updateContext = (NewRuntimeOperationContext) context;\n            final ServiceTarget serviceTarget = updateContext.getServiceTarget();\n            // Create the HornetQ Service\n            final HornetQService hqService = new HornetQService();\n            // Transform the configuration\n            final Configuration configuration = transformConfig(operation);\n\n            // Add the HornetQ Service\n            final ServiceBuilder<HornetQServer> serviceBuilder = serviceTarget.addService(MessagingSubsystemElement.JBOSS_MESSAGING, hqService)\n                .addDependency(DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"mbean\", \"server\"), MBeanServer.class, hqService.getMBeanServer());\n            // Create path services\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_BINDINGS_DIR, operation.get(BINDINGS_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_BINDINGS_DIR));\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_JOURNAL_DIR, operation.get(JOURNAL_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_JOURNAL_DIR));\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_LARGE_MESSSAGE_DIR, operation.get(LARGE_MESSAGES_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_LARGE_MESSSAGE_DIR));\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_PAGING_DIR, operation.get(PAGING_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_PAGING_DIR));\n\n            // Proccess acceptors and connectors\n            final Set<String> socketBindings = new HashSet<String>();\n            processAcceptors(configuration, operation, socketBindings);\n            processConnectors(configuration, operation, socketBindings);\n            for(final String socketBinding : socketBindings) {\n                final ServiceName socketName = SocketBinding.JBOSS_BINDING_NAME.append(socketBinding);\n                serviceBuilder.addDependency(socketName, SocketBinding.class, hqService.getSocketBindingInjector(socketBinding));\n            }\n            hqService.setConfiguration(configuration);\n\n            // Install the HornetQ Service\n            serviceBuilder.install();\n\n            // TODO this should be added by the jms subsystem itself\n            JMSService.addService(serviceTarget);\n        }\n\n        // Populate subModel\n        final ModelNode subModel = context.getSubModel();\n        subModel.setEmptyObject();\n        for(final String attribute : NewMessagingSubsystemProviders.MESSAGING_ROOT_ATTRIBUTES) {\n            if(operation.has(attribute)) {\n                subModel.get(attribute).set(operation.get(attribute));\n            }\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":30578,"modified_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext context, ModelNode operation, ResultHandler resultHandler) {\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        if(context instanceof NewRuntimeOperationContext) {\n            final NewRuntimeOperationContext updateContext = (NewRuntimeOperationContext) context;\n            final ServiceTarget serviceTarget = updateContext.getServiceTarget();\n            // Create the HornetQ Service\n            final HornetQService hqService = new HornetQService();\n            // Transform the configuration\n            final Configuration configuration = transformConfig(operation);\n\n            // Add the HornetQ Service\n            final ServiceBuilder<HornetQServer> serviceBuilder = serviceTarget.addService(MessagingSubsystemElement.JBOSS_MESSAGING, hqService)\n                .addDependency(DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"mbean\", \"server\"), MBeanServer.class, hqService.getMBeanServer());\n            // Create path services\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_BINDINGS_DIR, operation.get(BINDINGS_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_BINDINGS_DIR));\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_JOURNAL_DIR, operation.get(JOURNAL_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_JOURNAL_DIR));\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_LARGE_MESSSAGE_DIR, operation.get(LARGE_MESSAGES_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_LARGE_MESSSAGE_DIR));\n            serviceBuilder.addDependency(createDirectoryService(DEFAULT_PAGING_DIR, operation.get(PAGING_DIRECTORY), serviceTarget),\n                        String.class, hqService.getPathInjector(DEFAULT_PAGING_DIR));\n\n            // Proccess acceptors and connectors\n            final Set<String> socketBindings = new HashSet<String>();\n            processAcceptors(configuration, operation, socketBindings);\n            processConnectors(configuration, operation, socketBindings);\n            for(final String socketBinding : socketBindings) {\n                final ServiceName socketName = SocketBinding.JBOSS_BINDING_NAME.append(socketBinding);\n                serviceBuilder.addDependency(socketName, SocketBinding.class, hqService.getSocketBindingInjector(socketBinding));\n            }\n            hqService.setConfiguration(configuration);\n\n            // Install the HornetQ Service\n            serviceBuilder.install();\n\n            // TODO this should be added by the jms subsystem itself\n            JMSService.addService(serviceTarget);\n        }\n\n        // Populate subModel\n        final ModelNode subModel = context.getSubModel();\n        subModel.setEmptyObject();\n        for(final String attribute : NewMessagingSubsystemProviders.MESSAGING_ROOT_ATTRIBUTES) {\n            if(operation.get(attribute).isDefined()) {\n                subModel.get(attribute).set(operation.get(attribute));\n            }\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process the connector information.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     * @param bindings the referenced socket bindings\n     */\n    static void processConnectors(final Configuration configuration, final ModelNode params, final Set<String> bindings) {\n        if(params.has(CONNECTOR)) {\n            final Map<String, TransportConfiguration> connectors = new HashMap<String, TransportConfiguration>();\n            for(final Property property : params.get(CONNECTOR).asPropertyList()) {\n                final String connectorName = property.getName();\n                final ModelNode config = property.getValue();\n                final Map<String, Object> parameters = new HashMap<String, Object>();\n                if(config.has(PARAM) && config.get(PARAM).getType() != ModelType.UNDEFINED) {\n                    for(final Property parameter : config.get(PARAM).asPropertyList()) {\n                        parameters.put(parameter.getName(), parameter.getValue().asString());\n                    }\n                }\n                final TransportConfigType type = TransportConfigType.valueOf(config.get(TYPE).asString());\n                final String clazz;\n                switch(type) {\n                    case Remote: {\n                        clazz = NettyConnectorFactory.class.getName();\n                        final String binding = config.get(SOCKET_BINDING).asString();\n                        parameters.put(SOCKET_BINDING, binding);\n                        bindings.add(binding);\n                        break;\n                    } case InVM: {\n                        clazz = InVMConnectorFactory.class.getName();\n                        parameters.put(SERVER_ID, config.get(SERVER_ID).asInt());\n                        break;\n                    } case Generic: {\n                        clazz = config.get(FACTORY_CLASS).asString();\n                        break;\n                    } default: {\n                        clazz = null;\n                        break;\n                    }\n                }\n                connectors.put(connectorName, new TransportConfiguration(clazz, parameters, connectorName));\n            }\n            configuration.setConnectorConfigurations(connectors);\n        }\n    }","id":30579,"modified_method":"/**\n     * Process the connector information.\n     *\n     * @param configuration the hornetQ configuration\n     * @param params the detyped operation parameters\n     * @param bindings the referenced socket bindings\n     */\n    static void processConnectors(final Configuration configuration, final ModelNode params, final Set<String> bindings) {\n        if(params.has(CONNECTOR)) {\n            final Map<String, TransportConfiguration> connectors = new HashMap<String, TransportConfiguration>();\n            for(final Property property : params.get(CONNECTOR).asPropertyList()) {\n                final String connectorName = property.getName();\n                final ModelNode config = property.getValue();\n                final Map<String, Object> parameters = new HashMap<String, Object>();\n                if(config.get(PARAM).isDefined()) {\n                    for(final Property parameter : config.get(PARAM).asPropertyList()) {\n                        parameters.put(parameter.getName(), parameter.getValue().asString());\n                    }\n                }\n                final TransportConfigType type = TransportConfigType.valueOf(config.get(TYPE).asString());\n                final String clazz;\n                switch(type) {\n                    case Remote: {\n                        clazz = NettyConnectorFactory.class.getName();\n                        final String binding = config.get(SOCKET_BINDING).asString();\n                        parameters.put(SOCKET_BINDING, binding);\n                        bindings.add(binding);\n                        break;\n                    } case InVM: {\n                        clazz = InVMConnectorFactory.class.getName();\n                        parameters.put(SERVER_ID, config.get(SERVER_ID).asInt());\n                        break;\n                    } case Generic: {\n                        clazz = config.get(FACTORY_CLASS).asString();\n                        break;\n                    } default: {\n                        clazz = null;\n                        break;\n                    }\n                }\n                connectors.put(connectorName, new TransportConfiguration(clazz, parameters, connectorName));\n            }\n            configuration.setConnectorConfigurations(connectors);\n        }\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void main(String[] args) throws Exception {\n        ModelControllerClient client = null;\n        try {\n            System.out.println(\"Connecting\");\n            client = ModelControllerClient.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n            System.out.println(\"Connected\");\n\n            ModelNode request = new ModelNode();\n            request.get(\"operation\").set(\"read-resource\");\n            request.get(\"address\").setEmptyList();\n            // request.get(\"address\").set(\"subsystem\", \"threads\");\n            request.get(\"recursive\").set(true);\n            ModelNode r = client.execute(request);\n            System.out.println(r);\n\n//            System.out.println(\"--- Synchronous simple operation\");\n//            ModelNode result = client.execute(createOperation(0));\n//            System.out.println(\"Received synchronous result \" + result);\n//\n//            System.out.println(\"--- Synchronous operation\");\n//            client.execute(createOperation(0), new TestResultHandler());\n//\n//\n//            System.out.println(\"--- Asynchronous operation\");\n//            TestResultHandler handler = new TestResultHandler();\n//            Cancellable operation = client.execute(createOperation(1000), handler);\n//            System.out.println(\"Control returned to client\");\n//            handler.waitForFragment();\n//            System.out.println(\"Fragment signalled\");\n//            handler.waitForComplete();\n//\n//            System.out.println(\"--- Asynchronous cancelled operation\");\n//            TestResultHandler handler2 = new TestResultHandler();\n//            Cancellable operation2 = client.execute(createOperation(1000), handler2);\n//            handler2.waitForFragment();\n//            operation2.cancel();\n//            handler2.waitForComplete();\n\n        } finally {\n            StreamUtils.safeClose(client);\n            System.out.println(\"Closed\");\n        }\n    }","id":30580,"modified_method":"public static void main(String[] args) throws Exception {\n        ModelControllerClient client = null;\n        try {\n            System.out.println(\"Connecting\");\n            client = ModelControllerClient.Factory.create(InetAddress.getByName(\"localhost\"), 9999);\n            System.out.println(\"Connected\");\n\n            {\n                ModelNode request = new ModelNode();\n                request.get(\"operation\").set(\"read-resource\");\n                request.get(\"address\").setEmptyList();\n                // request.get(\"address\").set(\"subsystem\", \"threads\");\n                request.get(\"recursive\").set(true);\n                ModelNode r = client.execute(request);\n                System.out.println(r);\n            }\n            {\n                ModelNode request = new ModelNode();\n                request.get(\"operation\").set(\"read-operation-description\");\n                request.get(\"address\").setEmptyList();\n                request.get(\"address\").set(\"subsystem\", \"logging\");\n                request.get(\"recursive\").set(true);\n                request.get(\"name\").set(\"add\");\n                ModelNode r = client.execute(request);\n                System.out.println(r);\n            }\n\n//            System.out.println(\"--- Synchronous simple operation\");\n//            ModelNode result = client.execute(createOperation(0));\n//            System.out.println(\"Received synchronous result \" + result);\n//\n//            System.out.println(\"--- Synchronous operation\");\n//            client.execute(createOperation(0), new TestResultHandler());\n//\n//\n//            System.out.println(\"--- Asynchronous operation\");\n//            TestResultHandler handler = new TestResultHandler();\n//            Cancellable operation = client.execute(createOperation(1000), handler);\n//            System.out.println(\"Control returned to client\");\n//            handler.waitForFragment();\n//            System.out.println(\"Fragment signalled\");\n//            handler.waitForComplete();\n//\n//            System.out.println(\"--- Asynchronous cancelled operation\");\n//            TestResultHandler handler2 = new TestResultHandler();\n//            Cancellable operation2 = client.execute(createOperation(1000), handler2);\n//            handler2.waitForFragment();\n//            operation2.cancel();\n//            handler2.waitForComplete();\n\n        } finally {\n            StreamUtils.safeClose(client);\n            System.out.println(\"Closed\");\n        }\n    }","commit_id":"667fd25bc26e8c9077629cf812c4495cf451a433","url":"https://github.com/wildfly/wildfly"},{"original_method":"FileSystemDeploymentService(final String relativeTo, final File deploymentDir, final File relativeToDir,\n            final ModelControllerClient controllerClient, final ScheduledExecutorService scheduledExecutor,\n            final ServerDeploymentRepository deploymentRepository, final ContentRepository contentRepository)\n            throws OperationFailedException {\n        if (contentRepository == null) {\n            throw MESSAGES.nullVar(\"contentRepository\");\n        }\n        if (scheduledExecutor == null) {\n            throw MESSAGES.nullVar(\"scheduledExecutor\");\n        }\n        if (controllerClient == null) {\n            throw MESSAGES.nullVar(\"controllerClient\");\n        }\n        if (deploymentRepository == null) {\n            throw MESSAGES.nullVar(\"deploymentRepository\");\n        }\n        if (deploymentDir == null) {\n            throw MESSAGES.nullVar(\"deploymentDir\");\n        }\n        if (!deploymentDir.exists()) {\n            throw MESSAGES.directoryDoesNotExist(deploymentDir.getAbsolutePath());\n        }\n        if (!deploymentDir.isDirectory()) {\n            throw MESSAGES.notADirectory(deploymentDir.getAbsolutePath());\n        }\n        if (!deploymentDir.canWrite()) {\n            throw MESSAGES.directoryNotWritable(deploymentDir.getAbsolutePath());\n        }\n        this.relativeTo = relativeTo;\n        this.deploymentDir = deploymentDir;\n        this.controllerClient = controllerClient;\n        this.scheduledExecutor = scheduledExecutor;\n        this.deploymentRepository = deploymentRepository;\n        this.contentRepository = contentRepository;\n\n        if (relativeToDir != null) {\n            String fullDir = deploymentDir.getAbsolutePath();\n            String relDir = relativeToDir.getAbsolutePath();\n            String sub = fullDir.substring(relDir.length());\n            if (sub.startsWith(File.separator)) {\n                sub = sub.length() == 1 ? \"\" : sub.substring(1);\n            }\n            this.relativePath = sub.length() > 0 ? sub + \"/\" : sub;\n        } else {\n            relativePath = null;\n        }\n        establishDeployedContentList(deploymentDir);\n    }","id":30581,"modified_method":"FileSystemDeploymentService(final String relativeTo, final File deploymentDir, final File relativeToDir,\n            final ModelControllerClient controllerClient, final ScheduledExecutorService scheduledExecutor,\n            final ServerDeploymentRepository deploymentRepository, final ContentRepository contentRepository)\n            throws OperationFailedException {\n        if (contentRepository == null) {\n            throw MESSAGES.nullVar(\"contentRepository\");\n        }\n        if (scheduledExecutor == null) {\n            throw MESSAGES.nullVar(\"scheduledExecutor\");\n        }\n        if (controllerClient == null) {\n            throw MESSAGES.nullVar(\"controllerClient\");\n        }\n        if (deploymentRepository == null) {\n            throw MESSAGES.nullVar(\"deploymentRepository\");\n        }\n        if (deploymentDir == null) {\n            throw MESSAGES.nullVar(\"deploymentDir\");\n        }\n        if (!deploymentDir.exists()) {\n            throw MESSAGES.directoryDoesNotExist(deploymentDir.getAbsolutePath());\n        }\n        if (!deploymentDir.isDirectory()) {\n            throw MESSAGES.notADirectory(deploymentDir.getAbsolutePath());\n        }\n        if (!deploymentDir.canWrite()) {\n            throw MESSAGES.directoryNotWritable(deploymentDir.getAbsolutePath());\n        }\n        this.relativeTo = relativeTo;\n        this.deploymentDir = deploymentDir;\n        this.controllerClient = controllerClient;\n        this.scheduledExecutor = scheduledExecutor;\n        this.deploymentRepository = deploymentRepository;\n        this.contentRepository = contentRepository;\n\n        if (relativeToDir != null) {\n            String fullDir = deploymentDir.getAbsolutePath();\n            String relDir = relativeToDir.getAbsolutePath();\n            String sub = fullDir.substring(relDir.length());\n            if (sub.startsWith(File.separator)) {\n                sub = sub.length() == 1 ? \"\" : sub.substring(1);\n            }\n            this.relativePath = sub.length() > 0 ? sub + File.separator : sub;\n        } else {\n            relativePath = null;\n        }\n        establishDeployedContentList(deploymentDir);\n    }","commit_id":"dc5326ebec4d1c620a925982f50b8e5a7123116b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MailServerDefinition(PathElement path) {\n        super(path, MailExtension.getResourceDescriptionResolver(MailSubsystemModel.SERVER_TYPE), MailServerAdd.INSTANCE, MailServerRemove.INSTANCE);\n    }","id":30582,"modified_method":"private MailServerDefinition(PathElement path) {\n        super(path, MailExtension.getResourceDescriptionResolver(MailSubsystemModel.SERVER_TYPE), MailServerAdd.INSTANCE, ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","commit_id":"dc5326ebec4d1c620a925982f50b8e5a7123116b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Credentials readCredentials(final OperationContext operationContext, final ModelNode model) throws OperationFailedException {\n        if (model.has(USER_NAME)) {\n            String un = model.get(USER_NAME).asString();\n            String pw = operationContext.resolveExpressions((model.get(PASSWORD))).asString();\n            return new Credentials(un, pw);\n        }\n        return null;\n    }","id":30583,"modified_method":"private static Credentials readCredentials(final OperationContext operationContext, final ModelNode model) throws OperationFailedException {\n        if (model.get(USER_NAME).isDefined()){\n            String un = model.get(USER_NAME).asString();\n            String pw = operationContext.resolveExpressions((model.get(PASSWORD))).asString();\n            return new Credentials(un, pw);\n        }\n        return null;\n    }","commit_id":"dc5326ebec4d1c620a925982f50b8e5a7123116b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MailSessionDefinition() {\n        super(PathElement.pathElement(MailSubsystemModel.MAIL_SESSION),\n                MailExtension.getResourceDescriptionResolver(MailSubsystemModel.MAIL_SESSION),\n                MailSessionAdd.INSTANCE, MailSessionRemove.INSTANCE);\n    }","id":30584,"modified_method":"private MailSessionDefinition() {\n        super(PathElement.pathElement(MailSubsystemModel.MAIL_SESSION),\n                MailExtension.getResourceDescriptionResolver(MailSubsystemModel.MAIL_SESSION),\n                MailSessionAdd.INSTANCE, ReloadRequiredRemoveStepHandler.INSTANCE);\n    }","commit_id":"dc5326ebec4d1c620a925982f50b8e5a7123116b","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void setServerProps(Properties props, final MailSessionServer server, final String protocol) throws StartException {\n        InetSocketAddress socketAddress = getServerSocketAddress(server);\n        props.setProperty(getHostKey(protocol), socketAddress.getAddress().getHostName());\n        props.setProperty(getPortKey(protocol), String.valueOf(socketAddress.getPort()));\n        if (server.isSslEnabled()) {\n            props.setProperty(getPropKey(protocol, \"ssl.enable\"), \"true\");\n        }\n        if (server.getCredentials() != null) {\n            props.setProperty(getPropKey(protocol, \"auth\"), \"true\");\n            props.setProperty(getPropKey(protocol, \"user\"), server.getCredentials().getUsername());\n        }\n        props.setProperty(getPropKey(protocol, \"debug\"), String.valueOf(config.isDebug()));\n    }","id":30585,"modified_method":"private void setServerProps(Properties props, final MailSessionServer server, final String protocol) throws StartException {\n        InetSocketAddress socketAddress = getServerSocketAddress(server);\n        props.setProperty(getHostKey(protocol), socketAddress.getAddress().getHostName());\n        props.setProperty(getPortKey(protocol), String.valueOf(socketAddress.getPort()));\n        if (server.isSslEnabled()) {\n            props.setProperty(getPropKey(protocol, \"ssl.enable\"), \"true\");\n            props.setProperty(getPropKey(protocol, \"starttls.enable\"), \"true\");\n        }\n        if (server.getCredentials() != null) {\n            props.setProperty(getPropKey(protocol, \"auth\"), \"true\");\n            props.setProperty(getPropKey(protocol, \"user\"), server.getCredentials().getUsername());\n        }\n        props.setProperty(getPropKey(protocol, \"debug\"), String.valueOf(config.isDebug()));\n    }","commit_id":"dc5326ebec4d1c620a925982f50b8e5a7123116b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Configures mail session properties\n     *\n     * @return Properties for session\n     * @throws StartException if socket binding could not be found\n     * @see {http://javamail.kenai.com/nonav/javadocs/com/sun/mail/smtp/package-summary.html}\n     * @see {http://javamail.kenai.com/nonav/javadocs/com/sun/mail/pop3/package-summary.html}\n     * @see {http://javamail.kenai.com/nonav/javadocs/com/sun/mail/imap/package-summary.html}\n     */\n    private Properties getProperties() throws StartException {\n        Properties props = new Properties();\n\n        if (config.getSmtpServer() != null) {\n            props.setProperty(\"mail.transport.protocol\", \"smtp\");\n            setServerProps(props, config.getSmtpServer(), \"smtp\");\n            if (config.getSmtpServer().isSslEnabled()) {\n                props.setProperty(\"mail.smtp.starttls.enable\", \"true\");\n            }\n        }\n        if (config.getImapServer() != null) {\n            setServerProps(props, config.getImapServer(), \"imap\");\n        }\n        if (config.getPop3Server() != null) {\n            setServerProps(props, config.getPop3Server(), \"pop3\");\n        }\n        if (config.getFrom() != null) {\n            props.setProperty(\"mail.from\", config.getFrom());\n        }\n        props.setProperty(\"mail.debug\", String.valueOf(config.isDebug()));\n        log.tracef(\"props: %s\", props);\n        return props;\n    }","id":30586,"modified_method":"/**\n     * Configures mail session properties\n     *\n     * @return Properties for session\n     * @throws StartException if socket binding could not be found\n     * @see {http://javamail.kenai.com/nonav/javadocs/com/sun/mail/smtp/package-summary.html}\n     * @see {http://javamail.kenai.com/nonav/javadocs/com/sun/mail/pop3/package-summary.html}\n     * @see {http://javamail.kenai.com/nonav/javadocs/com/sun/mail/imap/package-summary.html}\n     */\n    private Properties getProperties() throws StartException {\n        Properties props = new Properties();\n\n        if (config.getSmtpServer() != null) {\n            props.setProperty(\"mail.transport.protocol\", \"smtp\");\n            setServerProps(props, config.getSmtpServer(), \"smtp\");\n        }\n        if (config.getImapServer() != null) {\n            setServerProps(props, config.getImapServer(), \"imap\");\n        }\n        if (config.getPop3Server() != null) {\n            setServerProps(props, config.getPop3Server(), \"pop3\");\n        }\n        if (config.getFrom() != null) {\n            props.setProperty(\"mail.from\", config.getFrom());\n        }\n        props.setProperty(\"mail.debug\", String.valueOf(config.isDebug()));\n        log.tracef(\"props: %s\", props);\n        return props;\n    }","commit_id":"dc5326ebec4d1c620a925982f50b8e5a7123116b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerOperations(final ManagementResourceRegistration rootResourceRegistration) {\n        final ResourceDescriptionResolver rootResolver = getResourceDescriptionResolver();\n        // Ops to add and remove the root resource\n        final MailSubsystemAdd subsystemAdd = MailSubsystemAdd.INSTANCE;\n        final DescriptionProvider subsystemAddDescription = new DefaultResourceAddDescriptionProvider(rootResourceRegistration, rootResolver);\n        rootResourceRegistration.registerOperationHandler(ADD, subsystemAdd, subsystemAddDescription, EnumSet.of(OperationEntry.Flag.RESTART_ALL_SERVICES));\n        final DescriptionProvider subsystemRemoveDescription = new DefaultResourceRemoveDescriptionProvider(rootResolver);\n        rootResourceRegistration.registerOperationHandler(REMOVE, MailSubsystemRemove.INSTANCE, subsystemRemoveDescription, EnumSet.of(OperationEntry.Flag.RESTART_ALL_SERVICES));\n    }","id":30587,"modified_method":"@Override\n    public void registerOperations(final ManagementResourceRegistration rootResourceRegistration) {\n        final ResourceDescriptionResolver rootResolver = getResourceDescriptionResolver();\n        // Ops to add and remove the root resource\n        final MailSubsystemAdd subsystemAdd = MailSubsystemAdd.INSTANCE;\n        final DescriptionProvider subsystemAddDescription = new DefaultResourceAddDescriptionProvider(rootResourceRegistration, rootResolver);\n        rootResourceRegistration.registerOperationHandler(ADD, subsystemAdd, subsystemAddDescription, EnumSet.of(OperationEntry.Flag.RESTART_ALL_SERVICES));\n        final DescriptionProvider subsystemRemoveDescription = new DefaultResourceRemoveDescriptionProvider(rootResolver);\n        rootResourceRegistration.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, subsystemRemoveDescription, EnumSet.of(OperationEntry.Flag.RESTART_ALL_SERVICES));\n    }","commit_id":"dc5326ebec4d1c620a925982f50b8e5a7123116b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Statement apply(final Statement base, Description description) {\n        init(description.getMethodName(), description.getTestClass().getSimpleName());\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                base.evaluate();\n                // TODO force deletion by calling 'deleteDir' once we fixed stalling processes\n                getTestDirectory().maybeDeleteDir();\n                // Don't delete on failure\n            }\n        };\n    }","id":30588,"modified_method":"public Statement apply(final Statement base, Description description) {\n        Class<?> testClass = description.getTestClass();\n        init(description.getMethodName(), testClass.getSimpleName());\n        boolean leaksHandles = testClass.getAnnotation(LeaksFileHandles.class) != null || description.getAnnotation(LeaksFileHandles.class) != null;\n        return new TestDirectoryCleaningStatement(base, getTestDirectory(), leaksHandles);\n    }","commit_id":"ab3b1759b42c03a84f9210932ab4b5e556773e3d","url":"https://github.com/gradle/gradle"},{"original_method":"protected Statement doApply(final Statement base, FrameworkMethod method, Object target) {\n        init(method.getName(), target.getClass().getSimpleName());\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                base.evaluate();\n                getTestDirectory().deleteDir();\n                // Don't delete on failure\n            }\n        };\n    }","id":30589,"modified_method":"protected Statement doApply(final Statement base, FrameworkMethod method, Object target) {\n        Class<?> testClass = target.getClass();\n        init(method.getName(), testClass.getSimpleName());\n        boolean leaksHandles = testClass.getAnnotation(LeaksFileHandles.class) != null || method.getAnnotation(LeaksFileHandles.class) != null;\n        return new TestDirectoryCleaningStatement(base, getTestDirectory(), leaksHandles);\n    }","commit_id":"ab3b1759b42c03a84f9210932ab4b5e556773e3d","url":"https://github.com/gradle/gradle"},{"original_method":"public static synchronized Namespace updateNamespaceTestStatus(KubernetesClient client, final Session session, final String test, final String status) {\n        return client.namespaces().withName(session.getNamespace())\n                .edit()\n                .editMetadata()\n                    .addToAnnotations(String.format(Annotations.Tests.TEST_CASE_STATUS_FORMAT, test), status)\n                .endMetadata()\n                .done();\n    }","id":30590,"modified_method":"public static synchronized Namespace updateNamespaceTestStatus(KubernetesClient client, final Session session, final String test, final String status) {\n        return client.namespaces().withName(session.getNamespace())\n                .edit()\n                .editMetadata()\n                    .addToAnnotations(Annotations.Tests.TEST_CASE_STATUS+ test, status)\n                .endMetadata()\n                .done();\n    }","commit_id":"bdee4071a5c65358f084034f7e5903337960cd94","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Performs the given SQL query and return the first row of the result set\n     */\n    public Object firstRow(String sql) throws SQLException {\n        return( rows(sql).get(0));\n    }","id":30591,"modified_method":"/**\n     * Performs the given SQL query and return the first row of the result set\n     */\n    public Object firstRow(String sql) throws SQLException {\n        List rows = rows(sql);\n        if (rows.isEmpty()) return null;\n        return(rows.get(0));\n    }","commit_id":"88c06a350b27952ccb5c5bf3cbc41ebfc66ee3a3","url":"https://github.com/apache/groovy"},{"original_method":"/**\n      * Performs the given SQL query with the list of params and return\n      * the first row of the result set\n      */\n    public Object firstRow(String sql, List params) throws SQLException {\n         return( rows(sql, params).get(0));\n     }","id":30592,"modified_method":"/**\n      * Performs the given SQL query with the list of params and return\n      * the first row of the result set\n      */\n    public Object firstRow(String sql, List params) throws SQLException {\n         List rows = rows(sql, params);\n         if (rows.isEmpty()) return null;\n         return rows.get(0);\n     }","commit_id":"88c06a350b27952ccb5c5bf3cbc41ebfc66ee3a3","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Executing queries locally.\n     *\n     * @param node Node.\n     * @param req Query request.\n     */\n    private void onQueryRequest(ClusterNode node, GridQueryRequest req) {\n        ConcurrentMap<Long,QueryResults> nodeRess = resultsForNode(node.id());\n\n        Collection<GridCacheSqlQuery> qrys;\n\n        try {\n            qrys = req.queries(ctx.config().getMarshaller());\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteException(e);\n        }\n\n        QueryResults qr = new QueryResults(req.requestId(), qrys.size());\n\n        if (nodeRess.putIfAbsent(req.requestId(), qr) != null)\n            throw new IllegalStateException();\n\n        h2.setFilters(h2.backupFilter());\n\n        try {\n            // TODO Prepare snapshots for all the needed tables before the run.\n\n            // Run queries.\n            int i = 0;\n\n            String space = req.space();\n\n            for (GridCacheSqlQuery qry : qrys) {\n                ResultSet rs = h2.executeSqlQueryWithTimer(space, h2.connectionForSpace(space), qry.query(),\n                    F.asList(qry.parameters()));\n\n                if (ctx.event().isRecordable(EVT_CACHE_QUERY_EXECUTED)) {\n                    ctx.event().record(new CacheQueryExecutedEvent<>(\n                        node,\n                        \"SQL query executed.\",\n                        EVT_CACHE_QUERY_EXECUTED,\n                        CacheQueryType.SQL,\n                        null,\n                        null,\n                        qry.query(),\n                        null,\n                        null,\n                        qry.parameters(),\n                        null,\n                        null));\n                }\n\n                assert rs instanceof JdbcResultSet : rs.getClass();\n\n                qr.addResult(i, rs);\n\n                if (qr.canceled) {\n                    qr.result(i).close();\n\n                    throw new IgniteException(\"Query was canceled.\");\n                }\n\n                // Send the first page.\n                sendNextPage(nodeRess, node, qr, i, req.pageSize());\n\n                i++;\n            }\n        }\n        catch (Throwable e) {\n            nodeRess.remove(req.requestId(), qr);\n\n            qr.cancel();\n\n            U.error(log, \"Failed to execute local query: \" + req, e);\n\n            sendError(node, req.requestId(), e);\n        }\n        finally {\n            h2.setFilters(null);\n        }\n    }","id":30593,"modified_method":"/**\n     * Executing queries locally.\n     *\n     * @param node Node.\n     * @param req Query request.\n     */\n    private void onQueryRequest(ClusterNode node, GridQueryRequest req) {\n        ConcurrentMap<Long,QueryResults> nodeRess = resultsForNode(node.id());\n\n        Collection<GridCacheSqlQuery> qrys;\n\n        try {\n            qrys = req.queries(ctx.config().getMarshaller());\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteException(e);\n        }\n\n        QueryResults qr = new QueryResults(req.requestId(), qrys.size());\n\n        if (nodeRess.put(req.requestId(), qr) != null)\n            throw new IllegalStateException();\n\n        h2.setFilters(h2.backupFilter());\n\n        try {\n            // TODO Prepare snapshots for all the needed tables before the run.\n\n            // Run queries.\n            int i = 0;\n\n            String space = req.space();\n\n            for (GridCacheSqlQuery qry : qrys) {\n                ResultSet rs = h2.executeSqlQueryWithTimer(space, h2.connectionForSpace(space), qry.query(),\n                    F.asList(qry.parameters()));\n\n                if (ctx.event().isRecordable(EVT_CACHE_QUERY_EXECUTED)) {\n                    ctx.event().record(new CacheQueryExecutedEvent<>(\n                        node,\n                        \"SQL query executed.\",\n                        EVT_CACHE_QUERY_EXECUTED,\n                        CacheQueryType.SQL,\n                        null,\n                        null,\n                        qry.query(),\n                        null,\n                        null,\n                        qry.parameters(),\n                        null,\n                        null));\n                }\n\n                assert rs instanceof JdbcResultSet : rs.getClass();\n\n                qr.addResult(i, rs);\n\n                if (qr.canceled) {\n                    qr.result(i).close();\n\n                    throw new IgniteException(\"Query was canceled.\");\n                }\n\n                // Send the first page.\n                sendNextPage(nodeRess, node, qr, i, req.pageSize());\n\n                i++;\n            }\n        }\n        catch (Throwable e) {\n            nodeRess.remove(req.requestId(), qr);\n\n            qr.cancel();\n\n            U.error(log, \"Failed to execute local query: \" + req, e);\n\n            sendError(node, req.requestId(), e);\n        }\n        finally {\n            h2.setFilters(null);\n        }\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param ctx Context.\n     * @param h2 H2 Indexing.\n     * @throws IgniteCheckedException If failed.\n     */\n    public void start(final GridKernalContext ctx, IgniteH2Indexing h2) throws IgniteCheckedException {\n        this.ctx = ctx;\n        this.h2 = h2;\n\n        log = ctx.log(GridMapQueryExecutor.class);\n\n        // TODO handle node failures.\n\n        ctx.io().addMessageListener(GridTopic.TOPIC_QUERY, this);\n    }","id":30594,"modified_method":"/**\n     * @param ctx Context.\n     * @param h2 H2 Indexing.\n     * @throws IgniteCheckedException If failed.\n     */\n    public void start(final GridKernalContext ctx, IgniteH2Indexing h2) throws IgniteCheckedException {\n        this.ctx = ctx;\n        this.h2 = h2;\n\n        log = ctx.log(GridMapQueryExecutor.class);\n\n        ctx.event().addLocalEventListener(new GridLocalEventListener() {\n            @Override public void onEvent(final Event evt) {\n                UUID nodeId = ((DiscoveryEvent)evt).eventNode().id();\n\n                ConcurrentMap<Long,QueryResults> nodeRess = qryRess.remove(nodeId);\n\n                if (nodeRess == null)\n                    return;\n\n                for (QueryResults ress : nodeRess.values())\n                    ress.cancel();\n            }\n        }, EventType.EVT_NODE_FAILED, EventType.EVT_NODE_LEFT);\n\n        ctx.io().addMessageListener(GridTopic.TOPIC_QUERY, this);\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected Cursor findInStream(@Nullable SearchRow first, @Nullable SearchRow last) {\n        return new FetchingCursor(new Iterator<Row>() {\n            /** */\n            Iterator<Value[]> iter = Collections.emptyIterator();\n\n            @Override public boolean hasNext() {\n                if (iter.hasNext())\n                    return true;\n\n                GridResultPage page;\n\n                try {\n                    page = queue.take();\n                }\n                catch (InterruptedException e) {\n                    throw new IgniteException(\"Query execution was interrupted.\", e);\n                }\n\n                if (page.isLast()) {\n                    assert queue.isEmpty() : \"It must be the last page: \" + queue;\n\n                    return false; // We are done.\n                }\n\n                fetchNextPage(page);\n\n                iter = page.rows().iterator();\n\n                assert iter.hasNext();\n\n                return true;\n            }\n\n            @Override public Row next() {\n                return new Row(iter.next(), 0);\n            }\n\n            @Override public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        });\n    }","id":30595,"modified_method":"/** {@inheritDoc} */\n    @Override protected Cursor findInStream(@Nullable SearchRow first, @Nullable SearchRow last) {\n        return new FetchingCursor(new Iterator<Row>() {\n            /** */\n            Iterator<Value[]> iter = Collections.emptyIterator();\n\n            @Override public boolean hasNext() {\n                while (!iter.hasNext()){\n                    GridResultPage page;\n\n                    try {\n                        page = queue.take();\n                    }\n                    catch (InterruptedException e) {\n                        throw new CacheException(\"Query execution was interrupted.\", e);\n                    }\n\n                    if (page.isLast())\n                        return false; // We are done.\n\n                    fetchNextPage(page);\n\n                    iter = page.rows().iterator();\n                }\n\n                return true;\n            }\n\n            @Override public Row next() {\n                return new Row(iter.next(), 0);\n            }\n\n            @Override public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        });\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected void addPage0(GridResultPage page) {\n        if (page.rows() != null || page.isLast()) // We are not interested in terminating pages which are not last.\n            queue.add(page);\n    }","id":30596,"modified_method":"/** {@inheritDoc} */\n    @Override protected void addPage0(GridResultPage page) {\n        if (!page.rows().isEmpty() || page.isLast() || queue.isEmpty())\n            queue.add(page);\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param node Node.\n     * @param msg Message.\n     */\n    private void onNextPage(final ClusterNode node, GridQueryNextPageResponse msg) {\n        final long qryReqId = msg.queryRequestId();\n        final int qry = msg.query();\n\n        final QueryRun r = runs.get(qryReqId);\n\n        if (r == null) // Already finished with error or canceled.\n            return;\n\n        final int pageSize = r.pageSize;\n\n        GridMergeIndex idx = r.tbls.get(msg.query()).getScanIndex(null);\n\n        idx.addPage(new GridResultPage(node.id(), msg, false) {\n            @Override public void fetchNextPage() {\n                try {\n                    GridQueryNextPageRequest msg0 = new GridQueryNextPageRequest(qryReqId, qry, pageSize);\n\n                    if (node.isLocal())\n                        h2.mapQueryExecutor().onMessage(ctx.localNodeId(), msg0);\n                    else\n                        ctx.io().send(node, GridTopic.TOPIC_QUERY, msg0, GridIoPolicy.PUBLIC_POOL);\n                }\n                catch (IgniteCheckedException e) {\n                    throw new IgniteException(e);\n                }\n            }\n        });\n\n        if (msg.allRows() != -1) // Only the first page contains row count.\n            r.latch.countDown();\n    }","id":30597,"modified_method":"/**\n     * @param node Node.\n     * @param msg Message.\n     */\n    private void onNextPage(final ClusterNode node, GridQueryNextPageResponse msg) {\n        final long qryReqId = msg.queryRequestId();\n        final int qry = msg.query();\n\n        final QueryRun r = runs.get(qryReqId);\n\n        if (r == null) // Already finished with error or canceled.\n            return;\n\n        final int pageSize = r.pageSize;\n\n        GridMergeIndex idx = r.tbls.get(msg.query()).getScanIndex(null);\n\n        idx.addPage(new GridResultPage(node.id(), msg, false) {\n            @Override public void fetchNextPage() {\n                if (r.rmtErr != null)\n                    throw new CacheException(\"Next page fetch failed.\", r.rmtErr);\n\n                try {\n                    GridQueryNextPageRequest msg0 = new GridQueryNextPageRequest(qryReqId, qry, pageSize);\n\n                    if (node.isLocal())\n                        h2.mapQueryExecutor().onMessage(ctx.localNodeId(), msg0);\n                    else\n                        ctx.io().send(node, GridTopic.TOPIC_QUERY, msg0, GridIoPolicy.PUBLIC_POOL);\n                }\n                catch (IgniteCheckedException e) {\n                    throw new CacheException(e);\n                }\n            }\n        });\n\n        if (msg.allRows() != -1) // Only the first page contains row count.\n            r.latch.countDown();\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param node Node.\n     * @param msg Message.\n     */\n    private void onFail(ClusterNode node, GridQueryFailResponse msg) {\n        QueryRun r = runs.get(msg.queryRequestId());\n\n        if (r != null && r.latch.getCount() != 0) {\n            r.rmtErr = new CacheException(\"Failed to execute map query on the node: \" + node.id() + \"\\n \" + msg.error());\n\n            while(r.latch.getCount() > 0)\n                r.latch.countDown();\n        }\n    }","id":30598,"modified_method":"/**\n     * @param node Node.\n     * @param msg Message.\n     */\n    private void onFail(ClusterNode node, GridQueryFailResponse msg) {\n        QueryRun r = runs.get(msg.queryRequestId());\n\n        fail(r, node.id(), msg.error());\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param ctx Context.\n     * @param h2 H2 Indexing.\n     * @throws IgniteCheckedException If failed.\n     */\n    public void start(final GridKernalContext ctx, IgniteH2Indexing h2) throws IgniteCheckedException {\n        this.ctx = ctx;\n        this.h2 = h2;\n\n        log = ctx.log(GridReduceQueryExecutor.class);\n\n        // TODO handle node failure.\n\n        ctx.io().addMessageListener(GridTopic.TOPIC_QUERY, this);\n\n        h2.executeStatement(\"PUBLIC\", \"CREATE ALIAS \" + GridSqlQuerySplitter.TABLE_FUNC_NAME +\n            \" FOR \\\"\" + GridReduceQueryExecutor.class.getName() + \".mergeTableFunction\\\"\");\n    }","id":30599,"modified_method":"/**\n     * @param ctx Context.\n     * @param h2 H2 Indexing.\n     * @throws IgniteCheckedException If failed.\n     */\n    public void start(final GridKernalContext ctx, IgniteH2Indexing h2) throws IgniteCheckedException {\n        this.ctx = ctx;\n        this.h2 = h2;\n\n        log = ctx.log(GridReduceQueryExecutor.class);\n\n        ctx.io().addMessageListener(GridTopic.TOPIC_QUERY, this);\n\n        ctx.event().addLocalEventListener(new GridLocalEventListener() {\n            @Override public void onEvent(final Event evt) {\n                UUID nodeId = ((DiscoveryEvent)evt).eventNode().id();\n\n                for (QueryRun r : runs.values()) {\n                    for (GridMergeTable tbl : r.tbls) {\n                        if (tbl.getScanIndex(null).hasSource(nodeId)) {\n                            fail(r, nodeId, \"Node left the topology.\");\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }, EventType.EVT_NODE_FAILED, EventType.EVT_NODE_LEFT);\n\n        h2.executeStatement(\"PUBLIC\", \"CREATE ALIAS \" + GridSqlQuerySplitter.TABLE_FUNC_NAME +\n            \" FOR \\\"\" + GridReduceQueryExecutor.class.getName() + \".mergeTableFunction\\\"\");\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param src Source.\n     * @param res Response.\n     * @param last If this is the globally last page.\n     */\n    protected GridResultPage(UUID src, GridQueryNextPageResponse res, boolean last) {\n        assert src != null;\n\n        this.src = src;\n        this.res = res;\n        this.last = last;\n\n        if (last)\n            assert res == null : \"The last page must be dummy.\";\n\n        // res == null means that it is a terminating dummy page for the given source node ID.\n        rows = res == null ? null : GridMapQueryExecutor.unmarshallRows(res.rows());\n    }","id":30600,"modified_method":"/**\n     * @param src Source.\n     * @param res Response.\n     * @param last If this is the globally last page.\n     */\n    public GridResultPage(UUID src, GridQueryNextPageResponse res, boolean last) {\n        assert src != null;\n\n        this.src = src;\n        this.res = res;\n        this.last = last;\n\n        if (last)\n            assert res == null : \"The last page must be dummy.\";\n\n        // res == null means that it is a terminating dummy page for the given source node ID.\n        rows = res == null ? Collections.<Value[]>emptySet() : GridMapQueryExecutor.unmarshallRows(res.rows());\n    }","commit_id":"eacbac44d26c259fbd3c8cb5da57affbd7a7c769","url":"https://github.com/apache/ignite"},{"original_method":"protected AlloySearchResult search(\n\t\t\tMap<String, Serializable> attributes, String keywords, Sort[] sorts)\n\t\tthrows Exception {\n\n\t\tif (indexer == null) {\n\t\t\tthrow new Exception(\"No indexer found for \" + controllerPath);\n\t\t}\n\n\t\tAlloySearchResult alloySearchResult = new AlloySearchResult();\n\n\t\talloySearchResult.setAlloyServiceInvoker(alloyServiceInvoker);\n\n\t\tSearchContainer<BaseModel<?>> searchContainer =\n\t\t\tnew SearchContainer<BaseModel<?>>(\n\t\t\t\tportletRequest, portletURL, null, null);\n\n\t\tSearchContext searchContext = SearchContextFactory.getInstance(request);\n\n\t\tif ((attributes != null) && !attributes.isEmpty()) {\n\t\t\tsearchContext.setAttributes(attributes);\n\t\t}\n\n\t\tsearchContext.setEnd(searchContainer.getEnd());\n\n\t\tClass<?> indexerClass = Class.forName(indexerClassName);\n\n\t\tif (!GroupedModel.class.isAssignableFrom(indexerClass)) {\n\t\t\tsearchContext.setGroupIds(null);\n\t\t}\n\t\telse if ((attributes != null) &&\n\t\t\t\t attributes.containsKey(Field.GROUP_ID)) {\n\n\t\t\tsearchContext.setGroupIds(\n\t\t\t\tnew long[] {(Long)attributes.get(Field.GROUP_ID)});\n\t\t}\n\n\t\tif (Validator.isNotNull(keywords)) {\n\t\t\tsearchContext.setKeywords(keywords);\n\t\t}\n\n\t\tif (ArrayUtil.isNotEmpty(sorts)) {\n\t\t\tsearchContext.setSorts(sorts);\n\t\t}\n\n\t\tsearchContext.setStart(searchContainer.getStart());\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\talloySearchResult.setHits(hits);\n\n\t\talloySearchResult.setPortletURL(portletURL);\n\n\t\talloySearchResult.afterPropertiesSet();\n\n\t\treturn alloySearchResult;\n\t}","id":30601,"modified_method":"protected AlloySearchResult search(\n\t\t\tMap<String, Serializable> attributes, String keywords, Sort[] sorts)\n\t\tthrows Exception {\n\n\t\tif (indexer == null) {\n\t\t\tthrow new Exception(\"No indexer found for \" + controllerPath);\n\t\t}\n\n\t\tAlloySearchResult alloySearchResult = new AlloySearchResult();\n\n\t\talloySearchResult.setAlloyServiceInvoker(alloyServiceInvoker);\n\n\t\tSearchContainer<BaseModel<?>> searchContainer =\n\t\t\tnew SearchContainer<BaseModel<?>>(\n\t\t\t\tportletRequest, portletURL, null, null);\n\n\t\tSearchContext searchContext = SearchContextFactory.getInstance(request);\n\n\t\tif ((attributes != null) && !attributes.isEmpty()) {\n\t\t\tsearchContext.setAttributes(attributes);\n\t\t}\n\n\t\tsearchContext.setEnd(searchContainer.getEnd());\n\n\t\tClass<?> indexerClass = Class.forName(indexerClassName);\n\n\t\tif (!GroupedModel.class.isAssignableFrom(indexerClass)) {\n\t\t\tsearchContext.setGroupIds(null);\n\t\t}\n\t\telse if (searchContext.getAttribute(Field.GROUP_ID) != null) {\n\t\t\tlong groupId = GetterUtil.getLong(\n\t\t\t\tsearchContext.getAttribute(Field.GROUP_ID));\n\n\t\t\tsearchContext.setGroupIds(new long[] {groupId});\n\t\t}\n\n\t\tif (Validator.isNotNull(keywords)) {\n\t\t\tsearchContext.setKeywords(keywords);\n\t\t}\n\n\t\tif (ArrayUtil.isNotEmpty(sorts)) {\n\t\t\tsearchContext.setSorts(sorts);\n\t\t}\n\n\t\tsearchContext.setStart(searchContainer.getStart());\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\talloySearchResult.setHits(hits);\n\n\t\talloySearchResult.setPortletURL(portletURL);\n\n\t\talloySearchResult.afterPropertiesSet();\n\n\t\treturn alloySearchResult;\n\t}","commit_id":"00287abe5866e9089b513e90c26dc6bda88fc766","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void storeFile(String fileNameLocal, String fileNameRemote) throws IOException\n    {\n        try\n        {\n            channelSftp.put(fileNameLocal, fileNameRemote);\n        }\n        catch (SftpException e)\n        {\n            throw new IOException(e.getMessage());\n        }\n    }","id":30602,"modified_method":"public void storeFile(String fileNameLocal, String fileNameRemote) throws IOException\n    {\n        storeFile(fileNameLocal, fileNameRemote, WriteMode.OVERWRITE);\n    }","commit_id":"237cfdace4947b952078c7033900c1393f333b1f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void storeFile(String fileName, InputStream stream) throws IOException\n    {\n        try\n        {\n\n            // Notify sftp put file action\n            if (notifier != null)\n            {\n                notifier.notify(SFTP_PUT_ACTION, currentDirectory + \"/\" + fileName);\n            }\n\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Sending to SFTP service: Stream = \" + stream + \" , filename = \" + fileName);\n            }\n\n            channelSftp.put(stream, fileName);\n        }\n        catch (SftpException e)\n        {\n            logger.error(\"Error writing data over SFTP service, error was: \" + e.getMessage(), e);\n            throw new IOException(e.getMessage());\n        }\n    }","id":30603,"modified_method":"public void storeFile(String fileName, InputStream stream) throws IOException\n    {\n        storeFile(fileName, stream, WriteMode.OVERWRITE);\n    }","commit_id":"237cfdace4947b952078c7033900c1393f333b1f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doDispatch(MuleEvent event) throws Exception\n    {\n        String filename = buildFilename(event);\n        InputStream inputStream = generateInputStream(event);\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Writing file to: \" + endpoint.getEndpointURI() + \" [\" + filename + \"]\");\n        }\n\n        SftpClient client = null;\n        boolean useTempDir = false;\n        String transferFilename = null;\n\n        try\n        {\n            String serviceName = (event.getFlowConstruct() == null)\n                                 ? \"UNKNOWN SERVICE\"\n                                 : event.getFlowConstruct().getName();\n            SftpNotifier notifier = new SftpNotifier(connector, event.getMessage(), endpoint, serviceName);\n            client = connector.createSftpClient(endpoint, notifier);\n            String destDir = endpoint.getEndpointURI().getPath();\n\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Connection setup successful, writing file.\");\n            }\n\n            // Duplicate Handling\n            filename = client.duplicateHandling(destDir, filename, sftpUtil.getDuplicateHandling());\n            transferFilename = filename;\n\n            useTempDir = sftpUtil.isUseTempDirOutbound();\n            if (useTempDir)\n            {\n                // TODO move to a init-method like doConnect?\n                // cd to tempDir and create it if it doesn't already exist\n                sftpUtil.cwdToTempDirOnOutbound(client, destDir);\n\n                // Add unique file-name (if configured) for use during transfer to\n                // temp-dir\n                boolean addUniqueSuffix = sftpUtil.isUseTempFileTimestampSuffix();\n                if (addUniqueSuffix)\n                {\n                    transferFilename = sftpUtil.createUniqueSuffix(transferFilename);\n                }\n            }\n\n            // send file over sftp\n            client.storeFile(transferFilename, inputStream);\n\n            if (useTempDir)\n            {\n                // Move the file to its final destination\n                client.rename(transferFilename, destDir + \"/\" + filename);\n            }\n\n            logger.info(\"Successfully wrote file '\" + filename + \"' to \" + endpoint.getEndpointURI());\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Unexpected exception attempting to write file, message was: \" + e.getMessage(), e);\n\n            sftpUtil.setErrorOccurredOnInputStream(inputStream);\n\n            if (useTempDir)\n            {\n                // Cleanup the remote temp dir from the not fullt completely\n                // transferred file!\n                String tempDir = sftpUtil.getTempDirOutbound();\n                sftpUtil.cleanupTempDir(client, transferFilename, tempDir);\n            }\n            throw e;\n        }\n        finally\n        {\n            if (client != null)\n            {\n                // If the connection fails, the client will be null, otherwise\n                // disconnect.\n                connector.releaseClient(endpoint, client);\n            }\n\n            inputStream.close();\n\n        }\n\n    }","id":30604,"modified_method":"protected void doDispatch(MuleEvent event) throws Exception\n    {\n        String filename = buildFilename(event);\n        InputStream inputStream = generateInputStream(event);\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Writing file to: \" + endpoint.getEndpointURI() + \" [\" + filename + \"]\");\n        }\n\n        SftpClient client = null;\n        boolean useTempDir = false;\n        String transferFilename = null;\n\n        try\n        {\n            String serviceName = (event.getFlowConstruct() == null)\n                                 ? \"UNKNOWN SERVICE\"\n                                 : event.getFlowConstruct().getName();\n            SftpNotifier notifier = new SftpNotifier(connector, event.getMessage(), endpoint, serviceName);\n            client = connector.createSftpClient(endpoint, notifier);\n            String destDir = endpoint.getEndpointURI().getPath();\n\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Connection setup successful, writing file.\");\n            }\n\n            // Duplicate Handling\n            filename = client.duplicateHandling(destDir, filename, sftpUtil.getDuplicateHandling());\n            transferFilename = filename;\n\n            useTempDir = sftpUtil.isUseTempDirOutbound();\n            if (useTempDir)\n            {\n                // TODO move to a init-method like doConnect?\n                // cd to tempDir and create it if it doesn't already exist\n                sftpUtil.cwdToTempDirOnOutbound(client, destDir);\n\n                // Add unique file-name (if configured) for use during transfer to\n                // temp-dir\n                boolean addUniqueSuffix = sftpUtil.isUseTempFileTimestampSuffix();\n                if (addUniqueSuffix)\n                {\n                    transferFilename = sftpUtil.createUniqueSuffix(transferFilename);\n                }\n            }\n\n            // send file over sftp\n            // choose appropriate writing mode\n            if (sftpUtil.getDuplicateHandling().equals(SftpConnector.PROPERTY_DUPLICATE_HANDLING_APPEND))\n            {\n                client.storeFile(transferFilename, inputStream, SftpClient.WriteMode.APPEND);\n            }\n            else\n            {\n                client.storeFile(transferFilename, inputStream);\n            }\n\n            if (useTempDir)\n            {\n                // Move the file to its final destination\n                client.rename(transferFilename, destDir + \"/\" + filename);\n            }\n\n            logger.info(\"Successfully wrote file '\" + filename + \"' to \" + endpoint.getEndpointURI());\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Unexpected exception attempting to write file, message was: \" + e.getMessage(), e);\n\n            sftpUtil.setErrorOccurredOnInputStream(inputStream);\n\n            if (useTempDir)\n            {\n                // Cleanup the remote temp dir from the not fullt completely\n                // transferred file!\n                String tempDir = sftpUtil.getTempDirOutbound();\n                sftpUtil.cleanupTempDir(client, transferFilename, tempDir);\n            }\n            throw e;\n        }\n        finally\n        {\n            if (client != null)\n            {\n                // If the connection fails, the client will be null, otherwise\n                // disconnect.\n                connector.releaseClient(endpoint, client);\n            }\n\n            inputStream.close();\n\n        }\n\n    }","commit_id":"237cfdace4947b952078c7033900c1393f333b1f","url":"https://github.com/mulesoft/mule"},{"original_method":"public static void createEmpty( PageCache pageCache, File storeFile, String version )\n    {\n        try\n        {\n            PagedFile pages = mapCountsStore( pageCache, storeFile );\n            try\n            {\n                SortedKeyValueStoreHeader.empty( version ).write( pages );\n            }\n            finally\n            {\n                pages.flush();\n                pageCache.unmap( storeFile );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( e );\n        }\n    }","id":30605,"modified_method":"public static void createEmpty( PageCache pageCache, File storeFile, SortedKeyValueStoreHeader header )\n    {\n        try\n        {\n            PagedFile pages = mapCountsStore( pageCache, storeFile );\n            try\n            {\n                header.write( pages );\n            }\n            finally\n            {\n                pages.flush();\n                pageCache.unmap( storeFile );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( e );\n        }\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBumpMinorVersion() throws IOException\n    {\n        // when\n        CountsStore.createEmpty( pageCache, alpha, ALL_STORES_VERSION );\n        try ( CountsStore counts = CountsStore.open( fs, pageCache, alpha ) )\n        {\n            // when\n            long initialMinorVersion = counts.minorVersion();\n\n            SortedKeyValueStore.Writer<CountsKey, Register.DoubleLongRegister> writer = counts.newWriter( beta, counts.lastTxId() );\n            writer.close();\n\n            try ( CountsStore updated = (CountsStore) writer.openForReading() )\n            {\n                assertEquals( initialMinorVersion + 1l, updated.minorVersion() );\n            }\n        }\n    }","id":30606,"modified_method":"@Test\n    public void shouldBumpMinorVersion() throws IOException\n    {\n        // when\n        CountsStore.createEmpty( pageCache, alpha, header );\n        try ( CountsStore counts = CountsStore.open( fs, pageCache, alpha ) )\n        {\n            // when\n            long initialMinorVersion = counts.minorVersion();\n\n            SortedKeyValueStore.Writer<CountsKey, Register.DoubleLongRegister> writer = counts.newWriter( beta, counts.lastTxId() );\n            writer.close();\n\n            try ( CountsStore updated = (CountsStore) writer.openForReading() )\n            {\n                assertEquals( initialMinorVersion + 1l, updated.minorVersion() );\n            }\n        }\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUpdateTheStore() throws IOException\n    {\n        // given\n        CountsStore.createEmpty( pageCache, alpha, ALL_STORES_VERSION );\n        SortedKeyValueStore.Writer<CountsKey, Register.DoubleLongRegister> writer;\n        try ( CountsStore counts = CountsStore.open( fs, pageCache, alpha ) )\n        {\n            // when\n            writer = counts.newWriter( beta, lastCommittedTxId );\n            writer.valueRegister().write( 0, 21 );\n            writer.visit( nodeKey( 0 ) );\n            writer.valueRegister().write( 0, 32 );\n            writer.visit( relationshipKey( 1, 2, 3 )  );\n            writer.valueRegister().write( 9, 11 );\n            writer.visit( indexCountsKey( 4, 5 ) );\n            writer.valueRegister().write( 24, 84 );\n            writer.visit( indexSampleKey( 4, 5 ) );\n            writer.close();\n        }\n\n        try ( CountsStore updated = (CountsStore) writer.openForReading() )\n        {\n            // then\n            assertEquals( 21, get( updated, nodeKey( 0 ) ) );\n            assertEquals( 32, get( updated, relationshipKey( 1, 2, 3 ) ) );\n            assertEquals( lastCommittedTxId, updated.lastTxId() );\n            assertEquals( BASE_MINOR_VERSION, updated.minorVersion() );\n            assertEquals( 4, updated.totalRecordsStored() );\n            assertEquals( beta, updated.file() );\n            updated.accept( new KeyValueRecordVisitor<CountsKey, Register.DoubleLongRegister>()\n            {\n                private final Register.DoubleLongRegister valueRegister = Registers.newDoubleLongRegister();\n\n                @Override\n                public Register.DoubleLongRegister valueRegister()\n                {\n                    return valueRegister;\n                }\n\n                @Override\n                public void visit( CountsKey key )\n                {\n                    key.accept( new CountsVisitor()\n                    {\n                        @Override\n                        public void visitNodeCount( int labelId, long count )\n                        {\n                            assertEquals( 0, labelId );\n                            assertEquals( 21, count );\n                        }\n\n                        @Override\n                        public void visitRelationshipCount( int startLabelId, int typeId, int endLabelId, long count )\n                        {\n                            assertEquals( 1, startLabelId );\n                            assertEquals( 2, typeId );\n                            assertEquals( 3, endLabelId );\n                            assertEquals( 32, count );\n                        }\n\n                        @Override\n                        public void visitIndexCounts( int labelId, int propertyKeyId, long updates, long size )\n                        {\n                            assertEquals( 4, labelId );\n                            assertEquals( 5, propertyKeyId );\n                            assertEquals( 9, updates );\n                            assertEquals( 11, size );\n                        }\n\n                        @Override\n                        public void visitIndexSample( int labelId, int propertyKeyId, long unique, long size )\n                        {\n                            assertEquals( 4, labelId );\n                            assertEquals( 5, propertyKeyId );\n                            assertEquals( 24, unique );\n                            assertEquals( 84, size );\n                        }\n                    }, valueRegister );\n                }\n            } );\n        }\n    }","id":30607,"modified_method":"@Test\n    public void shouldUpdateTheStore() throws IOException\n    {\n        // given\n        CountsStore.createEmpty( pageCache, alpha, header );\n        SortedKeyValueStore.Writer<CountsKey, Register.DoubleLongRegister> writer;\n        try ( CountsStore counts = CountsStore.open( fs, pageCache, alpha ) )\n        {\n            // when\n            writer = counts.newWriter( beta, lastCommittedTxId );\n            writer.valueRegister().write( 0, 21 );\n            writer.visit( nodeKey( 0 ) );\n            writer.valueRegister().write( 0, 32 );\n            writer.visit( relationshipKey( 1, 2, 3 )  );\n            writer.valueRegister().write( 9, 11 );\n            writer.visit( indexCountsKey( 4, 5 ) );\n            writer.valueRegister().write( 24, 84 );\n            writer.visit( indexSampleKey( 4, 5 ) );\n            writer.close();\n        }\n\n        try ( CountsStore updated = (CountsStore) writer.openForReading() )\n        {\n            // then\n            assertEquals( 21, get( updated, nodeKey( 0 ) ) );\n            assertEquals( 32, get( updated, relationshipKey( 1, 2, 3 ) ) );\n            assertEquals( lastCommittedTxId, updated.lastTxId() );\n            assertEquals( BASE_MINOR_VERSION, updated.minorVersion() );\n            assertEquals( 4, updated.totalRecordsStored() );\n            assertEquals( beta, updated.file() );\n            updated.accept( new KeyValueRecordVisitor<CountsKey, Register.DoubleLongRegister>()\n            {\n                private final Register.DoubleLongRegister valueRegister = Registers.newDoubleLongRegister();\n\n                @Override\n                public Register.DoubleLongRegister valueRegister()\n                {\n                    return valueRegister;\n                }\n\n                @Override\n                public void visit( CountsKey key )\n                {\n                    key.accept( new CountsVisitor()\n                    {\n                        @Override\n                        public void visitNodeCount( int labelId, long count )\n                        {\n                            assertEquals( 0, labelId );\n                            assertEquals( 21, count );\n                        }\n\n                        @Override\n                        public void visitRelationshipCount( int startLabelId, int typeId, int endLabelId, long count )\n                        {\n                            assertEquals( 1, startLabelId );\n                            assertEquals( 2, typeId );\n                            assertEquals( 3, endLabelId );\n                            assertEquals( 32, count );\n                        }\n\n                        @Override\n                        public void visitIndexCounts( int labelId, int propertyKeyId, long updates, long size )\n                        {\n                            assertEquals( 4, labelId );\n                            assertEquals( 5, propertyKeyId );\n                            assertEquals( 9, updates );\n                            assertEquals( 11, size );\n                        }\n\n                        @Override\n                        public void visitIndexSample( int labelId, int propertyKeyId, long unique, long size )\n                        {\n                            assertEquals( 4, labelId );\n                            assertEquals( 5, propertyKeyId );\n                            assertEquals( 24, unique );\n                            assertEquals( 84, size );\n                        }\n                    }, valueRegister );\n                }\n            } );\n        }\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateAnEmptyStore() throws IOException\n    {\n        // when\n        CountsStore.createEmpty( pageCache, alpha, ALL_STORES_VERSION );\n        try ( CountsStore counts = CountsStore.open( fs, pageCache, alpha ) )\n        {\n            // then\n            assertEquals( 0, get( counts, nodeKey( 0 ) ) );\n            assertEquals( 0, get( counts, relationshipKey( 1, 2, 3 ) ) );\n            assertEquals( BASE_TX_ID, counts.lastTxId() );\n            assertEquals( BASE_MINOR_VERSION, counts.minorVersion() );\n            assertEquals( 0, counts.totalRecordsStored() );\n            assertEquals( alpha, counts.file() );\n            counts.accept( new KeyValueRecordVisitor<CountsKey, Register.DoubleLongRegister>()\n            {\n                private final Register.DoubleLongRegister valueRegister = Registers.newDoubleLongRegister();\n\n                @Override\n                public Register.DoubleLongRegister valueRegister()\n                {\n                    return valueRegister;\n                }\n\n                @Override\n                public void visit( CountsKey key )\n                {\n                    fail( \"should not have been called\" );\n                }\n            } );\n        }\n    }","id":30608,"modified_method":"@Test\n    public void shouldCreateAnEmptyStore() throws IOException\n    {\n        // when\n        CountsStore.createEmpty( pageCache, alpha, header );\n        try ( CountsStore counts = CountsStore.open( fs, pageCache, alpha ) )\n        {\n            // then\n            assertEquals( 0, get( counts, nodeKey( 0 ) ) );\n            assertEquals( 0, get( counts, relationshipKey( 1, 2, 3 ) ) );\n            assertEquals( BASE_TX_ID, counts.lastTxId() );\n            assertEquals( BASE_MINOR_VERSION, counts.minorVersion() );\n            assertEquals( 0, counts.totalRecordsStored() );\n            assertEquals( alpha, counts.file() );\n            counts.accept( new KeyValueRecordVisitor<CountsKey, Register.DoubleLongRegister>()\n            {\n                private final Register.DoubleLongRegister valueRegister = Registers.newDoubleLongRegister();\n\n                @Override\n                public Register.DoubleLongRegister valueRegister()\n                {\n                    return valueRegister;\n                }\n\n                @Override\n                public void visit( CountsKey key )\n                {\n                    fail( \"should not have been called\" );\n                }\n            } );\n        }\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void createEmptyCountsStore( PageCache pageCache, File file, String version )\n    {\n        CountsStore.createEmpty( pageCache, storeFile( file, ALPHA ), version );\n    }","id":30609,"modified_method":"public static void createEmptyCountsStore( PageCache pageCache, File file, String storeVersion )\n    {\n        // create both files initially to avoid problems with unflushed metadata\n        // increase alpha minor version by 1 to ensure that we use alpha after creating the store\n\n        File alpha = storeFile( file, ALPHA );\n        CountsStore.createEmpty( pageCache, alpha, with( storeVersion, BASE_TX_ID, BASE_MINOR_VERSION + 1 ) );\n\n        File beta = storeFile( file, BETA );\n        CountsStore.createEmpty( pageCache, beta, with( storeVersion, BASE_TX_ID, BASE_MINOR_VERSION ) );\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createStoreFile( EphemeralFileSystemAbstraction fs, PageCache pageCache, File file, long lastTxId ) throws IOException\n    {\n        SortedKeyValueStoreHeader header = SortedKeyValueStoreHeader.empty( VERSION );\n        CountsStoreWriter writer = WRITER_FACTORY.create( fs, pageCache, header, file, lastTxId );\n        writer.close();\n        writer.openForReading().close();\n    }","id":30610,"modified_method":"private void createStoreFile( EphemeralFileSystemAbstraction fs, PageCache pageCache, File file, long lastTxId ) throws IOException\n    {\n        SortedKeyValueStoreHeader header = SortedKeyValueStoreHeader.with( VERSION, BASE_TX_ID, BASE_MINOR_VERSION );\n        CountsStoreWriter writer = WRITER_FACTORY.create( fs, pageCache, header, file, lastTxId );\n        writer.close();\n        writer.openForReading().close();\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldWriteHeaderInPageFile() throws IOException\n    {\n        // given\n        SortedKeyValueStoreHeader header = SortedKeyValueStoreHeader.empty( ALL_STORES_VERSION ).update( 42, 24, 12 );\n\n        // when\n        try\n        {\n            final PagedFile pagedFile = pageCache.map( file, pageCache.pageSize() );\n            header.write( pagedFile );\n            pagedFile.flush();\n\n            // then\n            assertEquals( header, SortedKeyValueStoreHeader.read( pagedFile ) );\n        }\n        finally\n        {\n            pageCache.unmap( file );\n        }\n    }","id":30611,"modified_method":"@Test\n    public void shouldWriteHeaderInPageFile() throws IOException\n    {\n        // given\n        SortedKeyValueStoreHeader header =\n                with( ALL_STORES_VERSION, BASE_TX_ID, BASE_MINOR_VERSION ).update( 42, 24, 12 );\n\n        // when\n        try\n        {\n            final PagedFile pagedFile = pageCache.map( file, pageCache.pageSize() );\n            header.write( pagedFile );\n            pagedFile.flush();\n\n            // then\n            assertEquals( header, SortedKeyValueStoreHeader.read( pagedFile ) );\n        }\n        finally\n        {\n            pageCache.unmap( file );\n        }\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUpdateHeader()\n    {\n        // given\n        SortedKeyValueStoreHeader header = SortedKeyValueStoreHeader.empty( ALL_STORES_VERSION );\n\n        // when\n        SortedKeyValueStoreHeader newHeader = header.update( 42, 24, 12 );\n\n        // then\n        assertEquals( 24, newHeader.lastTxId() );\n        assertEquals( 12, newHeader.minorVersion() );\n        assertEquals( 42, newHeader.dataRecords() );\n        assertEquals( 1, newHeader.headerRecords() );\n        assertEquals( ALL_STORES_VERSION, newHeader.storeFormatVersion() );\n    }","id":30612,"modified_method":"@Test\n    public void shouldUpdateHeader()\n    {\n        // given\n        SortedKeyValueStoreHeader header = with( ALL_STORES_VERSION, BASE_TX_ID, BASE_MINOR_VERSION );\n\n        // when\n        SortedKeyValueStoreHeader newHeader = header.update( 42, 24, 12 );\n\n        // then\n        assertEquals( 24, newHeader.lastTxId() );\n        assertEquals( 12, newHeader.minorVersion() );\n        assertEquals( 42, newHeader.dataRecords() );\n        assertEquals( 1, newHeader.headerRecords() );\n        assertEquals( ALL_STORES_VERSION, newHeader.storeFormatVersion() );\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateAnEmptyHeader()\n    {\n        // when\n        SortedKeyValueStoreHeader header = SortedKeyValueStoreHeader.empty( ALL_STORES_VERSION );\n\n        // then\n        assertEquals( BASE_TX_ID, header.lastTxId() );\n        assertEquals( 0, header.dataRecords() );\n        assertEquals( 1, header.headerRecords() );\n        assertEquals( ALL_STORES_VERSION, header.storeFormatVersion() );\n    }","id":30613,"modified_method":"@Test\n    public void shouldCreateAnEmptyHeader()\n    {\n        // when\n        SortedKeyValueStoreHeader header = with( ALL_STORES_VERSION, BASE_TX_ID, BASE_MINOR_VERSION );\n\n        // then\n        assertEquals( BASE_TX_ID, header.lastTxId() );\n        assertEquals( 0, header.dataRecords() );\n        assertEquals( 1, header.headerRecords() );\n        assertEquals( ALL_STORES_VERSION, header.storeFormatVersion() );\n    }","commit_id":"9f74e44d6ff8b38b6acb6ea544fd7294de8ff199","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {\n        log.trace(\"doStoreFile({})\", targetName);\n\n        // if an existing file already exists what should we do?\n        if (endpoint.getFileExist() == GenericFileExist.Ignore\n                || endpoint.getFileExist() == GenericFileExist.Fail\n                || endpoint.getFileExist() == GenericFileExist.Move) {\n            boolean existFile = existsFile(targetName);\n            if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {\n                // ignore but indicate that the file was written\n                log.trace(\"An existing file already exists: {}. Ignore and do not override it.\", name);\n                return true;\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {\n                throw new GenericFileOperationFailedException(\"File already exist: \" + name + \". Cannot write new file.\");\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {\n                // move any existing file first\n                doMoveExistingFile(name, targetName);\n            }\n        }\n\n        InputStream is = null;\n        if (exchange.getIn().getBody() == null) {\n            // Do an explicit test for a null body and decide what to do\n            if (endpoint.isAllowNullBody()) {\n                log.trace(\"Writing empty file.\");\n                is = new ByteArrayInputStream(new byte[]{});\n            } else {\n                throw new GenericFileOperationFailedException(\"Cannot write null body to file: \" + name);\n            }\n        }\n\n        try {\n            if (is == null) {\n                String charset = endpoint.getCharset();\n                if (charset != null) {\n                    // charset configured so we must convert to the desired\n                    // charset so we can write with encoding\n                    is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));\n                    log.trace(\"Using InputStream {} with charset {}.\", is, charset);\n                } else {\n                    is = exchange.getIn().getMandatoryBody(InputStream.class);\n                }\n            }\n            if (endpoint.getFileExist() == GenericFileExist.Append) {\n                log.trace(\"Client appendFile: {}\", targetName);\n                return client.appendFile(targetName, is);\n            } else {\n                log.trace(\"Client storeFile: {}\", targetName);\n                return client.storeFile(targetName, is);\n            }\n        } catch (IOException e) {\n            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        } catch (InvalidPayloadException e) {\n            throw new GenericFileOperationFailedException(\"Cannot store file: \" + name, e);\n        } finally {\n            IOHelper.close(is, \"store: \" + name, log);\n        }\n    }","id":30614,"modified_method":"private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {\n        log.trace(\"doStoreFile({})\", targetName);\n\n        // if an existing file already exists what should we do?\n        if (endpoint.getFileExist() == GenericFileExist.Ignore\n                || endpoint.getFileExist() == GenericFileExist.Fail\n                || endpoint.getFileExist() == GenericFileExist.Move) {\n            boolean existFile = existsFile(targetName);\n            if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {\n                // ignore but indicate that the file was written\n                log.trace(\"An existing file already exists: {}. Ignore and do not override it.\", name);\n                return true;\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {\n                throw new GenericFileOperationFailedException(\"File already exist: \" + name + \". Cannot write new file.\");\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {\n                // move any existing file first\n                doMoveExistingFile(name, targetName);\n            }\n        }\n\n        InputStream is = null;\n        if (exchange.getIn().getBody() == null) {\n            // Do an explicit test for a null body and decide what to do\n            if (endpoint.isAllowNullBody()) {\n                log.trace(\"Writing empty file.\");\n                is = new ByteArrayInputStream(new byte[]{});\n            } else {\n                throw new GenericFileOperationFailedException(\"Cannot write null body to file: \" + name);\n            }\n        }\n\n        try {\n            if (is == null) {\n                String charset = endpoint.getCharset();\n                if (charset != null) {\n                    // charset configured so we must convert to the desired\n                    // charset so we can write with encoding\n                    is = new ByteArrayInputStream(exchange.getIn().getMandatoryBody(String.class).getBytes(charset));\n                    log.trace(\"Using InputStream {} with charset {}.\", is, charset);\n                } else {\n                    is = exchange.getIn().getMandatoryBody(InputStream.class);\n                }\n            }\n\n            final StopWatch watch = new StopWatch();\n            boolean answer;\n            log.debug(\"About to store file: {} using stream: {}\", targetName, is);\n            if (endpoint.getFileExist() == GenericFileExist.Append) {\n                log.trace(\"Client appendFile: {}\", targetName);\n                answer = client.appendFile(targetName, is);\n            } else {\n                log.trace(\"Client storeFile: {}\", targetName);\n                answer = client.storeFile(targetName, is);\n            }\n            watch.stop();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Took {} ({} millis) to store file: {} and FTP client returned: {}\",\n                        new Object[]{TimeUtils.printDuration(watch.taken()), watch.taken(), targetName, answer});\n            }\n\n            return answer;\n\n        } catch (IOException e) {\n            throw new GenericFileOperationFailedException(client.getReplyCode(), client.getReplyString(), e.getMessage(), e);\n        } catch (InvalidPayloadException e) {\n            throw new GenericFileOperationFailedException(\"Cannot store file: \" + name, e);\n        } finally {\n            IOHelper.close(is, \"store: \" + name, log);\n        }\n    }","commit_id":"a5abaf97e86d117216396422f3b487958a7e6ac3","url":"https://github.com/apache/camel"},{"original_method":"private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {\n        LOG.trace(\"doStoreFile({})\", targetName);\n\n        // if an existing file already exists what should we do?\n        if (endpoint.getFileExist() == GenericFileExist.Ignore\n                || endpoint.getFileExist() == GenericFileExist.Fail\n                || endpoint.getFileExist() == GenericFileExist.Move) {\n            boolean existFile = existsFile(targetName);\n            if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {\n                // ignore but indicate that the file was written\n                LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", name);\n                return true;\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {\n                throw new GenericFileOperationFailedException(\"File already exist: \" + name + \". Cannot write new file.\");\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {\n                // move any existing file first\n                doMoveExistingFile(name, targetName);\n            }\n        }\n\n        InputStream is = null;\n        if (exchange.getIn().getBody() == null) {\n            // Do an explicit test for a null body and decide what to do\n            if (endpoint.isAllowNullBody()) {\n                LOG.trace(\"Writing empty file.\");\n                is = new ByteArrayInputStream(new byte[]{});\n            } else {\n                throw new GenericFileOperationFailedException(\"Cannot write null body to file: \" + name);\n            }\n        }\n\n        try {\n            if (is == null) {\n                is = exchange.getIn().getMandatoryBody(InputStream.class);\n            }\n            if (endpoint.getFileExist() == GenericFileExist.Append) {\n                LOG.trace(\"Client appendFile: {}\", targetName);\n                channel.put(is, targetName, ChannelSftp.APPEND);\n            } else {\n                LOG.trace(\"Client storeFile: {}\", targetName);\n                // override is default\n                channel.put(is, targetName);\n            }\n\n            // after storing file, we may set chmod on the file\n            String mode = endpoint.getConfiguration().getChmod();\n            if (ObjectHelper.isNotEmpty(mode)) {\n                // parse to int using 8bit mode\n                int permissions = Integer.parseInt(mode, 8);\n                LOG.trace(\"Setting chmod: {} on file: \", mode, targetName);\n                channel.chmod(permissions, targetName);\n            }\n\n            return true;\n        \n        } catch (SftpException e) {\n            throw new GenericFileOperationFailedException(\"Cannot store file: \" + name, e);\n        } catch (InvalidPayloadException e) {\n            throw new GenericFileOperationFailedException(\"Cannot store file: \" + name, e);\n        } finally {\n            IOHelper.close(is, \"store: \" + name, LOG);\n        }\n    }","id":30615,"modified_method":"private boolean doStoreFile(String name, String targetName, Exchange exchange) throws GenericFileOperationFailedException {\n        LOG.trace(\"doStoreFile({})\", targetName);\n\n        // if an existing file already exists what should we do?\n        if (endpoint.getFileExist() == GenericFileExist.Ignore\n                || endpoint.getFileExist() == GenericFileExist.Fail\n                || endpoint.getFileExist() == GenericFileExist.Move) {\n            boolean existFile = existsFile(targetName);\n            if (existFile && endpoint.getFileExist() == GenericFileExist.Ignore) {\n                // ignore but indicate that the file was written\n                LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", name);\n                return true;\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Fail) {\n                throw new GenericFileOperationFailedException(\"File already exist: \" + name + \". Cannot write new file.\");\n            } else if (existFile && endpoint.getFileExist() == GenericFileExist.Move) {\n                // move any existing file first\n                doMoveExistingFile(name, targetName);\n            }\n        }\n\n        InputStream is = null;\n        if (exchange.getIn().getBody() == null) {\n            // Do an explicit test for a null body and decide what to do\n            if (endpoint.isAllowNullBody()) {\n                LOG.trace(\"Writing empty file.\");\n                is = new ByteArrayInputStream(new byte[]{});\n            } else {\n                throw new GenericFileOperationFailedException(\"Cannot write null body to file: \" + name);\n            }\n        }\n\n        try {\n            if (is == null) {\n                is = exchange.getIn().getMandatoryBody(InputStream.class);\n            }\n\n            final StopWatch watch = new StopWatch();\n            LOG.debug(\"About to store file: {} using stream: {}\", targetName, is);\n            if (endpoint.getFileExist() == GenericFileExist.Append) {\n                LOG.trace(\"Client appendFile: {}\", targetName);\n                channel.put(is, targetName, ChannelSftp.APPEND);\n            } else {\n                LOG.trace(\"Client storeFile: {}\", targetName);\n                // override is default\n                channel.put(is, targetName);\n            }\n            watch.stop();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Took {} ({} millis) to store file: {} and FTP client returned: true\",\n                        new Object[]{TimeUtils.printDuration(watch.taken()), watch.taken(), targetName});\n            }\n\n            // after storing file, we may set chmod on the file\n            String mode = endpoint.getConfiguration().getChmod();\n            if (ObjectHelper.isNotEmpty(mode)) {\n                // parse to int using 8bit mode\n                int permissions = Integer.parseInt(mode, 8);\n                LOG.trace(\"Setting chmod: {} on file: \", mode, targetName);\n                channel.chmod(permissions, targetName);\n            }\n\n            return true;\n        \n        } catch (SftpException e) {\n            throw new GenericFileOperationFailedException(\"Cannot store file: \" + name, e);\n        } catch (InvalidPayloadException e) {\n            throw new GenericFileOperationFailedException(\"Cannot store file: \" + name, e);\n        } finally {\n            IOHelper.close(is, \"store: \" + name, LOG);\n        }\n    }","commit_id":"a5abaf97e86d117216396422f3b487958a7e6ac3","url":"https://github.com/apache/camel"},{"original_method":"/**\n   * Checks the language under the cursor. Used for opening the configuration\n   * dialog.\n   * \n   * @return Language the language under the visible cursor\n   */\n  private Language getLanguage() {\n    final XComponent xComponent = getXComponent();\n    final Locale charLocale;\n    final XPropertySet xCursorProps;\n    try {\n      final XModel model = (XModel) UnoRuntime.queryInterface(XModel.class, xComponent);\n      final XTextViewCursorSupplier xViewCursorSupplier = (XTextViewCursorSupplier) UnoRuntime\n          .queryInterface(XTextViewCursorSupplier.class,\n              model.getCurrentController());\n      final XTextViewCursor xCursor = xViewCursorSupplier.getViewCursor();\n      if (xCursor.isCollapsed()) { // no text selection\n        xCursorProps = (XPropertySet) UnoRuntime.queryInterface(\n            XPropertySet.class, xCursor);\n      } else { // text is selected, need to create another cursor\n        // as multiple languages can occur here - we care only\n        // about character under the cursor, which might be wrong\n        // but it applies only to the checking dialog to be removed\n        xCursorProps = (XPropertySet) UnoRuntime.queryInterface(\n            XPropertySet.class,\n            xCursor.getText().createTextCursorByRange(xCursor.getStart()));\n      }\n\n      // The CharLocale and CharLocaleComplex properties may both be set, so we still cannot know\n      // whether the text is Khmer (the only \"complex text layout (CTL)\" language we support so far).\n      // Thus we check the text itself:\n      final KhmerDetector khmerDetector = new KhmerDetector();\n      if (khmerDetector.isKhmer(xCursor.getText().getString())) {\n        return Language.getLanguageForShortName(\"km\"); // Khmer\n      }\n\n      final Object obj = xCursorProps.getPropertyValue(\"CharLocale\");\n      if (obj == null) {\n        return Language.getLanguageForShortName(\"en-US\");\n      }\n      charLocale = (Locale) obj;\n      boolean langIsSupported = false;\n      for (Language element : Language.LANGUAGES) {\n        if (charLocale.Language.equalsIgnoreCase(LIBREOFFICE_SPECIAL_LANGUAGE_TAG)\n            && element.getShortNameWithCountryAndVariant().equalsIgnoreCase(\n                charLocale.Variant)) {\n          langIsSupported = true;\n          break;\n        }\n        if (element.getShortName().equals(charLocale.Language)) {\n          langIsSupported = true;\n          break;\n        }\n      }\n      if (!langIsSupported) {\n        final String message = org.languagetool.gui.Tools.makeTexti18n(\n            MESSAGES, \"language_not_supported\", charLocale.Language);\n        // final String message = \"Language not supported. Language = \"\n        // + charLocale.Language + \", Country = \" + charLocale.Country\n        // + \", Variant = \" + charLocale.Variant;\n        JOptionPane.showMessageDialog(null, message);\n        return null;\n      }\n    } catch (final Throwable t) {\n      showError(t);\n      return null;\n    }\n\n    try {\n      if (charLocale.Language.equalsIgnoreCase(LIBREOFFICE_SPECIAL_LANGUAGE_TAG)) {\n        return Language.getLanguageForShortName(charLocale.Variant);\n      } else {\n        return Language.getLanguageForShortName(charLocale.Language + \"-\"\n            + charLocale.Country);\n      }\n    } catch (java.lang.IllegalArgumentException e) {\n      return Language.getLanguageForShortName(charLocale.Language);\n    }\n\n  }","id":30616,"modified_method":"/**\n   * Checks the language under the cursor. Used for opening the configuration\n   * dialog.\n   * \n   * @return Language the language under the visible cursor\n   */\n  private Language getLanguage() {\n    final XComponent xComponent = getXComponent();\n    final Locale charLocale;\n    final XPropertySet xCursorProps;\n    try {\n      final XModel model = UnoRuntime.queryInterface(XModel.class, xComponent);\n      final XTextViewCursorSupplier xViewCursorSupplier = UnoRuntime\n          .queryInterface(XTextViewCursorSupplier.class,\n              model.getCurrentController());\n      final XTextViewCursor xCursor = xViewCursorSupplier.getViewCursor();\n      if (xCursor.isCollapsed()) { // no text selection\n        xCursorProps = UnoRuntime.queryInterface(XPropertySet.class, xCursor);\n      } else { // text is selected, need to create another cursor\n        // as multiple languages can occur here - we care only\n        // about character under the cursor, which might be wrong\n        // but it applies only to the checking dialog to be removed\n        xCursorProps = UnoRuntime.queryInterface(\n            XPropertySet.class,\n            xCursor.getText().createTextCursorByRange(xCursor.getStart()));\n      }\n\n      // The CharLocale and CharLocaleComplex properties may both be set, so we still cannot know\n      // whether the text is Khmer (the only \"complex text layout (CTL)\" language we support so far).\n      // Thus we check the text itself:\n      final KhmerDetector khmerDetector = new KhmerDetector();\n      if (khmerDetector.isKhmer(xCursor.getText().getString())) {\n        return Language.getLanguageForShortName(\"km\"); // Khmer\n      }\n\n      final Object obj = xCursorProps.getPropertyValue(\"CharLocale\");\n      if (obj == null) {\n        return Language.getLanguageForShortName(\"en-US\");\n      }\n      charLocale = (Locale) obj;\n      boolean langIsSupported = false;\n      for (Language element : Language.LANGUAGES) {\n        if (charLocale.Language.equalsIgnoreCase(LIBREOFFICE_SPECIAL_LANGUAGE_TAG)\n            && element.getShortNameWithCountryAndVariant().equalsIgnoreCase(\n                charLocale.Variant)) {\n          langIsSupported = true;\n          break;\n        }\n        if (element.getShortName().equals(charLocale.Language)) {\n          langIsSupported = true;\n          break;\n        }\n      }\n      if (!langIsSupported) {\n        final String message = org.languagetool.gui.Tools.makeTexti18n(\n            MESSAGES, \"language_not_supported\", charLocale.Language);\n        // final String message = \"Language not supported. Language = \"\n        // + charLocale.Language + \", Country = \" + charLocale.Country\n        // + \", Variant = \" + charLocale.Variant;\n        JOptionPane.showMessageDialog(null, message);\n        return null;\n      }\n    } catch (final Throwable t) {\n      showError(t);\n      return null;\n    }\n\n    try {\n      if (charLocale.Language.equalsIgnoreCase(LIBREOFFICE_SPECIAL_LANGUAGE_TAG)) {\n        return Language.getLanguageForShortName(charLocale.Variant);\n      } else {\n        return Language.getLanguageForShortName(charLocale.Language + \"-\"\n            + charLocale.Country);\n      }\n    } catch (java.lang.IllegalArgumentException e) {\n      return Language.getLanguageForShortName(charLocale.Language);\n    }\n\n  }","commit_id":"ef1cd754de72a5dc57e7f514867c98472b43eb19","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private XComponent getXComponent() {\n    try {\n      final XMultiComponentFactory xMCF = xContext.getServiceManager();\n      final Object desktop = xMCF.createInstanceWithContext(\n          \"com.sun.star.frame.Desktop\", xContext);\n      final XDesktop xDesktop = (XDesktop) UnoRuntime.queryInterface(\n          XDesktop.class, desktop);\n      return xDesktop.getCurrentComponent();\n    } catch (final Throwable t) {\n      showError(t);\n      return null;\n    }\n  }","id":30617,"modified_method":"private XComponent getXComponent() {\n    try {\n      final XMultiComponentFactory xMCF = xContext.getServiceManager();\n      final Object desktop = xMCF.createInstanceWithContext(\n          \"com.sun.star.frame.Desktop\", xContext);\n      final XDesktop xDesktop = UnoRuntime.queryInterface(XDesktop.class, desktop);\n      return xDesktop.getCurrentComponent();\n    } catch (final Throwable t) {\n      showError(t);\n      return null;\n    }\n  }","commit_id":"ef1cd754de72a5dc57e7f514867c98472b43eb19","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private File getHomeDir() {\n    final String homeDir = System.getProperty(\"user.home\");\n    if (homeDir == null) {\n      @SuppressWarnings({ \"ThrowableInstanceNeverThrown\" })\n      final RuntimeException ex = new RuntimeException(\n          \"Could not get home directory\");\n      showError(ex);\n    }\n    return new File(homeDir);\n  }","id":30618,"modified_method":"private File getHomeDir() {\n    final String homeDir = System.getProperty(\"user.home\");\n    if (homeDir == null) {\n      @SuppressWarnings(\"ThrowableInstanceNeverThrown\")\n      final RuntimeException ex = new RuntimeException(\"Could not get home directory\");\n      showError(ex);\n    }\n    return new File(homeDir);\n  }","commit_id":"ef1cd754de72a5dc57e7f514867c98472b43eb19","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public static Object convertToNativeType(JIVariant type) throws WmiException {\n        try {\n            if (type.isArray()) {\n                ArrayList<Object> objs = new ArrayList<Object>();\n                Object [] array = (Object[])type.getObjectAsArray().getArrayInstance();\n\n                for(int j = 0; j < array.length; j++) {\n                    objs.add(convertToNativeType((JIVariant)array[j]));\n                }\n                \n                return objs;\n            }\n\n            switch (type.getType()) {\n                case JIVariant.VT_NULL:\n                    return null;\n                case JIVariant.VT_BSTR:\n                    return type.getObjectAsString().getString();\n                case JIVariant.VT_I2: // sint16\n                    return type.getObjectAsShort();\n                case JIVariant.VT_I4:\n                    return type.getObjectAsInt();\n                case JIVariant.VT_UI1: // uint8 (convert to Java Number)\n                    return type.getObjectAsUnsigned().getValue();\n                case JIVariant.VT_BOOL:\n                    return type.getObjectAsBoolean();\n                case JIVariant.VT_DECIMAL:\n                    return type.getObjectAsFloat();\n                case JIVariant.VT_DATE:\n                    return type.getObjectAsDate();\n                default:\n                    throw new WmiException(\"Unknown type presented (\"\n                            + type.getType() + \"), defaulting to Object: \"\n                            + type.toString());\n            }\n        } catch (JIException e) {\n            throw new WmiException(\n                    \"Failed to conver WMI type to native object: \"\n                            + e.getMessage(), e);\n        }\n    }","id":30619,"modified_method":"public static Object convertToNativeType(JIVariant type) throws WmiException {\n        try {\n            if (type.isArray()) {\n                ArrayList<Object> objs = new ArrayList<Object>();\n                Object [] array = (Object[])type.getObjectAsArray().getArrayInstance();\n\n                for (Object element : array) {\n                    objs.add(convertToNativeType((JIVariant)element));\n                }\n                \n                return objs;\n            }\n\n            switch (type.getType()) {\n                case JIVariant.VT_NULL:\n                    return null;\n                case JIVariant.VT_BSTR:\n                    return type.getObjectAsString().getString();\n                case JIVariant.VT_I2: // sint16\n                    return type.getObjectAsShort();\n                case JIVariant.VT_I4:\n                    return type.getObjectAsInt();\n                case JIVariant.VT_UI1: // uint8 (convert to Java Number)\n                    return type.getObjectAsUnsigned().getValue();\n                case JIVariant.VT_BOOL:\n                    return type.getObjectAsBoolean();\n                case JIVariant.VT_DECIMAL:\n                    return type.getObjectAsFloat();\n                case JIVariant.VT_DATE:\n                    return type.getObjectAsDate();\n                default:\n                    throw new WmiException(\"Unknown type presented (\"\n                            + type.getType() + \"), defaulting to Object: \"\n                            + type.toString());\n            }\n        } catch (JIException e) {\n            throw new WmiException(\n                    \"Failed to conver WMI type to native object: \"\n                            + e.getMessage(), e);\n        }\n    }","commit_id":"ba07139f0d59ff5dbb8183bc1d215f634949a651","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void connect(String domain, String username, String password)\n            throws WmiException {\n        try {\n\n            m_Session = JISession.createSession(domain, username, password);\n            m_Session.useSessionSecurity(true);\n            m_Session.setGlobalSocketTimeout(5000);\n\n            m_ComStub = new JIComServer(JIProgId.valueOf(WMI_PROGID), m_Address, m_Session);\n\n            IJIComObject unknown = m_ComStub.createInstance();\n            m_ComObject = (IJIComObject) unknown.queryInterface(WMI_CLSID);\n\n            // This will obtain the dispatch interface\n            m_Dispatch = (IJIDispatch) JIObjectFactory.narrowObject(\n                    m_ComObject.queryInterface(IJIDispatch.IID));\n            JIVariant results[] = m_Dispatch.callMethodA(\"ConnectServer\",new Object[]{new JIString(m_Address),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM()\n                            ,JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),0,JIVariant.OPTIONAL_PARAM()});\n\n\n            m_WbemServices = (IJIDispatch) JIObjectFactory.narrowObject((results[0]).getObjectAsComObject());\n\n        } catch (JIException e) {\n            throw new WmiException(\"Failed to connect to host '\" + m_Address\n                    + \"': \" + e.getMessage(), e);\n        } catch (UnknownHostException e) {\n            throw new WmiException(\"Unknown host '\" + m_Address\n                    + \"'. Failed to connect to WMI agent.\", e);\n        }\n    }","id":30620,"modified_method":"public void connect(String domain, String username, String password)\n            throws WmiException {\n        try {\n\n            m_Session = JISession.createSession(domain, username, password);\n            m_Session.useSessionSecurity(true);\n            m_Session.setGlobalSocketTimeout(5000);\n\n            m_ComStub = new JIComServer(JIProgId.valueOf(WMI_PROGID), m_Address, m_Session);\n\n            IJIComObject unknown = m_ComStub.createInstance();\n            m_ComObject = unknown.queryInterface(WMI_CLSID);\n\n            // This will obtain the dispatch interface\n            m_Dispatch = (IJIDispatch) JIObjectFactory.narrowObject(\n                    m_ComObject.queryInterface(IJIDispatch.IID));\n            JIVariant results[] = m_Dispatch.callMethodA(\"ConnectServer\",new Object[]{new JIString(m_Address),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM()\n                            ,JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),0,JIVariant.OPTIONAL_PARAM()});\n\n\n            m_WbemServices = (IJIDispatch) JIObjectFactory.narrowObject((results[0]).getObjectAsComObject());\n\n        } catch (JIException e) {\n            throw new WmiException(\"Failed to connect to host '\" + m_Address\n                    + \"': \" + e.getMessage(), e);\n        } catch (UnknownHostException e) {\n            throw new WmiException(\"Unknown host '\" + m_Address\n                    + \"'. Failed to connect to WMI agent.\", e);\n        }\n    }","commit_id":"ba07139f0d59ff5dbb8183bc1d215f634949a651","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n\n        String collectionName = parameters.get(\"collection\");\n        if (collectionName == null) {\n            //Look for the old configuration style:\n            collectionName = parameters.get(\"wmi-collection\");\n        }\n        // Find attributes to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        WmiCollection collection = WmiDataCollectionConfigFactory.getInstance().getWmiCollection(collectionName);\n        WmiAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        // Load the attribute group types.\n        loadAttributeGroupList(collection);\n\n        // Load the attribute types.\n        loadAttributeTypeList(collection);\n\n        // Create a new collection set.\n        WmiCollectionSet collectionSet = new WmiCollectionSet(agent);        \n\n        // Iterate through the WMI collection groups.\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                if (!isGroupAvailable(agentState, wpm)) continue;\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                // Collect the data\n                try {\n                    // Tell the agent to connect\n                    agentState.connect();\n\n                    // And retrieve the client object for working.\n                    WmiClient client = (WmiClient) agentState.getWmiClient();\n\n                    OnmsWbemObjectSet wOS;\n\n                    // Retrieve the WbemObjectSet from the class defined on the group.\n                    wOS = client.performInstanceOf(wpm.getWmiClass());\n\n                    // If we received a WbemObjectSet result, lets go through it and collect it.\n                    if (wOS != null) {\n                        //  Go through each object (class instance) in the object set.\n                        for (int i = 0; i < wOS.count(); i++) {\n                            // Create a new collection resource.\n                            WmiCollectionResource resource = null;\n\n                            // Fetch our WBEM Object\n                            OnmsWbemObject obj = wOS.get(i);\n\n                            // If this is multi-instance, fetch the instance name and store it.\n                            if(wOS.count()>1) {\n                                // Fetch the value of the key value. e.g. Name.\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(wpm.getKeyvalue());\n                                Object propVal = prop.getWmiValue();\n                                String instance = null;\n                                if(propVal instanceof String) {\n                                    instance = (String)propVal;\n                                } else {\n                                    instance = propVal.toString();\n                                }\n                                resource = new WmiMultiInstanceCollectionResource(agent,instance,wpm.getResourceType());\n                            } else {\n                                resource = new WmiSingleInstanceCollectionResource(agent);\n                            }\n\n\n                            for (Attrib attrib : wpm.getAttrib()) {\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(attrib.getWmiObject());                                \n                                WmiCollectionAttributeType attribType = m_attribTypeList.get(attrib.getName());\n                                resource.setAttributeValue(attribType, prop.getWmiValue().toString());\n                            }\n                            collectionSet.getResources().add(resource);\n                        }\n                    }\n                    client.disconnect();\n                } catch (WmiException e) {\n                    log().info(\"unable to collect params for wpm '\" + wpm.getName() + \"'\", e);\n                }\n            }\n        }\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n        return collectionSet;\n    }","id":30621,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n\n        String collectionName = parameters.get(\"collection\");\n        if (collectionName == null) {\n            //Look for the old configuration style:\n            collectionName = parameters.get(\"wmi-collection\");\n        }\n        // Find attributes to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        WmiCollection collection = WmiDataCollectionConfigFactory.getInstance().getWmiCollection(collectionName);\n        WmiAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        // Load the attribute group types.\n        loadAttributeGroupList(collection);\n\n        // Load the attribute types.\n        loadAttributeTypeList(collection);\n\n        // Create a new collection set.\n        WmiCollectionSet collectionSet = new WmiCollectionSet(agent);        \n\n        // Iterate through the WMI collection groups.\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                if (!isGroupAvailable(agentState, wpm)) {\n                    continue;\n                }\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                WmiClient client = null;\n                // Collect the data\n                try {\n                    // Tell the agent to connect\n                    agentState.connect();\n\n                    // And retrieve the client object for working.\n                    client = (WmiClient) agentState.getWmiClient();\n\n                    OnmsWbemObjectSet wOS;\n\n                    // Retrieve the WbemObjectSet from the class defined on the group.\n                    wOS = client.performInstanceOf(wpm.getWmiClass());\n\n                    // If we received a WbemObjectSet result, lets go through it and collect it.\n                    if (wOS != null) {\n                        //  Go through each object (class instance) in the object set.\n                        for (int i = 0; i < wOS.count(); i++) {\n                            // Create a new collection resource.\n                            WmiCollectionResource resource = null;\n\n                            // Fetch our WBEM Object\n                            OnmsWbemObject obj = wOS.get(i);\n\n                            // If this is multi-instance, fetch the instance name and store it.\n                            if(wOS.count()>1) {\n                                // Fetch the value of the key value. e.g. Name.\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(wpm.getKeyvalue());\n                                Object propVal = prop.getWmiValue();\n                                String instance = null;\n                                if(propVal instanceof String) {\n                                    instance = (String)propVal;\n                                } else {\n                                    instance = propVal.toString();\n                                }\n                                resource = new WmiMultiInstanceCollectionResource(agent,instance,wpm.getResourceType());\n                            } else {\n                                resource = new WmiSingleInstanceCollectionResource(agent);\n                            }\n\n\n                            for (Attrib attrib : wpm.getAttrib()) {\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(attrib.getWmiObject());                                \n                                WmiCollectionAttributeType attribType = m_attribTypeList.get(attrib.getName());\n                                resource.setAttributeValue(attribType, prop.getWmiValue().toString());\n                            }\n                            collectionSet.getResources().add(resource);\n                        }\n                    }\n                } catch (WmiException e) {\n                    log().info(\"unable to collect params for wpm '\" + wpm.getName() + \"'\", e);\n                } finally {\n                    if (client != null) {\n                        try {\n                            client.disconnect();\n                        } catch (WmiException e) {\n                            log().warn(\"An error occurred disconnecting while collecting from WMI\", e);\n                        }\n                    }\n                }\n            }\n        }\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n        return collectionSet;\n    }","commit_id":"ba07139f0d59ff5dbb8183bc1d215f634949a651","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <P>\n\t * Test to see if the passed host-port pair is an endpoint for a TCP server.\n\t * If there is a TCP server at the destination value then a connection is\n\t * made using the params variable data and a check is requested from the\n\t * remote WMI service.\n\t * <\/P>\n\t * \n\t * @param host\n\t *            The remote host to connect to.\n\t * @param retries\n\t *            The number of retries to attempt when connecting.\n\t * @param timeout\n\t *            The TCP socket timeout to use.\n\t * @param params\n\t *            The WMI parameters used to validate the response.\n\t * @return The WmiResult the server sent, updated by WmiManager to\n\t *         contain the proper result code based on the params passed.\n\t */\n\tprivate WmiResult isServer(InetAddress host, String user, String pass,\n\t\t\tString domain, String matchType, int retries, int timeout,\n\t\t\tWmiParams params) {\n\t\tboolean isAServer = false;\n\n\t\tWmiResult result = null;\n\t\tfor (int attempts = 0; attempts <= retries && !isAServer; attempts++) {\n\t\t\ttry {\n\t\t\t\t// Create the WMI Manager\n\t\t\t\tWmiManager mgr = new WmiManager(host.getHostAddress(), user,\n\t\t\t\t\t\tpass, domain, matchType);\n\n\t\t\t\t// Connect to the WMI server.\n\t\t\t\tmgr.init();\n\n\t\t\t\t// Perform the operation specified in the parameters.\n\t\t\t\tresult = mgr.performOp(params);\n                if(params.getWmiOperation().equals(WmiParams.WMI_OPERATION_WQL)) {\n                    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \"\n\t\t\t\t\t\t\t\t+ params.getWql()\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                } else {\n\t\t\t\t    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \\\\\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiClass()\n\t\t\t\t\t\t\t\t+ \"\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiObject()\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                }\n\n                isAServer = true;\n\n\t\t\t\t// Disconnect when complete.\n\t\t\t\tmgr.close();\n\n\t\t\t} catch (WmiException e) {\n\t\t\t\tStringBuffer message = new StringBuffer();\n\t\t\t\tmessage.append(\"WmiPlugin: Check failed... : \");\n\t\t\t\tmessage.append(e.getMessage());\n\t\t\t\tmessage.append(\" : \");\n\t\t\t\tmessage.append((e.getCause() == null ? \"\" : e.getCause()\n\t\t\t\t\t\t.getMessage()));\n\t\t\t\tlog().info(message.toString());\n\t\t\t\tisAServer = false;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":30622,"modified_method":"/**\n\t * <P>\n\t * Test to see if the passed host-port pair is an endpoint for a TCP server.\n\t * If there is a TCP server at the destination value then a connection is\n\t * made using the params variable data and a check is requested from the\n\t * remote WMI service.\n\t * <\/P>\n\t * \n\t * @param host\n\t *            The remote host to connect to.\n\t * @param retries\n\t *            The number of retries to attempt when connecting.\n\t * @param timeout\n\t *            The TCP socket timeout to use.\n\t * @param params\n\t *            The WMI parameters used to validate the response.\n\t * @return The WmiResult the server sent, updated by WmiManager to\n\t *         contain the proper result code based on the params passed.\n\t */\n\tprivate WmiResult isServer(InetAddress host, String user, String pass,\n\t\t\tString domain, String matchType, int retries, int timeout,\n\t\t\tWmiParams params) {\n\t\tboolean isAServer = false;\n\n\t\tWmiResult result = null;\n\t\tfor (int attempts = 0; attempts <= retries && !isAServer; attempts++) {\n\t\t    WmiManager mgr = null;\n\t\t\ttry {\n\t\t\t\t// Create the WMI Manager\n\t\t\t\tmgr = new WmiManager(host.getHostAddress(), user,\n\t\t\t\t\t\tpass, domain, matchType);\n\n\t\t\t\t// Connect to the WMI server.\n\t\t\t\tmgr.init();\n\n\t\t\t\t// Perform the operation specified in the parameters.\n\t\t\t\tresult = mgr.performOp(params);\n                if(params.getWmiOperation().equals(WmiParams.WMI_OPERATION_WQL)) {\n                    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \"\n\t\t\t\t\t\t\t\t+ params.getWql()\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                } else {\n\t\t\t\t    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \\\\\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiClass()\n\t\t\t\t\t\t\t\t+ \"\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiObject()\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                }\n\n                isAServer = true;\n\t\t\t} catch (WmiException e) {\n\t\t\t\tStringBuffer message = new StringBuffer();\n\t\t\t\tmessage.append(\"WmiPlugin: Check failed... : \");\n\t\t\t\tmessage.append(e.getMessage());\n\t\t\t\tmessage.append(\" : \");\n\t\t\t\tmessage.append((e.getCause() == null ? \"\" : e.getCause().getMessage()));\n\t\t\t\tlog().info(message.toString());\n\t\t\t\tisAServer = false;\n\t\t\t} finally {\n\t\t\t    if (mgr != null) {\n\t\t\t        try {\n\t\t\t            mgr.close();\n\t\t\t        } catch (WmiException e) {\n\t\t\t            log().warn(\"an error occurred closing the WMI Manager\", e);\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"ba07139f0d59ff5dbb8183bc1d215f634949a651","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static Object convertToNativeType(JIVariant type) throws WmiException {\n        try {\n            if (type.isArray()) {\n                ArrayList<Object> objs = new ArrayList<Object>();\n                Object [] array = (Object[])type.getObjectAsArray().getArrayInstance();\n\n                for(int j = 0; j < array.length; j++) {\n                    objs.add(convertToNativeType((JIVariant)array[j]));\n                }\n                \n                return objs;\n            }\n\n            switch (type.getType()) {\n                case JIVariant.VT_NULL:\n                    return null;\n                case JIVariant.VT_BSTR:\n                    return type.getObjectAsString().getString();\n                case JIVariant.VT_I2: // sint16\n                    return type.getObjectAsShort();\n                case JIVariant.VT_I4:\n                    return type.getObjectAsInt();\n                case JIVariant.VT_UI1: // uint8 (convert to Java Number)\n                    return type.getObjectAsUnsigned().getValue();\n                case JIVariant.VT_BOOL:\n                    return type.getObjectAsBoolean();\n                case JIVariant.VT_DECIMAL:\n                    return type.getObjectAsFloat();\n                case JIVariant.VT_DATE:\n                    return type.getObjectAsDate();\n                default:\n                    throw new WmiException(\"Unknown type presented (\"\n                            + type.getType() + \"), defaulting to Object: \"\n                            + type.toString());\n            }\n        } catch (JIException e) {\n            throw new WmiException(\n                    \"Failed to conver WMI type to native object: \"\n                            + e.getMessage(), e);\n        }\n    }","id":30623,"modified_method":"public static Object convertToNativeType(JIVariant type) throws WmiException {\n        try {\n            if (type.isArray()) {\n                ArrayList<Object> objs = new ArrayList<Object>();\n                Object [] array = (Object[])type.getObjectAsArray().getArrayInstance();\n\n                for (Object element : array) {\n                    objs.add(convertToNativeType((JIVariant)element));\n                }\n                \n                return objs;\n            }\n\n            switch (type.getType()) {\n                case JIVariant.VT_NULL:\n                    return null;\n                case JIVariant.VT_BSTR:\n                    return type.getObjectAsString().getString();\n                case JIVariant.VT_I2: // sint16\n                    return type.getObjectAsShort();\n                case JIVariant.VT_I4:\n                    return type.getObjectAsInt();\n                case JIVariant.VT_UI1: // uint8 (convert to Java Number)\n                    return type.getObjectAsUnsigned().getValue();\n                case JIVariant.VT_BOOL:\n                    return type.getObjectAsBoolean();\n                case JIVariant.VT_DECIMAL:\n                    return type.getObjectAsFloat();\n                case JIVariant.VT_DATE:\n                    return type.getObjectAsDate();\n                default:\n                    throw new WmiException(\"Unknown type presented (\"\n                            + type.getType() + \"), defaulting to Object: \"\n                            + type.toString());\n            }\n        } catch (JIException e) {\n            throw new WmiException(\n                    \"Failed to conver WMI type to native object: \"\n                            + e.getMessage(), e);\n        }\n    }","commit_id":"b18fc4ed59a81b84858fdc1d3c3e92199d92ee6d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void connect(String domain, String username, String password)\n            throws WmiException {\n        try {\n\n            m_Session = JISession.createSession(domain, username, password);\n            m_Session.useSessionSecurity(true);\n            m_Session.setGlobalSocketTimeout(5000);\n\n            m_ComStub = new JIComServer(JIProgId.valueOf(WMI_PROGID), m_Address, m_Session);\n\n            IJIComObject unknown = m_ComStub.createInstance();\n            m_ComObject = (IJIComObject) unknown.queryInterface(WMI_CLSID);\n\n            // This will obtain the dispatch interface\n            m_Dispatch = (IJIDispatch) JIObjectFactory.narrowObject(\n                    m_ComObject.queryInterface(IJIDispatch.IID));\n            JIVariant results[] = m_Dispatch.callMethodA(\"ConnectServer\",new Object[]{new JIString(m_Address),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM()\n                            ,JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),0,JIVariant.OPTIONAL_PARAM()});\n\n\n            m_WbemServices = (IJIDispatch) JIObjectFactory.narrowObject((results[0]).getObjectAsComObject());\n\n        } catch (JIException e) {\n            throw new WmiException(\"Failed to connect to host '\" + m_Address\n                    + \"': \" + e.getMessage(), e);\n        } catch (UnknownHostException e) {\n            throw new WmiException(\"Unknown host '\" + m_Address\n                    + \"'. Failed to connect to WMI agent.\", e);\n        }\n    }","id":30624,"modified_method":"public void connect(String domain, String username, String password)\n            throws WmiException {\n        try {\n\n            m_Session = JISession.createSession(domain, username, password);\n            m_Session.useSessionSecurity(true);\n            m_Session.setGlobalSocketTimeout(5000);\n\n            m_ComStub = new JIComServer(JIProgId.valueOf(WMI_PROGID), m_Address, m_Session);\n\n            IJIComObject unknown = m_ComStub.createInstance();\n            m_ComObject = unknown.queryInterface(WMI_CLSID);\n\n            // This will obtain the dispatch interface\n            m_Dispatch = (IJIDispatch) JIObjectFactory.narrowObject(\n                    m_ComObject.queryInterface(IJIDispatch.IID));\n            JIVariant results[] = m_Dispatch.callMethodA(\"ConnectServer\",new Object[]{new JIString(m_Address),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM()\n                            ,JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),0,JIVariant.OPTIONAL_PARAM()});\n\n\n            m_WbemServices = (IJIDispatch) JIObjectFactory.narrowObject((results[0]).getObjectAsComObject());\n\n        } catch (JIException e) {\n            throw new WmiException(\"Failed to connect to host '\" + m_Address\n                    + \"': \" + e.getMessage(), e);\n        } catch (UnknownHostException e) {\n            throw new WmiException(\"Unknown host '\" + m_Address\n                    + \"'. Failed to connect to WMI agent.\", e);\n        }\n    }","commit_id":"b18fc4ed59a81b84858fdc1d3c3e92199d92ee6d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n\n        String collectionName = parameters.get(\"collection\");\n        if (collectionName == null) {\n            //Look for the old configuration style:\n            collectionName = parameters.get(\"wmi-collection\");\n        }\n        // Find attributes to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        WmiCollection collection = WmiDataCollectionConfigFactory.getInstance().getWmiCollection(collectionName);\n        WmiAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        // Load the attribute group types.\n        loadAttributeGroupList(collection);\n\n        // Load the attribute types.\n        loadAttributeTypeList(collection);\n\n        // Create a new collection set.\n        WmiCollectionSet collectionSet = new WmiCollectionSet(agent);        \n\n        // Iterate through the WMI collection groups.\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                if (!isGroupAvailable(agentState, wpm)) continue;\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                // Collect the data\n                try {\n                    // Tell the agent to connect\n                    agentState.connect();\n\n                    // And retrieve the client object for working.\n                    WmiClient client = (WmiClient) agentState.getWmiClient();\n\n                    OnmsWbemObjectSet wOS;\n\n                    // Retrieve the WbemObjectSet from the class defined on the group.\n                    wOS = client.performInstanceOf(wpm.getWmiClass());\n\n                    // If we received a WbemObjectSet result, lets go through it and collect it.\n                    if (wOS != null) {\n                        //  Go through each object (class instance) in the object set.\n                        for (int i = 0; i < wOS.count(); i++) {\n                            // Create a new collection resource.\n                            WmiCollectionResource resource = null;\n\n                            // Fetch our WBEM Object\n                            OnmsWbemObject obj = wOS.get(i);\n\n                            // If this is multi-instance, fetch the instance name and store it.\n                            if(wOS.count()>1) {\n                                // Fetch the value of the key value. e.g. Name.\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(wpm.getKeyvalue());\n                                Object propVal = prop.getWmiValue();\n                                String instance = null;\n                                if(propVal instanceof String) {\n                                    instance = (String)propVal;\n                                } else {\n                                    instance = propVal.toString();\n                                }\n                                resource = new WmiMultiInstanceCollectionResource(agent,instance,wpm.getResourceType());\n                            } else {\n                                resource = new WmiSingleInstanceCollectionResource(agent);\n                            }\n\n\n                            for (Attrib attrib : wpm.getAttrib()) {\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(attrib.getWmiObject());                                \n                                WmiCollectionAttributeType attribType = m_attribTypeList.get(attrib.getName());\n                                resource.setAttributeValue(attribType, prop.getWmiValue().toString());\n                            }\n                            collectionSet.getResources().add(resource);\n                        }\n                    }\n                    client.disconnect();\n                } catch (WmiException e) {\n                    log().info(\"unable to collect params for wpm '\" + wpm.getName() + \"'\", e);\n                }\n            }\n        }\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n        return collectionSet;\n    }","id":30625,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n\n        String collectionName = parameters.get(\"collection\");\n        if (collectionName == null) {\n            //Look for the old configuration style:\n            collectionName = parameters.get(\"wmi-collection\");\n        }\n        // Find attributes to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        WmiCollection collection = WmiDataCollectionConfigFactory.getInstance().getWmiCollection(collectionName);\n        WmiAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        // Load the attribute group types.\n        loadAttributeGroupList(collection);\n\n        // Load the attribute types.\n        loadAttributeTypeList(collection);\n\n        // Create a new collection set.\n        WmiCollectionSet collectionSet = new WmiCollectionSet(agent);        \n\n        // Iterate through the WMI collection groups.\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                if (!isGroupAvailable(agentState, wpm)) {\n                    continue;\n                }\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                WmiClient client = null;\n                // Collect the data\n                try {\n                    // Tell the agent to connect\n                    agentState.connect();\n\n                    // And retrieve the client object for working.\n                    client = (WmiClient) agentState.getWmiClient();\n\n                    OnmsWbemObjectSet wOS;\n\n                    // Retrieve the WbemObjectSet from the class defined on the group.\n                    wOS = client.performInstanceOf(wpm.getWmiClass());\n\n                    // If we received a WbemObjectSet result, lets go through it and collect it.\n                    if (wOS != null) {\n                        //  Go through each object (class instance) in the object set.\n                        for (int i = 0; i < wOS.count(); i++) {\n                            // Create a new collection resource.\n                            WmiCollectionResource resource = null;\n\n                            // Fetch our WBEM Object\n                            OnmsWbemObject obj = wOS.get(i);\n\n                            // If this is multi-instance, fetch the instance name and store it.\n                            if(wOS.count()>1) {\n                                // Fetch the value of the key value. e.g. Name.\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(wpm.getKeyvalue());\n                                Object propVal = prop.getWmiValue();\n                                String instance = null;\n                                if(propVal instanceof String) {\n                                    instance = (String)propVal;\n                                } else {\n                                    instance = propVal.toString();\n                                }\n                                resource = new WmiMultiInstanceCollectionResource(agent,instance,wpm.getResourceType());\n                            } else {\n                                resource = new WmiSingleInstanceCollectionResource(agent);\n                            }\n\n\n                            for (Attrib attrib : wpm.getAttrib()) {\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(attrib.getWmiObject());                                \n                                WmiCollectionAttributeType attribType = m_attribTypeList.get(attrib.getName());\n                                resource.setAttributeValue(attribType, prop.getWmiValue().toString());\n                            }\n                            collectionSet.getResources().add(resource);\n                        }\n                    }\n                } catch (WmiException e) {\n                    log().info(\"unable to collect params for wpm '\" + wpm.getName() + \"'\", e);\n                } finally {\n                    if (client != null) {\n                        try {\n                            client.disconnect();\n                        } catch (WmiException e) {\n                            log().warn(\"An error occurred disconnecting while collecting from WMI\", e);\n                        }\n                    }\n                }\n            }\n        }\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n        return collectionSet;\n    }","commit_id":"b18fc4ed59a81b84858fdc1d3c3e92199d92ee6d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <P>\n\t * Test to see if the passed host-port pair is an endpoint for a TCP server.\n\t * If there is a TCP server at the destination value then a connection is\n\t * made using the params variable data and a check is requested from the\n\t * remote WMI service.\n\t * <\/P>\n\t * \n\t * @param host\n\t *            The remote host to connect to.\n\t * @param retries\n\t *            The number of retries to attempt when connecting.\n\t * @param timeout\n\t *            The TCP socket timeout to use.\n\t * @param params\n\t *            The WMI parameters used to validate the response.\n\t * @return The WmiResult the server sent, updated by WmiManager to\n\t *         contain the proper result code based on the params passed.\n\t */\n\tprivate WmiResult isServer(InetAddress host, String user, String pass,\n\t\t\tString domain, String matchType, int retries, int timeout,\n\t\t\tWmiParams params) {\n\t\tboolean isAServer = false;\n\n\t\tWmiResult result = null;\n\t\tfor (int attempts = 0; attempts <= retries && !isAServer; attempts++) {\n\t\t\ttry {\n\t\t\t\t// Create the WMI Manager\n\t\t\t\tWmiManager mgr = new WmiManager(host.getHostAddress(), user,\n\t\t\t\t\t\tpass, domain, matchType);\n\n\t\t\t\t// Connect to the WMI server.\n\t\t\t\tmgr.init();\n\n\t\t\t\t// Perform the operation specified in the parameters.\n\t\t\t\tresult = mgr.performOp(params);\n                if(params.getWmiOperation().equals(WmiParams.WMI_OPERATION_WQL)) {\n                    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \"\n\t\t\t\t\t\t\t\t+ params.getWql()\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                } else {\n\t\t\t\t    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \\\\\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiClass()\n\t\t\t\t\t\t\t\t+ \"\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiObject()\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                }\n\n                isAServer = true;\n\n\t\t\t\t// Disconnect when complete.\n\t\t\t\tmgr.close();\n\n\t\t\t} catch (WmiException e) {\n\t\t\t\tStringBuffer message = new StringBuffer();\n\t\t\t\tmessage.append(\"WmiPlugin: Check failed... : \");\n\t\t\t\tmessage.append(e.getMessage());\n\t\t\t\tmessage.append(\" : \");\n\t\t\t\tmessage.append((e.getCause() == null ? \"\" : e.getCause()\n\t\t\t\t\t\t.getMessage()));\n\t\t\t\tlog().info(message.toString());\n\t\t\t\tisAServer = false;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":30626,"modified_method":"/**\n\t * <P>\n\t * Test to see if the passed host-port pair is an endpoint for a TCP server.\n\t * If there is a TCP server at the destination value then a connection is\n\t * made using the params variable data and a check is requested from the\n\t * remote WMI service.\n\t * <\/P>\n\t * \n\t * @param host\n\t *            The remote host to connect to.\n\t * @param retries\n\t *            The number of retries to attempt when connecting.\n\t * @param timeout\n\t *            The TCP socket timeout to use.\n\t * @param params\n\t *            The WMI parameters used to validate the response.\n\t * @return The WmiResult the server sent, updated by WmiManager to\n\t *         contain the proper result code based on the params passed.\n\t */\n\tprivate WmiResult isServer(InetAddress host, String user, String pass,\n\t\t\tString domain, String matchType, int retries, int timeout,\n\t\t\tWmiParams params) {\n\t\tboolean isAServer = false;\n\n\t\tWmiResult result = null;\n\t\tfor (int attempts = 0; attempts <= retries && !isAServer; attempts++) {\n\t\t    WmiManager mgr = null;\n\t\t\ttry {\n\t\t\t\t// Create the WMI Manager\n\t\t\t\tmgr = new WmiManager(host.getHostAddress(), user,\n\t\t\t\t\t\tpass, domain, matchType);\n\n\t\t\t\t// Connect to the WMI server.\n\t\t\t\tmgr.init();\n\n\t\t\t\t// Perform the operation specified in the parameters.\n\t\t\t\tresult = mgr.performOp(params);\n                if(params.getWmiOperation().equals(WmiParams.WMI_OPERATION_WQL)) {\n                    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \"\n\t\t\t\t\t\t\t\t+ params.getWql()\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                } else {\n\t\t\t\t    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \\\\\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiClass()\n\t\t\t\t\t\t\t\t+ \"\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiObject()\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                }\n\n                isAServer = true;\n\t\t\t} catch (WmiException e) {\n\t\t\t\tStringBuffer message = new StringBuffer();\n\t\t\t\tmessage.append(\"WmiPlugin: Check failed... : \");\n\t\t\t\tmessage.append(e.getMessage());\n\t\t\t\tmessage.append(\" : \");\n\t\t\t\tmessage.append((e.getCause() == null ? \"\" : e.getCause().getMessage()));\n\t\t\t\tlog().info(message.toString());\n\t\t\t\tisAServer = false;\n\t\t\t} finally {\n\t\t\t    if (mgr != null) {\n\t\t\t        try {\n\t\t\t            mgr.close();\n\t\t\t        } catch (WmiException e) {\n\t\t\t            log().warn(\"an error occurred closing the WMI Manager\", e);\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"b18fc4ed59a81b84858fdc1d3c3e92199d92ee6d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void connect(String domain, String username, String password)\n            throws WmiException {\n        try {\n\n            m_Session = JISession.createSession(domain, username, password);\n            m_Session.useSessionSecurity(true);\n            m_Session.setGlobalSocketTimeout(5000);\n\n            m_ComStub = new JIComServer(JIProgId.valueOf(WMI_PROGID), m_Address, m_Session);\n\n            IJIComObject unknown = m_ComStub.createInstance();\n            m_ComObject = (IJIComObject) unknown.queryInterface(WMI_CLSID);\n\n            // This will obtain the dispatch interface\n            m_Dispatch = (IJIDispatch) JIObjectFactory.narrowObject(\n                    m_ComObject.queryInterface(IJIDispatch.IID));\n            JIVariant results[] = m_Dispatch.callMethodA(\"ConnectServer\",new Object[]{new JIString(m_Address),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM()\n                            ,JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),0,JIVariant.OPTIONAL_PARAM()});\n\n\n            m_WbemServices = (IJIDispatch) JIObjectFactory.narrowObject((results[0]).getObjectAsComObject());\n\n        } catch (JIException e) {\n            throw new WmiException(\"Failed to connect to host '\" + m_Address\n                    + \"': \" + e.getMessage(), e);\n        } catch (UnknownHostException e) {\n            throw new WmiException(\"Unknown host '\" + m_Address\n                    + \"'. Failed to connect to WMI agent.\", e);\n        }\n    }","id":30627,"modified_method":"public void connect(String domain, String username, String password)\n            throws WmiException {\n        try {\n\n            m_Session = JISession.createSession(domain, username, password);\n            m_Session.useSessionSecurity(true);\n            m_Session.setGlobalSocketTimeout(5000);\n\n            m_ComStub = new JIComServer(JIProgId.valueOf(WMI_PROGID), m_Address, m_Session);\n\n            IJIComObject unknown = m_ComStub.createInstance();\n            m_ComObject = unknown.queryInterface(WMI_CLSID);\n\n            // This will obtain the dispatch interface\n            m_Dispatch = (IJIDispatch) JIObjectFactory.narrowObject(\n                    m_ComObject.queryInterface(IJIDispatch.IID));\n            JIVariant results[] = m_Dispatch.callMethodA(\"ConnectServer\",new Object[]{new JIString(m_Address),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM()\n                            ,JIVariant.OPTIONAL_PARAM(),JIVariant.OPTIONAL_PARAM(),0,JIVariant.OPTIONAL_PARAM()});\n\n\n            m_WbemServices = (IJIDispatch) JIObjectFactory.narrowObject((results[0]).getObjectAsComObject());\n\n        } catch (JIException e) {\n            throw new WmiException(\"Failed to connect to host '\" + m_Address\n                    + \"': \" + e.getMessage(), e);\n        } catch (UnknownHostException e) {\n            throw new WmiException(\"Unknown host '\" + m_Address\n                    + \"'. Failed to connect to WMI agent.\", e);\n        }\n    }","commit_id":"8d8033e919791f4c2e7d5f621c02ca2c037a11ee","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static Object convertToNativeType(JIVariant type) throws WmiException {\n        try {\n            if (type.isArray()) {\n                ArrayList<Object> objs = new ArrayList<Object>();\n                Object [] array = (Object[])type.getObjectAsArray().getArrayInstance();\n\n                for(int j = 0; j < array.length; j++) {\n                    objs.add(convertToNativeType((JIVariant)array[j]));\n                }\n                \n                return objs;\n            }\n\n            switch (type.getType()) {\n                case JIVariant.VT_NULL:\n                    return null;\n                case JIVariant.VT_BSTR:\n                    return type.getObjectAsString().getString();\n                case JIVariant.VT_I2: // sint16\n                    return type.getObjectAsShort();\n                case JIVariant.VT_I4:\n                    return type.getObjectAsInt();\n                case JIVariant.VT_UI1: // uint8 (convert to Java Number)\n                    return type.getObjectAsUnsigned().getValue();\n                case JIVariant.VT_BOOL:\n                    return type.getObjectAsBoolean();\n                case JIVariant.VT_DECIMAL:\n                    return type.getObjectAsFloat();\n                case JIVariant.VT_DATE:\n                    return type.getObjectAsDate();\n                default:\n                    throw new WmiException(\"Unknown type presented (\"\n                            + type.getType() + \"), defaulting to Object: \"\n                            + type.toString());\n            }\n        } catch (JIException e) {\n            throw new WmiException(\n                    \"Failed to conver WMI type to native object: \"\n                            + e.getMessage(), e);\n        }\n    }","id":30628,"modified_method":"public static Object convertToNativeType(JIVariant type) throws WmiException {\n        try {\n            if (type.isArray()) {\n                ArrayList<Object> objs = new ArrayList<Object>();\n                Object [] array = (Object[])type.getObjectAsArray().getArrayInstance();\n\n                for (Object element : array) {\n                    objs.add(convertToNativeType((JIVariant)element));\n                }\n                \n                return objs;\n            }\n\n            switch (type.getType()) {\n                case JIVariant.VT_NULL:\n                    return null;\n                case JIVariant.VT_BSTR:\n                    return type.getObjectAsString().getString();\n                case JIVariant.VT_I2: // sint16\n                    return type.getObjectAsShort();\n                case JIVariant.VT_I4:\n                    return type.getObjectAsInt();\n                case JIVariant.VT_UI1: // uint8 (convert to Java Number)\n                    return type.getObjectAsUnsigned().getValue();\n                case JIVariant.VT_BOOL:\n                    return type.getObjectAsBoolean();\n                case JIVariant.VT_DECIMAL:\n                    return type.getObjectAsFloat();\n                case JIVariant.VT_DATE:\n                    return type.getObjectAsDate();\n                default:\n                    throw new WmiException(\"Unknown type presented (\"\n                            + type.getType() + \"), defaulting to Object: \"\n                            + type.toString());\n            }\n        } catch (JIException e) {\n            throw new WmiException(\n                    \"Failed to conver WMI type to native object: \"\n                            + e.getMessage(), e);\n        }\n    }","commit_id":"8d8033e919791f4c2e7d5f621c02ca2c037a11ee","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n\n        String collectionName = parameters.get(\"collection\");\n        if (collectionName == null) {\n            //Look for the old configuration style:\n            collectionName = parameters.get(\"wmi-collection\");\n        }\n        // Find attributes to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        WmiCollection collection = WmiDataCollectionConfigFactory.getInstance().getWmiCollection(collectionName);\n        WmiAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        // Load the attribute group types.\n        loadAttributeGroupList(collection);\n\n        // Load the attribute types.\n        loadAttributeTypeList(collection);\n\n        // Create a new collection set.\n        WmiCollectionSet collectionSet = new WmiCollectionSet(agent);        \n\n        // Iterate through the WMI collection groups.\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                if (!isGroupAvailable(agentState, wpm)) continue;\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                // Collect the data\n                try {\n                    // Tell the agent to connect\n                    agentState.connect();\n\n                    // And retrieve the client object for working.\n                    WmiClient client = (WmiClient) agentState.getWmiClient();\n\n                    OnmsWbemObjectSet wOS;\n\n                    // Retrieve the WbemObjectSet from the class defined on the group.\n                    wOS = client.performInstanceOf(wpm.getWmiClass());\n\n                    // If we received a WbemObjectSet result, lets go through it and collect it.\n                    if (wOS != null) {\n                        //  Go through each object (class instance) in the object set.\n                        for (int i = 0; i < wOS.count(); i++) {\n                            // Create a new collection resource.\n                            WmiCollectionResource resource = null;\n\n                            // Fetch our WBEM Object\n                            OnmsWbemObject obj = wOS.get(i);\n\n                            // If this is multi-instance, fetch the instance name and store it.\n                            if(wOS.count()>1) {\n                                // Fetch the value of the key value. e.g. Name.\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(wpm.getKeyvalue());\n                                Object propVal = prop.getWmiValue();\n                                String instance = null;\n                                if(propVal instanceof String) {\n                                    instance = (String)propVal;\n                                } else {\n                                    instance = propVal.toString();\n                                }\n                                resource = new WmiMultiInstanceCollectionResource(agent,instance,wpm.getResourceType());\n                            } else {\n                                resource = new WmiSingleInstanceCollectionResource(agent);\n                            }\n\n\n                            for (Attrib attrib : wpm.getAttrib()) {\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(attrib.getWmiObject());                                \n                                WmiCollectionAttributeType attribType = m_attribTypeList.get(attrib.getName());\n                                resource.setAttributeValue(attribType, prop.getWmiValue().toString());\n                            }\n                            collectionSet.getResources().add(resource);\n                        }\n                    }\n                    client.disconnect();\n                } catch (WmiException e) {\n                    log().info(\"unable to collect params for wpm '\" + wpm.getName() + \"'\", e);\n                }\n            }\n        }\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n        return collectionSet;\n    }","id":30629,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, Map<String, String> parameters) {\n\n        String collectionName = parameters.get(\"collection\");\n        if (collectionName == null) {\n            //Look for the old configuration style:\n            collectionName = parameters.get(\"wmi-collection\");\n        }\n        // Find attributes to collect - check groups in configuration. For each,\n        // check scheduled nodes to see if that group should be collected\n        WmiCollection collection = WmiDataCollectionConfigFactory.getInstance().getWmiCollection(collectionName);\n        WmiAgentState agentState = m_scheduledNodes.get(agent.getNodeId());\n\n        // Load the attribute group types.\n        loadAttributeGroupList(collection);\n\n        // Load the attribute types.\n        loadAttributeTypeList(collection);\n\n        // Create a new collection set.\n        WmiCollectionSet collectionSet = new WmiCollectionSet(agent);        \n\n        // Iterate through the WMI collection groups.\n        for (Wpm wpm : collection.getWpms().getWpm()) {\n            // A wpm consists of a list of attributes, identified by name\n            if (agentState.shouldCheckAvailability(wpm.getName(), wpm.getRecheckInterval())) {\n                if (!isGroupAvailable(agentState, wpm)) {\n                    continue;\n                }\n            }\n\n            if (agentState.groupIsAvailable(wpm.getName())) {\n                WmiClient client = null;\n                // Collect the data\n                try {\n                    // Tell the agent to connect\n                    agentState.connect();\n\n                    // And retrieve the client object for working.\n                    client = (WmiClient) agentState.getWmiClient();\n\n                    OnmsWbemObjectSet wOS;\n\n                    // Retrieve the WbemObjectSet from the class defined on the group.\n                    wOS = client.performInstanceOf(wpm.getWmiClass());\n\n                    // If we received a WbemObjectSet result, lets go through it and collect it.\n                    if (wOS != null) {\n                        //  Go through each object (class instance) in the object set.\n                        for (int i = 0; i < wOS.count(); i++) {\n                            // Create a new collection resource.\n                            WmiCollectionResource resource = null;\n\n                            // Fetch our WBEM Object\n                            OnmsWbemObject obj = wOS.get(i);\n\n                            // If this is multi-instance, fetch the instance name and store it.\n                            if(wOS.count()>1) {\n                                // Fetch the value of the key value. e.g. Name.\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(wpm.getKeyvalue());\n                                Object propVal = prop.getWmiValue();\n                                String instance = null;\n                                if(propVal instanceof String) {\n                                    instance = (String)propVal;\n                                } else {\n                                    instance = propVal.toString();\n                                }\n                                resource = new WmiMultiInstanceCollectionResource(agent,instance,wpm.getResourceType());\n                            } else {\n                                resource = new WmiSingleInstanceCollectionResource(agent);\n                            }\n\n\n                            for (Attrib attrib : wpm.getAttrib()) {\n                                OnmsWbemProperty prop = obj.getWmiProperties().getByName(attrib.getWmiObject());                                \n                                WmiCollectionAttributeType attribType = m_attribTypeList.get(attrib.getName());\n                                resource.setAttributeValue(attribType, prop.getWmiValue().toString());\n                            }\n                            collectionSet.getResources().add(resource);\n                        }\n                    }\n                } catch (WmiException e) {\n                    log().info(\"unable to collect params for wpm '\" + wpm.getName() + \"'\", e);\n                } finally {\n                    if (client != null) {\n                        try {\n                            client.disconnect();\n                        } catch (WmiException e) {\n                            log().warn(\"An error occurred disconnecting while collecting from WMI\", e);\n                        }\n                    }\n                }\n            }\n        }\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n        return collectionSet;\n    }","commit_id":"8d8033e919791f4c2e7d5f621c02ca2c037a11ee","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <P>\n\t * Test to see if the passed host-port pair is an endpoint for a TCP server.\n\t * If there is a TCP server at the destination value then a connection is\n\t * made using the params variable data and a check is requested from the\n\t * remote WMI service.\n\t * <\/P>\n\t * \n\t * @param host\n\t *            The remote host to connect to.\n\t * @param retries\n\t *            The number of retries to attempt when connecting.\n\t * @param timeout\n\t *            The TCP socket timeout to use.\n\t * @param params\n\t *            The WMI parameters used to validate the response.\n\t * @return The WmiResult the server sent, updated by WmiManager to\n\t *         contain the proper result code based on the params passed.\n\t */\n\tprivate WmiResult isServer(InetAddress host, String user, String pass,\n\t\t\tString domain, String matchType, int retries, int timeout,\n\t\t\tWmiParams params) {\n\t\tboolean isAServer = false;\n\n\t\tWmiResult result = null;\n\t\tfor (int attempts = 0; attempts <= retries && !isAServer; attempts++) {\n\t\t\ttry {\n\t\t\t\t// Create the WMI Manager\n\t\t\t\tWmiManager mgr = new WmiManager(host.getHostAddress(), user,\n\t\t\t\t\t\tpass, domain, matchType);\n\n\t\t\t\t// Connect to the WMI server.\n\t\t\t\tmgr.init();\n\n\t\t\t\t// Perform the operation specified in the parameters.\n\t\t\t\tresult = mgr.performOp(params);\n                if(params.getWmiOperation().equals(WmiParams.WMI_OPERATION_WQL)) {\n                    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \"\n\t\t\t\t\t\t\t\t+ params.getWql()\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                } else {\n\t\t\t\t    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \\\\\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiClass()\n\t\t\t\t\t\t\t\t+ \"\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiObject()\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                }\n\n                isAServer = true;\n\n\t\t\t\t// Disconnect when complete.\n\t\t\t\tmgr.close();\n\n\t\t\t} catch (WmiException e) {\n\t\t\t\tStringBuffer message = new StringBuffer();\n\t\t\t\tmessage.append(\"WmiPlugin: Check failed... : \");\n\t\t\t\tmessage.append(e.getMessage());\n\t\t\t\tmessage.append(\" : \");\n\t\t\t\tmessage.append((e.getCause() == null ? \"\" : e.getCause()\n\t\t\t\t\t\t.getMessage()));\n\t\t\t\tlog().info(message.toString());\n\t\t\t\tisAServer = false;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":30630,"modified_method":"/**\n\t * <P>\n\t * Test to see if the passed host-port pair is an endpoint for a TCP server.\n\t * If there is a TCP server at the destination value then a connection is\n\t * made using the params variable data and a check is requested from the\n\t * remote WMI service.\n\t * <\/P>\n\t * \n\t * @param host\n\t *            The remote host to connect to.\n\t * @param retries\n\t *            The number of retries to attempt when connecting.\n\t * @param timeout\n\t *            The TCP socket timeout to use.\n\t * @param params\n\t *            The WMI parameters used to validate the response.\n\t * @return The WmiResult the server sent, updated by WmiManager to\n\t *         contain the proper result code based on the params passed.\n\t */\n\tprivate WmiResult isServer(InetAddress host, String user, String pass,\n\t\t\tString domain, String matchType, int retries, int timeout,\n\t\t\tWmiParams params) {\n\t\tboolean isAServer = false;\n\n\t\tWmiResult result = null;\n\t\tfor (int attempts = 0; attempts <= retries && !isAServer; attempts++) {\n\t\t    WmiManager mgr = null;\n\t\t\ttry {\n\t\t\t\t// Create the WMI Manager\n\t\t\t\tmgr = new WmiManager(host.getHostAddress(), user,\n\t\t\t\t\t\tpass, domain, matchType);\n\n\t\t\t\t// Connect to the WMI server.\n\t\t\t\tmgr.init();\n\n\t\t\t\t// Perform the operation specified in the parameters.\n\t\t\t\tresult = mgr.performOp(params);\n                if(params.getWmiOperation().equals(WmiParams.WMI_OPERATION_WQL)) {\n                    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \"\n\t\t\t\t\t\t\t\t+ params.getWql()\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                } else {\n\t\t\t\t    log().debug(\n\t\t\t\t\t\t\"WmiPlugin: \\\\\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiClass()\n\t\t\t\t\t\t\t\t+ \"\\\\\"\n\t\t\t\t\t\t\t\t+ params.getWmiObject()\n\t\t\t\t\t\t\t\t+ \" : \"\n\t\t\t\t\t\t\t\t+ WmiResult.convertStateToString(result\n\t\t\t\t\t\t\t\t\t\t.getResultCode()));\n                }\n\n                isAServer = true;\n\t\t\t} catch (WmiException e) {\n\t\t\t\tStringBuffer message = new StringBuffer();\n\t\t\t\tmessage.append(\"WmiPlugin: Check failed... : \");\n\t\t\t\tmessage.append(e.getMessage());\n\t\t\t\tmessage.append(\" : \");\n\t\t\t\tmessage.append((e.getCause() == null ? \"\" : e.getCause().getMessage()));\n\t\t\t\tlog().info(message.toString());\n\t\t\t\tisAServer = false;\n\t\t\t} finally {\n\t\t\t    if (mgr != null) {\n\t\t\t        try {\n\t\t\t            mgr.close();\n\t\t\t        } catch (WmiException e) {\n\t\t\t            log().warn(\"an error occurred closing the WMI Manager\", e);\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"8d8033e919791f4c2e7d5f621c02ca2c037a11ee","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void update(final PresentationData data) {\n    if (!validate()) {\n      return;\n    }\n\n    final PsiElement value = extractPsiFromValue();\n    LOG.assertTrue(value.isValid());\n\n    int flags = getIconableFlags();\n\n    try {\n      Icon icon = value.getIcon(flags);\n      data.setClosedIcon(icon);\n      data.setOpenIcon(icon);\n    }\n    catch (IndexNotReadyException ignored) {\n    }\n    data.setPresentableText(myName);\n\n    try {\n      if (isDeprecated()) {\n        data.setAttributesKey(CodeInsightColors.DEPRECATED_ATTRIBUTES);\n      }\n    }\n    catch (IndexNotReadyException ignored) {\n    }\n    updateImpl(data);\n    for(ProjectViewNodeDecorator decorator: Extensions.getExtensions(ProjectViewNodeDecorator.EP_NAME, myProject)) {\n      decorator.decorate(this, data);\n    }\n  }","id":30631,"modified_method":"public void update(final PresentationData data) {\n    if (!validate()) {\n      return;\n    }\n\n    final PsiElement value = extractPsiFromValue();\n    LOG.assertTrue(value.isValid());\n\n    int flags = getIconableFlags();\n\n    try {\n      Icon icon = value.getIcon(flags);\n      data.setClosedIcon(icon);\n      data.setOpenIcon(icon);\n    }\n    catch (IndexNotReadyException ignored) {\n    }\n    data.setPresentableText(myName);\n\n    try {\n      if (isDeprecated()) {\n        data.setAttributesKey(CodeInsightColors.DEPRECATED_ATTRIBUTES);\n      }\n    }\n    catch (IndexNotReadyException ignored) {\n    }\n    updateImpl(data);\n    for(ProjectViewNodeDecorator decorator: Extensions.getExtensions(ProjectViewNodeDecorator.EP_NAME, myProject)) {\n      decorator.decorate(this, data);\n    }\n\n    value.putUserData(Iconable.LAST_COMPUTED_ICON, data.getIcon(false));\n  }","commit_id":"34874a6e4e2a26e818a45622ee919894474e24d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Icon getIcon(int flags) {\n    if (!(this instanceof PsiElement)) return null;\n\n    try {\n      final PsiElement element = (PsiElement)this;\n\n      final Icon providersIcon = PsiIconUtil.getProvidersIcon(element, flags);\n      if (providersIcon != null) {\n        return providersIcon instanceof RowIcon ? (RowIcon)providersIcon : createLayeredIcon(providersIcon, flags);\n      }\n\n      return getElementIcon(flags);\n    }\n    catch (ProcessCanceledException e) {\n      throw e;\n    }\n    catch (IndexNotReadyException e) {\n      throw e;\n    }\n    catch(Exception e) {\n      LOG.error(e);\n        return null;\n      }\n    }","id":30632,"modified_method":"@Nullable\n  public Icon getIcon(int flags) {\n    if (!(this instanceof PsiElement)) return null;\n\n    try {\n      return computeIcon(flags);\n    }\n    catch (ProcessCanceledException e) {\n      throw e;\n    }\n    catch (IndexNotReadyException e) {\n      throw e;\n    }\n    catch(Exception e) {\n      LOG.error(e);\n        return null;\n      }\n    }","commit_id":"34874a6e4e2a26e818a45622ee919894474e24d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Icon getIcon(final VirtualFile file, final int flags, final Project project) {\n    Icon lastIcon = file.getUserData(LAST_FILE_ICON);\n\n    return IconDeferrer.getInstance().defer(lastIcon != null ? lastIcon : file.getIcon(), new FileIconKey(file, project, flags), new Function<FileIconKey, Icon>() {\n      public Icon fun(final FileIconKey key) {\n        VirtualFile file = key.getFile();\n        int flags = key.getFlags();\n        Project project = key.getProject();\n\n        if (!file.isValid() || project != null && project.isDisposed()) return null;\n\n        Icon providersIcon = getProvidersIcon(file, flags, project);\n        Icon icon = providersIcon == null ? file.getIcon() : providersIcon;\n\n        final boolean dumb = project != null && DumbService.getInstance(project).isDumb();\n        for (FileIconPatcher patcher : getPatchers()) {\n          if (dumb && !(patcher instanceof DumbAware)) {\n            continue;\n          }\n\n          icon = patcher.patchIcon(icon, file, flags, project);\n        }\n\n        if ((flags & Iconable.ICON_FLAG_READ_STATUS) != 0 && !file.isWritable()) {\n          icon = new LayeredIcon(icon, Icons.LOCKED_ICON);\n        }\n        \n        file.putUserData(LAST_FILE_ICON, icon);\n\n        return icon;\n      }\n    });\n  }","id":30633,"modified_method":"public static Icon getIcon(final VirtualFile file, final int flags, final Project project) {\n    Icon lastIcon = file.getUserData(Iconable.LAST_COMPUTED_ICON);\n\n    return IconDeferrer.getInstance().defer(lastIcon != null ? lastIcon : file.getIcon(), new FileIconKey(file, project, flags), new Function<FileIconKey, Icon>() {\n      public Icon fun(final FileIconKey key) {\n        VirtualFile file = key.getFile();\n        int flags = key.getFlags();\n        Project project = key.getProject();\n\n        if (!file.isValid() || project != null && project.isDisposed()) return null;\n\n        Icon providersIcon = getProvidersIcon(file, flags, project);\n        Icon icon = providersIcon == null ? file.getIcon() : providersIcon;\n\n        final boolean dumb = project != null && DumbService.getInstance(project).isDumb();\n        for (FileIconPatcher patcher : getPatchers()) {\n          if (dumb && !(patcher instanceof DumbAware)) {\n            continue;\n          }\n\n          icon = patcher.patchIcon(icon, file, flags, project);\n        }\n\n        if ((flags & Iconable.ICON_FLAG_READ_STATUS) != 0 && !file.isWritable()) {\n          icon = new LayeredIcon(icon, Icons.LOCKED_ICON);\n        }\n        \n        file.putUserData(Iconable.LAST_COMPUTED_ICON, icon);\n\n        return icon;\n      }\n    });\n  }","commit_id":"34874a6e4e2a26e818a45622ee919894474e24d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Icon getClassIcon(final int flags, final PsiClass aClass) {\n    Icon symbolIcon = ElementPresentationUtil.getClassIconOfKind(aClass, ElementPresentationUtil.getBasicClassKind(aClass));\n    RowIcon baseIcon = ElementBase.createLayeredIcon(symbolIcon, 0);\n\n    return IconDeferrer.getInstance().defer(ElementPresentationUtil.addVisibilityIcon(aClass, flags, baseIcon),\n                                            new ClassIconRequest(aClass, flags),\n                                            FULL_ICON_EVALUATOR);\n  }","id":30634,"modified_method":"public static Icon getClassIcon(final int flags, final PsiClass aClass) {\n    Icon base = aClass.getUserData(Iconable.LAST_COMPUTED_ICON);\n    if (base == null) {\n      Icon symbolIcon = ElementPresentationUtil.getClassIconOfKind(aClass, ElementPresentationUtil.getBasicClassKind(aClass));\n      RowIcon baseIcon = ElementBase.createLayeredIcon(symbolIcon, 0);\n      base = ElementPresentationUtil.addVisibilityIcon(aClass, flags, baseIcon);\n    }\n\n    return IconDeferrer.getInstance().defer(base, new ClassIconRequest(aClass, flags), FULL_ICON_EVALUATOR);\n  }","commit_id":"34874a6e4e2a26e818a45622ee919894474e24d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Icon getIcon(int flags) {\n    if (!(this instanceof PsiElement)) return null;\n\n    final PsiElement element = (PsiElement)this;\n\n    final Icon providersIcon = IconUtil.getProvidersIcon(element, flags);\n    if(providersIcon != null) {\n      return providersIcon instanceof RowIcon ? addVisibilityIcon(element, flags, (RowIcon)providersIcon) : providersIcon;\n    }\n\n    RowIcon baseIcon;\n    final boolean isLocked = (flags & ICON_FLAG_READ_STATUS) != 0 && !element.isWritable();\n    int elementFlags = isLocked ? FLAGS_LOCKED : 0;\n    if (element instanceof PsiDirectory) {\n      Icon symbolIcon;\n      final PsiDirectory psiDirectory = (PsiDirectory)element;\n      if (psiDirectory.getPackage() != null) {\n        symbolIcon = Icons.PACKAGE_ICON;\n      }\n      else {\n        symbolIcon = Icons.DIRECTORY_CLOSED_ICON;\n      }\n      final VirtualFile vFile = psiDirectory.getVirtualFile();\n      final Project project = psiDirectory.getProject();\n      boolean isExcluded = isExcluded(vFile, project);\n      baseIcon = createLayeredIcon(symbolIcon, elementFlags | (isExcluded ? FLAGS_EXCLUDED : 0));\n    }\n    else if (element instanceof PsiPackage) {\n      baseIcon = createLayeredIcon(Icons.PACKAGE_ICON, elementFlags);\n    }\n    else if (element instanceof PsiFile) {\n      PsiFile file = (PsiFile)element;\n\n      VirtualFile virtualFile = file.getVirtualFile();\n      final Icon fileTypeIcon;\n      if (virtualFile == null) {\n        fileTypeIcon = file.getFileType().getIcon();\n      }\n      else {\n        fileTypeIcon = IconUtil.getIcon(virtualFile, flags & ~ICON_FLAG_READ_STATUS, file.getProject());\n      }\n      baseIcon = createLayeredIcon(fileTypeIcon, elementFlags);\n    }\n    else if (element instanceof PsiClass) {\n      final PsiClass aClass = (PsiClass)element;\n      Icon symbolIcon = getClassBaseIcon(aClass);\n      baseIcon = createLayeredIcon(symbolIcon, getFlags(aClass, isLocked));\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)element;\n      Icon methodIcon = method.hasModifierProperty(PsiModifier.ABSTRACT) ? Icons.ABSTRACT_METHOD_ICON : Icons.METHOD_ICON;\n      baseIcon = createLayeredIcon(methodIcon, getFlags(method, false));\n    }\n    else if (element instanceof PsiField) {\n      baseIcon = createLayeredIcon(Icons.FIELD_ICON, getFlags((PsiField)element, false));\n    }\n    else if (element instanceof PsiParameter) {\n      baseIcon = createLayeredIcon(Icons.PARAMETER_ICON, 0);\n    }\n    else if (element instanceof PsiVariable) {\n      baseIcon = createLayeredIcon(Icons.VARIABLE_ICON, getFlags((PsiVariable)element, false));\n    }\n    else if (element instanceof XmlTag) {\n      return Icons.XML_TAG_ICON;\n    }\n    else if (element instanceof PsiAntElement) {\n      return ((PsiAntElement)element).getRole().getIcon();\n    }\n    else if (element instanceof PsiClassObjectAccessExpression) {\n      final RowIcon rowIcon = createLayeredIcon(Icons.FIELD_ICON, 0);\n      rowIcon.setIcon(Icons.PUBLIC_ICON, 1);\n      return rowIcon;\n    }\n    else {\n      return null;\n    }\n    return addVisibilityIcon(element, flags, baseIcon);\n  }","id":30635,"modified_method":"@Nullable\n  public Icon getIcon(int flags) {\n    if (!(this instanceof PsiElement)) return null;\n\n    final PsiElement element = (PsiElement)this;\n\n    final Icon providersIcon = IconUtil.getProvidersIcon(element, flags);\n    if(providersIcon != null) {\n      return addVisibilityIcon(element, flags, providersIcon instanceof RowIcon ? (RowIcon)providersIcon : createLayeredIcon(providersIcon, flags));\n    }\n\n    RowIcon baseIcon;\n    final boolean isLocked = (flags & ICON_FLAG_READ_STATUS) != 0 && !element.isWritable();\n    int elementFlags = isLocked ? FLAGS_LOCKED : 0;\n    if (element instanceof PsiDirectory) {\n      Icon symbolIcon;\n      final PsiDirectory psiDirectory = (PsiDirectory)element;\n      if (psiDirectory.getPackage() != null) {\n        symbolIcon = Icons.PACKAGE_ICON;\n      }\n      else {\n        symbolIcon = Icons.DIRECTORY_CLOSED_ICON;\n      }\n      final VirtualFile vFile = psiDirectory.getVirtualFile();\n      final Project project = psiDirectory.getProject();\n      boolean isExcluded = isExcluded(vFile, project);\n      baseIcon = createLayeredIcon(symbolIcon, elementFlags | (isExcluded ? FLAGS_EXCLUDED : 0));\n    }\n    else if (element instanceof PsiPackage) {\n      baseIcon = createLayeredIcon(Icons.PACKAGE_ICON, elementFlags);\n    }\n    else if (element instanceof PsiFile) {\n      PsiFile file = (PsiFile)element;\n\n      VirtualFile virtualFile = file.getVirtualFile();\n      final Icon fileTypeIcon;\n      if (virtualFile == null) {\n        fileTypeIcon = file.getFileType().getIcon();\n      }\n      else {\n        fileTypeIcon = IconUtil.getIcon(virtualFile, flags & ~ICON_FLAG_READ_STATUS, file.getProject());\n      }\n      baseIcon = createLayeredIcon(fileTypeIcon, elementFlags);\n    }\n    else if (element instanceof PsiClass) {\n      final PsiClass aClass = (PsiClass)element;\n      Icon symbolIcon = getClassBaseIcon(aClass);\n      baseIcon = createLayeredIcon(symbolIcon, getFlags(aClass, isLocked));\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)element;\n      Icon methodIcon = method.hasModifierProperty(PsiModifier.ABSTRACT) ? Icons.ABSTRACT_METHOD_ICON : Icons.METHOD_ICON;\n      baseIcon = createLayeredIcon(methodIcon, getFlags(method, false));\n    }\n    else if (element instanceof PsiField) {\n      baseIcon = createLayeredIcon(Icons.FIELD_ICON, getFlags((PsiField)element, false));\n    }\n    else if (element instanceof PsiParameter) {\n      baseIcon = createLayeredIcon(Icons.PARAMETER_ICON, 0);\n    }\n    else if (element instanceof PsiVariable) {\n      baseIcon = createLayeredIcon(Icons.VARIABLE_ICON, getFlags((PsiVariable)element, false));\n    }\n    else if (element instanceof XmlTag) {\n      return Icons.XML_TAG_ICON;\n    }\n    else if (element instanceof PsiAntElement) {\n      return ((PsiAntElement)element).getRole().getIcon();\n    }\n    else if (element instanceof PsiClassObjectAccessExpression) {\n      final RowIcon rowIcon = createLayeredIcon(Icons.FIELD_ICON, 0);\n      rowIcon.setIcon(Icons.PUBLIC_ICON, 1);\n      return rowIcon;\n    }\n    else {\n      return null;\n    }\n    return addVisibilityIcon(element, flags, baseIcon);\n  }","commit_id":"935799f5143589eeeb0514a47af7fb08d46bebae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Icon getIcon(int flags) {\n    if (!(this instanceof PsiElement)) return null;\n\n    final PsiElement element = (PsiElement)this;\n\n    final Icon providersIcon = IconUtil.getProvidersIcon(element, flags);\n    if(providersIcon != null) {\n      return addVisibilityIcon(element, flags, providersIcon instanceof RowIcon ? (RowIcon)providersIcon : createLayeredIcon(providersIcon, flags));\n    }\n\n    RowIcon baseIcon;\n    final boolean isLocked = (flags & ICON_FLAG_READ_STATUS) != 0 && !element.isWritable();\n    int elementFlags = isLocked ? FLAGS_LOCKED : 0;\n    if (element instanceof PsiDirectory) {\n      Icon symbolIcon;\n      final PsiDirectory psiDirectory = (PsiDirectory)element;\n      if (psiDirectory.getPackage() != null) {\n        symbolIcon = Icons.PACKAGE_ICON;\n      }\n      else {\n        symbolIcon = Icons.DIRECTORY_CLOSED_ICON;\n      }\n      final VirtualFile vFile = psiDirectory.getVirtualFile();\n      final Project project = psiDirectory.getProject();\n      boolean isExcluded = isExcluded(vFile, project);\n      baseIcon = createLayeredIcon(symbolIcon, elementFlags | (isExcluded ? FLAGS_EXCLUDED : 0));\n    }\n    else if (element instanceof PsiPackage) {\n      baseIcon = createLayeredIcon(Icons.PACKAGE_ICON, elementFlags);\n    }\n    else if (element instanceof PsiFile) {\n      PsiFile file = (PsiFile)element;\n\n      VirtualFile virtualFile = file.getVirtualFile();\n      final Icon fileTypeIcon;\n      if (virtualFile == null) {\n        fileTypeIcon = file.getFileType().getIcon();\n      }\n      else {\n        fileTypeIcon = IconUtil.getIcon(virtualFile, flags & ~ICON_FLAG_READ_STATUS, file.getProject());\n      }\n      baseIcon = createLayeredIcon(fileTypeIcon, elementFlags);\n    }\n    else if (element instanceof PsiClass) {\n      final PsiClass aClass = (PsiClass)element;\n      Icon symbolIcon = getClassBaseIcon(aClass);\n      baseIcon = createLayeredIcon(symbolIcon, getFlags(aClass, isLocked));\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)element;\n      Icon methodIcon = method.hasModifierProperty(PsiModifier.ABSTRACT) ? Icons.ABSTRACT_METHOD_ICON : Icons.METHOD_ICON;\n      baseIcon = createLayeredIcon(methodIcon, getFlags(method, false));\n    }\n    else if (element instanceof PsiField) {\n      baseIcon = createLayeredIcon(Icons.FIELD_ICON, getFlags((PsiField)element, false));\n    }\n    else if (element instanceof PsiParameter) {\n      baseIcon = createLayeredIcon(Icons.PARAMETER_ICON, 0);\n    }\n    else if (element instanceof PsiVariable) {\n      baseIcon = createLayeredIcon(Icons.VARIABLE_ICON, getFlags((PsiVariable)element, false));\n    }\n    else if (element instanceof XmlTag) {\n      return Icons.XML_TAG_ICON;\n    }\n    else if (element instanceof PsiAntElement) {\n      return ((PsiAntElement)element).getRole().getIcon();\n    }\n    else if (element instanceof PsiClassObjectAccessExpression) {\n      final RowIcon rowIcon = createLayeredIcon(Icons.FIELD_ICON, 0);\n      rowIcon.setIcon(Icons.PUBLIC_ICON, 1);\n      return rowIcon;\n    }\n    else {\n      return null;\n    }\n    return addVisibilityIcon(element, flags, baseIcon);\n  }","id":30636,"modified_method":"@Nullable\n  public Icon getIcon(int flags) {\n    if (!(this instanceof PsiElement)) return null;\n\n    final PsiElement element = (PsiElement)this;\n\n    final Icon providersIcon = IconUtil.getProvidersIcon(element, flags);\n    if (providersIcon != null) {\n      final RowIcon rowIcon = providersIcon instanceof RowIcon ? (RowIcon)providersIcon : createLayeredIcon(providersIcon, flags);\n      return addVisibilityIcon(element, flags, rowIcon);\n    }\n\n    boolean visibilityAdded = false;\n    RowIcon baseIcon;\n    final boolean isLocked = (flags & ICON_FLAG_READ_STATUS) != 0 && !element.isWritable();\n    int elementFlags = isLocked ? FLAGS_LOCKED : 0;\n    if (element instanceof PsiDirectory) {\n      Icon symbolIcon;\n      final PsiDirectory psiDirectory = (PsiDirectory)element;\n      if (psiDirectory.getPackage() != null) {\n        symbolIcon = Icons.PACKAGE_ICON;\n      }\n      else {\n        symbolIcon = Icons.DIRECTORY_CLOSED_ICON;\n      }\n      final VirtualFile vFile = psiDirectory.getVirtualFile();\n      final Project project = psiDirectory.getProject();\n      boolean isExcluded = isExcluded(vFile, project);\n      baseIcon = createLayeredIcon(symbolIcon, elementFlags | (isExcluded ? FLAGS_EXCLUDED : 0));\n    }\n    else if (element instanceof PsiPackage) {\n      baseIcon = createLayeredIcon(Icons.PACKAGE_ICON, elementFlags);\n    }\n    else if (element instanceof PsiFile) {\n      PsiFile file = (PsiFile)element;\n\n      VirtualFile virtualFile = file.getVirtualFile();\n      final Icon fileTypeIcon;\n      if (virtualFile == null) {\n        fileTypeIcon = file.getFileType().getIcon();\n      }\n      else {\n        fileTypeIcon = IconUtil.getIcon(virtualFile, flags & ~ICON_FLAG_READ_STATUS, file.getProject());\n        if (fileTypeIcon instanceof RowIcon) {\n          visibilityAdded = true;\n        }\n      }\n      baseIcon = createLayeredIcon(fileTypeIcon, elementFlags);\n    }\n    else if (element instanceof PsiClass) {\n      final PsiClass aClass = (PsiClass)element;\n      Icon symbolIcon = getClassBaseIcon(aClass);\n      baseIcon = createLayeredIcon(symbolIcon, getFlags(aClass, isLocked));\n    }\n    else if (element instanceof PsiMethod) {\n      final PsiMethod method = (PsiMethod)element;\n      Icon methodIcon = method.hasModifierProperty(PsiModifier.ABSTRACT) ? Icons.ABSTRACT_METHOD_ICON : Icons.METHOD_ICON;\n      baseIcon = createLayeredIcon(methodIcon, getFlags(method, false));\n    }\n    else if (element instanceof PsiField) {\n      baseIcon = createLayeredIcon(Icons.FIELD_ICON, getFlags((PsiField)element, false));\n    }\n    else if (element instanceof PsiParameter) {\n      baseIcon = createLayeredIcon(Icons.PARAMETER_ICON, 0);\n    }\n    else if (element instanceof PsiVariable) {\n      baseIcon = createLayeredIcon(Icons.VARIABLE_ICON, getFlags((PsiVariable)element, false));\n    }\n    else if (element instanceof XmlTag) {\n      return Icons.XML_TAG_ICON;\n    }\n    else if (element instanceof PsiAntElement) {\n      return ((PsiAntElement)element).getRole().getIcon();\n    }\n    else if (element instanceof PsiClassObjectAccessExpression) {\n      final RowIcon rowIcon = createLayeredIcon(Icons.FIELD_ICON, 0);\n      rowIcon.setIcon(Icons.PUBLIC_ICON, 1);\n      return rowIcon;\n    }\n    else {\n      return null;\n    }\n    return visibilityAdded ? baseIcon : addVisibilityIcon(element, flags, baseIcon);\n  }","commit_id":"4d5c9d2801920fd605c9f3d72f314b2f2677c042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public UMOEvent[] process(UMOEvent event) throws MessagingException\n    {\n        if(super.process(event)!=null) {\n\n            UMOEndpoint endpoint = event.getComponent().getDescriptor().getOutboundEndpoint();\n            UMOOutboundMessageRouter router = event.getComponent().getDescriptor().getOutboundRouter();\n\n            if(endpoint == null && router==null) {\n\n                logger.debug(\"Descriptor has no outbound endpoint configured to forward to, continuing with normal processing\");\n                return new UMOEvent[]{event};\n            } else  {\n                try\n                {\n                    if(router!=null) {\n                        //this isn't ideal as the request will execute in this thread\n                        //and will not return a result in sync mode\n                        router.route(event.getMessage(), event.getSession(), event.isSynchronous());\n                        return null;\n                    } else {\n                        UMOEvent[] results = new UMOEvent[1];\n                        results[0] = event.getSession().createOutboundEvent(\n                                new MuleMessage(event.getTransformedMessage(), event.getProperties())\n                                , endpoint, event);\n                        logger.info(\"Forwarding event directly to: \" + endpoint.getEndpointURI());\n                        return results;\n                    }\n                } catch (UMOException e)\n                {\n                    throw new RoutingException(event.getMessage(), endpoint, e);\n                }\n            }\n        }\n        return null;\n    }","id":30637,"modified_method":"public UMOEvent[] process(UMOEvent event) throws MessagingException\n    {\n        if (super.process(event) != null) {\n\n            UMOOutboundMessageRouter router = event.getComponent().getDescriptor().getOutboundRouter();\n\t\t\t// Set the stopFurtherProcessing flag to true\n\t\t\t// to inform the InboundMessageRouter not to route\n\t\t\t// these events to the component\n\t\t\tevent.setStopFurtherProcessing(true);\n            if (router == null) {\n\n                logger.debug(\"Descriptor has no outbound router configured to forward to, continuing with normal processing\");\n                return new UMOEvent[] { event };\n            } else  {\n                try\n                {\n                    UMOMessage msg = router.route(event.getMessage(), event.getSession(), event.isSynchronous());\n                    return new UMOEvent[] { new MuleEvent(msg, event) };\n                } catch (UMOException e)\n                {\n                    throw new RoutingException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n        }\n        return null;\n    }","commit_id":"7eb99095b8721f3944774c44d93acee299225a8e","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage route(UMOEvent event) throws MessagingException\n    {\n        if (endpoints.size() > 0 && routers.size() == 0)\n        {\n            addRouter(new InboundPassThroughRouter());\n        }\n\n        String componentName = event.getSession().getComponent().getDescriptor().getName();\n\n        UMOEvent[] eventsToRoute = null;\n        boolean noRoute = true;\n        boolean match = false;\n        UMOInboundRouter umoInboundRouter = null;\n\n        for (Iterator iterator = getRouters().iterator(); iterator.hasNext();)\n        {\n            umoInboundRouter = (UMOInboundRouter) iterator.next();\n\n            if (umoInboundRouter.isMatch(event))\n            {\n                match = true;\n                eventsToRoute = umoInboundRouter.process(event);\n                noRoute = (eventsToRoute == null);\n                if(!matchAll) break;\n            }\n        }\n\n        if (noRoute)\n        {\n            //Update stats\n            if (getStatistics().isEnabled())\n            {\n                getStatistics().incrementNoRoutedMessage();\n            }\n            if (!match)\n            {\n                if (getCatchAllStrategy() != null)\n                {\n\n                    logger.debug(\"Message did not match any routers on: \" + componentName\n                            + \" invoking catch all strategy\");\n                    getStatistics().incrementCaughtMessage();\n                    return getCatchAllStrategy().catchMessage(event.getMessage(), event.getSession(), event.isSynchronous());\n\n                } else\n                {\n                    logger.warn(\"Message did not match any routers on: \"\n                            + componentName\n                            + \" and there is no catch all strategy configured on this router.  Disposing message.\");\n                    if (logger.isDebugEnabled())\n                    {\n                        try\n                        {\n                            logger.warn(\"Message fragment is: \" + StringMessageHelper.truncate(event.getMessageAsString(), 100, true));\n                        } catch (UMOException e)\n                        {\n\n                        }\n                    }\n                }\n            }\n        } else\n        {\n            try\n            {\n                if (event.isSynchronous())\n                {\n                    UMOMessage messageResult = null;\n                    for (int i = 0; i < eventsToRoute.length; i++)\n                    {\n                        messageResult = send(eventsToRoute[i]);\n                        //Update stats\n                        if (getStatistics().isEnabled())\n                        {\n                            getStatistics().incrementRoutedMessage(eventsToRoute[i].getEndpoint());\n                        }\n                    }\n                    return messageResult;\n                } else\n                {\n                    synchronized (eventsToRoute)\n                    {\n                        for (int i = 0; i < eventsToRoute.length; i++)\n                        {\n                            dispatch(eventsToRoute[i]);\n                            if (getStatistics().isEnabled())\n                            {\n                                getStatistics().incrementRoutedMessage(eventsToRoute[i].getEndpoint());\n                            }\n                        }\n                    }\n                    return null;\n                }\n            } catch (UMOException e)\n            {\n                throw new RoutingException(event.getMessage(), event.getEndpoint(), e);\n            }\n        }\n        return (eventsToRoute != null && eventsToRoute.length > 0 ? eventsToRoute[eventsToRoute.length - 1].getMessage() : null);\n\n    }","id":30638,"modified_method":"public UMOMessage route(UMOEvent event) throws MessagingException\n    {\n        if (endpoints.size() > 0 && routers.size() == 0)\n        {\n            addRouter(new InboundPassThroughRouter());\n        }\n\n        String componentName = event.getSession().getComponent().getDescriptor().getName();\n\n        UMOEvent[] eventsToRoute = null;\n        boolean noRoute = true;\n        boolean match = false;\n        UMOInboundRouter umoInboundRouter = null;\n\n        for (Iterator iterator = getRouters().iterator(); iterator.hasNext();)\n        {\n            umoInboundRouter = (UMOInboundRouter) iterator.next();\n\n            if (umoInboundRouter.isMatch(event))\n            {\n                match = true;\n                eventsToRoute = umoInboundRouter.process(event);\n                noRoute = (eventsToRoute == null);\n                if (!matchAll) {\n\t\t\t\t\tbreak;\n                }\n            }\n        }\n\n\t\t// If the stopFurtherProcessing flag has been set\n\t\t// do not route events to the component.\n\t\t// This is the case when using a ForwardingConsumer\n\t\t// inbound router for example.\n\t\tif (!event.isStopFurtherProcessing()) {\n\t        if (noRoute)\n\t        {\n\t            //Update stats\n\t            if (getStatistics().isEnabled())\n\t            {\n\t                getStatistics().incrementNoRoutedMessage();\n\t            }\n\t            if (!match)\n\t            {\n\t                if (getCatchAllStrategy() != null)\n\t                {\n\t\n\t                    logger.debug(\"Message did not match any routers on: \" + componentName\n\t                            + \" invoking catch all strategy\");\n\t                    getStatistics().incrementCaughtMessage();\n\t                    return getCatchAllStrategy().catchMessage(event.getMessage(), event.getSession(), event.isSynchronous());\n\t\n\t                } else\n\t                {\n\t                    logger.warn(\"Message did not match any routers on: \"\n\t                            + componentName\n\t                            + \" and there is no catch all strategy configured on this router.  Disposing message.\");\n\t                    if (logger.isDebugEnabled())\n\t                    {\n\t                        try\n\t                        {\n\t                            logger.warn(\"Message fragment is: \" + StringMessageHelper.truncate(event.getMessageAsString(), 100, true));\n\t                        } catch (UMOException e)\n\t                        {\n\t\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else\n\t        {\n\t            try\n\t            {\n                    UMOMessage messageResult = null;\n                    for (int i = 0; i < eventsToRoute.length; i++)\n                    {\n\t\t                if (event.isSynchronous())\n\t\t                {\n\t                        messageResult = send(eventsToRoute[i]);\n\t\t                } else\n\t\t                {\n                            dispatch(eventsToRoute[i]);\n\t\t                }\n                        //Update stats\n                        if (getStatistics().isEnabled())\n                        {\n                            getStatistics().incrementRoutedMessage(eventsToRoute[i].getEndpoint());\n                        }\n                    }\n                    return messageResult;\n\t            } catch (UMOException e)\n\t            {\n\t                throw new RoutingException(event.getMessage(), event.getEndpoint(), e);\n\t            }\n\t        }\n\t\t}\n        return (eventsToRoute != null && eventsToRoute.length > 0 ? eventsToRoute[eventsToRoute.length - 1].getMessage() : null);\n\n    }","commit_id":"7eb99095b8721f3944774c44d93acee299225a8e","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOEvent[] process(UMOEvent event) throws MessagingException\n    {\n        if(super.process(event)!=null) {\n\n            UMOEndpoint endpoint = event.getComponent().getDescriptor().getOutboundEndpoint();\n            UMOOutboundMessageRouter router = event.getComponent().getDescriptor().getOutboundRouter();\n\n            if(endpoint == null && router==null) {\n\n                logger.debug(\"Descriptor has no outbound endpoint configured to forward to, continuing with normal processing\");\n                return new UMOEvent[]{event};\n            } else  {\n                try\n                {\n                    if(router!=null) {\n                        //this isn't ideal as the request will execute in this thread\n                        //and will not return a result in sync mode\n                        router.route(event.getMessage(), event.getSession(), event.isSynchronous());\n                        return null;\n                    } else {\n                        UMOEvent[] results = new UMOEvent[1];\n                        results[0] = event.getSession().createOutboundEvent(\n                                new MuleMessage(event.getTransformedMessage(), event.getProperties())\n                                , endpoint, event);\n                        logger.info(\"Forwarding event directly to: \" + endpoint.getEndpointURI());\n                        return results;\n                    }\n                } catch (UMOException e)\n                {\n                    throw new RoutingException(event.getMessage(), endpoint, e);\n                }\n            }\n        }\n        return null;\n    }","id":30639,"modified_method":"public UMOEvent[] process(UMOEvent event) throws MessagingException\n    {\n        if (super.process(event) != null) {\n\n            UMOOutboundMessageRouter router = event.getComponent().getDescriptor().getOutboundRouter();\n\t\t\t// Set the stopFurtherProcessing flag to true\n\t\t\t// to inform the InboundMessageRouter not to route\n\t\t\t// these events to the component\n\t\t\tevent.setStopFurtherProcessing(true);\n            if (router == null) {\n\n                logger.debug(\"Descriptor has no outbound router configured to forward to, continuing with normal processing\");\n                return new UMOEvent[] { event };\n            } else  {\n                try\n                {\n                    UMOMessage msg = router.route(event.getMessage(), event.getSession(), event.isSynchronous());\n                    return new UMOEvent[] { new MuleEvent(msg, event) };\n                } catch (UMOException e)\n                {\n                    throw new RoutingException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n        }\n        return null;\n    }","commit_id":"1eaa26a37daa0e3259aa7cee725787787e3333a9","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage route(UMOEvent event) throws MessagingException\n    {\n        if (endpoints.size() > 0 && routers.size() == 0)\n        {\n            addRouter(new InboundPassThroughRouter());\n        }\n\n        String componentName = event.getSession().getComponent().getDescriptor().getName();\n\n        UMOEvent[] eventsToRoute = null;\n        boolean noRoute = true;\n        boolean match = false;\n        UMOInboundRouter umoInboundRouter = null;\n\n        for (Iterator iterator = getRouters().iterator(); iterator.hasNext();)\n        {\n            umoInboundRouter = (UMOInboundRouter) iterator.next();\n\n            if (umoInboundRouter.isMatch(event))\n            {\n                match = true;\n                eventsToRoute = umoInboundRouter.process(event);\n                noRoute = (eventsToRoute == null);\n                if(!matchAll) break;\n            }\n        }\n\n        if (noRoute)\n        {\n            //Update stats\n            if (getStatistics().isEnabled())\n            {\n                getStatistics().incrementNoRoutedMessage();\n            }\n            if (!match)\n            {\n                if (getCatchAllStrategy() != null)\n                {\n\n                    logger.debug(\"Message did not match any routers on: \" + componentName\n                            + \" invoking catch all strategy\");\n                    getStatistics().incrementCaughtMessage();\n                    return getCatchAllStrategy().catchMessage(event.getMessage(), event.getSession(), event.isSynchronous());\n\n                } else\n                {\n                    logger.warn(\"Message did not match any routers on: \"\n                            + componentName\n                            + \" and there is no catch all strategy configured on this router.  Disposing message.\");\n                    if (logger.isDebugEnabled())\n                    {\n                        try\n                        {\n                            logger.warn(\"Message fragment is: \" + StringMessageHelper.truncate(event.getMessageAsString(), 100, true));\n                        } catch (UMOException e)\n                        {\n\n                        }\n                    }\n                }\n            }\n        } else\n        {\n            try\n            {\n                if (event.isSynchronous())\n                {\n                    UMOMessage messageResult = null;\n                    for (int i = 0; i < eventsToRoute.length; i++)\n                    {\n                        messageResult = send(eventsToRoute[i]);\n                        //Update stats\n                        if (getStatistics().isEnabled())\n                        {\n                            getStatistics().incrementRoutedMessage(eventsToRoute[i].getEndpoint());\n                        }\n                    }\n                    return messageResult;\n                } else\n                {\n                    synchronized (eventsToRoute)\n                    {\n                        for (int i = 0; i < eventsToRoute.length; i++)\n                        {\n                            dispatch(eventsToRoute[i]);\n                            if (getStatistics().isEnabled())\n                            {\n                                getStatistics().incrementRoutedMessage(eventsToRoute[i].getEndpoint());\n                            }\n                        }\n                    }\n                    return null;\n                }\n            } catch (UMOException e)\n            {\n                throw new RoutingException(event.getMessage(), event.getEndpoint(), e);\n            }\n        }\n        return (eventsToRoute != null && eventsToRoute.length > 0 ? eventsToRoute[eventsToRoute.length - 1].getMessage() : null);\n\n    }","id":30640,"modified_method":"public UMOMessage route(UMOEvent event) throws MessagingException\n    {\n        if (endpoints.size() > 0 && routers.size() == 0)\n        {\n            addRouter(new InboundPassThroughRouter());\n        }\n\n        String componentName = event.getSession().getComponent().getDescriptor().getName();\n\n        UMOEvent[] eventsToRoute = null;\n        boolean noRoute = true;\n        boolean match = false;\n        UMOInboundRouter umoInboundRouter = null;\n\n        for (Iterator iterator = getRouters().iterator(); iterator.hasNext();)\n        {\n            umoInboundRouter = (UMOInboundRouter) iterator.next();\n\n            if (umoInboundRouter.isMatch(event))\n            {\n                match = true;\n                eventsToRoute = umoInboundRouter.process(event);\n                noRoute = (eventsToRoute == null);\n                if (!matchAll) {\n\t\t\t\t\tbreak;\n                }\n            }\n        }\n\n\t\t// If the stopFurtherProcessing flag has been set\n\t\t// do not route events to the component.\n\t\t// This is the case when using a ForwardingConsumer\n\t\t// inbound router for example.\n\t\tif (!event.isStopFurtherProcessing()) {\n\t        if (noRoute)\n\t        {\n\t            //Update stats\n\t            if (getStatistics().isEnabled())\n\t            {\n\t                getStatistics().incrementNoRoutedMessage();\n\t            }\n\t            if (!match)\n\t            {\n\t                if (getCatchAllStrategy() != null)\n\t                {\n\t\n\t                    logger.debug(\"Message did not match any routers on: \" + componentName\n\t                            + \" invoking catch all strategy\");\n\t                    getStatistics().incrementCaughtMessage();\n\t                    return getCatchAllStrategy().catchMessage(event.getMessage(), event.getSession(), event.isSynchronous());\n\t\n\t                } else\n\t                {\n\t                    logger.warn(\"Message did not match any routers on: \"\n\t                            + componentName\n\t                            + \" and there is no catch all strategy configured on this router.  Disposing message.\");\n\t                    if (logger.isDebugEnabled())\n\t                    {\n\t                        try\n\t                        {\n\t                            logger.warn(\"Message fragment is: \" + StringMessageHelper.truncate(event.getMessageAsString(), 100, true));\n\t                        } catch (UMOException e)\n\t                        {\n\t\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else\n\t        {\n\t            try\n\t            {\n                    UMOMessage messageResult = null;\n                    for (int i = 0; i < eventsToRoute.length; i++)\n                    {\n\t\t                if (event.isSynchronous())\n\t\t                {\n\t                        messageResult = send(eventsToRoute[i]);\n\t\t                } else\n\t\t                {\n                            dispatch(eventsToRoute[i]);\n\t\t                }\n                        //Update stats\n                        if (getStatistics().isEnabled())\n                        {\n                            getStatistics().incrementRoutedMessage(eventsToRoute[i].getEndpoint());\n                        }\n                    }\n                    return messageResult;\n\t            } catch (UMOException e)\n\t            {\n\t                throw new RoutingException(event.getMessage(), event.getEndpoint(), e);\n\t            }\n\t        }\n\t\t}\n        return (eventsToRoute != null && eventsToRoute.length > 0 ? eventsToRoute[eventsToRoute.length - 1].getMessage() : null);\n\n    }","commit_id":"1eaa26a37daa0e3259aa7cee725787787e3333a9","url":"https://github.com/mulesoft/mule"},{"original_method":"private void cloneExplorerTypeIcons(Map<String, String> iconPaths) throws CmsException {\r\n\r\n        for (Map.Entry<String, String> entry : iconPaths.entrySet()) {\r\n            String source = ICON_PATH + entry.getKey();\r\n            String target = ICON_PATH + entry.getValue();\r\n            getCmsObject().copyResource(source, target);\r\n        }\r\n    }","id":30641,"modified_method":"/**\r\n     * Copies the explorer type icons.<p>\r\n     * \r\n     * @param iconPaths the path to the location where the icons are located\r\n     * \r\n     * @throws CmsException if something goes wrong\r\n     */\r\n    private void cloneExplorerTypeIcons(Map<String, String> iconPaths) throws CmsException {\r\n\r\n        for (Map.Entry<String, String> entry : iconPaths.entrySet()) {\r\n            String source = ICON_PATH + entry.getKey();\r\n            String target = ICON_PATH + entry.getValue();\r\n            if (!getCmsObject().existsResource(target)) {\r\n                getCmsObject().copyResource(source, target);\r\n            }\r\n        }\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void createTargetClassesFolder(\r\n        CmsModule targetModule,\r\n        String sourceClassesPath,\r\n        String targetBaseClassesPath) throws CmsException {\r\n\r\n        StringTokenizer tok = new StringTokenizer(targetModule.getName(), \".\");\r\n        int folderId = CmsResourceTypeFolder.getStaticTypeId();\r\n        String targetClassesPath = targetBaseClassesPath;\r\n\r\n        while (tok.hasMoreTokens()) {\r\n            String folder = tok.nextToken();\r\n            targetClassesPath += folder + \"/\";\r\n            getCmsObject().createResource(targetClassesPath, folderId);\r\n        }\r\n        // move exiting content into new classes sub-folder\r\n\r\n        List<CmsResource> propertyFiles = getCmsObject().readResources(sourceClassesPath, CmsResourceFilter.ALL);\r\n        for (CmsResource res : propertyFiles) {\r\n            getCmsObject().copyResource(res.getRootPath(), targetClassesPath + res.getName());\r\n        }\r\n    }","id":30642,"modified_method":"/**\r\n     * Creates the target folder for the module clone.<p>\r\n     * \r\n     * @param targetModule the target module\r\n     * @param sourceClassesPath the source module class path\r\n     * @param targetBaseClassesPath the 'classes' folder of the target module\r\n     * \r\n     * @throws CmsException if something goes wrong\r\n     */\r\n    private void createTargetClassesFolder(\r\n        CmsModule targetModule,\r\n        String sourceClassesPath,\r\n        String targetBaseClassesPath) throws CmsException {\r\n\r\n        StringTokenizer tok = new StringTokenizer(targetModule.getName(), \".\");\r\n        int folderId = CmsResourceTypeFolder.getStaticTypeId();\r\n        String targetClassesPath = targetBaseClassesPath;\r\n\r\n        while (tok.hasMoreTokens()) {\r\n            String folder = tok.nextToken();\r\n            targetClassesPath += folder + \"/\";\r\n            if (!getCmsObject().existsResource(targetClassesPath)) {\r\n                getCmsObject().createResource(targetClassesPath, folderId);\r\n            }\r\n        }\r\n        // move exiting content into new classes sub-folder\r\n        List<CmsResource> propertyFiles = getCmsObject().readResources(sourceClassesPath, CmsResourceFilter.ALL);\r\n        for (CmsResource res : propertyFiles) {\r\n            if (!getCmsObject().existsResource(targetClassesPath + res.getName())) {\r\n                getCmsObject().copyResource(res.getRootPath(), targetClassesPath + res.getName());\r\n            }\r\n        }\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Executes the module clone and returns the new module.<p>\r\n     * \r\n     * @return the new module or <code>null<\/code> in case of any errors\r\n     */\r\n    public CmsModule executeModuleClone() {\r\n\r\n        CmsModule sourceModule = OpenCms.getModuleManager().getModule(m_sourceModuleName);\r\n        String errMessage = null;\r\n        if (sourceModule != null) {\r\n\r\n            // clone the module object\r\n            CmsModule targetModule = (CmsModule)sourceModule.clone();\r\n            targetModule.setName(m_packageName);\r\n            targetModule.setNiceName(m_niceName);\r\n            targetModule.setDescription(m_description);\r\n            targetModule.setAuthorEmail(m_authorEmail);\r\n            targetModule.setAuthorName(m_authorName);\r\n            targetModule.setGroup(m_group);\r\n            targetModule.setActionClass(m_actionClass);\r\n\r\n            try {\r\n\r\n                // store the module paths\r\n                String sourceModulePath = CmsWorkplace.VFS_PATH_MODULES + sourceModule.getName() + \"/\";\r\n                String targetModulePath = CmsWorkplace.VFS_PATH_MODULES + targetModule.getName() + \"/\";\r\n\r\n                // store the package name as path part\r\n                String sourcePathPart = sourceModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n                String targetPathPart = targetModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n\r\n                // store the classes folder paths\r\n                String sourceClassesPath = targetModulePath + PATH_CLASSES + sourcePathPart + \"/\";\r\n                String targetClassesPath = targetModulePath + PATH_CLASSES + targetPathPart + \"/\";\r\n\r\n                // copy the resources\r\n                getCmsObject().copyResource(sourceModulePath, targetModulePath);\r\n\r\n                // check if we have to create the classes folder\r\n                if (getCmsObject().existsResource(sourceClassesPath)) {\r\n                    // in the source module a classes folder was defined,\r\n                    // now create all sub-folders for the package structure in the new module folder\r\n                    createTargetClassesFolder(targetModule, sourceClassesPath, targetModulePath + PATH_CLASSES);\r\n                    // delete the origin classes folder\r\n                    deleteSourceClassesFolder(targetModulePath, sourcePathPart);\r\n                }\r\n\r\n                // TODO: clone module dependencies\r\n\r\n                // adjust the export points\r\n                cloneExportPoints(sourceModule, targetModule, sourcePathPart, targetPathPart);\r\n\r\n                // adjust the resource type names and IDs\r\n                Map<String, String> descKeys = new HashMap<String, String>();\r\n                Map<I_CmsResourceType, I_CmsResourceType> resTypeMap = cloneResourceTypes(\r\n                    sourceModule,\r\n                    targetModule,\r\n                    sourcePathPart,\r\n                    targetPathPart,\r\n                    descKeys);\r\n\r\n                // adjust the explorer type names and store referred icons and message keys\r\n                Map<String, String> iconPaths = new HashMap<String, String>();\r\n                cloneExplorerTypes(targetModule, iconPaths, descKeys);\r\n\r\n                // rename the icon file names\r\n                cloneExplorerTypeIcons(iconPaths);\r\n\r\n                // adjust the module resources\r\n                adjustModuleResources(sourceModule, targetModule, sourcePathPart, targetPathPart, iconPaths);\r\n\r\n                // search and replace the localization keys\r\n                replaceMessageKeys(targetClassesPath, descKeys);\r\n\r\n                // search and replace paths\r\n                CmsSearchReplaceThread t = initializePathThread();\r\n                t.start();\r\n                t.join();\r\n\r\n                // search and replace module name\r\n                t = initializeNameThread();\r\n                t.start();\r\n                t.join();\r\n\r\n                // replace formatter paths\r\n                Charset charset = Charset.forName(OpenCms.getSystemInfo().getDefaultEncoding());\r\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(m_formatterTargetModule)\r\n                    && !targetModule.getResourceTypes().isEmpty()) {\r\n\r\n                    CmsResource formatterSourceFolder = getCmsObject().readResource(\r\n                        \"/system/modules/\" + m_formatterSourceModule + \"/formatters/\");\r\n                    CmsResource formatterTargetFolder = getCmsObject().readResource(\r\n                        \"/system/modules/\" + m_formatterTargetModule + \"/formatters/\");\r\n                    for (I_CmsResourceType type : targetModule.getResourceTypes()) {\r\n                        String schemaPath = type.getConfiguration().get(\"schema\");\r\n                        CmsResource res = getCmsObject().readResource(schemaPath);\r\n                        CmsFile file = getCmsObject().readFile(res);\r\n                        String content = new String(file.getContents(), charset);\r\n                        content = content.replaceAll(\r\n                            formatterSourceFolder.getRootPath(),\r\n                            formatterTargetFolder.getRootPath());\r\n                        file.setContents(content.getBytes(charset));\r\n                        getCmsObject().writeFile(file);\r\n                    }\r\n                }\r\n\r\n                // publish the new module\r\n                for (String res : targetModule.getResources()) {\r\n                    OpenCms.getPublishManager().publishResource(getCmsObject(), res);\r\n                    OpenCms.getPublishManager().waitWhileRunning();\r\n                }\r\n\r\n                // add the module\r\n                OpenCms.getModuleManager().addModule(getCmsObject(), targetModule);\r\n\r\n                // change resource types and schema locations\r\n                if (Boolean.valueOf(m_changeResourceTypes).booleanValue()) {\r\n                    for (Map.Entry<I_CmsResourceType, I_CmsResourceType> mapping : resTypeMap.entrySet()) {\r\n                        List<CmsResource> resources = getCmsObject().readResources(\r\n                            \"/\",\r\n                            CmsResourceFilter.requireType(mapping.getKey().getTypeId()));\r\n                        String sourceSchemaPath = mapping.getKey().getConfiguration().get(\"schema\");\r\n                        String targetSchemaPath = mapping.getValue().getConfiguration().get(\"schema\");\r\n                        for (CmsResource res : resources) {\r\n                            CmsFile file = getCmsObject().readFile(res);\r\n                            String content = new String(file.getContents(), charset);\r\n                            content = content.replaceAll(sourceSchemaPath, targetSchemaPath);\r\n                            file.setContents(content.getBytes(charset));\r\n                            getCmsObject().writeFile(file);\r\n                            res.setType(mapping.getValue().getTypeId());\r\n                            getCmsObject().writeResource(res);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // TODO: delete the old module ??\r\n\r\n            } catch (CmsIllegalArgumentException e) {\r\n                LOG.error(e.getMessage(), e);\r\n            } catch (CmsException e) {\r\n                LOG.error(e.getMessage(), e);\r\n            } catch (Exception e) {\r\n                LOG.error(e.getMessage(), e);\r\n            }\r\n        } else {\r\n            errMessage = \"Source module does not exist.\";\r\n        }\r\n        if (errMessage != null) {\r\n            LOG.error(errMessage);\r\n        }\r\n        return null;\r\n    }","id":30643,"modified_method":"/**\r\n     * Executes the module clone and returns the new module.<p>\r\n     */\r\n    public void executeModuleClone() {\r\n\r\n        CmsModule sourceModule = OpenCms.getModuleManager().getModule(m_sourceModuleName);\r\n\r\n        // clone the module object\r\n        CmsModule targetModule = (CmsModule)sourceModule.clone();\r\n        targetModule.setName(m_packageName);\r\n        targetModule.setNiceName(m_niceName);\r\n        targetModule.setDescription(m_description);\r\n        targetModule.setAuthorEmail(m_authorEmail);\r\n        targetModule.setAuthorName(m_authorName);\r\n        targetModule.setGroup(m_group);\r\n        targetModule.setActionClass(m_actionClass);\r\n\r\n        try {\r\n\r\n            // store the module paths\r\n            String sourceModulePath = CmsWorkplace.VFS_PATH_MODULES + sourceModule.getName() + \"/\";\r\n            String targetModulePath = CmsWorkplace.VFS_PATH_MODULES + targetModule.getName() + \"/\";\r\n\r\n            // store the package name as path part\r\n            String sourcePathPart = sourceModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n            String targetPathPart = targetModule.getName().replaceAll(\"\\\\.\", \"/\");\r\n\r\n            // store the classes folder paths\r\n            String sourceClassesPath = targetModulePath + PATH_CLASSES + sourcePathPart + \"/\";\r\n            String targetClassesPath = targetModulePath + PATH_CLASSES + targetPathPart + \"/\";\r\n\r\n            // copy the resources\r\n            getCmsObject().copyResource(sourceModulePath, targetModulePath);\r\n\r\n            // check if we have to create the classes folder\r\n            if (getCmsObject().existsResource(sourceClassesPath)) {\r\n                // in the source module a classes folder was defined,\r\n                // now create all sub-folders for the package structure in the new module folder\r\n                createTargetClassesFolder(targetModule, sourceClassesPath, targetModulePath + PATH_CLASSES);\r\n                // delete the origin classes folder\r\n                deleteSourceClassesFolder(targetModulePath, sourcePathPart, targetPathPart);\r\n            }\r\n\r\n            // TODO: clone module dependencies\r\n\r\n            // adjust the export points\r\n            cloneExportPoints(sourceModule, targetModule, sourcePathPart, targetPathPart);\r\n\r\n            // adjust the resource type names and IDs\r\n            Map<String, String> descKeys = new HashMap<String, String>();\r\n            Map<I_CmsResourceType, I_CmsResourceType> resTypeMap = cloneResourceTypes(\r\n                sourceModule,\r\n                targetModule,\r\n                sourcePathPart,\r\n                targetPathPart,\r\n                descKeys);\r\n\r\n            // adjust the explorer type names and store referred icons and message keys\r\n            Map<String, String> iconPaths = new HashMap<String, String>();\r\n            cloneExplorerTypes(targetModule, iconPaths, descKeys);\r\n\r\n            // rename the icon file names\r\n            cloneExplorerTypeIcons(iconPaths);\r\n\r\n            // adjust the module resources\r\n            adjustModuleResources(sourceModule, targetModule, sourcePathPart, targetPathPart, iconPaths);\r\n\r\n            // search and replace the localization keys\r\n            replaceMessageKeys(targetClassesPath, descKeys);\r\n\r\n            // search and replace paths\r\n            CmsSearchReplaceThread t = initializePathThread();\r\n            t.start();\r\n            t.join();\r\n\r\n            // search and replace module name\r\n            t = initializeNameThread();\r\n            t.start();\r\n            t.join();\r\n\r\n            // replace formatter paths\r\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(m_formatterTargetModule)\r\n                && !targetModule.getResourceTypes().isEmpty()) {\r\n                replaceFormatterPaths(targetModule);\r\n            }\r\n\r\n            // publish the new module\r\n            for (String res : targetModule.getResources()) {\r\n                OpenCms.getPublishManager().publishResource(getCmsObject(), res);\r\n                OpenCms.getPublishManager().waitWhileRunning();\r\n            }\r\n\r\n            //  add the imported module to the module manager\r\n            OpenCms.getModuleManager().addModule(getCmsObject(), targetModule);\r\n\r\n            // reinitialize the resource manager with additional module resource types if necessary\r\n            if (targetModule.getResourceTypes() != Collections.EMPTY_LIST) {\r\n                OpenCms.getResourceManager().initialize(getCmsObject());\r\n            }\r\n            // reinitialize the workplace manager with additional module explorer types if necessary\r\n            if (targetModule.getExplorerTypes() != Collections.EMPTY_LIST) {\r\n                OpenCms.getWorkplaceManager().addExplorerTypeSettings(targetModule);\r\n            }\r\n\r\n            // re-initialize the workplace\r\n            OpenCms.getWorkplaceManager().initialize(getCmsObject());\r\n            // fire \"clear caches\" event to reload all cached resource bundles\r\n            OpenCms.fireCmsEvent(I_CmsEventListener.EVENT_CLEAR_CACHES, new HashMap<String, Object>());\r\n\r\n            // change resource types and schema locations\r\n            if (Boolean.valueOf(m_changeResourceTypes).booleanValue()) {\r\n                changeResourceTypes(resTypeMap);\r\n            }\r\n\r\n            // delete the old module\r\n            if (Boolean.valueOf(m_deleteModule).booleanValue()) {\r\n                OpenCms.getModuleManager().deleteModule(getCmsObject(), sourceModule.getName(), false, null);\r\n            }\r\n\r\n        } catch (CmsIllegalArgumentException e) {\r\n            LOG.error(e.getMessage(), e);\r\n        } catch (CmsException e) {\r\n            LOG.error(e.getMessage(), e);\r\n        } catch (Exception e) {\r\n            LOG.error(e.getMessage(), e);\r\n        }\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void cloneExplorerTypes(CmsModule targetModule, Map<String, String> iconPaths, Map<String, String> descKeys) {\r\n\r\n        List<CmsExplorerTypeSettings> targetExplorerTypes = targetModule.getExplorerTypes();\r\n        for (CmsExplorerTypeSettings expSetting : targetExplorerTypes) {\r\n            descKeys.put(expSetting.getKey(), expSetting.getKey().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            String newIcon = expSetting.getIcon().replaceAll(m_sourceNamePrefix, m_targetNamePrefix);\r\n            String newBigIcon = expSetting.getBigIconIfAvailable().replaceAll(m_sourceNamePrefix, m_targetNamePrefix);\r\n            iconPaths.put(expSetting.getIcon(), newIcon);\r\n            iconPaths.put(expSetting.getBigIconIfAvailable(), newBigIcon);\r\n            expSetting.setName(expSetting.getName().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setKey(expSetting.getKey().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setIcon(expSetting.getIcon().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setBigIcon(expSetting.getBigIconIfAvailable().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setNewResourceUri(expSetting.getNewResourceUri().replaceAll(\r\n                m_sourceNamePrefix,\r\n                m_targetNamePrefix));\r\n            expSetting.setInfo(expSetting.getInfo().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n        }\r\n    }","id":30644,"modified_method":"/**\r\n     * Copies the explorer type definitions.<p>\r\n     * \r\n     * @param targetModule the target module\r\n     * @param iconPaths the path to the location where the icons are located\r\n     * @param descKeys a map that contains a mapping of the explorer type definitions messages\r\n     */\r\n    private void cloneExplorerTypes(CmsModule targetModule, Map<String, String> iconPaths, Map<String, String> descKeys) {\r\n\r\n        List<CmsExplorerTypeSettings> targetExplorerTypes = targetModule.getExplorerTypes();\r\n        for (CmsExplorerTypeSettings expSetting : targetExplorerTypes) {\r\n            descKeys.put(expSetting.getKey(), expSetting.getKey().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            String newIcon = expSetting.getIcon().replaceAll(m_sourceNamePrefix, m_targetNamePrefix);\r\n            String newBigIcon = expSetting.getBigIconIfAvailable().replaceAll(m_sourceNamePrefix, m_targetNamePrefix);\r\n            iconPaths.put(expSetting.getIcon(), newIcon);\r\n            iconPaths.put(expSetting.getBigIconIfAvailable(), newBigIcon);\r\n            expSetting.setName(expSetting.getName().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setKey(expSetting.getKey().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setIcon(expSetting.getIcon().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setBigIcon(expSetting.getBigIconIfAvailable().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n            expSetting.setNewResourceUri(expSetting.getNewResourceUri().replaceAll(\r\n                m_sourceNamePrefix,\r\n                m_targetNamePrefix));\r\n            expSetting.setInfo(expSetting.getInfo().replaceAll(m_sourceNamePrefix, m_targetNamePrefix));\r\n        }\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void deleteSourceClassesFolder(String targetModulePath, String sourcePathPart) throws CmsException {\r\n\r\n        String topSourceClassesPath = targetModulePath\r\n            + PATH_CLASSES\r\n            + sourcePathPart.substring(0, sourcePathPart.indexOf('/'))\r\n            + \"/\";\r\n        getCmsObject().deleteResource(topSourceClassesPath, CmsResource.DELETE_PRESERVE_SIBLINGS);\r\n    }","id":30645,"modified_method":"/**\r\n     * Deletes the temporarily copied classes files.<p>\r\n     * \r\n     * @param targetModulePath the target module path\r\n     * @param sourcePathPart the path part of the source module\r\n     * @param targetPathPart the target path part\r\n     *  \r\n     * @throws CmsException if something goes wrong\r\n     */\r\n    private void deleteSourceClassesFolder(String targetModulePath, String sourcePathPart, String targetPathPart)\r\n    throws CmsException {\r\n\r\n        String[] targetPathParts = CmsStringUtil.splitAsArray(targetPathPart, '/');\r\n        String[] sourcePathParts = CmsStringUtil.splitAsArray(sourcePathPart, '/');\r\n        int sourceLength = sourcePathParts.length;\r\n        int diff = 0;\r\n        for (int i = 0; i < targetPathParts.length; i++) {\r\n            if (sourceLength >= i) {\r\n                if (!targetPathParts[i].equals(sourcePathParts[i])) {\r\n                    diff = i + 1;\r\n                }\r\n            }\r\n        }\r\n        String topSourceClassesPath = targetModulePath\r\n            + PATH_CLASSES\r\n            + sourcePathPart.substring(0, sourcePathPart.indexOf('/'))\r\n            + \"/\";\r\n\r\n        if (diff != 0) {\r\n\r\n            topSourceClassesPath = targetModulePath + PATH_CLASSES;\r\n            for (int i = 0; i < diff; i++) {\r\n                topSourceClassesPath += sourcePathParts[i] + \"/\";\r\n            }\r\n        }\r\n        getCmsObject().deleteResource(topSourceClassesPath, CmsResource.DELETE_PRESERVE_SIBLINGS);\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void adjustModuleResources(\r\n        CmsModule sourceModule,\r\n        CmsModule targetModule,\r\n        String sourcePathPart,\r\n        String targetPathPart,\r\n        Map<String, String> iconPaths) {\r\n\r\n        List<String> newTargetResources = new ArrayList<String>();\r\n        List<String> targetResources = targetModule.getResources();\r\n        for (String modRes : targetResources) {\r\n            String nIcon = iconPaths.get(modRes.substring(modRes.lastIndexOf('/') + 1));\r\n            if (nIcon != null) {\r\n                // the referenced resource is an resource type icon, add the new icon path\r\n                newTargetResources.add(ICON_PATH + nIcon);\r\n            } else if (modRes.contains(sourceModule.getName())) {\r\n                // there is the name in it\r\n                newTargetResources.add(modRes.replaceAll(sourceModule.getName(), targetModule.getName()));\r\n            } else if (modRes.contains(sourcePathPart)) {\r\n                // there is a path in it\r\n                newTargetResources.add(modRes.replaceAll(sourcePathPart, targetPathPart));\r\n            } else {\r\n                // there is whether the path nor the name in it\r\n                newTargetResources.add(modRes);\r\n            }\r\n        }\r\n        targetModule.setResources(newTargetResources);\r\n    }","id":30646,"modified_method":"/**\r\n     * Adjusts the paths of the module resources from the source path to the target path.<p>\r\n     * \r\n     * @param sourceModule the source module\r\n     * @param targetModule the target module\r\n     * @param sourcePathPart the path part of the source module\r\n     * @param targetPathPart the path part of the target module\r\n     * @param iconPaths the path where resource type icons are located\r\n     */\r\n    private void adjustModuleResources(\r\n        CmsModule sourceModule,\r\n        CmsModule targetModule,\r\n        String sourcePathPart,\r\n        String targetPathPart,\r\n        Map<String, String> iconPaths) {\r\n\r\n        List<String> newTargetResources = new ArrayList<String>();\r\n        List<String> targetResources = targetModule.getResources();\r\n        for (String modRes : targetResources) {\r\n            String nIcon = iconPaths.get(modRes.substring(modRes.lastIndexOf('/') + 1));\r\n            if (nIcon != null) {\r\n                // the referenced resource is an resource type icon, add the new icon path\r\n                newTargetResources.add(ICON_PATH + nIcon);\r\n            } else if (modRes.contains(sourceModule.getName())) {\r\n                // there is the name in it\r\n                newTargetResources.add(modRes.replaceAll(sourceModule.getName(), targetModule.getName()));\r\n            } else if (modRes.contains(sourcePathPart)) {\r\n                // there is a path in it\r\n                newTargetResources.add(modRes.replaceAll(sourcePathPart, targetPathPart));\r\n            } else {\r\n                // there is whether the path nor the name in it\r\n                newTargetResources.add(modRes);\r\n            }\r\n        }\r\n        targetModule.setResources(newTargetResources);\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void cloneExportPoints(\r\n        CmsModule sourceModule,\r\n        CmsModule targetModule,\r\n        String sourcePathPart,\r\n        String targetPathPart) {\r\n\r\n        for (CmsExportPoint exp : targetModule.getExportPoints()) {\r\n            if (exp.getUri().contains(sourceModule.getName())) {\r\n                exp.setUri(exp.getUri().replaceAll(sourceModule.getName(), targetModule.getName()));\r\n            }\r\n            if (exp.getUri().contains(sourcePathPart)) {\r\n                exp.setUri(exp.getUri().replaceAll(sourcePathPart, targetPathPart));\r\n            }\r\n        }\r\n    }","id":30647,"modified_method":"/**\r\n     * Clones the export points of the module and adjusts its paths.<p>\r\n     * \r\n     * @param sourceModule the source module\r\n     * @param targetModule the target module\r\n     * @param sourcePathPart the source path part\r\n     * @param targetPathPart the target path part\r\n     */\r\n    private void cloneExportPoints(\r\n        CmsModule sourceModule,\r\n        CmsModule targetModule,\r\n        String sourcePathPart,\r\n        String targetPathPart) {\r\n\r\n        for (CmsExportPoint exp : targetModule.getExportPoints()) {\r\n            if (exp.getUri().contains(sourceModule.getName())) {\r\n                exp.setUri(exp.getUri().replaceAll(sourceModule.getName(), targetModule.getName()));\r\n            }\r\n            if (exp.getUri().contains(sourcePathPart)) {\r\n                exp.setUri(exp.getUri().replaceAll(sourcePathPart, targetPathPart));\r\n            }\r\n        }\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void replaceMessageKeys(String targetClassesPath, Map<String, String> descKeys) throws CmsException {\r\n\r\n        List<CmsResource> propFiles = getCmsObject().readResources(targetClassesPath, CmsResourceFilter.DEFAULT_FILES);\r\n        Charset charset = Charset.forName(OpenCms.getSystemInfo().getDefaultEncoding());\r\n        for (CmsResource propFile : propFiles) {\r\n            CmsFile file = getCmsObject().readFile(propFile);\r\n            String content = new String(file.getContents(), charset);\r\n            for (Map.Entry<String, String> entry : descKeys.entrySet()) {\r\n                content = content.replaceAll(entry.getKey(), entry.getValue());\r\n            }\r\n            file.setContents(content.getBytes(charset));\r\n            getCmsObject().writeFile(file);\r\n        }\r\n    }","id":30648,"modified_method":"/**\r\n     * Replaces the message keys with in the message properties files below 'classes'.<p>\r\n     * \r\n     * @param targetClassesPath the 'classes' folder path of the cloned module\r\n     * @param descKeys the map with replacements\r\n     * \r\n     * @throws CmsException if something goes wrong\r\n     * @throws UnsupportedEncodingException if the file content could not be read with the determined encoding\r\n     */\r\n    private void replaceMessageKeys(String targetClassesPath, Map<String, String> descKeys)\r\n    throws CmsException, UnsupportedEncodingException {\r\n\r\n        List<CmsResource> propFiles = getCmsObject().readResources(targetClassesPath, CmsResourceFilter.DEFAULT_FILES);\r\n        for (CmsResource propFile : propFiles) {\r\n\r\n            CmsFile file = getCmsObject().readFile(propFile);\r\n            String encoding = CmsLocaleManager.getResourceEncoding(getCmsObject(), file);\r\n            String content = new String(file.getContents(), encoding);\r\n            for (Map.Entry<String, String> entry : descKeys.entrySet()) {\r\n                content = content.replaceAll(entry.getKey(), entry.getValue());\r\n            }\r\n            file.setContents(content.getBytes(encoding));\r\n            getCmsObject().writeFile(file);\r\n        }\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private Map<I_CmsResourceType, I_CmsResourceType> cloneResourceTypes(\r\n        CmsModule sourceModule,\r\n        CmsModule targetModule,\r\n        String sourcePathPart,\r\n        String targetPathPart,\r\n        Map<String, String> keys) {\r\n\r\n        Map<I_CmsResourceType, I_CmsResourceType> resourceTypeMapping = new HashMap<I_CmsResourceType, I_CmsResourceType>();\r\n\r\n        List<I_CmsResourceType> targetResourceTypes = new ArrayList<I_CmsResourceType>();\r\n        for (I_CmsResourceType sourceResType : targetModule.getResourceTypes()) {\r\n\r\n            // get the class name attribute\r\n            String className = sourceResType.getClassName();\r\n            // create the class instance\r\n            I_CmsResourceType targetResType;\r\n            try {\r\n                if (className != null) {\r\n                    className = className.trim();\r\n                }\r\n\r\n                int newId = -1;\r\n                boolean exists = true;\r\n                do {\r\n                    newId = new Random().nextInt((99999)) + 10000;\r\n                    try {\r\n                        OpenCms.getResourceManager().getResourceType(newId);\r\n                    } catch (CmsLoaderException e) {\r\n                        exists = false;\r\n                    }\r\n                } while (exists);\r\n\r\n                targetResType = (I_CmsResourceType)Class.forName(className).newInstance();\r\n\r\n                for (String mapping : sourceResType.getConfiguredMappings()) {\r\n                    targetResType.addMappingType(mapping);\r\n                }\r\n\r\n                targetResType.setAdjustLinksFolder(sourceResType.getAdjustLinksFolder());\r\n\r\n                if (targetResType instanceof A_CmsResourceType) {\r\n                    A_CmsResourceType concreteTargetResType = (A_CmsResourceType)targetResType;\r\n                    for (CmsProperty prop : sourceResType.getConfiguredDefaultProperties()) {\r\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(prop.getValue())) {\r\n                            prop.setStructureValue(prop.getStructureValue().replaceAll(\r\n                                sourceModule.getName(),\r\n                                targetModule.getName()).replaceAll(sourcePathPart, targetPathPart));\r\n                            prop.setResourceValue(prop.getResourceValue().replaceAll(\r\n                                sourceModule.getName(),\r\n                                targetModule.getName()).replaceAll(sourcePathPart, targetPathPart));\r\n                        }\r\n                        concreteTargetResType.addDefaultProperty(prop);\r\n                    }\r\n                    for (CmsConfigurationCopyResource conres : sourceResType.getConfiguredCopyResources()) {\r\n                        concreteTargetResType.addCopyResource(\r\n                            conres.getSource(),\r\n                            conres.getTarget(),\r\n                            conres.getTypeString());\r\n                    }\r\n                }\r\n\r\n                for (Map.Entry<String, String> entry : sourceResType.getConfiguration().entrySet()) {\r\n                    targetResType.addConfigurationParameter(\r\n                        entry.getKey(),\r\n                        entry.getValue().replaceAll(sourceModule.getName(), targetModule.getName()));\r\n                }\r\n\r\n                targetResType.setAdditionalModuleResourceType(true);\r\n                targetResType.initConfiguration(\r\n                    sourceResType.getTypeName().replaceFirst(m_sourceNamePrefix, m_targetNamePrefix),\r\n                    newId + \"\",\r\n                    sourceResType.getClassName());\r\n\r\n                keys.put(sourceResType.getTypeName(), targetResType.getTypeName());\r\n                targetResourceTypes.add(targetResType);\r\n\r\n                resourceTypeMapping.put(sourceResType, targetResType);\r\n\r\n            } catch (Exception e) {\r\n                // resource type is unknown, use dummy class to import the module resources\r\n                targetResType = new CmsResourceTypeUnknown();\r\n                // write an error to the log\r\n                LOG.error(\r\n                    Messages.get().getBundle().key(\r\n                        Messages.ERR_UNKNOWN_RESTYPE_CLASS_2,\r\n                        className,\r\n                        targetResType.getClass().getName()),\r\n                    e);\r\n            }\r\n        }\r\n        targetModule.setResourceTypes(targetResourceTypes);\r\n        return resourceTypeMapping;\r\n    }","id":30649,"modified_method":"/**\r\n     * Clones/copies the resource types.<p>\r\n     * \r\n     * @param sourceModule the source module\r\n     * @param targetModule the target module\r\n     * @param sourcePathPart the source path part\r\n     * @param targetPathPart the target path part\r\n     * @param keys the map where to put in the messages of the resource type\r\n     * \r\n     * @return a map with source resource types as key and the taregt resource types as value\r\n     */\r\n    private Map<I_CmsResourceType, I_CmsResourceType> cloneResourceTypes(\r\n        CmsModule sourceModule,\r\n        CmsModule targetModule,\r\n        String sourcePathPart,\r\n        String targetPathPart,\r\n        Map<String, String> keys) {\r\n\r\n        Map<I_CmsResourceType, I_CmsResourceType> resourceTypeMapping = new HashMap<I_CmsResourceType, I_CmsResourceType>();\r\n\r\n        List<I_CmsResourceType> targetResourceTypes = new ArrayList<I_CmsResourceType>();\r\n        for (I_CmsResourceType sourceResType : targetModule.getResourceTypes()) {\r\n\r\n            // get the class name attribute\r\n            String className = sourceResType.getClassName();\r\n            // create the class instance\r\n            I_CmsResourceType targetResType;\r\n            try {\r\n                if (className != null) {\r\n                    className = className.trim();\r\n                }\r\n\r\n                int newId = -1;\r\n                boolean exists = true;\r\n                do {\r\n                    newId = new Random().nextInt((99999)) + 10000;\r\n                    try {\r\n                        OpenCms.getResourceManager().getResourceType(newId);\r\n                    } catch (CmsLoaderException e) {\r\n                        exists = false;\r\n                    }\r\n                } while (exists);\r\n\r\n                targetResType = (I_CmsResourceType)Class.forName(className).newInstance();\r\n\r\n                for (String mapping : sourceResType.getConfiguredMappings()) {\r\n                    targetResType.addMappingType(mapping);\r\n                }\r\n\r\n                targetResType.setAdjustLinksFolder(sourceResType.getAdjustLinksFolder());\r\n\r\n                if (targetResType instanceof A_CmsResourceType) {\r\n                    A_CmsResourceType concreteTargetResType = (A_CmsResourceType)targetResType;\r\n                    for (CmsProperty prop : sourceResType.getConfiguredDefaultProperties()) {\r\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(prop.getValue())) {\r\n                            prop.setStructureValue(prop.getStructureValue().replaceAll(\r\n                                sourceModule.getName(),\r\n                                targetModule.getName()).replaceAll(sourcePathPart, targetPathPart));\r\n                            prop.setResourceValue(prop.getResourceValue().replaceAll(\r\n                                sourceModule.getName(),\r\n                                targetModule.getName()).replaceAll(sourcePathPart, targetPathPart));\r\n                        }\r\n                        concreteTargetResType.addDefaultProperty(prop);\r\n                    }\r\n                    for (CmsConfigurationCopyResource conres : sourceResType.getConfiguredCopyResources()) {\r\n                        concreteTargetResType.addCopyResource(\r\n                            conres.getSource(),\r\n                            conres.getTarget(),\r\n                            conres.getTypeString());\r\n                    }\r\n                }\r\n\r\n                for (Map.Entry<String, String> entry : sourceResType.getConfiguration().entrySet()) {\r\n                    targetResType.addConfigurationParameter(\r\n                        entry.getKey(),\r\n                        entry.getValue().replaceAll(sourceModule.getName(), targetModule.getName()));\r\n                }\r\n\r\n                targetResType.setAdditionalModuleResourceType(true);\r\n                targetResType.initConfiguration(\r\n                    sourceResType.getTypeName().replaceFirst(m_sourceNamePrefix, m_targetNamePrefix),\r\n                    newId + \"\",\r\n                    sourceResType.getClassName());\r\n\r\n                keys.put(sourceResType.getTypeName(), targetResType.getTypeName());\r\n                targetResourceTypes.add(targetResType);\r\n\r\n                resourceTypeMapping.put(sourceResType, targetResType);\r\n\r\n            } catch (Exception e) {\r\n                // resource type is unknown, use dummy class to import the module resources\r\n                targetResType = new CmsResourceTypeUnknown();\r\n                // write an error to the log\r\n                LOG.error(\r\n                    Messages.get().getBundle().key(\r\n                        Messages.ERR_UNKNOWN_RESTYPE_CLASS_2,\r\n                        className,\r\n                        targetResType.getClass().getName()),\r\n                    e);\r\n            }\r\n        }\r\n        targetModule.setResourceTypes(targetResourceTypes);\r\n        return resourceTypeMapping;\r\n    }","commit_id":"c62cc465fc5ed1e890c49251a821860295635fbb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Copies sample schema and resource type icons and adds the resources to the module.<p>\n     * \n     * @param module the module\n     * @param moduleFolder the module folder name\n     * \n     * @throws CmsIllegalArgumentException in case something goes wrong copying the resources\n     * @throws CmsException in case something goes wrong copying the resources\n     */\n    private void copySampleFiles(CmsModule module, String moduleFolder)\n    throws CmsIllegalArgumentException, CmsException {\n\n        CmsObject cms = getCms();\n        List<String> moduleResource = new ArrayList<String>(module.getResources());\n        if (!cms.existsResource(moduleFolder)) {\n            cms.createResource(moduleFolder, CmsResourceTypeFolder.getStaticTypeId());\n            moduleResource.add(moduleFolder);\n        }\n        String schemaFolder = CmsStringUtil.joinPaths(moduleFolder, \"schemas\");\n        if (!cms.existsResource(schemaFolder)) {\n            cms.createResource(schemaFolder, CmsResourceTypeFolder.getStaticTypeId());\n        }\n        String schemaFile = CmsStringUtil.joinPaths(schemaFolder, m_resInfo.getName() + \".xsd\");\n        if (!cms.existsResource(schemaFile)) {\n            cms.copyResource(SAMPLE_SCHEMA, schemaFile, CmsResource.COPY_AS_NEW);\n        }\n        m_resInfo.setSchema(schemaFile);\n        String filetypesFolder = \"/system/workplace/resources/filetypes/\";\n        String smallIcon = CmsStringUtil.joinPaths(filetypesFolder, m_resInfo.getName() + \".png\");\n        if (!cms.existsResource(smallIcon)) {\n            cms.copyResource(SAMPLE_ICON_SMALL, smallIcon, CmsResource.COPY_AS_NEW);\n            moduleResource.add(smallIcon);\n        }\n        m_resInfo.setSmallIcon(m_resInfo.getName() + \".png\");\n        String bigIcon = CmsStringUtil.joinPaths(filetypesFolder, m_resInfo.getName() + \"_big.png\");\n        if (!cms.existsResource(bigIcon)) {\n            cms.copyResource(SAMPLE_ICON_BIG, bigIcon, CmsResource.COPY_AS_NEW);\n            moduleResource.add(bigIcon);\n        }\n        m_resInfo.setBigIcon(m_resInfo.getName() + \"_big.png\");\n        module.setResources(moduleResource);\n    }","id":30650,"modified_method":"/**\n     * Copies sample schema and resource type icons and adds the resources to the module.<p>\n     * \n     * @param module the module\n     * @param moduleFolder the module folder name\n     * \n     * @throws CmsIllegalArgumentException in case something goes wrong copying the resources\n     * @throws CmsException in case something goes wrong copying the resources\n     */\n    private void copySampleFiles(CmsModule module, String moduleFolder)\n    throws CmsIllegalArgumentException, CmsException {\n\n        CmsObject cms = getCms();\n        List<String> moduleResource = new ArrayList<String>(module.getResources());\n        if (!cms.existsResource(moduleFolder)) {\n            cms.createResource(moduleFolder, CmsResourceTypeFolder.getStaticTypeId());\n            moduleResource.add(moduleFolder);\n        }\n        String schemaFolder = CmsStringUtil.joinPaths(moduleFolder, \"schemas\");\n        if (!cms.existsResource(schemaFolder)) {\n            cms.createResource(schemaFolder, CmsResourceTypeFolder.getStaticTypeId());\n        }\n        String schemaFile = CmsStringUtil.joinPaths(schemaFolder, m_resInfo.getName() + \".xsd\");\n        if (!cms.existsResource(schemaFile)) {\n            cms.copyResource(SAMPLE_SCHEMA, schemaFile, CmsResource.COPY_AS_NEW);\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(m_resInfo.getSchemaTypeName())) {\n                // replace the sample schema type name with the provided name\n                try {\n                    CmsFile schema = cms.readFile(schemaFile);\n                    OpenCms.getLocaleManager();\n                    String schemaContent = new String(schema.getContents(), CmsLocaleManager.getResourceEncoding(\n                        cms,\n                        schema));\n                    schemaContent = schemaContent.replaceAll(SAMPLE_SCHEMA_TYPE_NAME, m_resInfo.getSchemaTypeName());\n                    schema.setContents(schemaContent.getBytes());\n                    cms.writeFile(schema);\n                } catch (Exception e) {\n                    LOG.error(e.getLocalizedMessage(), e);\n                    getReport().addError(e);\n                }\n            }\n\n        }\n        m_resInfo.setSchema(schemaFile);\n        String filetypesFolder = \"/system/workplace/resources/filetypes/\";\n        String smallIcon = CmsStringUtil.joinPaths(filetypesFolder, m_resInfo.getName() + \".png\");\n        if (!cms.existsResource(smallIcon)) {\n            cms.copyResource(SAMPLE_ICON_SMALL, smallIcon, CmsResource.COPY_AS_NEW);\n            moduleResource.add(smallIcon);\n        }\n        m_resInfo.setSmallIcon(m_resInfo.getName() + \".png\");\n        String bigIcon = CmsStringUtil.joinPaths(filetypesFolder, m_resInfo.getName() + \"_big.png\");\n        if (!cms.existsResource(bigIcon)) {\n            cms.copyResource(SAMPLE_ICON_BIG, bigIcon, CmsResource.COPY_AS_NEW);\n            moduleResource.add(bigIcon);\n        }\n        m_resInfo.setBigIcon(m_resInfo.getName() + \"_big.png\");\n        module.setResources(moduleResource);\n    }","commit_id":"61ae120c3b275b76a25162bd096efea92ccc96c2","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.CmsWidgetDialog#defineWidgets()\n     */\n    @Override\n    protected void defineWidgets() {\n\n        initResInfo();\n        setKeyPrefix(KEY_PREFIX);\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"name\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"id\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"niceName\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"title\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"description\", new CmsInputWidget()));\n    }","id":30651,"modified_method":"/**\n     * @see org.opencms.workplace.CmsWidgetDialog#defineWidgets()\n     */\n    @Override\n    protected void defineWidgets() {\n\n        initResInfo();\n        setKeyPrefix(KEY_PREFIX);\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"name\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"id\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"niceName\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"title\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"description\", new CmsInputWidget()));\n        addWidget(new CmsWidgetDialogParameter(m_resInfo, \"schemaTypeName\", new CmsInputWidget()));\n    }","commit_id":"61ae120c3b275b76a25162bd096efea92ccc96c2","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.CmsWidgetDialog#createDialogHtml(java.lang.String)\n     */\n    @Override\n    protected String createDialogHtml(String page) {\n\n        StringBuffer result = new StringBuffer(1024);\n        if (PAGES[0].equals(page)) {\n\n            // create widget table\n            result.append(createWidgetTableStart());\n\n            // show error header once if there were validation errors\n            result.append(createWidgetErrorHeader());\n\n            result.append(createWidgetBlockStart(getMessages().key(Messages.GUI_ADD_TYPES_LABEL_0)));\n            result.append(createDialogRowsHtml(0, 4));\n            result.append(createWidgetBlockEnd());\n\n            // close widget table\n            result.append(createWidgetTableEnd());\n        } else {\n            result.append(page);\n\n        }\n\n        return result.toString();\n    }","id":30652,"modified_method":"/**\n     * @see org.opencms.workplace.CmsWidgetDialog#createDialogHtml(java.lang.String)\n     */\n    @Override\n    protected String createDialogHtml(String page) {\n\n        StringBuffer result = new StringBuffer(1024);\n        if (PAGES[0].equals(page)) {\n\n            // create widget table\n            result.append(createWidgetTableStart());\n\n            // show error header once if there were validation errors\n            result.append(createWidgetErrorHeader());\n\n            result.append(createWidgetBlockStart(getMessages().key(Messages.GUI_ADD_TYPES_LABEL_0)));\n            result.append(createDialogRowsHtml(0, 5));\n            result.append(createWidgetBlockEnd());\n\n            // close widget table\n            result.append(createWidgetTableEnd());\n        } else {\n            result.append(page);\n\n        }\n\n        return result.toString();\n    }","commit_id":"61ae120c3b275b76a25162bd096efea92ccc96c2","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Copy or name a resource or collection.\n\t * \n\t * @param resources\n\t *        Resources implementation to be used\n\t * @param errorList\n\t *        Hashtable containing the list of errors which occurred during the copy operation\n\t * @param source\n\t *        Path of the resource to be copied\n\t * @param dest\n\t *        Destination path\n\t */\n\tprivate boolean copyResource(DirContextSAKAI resources, Hashtable<String,Integer> errorList, String source, String dest, boolean move)\n\t{\n\n\t\tif (M_log.isDebugEnabled()) M_log.debug(\"Copy: \" + source + \" To: \" + dest);\n\n\t\tsource = fixDirPathSAKAI(source);\n\t\tdest = fixDirPathSAKAI(dest);\n\n\t\tif (prohibited(source) || prohibited(dest)) {\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\t\n\t\tsource = adjustId(source);\n\t\tdest = adjustId(dest);\n\n\t\t// Copy\n\t\t\n\t\ttry\n\t\t{\n\t\t    boolean isCollection = contentHostingService.getProperties(source).getBooleanProperty(ResourceProperties.PROP_IS_COLLECTION);\n\n\t\t    if (move) {\n\t\t    \tcontentHostingService.rename(source, dest);\n\t\t    }\n\t\t    else if (isCollection) {\n\t\t    \tcopyCollection(source, dest);\n\t\t    }\n\t\t    else {\n\t\t    \tcontentHostingService.copy(source, dest);\n\t\t    }\n\t\t}\n\t\tcatch (EntityPropertyNotDefinedException e)\n\t\t{\n\t\t    // System.out.println(\"propnotdef \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (EntityPropertyTypeException e)\n\t\t{\n\t\t    // System.out.println(\"propntype \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdUsedException e)\n\t\t    // internal error because caller checked for this\n\t\t{\n\t\t    // System.out.println(\"idunused \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdUniquenessException e)\n\t\t{\n\t\t    // System.out.println(\"iduniqu \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdLengthException e)\n\t\t{\n\t\t    // System.out.println(\"idlen \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (InconsistentException e)\n\t\t{\n\t\t    // System.out.println(\"inconsis \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_CONFLICT));\n\t\t    return false;\n\t\t}\n\t\tcatch (PermissionException e)\n\t\t{\n\t\t    // System.out.println(\"perm \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (InUseException e)\n\t\t{\n\t\t    // System.out.println(\"in use \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_CONFLICT));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdUnusedException e)\n\t\t{\n\t\t    // System.out.println(\"unused \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_NOT_FOUND));\n\t\t    return false;\n\t\t}\n\t\tcatch (OverQuotaException e)\n\t\t{\n\t\t    // System.out.println(\"quota \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdInvalidException e)\n\t\t{\n\t\t    // System.out.println(\"quota \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (TypeException e)\n\t\t{\n\t\t    // System.out.println(\"type \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (ServerOverloadException e)\n\t\t{\n\t\t    // System.out.println(\"overload \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\n\t\t// We did not have an error\n\t\terrorList.clear();\n\t\treturn true;\n\n\t}","id":30653,"modified_method":"/**\n\t * Copy or name a resource or collection.\n\t * \n\t * @param resources\n\t *        Resources implementation to be used\n\t * @param errorList\n\t *        Hashtable containing the list of errors which occurred during the copy operation\n\t * @param source\n\t *        Path of the resource to be copied\n\t * @param dest\n\t *        Destination path\n\t */\n\tprivate boolean copyResource(DirContextSAKAI resources, Hashtable<String,Integer> errorList, String source, String dest, boolean move)\n\t{\n\n\t\tif (M_log.isDebugEnabled()) M_log.debug(\"Copy: \" + source + \" To: \" + dest);\n\n\t\tsource = fixDirPathSAKAI(source);\n\t\tdest = fixDirPathSAKAI(dest);\n\n\t\tif (prohibited(source) || prohibited(dest)) {\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\t\n\t\tsource = adjustId(source);\n\t\tdest = adjustId(dest);\n\n\t\t// Copy\n\t\t\n\t\ttry\n\t\t{\n\t\t    boolean isCollection = contentHostingService.getProperties(source).getBooleanProperty(ResourceProperties.PROP_IS_COLLECTION);\n\n\t\t    /* https://jira.sakaiproject.org/browse/SAK-23639\n\t\t    if (move) {\n\t\t    \tcontentHostingService.rename(source, dest);\n\t\t    }\n\t\t    else */\n\t\t    // NOTE: moves cause a copy as below and a delete around line 2960, if rename() is fixed the remove that code also\n\t\t    if (isCollection) {\n\t\t        copyCollection(source, dest);\n\t\t    } else {\n\t\t        contentHostingService.copy(source, dest);\n\t\t    }\n\t\t}\n\t\tcatch (EntityPropertyNotDefinedException e)\n\t\t{\n\t\t    // System.out.println(\"propnotdef \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (EntityPropertyTypeException e)\n\t\t{\n\t\t    // System.out.println(\"propntype \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdUsedException e)\n\t\t    // internal error because caller checked for this\n\t\t{\n\t\t    // System.out.println(\"idunused \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdUniquenessException e)\n\t\t{\n\t\t    // System.out.println(\"iduniqu \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdLengthException e)\n\t\t{\n\t\t    // System.out.println(\"idlen \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (InconsistentException e)\n\t\t{\n\t\t    // System.out.println(\"inconsis \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_CONFLICT));\n\t\t    return false;\n\t\t}\n\t\tcatch (PermissionException e)\n\t\t{\n\t\t    // System.out.println(\"perm \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (InUseException e)\n\t\t{\n\t\t    // System.out.println(\"in use \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_CONFLICT));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdUnusedException e)\n\t\t{\n\t\t    // System.out.println(\"unused \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_NOT_FOUND));\n\t\t    return false;\n\t\t}\n\t\tcatch (OverQuotaException e)\n\t\t{\n\t\t    // System.out.println(\"quota \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (IdInvalidException e)\n\t\t{\n\t\t    // System.out.println(\"quota \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (TypeException e)\n\t\t{\n\t\t    // System.out.println(\"type \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_FORBIDDEN));\n\t\t    return false;\n\t\t}\n\t\tcatch (ServerOverloadException e)\n\t\t{\n\t\t    // System.out.println(\"overload \" + e);\n\t\t    errorList.put(source, new Integer(SakaidavStatus.SC_INTERNAL_SERVER_ERROR));\n\t\t    return false;\n\t\t}\n\n\t\t// We did not have an error\n\t\terrorList.clear();\n\t\treturn true;\n\n\t}","commit_id":"59c20bd20396a062f2b6bce3ef4135aa446e9aa6","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * MOVE Method.\n\t */\n\tprotected void doMove(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n\t{\n\n\t\tif (readOnly)\n\t\t{\n\t\t\tresp.sendError(SakaidavStatus.SC_FORBIDDEN);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isLocked(req))\n\t\t{\n\t\t\tresp.sendError(SakaidavStatus.SC_LOCKED);\n\t\t\treturn;\n\t\t}\n\n\t\tString path = getRelativePath(req);\n\n\t\tcopyResource(req, resp, true);\n\n\t}","id":30654,"modified_method":"/**\n\t * MOVE Method.\n\t */\n\tprotected void doMove(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n\t{\n\n\t\tif (readOnly)\n\t\t{\n\t\t\tresp.sendError(SakaidavStatus.SC_FORBIDDEN);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isLocked(req))\n\t\t{\n\t\t\tresp.sendError(SakaidavStatus.SC_LOCKED);\n\t\t\treturn;\n\t\t}\n\n\t\tString path = getRelativePath(req);\n\n\t\tboolean success = copyResource(req, resp, true);\n\t\t// https://jira.sakaiproject.org/browse/SAK-23639\n\t\t// Remove this call to deleteResource if rename() is fixed\n\t\tif (success) {\n\t\t    deleteResource(path, req, resp);\n\t\t}\n\n\t}","commit_id":"59c20bd20396a062f2b6bce3ef4135aa446e9aa6","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected DDMTemplate updateTemplate(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\tlong templateId = ParamUtil.getLong(uploadPortletRequest, \"templateId\");\n\n\t\tlong groupId = ParamUtil.getLong(uploadPortletRequest, \"groupId\");\n\t\tlong classNameId = ParamUtil.getLong(\n\t\t\tuploadPortletRequest, \"classNameId\");\n\t\tlong classPK = ParamUtil.getLong(uploadPortletRequest, \"classPK\");\n\t\tMap<Locale, String> nameMap = LocalizationUtil.getLocalizationMap(\n\t\t\tuploadPortletRequest, \"name\");\n\t\tMap<Locale, String> descriptionMap =\n\t\t\tLocalizationUtil.getLocalizationMap(\n\t\t\t\tuploadPortletRequest, \"description\");\n\t\tString type = ParamUtil.getString(uploadPortletRequest, \"type\");\n\t\tString mode = ParamUtil.getString(uploadPortletRequest, \"mode\");\n\t\tString language = ParamUtil.getString(\n\t\t\tuploadPortletRequest, \"language\", TemplateConstants.LANG_TYPE_VM);\n\n\t\tString script = getScript(uploadPortletRequest);\n\t\tString scriptContent = ParamUtil.getString(\n\t\t\tuploadPortletRequest, \"scriptContent\");\n\n\t\tif (Validator.isNull(script)) {\n\t\t\tscript = scriptContent;\n\t\t}\n\n\t\tboolean cacheable = ParamUtil.getBoolean(\n\t\t\tuploadPortletRequest, \"cacheable\");\n\t\tboolean smallImage = ParamUtil.getBoolean(\n\t\t\tuploadPortletRequest, \"smallImage\");\n\t\tString smallImageURL = ParamUtil.getString(\n\t\t\tuploadPortletRequest, \"smallImageURL\");\n\t\tFile smallImageFile = uploadPortletRequest.getFile(\"smallImageFile\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tDDMTemplate.class.getName(), uploadPortletRequest);\n\n\t\tDDMTemplate template = null;\n\n\t\tif (templateId <= 0) {\n\t\t\ttemplate = DDMTemplateServiceUtil.addTemplate(\n\t\t\t\tgroupId, classNameId, classPK, null, nameMap, descriptionMap,\n\t\t\t\ttype, mode, language, script, cacheable, smallImage,\n\t\t\t\tsmallImageURL, smallImageFile, serviceContext);\n\t\t}\n\t\telse {\n\t\t\ttemplate = DDMTemplateServiceUtil.updateTemplate(\n\t\t\t\ttemplateId, classPK, nameMap, descriptionMap, type, mode,\n\t\t\t\tlanguage, script, cacheable, smallImage, smallImageURL,\n\t\t\t\tsmallImageFile, serviceContext);\n\t\t}\n\n\t\tPortletPreferences portletPreferences = getStrictPortletSetup(\n\t\t\tactionRequest);\n\n\t\tif (portletPreferences != null) {\n\t\t\tif (type.equals(DDMTemplateConstants.TEMPLATE_TYPE_DISPLAY)) {\n\t\t\t\tportletPreferences.setValue(\n\t\t\t\t\t\"displayDDMTemplateId\",\n\t\t\t\t\tString.valueOf(template.getTemplateId()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletPreferences.setValue(\n\t\t\t\t\t\"formDDMTemplateId\",\n\t\t\t\t\tString.valueOf(template.getTemplateId()));\n\t\t\t}\n\n\t\t\tportletPreferences.store();\n\t\t}\n\n\t\treturn template;\n\t}","id":30655,"modified_method":"protected DDMTemplate updateTemplate(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\tlong templateId = ParamUtil.getLong(uploadPortletRequest, \"templateId\");\n\n\t\tlong groupId = ParamUtil.getLong(uploadPortletRequest, \"groupId\");\n\t\tlong classNameId = ParamUtil.getLong(\n\t\t\tuploadPortletRequest, \"classNameId\");\n\t\tlong classPK = ParamUtil.getLong(uploadPortletRequest, \"classPK\");\n\t\tMap<Locale, String> nameMap = LocalizationUtil.getLocalizationMap(\n\t\t\tuploadPortletRequest, \"name\");\n\t\tMap<Locale, String> descriptionMap =\n\t\t\tLocalizationUtil.getLocalizationMap(\n\t\t\t\tuploadPortletRequest, \"description\");\n\t\tString type = ParamUtil.getString(uploadPortletRequest, \"type\");\n\t\tString mode = ParamUtil.getString(uploadPortletRequest, \"mode\");\n\t\tString language = ParamUtil.getString(\n\t\t\tuploadPortletRequest, \"language\", TemplateConstants.LANG_TYPE_VM);\n\n\t\tString script = getScript(uploadPortletRequest);\n\n\t\tboolean cacheable = ParamUtil.getBoolean(\n\t\t\tuploadPortletRequest, \"cacheable\");\n\t\tboolean smallImage = ParamUtil.getBoolean(\n\t\t\tuploadPortletRequest, \"smallImage\");\n\t\tString smallImageURL = ParamUtil.getString(\n\t\t\tuploadPortletRequest, \"smallImageURL\");\n\t\tFile smallImageFile = uploadPortletRequest.getFile(\"smallImageFile\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tDDMTemplate.class.getName(), uploadPortletRequest);\n\n\t\tDDMTemplate template = null;\n\n\t\tif (templateId <= 0) {\n\t\t\ttemplate = DDMTemplateServiceUtil.addTemplate(\n\t\t\t\tgroupId, classNameId, classPK, null, nameMap, descriptionMap,\n\t\t\t\ttype, mode, language, script, cacheable, smallImage,\n\t\t\t\tsmallImageURL, smallImageFile, serviceContext);\n\t\t}\n\t\telse {\n\t\t\ttemplate = DDMTemplateServiceUtil.updateTemplate(\n\t\t\t\ttemplateId, classPK, nameMap, descriptionMap, type, mode,\n\t\t\t\tlanguage, script, cacheable, smallImage, smallImageURL,\n\t\t\t\tsmallImageFile, serviceContext);\n\t\t}\n\n\t\tPortletPreferences portletPreferences = getStrictPortletSetup(\n\t\t\tactionRequest);\n\n\t\tif (portletPreferences != null) {\n\t\t\tif (type.equals(DDMTemplateConstants.TEMPLATE_TYPE_DISPLAY)) {\n\t\t\t\tportletPreferences.setValue(\n\t\t\t\t\t\"displayDDMTemplateId\",\n\t\t\t\t\tString.valueOf(template.getTemplateId()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletPreferences.setValue(\n\t\t\t\t\t\"formDDMTemplateId\",\n\t\t\t\t\tString.valueOf(template.getTemplateId()));\n\t\t\t}\n\n\t\t\tportletPreferences.store();\n\t\t}\n\n\t\treturn template;\n\t}","commit_id":"d2165e2cf4b881af14c0c21ab0e45745ac1f74a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getScript(UploadPortletRequest uploadPortletRequest) {\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tinputStream = uploadPortletRequest.getFileAsStream(\"script\");\n\n\t\t\tif (inputStream != null) {\n\t\t\t\treturn new String(FileUtil.getBytes(inputStream));\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(ioe, ioe);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\n\t\treturn null;\n\t}","id":30656,"modified_method":"protected String getScript(UploadPortletRequest uploadPortletRequest)\n\t\tthrows Exception {\n\n\t\tString scriptContent = ParamUtil.getString(\n\t\t\tuploadPortletRequest, \"scriptContent\");\n\n\t\tFile file = uploadPortletRequest.getFile(\"script\");\n\n\t\tif (file == null) {\n\t\t\treturn scriptContent;\n\t\t}\n\n\t\tif (!isTextFile(file)) {\n\t\t\tthrow new TemplateScriptException();\n\t\t}\n\n\t\tString script = FileUtil.read(file);\n\n\t\treturn GetterUtil.getString(script, scriptContent);\n\t}","commit_id":"d2165e2cf4b881af14c0c21ab0e45745ac1f74a4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong userId, long folderId, long newFolderId, String name,\n\t\t\tString sourceFileName, String title, String description,\n\t\t\tString[] tagsEntries, String extraSettings, InputStream is,\n\t\t\tlong size)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tDLFolder folder = DLFolderUtil.findByPrimaryKey(folderId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tDLFileEntry fileEntry = DLFileEntryUtil.findByF_N(folderId, name);\n\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\n\t\tDLFileEntryUtil.update(fileEntry);\n\n\t\t// Move file entry\n\n\t\tif ((newFolderId > 0) && (folderId != newFolderId)) {\n\t\t\tDLFolder newFolder = DLFolderUtil.findByPrimaryKey(newFolderId);\n\n\t\t\tif (folder.getGroupId() != newFolder.getGroupId()) {\n\t\t\t\tthrow new NoSuchFolderException();\n\t\t\t}\n\n\t\t\tif (DLLocalServiceUtil.hasFileContentNode(\n\t\t\t\t\tuser.getCompanyId(), newFolderId, name, 0)) {\n\n\t\t\t\tthrow new DuplicateFileException(name);\n\t\t\t}\n\n\t\t\tlong newFileEntryId = CounterLocalServiceUtil.increment();\n\n\t\t\tDLFileEntry newFileEntry = DLFileEntryUtil.create(newFileEntryId);\n\n\t\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\t\tnewFileEntry.setFolderId(newFolderId);\n\t\t\tnewFileEntry.setName(name);\n\t\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\t\t\tnewFileEntry.setExtraSettings(extraSettings);\n\n\t\t\tDLFileEntryUtil.update(newFileEntry);\n\n\t\t\tDLFileEntryUtil.remove(fileEntry);\n\n\t\t\tfileEntry = newFileEntry;\n\n\t\t\tIterator itr = DLFileVersionUtil.findByF_N(\n\t\t\t\tfolderId, name).iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tDLFileVersion fileVersion = (DLFileVersion)itr.next();\n\n\t\t\t\tlong newFileVersionId = CounterLocalServiceUtil.increment();\n\n\t\t\t\tDLFileVersion newFileVersion = DLFileVersionUtil.create(\n\t\t\t\t\tnewFileVersionId);\n\n\t\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\t\tnewFileVersion.setFolderId(newFolderId);\n\t\t\t\tnewFileVersion.setName(name);\n\t\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\n\t\t\t\tDLFileVersionUtil.update(newFileVersion);\n\n\t\t\t\tDLFileVersionUtil.remove(fileVersion);\n\t\t\t}\n\n\t\t\tDLFileShortcutLocalServiceUtil.updateFileShortcuts(\n\t\t\t\tfolderId, name, newFolderId, name);\n\n\t\t\ttry {\n\t\t\t\tDLServiceUtil.updateFile(\n\t\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tfolder.getGroupId(), folderId, newFolderId, name);\n\t\t\t}\n\t\t\tcatch (RemoteException re) {\n\t\t\t\tthrow new SystemException(re);\n\t\t\t}\n\n\t\t\tfolderId = newFolderId;\n\t\t\tfolder = newFolder;\n\t\t}\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\tuserId, DLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\ttagsEntries);\n\n\t\t// File version\n\n\t\tif (is == null) {\n\t\t\treturn fileEntry;\n\t\t}\n\n\t\tdouble oldVersion = fileEntry.getVersion();\n\t\tdouble newVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\tlong fileVersionId = CounterLocalServiceUtil.increment();\n\n\t\tDLFileVersion fileVersion = DLFileVersionUtil.create(fileVersionId);\n\n\t\tlong versionUserId = fileEntry.getVersionUserId();\n\n\t\tif (versionUserId <= 0) {\n\t\t\tversionUserId = fileEntry.getUserId();\n\t\t}\n\n\t\tString versionUserName = GetterUtil.getString(\n\t\t\tfileEntry.getVersionUserName(), fileEntry.getUserName());\n\n\t\tfileVersion.setCompanyId(fileEntry.getCompanyId());\n\t\tfileVersion.setUserId(versionUserId);\n\t\tfileVersion.setUserName(versionUserName);\n\t\tfileVersion.setCreateDate(fileEntry.getModifiedDate());\n\t\tfileVersion.setFolderId(folderId);\n\t\tfileVersion.setName(name);\n\t\tfileVersion.setVersion(oldVersion);\n\t\tfileVersion.setSize(fileEntry.getSize());\n\n\t\tDLFileVersionUtil.update(fileVersion);\n\n\t\t// File entry\n\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setModifiedDate(new Date());\n\t\tfileEntry.setVersion(newVersion);\n\t\tfileEntry.setSize((int)size);\n\n\t\tDLFileEntryUtil.update(fileEntry);\n\n\t\t// File\n\n\t\tDLLocalServiceUtil.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfolder.getGroupId(), folderId, name, newVersion, sourceFileName,\n\t\t\tis);\n\n\t\t// Folder\n\n\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\tDLFolderUtil.update(folder);\n\n\t\treturn fileEntry;\n\t}","id":30657,"modified_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong userId, long folderId, long newFolderId, String name,\n\t\t\tString sourceFileName, String title, String description,\n\t\t\tString[] tagsEntries, String extraSettings, InputStream is,\n\t\t\tlong size)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tDLFolder folder = DLFolderUtil.findByPrimaryKey(folderId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tDLFileEntry fileEntry = DLFileEntryUtil.findByF_N(folderId, name);\n\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\n\t\tDLFileEntryUtil.update(fileEntry);\n\n\t\t// Move file entry\n\n\t\tif ((newFolderId > 0) && (folderId != newFolderId)) {\n\t\t\tDLFolder newFolder = DLFolderUtil.findByPrimaryKey(newFolderId);\n\n\t\t\tif (folder.getGroupId() != newFolder.getGroupId()) {\n\t\t\t\tthrow new NoSuchFolderException();\n\t\t\t}\n\n\t\t\tif (DLLocalServiceUtil.hasFile(\n\t\t\t\t\tuser.getCompanyId(), newFolderId, name, 0)) {\n\n\t\t\t\tthrow new DuplicateFileException(name);\n\t\t\t}\n\n\t\t\tlong newFileEntryId = CounterLocalServiceUtil.increment();\n\n\t\t\tDLFileEntry newFileEntry = DLFileEntryUtil.create(newFileEntryId);\n\n\t\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\t\tnewFileEntry.setFolderId(newFolderId);\n\t\t\tnewFileEntry.setName(name);\n\t\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\t\t\tnewFileEntry.setExtraSettings(extraSettings);\n\n\t\t\tDLFileEntryUtil.update(newFileEntry);\n\n\t\t\tDLFileEntryUtil.remove(fileEntry);\n\n\t\t\tfileEntry = newFileEntry;\n\n\t\t\tIterator itr = DLFileVersionUtil.findByF_N(\n\t\t\t\tfolderId, name).iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tDLFileVersion fileVersion = (DLFileVersion)itr.next();\n\n\t\t\t\tlong newFileVersionId = CounterLocalServiceUtil.increment();\n\n\t\t\t\tDLFileVersion newFileVersion = DLFileVersionUtil.create(\n\t\t\t\t\tnewFileVersionId);\n\n\t\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\t\tnewFileVersion.setFolderId(newFolderId);\n\t\t\t\tnewFileVersion.setName(name);\n\t\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\n\t\t\t\tDLFileVersionUtil.update(newFileVersion);\n\n\t\t\t\tDLFileVersionUtil.remove(fileVersion);\n\t\t\t}\n\n\t\t\tDLFileShortcutLocalServiceUtil.updateFileShortcuts(\n\t\t\t\tfolderId, name, newFolderId, name);\n\n\t\t\ttry {\n\t\t\t\tDLServiceUtil.updateFile(\n\t\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\t\tfolder.getGroupId(), folderId, newFolderId, name);\n\t\t\t}\n\t\t\tcatch (RemoteException re) {\n\t\t\t\tthrow new SystemException(re);\n\t\t\t}\n\n\t\t\tfolderId = newFolderId;\n\t\t\tfolder = newFolder;\n\t\t}\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\tuserId, DLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\ttagsEntries);\n\n\t\t// File version\n\n\t\tif (is == null) {\n\t\t\treturn fileEntry;\n\t\t}\n\n\t\tdouble oldVersion = fileEntry.getVersion();\n\t\tdouble newVersion = MathUtil.format(oldVersion + 0.1, 1, 1);\n\n\t\tlong fileVersionId = CounterLocalServiceUtil.increment();\n\n\t\tDLFileVersion fileVersion = DLFileVersionUtil.create(fileVersionId);\n\n\t\tlong versionUserId = fileEntry.getVersionUserId();\n\n\t\tif (versionUserId <= 0) {\n\t\t\tversionUserId = fileEntry.getUserId();\n\t\t}\n\n\t\tString versionUserName = GetterUtil.getString(\n\t\t\tfileEntry.getVersionUserName(), fileEntry.getUserName());\n\n\t\tfileVersion.setCompanyId(fileEntry.getCompanyId());\n\t\tfileVersion.setUserId(versionUserId);\n\t\tfileVersion.setUserName(versionUserName);\n\t\tfileVersion.setCreateDate(fileEntry.getModifiedDate());\n\t\tfileVersion.setFolderId(folderId);\n\t\tfileVersion.setName(name);\n\t\tfileVersion.setVersion(oldVersion);\n\t\tfileVersion.setSize(fileEntry.getSize());\n\n\t\tDLFileVersionUtil.update(fileVersion);\n\n\t\t// File entry\n\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setModifiedDate(new Date());\n\t\tfileEntry.setVersion(newVersion);\n\t\tfileEntry.setSize((int)size);\n\n\t\tDLFileEntryUtil.update(fileEntry);\n\n\t\t// File\n\n\t\tDLLocalServiceUtil.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfolder.getGroupId(), folderId, name, newVersion, sourceFileName,\n\t\t\tis);\n\n\t\t// Folder\n\n\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\tDLFolderUtil.update(folder);\n\n\t\treturn fileEntry;\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry addFileEntry(\n\t\t\tlong userId, long folderId, String name, String title,\n\t\t\tString description,\tString[] tagsEntries, String extraSettings,\n\t\t\tInputStream is, long size, Boolean addCommunityPermissions,\n\t\t\tBoolean addGuestPermissions, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tfolderId = getFolderId(user.getCompanyId(), folderId);\n\t\tDLFolder folder = DLFolderUtil.findByPrimaryKey(folderId);\n\t\tDate now = new Date();\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tname = getName(name);\n\n\t\tif (is == null) {\n\t\t\tthrow new FileSizeException();\n\t\t}\n\n\t\tif (DLLocalServiceUtil.hasFileContentNode(\n\t\t\t\tuser.getCompanyId(), folderId, name, 0)) {\n\n\t\t\tthrow new DuplicateFileException(name);\n\t\t}\n\n\t\tlong fileEntryId = CounterLocalServiceUtil.increment();\n\n\t\tDLFileEntry fileEntry = DLFileEntryUtil.create(fileEntryId);\n\n\t\tfileEntry.setCompanyId(user.getCompanyId());\n\t\tfileEntry.setUserId(user.getUserId());\n\t\tfileEntry.setUserName(user.getFullName());\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setCreateDate(now);\n\t\tfileEntry.setModifiedDate(now);\n\t\tfileEntry.setFolderId(folderId);\n\t\tfileEntry.setName(name);\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setVersion(DLFileEntryImpl.DEFAULT_VERSION);\n\t\tfileEntry.setSize((int)size);\n\t\tfileEntry.setReadCount(DLFileEntryImpl.DEFAULT_READ_COUNT);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\n\t\tDLFileEntryUtil.update(fileEntry);\n\n\t\t// File\n\n\t\tDLLocalServiceUtil.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfolder.getGroupId(), folderId, name, is);\n\n\t\t// Resources\n\n\t\tif ((addCommunityPermissions != null) &&\n\t\t\t(addGuestPermissions != null)) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tfolder, fileEntry, addCommunityPermissions.booleanValue(),\n\t\t\t\taddGuestPermissions.booleanValue());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tfolder, fileEntry, communityPermissions, guestPermissions);\n\t\t}\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\tuserId, DLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\ttagsEntries);\n\n\t\t// Folder\n\n\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\tDLFolderUtil.update(folder);\n\n\t\treturn fileEntry;\n\t}","id":30658,"modified_method":"public DLFileEntry addFileEntry(\n\t\t\tlong userId, long folderId, String name, String title,\n\t\t\tString description,\tString[] tagsEntries, String extraSettings,\n\t\t\tInputStream is, long size, Boolean addCommunityPermissions,\n\t\t\tBoolean addGuestPermissions, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tfolderId = getFolderId(user.getCompanyId(), folderId);\n\t\tDLFolder folder = DLFolderUtil.findByPrimaryKey(folderId);\n\t\tDate now = new Date();\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tname = getName(name);\n\n\t\tif (is == null) {\n\t\t\tthrow new FileSizeException();\n\t\t}\n\n\t\tif (DLLocalServiceUtil.hasFile(\n\t\t\t\tuser.getCompanyId(), folderId, name, 0)) {\n\n\t\t\tthrow new DuplicateFileException(name);\n\t\t}\n\n\t\tlong fileEntryId = CounterLocalServiceUtil.increment();\n\n\t\tDLFileEntry fileEntry = DLFileEntryUtil.create(fileEntryId);\n\n\t\tfileEntry.setCompanyId(user.getCompanyId());\n\t\tfileEntry.setUserId(user.getUserId());\n\t\tfileEntry.setUserName(user.getFullName());\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setCreateDate(now);\n\t\tfileEntry.setModifiedDate(now);\n\t\tfileEntry.setFolderId(folderId);\n\t\tfileEntry.setName(name);\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setVersion(DLFileEntryImpl.DEFAULT_VERSION);\n\t\tfileEntry.setSize((int)size);\n\t\tfileEntry.setReadCount(DLFileEntryImpl.DEFAULT_READ_COUNT);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\n\t\tDLFileEntryUtil.update(fileEntry);\n\n\t\t// File\n\n\t\tDLLocalServiceUtil.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfolder.getGroupId(), folderId, name, is);\n\n\t\t// Resources\n\n\t\tif ((addCommunityPermissions != null) &&\n\t\t\t(addGuestPermissions != null)) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tfolder, fileEntry, addCommunityPermissions.booleanValue(),\n\t\t\t\taddGuestPermissions.booleanValue());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tfolder, fileEntry, communityPermissions, guestPermissions);\n\t\t}\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.updateAsset(\n\t\t\tuserId, DLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\ttagsEntries);\n\n\t\t// Folder\n\n\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\tDLFolderUtil.update(folder);\n\n\t\treturn fileEntry;\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, double versionNumber, String sourceFileName,\n\t\t\tInputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tString versionLabel = String.valueOf(versionNumber);\n\n\t\tint pos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\tif (pos != -1) {\n\t\t\tString fileNameExtension =\n\t\t\t\tfileName.substring(pos, fileName.length());\n\n\t\t\tpos = sourceFileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\tif (pos == -1) {\n\t\t\t\tthrow new SourceFileNameException(sourceFileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString sourceFileNameExtension =\n\t\t\t\t\tsourceFileName.substring(pos, sourceFileName.length());\n\n\t\t\t\tif (!fileNameExtension.equalsIgnoreCase(\n\t\t\t\t\t\tsourceFileNameExtension)) {\n\n\t\t\t\t\tthrow new SourceFileNameException(sourceFileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tcontentNode.checkout();\n\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, is);\n\t\t\tcontentNode.setProperty(\n\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\tsession.save();\n\n\t\t\tVersion version = contentNode.checkin();\n\n\t\t\tcontentNode.getVersionHistory().addVersionLabel(\n\t\t\t\tversion.getName(), versionLabel, false);\n\n\t\t\tIndexer.updateFile(\n\t\t\t\tcompanyId, portletId, groupId, repositoryId, fileName);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30659,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, double versionNumber, String sourceFileName,\n\t\t\tInputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tint pos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\tif (pos != -1) {\n\t\t\tString fileNameExtension =\n\t\t\t\tfileName.substring(pos, fileName.length());\n\n\t\t\tpos = sourceFileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\tif (pos == -1) {\n\t\t\t\tthrow new SourceFileNameException(sourceFileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString sourceFileNameExtension =\n\t\t\t\t\tsourceFileName.substring(pos, sourceFileName.length());\n\n\t\t\t\tif (!fileNameExtension.equalsIgnoreCase(\n\t\t\t\t\t\tsourceFileNameExtension)) {\n\n\t\t\t\t\tthrow new SourceFileNameException(sourceFileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.updateFile(\n\t\t\tcompanyId, portletId, groupId, repositoryId, fileName,\n\t\t\tversionNumber, sourceFileName, is);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn getFileAsStream(companyId, repositoryId, fileName, 0);\n\t}","id":30660,"modified_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\treturn hook.getFileAsStream(companyId, repositoryId, fileName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((fileName.indexOf(\"\\\\\\\\\") != -1) ||\n\t\t\t(fileName.indexOf(\"//\") != -1) ||\n\t\t\t(fileName.indexOf(\":\") != -1) ||\n\t\t\t(fileName.indexOf(\"*\") != -1) ||\n\t\t\t(fileName.indexOf(\"?\") != -1) ||\n\t\t\t(fileName.indexOf(\"\\\"\") != -1) ||\n\t\t\t(fileName.indexOf(\"<\") != -1) ||\n\t\t\t(fileName.indexOf(\">\") != -1) ||\n\t\t\t(fileName.indexOf(\"|\") != -1) ||\n\t\t\t(fileName.indexOf(\"&\") != -1) ||\n\t\t\t(fileName.indexOf(\"[\") != -1) ||\n\t\t\t(fileName.indexOf(\"]\") != -1) ||\n\t\t\t(fileName.indexOf(\"'\") != -1)) {\n\n\t\t\tthrow new FileNameException(fileName);\n\t\t}\n\n\t\tboolean validFileExtension = false;\n\n\t\tString[] fileExtensions =\n\t\t\tPropsUtil.getArray(PropsUtil.DL_FILE_EXTENSIONS);\n\n\t\tfor (int i = 0; i < fileExtensions.length; i++) {\n\t\t\tif (StringPool.STAR.equals(fileExtensions[i]) ||\n\t\t\t\tStringUtil.endsWith(fileName, fileExtensions[i])) {\n\n\t\t\t\tvalidFileExtension = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!validFileExtension) {\n\t\t\tthrow new FileNameException(fileName);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\n\t\t\tif (repositoryNode.hasNode(fileName)) {\n\t\t\t\tthrow new DuplicateFileException(fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNode fileNode = repositoryNode.addNode(\n\t\t\t\t\tfileName, JCRConstants.NT_FILE);\n\n\t\t\t\tNode contentNode = fileNode.addNode(\n\t\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\t\tcontentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\tcontentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, is);\n\t\t\t\tcontentNode.setProperty(\n\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\tsession.save();\n\n\t\t\t\tVersion version = contentNode.checkin();\n\n\t\t\t\tcontentNode.getVersionHistory().addVersionLabel(\n\t\t\t\t\tversion.getName(), String.valueOf(DEFAULT_VERSION), false);\n\n\t\t\t\tIndexer.addFile(\n\t\t\t\t\tcompanyId, portletId, groupId, repositoryId, fileName);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30661,"modified_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((fileName.indexOf(\"\\\\\\\\\") != -1) ||\n\t\t\t(fileName.indexOf(\"//\") != -1) ||\n\t\t\t(fileName.indexOf(\":\") != -1) ||\n\t\t\t(fileName.indexOf(\"*\") != -1) ||\n\t\t\t(fileName.indexOf(\"?\") != -1) ||\n\t\t\t(fileName.indexOf(\"\\\"\") != -1) ||\n\t\t\t(fileName.indexOf(\"<\") != -1) ||\n\t\t\t(fileName.indexOf(\">\") != -1) ||\n\t\t\t(fileName.indexOf(\"|\") != -1) ||\n\t\t\t(fileName.indexOf(\"&\") != -1) ||\n\t\t\t(fileName.indexOf(\"[\") != -1) ||\n\t\t\t(fileName.indexOf(\"]\") != -1) ||\n\t\t\t(fileName.indexOf(\"'\") != -1)) {\n\n\t\t\tthrow new FileNameException(fileName);\n\t\t}\n\n\t\tboolean validFileExtension = false;\n\n\t\tString[] fileExtensions =\n\t\t\tPropsUtil.getArray(PropsUtil.DL_FILE_EXTENSIONS);\n\n\t\tfor (int i = 0; i < fileExtensions.length; i++) {\n\t\t\tif (StringPool.STAR.equals(fileExtensions[i]) ||\n\t\t\t\tStringUtil.endsWith(fileName, fileExtensions[i])) {\n\n\t\t\t\tvalidFileExtension = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!validFileExtension) {\n\t\t\tthrow new FileNameException(fileName);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.addFile(companyId, portletId, groupId, repositoryId, fileName, is);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void checkRootNode(long companyId) throws SystemException {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30662,"modified_method":"public void checkRoot(long companyId) throws SystemException {\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.checkRoot(companyId);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void move(String srcDir, String destDir) throws SystemException {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tsession.move(srcDir, destDir);\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30663,"modified_method":"public void move(String srcDir, String destDir) throws SystemException {\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.move(srcDir, destDir);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean hasFileContentNode(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\ttry {\n\t\t\tDLUtil.getFileContentNode(\n\t\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":30664,"modified_method":"public boolean hasFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\treturn hook.hasFile(companyId, repositoryId, fileName, versionNumber);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tInputStream is = null;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode contentNode = DLUtil.getFileContentNode(\n\t\t\t\tsession, companyId, repositoryId, fileName, versionNumber);\n\n\t\t\tProperty data = contentNode.getProperty(JCRConstants.JCR_DATA);\n\n\t\t\tis = new BufferedInputStream(data.getStream());\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\treturn is;\n\t}","id":30665,"modified_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\treturn hook.getFileAsStream(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void checkRootNode(long companyId) throws SystemException {\n\t\tDLLocalService dlLocalService = DLLocalServiceFactory.getService();\n\n\t\tdlLocalService.checkRootNode(companyId);\n\t}","id":30666,"modified_method":"public static void checkRoot(long companyId) throws SystemException {\n\t\tDLLocalService dlLocalService = DLLocalServiceFactory.getService();\n\n\t\tdlLocalService.checkRoot(companyId);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean hasFileContentNode(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLLocalService dlLocalService = DLLocalServiceFactory.getService();\n\n\t\treturn dlLocalService.hasFileContentNode(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\t}","id":30667,"modified_method":"public static boolean hasFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tDLLocalService dlLocalService = DLLocalServiceFactory.getService();\n\n\t\treturn dlLocalService.hasFile(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public byte[] getFile(long companyId, long repositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tbyte[] bytes = null;\n\n\t\ttry {\n\t\t\tInputStream is = DLLocalServiceUtil.getFileAsStream(\n\t\t\t\tcompanyId, repositoryId, fileName);\n\n\t\t\tbytes = FileUtil.getBytes(is);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\treturn bytes;\n\t}","id":30668,"modified_method":"public byte[] getFile(long companyId, long repositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\treturn hook.getFile(companyId, repositoryId, fileName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, double versionNumber, String sourceFileName,\n\t\t\tFile file)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((file == null) || (file.length() > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tis = new BufferedInputStream(new FileInputStream(file));\n\n\t\t\tDLLocalServiceUtil.updateFile(\n\t\t\t\tcompanyId, portletId, groupId, repositoryId, fileName,\n\t\t\t\tversionNumber, sourceFileName, is);\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (is != null) {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(ioe);\n\t\t\t}\n\t\t}\n\t}","id":30669,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, double versionNumber, String sourceFileName,\n\t\t\tFile file)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((file == null) || (file.length() > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.updateFile(\n\t\t\tcompanyId, portletId, groupId, repositoryId, fileName,\n\t\t\tversionNumber, sourceFileName, file);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public byte[] getFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tbyte[] bytes = null;\n\n\t\ttry {\n\t\t\tInputStream is = DLLocalServiceUtil.getFileAsStream(\n\t\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\n\t\t\tbytes = FileUtil.getBytes(is);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\treturn bytes;\n\t}","id":30670,"modified_method":"public byte[] getFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tdouble versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\treturn hook.getFile(companyId, repositoryId, fileName, versionNumber);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, double versionNumber, String sourceFileName,\n\t\t\tbyte[] byteArray)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((byteArray == null) || (byteArray.length > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tInputStream is = new ByteArrayInputStream(byteArray);\n\n\t\ttry {\n\t\t\tDLLocalServiceUtil.updateFile(\n\t\t\t\tcompanyId, portletId, groupId, repositoryId, fileName,\n\t\t\t\tversionNumber, sourceFileName, is);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(ioe);\n\t\t\t}\n\t\t}\n\t}","id":30671,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, double versionNumber, String sourceFileName,\n\t\t\tbyte[] byteArray)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((byteArray == null) || (byteArray.length > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.updateFile(\n\t\t\tcompanyId, portletId, groupId, repositoryId, fileName,\n\t\t\tversionNumber, sourceFileName, byteArray);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] getFileNames(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tList fileNames = new ArrayList();\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode dirNode = repositoryNode.getNode(dirName);\n\n\t\t\tNodeIterator itr = dirNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tif (node.getPrimaryNodeType().getName().equals(\n\t\t\t\t\t\tJCRConstants.NT_FILE)) {\n\n\t\t\t\t\tfileNames.add(dirName + \"/\" + node.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchDirectoryException(dirName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\treturn (String[])fileNames.toArray(new String[0]);\n\t}","id":30672,"modified_method":"public String[] getFileNames(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\treturn hook.getFileNames(companyId, repositoryId, dirName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addDirectory(long companyId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((dirName == null || dirName.equals(\"/\")) ||\n\t\t\t(dirName.indexOf(\"\\\\\\\\\") != -1) ||\n\t\t\t(dirName.indexOf(\"//\") != -1) ||\n\t\t\t(dirName.indexOf(\":\") != -1) ||\n\t\t\t(dirName.indexOf(\"*\") != -1) ||\n\t\t\t(dirName.indexOf(\"?\") != -1) ||\n\t\t\t(dirName.indexOf(\"\\\"\") != -1) ||\n\t\t\t(dirName.indexOf(\"<\") != -1) ||\n\t\t\t(dirName.indexOf(\">\") != -1) ||\n\t\t\t(dirName.indexOf(\"|\") != -1) ||\n\t\t\t(dirName.indexOf(\"&\") != -1) ||\n\t\t\t(dirName.indexOf(\"[\") != -1) ||\n\t\t\t(dirName.indexOf(\"]\") != -1) ||\n\t\t\t(dirName.indexOf(\"'\") != -1)) {\n\n\t\t\tthrow new DirectoryNameException(dirName);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\n\t\t\tif (repositoryNode.hasNode(dirName)) {\n\t\t\t\tthrow new DuplicateDirectoryException(dirName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] dirNameArray = StringUtil.split(dirName, \"/\");\n\n\t\t\t\tNode dirNode = repositoryNode;\n\n\t\t\t\tfor (int i = 0; i < dirNameArray.length; i++) {\n\t\t\t\t\tif (Validator.isNotNull(dirNameArray[i])) {\n\t\t\t\t\t\tif (dirNode.hasNode(dirNameArray[i])) {\n\t\t\t\t\t\t\tdirNode = dirNode.getNode(dirNameArray[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdirNode = dirNode.addNode(\n\t\t\t\t\t\t\t\tdirNameArray[i], JCRConstants.NT_FOLDER);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsession.save();\n\t\t\t}\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30673,"modified_method":"public void addDirectory(long companyId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((dirName == null || dirName.equals(\"/\")) ||\n\t\t\t(dirName.indexOf(\"\\\\\\\\\") != -1) ||\n\t\t\t(dirName.indexOf(\"//\") != -1) ||\n\t\t\t(dirName.indexOf(\":\") != -1) ||\n\t\t\t(dirName.indexOf(\"*\") != -1) ||\n\t\t\t(dirName.indexOf(\"?\") != -1) ||\n\t\t\t(dirName.indexOf(\"\\\"\") != -1) ||\n\t\t\t(dirName.indexOf(\"<\") != -1) ||\n\t\t\t(dirName.indexOf(\">\") != -1) ||\n\t\t\t(dirName.indexOf(\"|\") != -1) ||\n\t\t\t(dirName.indexOf(\"&\") != -1) ||\n\t\t\t(dirName.indexOf(\"[\") != -1) ||\n\t\t\t(dirName.indexOf(\"]\") != -1) ||\n\t\t\t(dirName.indexOf(\"'\") != -1)) {\n\n\t\t\tthrow new DirectoryNameException(dirName);\n\t\t}\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.addDirectory(companyId, repositoryId, dirName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteDirectory(\n\t\t\tlong companyId, String portletId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode dirNode = repositoryNode.getNode(dirName);\n\n\t\t\t_deleteDirectory(companyId, portletId, repositoryId, dirNode);\n\n\t\t\tdirNode.remove();\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchDirectoryException(dirName);\n\t\t}\n\t\tcatch (RepositoryException e) {\n\t\t\tthrow new PortalException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30674,"modified_method":"public void deleteDirectory(\n\t\t\tlong companyId, String portletId, long repositoryId, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.deleteDirectory(companyId, portletId, repositoryId, dirName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tlong newRepositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tNode newRepositoryNode = DLUtil.getFolderNode(\n\t\t\t\trootNode, newRepositoryId);\n\n\t\t\tif (newRepositoryNode.hasNode(fileName)) {\n\t\t\t\tthrow new DuplicateFileException(fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNode newFileNode = newRepositoryNode.addNode(\n\t\t\t\t\tfileName, JCRConstants.NT_FILE);\n\n\t\t\t\tNode newContentNode = newFileNode.addNode(\n\t\t\t\t\tJCRConstants.JCR_CONTENT, JCRConstants.NT_RESOURCE);\n\n\t\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\t\tString[] versionLabels = versionHistory.getVersionLabels();\n\n\t\t\t\tfor (int i = (versionLabels.length - 1); i >= 0; i--) {\n\t\t\t\t\tVersion version = versionHistory.getVersionByLabel(\n\t\t\t\t\t\tversionLabels[i]);\n\n\t\t\t\t\tNode frozenContentNode = version.getNode(\n\t\t\t\t\t\tJCRConstants.JCR_FROZEN_NODE);\n\n\t\t\t\t\tif (i == (versionLabels.length - 1)) {\n\t\t\t\t\t\tnewContentNode.addMixin(JCRConstants.MIX_VERSIONABLE);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewContentNode.checkout();\n\t\t\t\t\t}\n\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_DATA,\n\t\t\t\t\t\tfrozenContentNode.getProperty(\n\t\t\t\t\t\t\tJCRConstants.JCR_DATA).getStream());\n\t\t\t\t\tnewContentNode.setProperty(\n\t\t\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\t\t\tsession.save();\n\n\t\t\t\t\tVersion newVersion = newContentNode.checkin();\n\n\t\t\t\t\tnewContentNode.getVersionHistory().addVersionLabel(\n\t\t\t\t\t\tnewVersion.getName(), versionLabels[i], false);\n\t\t\t\t}\n\n\t\t\t\tfileNode.remove();\n\n\t\t\t\tsession.save();\n\n\t\t\t\ttry {\n\t\t\t\t\tIndexer.deleteFile(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, fileName);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t}\n\n\t\t\t\tIndexer.addFile(\n\t\t\t\t\tcompanyId, portletId, groupId, newRepositoryId, fileName);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30675,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tlong newRepositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.updateFile(\n\t\t\tcompanyId, portletId, groupId, repositoryId, newRepositoryId,\n\t\t\tfileName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\t// A bug in Jackrabbit requires us to create a dummy node and delete the\n\t\t// version tree manually to successfully delete a file\n\n\t\t// Create a dummy node\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tcontentNode.checkout();\n\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_MIME_TYPE, \"text/plain\");\n\t\t\tcontentNode.setProperty(JCRConstants.JCR_DATA, \"\");\n\t\t\tcontentNode.setProperty(\n\t\t\t\tJCRConstants.JCR_LAST_MODIFIED, Calendar.getInstance());\n\n\t\t\tsession.save();\n\n\t\t\tVersion version = contentNode.checkin();\n\n\t\t\tcontentNode.getVersionHistory().addVersionLabel(\n\t\t\t\tversion.getName(), \"0.0\", false);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\t// Delete version tree\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tVersionIterator itr = versionHistory.getAllVersions();\n\n\t\t\twhile (itr.hasNext()){\n\t\t\t\tVersion version = itr.nextVersion();\n\n\t\t\t\tif (itr.getPosition() == itr.getSize()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!StringUtils.equals(\n\t\t\t\t\t\t\tJCRConstants.JCR_ROOT_VERSION, version.getName())) {\n\n\t\t\t\t\t\tversionHistory.removeVersion(version.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\t// Delete file\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\n\t\t\tIndexer.deleteFile(companyId, portletId, repositoryId, fileName);\n\n\t\t\tfileNode.remove();\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30676,"modified_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.deleteFile(companyId, portletId, repositoryId, fileName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((file == null) || (file.length() > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tis = new BufferedInputStream(new FileInputStream(file));\n\n\t\t\tDLLocalServiceUtil.addFile(\n\t\t\t\tcompanyId, portletId, groupId, repositoryId, fileName, is);\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (is != null) {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(ioe);\n\t\t\t}\n\t\t}\n\t}","id":30677,"modified_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((file == null) || (file.length() > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.addFile(\n\t\t\tcompanyId, portletId, groupId, repositoryId, fileName, file);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public long getFileSize(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong size;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode contentNode = DLUtil.getFileContentNode(\n\t\t\t\tsession, companyId, repositoryId, fileName, 0);\n\n\t\t\tsize = contentNode.getProperty(JCRConstants.JCR_DATA).getLength();\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\treturn size;\n\t}","id":30678,"modified_method":"public long getFileSize(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\treturn hook.getFileSize(companyId, repositoryId, fileName);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, byte[] byteArray)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((byteArray == null) || (byteArray.length > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tInputStream is = new ByteArrayInputStream(byteArray);\n\n\t\ttry {\n\t\t\tDLLocalServiceUtil.addFile(\n\t\t\t\tcompanyId, portletId, groupId, repositoryId, fileName, is);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(ioe);\n\t\t\t}\n\t\t}\n\t}","id":30679,"modified_method":"public void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, byte[] byteArray)\n\t\tthrows PortalException, SystemException {\n\n\t\tif ((FILE_MAX_SIZE > 0) &&\n\t\t\t((byteArray == null) || (byteArray.length > FILE_MAX_SIZE))) {\n\t\t\tthrow new FileSizeException(fileName);\n\t\t}\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.addFile(\n\t\t\tcompanyId, portletId, groupId, repositoryId, fileName, byteArray);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName, double versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tString versionLabel = String.valueOf(versionNumber);\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\t\t\tNode fileNode = repositoryNode.getNode(fileName);\n\t\t\tNode contentNode = fileNode.getNode(JCRConstants.JCR_CONTENT);\n\n\t\t\tVersionHistory versionHistory = contentNode.getVersionHistory();\n\n\t\t\tVersion version = versionHistory.getVersionByLabel(versionLabel);\n\n\t\t\tversionHistory.removeVersion(version.getName());\n\n\t\t\tsession.save();\n\t\t}\n\t\tcatch (PathNotFoundException pnfe) {\n\t\t\tthrow new NoSuchFileException(fileName);\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30680,"modified_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName, double versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.deleteFile(\n\t\t\tcompanyId, portletId, repositoryId, fileName, versionNumber);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows IOException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Indexing document \" + companyId + \" \" + portletId + \" \" +\n\t\t\t\t\tgroupId + \" \" + repositoryId + \" \" + fileName);\n\t\t}\n\n\t\tString fileExt = StringPool.BLANK;\n\n\t\tint fileExtVersionPos = fileName.indexOf(DLServiceImpl.VERSION);\n\n\t\tif (fileExtVersionPos != -1) {\n\t\t\tint fileExtPos = fileName.lastIndexOf(\n\t\t\t\tStringPool.PERIOD, fileExtVersionPos);\n\n\t\t\tif (fileExtPos != -1) {\n\t\t\t\tfileExt = fileName.substring(fileExtPos, fileExtVersionPos);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint fileExtPos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\tif (fileExtPos != -1) {\n\t\t\t\tfileExt = fileName.substring(fileExtPos, fileName.length());\n\t\t\t}\n\t\t}\n\n\t\tInputStream is = null;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode contentNode = DLUtil.getFileContentNode(\n\t\t\t\tsession, companyId, repositoryId, fileName, 0);\n\n\t\t\tis = contentNode.getProperty(JCRConstants.JCR_DATA).getStream();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" + groupId +\n\t\t\t\t\t\t\" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\t\" does not have any content\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, portletId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\tdoc.add(LuceneFields.getFile(LuceneFields.CONTENT, is, fileExt));\n\n\t\tif (portletId.equals(PortletKeys.DOCUMENT_LIBRARY)) {\n\t\t\ttry {\n\t\t\t\tDLFileEntry fileEntry = null;\n\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfileEntry = DLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\t\t\t\trepositoryId, fileName);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchFileEntryException nsfe) {\n\n\t\t\t\t\t\t// Indexing is spawned off to a queue. Try to get\n\t\t\t\t\t\t// the file entry object after waiting for 1 second\n\t\t\t\t\t\t// to fix a possible race condition.\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fileEntry == null) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"File \" + fileName + \" in repository \" +\n\t\t\t\t\t\t\t\trepositoryId + \" exists in the JCR but does \" +\n\t\t\t\t\t\t\t\t\t\"not exist in the database\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\tsm.append(fileEntry.getTitle());\n\t\t\t\tsm.append(StringPool.SPACE);\n\t\t\t\tsm.append(fileEntry.getDescription());\n\t\t\t\tsm.append(StringPool.SPACE);\n\n\t\t\t\tProperties extraSettingsProps =\n\t\t\t\t\tfileEntry.getExtraSettingsProperties();\n\n\t\t\t\tIterator itr =\n\t\t\t\t\t(Iterator)extraSettingsProps.entrySet().iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\t\t\tString value = GetterUtil.getString(\n\t\t\t\t\t\t(String)entry.getValue());\n\n\t\t\t\t\tsm.append(value);\n\t\t\t\t}\n\n\t\t\t\tdoc.add(LuceneFields.getText(LuceneFields.PROPERTIES, sm));\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tthrow new IOException(pe.getMessage());\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tthrow new IOException(se.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"repositoryId\", repositoryId));\n\t\tdoc.add(LuceneFields.getKeyword(\"path\", fileName));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" + groupId +\n\t\t\t\t\t\" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\" indexed successfully\");\n\t\t}\n\t}","id":30681,"modified_method":"public static void addFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows IOException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Indexing document \" + companyId + \" \" + portletId + \" \" +\n\t\t\t\t\tgroupId + \" \" + repositoryId + \" \" + fileName);\n\t\t}\n\n\t\tString fileExt = StringPool.BLANK;\n\n\t\tint fileExtVersionPos = fileName.indexOf(DLServiceImpl.VERSION);\n\n\t\tif (fileExtVersionPos != -1) {\n\t\t\tint fileExtPos = fileName.lastIndexOf(\n\t\t\t\tStringPool.PERIOD, fileExtVersionPos);\n\n\t\t\tif (fileExtPos != -1) {\n\t\t\t\tfileExt = fileName.substring(fileExtPos, fileExtVersionPos);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint fileExtPos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\tif (fileExtPos != -1) {\n\t\t\t\tfileExt = fileName.substring(fileExtPos, fileName.length());\n\t\t\t}\n\t\t}\n\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tHook hook = HookFactory.getInstance();\n\n\t\t\tis = hook.getFileAsStream(companyId, repositoryId, fileName);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" + groupId +\n\t\t\t\t\t\t\" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\t\" does not have any content\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tDocument doc = new Document();\n\n\t\tdoc.add(\n\t\t\tLuceneFields.getKeyword(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.COMPANY_ID, companyId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.PORTLET_ID, portletId));\n\t\tdoc.add(LuceneFields.getKeyword(LuceneFields.GROUP_ID, groupId));\n\n\t\tdoc.add(LuceneFields.getFile(LuceneFields.CONTENT, is, fileExt));\n\n\t\tif (portletId.equals(PortletKeys.DOCUMENT_LIBRARY)) {\n\t\t\ttry {\n\t\t\t\tDLFileEntry fileEntry = null;\n\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfileEntry = DLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\t\t\t\trepositoryId, fileName);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchFileEntryException nsfe) {\n\n\t\t\t\t\t\t// Indexing is spawned off to a queue. Try to get\n\t\t\t\t\t\t// the file entry object after waiting for 1 second\n\t\t\t\t\t\t// to fix a possible race condition.\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fileEntry == null) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\t\"File \" + fileName + \" in repository \" +\n\t\t\t\t\t\t\t\trepositoryId + \" exists in the JCR but does \" +\n\t\t\t\t\t\t\t\t\t\"not exist in the database\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\tsm.append(fileEntry.getTitle());\n\t\t\t\tsm.append(StringPool.SPACE);\n\t\t\t\tsm.append(fileEntry.getDescription());\n\t\t\t\tsm.append(StringPool.SPACE);\n\n\t\t\t\tProperties extraSettingsProps =\n\t\t\t\t\tfileEntry.getExtraSettingsProperties();\n\n\t\t\t\tIterator itr =\n\t\t\t\t\t(Iterator)extraSettingsProps.entrySet().iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\t\t\tString value = GetterUtil.getString(\n\t\t\t\t\t\t(String)entry.getValue());\n\n\t\t\t\t\tsm.append(value);\n\t\t\t\t}\n\n\t\t\t\tdoc.add(LuceneFields.getText(LuceneFields.PROPERTIES, sm));\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t\tthrow new IOException(pe.getMessage());\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tthrow new IOException(se.getMessage());\n\t\t\t}\n\t\t}\n\n\t\tdoc.add(LuceneFields.getDate(LuceneFields.MODIFIED));\n\n\t\tdoc.add(LuceneFields.getKeyword(\"repositoryId\", repositoryId));\n\t\tdoc.add(LuceneFields.getKeyword(\"path\", fileName));\n\n\t\tIndexWriter writer = null;\n\n\t\ttry {\n\t\t\twriter = LuceneUtil.getWriter(companyId);\n\n\t\t\twriter.addDocument(doc);\n\t\t}\n\t\tfinally {\n\t\t\tif (writer != null) {\n\t\t\t\tLuceneUtil.write(companyId);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Document \" + companyId + \" \" + portletId + \" \" + groupId +\n\t\t\t\t\t\" \" + repositoryId + \" \" + fileName +\n\t\t\t\t\t\t\" indexed successfully\");\n\t\t}\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void reIndex(String[] ids) throws SearchException {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\t\tString portletId = ids[1];\n\t\tlong groupId = GetterUtil.getLong(ids[2]);\n\t\tlong repositoryId = GetterUtil.getLong(ids[3]);\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode rootNode = DLUtil.getRootNode(session, companyId);\n\t\t\tNode repositoryNode = DLUtil.getFolderNode(rootNode, repositoryId);\n\n\t\t\tNodeIterator itr = repositoryNode.getNodes();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNode node = (Node)itr.next();\n\n\t\t\t\tif (node.getPrimaryNodeType().getName().equals(\n\t\t\t\t\t\tJCRConstants.NT_FILE)) {\n\n\t\t\t\t\taddFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tnode.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","id":30682,"modified_method":"public static void reIndex(String[] ids) throws SearchException {\n\t\tHook hook = HookFactory.getInstance();\n\n\t\thook.reIndex(ids);\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doUpgrade() throws Exception {\n\t\tValueMapper companyIdMapper = ValueMapperFactory.getValueMapper();\n\n\t\tAvailableMappersUtil.setCompanyIdMapper(companyIdMapper);\n\n\t\tString[] webIds = WebIdUtil.getWebIds();\n\n\t\tfor (int i = 0; i < webIds.length; i++) {\n\t\t\tString webId = webIds[i];\n\n\t\t\tlong companyId = upgradeWebId(webId);\n\n\t\t\tcompanyIdMapper.mapValue(webId, new Long(companyId));\n\n\t\t\tLuceneUtil.checkLuceneDir(companyId);\n\n\t\t\tDLLocalServiceUtil.checkRootNode(companyId);\n\t\t}\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tCompanyImpl.TABLE_NAME, CompanyImpl.TABLE_COLUMNS);\n\n\t\tupgradeTable.setCreateSQL(CompanyImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\n\t\trunSQL(\n\t\t\t\"update PortletPreferences set ownerId = '0', ownerType = \" +\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_COMPANY +\n\t\t\t\t\t\" where ownerId = 'COMPANY.LIFERAY_PORTAL'\");\n\t}","id":30683,"modified_method":"protected void doUpgrade() throws Exception {\n\t\tValueMapper companyIdMapper = ValueMapperFactory.getValueMapper();\n\n\t\tAvailableMappersUtil.setCompanyIdMapper(companyIdMapper);\n\n\t\tString[] webIds = WebIdUtil.getWebIds();\n\n\t\tfor (int i = 0; i < webIds.length; i++) {\n\t\t\tString webId = webIds[i];\n\n\t\t\tlong companyId = upgradeWebId(webId);\n\n\t\t\tcompanyIdMapper.mapValue(webId, new Long(companyId));\n\n\t\t\tLuceneUtil.checkLuceneDir(companyId);\n\n\t\t\tDLLocalServiceUtil.checkRoot(companyId);\n\t\t}\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tCompanyImpl.TABLE_NAME, CompanyImpl.TABLE_COLUMNS);\n\n\t\tupgradeTable.setCreateSQL(CompanyImpl.TABLE_SQL_CREATE);\n\n\t\tupgradeTable.updateTable();\n\n\t\trunSQL(\n\t\t\t\"update PortletPreferences set ownerId = '0', ownerType = \" +\n\t\t\t\tPortletKeys.PREFS_OWNER_TYPE_COMPANY +\n\t\t\t\t\t\" where ownerId = 'COMPANY.LIFERAY_PORTAL'\");\n\t}","commit_id":"fdc0b9dca993293c44e638c9855e59467768befa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** Checks if the provided request's remote server is whitelisted **/\n    private boolean isWhitelisted(final SlingHttpServletRequest request) {\n        if (config.isHmacEnabled()) {\n            return requestValidator.isTrusted(request);\n        } else {\n            if (whitelist.contains(request.getRemoteAddr())) {\n                return true;\n            } else if (whitelist.contains(request.getRemoteHost())) {\n                return true;\n            }\n        }\n        logger.info(\"isWhitelisted: rejecting \" + request.getRemoteAddr()\n                + \", \" + request.getRemoteHost());\n        return false;\n    }","id":30684,"modified_method":"/** Checks if the provided request's remote server is whitelisted **/\n    boolean isWhitelisted(final HttpServletRequest request) {\n        if (config.isHmacEnabled()) {\n            final boolean isTrusted = requestValidator.isTrusted(request);\n            if (!isTrusted) {\n                logger.info(\"isWhitelisted: rejecting distrusted \" + request.getRemoteAddr()\n                        + \", \" + request.getRemoteHost());\n            }\n            return isTrusted;\n        }\n        \n        if (plaintextWhitelist.contains(request.getRemoteHost()) ||\n                plaintextWhitelist.contains(request.getRemoteAddr())) {\n            return true;\n        }\n\n        for (Iterator<WhitelistEntry> it = whitelist.iterator(); it.hasNext();) {\n            WhitelistEntry whitelistEntry = it.next();\n            if (whitelistEntry.accepts(request)) {\n                return true;\n            }\n        }\n        logger.info(\"isWhitelisted: rejecting \" + request.getRemoteAddr()\n                + \", \" + request.getRemoteHost());\n        return false;\n    }","commit_id":"3aa60007781da2c0ee89d9d7ee148b757b2d79f4","url":"https://github.com/apache/sling"},{"original_method":"protected void activate(final ComponentContext context) {\n        whitelist.clear();\n        if (!config.isHmacEnabled()) {\n            String[] whitelistConfig = config.getTopologyConnectorWhitelist();\n            for (int i = 0; i < whitelistConfig.length; i++) {\n                String aWhitelistEntry = whitelistConfig[i];\n                logger.info(\"activate: adding whitelist entry: \" + aWhitelistEntry);\n                whitelist.add(aWhitelistEntry);\n            }\n        }\n        requestValidator = new TopologyRequestValidator(config);\n    }","id":30685,"modified_method":"protected void activate(final ComponentContext context) {\n        whitelist.clear();\n        if (!config.isHmacEnabled()) {\n            String[] whitelistConfig = config.getTopologyConnectorWhitelist();\n            initWhitelist(whitelistConfig);\n        }\n        requestValidator = new TopologyRequestValidator(config);\n    }","commit_id":"3aa60007781da2c0ee89d9d7ee148b757b2d79f4","url":"https://github.com/apache/sling"},{"original_method":"public IpAddressRange(String cidr) throws UnknownHostException {\n      String[] parts = cidr.split(\"/\");\n      network = InetAddress.getByName(parts[0]).getAddress();\n      if (parts.length > 1) {\n         mask = Integer.valueOf(parts[1]);\n      } else {\n         mask = network.length * BYTE_SIZE;\n      }\n\n   }","id":30686,"modified_method":"public IpAddressRange(String cidr) throws UnknownHostException {\n      String[] parts = cidr.split(\"/\");\n      InetAddress[] addresses = InetAddress.getAllByName(parts[0]);\n      if (addresses.length == 0) {\n         throw new IllegalArgumentException(\"Unable to determine addresses for cidr: \" + cidr);\n      }\n      \n      if (addresses.length > 1) {\n         LOG.warn(\"Multiple addresses found for cidr \" + cidr + \" Using first available.\");\n      }\n      \n      InetAddress address = addresses[0];\n      network = address.getAddress();\n      if (parts.length > 1) {\n         mask = Integer.valueOf(parts[1]);\n      } else {\n         mask = network.length * BYTE_SIZE;\n      }\n\n   }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"private boolean onWhiteList(String address) {\n      boolean onList = false;\n\n      for (String addressOnList : whiteList.getIpAddress()) {\n         if (StringUtilities.nullSafeEqualsIgnoreCase(addressOnList, address)) {\n            onList = true;\n            break;\n         }\n      }\n            \n      return onList;\n   }","id":30687,"modified_method":"private boolean onWhiteList(String address) throws UnknownHostException {\n      boolean onList = false;\n\n      byte[] addressBytes = InetAddress.getByName(address).getAddress();\n\n      for (IpAddressRange range : whitelistIps) {\n         if (range.addressInRange(addressBytes)) {\n            onList = true;\n            break;\n         }\n      }\n\n      return onList;\n   }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n\n      final FilterDirector filterDirector = new FilterDirectorImpl();\n      HeaderManager headerManager = filterDirector.requestHeaderManager();\n      String address = request.getRemoteAddr();\n\n      if (!address.isEmpty()) {\n         filterDirector.setFilterAction(FilterAction.PASS);\n\n         String q = quality;\n         String group = IpIdentityGroup.DEST_GROUP;         \n         if (onWhiteList(address)) {\n            group = IpIdentityGroup.DEFAULT_WHITELIST_GROUP;\n            q = \";q=\" + whiteList.getQuality();\n         }\n                  \n         headerManager.appendHeader(PowerApiHeader.USER.toString(), address + q);\n         headerManager.appendHeader(PowerApiHeader.GROUPS.toString(), group + q);\n      }\n      return filterDirector;\n   }","id":30688,"modified_method":"@Override\n   public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n\n      final FilterDirector filterDirector = new FilterDirectorImpl();\n      HeaderManager headerManager = filterDirector.requestHeaderManager();\n      String address = request.getHeader(X_FORWARDED_FOR_HEADER);\n      if (address == null) {\n         address = request.getRemoteAddr();\n      } else {\n         address = address.split(\",\")[0];\n      }\n\n      if (StringUtilities.isNotBlank(address)) {\n         filterDirector.setFilterAction(FilterAction.PASS);\n\n         String q = quality;\n         String group = IpIdentityGroup.DEST_GROUP;\n         try {\n            if (onWhiteList(address)) {\n               group = IpIdentityGroup.DEFAULT_WHITELIST_GROUP;\n               q = \";q=\" + whiteList.getQuality();\n            }\n         } catch (UnknownHostException ex) {\n            LOG.warn(\"Invalid client IP Address: \" + address);\n         }\n\n         headerManager.appendHeader(PowerApiHeader.USER.toString(), address + q);\n         headerManager.appendHeader(PowerApiHeader.GROUPS.toString(), group + q);\n      }\n      return filterDirector;\n   }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"public IpIdentityHandler(IpIdentityConfig config) {\n      this.config = config;\n      this.whiteList = config.getWhiteList() == null ? new WhiteList() : config.getWhiteList();\n      this.quality = determineQuality();\n   }","id":30689,"modified_method":"public IpIdentityHandler(IpIdentityConfig config, List<IpAddressRange> whitelistIps) {\n      this.config = config;\n      this.whiteList = config.getWhiteList() == null ? new WhiteList() : config.getWhiteList();\n      this.quality = determineQuality();\n      this.whitelistIps = whitelistIps;\n   }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   protected IpIdentityHandler buildHandler() {\n      return new IpIdentityHandler(config);\n   }","id":30690,"modified_method":"@Override\n   protected IpIdentityHandler buildHandler() {\n      return new IpIdentityHandler(config, whitelist);\n   }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n      public void configurationUpdated(IpIdentityConfig configurationObject) {\n         config = configurationObject;\n      }","id":30691,"modified_method":"@Override\n      public void configurationUpdated(IpIdentityConfig configurationObject) {\n         config = configurationObject;\n         whitelist = new ArrayList<IpAddressRange>();\n         if (config.getWhiteList() != null) {\n            for (String address : config.getWhiteList().getIpAddress()) {\n               try {\n                  whitelist.add(new IpAddressRange(address));\n               } catch (UnknownHostException ex) {\n                  LOG.warn(\"Invalid IP address specified in white list: \" + address);\n               }\n            }\n         }\n      }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"/**\n    * Test of handleRequest method, of class IpIdentityHandler.\n    */\n   @Test\n   public void testHandleRequest() {\n      config = new IpIdentityConfig();\n      config.setQuality(QUALITY);\n      handler = new IpIdentityHandler(config);\n\n      FilterDirector director = handler.handleRequest(request, response);\n\n      assertTrue(\"Should have Requests Source IP as x-pp-user\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.USER.toString()).contains(DEFAULT_IP_VALUE + QUALITY_VALUE));\n      assertTrue(\"Should have IP_Standard as a group\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.GROUPS.toString()).contains(IpIdentityGroup.DEST_GROUP + QUALITY_VALUE));\n   }","id":30692,"modified_method":"/**\n    * Test of handleRequest method, of class IpIdentityHandler.\n    */\n   @Test\n   public void testHandleRequest() {\n      config = new IpIdentityConfig();\n      config.setQuality(QUALITY);\n      handler = new IpIdentityHandler(config, new ArrayList<IpAddressRange>());\n\n      FilterDirector director = handler.handleRequest(request, response);\n\n      assertTrue(\"Should have Requests Source IP as x-pp-user\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.USER.toString()).contains(DEFAULT_IP_VALUE + QUALITY_VALUE));\n      assertTrue(\"Should have IP_Standard as a group\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.GROUPS.toString()).contains(IpIdentityGroup.DEST_GROUP + QUALITY_VALUE));\n   }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Test\n   public void shouldAddWhiteListGroupAndQuality() {      \n      config = new IpIdentityConfig();\n      config.setQuality(QUALITY);\n      WhiteList whiteList = new WhiteList();\n      whiteList.setQuality(WL_QUALITY);\n      whiteList.getIpAddress().add(WHITELIST_IP_VALUE);\n      config.setWhiteList(whiteList);\n      handler = new IpIdentityHandler(config);\n\n      FilterDirector director = handler.handleRequest(request, response);\n\n      assertTrue(\"Should have Requests Source IP as x-pp-user\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.USER.toString()).contains(DEFAULT_IP_VALUE + WL_QUALITY_VALUE));\n      assertTrue(\"Should have IP_Super as a group\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.GROUPS.toString()).contains(IpIdentityGroup.DEFAULT_WHITELIST_GROUP + WL_QUALITY_VALUE));\n   }","id":30693,"modified_method":"@Test\n   public void shouldAddWhiteListGroupAndQuality() {      \n      config = new IpIdentityConfig();\n      config.setQuality(QUALITY);\n      WhiteList whiteList = new WhiteList();\n      whiteList.setQuality(WL_QUALITY);\n      whiteList.getIpAddress().add(WHITELIST_IP_VALUE);\n      config.setWhiteList(whiteList);\n      handler = new IpIdentityHandler(config, buildRanges(whiteList));\n\n      FilterDirector director = handler.handleRequest(request, response);\n\n      assertTrue(\"Should have Requests Source IP as x-pp-user\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.USER.toString()).contains(DEFAULT_IP_VALUE + WL_QUALITY_VALUE));\n      assertTrue(\"Should have IP_Super as a group\", director.requestHeaderManager().headersToAdd().get(PowerApiHeader.GROUPS.toString()).contains(IpIdentityGroup.DEFAULT_WHITELIST_GROUP + WL_QUALITY_VALUE));\n   }","commit_id":"078d3457af8136784bf3d39f2fd5d65cd134bc89","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n  public void initFilter(FilterContainer container, Configuration conf) {\n    Map<String, String> params = new HashMap<String, String>();\n    List<String> proxies = WebAppUtils.getProxyHostsAndPortsForAmFilter(conf);\n    StringBuilder sb = new StringBuilder();\n    for (String proxy : proxies) {\n      sb.append(proxy.split(\":\")[0]).append(AmIpFilter.PROXY_HOSTS_DELIMITER);\n    }\n    sb.setLength(sb.length() - 1);\n    params.put(AmIpFilter.PROXY_HOSTS, sb.toString());\n\n    String prefix = WebAppUtils.getHttpSchemePrefix(conf);\n    String proxyBase = getApplicationWebProxyBase();\n    sb = new StringBuilder();\n    for (String proxy : proxies) {\n      sb.append(prefix).append(proxy).append(proxyBase)\n          .append(AmIpFilter.PROXY_HOSTS_DELIMITER);\n    }\n    sb.setLength(sb.length() - 1);\n    params.put(AmIpFilter.PROXY_URI_BASES, sb.toString());\n    container.addFilter(FILTER_NAME, FILTER_CLASS, params);\n  }","id":30694,"modified_method":"@Override\n  public void initFilter(FilterContainer container, Configuration conf) {\n    Map<String, String> params = new HashMap<>();\n    List<String> proxies = WebAppUtils.getProxyHostsAndPortsForAmFilter(conf);\n    StringBuilder sb = new StringBuilder();\n    for (String proxy : proxies) {\n      sb.append(proxy.split(\":\")[0]).append(AmIpFilter.PROXY_HOSTS_DELIMITER);\n    }\n    sb.setLength(sb.length() - 1);\n    params.put(AmIpFilter.PROXY_HOSTS, sb.toString());\n\n    String prefix = WebAppUtils.getHttpSchemePrefix(conf);\n    String proxyBase = getApplicationWebProxyBase();\n    sb = new StringBuilder();\n    for (String proxy : proxies) {\n      sb.append(prefix).append(proxy).append(proxyBase)\n          .append(AmIpFilter.PROXY_HOSTS_DELIMITER);\n    }\n    sb.setLength(sb.length() - 1);\n    params.put(AmIpFilter.PROXY_URI_BASES, sb.toString());\n    container.addFilter(FILTER_NAME, FILTER_CLASS, params);\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"protected Set<String> getProxyAddresses() throws ServletException {\n    long now = System.currentTimeMillis();\n    synchronized(this) {\n      if(proxyAddresses == null || (lastUpdate + updateInterval) >= now) {\n        proxyAddresses = new HashSet<String>();\n        for (String proxyHost : proxyHosts) {\n          try {\n              for(InetAddress add : InetAddress.getAllByName(proxyHost)) {\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"proxy address is: \" + add.getHostAddress());\n                }\n                proxyAddresses.add(add.getHostAddress());\n              }\n              lastUpdate = now;\n            } catch (UnknownHostException e) {\n              LOG.warn(\"Could not locate \" + proxyHost + \" - skipping\", e);\n            }\n          }\n        if (proxyAddresses.isEmpty()) {\n          throw new ServletException(\"Could not locate any of the proxy hosts\");\n        }\n      }\n      return proxyAddresses;\n    }\n  }","id":30695,"modified_method":"protected Set<String> getProxyAddresses() throws ServletException {\n    long now = System.currentTimeMillis();\n    synchronized(this) {\n      if(proxyAddresses == null || (lastUpdate + updateInterval) >= now) {\n        proxyAddresses = new HashSet<>();\n        for (String proxyHost : proxyHosts) {\n          try {\n              for(InetAddress add : InetAddress.getAllByName(proxyHost)) {\n                if (LOG.isDebugEnabled()) {\n                  LOG.debug(\"proxy address is: {}\", add.getHostAddress());\n                }\n                proxyAddresses.add(add.getHostAddress());\n              }\n              lastUpdate = now;\n            } catch (UnknownHostException e) {\n              LOG.warn(\"Could not locate {} - skipping\", proxyHost, e);\n            }\n          }\n        if (proxyAddresses.isEmpty()) {\n          throw new ServletException(\"Could not locate any of the proxy hosts\");\n        }\n      }\n      return proxyAddresses;\n    }\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void init(FilterConfig conf) throws ServletException {\n    // Maintain for backwards compatibility\n    if (conf.getInitParameter(PROXY_HOST) != null\n        && conf.getInitParameter(PROXY_URI_BASE) != null) {\n      proxyHosts = new String[]{conf.getInitParameter(PROXY_HOST)};\n      proxyUriBases = new HashMap<String, String>(1);\n      proxyUriBases.put(\"dummy\", conf.getInitParameter(PROXY_URI_BASE));\n    } else {\n      proxyHosts = conf.getInitParameter(PROXY_HOSTS)\n          .split(PROXY_HOSTS_DELIMITER);\n\n      String[] proxyUriBasesArr = conf.getInitParameter(PROXY_URI_BASES)\n          .split(PROXY_URI_BASES_DELIMITER);\n      proxyUriBases = new HashMap<String, String>();\n      for (String proxyUriBase : proxyUriBasesArr) {\n        try {\n          URL url = new URL(proxyUriBase);\n          proxyUriBases.put(url.getHost() + \":\" + url.getPort(), proxyUriBase);\n        } catch(MalformedURLException e) {\n          LOG.warn(proxyUriBase + \" does not appear to be a valid URL\", e);\n        }\n      }\n    }\n  }","id":30696,"modified_method":"@Override\n  public void init(FilterConfig conf) throws ServletException {\n    // Maintain for backwards compatibility\n    if (conf.getInitParameter(PROXY_HOST) != null\n        && conf.getInitParameter(PROXY_URI_BASE) != null) {\n      proxyHosts = new String[]{conf.getInitParameter(PROXY_HOST)};\n      proxyUriBases = new HashMap<>(1);\n      proxyUriBases.put(\"dummy\", conf.getInitParameter(PROXY_URI_BASE));\n    } else {\n      proxyHosts = conf.getInitParameter(PROXY_HOSTS)\n          .split(PROXY_HOSTS_DELIMITER);\n\n      String[] proxyUriBasesArr = conf.getInitParameter(PROXY_URI_BASES)\n          .split(PROXY_URI_BASES_DELIMITER);\n      proxyUriBases = new HashMap<>(proxyUriBasesArr.length);\n      for (String proxyUriBase : proxyUriBasesArr) {\n        try {\n          URL url = new URL(proxyUriBase);\n          proxyUriBases.put(url.getHost() + \":\" + url.getPort(), proxyUriBase);\n        } catch(MalformedURLException e) {\n          LOG.warn(\"{} does not appear to be a valid URL\", proxyUriBase, e);\n        }\n      }\n    }\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void doFilter(ServletRequest req, ServletResponse resp,\n      FilterChain chain) throws IOException, ServletException {\n    if(!(req instanceof HttpServletRequest)) {\n      throw new ServletException(\"This filter only works for HTTP/HTTPS\");\n    }\n\n    HttpServletRequest httpReq = (HttpServletRequest)req;\n    HttpServletResponse httpResp = (HttpServletResponse)resp;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Remote address for request is: \" + httpReq.getRemoteAddr());\n    }\n    if(!getProxyAddresses().contains(httpReq.getRemoteAddr())) {\n      String redirectUrl = findRedirectUrl();\n      redirectUrl = httpResp.encodeRedirectURL(redirectUrl +\n          httpReq.getRequestURI());\n      httpResp.sendRedirect(redirectUrl);\n      return;\n    }\n\n    String user = null;\n\n    if (httpReq.getCookies() != null) {\n      for(Cookie c: httpReq.getCookies()) {\n        if(WebAppProxyServlet.PROXY_USER_COOKIE_NAME.equals(c.getName())){\n          user = c.getValue();\n          break;\n        }\n      }\n    }\n    if(user == null) {\n      LOG.warn(\"Could not find \"+WebAppProxyServlet.PROXY_USER_COOKIE_NAME\n          +\" cookie, so user will not be set\");\n      chain.doFilter(req, resp);\n    } else {\n      final AmIpPrincipal principal = new AmIpPrincipal(user);\n      ServletRequest requestWrapper = new AmIpServletRequestWrapper(httpReq,\n          principal);\n      chain.doFilter(requestWrapper, resp);\n    }\n  }","id":30697,"modified_method":"@Override\n  public void doFilter(ServletRequest req, ServletResponse resp,\n      FilterChain chain) throws IOException, ServletException {\n    ProxyUtils.rejectNonHttpRequests(req);\n\n    HttpServletRequest httpReq = (HttpServletRequest)req;\n    HttpServletResponse httpResp = (HttpServletResponse)resp;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Remote address for request is: {}\", httpReq.getRemoteAddr());\n    }\n    if (!getProxyAddresses().contains(httpReq.getRemoteAddr())) {\n      String redirectUrl = findRedirectUrl();\n      String target = redirectUrl + httpReq.getRequestURI();\n      ProxyUtils.sendRedirect(httpReq,  httpResp,  target);\n      return;\n    }\n\n    String user = null;\n\n    if (httpReq.getCookies() != null) {\n      for(Cookie c: httpReq.getCookies()) {\n        if(WebAppProxyServlet.PROXY_USER_COOKIE_NAME.equals(c.getName())){\n          user = c.getValue();\n          break;\n        }\n      }\n    }\n    if (user == null) {\n      LOG.warn(\"Could not find \" + WebAppProxyServlet.PROXY_USER_COOKIE_NAME\n               + \" cookie, so user will not be set\");\n      chain.doFilter(req, resp);\n    } else {\n      final AmIpPrincipal principal = new AmIpPrincipal(user);\n      ServletRequest requestWrapper = new AmIpServletRequestWrapper(httpReq,\n          principal);\n      chain.doFilter(requestWrapper, resp);\n    }\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Test AmIpFilter\n   */\n  @Test(timeout = 1000)\n  @SuppressWarnings(\"deprecation\")\n  public void testFilter() throws Exception {\n    Map<String, String> params = new HashMap<String, String>();\n    params.put(AmIpFilter.PROXY_HOST, proxyHost);\n    params.put(AmIpFilter.PROXY_URI_BASE, proxyUri);\n    FilterConfig config = new DummyFilterConfig(params);\n\n    // dummy filter\n    FilterChain chain = new FilterChain() {\n      @Override\n      public void doFilter(ServletRequest servletRequest,\n          ServletResponse servletResponse) throws IOException, ServletException {\n        doFilterRequest = servletRequest.getClass().getName();\n        if (servletRequest instanceof AmIpServletRequestWrapper) {\n          servletWrapper = (AmIpServletRequestWrapper) servletRequest;\n\n        }\n      }\n    };\n    AmIpFilter testFilter = new AmIpFilter();\n    testFilter.init(config);\n\n    HttpServletResponseForTest response = new HttpServletResponseForTest();\n    // Test request should implements HttpServletRequest\n\n    ServletRequest failRequest = Mockito.mock(ServletRequest.class);\n    try {\n      testFilter.doFilter(failRequest, response, chain);\n      fail();\n    } catch (ServletException e) {\n      assertEquals(\"This filter only works for HTTP/HTTPS\", e.getMessage());\n    }\n\n    // request with HttpServletRequest\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\n    Mockito.when(request.getRemoteAddr()).thenReturn(\"redirect\");\n    Mockito.when(request.getRequestURI()).thenReturn(\"/redirect\");\n    testFilter.doFilter(request, response, chain);\n    // address \"redirect\" is not in host list\n    assertEquals(\"http://bogus/redirect\", response.getRedirect());\n    // \"127.0.0.1\" contains in host list. Without cookie\n    Mockito.when(request.getRemoteAddr()).thenReturn(\"127.0.0.1\");\n    testFilter.doFilter(request, response, chain);\n\n    assertTrue(doFilterRequest\n        .contains(\"javax.servlet.http.HttpServletRequest\"));\n    // cookie added\n    Cookie[] cookies = new Cookie[1];\n    cookies[0] = new Cookie(WebAppProxyServlet.PROXY_USER_COOKIE_NAME, \"user\");\n\n    Mockito.when(request.getCookies()).thenReturn(cookies);\n    testFilter.doFilter(request, response, chain);\n\n    assertEquals(\n        \"org.apache.hadoop.yarn.server.webproxy.amfilter.AmIpServletRequestWrapper\",\n        doFilterRequest);\n    // request contains principal from cookie\n    assertEquals(\"user\", servletWrapper.getUserPrincipal().getName());\n    assertEquals(\"user\", servletWrapper.getRemoteUser());\n    assertFalse(servletWrapper.isUserInRole(\"\"));\n\n  }","id":30698,"modified_method":"/**\n   * Test AmIpFilter\n   */\n  @Test(timeout = 1000)\n  @SuppressWarnings(\"deprecation\")\n  public void testFilter() throws Exception {\n    Map<String, String> params = new HashMap<String, String>();\n    params.put(AmIpFilter.PROXY_HOST, proxyHost);\n    params.put(AmIpFilter.PROXY_URI_BASE, proxyUri);\n    FilterConfig config = new DummyFilterConfig(params);\n\n    // dummy filter\n    FilterChain chain = new FilterChain() {\n      @Override\n      public void doFilter(ServletRequest servletRequest,\n          ServletResponse servletResponse) throws IOException, ServletException {\n        doFilterRequest = servletRequest.getClass().getName();\n        if (servletRequest instanceof AmIpServletRequestWrapper) {\n          servletWrapper = (AmIpServletRequestWrapper) servletRequest;\n\n        }\n      }\n    };\n    AmIpFilter testFilter = new AmIpFilter();\n    testFilter.init(config);\n\n    HttpServletResponseForTest response = new HttpServletResponseForTest();\n    // Test request should implements HttpServletRequest\n\n    ServletRequest failRequest = Mockito.mock(ServletRequest.class);\n    try {\n      testFilter.doFilter(failRequest, response, chain);\n      fail();\n    } catch (ServletException e) {\n      assertEquals(ProxyUtils.E_HTTP_HTTPS_ONLY, e.getMessage());\n    }\n\n    // request with HttpServletRequest\n    HttpServletRequest request = Mockito.mock(HttpServletRequest.class);\n    Mockito.when(request.getRemoteAddr()).thenReturn(\"redirect\");\n    Mockito.when(request.getRequestURI()).thenReturn(\"/redirect\");\n    testFilter.doFilter(request, response, chain);\n    // address \"redirect\" is not in host list\n    assertEquals(302, response.status);\n    String redirect = response.getHeader(ProxyUtils.LOCATION);\n    assertEquals(\"http://bogus/redirect\", redirect);\n    // \"127.0.0.1\" contains in host list. Without cookie\n    Mockito.when(request.getRemoteAddr()).thenReturn(\"127.0.0.1\");\n    testFilter.doFilter(request, response, chain);\n\n    assertTrue(doFilterRequest\n        .contains(\"javax.servlet.http.HttpServletRequest\"));\n    // cookie added\n    Cookie[] cookies = new Cookie[1];\n    cookies[0] = new Cookie(WebAppProxyServlet.PROXY_USER_COOKIE_NAME, \"user\");\n\n    Mockito.when(request.getCookies()).thenReturn(cookies);\n    testFilter.doFilter(request, response, chain);\n\n    assertEquals(\n        \"org.apache.hadoop.yarn.server.webproxy.amfilter.AmIpServletRequestWrapper\",\n        doFilterRequest);\n    // request contains principal from cookie\n    assertEquals(\"user\", servletWrapper.getUserPrincipal().getName());\n    assertEquals(\"user\", servletWrapper.getRemoteUser());\n    assertFalse(servletWrapper.isUserInRole(\"\"));\n\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n    public synchronized void init(Configuration conf) {\n      Configuration config = new YarnConfiguration(conf);\n      proxy = new WebAppProxyForTest();\n      addService(proxy);\n      super.init(config);\n    }","id":30699,"modified_method":"@Override\n    public synchronized void serviceInit(Configuration conf) throws Exception {\n      proxy = new WebAppProxyForTest();\n      addService(proxy);\n      super.serviceInit(conf);\n    }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void serviceStop() throws Exception {\n    if(proxyServer != null) {\n      try {\n        proxyServer.stop();\n      } catch (Exception e) {\n        LOG.fatal(\"Error stopping proxy web server\", e);\n        throw new YarnRuntimeException(\"Error stopping proxy web server\",e);\n      }\n    }\n    if(this.fetcher != null) {\n      this.fetcher.stop();\n    }\n    super.serviceStop();\n  }","id":30700,"modified_method":"@Override\n  protected void serviceStop() throws Exception {\n    if(proxyServer != null) {\n      try {\n        proxyServer.stop();\n      } catch (Exception e) {\n        LOG.error(\"Error stopping proxy web server\", e);\n        throw new YarnRuntimeException(\"Error stopping proxy web server\",e);\n      }\n    }\n    if(this.fetcher != null) {\n      this.fetcher.stop();\n    }\n    super.serviceStop();\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void serviceStart() throws Exception {\n    try {\n      Configuration conf = getConfig();\n      HttpServer2.Builder b = new HttpServer2.Builder()\n          .setName(\"proxy\")\n          .addEndpoint(\n              URI.create(WebAppUtils.getHttpSchemePrefix(conf) + bindAddress\n                  + \":\" + port)).setFindPort(port == 0).setConf(getConfig())\n          .setACL(acl);\n      if (YarnConfiguration.useHttps(conf)) {\n        WebAppUtils.loadSslConfiguration(b);\n      }\n      proxyServer = b.build();\n      proxyServer.addServlet(ProxyUriUtils.PROXY_SERVLET_NAME,\n          ProxyUriUtils.PROXY_PATH_SPEC, WebAppProxyServlet.class);\n      proxyServer.setAttribute(FETCHER_ATTRIBUTE, fetcher);\n      proxyServer\n          .setAttribute(IS_SECURITY_ENABLED_ATTRIBUTE, isSecurityEnabled);\n      proxyServer.setAttribute(PROXY_HOST_ATTRIBUTE, proxyHost);\n      proxyServer.start();\n    } catch (IOException e) {\n      LOG.fatal(\"Could not start proxy web server\",e);\n      throw new YarnRuntimeException(\"Could not start proxy web server\",e);\n    }\n    super.serviceStart();\n  }","id":30701,"modified_method":"@Override\n  protected void serviceStart() throws Exception {\n    try {\n      Configuration conf = getConfig();\n      HttpServer2.Builder b = new HttpServer2.Builder()\n          .setName(\"proxy\")\n          .addEndpoint(\n              URI.create(WebAppUtils.getHttpSchemePrefix(conf) + bindAddress\n                  + \":\" + port)).setFindPort(port == 0).setConf(getConfig())\n          .setACL(acl);\n      if (YarnConfiguration.useHttps(conf)) {\n        WebAppUtils.loadSslConfiguration(b);\n      }\n      proxyServer = b.build();\n      proxyServer.addServlet(ProxyUriUtils.PROXY_SERVLET_NAME,\n          ProxyUriUtils.PROXY_PATH_SPEC, WebAppProxyServlet.class);\n      proxyServer.setAttribute(FETCHER_ATTRIBUTE, fetcher);\n      proxyServer\n          .setAttribute(IS_SECURITY_ENABLED_ATTRIBUTE, isSecurityEnabled);\n      proxyServer.setAttribute(PROXY_HOST_ATTRIBUTE, proxyHost);\n      proxyServer.start();\n    } catch (IOException e) {\n      LOG.error(\"Could not start proxy web server\",e);\n      throw e;\n    }\n    super.serviceStart();\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void serviceInit(Configuration conf) throws Exception {\n    Configuration config = new YarnConfiguration(conf);\n    try {\n      doSecureLogin(conf);      \n    } catch(IOException ie) {\n      throw new YarnRuntimeException(\"Proxy Server Failed to login\", ie);\n    }\n    proxy = new WebAppProxy();\n    addService(proxy);\n    super.serviceInit(config);\n  }","id":30702,"modified_method":"@Override\n  protected void serviceInit(Configuration conf) throws Exception {\n    Configuration config = new YarnConfiguration(conf);\n    doSecureLogin(conf);      \n    proxy = new WebAppProxy();\n    addService(proxy);\n    super.serviceInit(config);\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"public static void main(String[] args) {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    StringUtils.startupShutdownMessage(WebAppProxyServer.class, args, LOG);\n    try {\n      YarnConfiguration configuration = new YarnConfiguration();\n      WebAppProxyServer proxyServer = startServer(configuration);\n      proxyServer.proxy.join();\n    } catch (Throwable t) {\n      LOG.fatal(\"Error starting Proxy server\", t);\n      System.exit(-1);\n    }\n  }","id":30703,"modified_method":"public static void main(String[] args) {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    StringUtils.startupShutdownMessage(WebAppProxyServer.class, args, LOG);\n    try {\n      YarnConfiguration configuration = new YarnConfiguration();\n      WebAppProxyServer proxyServer = startServer(configuration);\n      proxyServer.proxy.join();\n    } catch (Throwable t) {\n      ExitUtil.terminate(-1, t);\n    }\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"private void readObject(ObjectInputStream input)\n      throws IOException, ClassNotFoundException {\n    input.defaultReadObject();\n    conf = new YarnConfiguration();\n    this.trackingUriPlugins =\n        conf.getInstances(YarnConfiguration.YARN_TRACKING_URL_GENERATOR,\n            TrackingUriPlugin.class);\n  }","id":30704,"modified_method":"/**\n   * This method is used by Java object deserialization, to fill in the\n   * transient {@link #trackingUriPlugins} field.\n   * See {@link ObjectInputStream#defaultReadObject()}\n   * <p>\n   *   <I>Do not remove<\/I>\n   * <p>\n   * Yarn isn't currently serializing this class, but findbugs\n   * complains in its absence.\n   * \n   * \n   * @param input source\n   * @throws IOException IO failure\n   * @throws ClassNotFoundException classloader fun\n   */\n  private void readObject(ObjectInputStream input)\n      throws IOException, ClassNotFoundException {\n    input.defaultReadObject();\n    conf = new YarnConfiguration();\n    this.trackingUriPlugins =\n        conf.getInstances(YarnConfiguration.YARN_TRACKING_URL_GENERATOR,\n            TrackingUriPlugin.class);\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Output 404 with appropriate message.\n   * @param resp the http response.\n   * @param message the message to include on the page.\n   * @throws IOException on any error.\n   */\n  private static void notFound(HttpServletResponse resp, String message) \n    throws IOException {\n    resp.setStatus(HttpServletResponse.SC_NOT_FOUND);\n    resp.setContentType(MimeType.HTML);\n    Page p = new Page(resp.getWriter());\n    p.html().\n      h1(message).\n    _();\n  }","id":30705,"modified_method":"/**\n   * Output 404 with appropriate message.\n   * @param resp the http response.\n   * @param message the message to include on the page.\n   * @throws IOException on any error.\n   */\n  private static void notFound(HttpServletResponse resp, String message) \n    throws IOException {\n    ProxyUtils.notFound(resp, message);\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS = \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned = false;\n      boolean userApproved = \n        (userApprovedParamS != null && Boolean.valueOf(userApprovedParamS));\n      boolean securityEnabled = isSecurityEnabled();\n      final String remoteUser = req.getRemoteUser();\n      final String pathInfo = req.getPathInfo();\n\n      String parts[] = pathInfo.split(\"/\", 3);\n      if(parts.length < 2) {\n        LOG.warn(remoteUser+\" Gave an invalid proxy path \"+pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId = parts[1];\n      String rest = parts.length > 2 ? parts[2] : \"\";\n      ApplicationId id = Apps.toAppID(appId);\n      if(id == null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+appId+\n        \" that is invalid\");\n        notFound(resp, appId+\" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName = getCheckCookieName(id); \n        Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned = true;\n              userApproved = userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser = securityEnabled && (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport = null;\n      try {\n        applicationReport = getApplicationReport(id);\n      } catch (ApplicationNotFoundException e) {\n        applicationReport = null;\n      }\n      if(applicationReport == null) {\n        LOG.warn(req.getRemoteUser()+\" Attempting to access \"+id+\n            \" that was not found\");\n\n        URI toFetch =\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch != null)\n        {\n          resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n          return;\n        }\n\n        notFound(resp, \"Application \"+appId+\" could not be found, \" +\n        \t\t\"please try the history server\");\n        return;\n      }\n      String original = applicationReport.getOriginalTrackingUrl();\n      URI trackingUri = null;\n      // fallback to ResourceManager's app page if no tracking URI provided\n      if(original == null || original.equals(\"N/A\")) {\n        resp.sendRedirect(resp.encodeRedirectURL(\n            StringHelper.pjoin(rmAppPageUrlBase, id.toString())));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri = ProxyUriUtils.getUriFromAMUrl(\n              WebAppUtils.getHttpSchemePrefix(conf), original);\n        } else {\n          trackingUri = new URI(original);\n        }\n      }\n\n      String runningUser = applicationReport.getUser();\n      if(checkUser && !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking \"+remoteUser+\" if they want to connect to the \" +\n            \"app master GUI of \"+appId+\" owned by \"+runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      URI toFetch = new URI(trackingUri.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(req.getRemoteUser()+\" is accessing unchecked \"+toFetch+\n          \" which is the app master GUI of \"+appId+\" owned by \"+runningUser);\n\n      switch(applicationReport.getYarnApplicationState()) {\n      case KILLED:\n      case FINISHED:\n      case FAILED:\n        resp.sendRedirect(resp.encodeRedirectURL(toFetch.toString()));\n        return;\n      }\n      Cookie c = null;\n      if(userWasWarned && userApproved) {\n        c = makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException e) {\n      throw new IOException(e); \n    } catch (YarnException e) {\n      throw new IOException(e);\n    }\n  }","id":30706,"modified_method":"@Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) \n  throws IOException{\n    try {\n      String userApprovedParamS = \n        req.getParameter(ProxyUriUtils.PROXY_APPROVAL_PARAM);\n      boolean userWasWarned = false;\n      boolean userApproved = Boolean.valueOf(userApprovedParamS);\n      boolean securityEnabled = isSecurityEnabled();\n      final String remoteUser = req.getRemoteUser();\n      final String pathInfo = req.getPathInfo();\n\n      String[] parts = pathInfo.split(\"/\", 3);\n      if(parts.length < 2) {\n        LOG.warn(\"{} gave an invalid proxy path {}\", remoteUser,  pathInfo);\n        notFound(resp, \"Your path appears to be formatted incorrectly.\");\n        return;\n      }\n      //parts[0] is empty because path info always starts with a /\n      String appId = parts[1];\n      String rest = parts.length > 2 ? parts[2] : \"\";\n      ApplicationId id = Apps.toAppID(appId);\n      if(id == null) {\n        LOG.warn(\"{} attempting to access {} that is invalid\",\n            remoteUser, appId);\n        notFound(resp, appId + \" appears to be formatted incorrectly.\");\n        return;\n      }\n      \n      if(securityEnabled) {\n        String cookieName = getCheckCookieName(id); \n        Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n          for (Cookie c : cookies) {\n            if (cookieName.equals(c.getName())) {\n              userWasWarned = true;\n              userApproved = userApproved || Boolean.valueOf(c.getValue());\n              break;\n            }\n          }\n        }\n      }\n      \n      boolean checkUser = securityEnabled && (!userWasWarned || !userApproved);\n\n      ApplicationReport applicationReport;\n      try {\n        applicationReport = getApplicationReport(id);\n      } catch (ApplicationNotFoundException e) {\n        applicationReport = null;\n      }\n      if(applicationReport == null) {\n        LOG.warn(\"{} attempting to access {} that was not found\",\n            remoteUser, id);\n\n        URI toFetch =\n            ProxyUriUtils\n                .getUriFromTrackingPlugins(id, this.trackingUriPlugins);\n        if (toFetch != null) {\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        }\n\n        notFound(resp, \"Application \" + appId + \" could not be found, \" +\n                       \"please try the history server\");\n        return;\n      }\n      String original = applicationReport.getOriginalTrackingUrl();\n      URI trackingUri;\n      // fallback to ResourceManager's app page if no tracking URI provided\n      if(original == null || original.equals(\"N/A\")) {\n        ProxyUtils.sendRedirect(req, resp, \n            StringHelper.pjoin(rmAppPageUrlBase, id.toString()));\n        return;\n      } else {\n        if (ProxyUriUtils.getSchemeFromUrl(original).isEmpty()) {\n          trackingUri = ProxyUriUtils.getUriFromAMUrl(\n              WebAppUtils.getHttpSchemePrefix(conf), original);\n        } else {\n          trackingUri = new URI(original);\n        }\n      }\n\n      String runningUser = applicationReport.getUser();\n      if(checkUser && !runningUser.equals(remoteUser)) {\n        LOG.info(\"Asking {} if they want to connect to the \"\n            + \"app master GUI of {} owned by {}\",\n            remoteUser, appId, runningUser);\n        warnUserPage(resp, ProxyUriUtils.getPathAndQuery(id, rest, \n            req.getQueryString(), true), runningUser, id);\n        return;\n      }\n      URI toFetch = new URI(trackingUri.getScheme(), \n          trackingUri.getAuthority(),\n          StringHelper.ujoin(trackingUri.getPath(), rest), req.getQueryString(),\n          null);\n      \n      LOG.info(\"{} is accessing unchecked {}\"\n          + \" which is the app master GUI of {} owned by {}\",\n          remoteUser, toFetch, appId, runningUser);\n\n      switch (applicationReport.getYarnApplicationState()) {\n        case KILLED:\n        case FINISHED:\n        case FAILED:\n          ProxyUtils.sendRedirect(req, resp, toFetch.toString());\n          return;\n        default:\n          // fall out of the switch\n      }\n      Cookie c = null;\n      if (userWasWarned && userApproved) {\n        c = makeCheckCookie(id, true);\n      }\n      proxyLink(req, resp, toFetch, c, getProxyHost());\n\n    } catch(URISyntaxException | YarnException e) {\n      throw new IOException(e); \n    }\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Download link and have it be the response.\n   * @param req the http request\n   * @param resp the http response\n   * @param link the link to download\n   * @param c the cookie to set if any\n   * @throws IOException on any error.\n   */\n  private static void proxyLink(HttpServletRequest req, \n      HttpServletResponse resp, URI link, Cookie c, String proxyHost)\n      throws IOException {\n    org.apache.commons.httpclient.URI uri = \n      new org.apache.commons.httpclient.URI(link.toString(), false);\n    HttpClientParams params = new HttpClientParams();\n    params.setCookiePolicy(CookiePolicy.BROWSER_COMPATIBILITY);\n    params.setBooleanParameter(HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, true);\n    HttpClient client = new HttpClient(params);\n    // Make sure we send the request from the proxy address in the config\n    // since that is what the AM filter checks against. IP aliasing or\n    // similar could cause issues otherwise.\n    HostConfiguration config = new HostConfiguration();\n    InetAddress localAddress = InetAddress.getByName(proxyHost);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"local InetAddress for proxy host: \" + localAddress.toString());\n    }\n    config.setLocalAddress(localAddress);\n    HttpMethod method = new GetMethod(uri.getEscapedURI());\n    method.setRequestHeader(\"Connection\",\"close\");\n    @SuppressWarnings(\"unchecked\")\n    Enumeration<String> names = req.getHeaderNames();\n    while(names.hasMoreElements()) {\n      String name = names.nextElement();\n      if(passThroughHeaders.contains(name)) {\n        String value = req.getHeader(name);\n        LOG.debug(\"REQ HEADER: \"+name+\" : \"+value);\n        method.setRequestHeader(name, value);\n      }\n    }\n\n    String user = req.getRemoteUser();\n    if(user != null && !user.isEmpty()) {\n      method.setRequestHeader(\"Cookie\",PROXY_USER_COOKIE_NAME+\"=\"+\n          URLEncoder.encode(user, \"ASCII\"));\n    }\n    OutputStream out = resp.getOutputStream();\n    try {\n      resp.setStatus(client.executeMethod(config, method));\n      for(Header header : method.getResponseHeaders()) {\n        resp.setHeader(header.getName(), header.getValue());\n      }\n      if(c != null) {\n        resp.addCookie(c);\n      }\n      InputStream in = method.getResponseBodyAsStream();\n      if(in != null) {\n        IOUtils.copyBytes(in, out, 4096, true);\n      }\n    } finally {\n      method.releaseConnection();\n    }\n  }","id":30707,"modified_method":"/**\n   * Download link and have it be the response.\n   * @param req the http request\n   * @param resp the http response\n   * @param link the link to download\n   * @param c the cookie to set if any\n   * @throws IOException on any error.\n   */\n  private static void proxyLink(HttpServletRequest req, \n      HttpServletResponse resp, URI link, Cookie c, String proxyHost)\n      throws IOException {\n    org.apache.commons.httpclient.URI uri = \n      new org.apache.commons.httpclient.URI(link.toString(), false);\n    HttpClientParams params = new HttpClientParams();\n    params.setCookiePolicy(CookiePolicy.BROWSER_COMPATIBILITY);\n    params.setBooleanParameter(HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, true);\n    HttpClient client = new HttpClient(params);\n    // Make sure we send the request from the proxy address in the config\n    // since that is what the AM filter checks against. IP aliasing or\n    // similar could cause issues otherwise.\n    HostConfiguration config = new HostConfiguration();\n    InetAddress localAddress = InetAddress.getByName(proxyHost);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"local InetAddress for proxy host: {}\", localAddress);\n    }\n    config.setLocalAddress(localAddress);\n    HttpMethod method = new GetMethod(uri.getEscapedURI());\n    method.setRequestHeader(\"Connection\",\"close\");\n    @SuppressWarnings(\"unchecked\")\n    Enumeration<String> names = req.getHeaderNames();\n    while(names.hasMoreElements()) {\n      String name = names.nextElement();\n      if(passThroughHeaders.contains(name)) {\n        String value = req.getHeader(name);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"REQ HEADER: {} : {}\", name, value);\n        }\n        method.setRequestHeader(name, value);\n      }\n    }\n\n    String user = req.getRemoteUser();\n    if (user != null && !user.isEmpty()) {\n      method.setRequestHeader(\"Cookie\",\n          PROXY_USER_COOKIE_NAME + \"=\" + URLEncoder.encode(user, \"ASCII\"));\n    }\n    OutputStream out = resp.getOutputStream();\n    try {\n      resp.setStatus(client.executeMethod(config, method));\n      for(Header header : method.getResponseHeaders()) {\n        resp.setHeader(header.getName(), header.getValue());\n      }\n      if (c != null) {\n        resp.addCookie(c);\n      }\n      InputStream in = method.getResponseBodyAsStream();\n      if (in != null) {\n        IOUtils.copyBytes(in, out, 4096, true);\n      }\n    } finally {\n      method.releaseConnection();\n    }\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"public HTML<WebAppProxyServlet._> html() {\n      return new HTML<WebAppProxyServlet._>(\"html\", null, EnumSet.of(EOpt.ENDTAG));\n    }","id":30708,"modified_method":"public HTML<WebAppProxyServlet._> html() {\n      return new HTML<>(\"html\", null, EnumSet.of(EOpt.ENDTAG));\n    }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"private boolean isSecurityEnabled() {\n    Boolean b = (Boolean) getServletContext()\n        .getAttribute(WebAppProxy.IS_SECURITY_ENABLED_ATTRIBUTE);\n    if(b != null) return b;\n    return false;\n  }","id":30709,"modified_method":"private boolean isSecurityEnabled() {\n    Boolean b = (Boolean) getServletContext()\n        .getAttribute(WebAppProxy.IS_SECURITY_ENABLED_ATTRIBUTE);\n    return b != null ? b : false;\n  }","commit_id":"83be450acc7fc9bb9f7bbd006e7b0804bf10279c","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tString remoteAddr = request.getRemoteAddr();\n\n\t\tif (AccessControlUtil.isAccessAllowed(request, _hostsAllowed)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Access allowed for \" + remoteAddr);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Access denied for \" + remoteAddr);\n\t\t\t}\n\n\t\t\tresponse.sendError(\n\t\t\t\tHttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\"Access denied for \" + remoteAddr);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (_httpsRequired) {\n\t\t\t\t_log.debug(\"https is required\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"https is not required\");\n\t\t\t}\n\t\t}\n\n\t\tif (_httpsRequired && !request.isSecure()) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString completeURL = HttpUtil.getCompleteURL(request);\n\n\t\t\t\t_log.debug(\"Securing \" + completeURL);\n\t\t\t}\n\n\t\t\tStringBundler redirectURL = new StringBundler(5);\n\n\t\t\tredirectURL.append(Http.HTTPS_WITH_SLASH);\n\t\t\tredirectURL.append(request.getServerName());\n\t\t\tredirectURL.append(request.getServletPath());\n\n\t\t\tString queryString = request.getQueryString();\n\n\t\t\tif (Validator.isNotNull(queryString)) {\n\t\t\t\tredirectURL.append(StringPool.QUESTION);\n\t\t\t\tredirectURL.append(request.getQueryString());\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Redirect to \" + redirectURL);\n\t\t\t}\n\n\t\t\tresponse.sendRedirect(redirectURL.toString());\n\t\t}\n\t\telse {\n\t\t\tString completeURL = HttpUtil.getCompleteURL(request);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Not securing \" + completeURL);\n\t\t\t}\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = PortalUtil.initUser(request);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tresponse.sendRedirect(completeURL);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tinitThreadLocals(user);\n\n\t\t\tif (!user.isDefaultUser()) {\n\t\t\t\trequest = setCredentials(\n\t\t\t\t\trequest, request.getSession(), user.getUserId(), null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_digestAuthEnabled) {\n\t\t\t\t\trequest = digestAuth(request, response);\n\t\t\t\t}\n\t\t\t\telse if (_basicAuthEnabled) {\n\t\t\t\t\trequest = basicAuth(request, response);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (request != null) {\n\t\t\t\tClass<?> clazz = getClass();\n\n\t\t\t\tprocessFilter(clazz.getName(), request, response, filterChain);\n\t\t\t}\n\t\t}\n\t}","id":30710,"modified_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tif (AccessControlUtil.isAccessAllowed(request, _hostsAllowed)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Access allowed for \" + request.getRemoteAddr());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Access denied for \" + request.getRemoteAddr());\n\t\t\t}\n\n\t\t\tresponse.sendError(\n\t\t\t\tHttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\"Access denied for \" + request.getRemoteAddr());\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (_httpsRequired) {\n\t\t\t\t_log.debug(\"https is required\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"https is not required\");\n\t\t\t}\n\t\t}\n\n\t\tif (_httpsRequired && !request.isSecure()) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tString completeURL = HttpUtil.getCompleteURL(request);\n\n\t\t\t\t_log.debug(\"Securing \" + completeURL);\n\t\t\t}\n\n\t\t\tStringBundler redirectURL = new StringBundler(5);\n\n\t\t\tredirectURL.append(Http.HTTPS_WITH_SLASH);\n\t\t\tredirectURL.append(request.getServerName());\n\t\t\tredirectURL.append(request.getServletPath());\n\n\t\t\tString queryString = request.getQueryString();\n\n\t\t\tif (Validator.isNotNull(queryString)) {\n\t\t\t\tredirectURL.append(StringPool.QUESTION);\n\t\t\t\tredirectURL.append(request.getQueryString());\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Redirect to \" + redirectURL);\n\t\t\t}\n\n\t\t\tresponse.sendRedirect(redirectURL.toString());\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Not securing \" + HttpUtil.getCompleteURL(request));\n\t\t\t}\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = PortalUtil.initUser(request);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tresponse.sendRedirect(HttpUtil.getCompleteURL(request));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tinitThreadLocals(user);\n\n\t\t\tif (!user.isDefaultUser()) {\n\t\t\t\trequest = setCredentials(\n\t\t\t\t\trequest, request.getSession(), user.getUserId(), null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_digestAuthEnabled) {\n\t\t\t\t\trequest = digestAuth(request, response);\n\t\t\t\t}\n\t\t\t\telse if (_basicAuthEnabled) {\n\t\t\t\t\trequest = basicAuth(request, response);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (request != null) {\n\t\t\t\tClass<?> clazz = getClass();\n\n\t\t\t\tprocessFilter(clazz.getName(), request, response, filterChain);\n\t\t\t}\n\t\t}\n\t}","commit_id":"10cd467bb6e38beda35bd5180fe1a400bd169b2c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void processRequestInContext(HttpServletRequest req, HttpServletResponse resp) {\n        StringBuffer auditTrailSb = new StringBuffer();\n        auditTrailSb.append(\" \" + req.getRemoteAddr());\n        auditTrailSb.append(\" -- \" + req.getMethod() + \" \");\n        // get the response format since we'll need it in a couple of places\n        String responseType = BaseCmd.RESPONSE_TYPE_XML;\n        Map<String, Object[]> params = new HashMap<String, Object[]>();\n        params.putAll(req.getParameterMap());\n\n        // For HTTP GET requests, it seems that HttpServletRequest.getParameterMap() actually tries\n        // to unwrap URL encoded content from ISO-9959-1.\n        // After failed in using setCharacterEncoding() to control it, end up with following hacking:\n        // for all GET requests, we will override it with our-own way of UTF-8 based URL decoding.\n        utf8Fixup(req, params);\n\n        // logging the request start and end in management log for easy debugging\n        String reqStr = \"\";\n        if (s_logger.isDebugEnabled()) {\n            reqStr = auditTrailSb.toString() + \" \" + StringUtils.cleanString(req.getQueryString());\n            s_logger.debug(\"===START=== \" + reqStr);\n        }\n\n        try {\n            HttpSession session = req.getSession(false);\n            Object[] responseTypeParam = params.get(\"response\");\n            if (responseTypeParam != null) {\n                responseType = (String)responseTypeParam[0];\n            }\n\n            Object[] commandObj = params.get(\"command\");\n            if (commandObj != null) {\n                String command = (String)commandObj[0];\n                if (\"logout\".equalsIgnoreCase(command)) {\n                    // if this is just a logout, invalidate the session and return\n                    if (session != null) {\n                        Long userId = (Long)session.getAttribute(\"userid\");\n                        Account account = (Account)session.getAttribute(\"accountobj\");\n                        Long accountId = null;\n                        if (account != null) {\n                            accountId = account.getId();\n                        }\n                        auditTrailSb.insert(0, \"(userId=\" + userId + \" accountId=\" + accountId + \" sessionId=\" + session.getId() + \")\");\n                        if (userId != null) {\n                            _apiServer.logoutUser(userId);\n                        }\n                        try {\n                            session.invalidate();\n                        } catch (IllegalStateException ise) {\n                        }\n                    }\n                    auditTrailSb.append(\"command=logout\");\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_OK);\n                    writeResponse(resp, getLogoutSuccessResponse(responseType), HttpServletResponse.SC_OK, responseType);\n                    return;\n                } else if (\"login\".equalsIgnoreCase(command)) {\n                    auditTrailSb.append(\"command=login\");\n                    // if this is a login, authenticate the user and return\n                    if (session != null) {\n                        try {\n                            session.invalidate();\n                        } catch (IllegalStateException ise) {\n                        }\n                    }\n                    session = req.getSession(true);\n                    String[] username = (String[])params.get(\"username\");\n                    String[] password = (String[])params.get(\"password\");\n                    String[] domainIdArr = (String[])params.get(\"domainid\");\n\n                    if (domainIdArr == null) {\n                        domainIdArr = (String[])params.get(\"domainId\");\n                    }\n                    String[] domainName = (String[])params.get(\"domain\");\n                    Long domainId = null;\n                    if ((domainIdArr != null) && (domainIdArr.length > 0)) {\n                        try {\n                            //check if UUID is passed in for domain\n                            domainId = _apiServer.fetchDomainId(domainIdArr[0]);\n                            if (domainId == null) {\n                                domainId = new Long(Long.parseLong(domainIdArr[0]));\n                            }\n                            auditTrailSb.append(\" domainid=\" + domainId);// building the params for POST call\n                        } catch (NumberFormatException e) {\n                            s_logger.warn(\"Invalid domain id entered by user\");\n                            auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"Invalid domain id entered, please enter a valid one\");\n                            String serializedResponse =\n                                _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid domain id entered, please enter a valid one\", params,\n                                    responseType);\n                            writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n                        }\n                    }\n                    String domain = null;\n                    if (domainName != null) {\n                        domain = domainName[0];\n                        auditTrailSb.append(\" domain=\" + domain);\n                        if (domain != null) {\n                            // ensure domain starts with '/' and ends with '/'\n                            if (!domain.endsWith(\"/\")) {\n                                domain += '/';\n                            }\n                            if (!domain.startsWith(\"/\")) {\n                                domain = \"/\" + domain;\n                            }\n                        }\n                    }\n\n                    if (username != null) {\n                        String pwd = ((password == null) ? null : password[0]);\n                        try {\n                            _apiServer.loginUser(session, username[0], pwd, domainId, domain, req.getRemoteAddr(), params);\n                            auditTrailSb.insert(0, \"(userId=\" + session.getAttribute(\"userid\") + \" accountId=\" + ((Account)session.getAttribute(\"accountobj\")).getId() +\n                                \" sessionId=\" + session.getId() + \")\");\n                            String loginResponse = getLoginSuccessResponse(session, responseType);\n                            writeResponse(resp, loginResponse, HttpServletResponse.SC_OK, responseType);\n                            return;\n                        } catch (CloudAuthenticationException ex) {\n                            // TODO: fall through to API key, or just fail here w/ auth error? (HTTP 401)\n                            try {\n                                session.invalidate();\n                            } catch (IllegalStateException ise) {\n                            }\n\n                            auditTrailSb.append(\" \" + ApiErrorCode.ACCOUNT_ERROR + \" \" + ex.getMessage() != null ? ex.getMessage()\n                                : \"failed to authenticate user, check if username/password are correct\");\n                            String serializedResponse =\n                                _apiServer.getSerializedApiError(ApiErrorCode.ACCOUNT_ERROR.getHttpCode(), ex.getMessage() != null ? ex.getMessage()\n                                    : \"failed to authenticate user, check if username/password are correct\", params, responseType);\n                            writeResponse(resp, serializedResponse, ApiErrorCode.ACCOUNT_ERROR.getHttpCode(), responseType);\n                            return;\n                        }\n                    }\n                }\n            }\n            auditTrailSb.append(req.getQueryString());\n            boolean isNew = ((session == null) ? true : session.isNew());\n\n            // Initialize an empty context and we will update it after we have verified the request below,\n            // we no longer rely on web-session here, verifyRequest will populate user/account information\n            // if a API key exists\n            Long userId = null;\n\n            if (!isNew) {\n                userId = (Long)session.getAttribute(\"userid\");\n                String account = (String)session.getAttribute(\"account\");\n                Object accountObj = session.getAttribute(\"accountobj\");\n                String sessionKey = (String)session.getAttribute(\"sessionkey\");\n                String[] sessionKeyParam = (String[])params.get(\"sessionkey\");\n                if ((sessionKeyParam == null) || (sessionKey == null) || !sessionKey.equals(sessionKeyParam[0])) {\n                    try {\n                        session.invalidate();\n                    } catch (IllegalStateException ise) {\n                    }\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials\");\n                    String serializedResponse =\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\", params, responseType);\n                    writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n                    return;\n                }\n\n                // Do a sanity check here to make sure the user hasn't already been deleted\n                if ((userId != null) && (account != null) && (accountObj != null) && _apiServer.verifyUser(userId)) {\n                    String[] command = (String[])params.get(\"command\");\n                    if (command == null) {\n                        s_logger.info(\"missing command, ignoring request...\");\n                        auditTrailSb.append(\" \" + HttpServletResponse.SC_BAD_REQUEST + \" \" + \"no command specified\");\n                        String serializedResponse = _apiServer.getSerializedApiError(HttpServletResponse.SC_BAD_REQUEST, \"no command specified\", params, responseType);\n                        writeResponse(resp, serializedResponse, HttpServletResponse.SC_BAD_REQUEST, responseType);\n                        return;\n                    }\n                    User user = _entityMgr.findById(User.class, userId);\n                    CallContext.register(user, (Account)accountObj);\n                } else {\n                    // Invalidate the session to ensure we won't allow a request across management server\n                    // restarts if the userId was serialized to the stored session\n                    try {\n                        session.invalidate();\n                    } catch (IllegalStateException ise) {\n                    }\n\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials\");\n                    String serializedResponse =\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\", params, responseType);\n                    writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n                    return;\n                }\n            } else {\n                CallContext.register(_accountMgr.getSystemUser(), _accountMgr.getSystemAccount());\n            }\n\n            if (_apiServer.verifyRequest(params, userId)) {\n                /*\n                 * if (accountObj != null) { Account userAccount = (Account)accountObj; if (userAccount.getType() ==\n                 * Account.ACCOUNT_TYPE_NORMAL) { params.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\n                 * params.put(BaseCmd.Properties.ACCOUNT.getName(), new String[] { account });\n                 * params.put(BaseCmd.Properties.DOMAIN_ID.getName(), new String[] { domainId });\n                 * params.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj }); } else {\n                 * params.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\n                 * params.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj }); } }\n                 *\n                 * // update user context info here so that we can take information if the request is authenticated // via api\n                 * key mechanism updateUserContext(params, session != null ? session.getId() : null);\n                 */\n\n                auditTrailSb.insert(0, \"(userId=\" + CallContext.current().getCallingUserId() + \" accountId=\" + CallContext.current().getCallingAccount().getId() +\n                    \" sessionId=\" + (session != null ? session.getId() : null) + \")\");\n\n                // Add the HTTP method (GET/POST/PUT/DELETE) as well into the params map.\n                params.put(\"httpmethod\", new String[] {req.getMethod()});\n                String response = _apiServer.handleRequest(params, responseType, auditTrailSb);\n                writeResponse(resp, response != null ? response : \"\", HttpServletResponse.SC_OK, responseType);\n            } else {\n                if (session != null) {\n                    try {\n                        session.invalidate();\n                    } catch (IllegalStateException ise) {\n                    }\n                }\n\n                auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials and/or request signature\");\n                String serializedResponse =\n                    _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials and/or request signature\", params,\n                        responseType);\n                writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n\n            }\n        } catch (ServerApiException se) {\n            String serializedResponseText = _apiServer.getSerializedApiError(se, params, responseType);\n            resp.setHeader(\"X-Description\", se.getDescription());\n            writeResponse(resp, serializedResponseText, se.getErrorCode().getHttpCode(), responseType);\n            auditTrailSb.append(\" \" + se.getErrorCode() + \" \" + se.getDescription());\n        } catch (Exception ex) {\n            s_logger.error(\"unknown exception writing api response\", ex);\n            auditTrailSb.append(\" unknown exception writing api response\");\n        } finally {\n            s_accessLogger.info(auditTrailSb.toString());\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"===END=== \" + reqStr);\n            }\n            // cleanup user context to prevent from being peeked in other request context\n            CallContext.unregister();\n        }\n    }","id":30711,"modified_method":"private void processRequestInContext(HttpServletRequest req, HttpServletResponse resp) {\n        StringBuffer auditTrailSb = new StringBuffer();\n        String ipAddress = req.getHeader(\"X-FORWARDED-FOR\");\n        if (ipAddress == null) {\n            ipAddress = req.getRemoteAddr();\n        } else {\n            ipAddress = ipAddress.split(\",\")[0];\n        }\n        auditTrailSb.append(\" \" + ipAddress);\n        auditTrailSb.append(\" -- \" + req.getMethod() + \" \");\n        // get the response format since we'll need it in a couple of places\n        String responseType = BaseCmd.RESPONSE_TYPE_XML;\n        Map<String, Object[]> params = new HashMap<String, Object[]>();\n        params.putAll(req.getParameterMap());\n\n        // For HTTP GET requests, it seems that HttpServletRequest.getParameterMap() actually tries\n        // to unwrap URL encoded content from ISO-9959-1.\n        // After failed in using setCharacterEncoding() to control it, end up with following hacking:\n        // for all GET requests, we will override it with our-own way of UTF-8 based URL decoding.\n        utf8Fixup(req, params);\n\n        // logging the request start and end in management log for easy debugging\n        String reqStr = \"\";\n        if (s_logger.isDebugEnabled()) {\n            reqStr = auditTrailSb.toString() + \" \" + StringUtils.cleanString(req.getQueryString());\n            s_logger.debug(\"===START=== \" + reqStr);\n        }\n\n        try {\n            HttpSession session = req.getSession(false);\n            Object[] responseTypeParam = params.get(\"response\");\n            if (responseTypeParam != null) {\n                responseType = (String)responseTypeParam[0];\n            }\n\n            Object[] commandObj = params.get(\"command\");\n            if (commandObj != null) {\n                String command = (String)commandObj[0];\n                if (\"logout\".equalsIgnoreCase(command)) {\n                    // if this is just a logout, invalidate the session and return\n                    if (session != null) {\n                        Long userId = (Long)session.getAttribute(\"userid\");\n                        Account account = (Account)session.getAttribute(\"accountobj\");\n                        Long accountId = null;\n                        if (account != null) {\n                            accountId = account.getId();\n                        }\n                        auditTrailSb.insert(0, \"(userId=\" + userId + \" accountId=\" + accountId + \" sessionId=\" + session.getId() + \")\");\n                        if (userId != null) {\n                            _apiServer.logoutUser(userId);\n                        }\n                        try {\n                            session.invalidate();\n                        } catch (IllegalStateException ise) {\n                        }\n                    }\n                    auditTrailSb.append(\"command=logout\");\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_OK);\n                    writeResponse(resp, getLogoutSuccessResponse(responseType), HttpServletResponse.SC_OK, responseType);\n                    return;\n                } else if (\"login\".equalsIgnoreCase(command)) {\n                    auditTrailSb.append(\"command=login\");\n                    // if this is a login, authenticate the user and return\n                    if (session != null) {\n                        try {\n                            session.invalidate();\n                        } catch (IllegalStateException ise) {\n                        }\n                    }\n                    session = req.getSession(true);\n                    String[] username = (String[])params.get(\"username\");\n                    String[] password = (String[])params.get(\"password\");\n                    String[] domainIdArr = (String[])params.get(\"domainid\");\n\n                    if (domainIdArr == null) {\n                        domainIdArr = (String[])params.get(\"domainId\");\n                    }\n                    String[] domainName = (String[])params.get(\"domain\");\n                    Long domainId = null;\n                    if ((domainIdArr != null) && (domainIdArr.length > 0)) {\n                        try {\n                            //check if UUID is passed in for domain\n                            domainId = _apiServer.fetchDomainId(domainIdArr[0]);\n                            if (domainId == null) {\n                                domainId = new Long(Long.parseLong(domainIdArr[0]));\n                            }\n                            auditTrailSb.append(\" domainid=\" + domainId);// building the params for POST call\n                        } catch (NumberFormatException e) {\n                            s_logger.warn(\"Invalid domain id entered by user\");\n                            auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"Invalid domain id entered, please enter a valid one\");\n                            String serializedResponse =\n                                _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid domain id entered, please enter a valid one\", params,\n                                    responseType);\n                            writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n                        }\n                    }\n                    String domain = null;\n                    if (domainName != null) {\n                        domain = domainName[0];\n                        auditTrailSb.append(\" domain=\" + domain);\n                        if (domain != null) {\n                            // ensure domain starts with '/' and ends with '/'\n                            if (!domain.endsWith(\"/\")) {\n                                domain += '/';\n                            }\n                            if (!domain.startsWith(\"/\")) {\n                                domain = \"/\" + domain;\n                            }\n                        }\n                    }\n\n                    if (username != null) {\n                        String pwd = ((password == null) ? null : password[0]);\n                        try {\n                            _apiServer.loginUser(session, username[0], pwd, domainId, domain, req.getRemoteAddr(), params);\n                            auditTrailSb.insert(0, \"(userId=\" + session.getAttribute(\"userid\") + \" accountId=\" + ((Account)session.getAttribute(\"accountobj\")).getId() +\n                                \" sessionId=\" + session.getId() + \")\");\n                            String loginResponse = getLoginSuccessResponse(session, responseType);\n                            writeResponse(resp, loginResponse, HttpServletResponse.SC_OK, responseType);\n                            return;\n                        } catch (CloudAuthenticationException ex) {\n                            // TODO: fall through to API key, or just fail here w/ auth error? (HTTP 401)\n                            try {\n                                session.invalidate();\n                            } catch (IllegalStateException ise) {\n                            }\n\n                            auditTrailSb.append(\" \" + ApiErrorCode.ACCOUNT_ERROR + \" \" + ex.getMessage() != null ? ex.getMessage()\n                                : \"failed to authenticate user, check if username/password are correct\");\n                            String serializedResponse =\n                                _apiServer.getSerializedApiError(ApiErrorCode.ACCOUNT_ERROR.getHttpCode(), ex.getMessage() != null ? ex.getMessage()\n                                    : \"failed to authenticate user, check if username/password are correct\", params, responseType);\n                            writeResponse(resp, serializedResponse, ApiErrorCode.ACCOUNT_ERROR.getHttpCode(), responseType);\n                            return;\n                        }\n                    }\n                }\n            }\n            auditTrailSb.append(req.getQueryString());\n            boolean isNew = ((session == null) ? true : session.isNew());\n\n            // Initialize an empty context and we will update it after we have verified the request below,\n            // we no longer rely on web-session here, verifyRequest will populate user/account information\n            // if a API key exists\n            Long userId = null;\n\n            if (!isNew) {\n                userId = (Long)session.getAttribute(\"userid\");\n                String account = (String)session.getAttribute(\"account\");\n                Object accountObj = session.getAttribute(\"accountobj\");\n                String sessionKey = (String)session.getAttribute(\"sessionkey\");\n                String[] sessionKeyParam = (String[])params.get(\"sessionkey\");\n                if ((sessionKeyParam == null) || (sessionKey == null) || !sessionKey.equals(sessionKeyParam[0])) {\n                    try {\n                        session.invalidate();\n                    } catch (IllegalStateException ise) {\n                    }\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials\");\n                    String serializedResponse =\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\", params, responseType);\n                    writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n                    return;\n                }\n\n                // Do a sanity check here to make sure the user hasn't already been deleted\n                if ((userId != null) && (account != null) && (accountObj != null) && _apiServer.verifyUser(userId)) {\n                    String[] command = (String[])params.get(\"command\");\n                    if (command == null) {\n                        s_logger.info(\"missing command, ignoring request...\");\n                        auditTrailSb.append(\" \" + HttpServletResponse.SC_BAD_REQUEST + \" \" + \"no command specified\");\n                        String serializedResponse = _apiServer.getSerializedApiError(HttpServletResponse.SC_BAD_REQUEST, \"no command specified\", params, responseType);\n                        writeResponse(resp, serializedResponse, HttpServletResponse.SC_BAD_REQUEST, responseType);\n                        return;\n                    }\n                    User user = _entityMgr.findById(User.class, userId);\n                    CallContext.register(user, (Account)accountObj);\n                } else {\n                    // Invalidate the session to ensure we won't allow a request across management server\n                    // restarts if the userId was serialized to the stored session\n                    try {\n                        session.invalidate();\n                    } catch (IllegalStateException ise) {\n                    }\n\n                    auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials\");\n                    String serializedResponse =\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\", params, responseType);\n                    writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n                    return;\n                }\n            } else {\n                CallContext.register(_accountMgr.getSystemUser(), _accountMgr.getSystemAccount());\n            }\n\n            if (_apiServer.verifyRequest(params, userId)) {\n                /*\n                 * if (accountObj != null) { Account userAccount = (Account)accountObj; if (userAccount.getType() ==\n                 * Account.ACCOUNT_TYPE_NORMAL) { params.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\n                 * params.put(BaseCmd.Properties.ACCOUNT.getName(), new String[] { account });\n                 * params.put(BaseCmd.Properties.DOMAIN_ID.getName(), new String[] { domainId });\n                 * params.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj }); } else {\n                 * params.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\n                 * params.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj }); } }\n                 *\n                 * // update user context info here so that we can take information if the request is authenticated // via api\n                 * key mechanism updateUserContext(params, session != null ? session.getId() : null);\n                 */\n\n                auditTrailSb.insert(0, \"(userId=\" + CallContext.current().getCallingUserId() + \" accountId=\" + CallContext.current().getCallingAccount().getId() +\n                    \" sessionId=\" + (session != null ? session.getId() : null) + \")\");\n\n                // Add the HTTP method (GET/POST/PUT/DELETE) as well into the params map.\n                params.put(\"httpmethod\", new String[] {req.getMethod()});\n                String response = _apiServer.handleRequest(params, responseType, auditTrailSb);\n                writeResponse(resp, response != null ? response : \"\", HttpServletResponse.SC_OK, responseType);\n            } else {\n                if (session != null) {\n                    try {\n                        session.invalidate();\n                    } catch (IllegalStateException ise) {\n                    }\n                }\n\n                auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"unable to verify user credentials and/or request signature\");\n                String serializedResponse =\n                    _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials and/or request signature\", params,\n                        responseType);\n                writeResponse(resp, serializedResponse, HttpServletResponse.SC_UNAUTHORIZED, responseType);\n\n            }\n        } catch (ServerApiException se) {\n            String serializedResponseText = _apiServer.getSerializedApiError(se, params, responseType);\n            resp.setHeader(\"X-Description\", se.getDescription());\n            writeResponse(resp, serializedResponseText, se.getErrorCode().getHttpCode(), responseType);\n            auditTrailSb.append(\" \" + se.getErrorCode() + \" \" + se.getDescription());\n        } catch (Exception ex) {\n            s_logger.error(\"unknown exception writing api response\", ex);\n            auditTrailSb.append(\" unknown exception writing api response\");\n        } finally {\n            s_accessLogger.info(auditTrailSb.toString());\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"===END=== \" + reqStr);\n            }\n            // cleanup user context to prevent from being peeked in other request context\n            CallContext.unregister();\n        }\n    }","commit_id":"5cc47f77c5d7c1c8c40c5e7cb2f7083fd2ce56cd","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Parser createFixedParser(String resourceUri, Reader bodyReader) throws IOException {\n        InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext().getClassResolver(), resourceUri);\n        InputStreamReader reader = new InputStreamReader(is);\n        Parser parser = getParserFactory().newFixedLengthParser(reader, bodyReader);\n        if (allowShortLines) {\n            parser.setHandlingShortLines(true);\n            parser.setIgnoreParseWarnings(true);\n        }\n        if (ignoreExtraColumns) {\n            parser.setIgnoreExtraColumns(true);\n            parser.setIgnoreParseWarnings(true);\n        }\n        return parser;\n    }","id":30712,"modified_method":"protected Parser createFixedParser(String resourceUri, Reader bodyReader) throws IOException {\n        InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext().getClassResolver(), resourceUri);\n        InputStreamReader reader = new InputStreamReader(is);\n        Parser parser = getParserFactory().newFixedLengthParser(reader, bodyReader);\n        if (isAllowShortLines()) {\n            parser.setHandlingShortLines(true);\n            parser.setIgnoreParseWarnings(true);\n        }\n        if (isIgnoreExtraColumns()) {\n            parser.setIgnoreExtraColumns(true);\n            parser.setIgnoreParseWarnings(true);\n        }\n        return parser;\n    }","commit_id":"9224b8d6375bae7841b1230fbd31e83ea6fdc865","url":"https://github.com/apache/camel"},{"original_method":"public Parser createDelimitedParser(Exchange exchange) throws InvalidPayloadException, IOException {\n        Reader bodyReader = exchange.getIn().getMandatoryBody(Reader.class);\n        if (ObjectHelper.isEmpty(getResourceUri())) {\n            return getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier);\n        } else {\n            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext().getClassResolver(), resourceUri);\n            InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n            Parser parser = getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord);\n            if (isAllowShortLines()) {\n                parser.setHandlingShortLines(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            if (isIgnoreExtraColumns()) {\n                parser.setIgnoreExtraColumns(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            return parser;\n        }\n    }","id":30713,"modified_method":"public Parser createDelimitedParser(Exchange exchange) throws InvalidPayloadException, IOException {\n        Reader bodyReader = exchange.getIn().getMandatoryBody(Reader.class);\n\n        Parser parser;\n        if (ObjectHelper.isEmpty(getResourceUri())) {\n            parser = getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier);\n        } else {\n            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext().getClassResolver(), resourceUri);\n            InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n            parser = getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord);\n        }\n\n        if (isAllowShortLines()) {\n            parser.setHandlingShortLines(true);\n            parser.setIgnoreParseWarnings(true);\n        }\n        if (isIgnoreExtraColumns()) {\n            parser.setIgnoreExtraColumns(true);\n            parser.setIgnoreParseWarnings(true);\n        }\n\n        return parser;\n    }","commit_id":"9224b8d6375bae7841b1230fbd31e83ea6fdc865","url":"https://github.com/apache/camel"},{"original_method":"public Parser createParser(Exchange exchange) throws InvalidPayloadException, IOException {\n        Reader bodyReader = exchange.getIn().getMandatoryBody(Reader.class);\n        if (ObjectHelper.isEmpty(getDefinition())) {\n            return getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier);\n        } else {\n            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext().getClassResolver(), definition);\n            InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n            return getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord);\n        }\n    }","id":30714,"modified_method":"public Parser createParser(Exchange exchange) throws InvalidPayloadException, IOException {\n        Reader bodyReader = exchange.getIn().getMandatoryBody(Reader.class);\n        if (ObjectHelper.isEmpty(getDefinition())) {\n            return getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier);\n        } else {\n            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext().getClassResolver(), definition);\n            InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n            Parser parser = getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord);\n            if (isAllowShortLines()) {\n                parser.setHandlingShortLines(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            if (isIgnoreExtraColumns()) {\n                parser.setIgnoreExtraColumns(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            return parser;\n        }\n    }","commit_id":"d2d1ce1e8e3fcc317aba76f2546b3304f4338092","url":"https://github.com/apache/camel"},{"original_method":"protected Parser createParser(Exchange exchange, Reader bodyReader) throws IOException {\n        if (isFixed()) {\n            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext().getClassResolver(), getDefinition());\n            InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n            Parser parser = getParserFactory().newFixedLengthParser(reader, bodyReader);\n            if (allowShortLines) {\n                parser.setHandlingShortLines(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            if (ignoreExtraColumns) {\n                parser.setIgnoreExtraColumns(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            return parser;\n        } else {\n            if (ObjectHelper.isEmpty(getDefinition())) {\n                return getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier);\n            } else {\n                InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext().getClassResolver(), getDefinition());\n                InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n                return getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord);\n            }\n        }\n    }","id":30715,"modified_method":"protected Parser createParser(Exchange exchange, Reader bodyReader) throws IOException {\n        if (isFixed()) {\n            InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext().getClassResolver(), getDefinition());\n            InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n            Parser parser = getParserFactory().newFixedLengthParser(reader, bodyReader);\n            if (allowShortLines) {\n                parser.setHandlingShortLines(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            if (ignoreExtraColumns) {\n                parser.setIgnoreExtraColumns(true);\n                parser.setIgnoreParseWarnings(true);\n            }\n            return parser;\n        } else {\n            if (ObjectHelper.isEmpty(getDefinition())) {\n                return getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier);\n            } else {\n                InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext().getClassResolver(), getDefinition());\n                InputStreamReader reader = new InputStreamReader(is, IOHelper.getCharsetName(exchange));\n                Parser parser = getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord);\n                if (allowShortLines) {\n                    parser.setHandlingShortLines(true);\n                    parser.setIgnoreParseWarnings(true);\n                }\n                if (ignoreExtraColumns) {\n                    parser.setIgnoreExtraColumns(true);\n                    parser.setIgnoreParseWarnings(true);\n                }\n                return parser;\n            }\n        }\n    }","commit_id":"d2d1ce1e8e3fcc317aba76f2546b3304f4338092","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Method called from the scheduler\n     * \n     * @param jobContext Context of the request\n     */\n    @Override\n    public void executeJob(JobExecutionContext jobContext) throws JobExecutionException\n    {\n        try {\n            try {\n                // Set required objects\n                init(jobContext);\n                // init components (needed for velocity to work)\n                initializeContainerComponent(this.context);\n            } catch (Exception e) {\n                LOG.error(logprefix + \"exception while initializing watchlist job\", e);\n            }\n\n            // Retreive notification subscribers (all wikis)\n            Collection subscribers = retrieveNotificationSubscribers();\n            if (subscribers != null && subscribers.size() > 0) {\n                // Retreive updated documents\n                List updatedDocuments = retrieveUpdatedDocuments();\n                LOG.info(logprefix + \"updatedDocumentsNumber : [\" + updatedDocuments.size() + \"]\");\n                Iterator it = subscribers.iterator();\n                while (it.hasNext()) {\n                    try {\n                        // Retreive WatchList Object for each subscribers\n                        Document subscriber =\n                            new Document(context.getWiki().getDocument((String) it.next(), context), context);\n                        LOG.info(logprefix + \"checkingDocumentsForUser \" + subscriber.getFullName());\n                        Object userObj = subscriber.getObject(\"XWiki.XWikiUsers\");\n                        Object notificationCriteria = subscriber.getObject(WatchListPlugin.WATCHLIST_CLASS);\n                        if (userObj == null || notificationCriteria == null) {\n                            continue;\n                        }\n                        // Filter documents according to lists in the WatchList Object\n                        List matchingDocuments =\n                            filter(updatedDocuments, notificationCriteria, subscriber.getFullName());\n\n                        // If there are matching documents, sends the notification\n                        if (matchingDocuments.size() > 0) {\n                            LOG.info(logprefix + \"matchingDocumentsForUser \" + subscriber.getFullName() + \": [\"\n                                + matchingDocuments.size() + \"]\");\n                            try {\n                                sendNotificationMessage(subscriber, matchingDocuments);\n                            } catch (Exception e) {\n                                if (LOG.isErrorEnabled()) {\n                                    LOG.error(logprefix + \"exception while sending email to \"\n                                        + subscriber.getValue(\"email\") + \" with \" + matchingDocuments.size()\n                                        + \" matching documents\", e);\n                                }\n                            }\n                        }\n                    } catch (XWikiException e) {\n                        if (LOG.isErrorEnabled()) {\n                            LOG.error(\"Exception while running job for one user\", e);\n                        }\n                    }\n                }\n            }\n        } catch (XWikiException e) {\n            // We're in a job, don't throw it\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Exception while running job\", e);\n            }\n        } finally {\n            // give back execution context\n            try {\n                cleanupComponents();\n            } catch (Throwable e) {\n                // Don't throw anything to be sure that the finally will continue\n            }\n            // cleanup use database connections\n            context.getWiki().getStore().cleanUp(context);\n        }\n    }","id":30716,"modified_method":"/**\n     * Method called from the scheduler.\n     * \n     * @param jobContext Context of the request\n     * @throws JobExecutionException if the job execution fails.\n     */\n    @Override\n    public void executeJob(JobExecutionContext jobContext) throws JobExecutionException\n    {\n        try {\n            init(jobContext);\n            \n            if (watchListJobObject == null) {\n                return;\n            }\n            \n            List<String> subscribers = getSubscribers();\n            Date previousFireTime = getPreviousFireTime();\n            WatchListEventManager eventMatcher = new WatchListEventManager(previousFireTime, context);\n\n            if (!hasSubscribers()) {\n                return;\n            }\n\n            if (eventMatcher.getEventNumber() == 0) {\n                return;\n            }\n\n            for (String subscriber : subscribers) {\n                List<String> wikis = plugin.getStore().getWatchedElements(subscriber, ElementType.WIKI, this.context);\n                List<String> spaces = plugin.getStore().getWatchedElements(subscriber, ElementType.SPACE, this.context);\n                List<String> documents =\n                    plugin.getStore().getWatchedElements(subscriber, ElementType.DOCUMENT, this.context);\n                List<WatchListEvent> matchingEvents = eventMatcher.getMatchingEvents(wikis, spaces, documents);\n\n                // If events have occurred on at least one element watched by the user, send the email\n                if (matchingEvents.size() > 0) {\n                    plugin.getNotifier().sendEmailNotification(subscriber, matchingEvents, getEmailTemplate(),\n                        previousFireTime, context);\n                }\n            }\n\n            setPreviousFireTime();\n\n        } catch (Exception e) {\n            // We're in a job, we don't throw exceptions\n            LOG.error(\"Exception while running job\", e);\n            e.printStackTrace();\n        } finally {\n            context.getWiki().getStore().cleanUp(context);\n            cleanupComponents();\n        }\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void initializeContainerComponent(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer =\n            (ServletContainerInitializer) Utils.getComponent(ServletContainerInitializer.class.getName());\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse().getHttpServletResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }","id":30717,"modified_method":"/**\n     * Initialize container context.\n     * \n     * @param context The XWiki context.\n     * @throws ServletException If the container initialization fails.\n     */\n    protected void initializeComponents(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer =\n            (ServletContainerInitializer) Utils.getComponent(ServletContainerInitializer.class);\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse().getHttpServletResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void cleanupComponents()\n    {\n        Container container = (Container) Utils.getComponent(Container.class.getName());\n        Execution execution = (Execution) Utils.getComponent(Execution.class.getName());\n\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }","id":30718,"modified_method":"/**\n     * Clean the container context.\n     */\n    protected void cleanupComponents()\n    {\n        Container container = (Container) Utils.getComponent(Container.class);\n        Execution execution = (Execution) Utils.getComponent(Execution.class);\n\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Sets objects required by the Job : XWiki, XWikiContext, WatchListPlugin, etc\n     * \n     * @param jobContext Context of the request\n     */\n    public void init(JobExecutionContext jobContext) throws Exception\n    {\n        JobDataMap data = jobContext.getJobDetail().getJobDataMap();\n        // clone the context to make sure we have a new one per run\n        context = (XWikiContext) ((XWikiContext) data.get(\"context\")).clone();\n        // clean up the database connections\n        context.getWiki().getStore().cleanUp(context);\n        plugin = (WatchListPlugin) context.getWiki().getPlugin(WatchListPlugin.ID, context);\n        xjob = (BaseObject) data.get(\"xjob\");\n        jobMailTemplate = xjob.getLargeStringValue(\"script\").trim();\n        // retreive the interval from job name (1=hourly, 2=daily, etc)\n        interval = Integer.parseInt(xjob.getName().substring(xjob.getName().length() - 1));\n        logprefix = \"WatchList job \" + context.getDatabase() + \":\" + xjob.getName() + \" \";\n    }","id":30719,"modified_method":"/**\n     * Sets objects required by the Job : XWiki, XWikiContext, WatchListPlugin, etc.\n     * \n     * @param jobContext Context of the request\n     * @throws Exception when the init of components fails\n     */\n    public void init(JobExecutionContext jobContext) throws Exception\n    {\n        JobDataMap data = jobContext.getJobDetail().getJobDataMap();\n        // clone the context to make sure we have a new one per run\n        context = (XWikiContext) ((XWikiContext) data.get(\"context\")).clone();\n        // clean up the database connections\n        context.getWiki().getStore().cleanUp(context);\n        plugin = (WatchListPlugin) context.getWiki().getPlugin(WatchListPlugin.ID, context);\n        schedulerJobObject = (BaseObject) data.get(\"xjob\");\n        watchListJobObject =\n            context.getWiki().getDocument(schedulerJobObject.getName(), context).getObject(\n                WatchListJobManager.WATCHLIST_JOB_CLASS);\n        initializeComponents(context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiDefaultPlugin#init(XWikiContext)\n     */\n    public void init(XWikiContext context)\n    {\n        super.init(context);\n        try {\n            // Main wiki\n            initWatchListClass(context);\n            initWatchlistJobs(context);\n            sanitizeWatchlists(context);\n        } catch (XWikiException e) {\n            log.error(\"init\", e);\n            e.printStackTrace();\n        }\n    }","id":30720,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see com.xpn.xwiki.plugin.XWikiDefaultPlugin#init(XWikiContext)\n     */\n    public void init(XWikiContext context)\n    {\n        super.init(context);               \n        \n        try {\n            jobManager.init(context);\n            store.init(context);\n            Utils.getComponent(ObservationManager.class).addListener(store);\n        } catch (XWikiException e) {\n            LOG.error(\"init\", e);\n            e.printStackTrace();\n        }\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiDefaultPlugin#virtualInit(XWikiContext)\n     */\n    public void virtualInit(XWikiContext context)\n    {\n        super.virtualInit(context);\n        try {\n            initWatchListClass(context);\n        } catch (XWikiException e) {\n            log.error(\"virtualInit\", e);\n            e.printStackTrace();\n        }\n    }","id":30721,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see com.xpn.xwiki.plugin.XWikiDefaultPlugin#virtualInit(XWikiContext)\n     */\n    public void virtualInit(XWikiContext context)\n    {\n        super.virtualInit(context);\n        try {            \n            store.virtualInit(context);\n        } catch (XWikiException e) {\n            LOG.error(\"virtualInit\", e);\n            e.printStackTrace();\n        }\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiDefaultPlugin#getPluginApi(XWikiPluginInterface, XWikiContext)\n     */\n    public Api getPluginApi(XWikiPluginInterface plugin, XWikiContext context)\n    {\n        return new WatchListPluginApi((WatchListPlugin) plugin, context);\n    }","id":30722,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see com.xpn.xwiki.plugin.XWikiDefaultPlugin#getPluginApi(XWikiPluginInterface, XWikiContext)\n     */\n    public WatchListPluginApi getPluginApi(XWikiPluginInterface plugin, XWikiContext context)\n    {\n        return new WatchListPluginApi((WatchListPlugin) plugin, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the documents watched by the current user\n     *\n     * @return The list of the documents in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public List getWatchedDocuments() throws XWikiException\n    {\n        return getWatchListPlugin().getWatchedDocuments(getXWikiContext().getUser(), context);\n    }","id":30723,"modified_method":"/**\n     * Get the documents watched by the current user.\n     * \n     * @return The list of the documents in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retrieved nor created\n     */\n    public List<String> getWatchedDocuments() throws XWikiException\n    {\n        return getWatchListPlugin().getStore().getWatchedElements(context.getUser(), ElementType.DOCUMENT, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the list of the elements watched by user ordered by last modification date, descending\n     *\n     * @param user XWiki User\n     * @return the list of the elements watched by user ordered by last modification date, descending\n     * @throws XWikiException If the search request fails\n     */\n    public List getWatchListWhatsNew(String user) throws Exception\n    {\n        return getWatchListPlugin().getWatchListWhatsNew(user, context);\n    }","id":30724,"modified_method":"/**\n     * Get the list of the elements watched by user ordered by last modification date, descending.\n     * \n     * @param user XWiki User\n     * @return the list of the elements watched by user ordered by last modification date, descending\n     * @throws Exception If the search request fails\n     */\n    public List<String> getWatchListWhatsNew(String user) throws Exception\n    {\n        // TODO\n        \n        return null;\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Is the current space watched by the current user\n     *\n     * @return True if the document is in the current user's watchlist\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean isSpaceWatched() throws XWikiException\n    {\n        return getWatchListPlugin().getWatchedSpaces(context.getUser(), context)\n            .contains(context.getDatabase() + \":\" + context.getDoc().getSpace());\n    }","id":30725,"modified_method":"/**\n     * Is the current space watched by the current user.\n     * \n     * @return True if the document is in the current user's watchlist\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean isSpaceWatched() throws XWikiException\n    {\n        return getWatchListPlugin().getStore().getWatchedElements(context.getUser(), ElementType.SPACE, context)\n            .contains(context.getDatabase() + WatchListStore.WIKI_SPACE_SEP + context.getDoc().getSpace());\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Allows Administrators to add the specified space to the specified user's WatchList\n     *\n     * @param user XWiki User\n     * @param wSpace Space to add\n     * @return True if the space wasn't already in the user's WatchList and has been added\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addSpaceForUser(String user, String wSpace) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights() &&\n            getWatchListPlugin().addWatchedElement(user, wSpace, true,\n                getXWikiContext());\n    }","id":30726,"modified_method":"/**\n     * Allows Administrators to add the specified space to the specified user's WatchList.\n     * \n     * @param user XWiki User\n     * @param wSpace Space to add\n     * @return True if the space wasn't already in the user's WatchList and has been added\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addSpaceForUser(String user, String wSpace) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights()\n            && getWatchListPlugin().getStore().addWatchedElement(user, wSpace, ElementType.SPACE, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Allows Adminstrators to add the specified document in the specified user's WatchList\n     *\n     * @param user XWiki User\n     * @param wDoc Document to add\n     * @return True if the document wasn't already in the WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addDocumentForUser(String user, String wDoc) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights() &&\n            getWatchListPlugin().addWatchedElement(user, wDoc, false,\n                getXWikiContext());\n    }","id":30727,"modified_method":"/**\n     * Allows Adminstrators to add the specified document in the specified user's WatchList.\n     * \n     * @param user XWiki User\n     * @param wDoc Document to add\n     * @return True if the document wasn't already in the WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addDocumentForUser(String user, String wDoc) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights()\n            && getWatchListPlugin().getStore().addWatchedElement(user, wDoc, ElementType.DOCUMENT, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Remove the specified space from the current user's WatchList\n     *\n     * @param wSpace Space to remove\n     * @return True if the space was in the user's WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeSpace(String wSpace) throws XWikiException\n    {\n        return getWatchListPlugin().removeWatchedElement(getXWikiContext().getUser(),\n            wSpace, true, getXWikiContext());\n    }","id":30728,"modified_method":"/**\n     * Remove the specified space from the current user's WatchList.\n     * \n     * @param wSpace Space to remove\n     * @return True if the space was in the user's WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeSpace(String wSpace) throws XWikiException\n    {\n        return getWatchListPlugin().getStore().removeWatchedElement(context.getUser(), wSpace, ElementType.SPACE,\n            context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Is current document watched by the current user\n     *\n     * @return True if the document is in the current user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean isDocumentWatched() throws XWikiException\n    {\n        return getWatchListPlugin().getWatchedDocuments(context.getUser(), context)\n            .contains(context.getDatabase() + \":\" + context.getDoc().getFullName());\n    }","id":30729,"modified_method":"/**\n     * Is current document watched by the current user.\n     * \n     * @return True if the document is in the current user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean isDocumentWatched() throws XWikiException\n    {\n        return getWatchListPlugin().getStore().getWatchedElements(context.getUser(), ElementType.DOCUMENT, context)\n            .contains(context.getDatabase() + WatchListStore.WIKI_SPACE_SEP + context.getDoc().getFullName());\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Allows Adminstrators to remove the specified document from the specified user's WatchList\n     *\n     * @param user XWiki User\n     * @param wDoc Document to remove\n     * @return True if the document was in the WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeDocumentForUser(String user, String wDoc) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights() &&\n            getWatchListPlugin().removeWatchedElement(user, wDoc,\n                false, getXWikiContext());\n    }","id":30730,"modified_method":"/**\n     * Allows Adminstrators to remove the specified document from the specified user's WatchList.\n     * \n     * @param user XWiki User\n     * @param wDoc Document to remove\n     * @return True if the document was in the WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeDocumentForUser(String user, String wDoc) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights()\n            && getWatchListPlugin().getStore().removeWatchedElement(user, wDoc, ElementType.DOCUMENT, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Is current document within a space watched by the current user\n     *\n     * @return True if the containing space is watched\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean isDocInWatchedSpaces() throws XWikiException\n    {\n        return getWatchListPlugin().getWatchedSpaces(getXWikiContext().getUser(),\n            getXWikiContext()).contains(context.getDatabase() + \":\" + context.getDoc().getSpace());\n    }","id":30731,"modified_method":"/**\n     * Is current document within a space watched by the current user.\n     * \n     * @return True if the containing space is watched\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean isDocInWatchedSpaces() throws XWikiException\n    {\n        return getWatchListPlugin().getStore().getWatchedElements(context.getUser(), ElementType.SPACE, context)\n            .contains(context.getDatabase() + WatchListStore.WIKI_SPACE_SEP + context.getDoc().getSpace());\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Allows Administrators to remove the specified space from the specified user's WatchList\n     *\n     * @param user XWiki User\n     * @param wSpace Space to remove\n     * @return True if the space was in the user's WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeSpaceForUser(String user, String wSpace) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights() &&\n            getWatchListPlugin().removeWatchedElement(user, wSpace,\n                true, getXWikiContext());\n    }","id":30732,"modified_method":"/**\n     * Allows Administrators to remove the specified space from the specified user's WatchList.\n     * \n     * @param user XWiki User\n     * @param wSpace Space to remove\n     * @return True if the space was in the user's WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeSpaceForUser(String user, String wSpace) throws XWikiException\n    {\n        return context.getWiki().getUser(context).hasAdminRights()\n            && getWatchListPlugin().getStore().removeWatchedElement(user, wSpace, ElementType.SPACE, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Add the current space to the current user's WatchList\n     *\n     * @param wSpace Space to add\n     * @return True if the space wasn't already in the user's WatchList and has been added\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addSpace(String wSpace) throws XWikiException\n    {\n        return getWatchListPlugin().addWatchedElement(getXWikiContext().getUser(),\n            wSpace, true, getXWikiContext());\n    }","id":30733,"modified_method":"/**\n     * Add the current space to the current user's WatchList.\n     * \n     * @param wSpace Space to add\n     * @return True if the space wasn't already in the user's WatchList and has been added\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addSpace(String wSpace) throws XWikiException\n    {\n        return getWatchListPlugin().getStore().addWatchedElement(context.getUser(), wSpace, ElementType.SPACE, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Add the specified document to the current user's WatchList\n     *\n     * @param wDoc Document to add\n     * @return True if the document wasn't already in the WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addDocument(String wDoc) throws XWikiException\n    {\n        return getWatchListPlugin().addWatchedElement(getXWikiContext().getUser(),\n            wDoc, false, getXWikiContext());\n    }","id":30734,"modified_method":"/**\n     * Add the specified document to the current user's WatchList.\n     * \n     * @param wDoc Document to add\n     * @return True if the document wasn't already in the WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean addDocument(String wDoc) throws XWikiException\n    {\n        return getWatchListPlugin().getStore()\n            .addWatchedElement(context.getUser(), wDoc, ElementType.DOCUMENT, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the spaces watched by the current user\n     *\n     * @return The list of the spaces in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public List getWatchedSpaces() throws XWikiException\n    {\n        return getWatchListPlugin().getWatchedSpaces(getXWikiContext().getUser(), context);\n    }","id":30735,"modified_method":"/**\n     * Get the spaces watched by the current user.\n     * \n     * @return The list of the spaces in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retrieved nor created\n     */\n    public List<String> getWatchedSpaces() throws XWikiException\n    {\n        return getWatchListPlugin().getStore().getWatchedElements(context.getUser(), ElementType.SPACE, context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Removed the specified document from the current user's WatchList\n     *\n     * @param wDoc Document to remove\n     * @return True if the document was in the WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeDocument(String wDoc) throws XWikiException\n    {\n        return getWatchListPlugin().removeWatchedElement(getXWikiContext().getUser(),\n            wDoc, false, getXWikiContext());\n    }","id":30736,"modified_method":"/**\n     * Removed the specified document from the current user's WatchList.\n     * \n     * @param wDoc Document to remove\n     * @return True if the document was in the WatchList and has been removed\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public boolean removeDocument(String wDoc) throws XWikiException\n    {\n        return getWatchListPlugin().getStore().removeWatchedElement(context.getUser(), wDoc, ElementType.DOCUMENT,\n            context);\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the elements (documents + spaces) watched by the current user\n     *\n     * @return The list of the elements in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public List getWatchedElements() throws XWikiException\n    {\n        List wEls = new ArrayList();\n        wEls.addAll(getWatchedDocuments());\n        wEls.addAll(getWatchedSpaces());\n        return wEls;\n    }","id":30737,"modified_method":"/**\n     * Get the elements (wikis + spaces + documents) watched by the current user.\n     * \n     * @return The list of the elements in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public List<String> getWatchedElements() throws XWikiException\n    {\n        List<String> wEls = new ArrayList<String>();\n        wEls.addAll(getWatchedDocuments());\n        wEls.addAll(getWatchedSpaces());\n        wEls.addAll(getWatchedWikis());\n        return wEls;\n    }","commit_id":"2a09733a32d3c602202942b75eea7ff2d95b409c","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean isEffectivelyFinal(Variable v) {\n        if (v instanceof VariableExpression) {\n            v = ((VariableExpression) v).getAccessedVariable();\n        }\n        VariableState state = getState().get(v);\n        return state == null || state.isFinal();\n    }","id":30738,"modified_method":"public boolean isEffectivelyFinal(Variable v) {\n        VariableState state = getState().get(v);\n        return (v instanceof Parameter && state == null)\n                || (state != null && state.isFinal());\n    }","commit_id":"315476cca7b2b1ac1b474703492b36c5e4286d6e","url":"https://github.com/apache/groovy"},{"original_method":"public void sawOpcode(int seen) {\t\t\t\t\t\n\t\ttry {\n\t\t\tif ((seen == INVOKEVIRTUAL) \n\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")) {\n\t\t\t\n\t\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\t\tJavaClass cls = item.getJavaClass();\n\t\t\t\t\tString methodClassName = getClassConstantOperand();\n\t\t\t\t\n\t\t\t\t\tif (cls.isFinal()) {\n\t\t\t\t\t\tif (methodClassName.equals(\"java/lang/Object\")) {\n\t\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(\"UOE_USE_OBJECT_EQUALS\", LOW_PRIORITY)\n\t\t\t\t        \t\t.addClassAndMethod(this)\n\t\t\t\t        \t\t.addSourceLine(this));\t\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t\telse if (item.isArray()) {\n\t\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(\"UOE_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t\t        \t\t.addClassAndMethod(this)\n\t\t\t\t\t        \t\t.addSourceLine(this));\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\tcnfe.printStackTrace();\n\t\t\tbugReporter.reportMissingClass(cnfe);\n\t\t}\n\t\tfinally {\n\t\t\tstack.sawOpcode(this, seen);\n\t\t}\n\t}","id":30739,"modified_method":"public void sawOpcode(int seen) {\t\t\t\t\t\n\t\ttry {\n\t\t\tif ((seen == INVOKEVIRTUAL) \n\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")) {\n\t\t\t\n\t\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\t\tJavaClass cls = item.getJavaClass();\n\t\t\t\t\n\t\t\t\t\tif (item.isArray()) {\n\t\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(\"UOE_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t\t        \t\t.addClassAndMethod(this)\n\t\t\t\t\t        \t\t.addSourceLine(this));\n\t\t\t\t\t}\n\t\t\t\t\telse if ((cls != null) && cls.isFinal()) {\n\t\t\t\t\t\tString methodClassName = getClassConstantOperand();\n\t\t\t\t\t\tif (methodClassName.equals(\"java/lang/Object\")) {\n\t\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(\"UOE_USE_OBJECT_EQUALS\", LOW_PRIORITY)\n\t\t\t\t        \t\t.addClassAndMethod(this)\n\t\t\t\t        \t\t.addSourceLine(this));\t\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\tcnfe.printStackTrace();\n\t\t\tbugReporter.reportMissingClass(cnfe);\n\t\t}\n\t\tfinally {\n\t\t\tstack.sawOpcode(this, seen);\n\t\t}\n\t}","commit_id":"a5bb6442ef48275d78c0d1b9c2fd186f592302e5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public XField findField(String name, String signature, boolean isStatic) {\n\t\tfor (FieldInfo fInfo : xFields) \n\t\t\t\tif (fInfo.getName().equals(name)\n\t\t\t\t\t\t&& fInfo.getSignature().equals(signature)\n\t\t\t\t\t\t&& fInfo.isStatic() == isStatic) \n\t\t\t\t\treturn fInfo;\n\t\treturn null;\n\t}","id":30740,"modified_method":"public XField findField(String name, String signature, boolean isStatic) {\n\t\tfor (FieldInfo fInfo : xFields) \n\t\t\t\tif (fInfo.getName().equals(name)\n\t\t\t\t\t\t&& fInfo.getSignature().equals(signature)\n\t\t\t\t\t\t&& fInfo.isStatic() == isStatic) \n\t\t\t\t\treturn fInfo;\n\t\ttry {\n\t\t\tif (getSuperclassDescriptor() == null) return null;\n\t\t\tXClass superClass = Global.getAnalysisCache().getClassAnalysis(XClass.class,  getSuperclassDescriptor());\n\t\t\treturn superClass.findField(name, signature, isStatic);\n        } catch (CheckedAnalysisException e) {\n        \treturn null;\n        }\n\t}","commit_id":"4fe933fe976863887cafa083b7f54cdd6bf25aa3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public XMethod findMethod(String methodName, String methodSig, boolean isStatic) {\n\t\tfor (MethodInfo mInfo : xMethods) \n\t\t\t\tif (mInfo.getName().equals(methodName)\n\t\t\t\t\t\t&& mInfo.getSignature().equals(methodSig)\n\t\t\t\t\t\t&& mInfo.isStatic() == isStatic) \n\t\t\t\t\treturn mInfo;\n\t\treturn null;\n\t}","id":30741,"modified_method":"public XMethod findMethod(String methodName, String methodSig, boolean isStatic) {\n\t\tfor (MethodInfo mInfo : xMethods) \n\t\t\t\tif (mInfo.getName().equals(methodName)\n\t\t\t\t\t\t&& mInfo.getSignature().equals(methodSig)\n\t\t\t\t\t\t&& mInfo.isStatic() == isStatic) \n\t\t\t\t\treturn mInfo;\n\t\tif (true) return null;\n\t\ttry {\n\t\t\tif (getSuperclassDescriptor() == null) return null;\n\t\t\tXClass superClass = Global.getAnalysisCache().getClassAnalysis(XClass.class,  getSuperclassDescriptor());\n\t\t\treturn superClass.findMethod(methodName, methodSig, isStatic);\n        } catch (CheckedAnalysisException e) {\n        \treturn null;\n        }\n\t}","commit_id":"4fe933fe976863887cafa083b7f54cdd6bf25aa3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\t\n\t\tif (seen == PUTFIELD || seen == PUTSTATIC) {\n\t\t\tXField f = getXFieldOperand();\n\t\t\tif (f.isFinal())\n\t\t\t\temptyArray.add(f);\n\t\t\t\n\t\t\t\t\n\t\t}\n\t\temptyArrayOnTOS = (seen == ANEWARRAY || seen == NEWARRAY) && getPrevOpcode(1) == ICONST_0;\n\t\t\n\t\tif (!check) return;\n\t\t\n\t\tif (staticMethod && dangerousToStoreIntoField && seen == PUTSTATIC\n\t\t\t\t&& MutableStaticFields.mutableSignature(getSigConstantOperand())) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EI_EXPOSE_STATIC_REP2\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(),\n\t\t\t\t\t\t\ttrue)\n\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\t\tif (!staticMethod && dangerousToStoreIntoField && seen == PUTFIELD\n\t\t\t\t&& MutableStaticFields.mutableSignature(getSigConstantOperand())) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EI_EXPOSE_REP2\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(),\n\t\t\t\t\t\t\ttrue)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t/*\n\t\t\tSystem.out.println(\"Store of parameter \"\n\t\t\t\t\t+ r +\"/\" + parameterCount\n\t\t\t\t\t+ \" into field of type \" + sigConstant\n\t\t\t\t\t+ \" in \" + betterMethodName);\n\t\t\t\tbugReporter.reportBug(new BugInstance(\"EI_EXPOSE_REP2\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(betterClassConstant, nameConstant, betterSigConstant,\n\t\t\t\t\t\t\tfalse)\n\t\t\t\t\t.addSourceLine(this));\n\t\t`\t*/\n\t\t}\n\t\tdangerousToStoreIntoField = false;\n\t\tint reg = -1; // this value should never be seen\n\t\tcheckStore: {\n\t\t\tswitch (seen) {\n\t\t\tcase ALOAD_0:\n\t\t\t\treg = 0;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD_1:\n\t\t\t\treg = 1;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD_2:\n\t\t\t\treg = 2;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD_3:\n\t\t\t\treg = 3;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD:\n\t\t\t\treg = getRegisterOperand();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak checkStore;\n\t\t\t}\n\t\t\tif (reg < parameterCount)\n\t\t\t\ttimesRead[reg]++;\n\t\t}\n\t\tif (thisOnTOS && !staticMethod) {\n\t\t\tswitch (seen) {\n\t\t\tcase ALOAD_1:\n\t\t\tcase ALOAD_2:\n\t\t\tcase ALOAD_3:\n\t\t\tcase ALOAD:\n\t\t\t\tif (reg < parameterCount) {\n\t\t\t\t\t//r = reg;\n\t\t\t\t\tdangerousToStoreIntoField = true;\n\t\t\t\t\t// System.out.println(\"Found dangerous value from parameter \" + reg);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t}\n\t\t} else if (staticMethod) {\n\t\t\tswitch (seen) {\n\t\t\tcase ALOAD_0:\n\t\t\tcase ALOAD_1:\n\t\t\tcase ALOAD_2:\n\t\t\tcase ALOAD_3:\n\t\t\tcase ALOAD:\n\t\t\t\tif (reg < parameterCount) {\n\t\t\t\t\t//r = reg;\n\t\t\t\t\tdangerousToStoreIntoField = true;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\n\t\tif (seen == ALOAD_0 && !staticMethod) {\n\t\t\tthisOnTOS = true;\n\t\t\tfieldOnTOS = false;\n\t\t\treturn;\n\t\t}\n\n\n\t\tif (thisOnTOS && seen == GETFIELD && getClassConstantOperand().equals(getClassName()) && !emptyArray.contains(getXFieldOperand())) {\n\t\t\tfieldOnTOS = true;\n\t\t\tthisOnTOS = false;\n\t\t\tnameOnStack = getNameConstantOperand();\n\t\t\tclassNameOnStack = getDottedClassConstantOperand();\n\t\t\tsigOnStack = getSigConstantOperand();\n\t\t\tfieldIsStatic = false;\n\t\t\t// System.out.println(\"Saw getfield\");\n\t\t\treturn;\n\t\t}\n\t\tif (seen == GETSTATIC && getClassConstantOperand().equals(getClassName()) && !emptyArray.contains(getXFieldOperand())) {\n\t\t\tfieldOnTOS = true;\n\t\t\tthisOnTOS = false;\n\t\t\tnameOnStack = getNameConstantOperand();\n\t\t\tclassNameOnStack = getDottedClassConstantOperand();\n\t\t\tsigOnStack = getSigConstantOperand();\n\t\t\tfieldIsStatic = true;\n\t\t\treturn;\n\t\t}\n\t\tthisOnTOS = false;\n\t\tif (check && fieldOnTOS && seen == ARETURN\n\t\t\t\t/*\n\t\t\t\t&& !sigOnStack.equals(\"Ljava/lang/String;\")\n\t\t\t\t&& sigOnStack.indexOf(\"Exception\") == -1\n\t\t\t\t&& sigOnStack.indexOf(\"[\") >= 0\n\t\t\t\t*/\n\t\t\t\t&& nameOnStack.indexOf(\"EMPTY\") == -1\n\t\t\t\t&& MutableStaticFields.mutableSignature(sigOnStack)\n\t\t) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, staticMethod ? \"MS_EXPOSE_REP\" : \"EI_EXPOSE_REP\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(classNameOnStack, nameOnStack, sigOnStack, fieldIsStatic)\n\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\n\t\tfieldOnTOS = false;\n\t\tthisOnTOS = false;\n\t}","id":30742,"modified_method":"@Override\n\t\t public void sawOpcode(int seen) {\n\t\t\n\t\tif (emptyArrayOnTOS && (seen == PUTFIELD || seen == PUTSTATIC)) {\n\t\t\tXField f = getXFieldOperand();\n\t\t\tif (f != null && f.isFinal())\n\t\t\t\temptyArray.add(f);\n\t\t\t\n\t\t\t\t\n\t\t}\n\t\temptyArrayOnTOS = (seen == ANEWARRAY || seen == NEWARRAY) && getPrevOpcode(1) == ICONST_0;\n\t\t\n\t\tif (!check) return;\n\t\t\n\t\tif (staticMethod && dangerousToStoreIntoField && seen == PUTSTATIC\n\t\t\t\t&& MutableStaticFields.mutableSignature(getSigConstantOperand())) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EI_EXPOSE_STATIC_REP2\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(),\n\t\t\t\t\t\t\ttrue)\n\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\t\tif (!staticMethod && dangerousToStoreIntoField && seen == PUTFIELD\n\t\t\t\t&& MutableStaticFields.mutableSignature(getSigConstantOperand())) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EI_EXPOSE_REP2\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(),\n\t\t\t\t\t\t\ttrue)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t/*\n\t\t\tSystem.out.println(\"Store of parameter \"\n\t\t\t\t\t+ r +\"/\" + parameterCount\n\t\t\t\t\t+ \" into field of type \" + sigConstant\n\t\t\t\t\t+ \" in \" + betterMethodName);\n\t\t\t\tbugReporter.reportBug(new BugInstance(\"EI_EXPOSE_REP2\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(betterClassConstant, nameConstant, betterSigConstant,\n\t\t\t\t\t\t\tfalse)\n\t\t\t\t\t.addSourceLine(this));\n\t\t`\t*/\n\t\t}\n\t\tdangerousToStoreIntoField = false;\n\t\tint reg = -1; // this value should never be seen\n\t\tcheckStore: {\n\t\t\tswitch (seen) {\n\t\t\tcase ALOAD_0:\n\t\t\t\treg = 0;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD_1:\n\t\t\t\treg = 1;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD_2:\n\t\t\t\treg = 2;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD_3:\n\t\t\t\treg = 3;\n\t\t\t\tbreak;\n\t\t\tcase ALOAD:\n\t\t\t\treg = getRegisterOperand();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak checkStore;\n\t\t\t}\n\t\t\tif (reg < parameterCount)\n\t\t\t\ttimesRead[reg]++;\n\t\t}\n\t\tif (thisOnTOS && !staticMethod) {\n\t\t\tswitch (seen) {\n\t\t\tcase ALOAD_1:\n\t\t\tcase ALOAD_2:\n\t\t\tcase ALOAD_3:\n\t\t\tcase ALOAD:\n\t\t\t\tif (reg < parameterCount) {\n\t\t\t\t\t//r = reg;\n\t\t\t\t\tdangerousToStoreIntoField = true;\n\t\t\t\t\t// System.out.println(\"Found dangerous value from parameter \" + reg);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t}\n\t\t} else if (staticMethod) {\n\t\t\tswitch (seen) {\n\t\t\tcase ALOAD_0:\n\t\t\tcase ALOAD_1:\n\t\t\tcase ALOAD_2:\n\t\t\tcase ALOAD_3:\n\t\t\tcase ALOAD:\n\t\t\t\tif (reg < parameterCount) {\n\t\t\t\t\t//r = reg;\n\t\t\t\t\tdangerousToStoreIntoField = true;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\n\t\tif (seen == ALOAD_0 && !staticMethod) {\n\t\t\tthisOnTOS = true;\n\t\t\tfieldOnTOS = false;\n\t\t\treturn;\n\t\t}\n\n\n\t\tif (thisOnTOS && seen == GETFIELD && getClassConstantOperand().equals(getClassName()) && !emptyArray.contains(getXFieldOperand())) {\n\t\t\tfieldOnTOS = true;\n\t\t\tthisOnTOS = false;\n\t\t\tnameOnStack = getNameConstantOperand();\n\t\t\tclassNameOnStack = getDottedClassConstantOperand();\n\t\t\tsigOnStack = getSigConstantOperand();\n\t\t\tfieldIsStatic = false;\n\t\t\t// System.out.println(\"Saw getfield\");\n\t\t\treturn;\n\t\t}\n\t\tif (seen == GETSTATIC && getClassConstantOperand().equals(getClassName()) && !emptyArray.contains(getXFieldOperand())) {\n\t\t\tfieldOnTOS = true;\n\t\t\tthisOnTOS = false;\n\t\t\tnameOnStack = getNameConstantOperand();\n\t\t\tclassNameOnStack = getDottedClassConstantOperand();\n\t\t\tsigOnStack = getSigConstantOperand();\n\t\t\tfieldIsStatic = true;\n\t\t\treturn;\n\t\t}\n\t\tthisOnTOS = false;\n\t\tif (check && fieldOnTOS && seen == ARETURN\n\t\t\t\t/*\n\t\t\t\t&& !sigOnStack.equals(\"Ljava/lang/String;\")\n\t\t\t\t&& sigOnStack.indexOf(\"Exception\") == -1\n\t\t\t\t&& sigOnStack.indexOf(\"[\") >= 0\n\t\t\t\t*/\n\t\t\t\t&& nameOnStack.indexOf(\"EMPTY\") == -1\n\t\t\t\t&& MutableStaticFields.mutableSignature(sigOnStack)\n\t\t) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, staticMethod ? \"MS_EXPOSE_REP\" : \"EI_EXPOSE_REP\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addField(classNameOnStack, nameOnStack, sigOnStack, fieldIsStatic)\n\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\n\t\tfieldOnTOS = false;\n\t\tthisOnTOS = false;\n\t}","commit_id":"4fe933fe976863887cafa083b7f54cdd6bf25aa3","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static void main(String args[]) {\n        Bug1744457 b = new Bug1744457();\n        // b.justFirst();\n        // b.justSecond();\n        b.both();\n    }","id":30743,"modified_method":"public static void main(String args[]) {\n        Bug1744457 b = new Bug1744457();\n        b.justFirst();\n        b.justSecond();\n        b.both();\n    }","commit_id":"a653cdf5b14dcf7d7b5ede712557222f4e915330","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void both() {\n        List A = new ArrayList();\n        A.add(\"Alex\");\n        A.add(\"john\");\n        A.add(\"lily\");\n        A.add(\"tracy\");\n        Iterator it = A.iterator();\n\n        while (it.hasNext()) {\n            String retrieve = (String) it.next();\n            if (retrieve != null && !retrieve.equals(\"\"))\n                System.out.println(retrieve);\n        }\n\n        it = A.iterator();\n        String add = \"\";\n        while (it.hasNext()) {\n            String retrieve = (String) it.next();\n            // FindBugs incorrectly misses ES_COMPARING_STRINGS_WITH_EQ\n            if (retrieve != null && retrieve != \"\")\n                // FindBugs correctly finds\n                // SBSC_USE_STRINGBUFFER_CONCATENATION\n                add += retrieve;\n            System.out.println(add);\n        }\n    }","id":30744,"modified_method":"@ExpectWarning(\"ES_COMPARING_STRINGS_WITH_EQ,SBSC_USE_STRINGBUFFER_CONCATENATION\")\n    public void both() {\n        List<String> A = new ArrayList<String>();\n        A.add(\"Alex\");\n        A.add(\"john\");\n        A.add(\"lily\");\n        A.add(\"tracy\");\n        Iterator<String> it = A.iterator();\n\n        while (it.hasNext()) {\n            String retrieve = it.next();\n            if (retrieve != null && !retrieve.equals(\"\"))\n                System.out.println(retrieve);\n        }\n\n        it = A.iterator();\n        String add = \"\";\n        while (it.hasNext()) {\n            String retrieve = it.next();\n            if (retrieve != null && retrieve != \"\")\n               add += retrieve;\n            System.out.println(add);\n        }\n    }","commit_id":"a653cdf5b14dcf7d7b5ede712557222f4e915330","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void handleStringComparison(JavaClass jclass, Method method, MethodGen methodGen,\n            RefComparisonTypeFrameModelingVisitor visitor, List<WarningWithProperties> stringComparisonList, Location location,\n            Type lhsType, Type rhsType) {\n        if (DEBUG) {\n            System.out.println(\"String/String comparison at \" + location.getHandle());\n        }\n\n        // Compute the priority:\n        // - two static strings => do not report\n        // - dynamic string and anything => high\n        // - static string and unknown => medium\n        // - all other cases => low\n        // System.out.println(\"Compare \" + lhsType + \" == \" + rhsType);\n        byte type1 = lhsType.getType();\n        byte type2 = rhsType.getType();\n\n        String bugPattern = \"ES_COMPARING_STRINGS_WITH_EQ\";\n        // T1 T2 result\n        // S S no-op\n        // D ? high\n        // ? D high\n        // S ? normal\n        // ? S normal\n        WarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n        if (type1 == T_STATIC_STRING && type2 == T_STATIC_STRING) {\n            propertySet.addProperty(RefComparisonWarningProperty.COMPARE_STATIC_STRINGS);\n        } else if (type1 == T_DYNAMIC_STRING || type2 == T_DYNAMIC_STRING) {\n            propertySet.addProperty(RefComparisonWarningProperty.DYNAMIC_AND_UNKNOWN);\n        } else if (type2 == T_PARAMETER_STRING || type1 == T_PARAMETER_STRING) {\n            bugPattern = \"ES_COMPARING_PARAMETER_STRING_WITH_EQ\";\n            if (methodGen.isPublic() || methodGen.isProtected()) {\n                propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER_IN_PUBLIC_METHOD);\n            } else {\n                propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER);\n            }\n        } else if (type1 == T_STATIC_STRING || type2 == T_STATIC_STRING) {\n            propertySet.addProperty(RefComparisonWarningProperty.STATIC_AND_UNKNOWN);\n        } else if (visitor.sawStringIntern()) {\n            propertySet.addProperty(RefComparisonWarningProperty.SAW_INTERN);\n        }\n\n        String sourceFile = jclass.getSourceFileName();\n        BugInstance instance = new BugInstance(this, bugPattern, BASE_ES_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                .addType(\"Ljava/lang/String;\").describe(TypeAnnotation.FOUND_ROLE).addSomeSourceForTopTwoStackValues(classContext, method, location);\n        SourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstruction(classContext, methodGen,\n                sourceFile, location.getHandle());\n        if (sourceLineAnnotation != null) {\n            WarningWithProperties warn = new WarningWithProperties(instance, propertySet, sourceLineAnnotation, location);\n            stringComparisonList.add(warn);\n        }\n\n    }","id":30745,"modified_method":"private void handleStringComparison(JavaClass jclass, Method method, MethodGen methodGen,\n            RefComparisonTypeFrameModelingVisitor visitor, List<WarningWithProperties> stringComparisonList, Location location,\n            Type lhsType, Type rhsType) {\n        if (DEBUG) {\n            System.out.println(\"String/String comparison at \" + location.getHandle());\n        }\n\n        // Compute the priority:\n        // - two static strings => do not report\n        // - dynamic string and anything => high\n        // - static string and unknown => medium\n        // - all other cases => low\n        // System.out.println(\"Compare \" + lhsType + \" == \" + rhsType);\n        byte type1 = lhsType.getType();\n        byte type2 = rhsType.getType();\n\n        String bugPattern = \"ES_COMPARING_STRINGS_WITH_EQ\";\n        // T1 T2 result\n        // S S no-op\n        // D ? high\n        // ? D high\n        // S ? normal\n        // ? S normal\n        WarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n        if (type1 == T_STATIC_STRING && type2 == T_STATIC_STRING) {\n            propertySet.addProperty(RefComparisonWarningProperty.COMPARE_STATIC_STRINGS);\n        } else if (type1 == T_DYNAMIC_STRING || type2 == T_DYNAMIC_STRING) {\n            propertySet.addProperty(RefComparisonWarningProperty.DYNAMIC_AND_UNKNOWN);\n        } else if (type2 == T_PARAMETER_STRING || type1 == T_PARAMETER_STRING) {\n            bugPattern = \"ES_COMPARING_PARAMETER_STRING_WITH_EQ\";\n            if (methodGen.isPublic() || methodGen.isProtected()) {\n                propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER_IN_PUBLIC_METHOD);\n            } else {\n                propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER);\n            }\n        } else if (type1 == T_STATIC_STRING || type2 == T_STATIC_STRING) {\n            if (lhsType instanceof EmptyStringType || rhsType instanceof EmptyStringType)\n                propertySet.addProperty(RefComparisonWarningProperty.EMPTY_AND_UNKNOWN);\n            else\n                propertySet.addProperty(RefComparisonWarningProperty.STATIC_AND_UNKNOWN);\n        } else if (visitor.sawStringIntern()) {\n            propertySet.addProperty(RefComparisonWarningProperty.SAW_INTERN);\n        }\n\n        String sourceFile = jclass.getSourceFileName();\n        BugInstance instance = new BugInstance(this, bugPattern, BASE_ES_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                .addType(\"Ljava/lang/String;\").describe(TypeAnnotation.FOUND_ROLE).addSomeSourceForTopTwoStackValues(classContext, method, location);\n        SourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstruction(classContext, methodGen,\n                sourceFile, location.getHandle());\n        if (sourceLineAnnotation != null) {\n            WarningWithProperties warn = new WarningWithProperties(instance, propertySet, sourceLineAnnotation, location);\n            stringComparisonList.add(warn);\n        }\n\n    }","commit_id":"a653cdf5b14dcf7d7b5ede712557222f4e915330","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n        public void visitLDC(LDC obj) {\n            Type type = obj.getType(getCPG());\n            pushValue(isString(type) ? staticStringTypeInstance : type);\n        }","id":30746,"modified_method":"@Override\n        public void visitLDC(LDC obj) {\n            Type type = obj.getType(getCPG());\n            if (isString(type)) {\n                Object value = obj.getValue(getCPG());\n                if (value instanceof String && ((String)value).isEmpty())\n                    pushValue( emptyStringTypeInstance);\n                else pushValue( staticStringTypeInstance);\n            }\n            else pushValue(type);\n        }","commit_id":"a653cdf5b14dcf7d7b5ede712557222f4e915330","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void handleLoad(FieldInstruction obj) {\n            consumeStack(obj);\n\n            Type type = obj.getType(getCPG());\n            if (!type.getSignature().equals(STRING_SIGNATURE))\n                throw new IllegalArgumentException(\"type is not String: \" + type);\n            try {\n                String className = obj.getClassName(getCPG());\n                String fieldName = obj.getName(getCPG());\n                Field field = Hierarchy.findField(className, fieldName);\n\n                if (field != null) {\n                    // If the field is final, we'll assume that the String value\n                    // is static.\n                    if (field.isFinal()) {\n                        pushValue(staticStringTypeInstance);\n                    } else {\n                        pushValue(type);\n                    }\n\n                    return;\n                }\n            } catch (ClassNotFoundException ex) {\n                lookupFailureCallback.reportMissingClass(ex);\n            }\n\n            pushValue(type);\n        }","id":30747,"modified_method":"private void handleLoad(FieldInstruction obj) {\n            consumeStack(obj);\n\n            Type type = obj.getType(getCPG());\n            if (!type.getSignature().equals(STRING_SIGNATURE))\n                throw new IllegalArgumentException(\"type is not String: \" + type);\n            try {\n                String className = obj.getClassName(getCPG());\n                String fieldName = obj.getName(getCPG());\n                Field field = Hierarchy.findField(className, fieldName);\n\n                if (field != null) {\n                    // If the field is final, we'll assume that the String value\n                    // is static.\n                    if (field.isFinal() && field.isFinal()) {\n                        pushValue(staticStringTypeInstance);\n                    } else {\n                        pushValue(type);\n                    }\n\n                    return;\n                }\n            } catch (ClassNotFoundException ex) {\n                lookupFailureCallback.reportMissingClass(ex);\n            }\n\n            pushValue(type);\n        }","commit_id":"a653cdf5b14dcf7d7b5ede712557222f4e915330","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName(); \n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n        InvokeInstruction inv = (InvokeInstruction) handle.getInstruction();\n        MethodAnnotation calledMethodAnnotation = getMethodCalledAnnotation(cpg, inv);\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 1;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull())\n                        bugAccumulator.accumulateBug(\n                                new BugInstance(this, \"EC_NULL_ARG\", priority).addClassAndMethod(methodGen, sourceFile),\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            comparedForEqualityInThisMethod.add(lhsType_.getSignature());\n            comparedForEqualityInThisMethod.add(rhsType_.getSignature());\n        }\n        \n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n       \n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (true) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n\n                int priority = result.getPriority() + priorityModifier;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", priority)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets)\n                                .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","id":30748,"modified_method":"private void checkEqualsComparison(Location location, JavaClass jclass, Method method, MethodGen methodGen,\n            ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n        InstructionHandle handle = location.getHandle();\n        InstructionHandle next = handle.getNext();\n        if (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n            INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n            if (is.getMethodName(cpg).equals(\"assertFalse\")) {\n                return;\n            }\n        }\n        String sourceFile = jclass.getSourceFileName(); \n\n        TypeFrame frame = typeDataflow.getFactAtLocation(location);\n        if (frame.getStackDepth() < 2) {\n            throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n        int numSlots = frame.getNumSlots();\n        Type lhsType_ = frame.getValue(numSlots - 2);\n        Type rhsType_ = frame.getValue(numSlots - 1);\n\n        // Ignore top and bottom values\n        if (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM || rhsType_.getType() == T_TOP\n                || rhsType_.getType() == T_BOTTOM) {\n            return;\n        }\n        InvokeInstruction inv = (InvokeInstruction) handle.getInstruction();\n        MethodAnnotation calledMethodAnnotation = getMethodCalledAnnotation(cpg, inv);\n        boolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n        int priorityModifier = 0;\n        if (looksLikeTestCase) {\n            priorityModifier = 1;\n        }\n\n        if (rhsType_.getType() == T_NULL) {\n            // A literal null value was passed directly to equals().\n            if (!looksLikeTestCase) {\n\n                try {\n                    IsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n                    IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n                    BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext, method, location);\n                    int priority = NORMAL_PRIORITY;\n                    if (a instanceof FieldAnnotation && ((FieldAnnotation) a).isStatic())\n                        priority = LOW_PRIORITY;\n                    if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull())\n                        bugAccumulator.accumulateBug(\n                                new BugInstance(this, \"EC_NULL_ARG\", priority).addClassAndMethod(methodGen, sourceFile),\n                                SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                        location.getHandle()));\n                } catch (CFGBuilderException e) {\n                    AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\n            }\n            return;\n        } else if (lhsType_.getType() == T_NULL) {\n            // Hmm...in this case, equals() is being invoked on\n            // a literal null value. This is really the\n            // purview of FindNullDeref. So, we'll just do nothing.\n            return;\n        } else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n            bugReporter.logError(\"equals() used to compare non-object type(s) \" + lhsType_ + \" and \" + rhsType_ + \" in \"\n                    + SignatureConverter.convertMethodSignature(methodGen) + \" at \" + location.getHandle());\n            return;\n        }\n        IncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\n        if (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n            String pattern = \"EC_BAD_ARRAY_COMPARE\";\n            IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n            if (result2.getPriority() <= Priorities.NORMAL_PRIORITY)\n                pattern = \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n            bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)\n                    .addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n        if (result.getPriority() >= Priorities.LOW_PRIORITY) {\n            addEqualsCheck(lhsType_.getSignature(), handle.getPosition());\n            addEqualsCheck(rhsType_.getSignature(), handle.getPosition());\n        }\n        \n        if (result == IncompatibleTypes.SEEMS_OK) return;\n\n       \n        if (result.getPriority() > Priorities.LOW_PRIORITY)\n            return;\n\n         if (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, new HashSet<XMethod>());\n            if (allOk)\n                priorityModifier += 2;\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n            String lhsSig = lhsType_.getSignature();\n            String rhsSig = rhsType_.getSignature();\n            boolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n            if (core) {\n                looksLikeTestCase = false;\n                priorityModifier = 0;\n            }\n            if (true) {\n                Set<XMethod> targets = new HashSet<XMethod>();\n                boolean allOk = checkForWeirdEquals(lhsSig, rhsSig, targets);\n                if (allOk)\n                    priorityModifier += 2;\n\n                int priority = result.getPriority() + priorityModifier;\n                bugAccumulator.accumulateBug(\n                        new BugInstance(this, \"EC_UNRELATED_TYPES\", priority)\n                                .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                                .addSomeSourceForTopTwoStackValues(classContext, method, location).addEqualsMethodUsed(targets)\n                                .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                        SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile,\n                                location.getHandle()));\n            }\n        } else if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n                || result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n            bugAccumulator.accumulateBug(\n                    new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n                            .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                            .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                            .addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature()))\n                            .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        } else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n            bugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n                    .addClassAndMethod(methodGen, sourceFile).addFoundAndExpectedType(rhsType_, lhsType_)\n                    .addSomeSourceForTopTwoStackValues(classContext, method, location)\n                    .addOptionalAnnotation(calledMethodAnnotation, MethodAnnotation.METHOD_CALLED),\n                    SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n        }\n\n    }","commit_id":"a653cdf5b14dcf7d7b5ede712557222f4e915330","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, final Method method) throws CFGBuilderException,\n            DataflowAnalysisException {\n\n        MethodGen methodGen = classContext.getMethodGen(method);\n        if (methodGen == null) {\n            return;\n        }\n\n        JavaClass jclass = classContext.getJavaClass();\n        ConstantPoolGen cpg = classContext.getConstantPoolGen();\n\n        // Enqueue all of the potential violations we find in the method.\n        // Normally we'll only report the first highest-priority warning,\n        // but if in relaxed mode or if REPORT_ALL_REF_COMPARISONS is set,\n        // then we'll report everything.\n        LinkedList<WarningWithProperties> refComparisonList = new LinkedList<WarningWithProperties>();\n        LinkedList<WarningWithProperties> stringComparisonList = new LinkedList<WarningWithProperties>();\n\n        comparedForEqualityInThisMethod = new HashSet<String>();\n        CFG cfg = classContext.getCFG(method);\n        DepthFirstSearch dfs = classContext.getDepthFirstSearch(method);\n        ExceptionSetFactory exceptionSetFactory = classContext.getExceptionSetFactory(method);\n\n        // Perform type analysis using our special type merger\n        // (which handles String types specially, keeping track of\n        // which ones appear to be dynamically created)\n        RefComparisonTypeMerger typeMerger = new RefComparisonTypeMerger(bugReporter, exceptionSetFactory);\n        RefComparisonTypeFrameModelingVisitor visitor = new RefComparisonTypeFrameModelingVisitor(methodGen.getConstantPool(),\n                typeMerger, bugReporter);\n        TypeAnalysis typeAnalysis = new SpecialTypeAnalysis(method, methodGen, cfg, dfs, typeMerger, visitor, bugReporter,\n                exceptionSetFactory);\n        TypeDataflow typeDataflow = new TypeDataflow(cfg, typeAnalysis);\n        Profiler profiler = Global.getAnalysisCache().getProfiler();\n        profiler.start(SpecialTypeAnalysis.class);\n        try {\n            typeDataflow.execute();\n        } finally {\n            profiler.end(SpecialTypeAnalysis.class);\n        }\n\n        // Inspect Locations in the method for suspicious ref comparisons and\n        // calls to equals()\n        for (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n            Location location = i.next();\n\n            inspectLocation(jclass, cpg, method, methodGen, refComparisonList, stringComparisonList, visitor, typeDataflow,\n                    location);\n        }\n\n        if (stringComparisonList.isEmpty() && refComparisonList.isEmpty()) {\n            return;\n        }\n        // Add method-wide properties to BugInstances\n        final boolean likelyTestcase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(jclass, method));\n\n        decorateWarnings(stringComparisonList, new WarningDecorator() {\n            public void decorate(WarningWithProperties warn) {\n                if (mightBeCheckedUsingEquals(warn.instance)) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.SAW_CALL_TO_EQUALS);\n                }\n\n                if (likelyTestcase) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.COMPARE_IN_TEST_CASE);\n                }\n\n                if (false && !(method.isPublic() || method.isProtected())) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.PRIVATE_METHOD);\n                }\n            }\n        });\n        decorateWarnings(refComparisonList, new WarningDecorator() {\n            public void decorate(WarningWithProperties warn) {\n                if (likelyTestcase) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.COMPARE_IN_TEST_CASE);\n                }\n\n                if (mightBeCheckedUsingEquals(warn.instance)) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.SAW_CALL_TO_EQUALS);\n                }\n            }\n        });\n\n        // Report violations\n        boolean relaxed = FindBugsAnalysisFeatures.isRelaxedMode();\n        reportBest(classContext, method, stringComparisonList, relaxed);\n        reportBest(classContext, method, refComparisonList, relaxed);\n    }","id":30749,"modified_method":"private void analyzeMethod(ClassContext classContext, final Method method) throws CFGBuilderException,\n            DataflowAnalysisException {\n\n        MethodGen methodGen = classContext.getMethodGen(method);\n        if (methodGen == null) {\n            return;\n        }\n\n        JavaClass jclass = classContext.getJavaClass();\n        ConstantPoolGen cpg = classContext.getConstantPoolGen();\n\n        // Enqueue all of the potential violations we find in the method.\n        // Normally we'll only report the first highest-priority warning,\n        // but if in relaxed mode or if REPORT_ALL_REF_COMPARISONS is set,\n        // then we'll report everything.\n        LinkedList<WarningWithProperties> refComparisonList = new LinkedList<WarningWithProperties>();\n        LinkedList<WarningWithProperties> stringComparisonList = new LinkedList<WarningWithProperties>();\n\n        \n        comparedForEqualityInThisMethod = new HashMap<String,Integer>();\n        CFG cfg = classContext.getCFG(method);\n        DepthFirstSearch dfs = classContext.getDepthFirstSearch(method);\n        ExceptionSetFactory exceptionSetFactory = classContext.getExceptionSetFactory(method);\n\n        // Perform type analysis using our special type merger\n        // (which handles String types specially, keeping track of\n        // which ones appear to be dynamically created)\n        RefComparisonTypeMerger typeMerger = new RefComparisonTypeMerger(bugReporter, exceptionSetFactory);\n        RefComparisonTypeFrameModelingVisitor visitor = new RefComparisonTypeFrameModelingVisitor(methodGen.getConstantPool(),\n                typeMerger, bugReporter);\n        TypeAnalysis typeAnalysis = new SpecialTypeAnalysis(method, methodGen, cfg, dfs, typeMerger, visitor, bugReporter,\n                exceptionSetFactory);\n        TypeDataflow typeDataflow = new TypeDataflow(cfg, typeAnalysis);\n        Profiler profiler = Global.getAnalysisCache().getProfiler();\n        profiler.start(SpecialTypeAnalysis.class);\n        try {\n            typeDataflow.execute();\n        } finally {\n            profiler.end(SpecialTypeAnalysis.class);\n        }\n\n        // Inspect Locations in the method for suspicious ref comparisons and\n        // calls to equals()\n        for (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n            Location location = i.next();\n\n            inspectLocation(jclass, cpg, method, methodGen, refComparisonList, stringComparisonList, visitor, typeDataflow,\n                    location);\n        }\n\n        if (stringComparisonList.isEmpty() && refComparisonList.isEmpty()) {\n            return;\n        }\n        // Add method-wide properties to BugInstances\n        final boolean likelyTestcase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(jclass, method));\n\n        decorateWarnings(stringComparisonList, new WarningDecorator() {\n            public void decorate(WarningWithProperties warn) {\n                if (mightBeLaterCheckedUsingEquals(warn)) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.SAW_CALL_TO_EQUALS);\n                }\n\n                if (likelyTestcase) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.COMPARE_IN_TEST_CASE);\n                }\n\n                if (false && !(method.isPublic() || method.isProtected())) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.PRIVATE_METHOD);\n                }\n            }\n        });\n        decorateWarnings(refComparisonList, new WarningDecorator() {\n            public void decorate(WarningWithProperties warn) {\n                if (likelyTestcase) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.COMPARE_IN_TEST_CASE);\n                }\n\n                if (mightBeLaterCheckedUsingEquals(warn)) {\n                    warn.propertySet.addProperty(RefComparisonWarningProperty.SAW_CALL_TO_EQUALS);\n                }\n            }\n        });\n\n        // Report violations\n        boolean relaxed = FindBugsAnalysisFeatures.isRelaxedMode();\n        reportBest(classContext, method, stringComparisonList, relaxed);\n        reportBest(classContext, method, refComparisonList, relaxed);\n    }","commit_id":"a653cdf5b14dcf7d7b5ede712557222f4e915330","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int opcode) {\n\t\tif (opcode == PUTFIELD) {\n\t\t\tXField f = getXFieldOperand();\n\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\tif (item.getRegisterNumber() != 0)\n\t\t\t\treturn;\n\t\t\tinitializedFields.add(f);\n\t\t\treturn;\n\t\t}\n\t\tif (opcode != GETFIELD)\n\t\t\treturn;\n\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\tif (item.getRegisterNumber() != 0)\n\t\t\treturn;\n\t\tXField f = getXFieldOperand();\n\t\t\n\t\tif (f == null || !f.getClassDescriptor().equals(getClassDescriptor()))\n\t\t\treturn;\n\t\tif (f.isSynthetic() || f.getName().startsWith(\"this$\"))\n\t\t\treturn;\n\t\tif (initializedFields.contains(f))\n\t\t\treturn;\n\t\tFieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n\n\t\tSet<XMethod> calledFrom = fieldSummary.getCalledFromSuperConstructor(DescriptorFactory\n\t\t        .createClassDescriptor(getSuperclassName()), getXMethod());\n\t\tif (calledFrom.isEmpty())\n\t\t\treturn;\n\t\tUnreadFields unreadFields = AnalysisContext.currentAnalysisContext().getUnreadFields();\n\t\t\n\t\tint priority;\n\t\tif (!unreadFields.isWrittenInConstructor(f))\n\t\t\treturn;\n\t\t\n\t\tif (f.isFinal() || !unreadFields.isWrittenOutsideOfConstructor(f))\n\t\t\tpriority = HIGH_PRIORITY;\n\t\telse {\n\t\t\tpriority = NORMAL_PRIORITY;\n\t\t}\n\t\tint nextOpcode = getNextOpcode();\n\t\tif (nextOpcode == IFNULL || nextOpcode == IFNONNULL)\n\t\t\tpriority++;\n\t\tBugInstance bug = new BugInstance(this, \"UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR\", priority).addClassAndMethod(this).addField(f);\n\t\t\n\t\tfor (XMethod m : calledFrom) \n\t\t\tbug.addMethod(m).describe(MethodAnnotation.METHOD_CALLED_FROM);\n\n\t\taccumulator.accumulateBug(bug, this);\n\t\t\n\n\t}","id":30750,"modified_method":"@Override\n\tpublic void sawOpcode(int opcode) {\n\t\tif (opcode == PUTFIELD) {\n\t\t\tXField f = getXFieldOperand();\n\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\tif (item.getRegisterNumber() != 0)\n\t\t\t\treturn;\n\t\t\tinitializedFields.add(f);\n\t\t\treturn;\n\t\t}\n\t\tif (opcode != GETFIELD)\n\t\t\treturn;\n\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\tif (item.getRegisterNumber() != 0)\n\t\t\treturn;\n\t\tXField f = getXFieldOperand();\n\t\t\n\t\tif (f == null || !f.getClassDescriptor().equals(getClassDescriptor()))\n\t\t\treturn;\n\t\tif (f.isSynthetic() || f.getName().startsWith(\"this$\"))\n\t\t\treturn;\n\t\tif (initializedFields.contains(f))\n\t\t\treturn;\n\t\tFieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n\n\t\tSet<XMethod> calledFrom = fieldSummary.getCalledFromSuperConstructor(DescriptorFactory\n\t\t        .createClassDescriptor(getSuperclassName()), getXMethod());\n\t\tif (calledFrom.isEmpty())\n\t\t\treturn;\n\t\tUnreadFields unreadFields = AnalysisContext.currentAnalysisContext().getUnreadFields();\n\t\t\n\t\tint priority;\n\t\tif (!unreadFields.isWrittenInConstructor(f))\n\t\t\treturn;\n\t\t\n\t\tif (f.isFinal())\n\t\t\tpriority = HIGH_PRIORITY;\n\t\telse if (unreadFields.isWrittenDuringInitialization(f) || unreadFields.isWrittenOutsideOfInitialization(f) )\n\t\t\tpriority = NORMAL_PRIORITY;\n\t\telse\n\t\t\tpriority = HIGH_PRIORITY;\n\t\t\n\t\tint nextOpcode = getNextOpcode();\n\t\tif (nullCheckedFields.contains(f) || nextOpcode == IFNULL || nextOpcode == IFNONNULL) {\n\t\t\tpriority++;\n\t\t\tnullCheckedFields.add(f);\n\t\t}\n\t\tBugInstance bug = new BugInstance(this, \"UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR\", priority).addClassAndMethod(this).addField(f);\n\t\t\n\t\tfor (XMethod m : calledFrom) \n\t\t\tbug.addMethod(m).describe(MethodAnnotation.METHOD_CALLED_FROM);\n\n\t\taccumulator.accumulateBug(bug, this);\n\t\t\n\n\t}","commit_id":"06980698707359c94a26943e6f24fe991981d85d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Code obj) {\n\t\tif (getMethod().isStatic())\n\t\t\treturn;\n\t\tinitializedFields = new HashSet<XField>();\n\t\tsuper.visit(obj);\n\t\taccumulator.reportAccumulatedBugs();\n\t}","id":30751,"modified_method":"public void visit(Code obj) {\n\t\tif (getMethod().isStatic())\n\t\t\treturn;\n\t\tinitializedFields = new HashSet<XField>();\n\t\tnullCheckedFields = new HashSet<XField>();\n\t\tsuper.visit(obj);\n\t\taccumulator.reportAccumulatedBugs();\n\t}","commit_id":"06980698707359c94a26943e6f24fe991981d85d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public AzorsElocutors(UUID ownerId) {\r\n        super(ownerId, 210, \"Azor's Elocutors\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{3}{W/U}{W/U}\");\r\n        this.expansionSetCode = \"RTR\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Advisor\");\r\n        this.color.setWhite(true);\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(5);\r\n\r\n        // At the beginning of your upkeep, put a filibuster counter on Azor's Elocutors. Then if Azor's Elocutors has five or more filibuster counters on it, you win the game.\r\n        this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(new Counter(\"filibuster\",1)), TargetController.YOU, false));\r\n\r\n        // Whenever a source deals damage to you, remove a filibuster counter from Azor's Elocutors.\r\n        this.addAbility(new AzorsElocutorsTriggeredAbility());\r\n\r\n    }","id":30752,"modified_method":"public AzorsElocutors(UUID ownerId) {\r\n        super(ownerId, 210, \"Azor's Elocutors\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{3}{W/U}{W/U}\");\r\n        this.expansionSetCode = \"RTR\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Advisor\");\r\n        this.color.setWhite(true);\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(5);\r\n\r\n        // At the beginning of your upkeep, put a filibuster counter on Azor's Elocutors. Then if Azor's Elocutors has five or more filibuster counters on it, you win the game.\r\n        this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new AzorsElocutorsEffect(), TargetController.YOU, false));\r\n\r\n        // Whenever a source deals damage to you, remove a filibuster counter from Azor's Elocutors.\r\n        this.addAbility(new AzorsElocutorsTriggeredAbility());\r\n\r\n    }","commit_id":"3c49bdb4b3bcf69f75b909d918cc07d3e7cd4d49","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n        if(permanent != null)\r\n        {\r\n            for(UUID uuid : permanent.getAttachments())\r\n            {\r\n                Permanent aura = game.getPermanent(uuid);\r\n                if(aura != null && aura.getSubtype().contains(\"Aura\"))\r\n                {\r\n                    permanent.destroy(source.getSourceId(), game, false);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":30753,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n        if(permanent != null)\r\n        {\r\n            LinkedList<UUID> attachments = new LinkedList();\r\n            attachments.addAll(permanent.getAttachments());\r\n            for(UUID uuid : attachments)\r\n            {\r\n                Permanent aura = game.getPermanent(uuid);\r\n                if(aura != null && aura.getSubtype().contains(\"Aura\"))\r\n                {\r\n                    aura.destroy(source.getSourceId(), game, false);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"3c49bdb4b3bcf69f75b909d918cc07d3e7cd4d49","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\n        if(permanent != null)\n        {\n            for(UUID uuid : permanent.getAttachments())\n            {\n                Permanent aura = game.getPermanent(uuid);\n                if(aura != null && aura.getSubtype().contains(\"Aura\"))\n                {\n                    permanent.destroy(source.getId(), game, false);\n                }\n            }\n        }\n        return false;\n    }","id":30754,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\n        if(permanent != null)\n        {\n            LinkedList<UUID> attachments = new LinkedList();\n            attachments.addAll(permanent.getAttachments());\n            for(UUID uuid : attachments)\n            {\n                Permanent aura = game.getPermanent(uuid);\n                if(aura != null && aura.getSubtype().contains(\"Aura\"))\n                {\n                    aura.destroy(source.getId(), game, false);\n                }\n            }\n        }\n        return false;\n    }","commit_id":"3c49bdb4b3bcf69f75b909d918cc07d3e7cd4d49","url":"https://github.com/magefree/mage"},{"original_method":"private void sendViaClient(final MessageContext context, final OutMessage message) throws Exception\n    {\n        MuleClient client = new MuleClient();\n        OutputHandler handler = new OutputHandler() {\n            public void write(UMOEvent event, OutputStream out) throws IOException\n            {\n                try {\n                    Attachments atts = message.getAttachments();\n                    if (atts != null && atts.size() > 0) {\n                        atts.write(out);\n                    }\n                    else {\n                        XMLStreamWriter writer = STAXUtils.createXMLStreamWriter(out, message\n                                .getEncoding(), context);\n                        message.getSerializer().writeMessage(message, writer, context);\n                        try {\n                            writer.flush();\n                        }\n                        catch (XMLStreamException e) {\n                            logger.error(e);\n                            throw new XFireException(\"Couldn't send message.\", e);\n                        }\n                    }\n                }\n                catch (XFireException e) {\n                    logger.error(\"Couldn't send message.\", e);\n                    throw new IOException(e.getMessage());\n                }\n            }\n\n            public Map getHeaders(UMOEvent event) {\n                Map headers = new HashMap();\n                headers.put(HttpConstants.HEADER_CONTENT_TYPE, getSoapMimeType(message));\n                headers.put(SoapConstants.SOAP_ACTION, message.getProperty(SoapConstants.SOAP_ACTION));\n                for (Iterator iterator = event.getMessage().getPropertyNames().iterator(); iterator.hasNext();) {\n                    String headerName = (String)iterator.next();\n                    Object headerValue = event.getMessage().getStringProperty(headerName, null);\n                    \n                    //let us filter only MULE properties except MULE_USER, Content-Type and Content-Lenght, \n                    // and all other properties are allowed through including custom headers\n                    if ((!headerName.startsWith(MuleProperties.PROPERTY_PREFIX) || (MuleProperties.MULE_USER_PROPERTY.compareTo(headerName) == 0))\n                        && (!HttpConstants.HEADER_CONTENT_TYPE.equalsIgnoreCase(headerName)) && (!HttpConstants.HEADER_CONTENT_LENGTH.equalsIgnoreCase(headerName))) {\n                            headers.put(headerName, headerValue);\n                    }\n                }\n                \n                return headers;\n            }\n        };\n\n        //We can create a generic StreamMessageAdapter here as the underlying transport will create one specific to the transport\n        UMOStreamMessageAdapter sp = new StreamMessageAdapter(handler);\n        sp.setProperty(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_POST);\n        \n       \n        //set all properties on the message adapter\n        UMOMessage msg = RequestContext.getEvent().getMessage();\n        for (Iterator i = msg.getPropertyNames().iterator();i.hasNext();)\n        {\n             String propertyName = (String)i.next();\n             sp.setProperty(propertyName, msg.getProperty(propertyName));\n        }\n\n        UMOStreamMessageAdapter result = client.sendStream(getUri(), sp);\n\n        if (result!=null) {\n            InMessage inMessage;\n            String ct = sp.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, \"text/xml\");\n            InputStream in = result.getInputStream();\n            if (ct.toLowerCase().indexOf(\"multipart/related\") != -1) {\n                try {\n                    Attachments atts = new JavaMailAttachments(in, ct);\n                    InputStream msgIs = atts.getSoapMessage().getDataHandler().getInputStream();\n                    inMessage = new InMessage(STAXUtils.createXMLStreamReader(msgIs, message\n                            .getEncoding(), context), getUri());\n                    inMessage.setAttachments(atts);\n                }\n                catch (MessagingException e) {\n                    throw new IOException(e.getMessage());\n                }\n            }\n            else {\n                inMessage = new InMessage(STAXUtils.createXMLStreamReader(in, message.getEncoding(), context),\n                        getUri());\n            }\n            getEndpoint().onReceive(context, inMessage);\n        }\n        sp.release();\n        result.release();\n\n    }","id":30755,"modified_method":"private void sendViaClient(final MessageContext context, final OutMessage message) throws Exception\n    {\n        MuleClient client = new MuleClient();\n        OutputHandler handler = new OutputHandler()\n        {\n            public void write(UMOEvent event, OutputStream out) throws IOException\n            {\n                try\n                {\n                    Attachments atts = message.getAttachments();\n                    if (atts != null && atts.size() > 0)\n                    {\n                        atts.write(out);\n                    }\n                    else\n                    {\n                        XMLStreamWriter writer = STAXUtils.createXMLStreamWriter(out, message.getEncoding(),\n                            context);\n                        message.getSerializer().writeMessage(message, writer, context);\n                        try\n                        {\n                            writer.flush();\n                        }\n                        catch (XMLStreamException e)\n                        {\n                            logger.error(e);\n                            throw new XFireException(\"Couldn't send message.\", e);\n                        }\n                    }\n                }\n                catch (XFireException e)\n                {\n                    logger.error(\"Couldn't send message.\", e);\n                    throw new IOException(e.getMessage());\n                }\n            }\n\n            public Map getHeaders(UMOEvent event)\n            {\n                Map headers = new HashMap();\n                headers.put(HttpConstants.HEADER_CONTENT_TYPE, getSoapMimeType(message));\n                headers.put(SoapConstants.SOAP_ACTION, message.getProperty(SoapConstants.SOAP_ACTION));\n                UMOMessage msg = event.getMessage();\n                for (Iterator iterator = msg.getPropertyNames().iterator(); iterator.hasNext();)\n                {\n                    String headerName = (String)iterator.next();\n                    Object headerValue = msg.getStringProperty(headerName, null);\n\n                    // let us filter only MULE properties except MULE_USER,\n                    // Content-Type and Content-Lenght; all other properties are\n                    // allowed through including custom headers\n                    if ((!headerName.startsWith(MuleProperties.PROPERTY_PREFIX) || (MuleProperties.MULE_USER_PROPERTY.compareTo(headerName) == 0))\n                        && (!HttpConstants.HEADER_CONTENT_TYPE.equalsIgnoreCase(headerName))\n                        && (!HttpConstants.HEADER_CONTENT_LENGTH.equalsIgnoreCase(headerName)))\n                    {\n                        headers.put(headerName, headerValue);\n                    }\n                }\n\n                return headers;\n            }\n        };\n\n        // We can create a generic StreamMessageAdapter here as the underlying\n        // transport will create one specific to the transport\n        UMOStreamMessageAdapter sp = new StreamMessageAdapter(handler);\n        sp.setProperty(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_POST);\n\n        // set all properties on the message adapter\n        UMOMessage msg = RequestContext.getEvent().getMessage();\n        for (Iterator i = msg.getPropertyNames().iterator(); i.hasNext();)\n        {\n            String propertyName = (String)i.next();\n            sp.setProperty(propertyName, msg.getProperty(propertyName));\n        }\n\n        UMOStreamMessageAdapter result = null;\n\n        try\n        {\n            result = client.sendStream(getUri(), sp);\n            if (result != null)\n            {\n                InMessage inMessage;\n                String contentType = sp.getStringProperty(HttpConstants.HEADER_CONTENT_TYPE, \"text/xml\");\n                InputStream in = result.getInputStream();\n                if (contentType.toLowerCase().indexOf(\"multipart/related\") != -1)\n                {\n                    try\n                    {\n                        Attachments atts = new JavaMailAttachments(in, contentType);\n                        InputStream msgIs = atts.getSoapMessage().getDataHandler().getInputStream();\n                        inMessage = new InMessage(STAXUtils.createXMLStreamReader(msgIs,\n                            message.getEncoding(), context), getUri());\n                        inMessage.setAttachments(atts);\n                    }\n                    catch (MessagingException e)\n                    {\n                        throw new IOException(e.getMessage());\n                    }\n                }\n                else\n                {\n                    inMessage = new InMessage(STAXUtils.createXMLStreamReader(in, message.getEncoding(),\n                        context), getUri());\n                }\n                getEndpoint().onReceive(context, inMessage);\n            }\n        }\n        finally\n        {\n            sp.release();\n            if (result != null)\n            {\n                result.release();\n            }\n        }\n    }","commit_id":"f9d13d4f668e210937190683e520b17bc8f275cb","url":"https://github.com/mulesoft/mule"},{"original_method":"String getMimeType(AbstractMessage msg)\n    {\n        if (msg.getAttachments() != null && msg.getAttachments().size() > 0) {\n            return msg.getAttachments().getContentType();\n        }\n        else {\n            return getSoapMimeType(msg);\n        }\n    }","id":30756,"modified_method":"String getMimeType(AbstractMessage msg)\n    {\n        Attachments atts = msg.getAttachments();\n\n        if (atts != null && atts.size() > 0)\n        {\n            return atts.getContentType();\n        }\n        else\n        {\n            return getSoapMimeType(msg);\n        }\n    }","commit_id":"f9d13d4f668e210937190683e520b17bc8f275cb","url":"https://github.com/mulesoft/mule"},{"original_method":"static String getSoapMimeType(AbstractMessage msg)\n    {\n        SoapVersion soap = msg.getSoapVersion();\n        if (soap instanceof Soap11) {\n            return \"text/xml; charset=\" + msg.getEncoding();\n        }\n        else if (soap instanceof Soap12) {\n            return \"application/soap+xml; charset=\" + msg.getEncoding();\n        }\n        else {\n            return \"text/xml; charset=\" + msg.getEncoding();\n        }\n    }","id":30757,"modified_method":"static String getSoapMimeType(AbstractMessage msg)\n    {\n        SoapVersion soap = msg.getSoapVersion();\n        String encoding = msg.getEncoding();\n        StringBuffer soapMimeType = new StringBuffer(40);\n\n        if (soap instanceof Soap12)\n        {\n            soapMimeType.append(\"application/soap+xml; charset=\");\n        }\n        else\n        {\n            // SOAP 1.1 & default\n            soapMimeType.append(\"text/xml; charset=\");\n        }\n\n        return soapMimeType.append(encoding).toString();\n    }","commit_id":"f9d13d4f668e210937190683e520b17bc8f275cb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testAddAdSense() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Google Adsense Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Google Adsense Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Configuration\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_adClient\", RuntimeVariables.replace(\"pub-0000000000\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_adChannel\", RuntimeVariables.replace(\"12345678\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"_86_adType\", RuntimeVariables.replace(\"label=Text\"));\n\t\tselenium.select(\"_86_adFormat\",\n\t\t\tRuntimeVariables.replace(\"label=(728 x 90) - Leaderboard\"));\n\t\tselenium.type(\"_86_colorBorder\", RuntimeVariables.replace(\"FFFFFF\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorBg\", RuntimeVariables.replace(\"0000FF\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorLink\", RuntimeVariables.replace(\"FFFFFF\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorText\", RuntimeVariables.replace(\"000000\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorUrl\", RuntimeVariables.replace(\"008000\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\t}","id":30758,"modified_method":"public void testAddAdSense() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Google Adsense Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Google Adsense Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"_86_adClient\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_adClient\", RuntimeVariables.replace(\"pub-0000000000\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_adChannel\", RuntimeVariables.replace(\"12345678\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"_86_adType\", RuntimeVariables.replace(\"label=Text\"));\n\t\tselenium.select(\"_86_adFormat\",\n\t\t\tRuntimeVariables.replace(\"label=(728 x 90) - Leaderboard\"));\n\t\tselenium.type(\"_86_colorBorder\", RuntimeVariables.replace(\"FFFFFF\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorBg\", RuntimeVariables.replace(\"0000FF\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorLink\", RuntimeVariables.replace(\"FFFFFF\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorText\", RuntimeVariables.replace(\"000000\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_colorUrl\", RuntimeVariables.replace(\"008000\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\", RuntimeVariables.replace(\"\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\n\t\t\t\t\t\t\t\"You have successfully updated the setup.\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='portlet-msg-success']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddDraftEntry() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Blogs\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Add Blog Entry']\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_33_title\", RuntimeVariables.replace(\"Draft Test\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"_33_editor\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"_33_editor\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"cke_contents_CKEditor1\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\"//iframe[@id='_33_editor']\");\n\t\tselenium.selectFrame(\"//td[@id='cke_contents_CKEditor1']/iframe\");\n\t\tselenium.type(\"//body\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"This is a test for the emergency draft system.\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(15000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isTextPresent(\"Draft saved\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isTextPresent(\"Draft saved\"));\n\t\tselenium.clickAt(\"link=Blogs\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//form/div[2]/div[1]/div[1]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Draft\"), selenium.getText(\"//h3\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Draft Test\"),\n\t\t\tselenium.getText(\"//form/div[2]/div[1]/div[1]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"This is a test for the emergency draft system.\"),\n\t\t\tselenium.getText(\"//p\"));\n\t}","id":30759,"modified_method":"public void testAddDraftEntry() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Blogs\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Add Blog Entry']\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_33_title\", RuntimeVariables.replace(\"Draft Test\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"_33_editor\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"_33_editor\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"cke_contents_CKEditor1\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\"//iframe[@id='_33_editor']\");\n\t\tselenium.selectFrame(\"//td[@id='cke_contents_CKEditor1']/iframe\");\n\t\tselenium.type(\"//body\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"This is a test for the emergency draft system.\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(15000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isTextPresent(\"Saving draft...\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isTextPresent(\"Saving draft...\"));\n\t\tselenium.clickAt(\"link=Blogs\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//form/div[2]/div[1]/div[1]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Draft\"), selenium.getText(\"//h3\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Draft Test\"),\n\t\t\tselenium.getText(\"//form/div[2]/div[1]/div[1]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"This is a test for the emergency draft system.\"),\n\t\t\tselenium.getText(\"//p\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddGoogleMap() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Google Maps Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Configuration\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_license\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"ABQIAAAA3nrHjKy73DtxJL8D67iR6hSqd3WNkXftHeaSLroSolGIoU-u5BTriDnzHVQc9TudabxQnFqk-gNe8A\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_mapAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_directionsAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\t}","id":30760,"modified_method":"public void testAddGoogleMap() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Google Maps Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"_86_license\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_license\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"ABQIAAAA3nrHjKy73DtxJL8D67iR6hSqd3WNkXftHeaSLroSolGIoU-u5BTriDnzHVQc9TudabxQnFqk-gNe8A\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_mapAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_directionsAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddGoogleMapWithDirections() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"link=Google Maps Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Configuration\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"_86_license\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"ABQIAAAA3nrHjKy73DtxJL8D67iR6hSqd3WNkXftHeaSLroSolGIoU-u5BTriDnzHVQc9TudabxQnFqk-gNe8A\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"_86_mapAddress\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"17730 Antonio Ave, Cerritos, CA, 90703\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"_86_directionsAddress\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"11947 Del Amo Blvd, Cerritos, CA, 90703\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean DirectionChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\t\tif (DirectionChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\tcase 2:\n\t\t\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":30761,"modified_method":"public void testAddGoogleMapWithDirections() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"link=Google Maps Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\t\t\tselenium.click(\n\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"_86_license\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"_86_license\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"ABQIAAAA3nrHjKy73DtxJL8D67iR6hSqd3WNkXftHeaSLroSolGIoU-u5BTriDnzHVQc9TudabxQnFqk-gNe8A\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"_86_mapAddress\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"17730 Antonio Ave, Cerritos, CA, 90703\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"_86_directionsAddress\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"11947 Del Amo Blvd, Cerritos, CA, 90703\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean DirectionChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\t\tif (DirectionChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\tcase 2:\n\t\t\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddGoogleMapWithMap() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Google Maps Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Configuration\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_license\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"ABQIAAAA3nrHjKy73DtxJL8D67iR6hSqd3WNkXftHeaSLroSolGIoU-u5BTriDnzHVQc9TudabxQnFqk-gNe8A\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_mapAddress\",\n\t\t\tRuntimeVariables.replace(\"17730 Antonio Ave, Cerritos, CA, 90703\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_directionsAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\t}","id":30762,"modified_method":"public void testAddGoogleMapWithMap() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Google Maps Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"_86_license\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_license\",\n\t\t\tRuntimeVariables.replace(\n\t\t\t\t\"ABQIAAAA3nrHjKy73DtxJL8D67iR6hSqd3WNkXftHeaSLroSolGIoU-u5BTriDnzHVQc9TudabxQnFqk-gNe8A\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_mapAddress\",\n\t\t\tRuntimeVariables.replace(\"17730 Antonio Ave, Cerritos, CA, 90703\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_86_directionsAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletKBLDuplicate() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Knowledge Base Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Knowledge Base Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"_145_addApplication\", RuntimeVariables.replace(\"\"));\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"layout_configuration_content\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.typeKeys(\"layout_configuration_content\",\n\t\t\tRuntimeVariables.replace(\"k\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@title='Knowledge Base List']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isVisible(\n\t\t\t\t\"//div[@title='Knowledge Base List']/p/a\"));\n\t}","id":30763,"modified_method":"public void testAddPortletKBLDuplicate() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Knowledge Base Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Knowledge Base Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"_145_addApplication\", RuntimeVariables.replace(\"\"));\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"layout_configuration_content\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.typeKeys(\"layout_configuration_content\",\n\t\t\tRuntimeVariables.replace(\"k\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//div[@title='Knowledge Base List']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isVisible(\n\t\t\t\t\"//div[@title='Knowledge Base List']/p/a\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletKBSDuplicate() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Knowledge Base Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Knowledge Base Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"_145_addApplication\", RuntimeVariables.replace(\"\"));\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"layout_configuration_content\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.typeKeys(\"layout_configuration_content\",\n\t\t\tRuntimeVariables.replace(\"k\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@title='Knowledge Base Search']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isVisible(\n\t\t\t\t\"//div[@title='Knowledge Base Search']/p/a\"));\n\t}","id":30764,"modified_method":"public void testAddPortletKBSDuplicate() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Knowledge Base Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Knowledge Base Test Page\",\n\t\t\tRuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"_145_addApplication\", RuntimeVariables.replace(\"\"));\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"layout_configuration_content\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.typeKeys(\"layout_configuration_content\",\n\t\t\tRuntimeVariables.replace(\"k\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//div[@title='Knowledge Base Search']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isVisible(\n\t\t\t\t\"//div[@title='Knowledge Base Search']/p/a\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddUserEmailAddressInvalid() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Users\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Users\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Add\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_screenName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_emailAddress\",\n\t\t\tRuntimeVariables.replace(\"testAseleniumcom\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_firstName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_lastName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have entered invalid data. Please try again.\"),\n\t\t\tselenium.getText(\"//section/div/div/div/div[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Please enter a valid email address.\"),\n\t\t\tselenium.getText(\"//fieldset[1]/div/div\"));\n\t}","id":30765,"modified_method":"public void testAddUserEmailAddressInvalid() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Users\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Users\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Add\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_screenName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_emailAddress\",\n\t\t\tRuntimeVariables.replace(\"testAseleniumcom\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_firstName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_lastName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have entered invalid data. Please try again.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-error']\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Please enter a valid email address.\"),\n\t\t\tselenium.getText(\"xPath=(//div[@class='portlet-msg-error'])[2]\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddUserEmailAddressNull() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Users\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Users\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Add\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_screenName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_emailAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_firstName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_lastName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have entered invalid data. Please try again.\"),\n\t\t\tselenium.getText(\"//section/div/div/div/div[1]\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Please enter a valid email address.\"),\n\t\t\tselenium.getText(\"//fieldset[1]/div/div\"));\n\t}","id":30766,"modified_method":"public void testAddUserEmailAddressNull() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Users\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Users\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Add\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_screenName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_emailAddress\", RuntimeVariables.replace(\"\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_firstName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"_125_lastName\", RuntimeVariables.replace(\"testA\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\", RuntimeVariables.replace(\"\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have entered invalid data. Please try again.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-error']\"));\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Please enter a valid email address.\"),\n\t\t\tselenium.getText(\"xPath=(//div[@class='portlet-msg-error'])[2]\"));\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testDisableInput() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"link=Google Maps Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Configuration\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MapChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_mapInputEnabledCheckbox\");\n\n\t\t\t\tif (!MapChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_mapInputEnabledCheckbox\");\n\n\t\t\tcase 2:\n\t\t\t\tThread.sleep(500);\n\n\t\t\t\tboolean DirectionChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\t\tif (!DirectionChecked) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":30767,"modified_method":"public void testDisableInput() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"link=Google Maps Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\t\t\tselenium.click(\n\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"_86_mapInputEnabledCheckbox\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MapChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_mapInputEnabledCheckbox\");\n\n\t\t\t\tif (!MapChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_mapInputEnabledCheckbox\");\n\n\t\t\tcase 2:\n\t\t\t\tThread.sleep(500);\n\n\t\t\t\tboolean DirectionChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\t\tif (!DirectionChecked) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testEnableInput() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"link=Google Maps Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Configuration\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MapChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_mapInputEnabledCheckbox\");\n\n\t\t\t\tif (MapChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_mapInputEnabledCheckbox\");\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean DirectionChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\t\tif (DirectionChecked) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":30768,"modified_method":"public void testEnableInput() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"link=Google Maps Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Google Maps Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\t\t\tselenium.click(\n\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"_86_mapInputEnabledCheckbox\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MapChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_mapInputEnabledCheckbox\");\n\n\t\t\t\tif (MapChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_mapInputEnabledCheckbox\");\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean DirectionChecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\t\tif (DirectionChecked) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.click(\"_86_directionsInputEnabledCheckbox\");\n\n\t\t\tcase 3:\n\t\t\t\tselenium.clickAt(\"//form/input[2]\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@id='p_p_id_86_']/div/div\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"858c86a0cc977f6927b43f7f6eb89396966b7805","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddNewWCWebContentAPActions() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Web Content\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_15_title']\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\n\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\");\n\t\tselenium.type(\"//body\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Content\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Name\"),\n\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Content\"),\n\t\t\tselenium.getText(\"//div[@class='asset-summary']\"));\n\t}","id":30769,"modified_method":"public void testAddNewWCWebContentAPActions() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Basic Web Content\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\",\n\t\t\tRuntimeVariables.replace(\"Basic Web Content\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_15_title_en_US']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_15_title_en_US']\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Title\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\n\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\");\n\t\tselenium.type(\"//body\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Content\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//h3[@class='asset-title']/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Title\"),\n\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Content\"),\n\t\t\tselenium.getText(\"//div[@class='asset-summary']\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddNewWCWebContentAPActions() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Web Content\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[6]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_15_title']\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\n\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\");\n\t\tselenium.type(\"//body\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Content\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Name\"),\n\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Content\"),\n\t\t\tselenium.getText(\"//div[@class='asset-summary']\"));\n\t}","id":30770,"modified_method":"public void testAddNewWCWebContentAPActions() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add New\"),\n\t\t\tselenium.getText(\"//span[@title='Add New']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Add New']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Add New\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Basic Web Content\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\",\n\t\t\tRuntimeVariables.replace(\"Basic Web Content\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_15_title_en_US']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_15_title_en_US']\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Title\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\n\t\t\t\"//td[@id='cke_contents__15__15_structure_el_TextAreaField_content']/iframe\");\n\t\tselenium.type(\"//body\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Content\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//h3[@class='asset-title']/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Title\"),\n\t\t\tselenium.getText(\"//h3[@class='asset-title']/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Content\"),\n\t\t\tselenium.getText(\"//div[@class='asset-summary']\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"More\\u2026\"),\n\t\t\tselenium.getText(\"//a[@id='_145_addApplication']\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\\u2026\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","id":30771,"modified_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"More\\u2026\"),\n\t\t\tselenium.getText(\"//a[@id='_145_addApplication']\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\\u2026\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","id":30772,"modified_method":"public void testAddPortletAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Asset Publisher']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Asset Publisher']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testBeTheFirstWCWebContentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Comment Body\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\48\"));\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\8\"));\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Comment Body\"),\n\t\t\tselenium.getText(\"//div/div[3]/div/div[1]\"));\n\t}","id":30773,"modified_method":"public void testBeTheFirstWCWebContentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Comment\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Comment\"),\n\t\t\tselenium.getText(\"//div[@class='lfr-discussion-message']\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testBeTheFirstWCWebContentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Comment Body\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\48\"));\n\t\tselenium.keyPress(\"//textarea\", RuntimeVariables.replace(\"\\\\8\"));\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Comment Body\"),\n\t\t\tselenium.getText(\"//div/div[3]/div/div[1]\"));\n\t}","id":30774,"modified_method":"public void testBeTheFirstWCWebContentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Be the first.\"),\n\t\t\tselenium.getText(\"//fieldset/div/a\"));\n\t\tselenium.clickAt(\"//fieldset/div/a\",\n\t\t\tRuntimeVariables.replace(\"Be the first.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//textarea\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//textarea\",\n\t\t\tRuntimeVariables.replace(\"WC Web Content Comment\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Reply']\",\n\t\t\tRuntimeVariables.replace(\"Reply\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request processed successfully.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-message-response portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"WC Web Content Comment\"),\n\t\t\tselenium.getText(\"//div[@class='lfr-discussion-message']\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"label=Full Content\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","id":30775,"modified_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"Full Content\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"label=Full Content\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","id":30776,"modified_method":"public void testConfigurePortletDisplayStyleFullContent()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//select[@id='_86_displayStyle']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.select(\"//select[@id='_86_displayStyle']\",\n\t\t\tRuntimeVariables.replace(\"Full Content\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"Full Content\",\n\t\t\tselenium.getSelectedLabel(\"//select[@id='_86_displayStyle']\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletEnableCommentRatings()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentRatingsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comment Ratings\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":30777,"modified_method":"public void testConfigurePortletEnableCommentRatings()\n\t\tthrows Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\t\t\tselenium.getText(\"//strong/a\"));\n\t\t\t\tselenium.clickAt(\"//strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean enableCommentRatingsUnchecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_enableCommentRatingsCheckbox\");\n\n\t\t\t\tif (enableCommentRatingsUnchecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='_86_enableCommentRatingsCheckbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Enable Comment Ratings\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\t\t\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentRatingsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":30778,"modified_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\t\t\tselenium.getText(\"//strong/a\"));\n\t\t\t\tselenium.clickAt(\"//strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean enableCommentsUnchecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_enableCommentsCheckbox\");\n\n\t\t\t\tif (enableCommentsUnchecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\t\t\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.click(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t}","id":30779,"modified_method":"public void testConfigurePortletEnableComments() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\t\t\tselenium.getText(\"//strong/a\"));\n\t\t\t\tselenium.clickAt(\"//strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean enableCommentsUnchecked = selenium.isChecked(\n\t\t\t\t\t\t\"_86_enableCommentsCheckbox\");\n\n\t\t\t\tif (enableCommentsUnchecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='_86_enableCommentsCheckbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Enable Comments\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\t\t\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\t\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='_86_enableCommentsCheckbox']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testRateWCWebContentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isPartialText(\n\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\",\n\t\t\t\t\t\t\t\"0 Votes\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\"//div[@class='aui-rating-label-element']\", \"0 Votes\"));\n\t\tselenium.clickAt(\"//div/div[1]/div/div/div/div/a[1]\",\n\t\t\tRuntimeVariables.replace(\"Rate this as good.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"+1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"+1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertTrue(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tselenium.clickAt(\"//div/div[1]/div/div/div/div/a[2]\",\n\t\t\tRuntimeVariables.replace(\"Rate this as bad.\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"-1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"-1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertTrue(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t\tselenium.clickAt(\"//div/div[1]/div/div/div/div/a[2]\",\n\t\t\tRuntimeVariables.replace(\"Rate this as bad.\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t}","id":30780,"modified_method":"public void testRateWCWebContentCommentAP() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Asset Publisher Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Asset Publisher Test Page\",\n\t\t\tRuntimeVariables.replace(\"Asset Publisher Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"0 (0 Votes)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"0 (0 Votes)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as good.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"+1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"+1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as good.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"0 (0 Votes)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"0 (0 Votes)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as bad.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"-1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"-1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as bad.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"0 (0 Votes)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"0 (0 Votes)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as good.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"+1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"+1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as bad.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"-1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"-1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as bad.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"0 (0 Votes)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"0 (0 Votes)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as bad.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"-1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"-1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as good.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"+1 (1 Vote)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"+1 (1 Vote)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Rate this as good.\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tselenium.click(\n\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (RuntimeVariables.replace(\"0 (0 Votes)\")\n\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\"//div[@class='aui-rating-label-element']\"))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"0 (0 Votes)\"),\n\t\t\tselenium.getText(\"//div[@class='aui-rating-label-element']\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up']\"));\n\t\tassertTrue(selenium.isVisible(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down']\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-up aui-rating-element-on']\"));\n\t\tassertFalse(selenium.isElementPresent(\n\t\t\t\t\"//a[@class='aui-rating-element aui-rating-element-off aui-rating-thumb-down aui-rating-element-on']\"));\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownWCWebContent() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Web Content\",\n\t\t\t\t\tRuntimeVariables.replace(\"Web Content\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean webContent1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean webContent2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tboolean webContent3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent3Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 4:\n\n\t\t\t\tboolean webContent4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent4Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\n\t\t\t\tboolean webContent5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent5Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 6:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":30781,"modified_method":"public void testTearDownWCWebContent() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Web Content\",\n\t\t\t\t\tRuntimeVariables.replace(\"Web Content\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean webContentPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContentPresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_15_allRowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All Rows\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownWCWebContent() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Web Content\",\n\t\t\t\t\tRuntimeVariables.replace(\"Web Content\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean webContent1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean webContent2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tboolean webContent3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent3Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 4:\n\n\t\t\t\tboolean webContent4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent4Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\n\t\t\t\tboolean webContent5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContent5Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"_15_rowIds\", RuntimeVariables.replace(\"Flag\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 6:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":30782,"modified_method":"public void testTearDownWCWebContent() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Web Content\",\n\t\t\t\t\tRuntimeVariables.replace(\"Web Content\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean webContentPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"_15_rowIds\");\n\n\t\t\t\tif (!webContentPresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_15_allRowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All Rows\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected web content[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"c7070293852c3d5f911e0fb7159ef45c6acafb04","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getOldOpennetPeersString(OpennetManager om) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(PeerNode pn : om.getOldPeers()) {\n\t\t\tif(pn instanceof OpennetPeerNode)\n\t\t\t\tsb.append(pn.exportDiskFieldSet());\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}","id":30783,"modified_method":"protected String getOldOpennetPeersString(OpennetManager om) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(PeerNode pn : om.getOldPeers()) {\n\t\t\tif(pn instanceof OpennetPeerNode)\n\t\t\t\tsb.append(pn.exportDiskFieldSet().toOrderedString());\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}","commit_id":"aa6d687da573bc6bfa47d8cdc0d0a05a3c239e8f","url":"https://github.com/freenet/fred"},{"original_method":"protected String getDarknetPeersString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tPeerNode[] peers;\n\t\tsynchronized(this) {\n\t\t\tpeers = myPeers;\n\t\t}\n\t\tfor(PeerNode pn : peers) {\n\t\t\tif(pn instanceof DarknetPeerNode)\n\t\t\t\tsb.append(pn.exportDiskFieldSet());\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}","id":30784,"modified_method":"protected String getDarknetPeersString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tPeerNode[] peers;\n\t\tsynchronized(this) {\n\t\t\tpeers = myPeers;\n\t\t}\n\t\tfor(PeerNode pn : peers) {\n\t\t\tif(pn instanceof DarknetPeerNode)\n\t\t\t\tsb.append(pn.exportDiskFieldSet().toOrderedString());\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}","commit_id":"aa6d687da573bc6bfa47d8cdc0d0a05a3c239e8f","url":"https://github.com/freenet/fred"},{"original_method":"protected String getOpennetPeersString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tPeerNode[] peers;\n\t\tsynchronized(this) {\n\t\t\tpeers = myPeers;\n\t\t}\n\t\tfor(PeerNode pn : peers) {\n\t\t\tif(pn instanceof OpennetPeerNode)\n\t\t\t\tsb.append(pn.exportDiskFieldSet());\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}","id":30785,"modified_method":"protected String getOpennetPeersString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tPeerNode[] peers;\n\t\tsynchronized(this) {\n\t\t\tpeers = myPeers;\n\t\t}\n\t\tfor(PeerNode pn : peers) {\n\t\t\tif(pn instanceof OpennetPeerNode)\n\t\t\t\tsb.append(pn.exportDiskFieldSet().toOrderedString());\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}","commit_id":"aa6d687da573bc6bfa47d8cdc0d0a05a3c239e8f","url":"https://github.com/freenet/fred"},{"original_method":"public BuildModelAction(Class<? extends ProjectVersion3> type) {\n        if (!type.isAssignableFrom(EclipseProjectVersion3.class)) {\n            throw new UnsupportedOperationException(String.format(\"Do not know how to build a model of type '%s'.\", type.getSimpleName()));\n        }\n\n        boolean projectDependenciesOnly = !EclipseProjectVersion3.class.isAssignableFrom(type);\n        boolean includeTasks = BuildableProjectVersion1.class.isAssignableFrom(type);\n\n        ModelBuilder defaultBuilder = new ModelBuilder(includeTasks, projectDependenciesOnly, VersionedTypes.forType(type));\n\n        modelBuildingAdapter = new ModelBuildingAdapter(defaultBuilder);\n    }","id":30786,"modified_method":"public BuildModelAction(Class<? extends ProjectVersion3> type) {\n        if (!type.isAssignableFrom(EclipseProjectVersion3.class)) {\n            throw new UnsupportedOperationException(String.format(\"Do not know how to build a model of type '%s'.\", type.getSimpleName()));\n        }\n\n        boolean projectDependenciesOnly = !EclipseProjectVersion3.class.isAssignableFrom(type);\n        boolean includeTasks = BuildableProjectVersion1.class.isAssignableFrom(type);\n\n        ModelBuilder defaultBuilder = new ModelBuilder(includeTasks, projectDependenciesOnly);\n\n        modelBuildingAdapter = new ModelBuildingAdapter(defaultBuilder);\n    }","commit_id":"c8eb36ac886d994aa9f66f30c8fe6115a3d6c89b","url":"https://github.com/gradle/gradle"},{"original_method":"private void populate(Project project) {\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        EclipseClasspath classpath = eclipseModel.getClasspath();\n\n        classpath.setProjectDependenciesOnly(projectDependenciesOnly);\n        List<ClasspathEntry> entries = classpath.resolveDependencies();\n\n        final List<ExternalDependencyVersion1> externalDependencies = new LinkedList<ExternalDependencyVersion1>();\n        final List projectDependencies = new LinkedList();\n        final List<EclipseSourceDirectoryVersion1> sourceDirectories = new LinkedList<EclipseSourceDirectoryVersion1>();\n\n        for (ClasspathEntry entry : entries) {\n            if (entry instanceof Library) {\n                Library library = (Library) entry;\n                final File file = project.file(library.getPath());\n                final File source = library.getSourcePath() == null ? null : project.file(library.getSourcePath());\n                final File javadoc = library.getJavadocPath() == null ? null : project.file(library.getJavadocPath());\n                externalDependencies.add(new DefaultExternalDependency(file, javadoc, source));\n            } else if (entry instanceof ProjectDependency) {\n                final ProjectDependency projectDependency = (ProjectDependency) entry;\n                final String path = StringUtils.removeStart(projectDependency.getPath(), \"/\");\n                projectDependencies.add(ReflectionUtil.newInstance(versionedTypes.forProjectDependency, path, projectMapping.get(projectDependency.getGradlePath())));\n            } else if (entry instanceof SourceFolder) {\n                String path = ((SourceFolder) entry).getPath();\n                sourceDirectories.add(new DefaultEclipseSourceDirectory(path, project.file(path)));\n            }\n        }\n\n        final Object eclipseProject = projectMapping.get(project.getPath());\n        ReflectionUtil.setProperty(eclipseProject, \"classpath\", externalDependencies);\n        ReflectionUtil.setProperty(eclipseProject, \"projectDependencies\", projectDependencies);\n        ReflectionUtil.setProperty(eclipseProject, \"sourceDirectories\", sourceDirectories);\n\n        if (ReflectionUtil.hasProperty(eclipseProject, \"linkedResources\")) {\n            List<DefaultEclipseLinkedResource> linkedResources = new LinkedList<DefaultEclipseLinkedResource>();\n            for(Link r: eclipseModel.getProject().getLinkedResources()) {\n                linkedResources.add(new DefaultEclipseLinkedResource(r.getName(), r.getType(), r.getLocation(), r.getLocationUri()));\n            }\n            ReflectionUtil.setProperty(eclipseProject, \"linkedResources\", linkedResources);\n        }\n\n        List out = new ArrayList();\n        for (final Task t : tasksFactory.getTasks(project)) {\n            out.add(ReflectionUtil.newInstance(versionedTypes.forTask, eclipseProject, t.getPath(), t.getName(), t.getDescription()));\n        }\n        ReflectionUtil.setProperty(eclipseProject, \"tasks\", out);\n\n        for (Project childProject : project.getChildProjects().values()) {\n            populate(childProject);\n        }\n    }","id":30787,"modified_method":"private void populate(Project project) {\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        EclipseClasspath classpath = eclipseModel.getClasspath();\n\n        classpath.setProjectDependenciesOnly(projectDependenciesOnly);\n        List<ClasspathEntry> entries = classpath.resolveDependencies();\n\n        final List<ExternalDependencyVersion1> externalDependencies = new LinkedList<ExternalDependencyVersion1>();\n        final List<EclipseProjectDependencyVersion2> projectDependencies = new LinkedList<EclipseProjectDependencyVersion2>();\n        final List<EclipseSourceDirectoryVersion1> sourceDirectories = new LinkedList<EclipseSourceDirectoryVersion1>();\n\n        for (ClasspathEntry entry : entries) {\n            if (entry instanceof Library) {\n                Library library = (Library) entry;\n                final File file = project.file(library.getPath());\n                final File source = library.getSourcePath() == null ? null : project.file(library.getSourcePath());\n                final File javadoc = library.getJavadocPath() == null ? null : project.file(library.getJavadocPath());\n                externalDependencies.add(new DefaultExternalDependency(file, javadoc, source));\n            } else if (entry instanceof ProjectDependency) {\n                final ProjectDependency projectDependency = (ProjectDependency) entry;\n                final String path = StringUtils.removeStart(projectDependency.getPath(), \"/\");\n                projectDependencies.add(new DefaultEclipseProjectDependency(path, projectMapping.get(projectDependency.getGradlePath())));\n            } else if (entry instanceof SourceFolder) {\n                String path = ((SourceFolder) entry).getPath();\n                sourceDirectories.add(new DefaultEclipseSourceDirectory(path, project.file(path)));\n            }\n        }\n\n        final EclipseProjectVersion3 eclipseProject = projectMapping.get(project.getPath());\n        ReflectionUtil.setProperty(eclipseProject, \"classpath\", externalDependencies);\n        ReflectionUtil.setProperty(eclipseProject, \"projectDependencies\", projectDependencies);\n        ReflectionUtil.setProperty(eclipseProject, \"sourceDirectories\", sourceDirectories);\n\n        if (ReflectionUtil.hasProperty(eclipseProject, \"linkedResources\")) {\n            List<DefaultEclipseLinkedResource> linkedResources = new LinkedList<DefaultEclipseLinkedResource>();\n            for(Link r: eclipseModel.getProject().getLinkedResources()) {\n                linkedResources.add(new DefaultEclipseLinkedResource(r.getName(), r.getType(), r.getLocation(), r.getLocationUri()));\n            }\n            ReflectionUtil.setProperty(eclipseProject, \"linkedResources\", linkedResources);\n        }\n\n        List<EclipseTaskVersion1> out = new ArrayList<EclipseTaskVersion1>();\n        for (final Task t : tasksFactory.getTasks(project)) {\n            out.add(new DefaultEclipseTask(eclipseProject, t.getPath(), t.getName(), t.getDescription()));\n        }\n        ReflectionUtil.setProperty(eclipseProject, \"tasks\", out);\n\n        for (Project childProject : project.getChildProjects().values()) {\n            populate(childProject);\n        }\n    }","commit_id":"c8eb36ac886d994aa9f66f30c8fe6115a3d6c89b","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelBuilder(boolean includeTasks, boolean projectDependenciesOnly, VersionedTypes versionedTypes) {\n        this.versionedTypes = versionedTypes;\n        this.tasksFactory = new TasksFactory(includeTasks);\n        this.projectDependenciesOnly = projectDependenciesOnly;\n    }","id":30788,"modified_method":"public ModelBuilder(boolean includeTasks, boolean projectDependenciesOnly) {\n        this.tasksFactory = new TasksFactory(includeTasks);\n        this.projectDependenciesOnly = projectDependenciesOnly;\n    }","commit_id":"c8eb36ac886d994aa9f66f30c8fe6115a3d6c89b","url":"https://github.com/gradle/gradle"},{"original_method":"private Object buildHierarchy(Project project) {\n        List children = new ArrayList();\n        for (Project child : project.getChildProjects().values()) {\n            children.add(buildHierarchy(child));\n        }\n\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        org.gradle.plugins.ide.eclipse.model.EclipseProject internalProject = eclipseModel.getProject();\n        String name = internalProject.getName();\n        String description = GUtil.elvis(internalProject.getComment(), null);\n        Object eclipseProject = ReflectionUtil.newInstance(versionedTypes.forProject, name, project.getPath(), description, project.getProjectDir(), children);\n        for (Object child : children) {\n            ReflectionUtil.setProperty(child, \"parent\", eclipseProject);\n        }\n        addProject(project, eclipseProject);\n        return eclipseProject;\n    }","id":30789,"modified_method":"private EclipseProjectVersion3 buildHierarchy(Project project) {\n        List<EclipseProjectVersion3> children = new ArrayList<EclipseProjectVersion3>();\n        for (Project child : project.getChildProjects().values()) {\n            children.add(buildHierarchy(child));\n        }\n\n        EclipseModel eclipseModel = project.getPlugins().getPlugin(EclipsePlugin.class).getModel();\n        org.gradle.plugins.ide.eclipse.model.EclipseProject internalProject = eclipseModel.getProject();\n        String name = internalProject.getName();\n        String description = GUtil.elvis(internalProject.getComment(), null);\n        EclipseProjectVersion3 eclipseProject = new DefaultEclipseProject(name, project.getPath(), description, project.getProjectDir(), children);\n        for (Object child : children) {\n            ReflectionUtil.setProperty(child, \"parent\", eclipseProject);\n        }\n        addProject(project, eclipseProject);\n        return eclipseProject;\n    }","commit_id":"c8eb36ac886d994aa9f66f30c8fe6115a3d6c89b","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public <T> Iterable<ModelResult<T>> produceModels(Class<T> elementType, ConsumerOperationParameters operationParameters) {\n        BuildResult<?> result = buildModels(elementType, operationParameters);\n        final List<ModelResult<T>> models = new LinkedList<ModelResult<T>>();\n        if (result.getModel() instanceof Map) {\n            // TODO: Convert to ModelResult\n            Map<Object, Object> targetMap = new HashMap<Object, Object>();\n            adapter.convertMap(targetMap, String.class, elementType, Map.class.cast(result.getModel()), getCompatibilityMapperAction());\n            for (Map.Entry<Object, Object> e : targetMap.entrySet()) {\n                String projectIdentityString = (String)e.getKey();\n                String[] splits = projectIdentityString.split(\"[$]\");\n                File rootDir = new File(splits[0]);\n                String projectPath = splits[1];\n                BuildIdentity buildIdentity = new DefaultBuildIdentity(rootDir);\n                ProjectIdentity projectIdentity = new DefaultProjectIdentity(buildIdentity, rootDir, projectPath);\n                T model = (T)e.getValue();\n                models.add(new DefaultModelResult<T>(model, projectIdentity));\n            }\n        }\n        // TODO: Adapt other types?\n        return models;\n    }","id":30790,"modified_method":"@Override\n    public <T> Iterable<ModelResult<T>> produceModels(Class<T> elementType, ConsumerOperationParameters operationParameters) {\n        BuildResult<?> result = buildModels(elementType, operationParameters);\n        final List<ModelResult<T>> models = new LinkedList<ModelResult<T>>();\n        if (result.getModel() instanceof Map) {\n            Map<Object, Object> targetMap = new HashMap<Object, Object>();\n            adapter.convertMap(targetMap, ProjectIdentity.class, elementType, Map.class.cast(result.getModel()), getCompatibilityMapperAction());\n            for (Map.Entry<Object, Object> e : targetMap.entrySet()) {\n                ProjectIdentity projectIdentity = (ProjectIdentity)e.getKey();\n                T model = (T)e.getValue();\n                models.add(new DefaultModelResult<T>(model, projectIdentity));\n            }\n        }\n        // TODO: Adapt other types?\n        return models;\n    }","commit_id":"cf1a89bbe3156adb0df2ec8e9200e5feef2038d2","url":"https://github.com/gradle/gradle"},{"original_method":"private void fetchPerBuildModels(Map<Object, Object> results, Object projectIdentity, ProjectConnection projectConnection, Class<?> modelType, BuildCancellationToken cancellationToken, ProgressLoggerFactory progressLoggerFactory) {\n        Object result = fetchModel(projectConnection, modelType, cancellationToken, progressLoggerFactory);\n        if(result != null) {\n            results.put(projectIdentity, result);\n        }\n    }","id":30791,"modified_method":"private Map<Object, Object> fetchPerBuildModels(Object projectIdentity, ProjectConnection projectConnection, Class<?> modelType, BuildCancellationToken cancellationToken, ProgressLoggerFactory progressLoggerFactory) {\n        Object result = fetchModel(projectConnection, modelType, cancellationToken, progressLoggerFactory);\n        if(result != null) {\n            return Collections.singletonMap(projectIdentity, result);\n        }\n        return Collections.emptyMap();\n    }","commit_id":"cf1a89bbe3156adb0df2ec8e9200e5feef2038d2","url":"https://github.com/gradle/gradle"},{"original_method":"private Map<Object, Object> fetchModels(List<GradleParticipantBuild> participantBuilds, Class<?> modelType, final BuildCancellationToken cancellationToken, CompositeParameters compositeParameters, final ProgressLoggerFactory progressLoggerFactory) {\n        final Map<Object, Object> results = new HashMap<Object, Object>();\n        for (GradleParticipantBuild participant : participantBuilds) {\n            if (cancellationToken.isCancellationRequested()) {\n                break;\n            }\n            ProjectConnection projectConnection = connect(participant, compositeParameters);\n            try {\n                if (modelType == BuildEnvironment.class) {\n                    // TODO:\n                    Object projectIdentity = participant.getProjectDir() + \"$:\";\n                    fetchPerBuildModels(results, projectIdentity, projectConnection, modelType, cancellationToken, progressLoggerFactory);\n                } else {\n                    fetchPerProjectModels(results, projectConnection, modelType, cancellationToken, progressLoggerFactory);\n                }\n            } catch (GradleConnectionException e) {\n                throw new CompositeBuildExceptionVersion1(e);\n            } finally {\n                projectConnection.close();\n            }\n        }\n        return results;\n    }","id":30792,"modified_method":"private Map<Object, Object> fetchModels(List<GradleParticipantBuild> participantBuilds, Class<?> modelType, final BuildCancellationToken cancellationToken, CompositeParameters compositeParameters, final ProgressLoggerFactory progressLoggerFactory) {\n        final Map<Object, Object> results = new HashMap<Object, Object>();\n        for (GradleParticipantBuild participant : participantBuilds) {\n            if (cancellationToken.isCancellationRequested()) {\n                break;\n            }\n            ProjectConnection projectConnection = connect(participant, compositeParameters);\n            try {\n                if (modelType == BuildEnvironment.class) {\n                    File rootDir = participant.getProjectDir();\n                    ProjectIdentity projectIdentity = new DefaultProjectIdentity(new DefaultBuildIdentity(rootDir), rootDir, \":\");\n                    results.putAll(fetchPerBuildModels(projectIdentity, projectConnection, modelType, cancellationToken, progressLoggerFactory));\n                } else {\n                    results.putAll(fetchPerProjectModels(projectConnection, modelType, cancellationToken, progressLoggerFactory));\n                }\n            } catch (GradleConnectionException e) {\n                throw new CompositeBuildExceptionVersion1(e);\n            } finally {\n                projectConnection.close();\n            }\n        }\n        return results;\n    }","commit_id":"cf1a89bbe3156adb0df2ec8e9200e5feef2038d2","url":"https://github.com/gradle/gradle"},{"original_method":"private void fetchResults(Class<?> modelType, Map<Object, Object> results, BuildController controller, BasicGradleProject project, BasicGradleProject rootProject) {\n            File rootDir = rootProject.getProjectDirectory();\n            // TODO: What kind of ProjectIdentity do we create?\n            Object projectIdentity = rootDir + \"$\" + project.getPath();\n            results.put(projectIdentity, controller.getModel(project, modelType));\n            for (BasicGradleProject child : project.getChildren()) {\n                fetchResults(modelType, results, controller, child, rootProject);\n            }\n        }","id":30793,"modified_method":"private void fetchResults(Class<?> modelType, Map<Object, Object> results, BuildController controller, BasicGradleProject project, BasicGradleProject rootProject) {\n            File rootDir = rootProject.getProjectDirectory();\n            results.put(new InternalProjectIdentity(rootDir, project.getPath()), controller.getModel(project, modelType));\n            for (BasicGradleProject child : project.getChildren()) {\n                fetchResults(modelType, results, controller, child, rootProject);\n            }\n        }","commit_id":"cf1a89bbe3156adb0df2ec8e9200e5feef2038d2","url":"https://github.com/gradle/gradle"},{"original_method":"private void fetchPerProjectModels(Map<Object, Object> results, ProjectConnection projectConnection, Class<?> modelType, BuildCancellationToken cancellationToken, ProgressLoggerFactory progressLoggerFactory) {\n        BuildActionExecuter<Map<Object, Object>> buildActionExecuter = projectConnection.action(new FetchPerProjectModelAction(modelType.getName()));\n        buildActionExecuter.withCancellationToken(new CancellationTokenAdapter(cancellationToken));\n        buildActionExecuter.addProgressListener(new ProgressListenerToProgressLoggerAdapter(progressLoggerFactory));\n        if (cancellationToken.isCancellationRequested()) {\n            return;\n        }\n        results.putAll(buildActionExecuter.run());\n    }","id":30794,"modified_method":"private Map<Object, Object> fetchPerProjectModels(ProjectConnection projectConnection, Class<?> modelType, BuildCancellationToken cancellationToken, ProgressLoggerFactory progressLoggerFactory) {\n        Map<Object, Object> results = new HashMap<Object, Object>();\n        BuildActionExecuter<Map<Object, Object>> buildActionExecuter = projectConnection.action(new FetchPerProjectModelAction(modelType.getName()));\n        buildActionExecuter.withCancellationToken(new CancellationTokenAdapter(cancellationToken));\n        buildActionExecuter.addProgressListener(new ProgressListenerToProgressLoggerAdapter(progressLoggerFactory));\n\n        if (!cancellationToken.isCancellationRequested()) {\n            for (Map.Entry<Object, Object> e : buildActionExecuter.run().entrySet()) {\n                InternalProjectIdentity internalProjectIdentity = (InternalProjectIdentity) e.getKey();\n                results.put(convertToProjectIdentity(internalProjectIdentity), e.getValue());\n            }\n        }\n        return results;\n    }","commit_id":"cf1a89bbe3156adb0df2ec8e9200e5feef2038d2","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public ProjectIdentity toProjectIdentity(String projectPath) {\n        if (projectPath==null) {\n            throw new NullPointerException(\"projectPath cannot be null\");\n        }\n        if (!projectPath.startsWith(\":\")) {\n            throw new IllegalArgumentException(\"projectPath must be absolute and start with a :\");\n        }\n        return new DefaultProjectIdentity(toBuildIdentity(), projectDir, projectPath);\n    }","id":30795,"modified_method":"@Override\n    public ProjectIdentity toProjectIdentity(String projectPath) {\n        if (projectPath==null) {\n            throw new NullPointerException(\"projectPath cannot be null\");\n        }\n        if (!projectPath.startsWith(\":\")) {\n            throw new IllegalArgumentException(\"projectPath must be absolute and start with a :\");\n        }\n        return new DefaultProjectIdentity((DefaultBuildIdentity)toBuildIdentity(), projectDir, projectPath);\n    }","commit_id":"cf1a89bbe3156adb0df2ec8e9200e5feef2038d2","url":"https://github.com/gradle/gradle"},{"original_method":"private Class<?> resolveModelType(BuildModelAction action) {\n        final String requestedModelName = action.getModelName();\n        try {\n            return Cast.uncheckedCast(getClass().getClassLoader().loadClass(requestedModelName));\n        } catch (ClassNotFoundException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","id":30796,"modified_method":"private boolean isModelRequest(BuildModelAction action) {\n        final String requestedModelName = action.getModelName();\n        return !requestedModelName.equals(Void.class.getName());\n    }","commit_id":"5d7922900aee38616bbfbe5f868d2b51cb7e8ae5","url":"https://github.com/gradle/gradle"},{"original_method":"private <T> Map<Object, Object> fetchCompositeModelsInProcess(BuildModelAction modelAction, Class<T> modelType, BuildRequestContext buildRequestContext,\n                                                                  List<GradleParticipantBuild> participantBuilds,\n                                                                  ServiceRegistry sharedServices) {\n        final Map<Object, Object> results = new HashMap<Object, Object>();\n\n        PayloadSerializer payloadSerializer = sharedServices.get(PayloadSerializer.class);\n        GradleLauncherFactory gradleLauncherFactory = sharedServices.get(GradleLauncherFactory.class);\n\n        BuildActionRunner runner = new SubscribableBuildActionRunner(new ClientProvidedBuildActionRunner());\n        org.gradle.launcher.exec.BuildActionExecuter<BuildActionParameters> buildActionExecuter = new InProcessBuildActionExecuter(gradleLauncherFactory, runner);\n        // TODO Need to consider how to handle builds in parallel when sharing event consumers/output streams\n        DefaultBuildRequestContext requestContext = new DefaultBuildRequestContext(new DefaultBuildRequestMetaData(System.currentTimeMillis()),\n            buildRequestContext.getCancellationToken(), buildRequestContext.getEventConsumer(), buildRequestContext.getOutputListener(),\n            buildRequestContext.getErrorListener());\n\n        ProtocolToModelAdapter protocolToModelAdapter = new ProtocolToModelAdapter();\n\n        FetchPerProjectModelAction fetchPerProjectModelAction = new FetchPerProjectModelAction(modelType.getName());\n        InternalBuildAction<?> internalBuildAction = new InternalBuildActionAdapter<Map<Object, Object>>(fetchPerProjectModelAction, protocolToModelAdapter);\n        SerializedPayload serializedAction = payloadSerializer.serialize(internalBuildAction);\n\n        for (GradleParticipantBuild participant : participantBuilds) {\n            DefaultBuildActionParameters actionParameters = new DefaultBuildActionParameters(Collections.EMPTY_MAP, Collections.<String, String>emptyMap(), participant.getProjectDir(), LogLevel.INFO, DaemonUsage.EXPLICITLY_DISABLED, false, true, ClassPath.EMPTY);\n\n            StartParameter startParameter = modelAction.getStartParameter().newInstance();\n            startParameter.setProjectDir(participant.getProjectDir());\n\n            ServiceRegistry buildScopedServices = new BuildSessionScopeServices(sharedServices, startParameter, ClassPath.EMPTY);\n\n            ClientProvidedBuildAction mappedAction = new ClientProvidedBuildAction(startParameter, serializedAction, modelAction.getClientSubscriptions());\n\n            try {\n                BuildActionResult result = (BuildActionResult) buildActionExecuter.execute(mappedAction, requestContext, actionParameters, buildScopedServices);\n                if (result.result != null) {\n                    Map<Object, Object> values = Cast.uncheckedCast(payloadSerializer.deserialize(result.result));\n                    for (Map.Entry<Object, Object> e : values.entrySet()) {\n                        InternalProjectIdentity internalProjectIdentity = (InternalProjectIdentity) e.getKey();\n                        results.put(convertToProjectIdentity(internalProjectIdentity), e.getValue());\n                    }\n                } else {\n                    Throwable failure = (Throwable) payloadSerializer.deserialize(result.failure);\n                    File rootDir = participant.getProjectDir();\n                    BuildIdentifier buildIdentifier = new DefaultBuildIdentifier(rootDir);\n                    results.put(new DefaultProjectIdentifier(buildIdentifier, \":\"), failure);\n                }\n            } catch (Exception e) {\n                File rootDir = participant.getProjectDir();\n                BuildIdentifier buildIdentifier = new DefaultBuildIdentifier(rootDir);\n                results.put(new DefaultProjectIdentifier(buildIdentifier, \":\"), e);\n            }\n\n        }\n        return results;\n    }","id":30797,"modified_method":"private Map<Object, Object> fetchCompositeModelsInProcess(BuildModelAction modelAction, BuildRequestContext buildRequestContext,\n                                                              List<GradleParticipantBuild> participantBuilds,\n                                                              ServiceRegistry sharedServices) {\n        final Map<Object, Object> results = new HashMap<Object, Object>();\n        GradleLauncherFactory gradleLauncherFactory = sharedServices.get(GradleLauncherFactory.class);\n\n        BuildActionRunner runner = new SubscribableBuildActionRunner(new BuildModelsActionRunner());\n        org.gradle.launcher.exec.BuildActionExecuter<BuildActionParameters> buildActionExecuter = new InProcessBuildActionExecuter(gradleLauncherFactory, runner);\n        // TODO Need to consider how to handle builds in parallel when sharing event consumers/output streams\n        DefaultBuildRequestContext requestContext = new DefaultBuildRequestContext(new DefaultBuildRequestMetaData(System.currentTimeMillis()),\n            buildRequestContext.getCancellationToken(), buildRequestContext.getEventConsumer(), buildRequestContext.getOutputListener(),\n            buildRequestContext.getErrorListener());\n\n        for (GradleParticipantBuild participant : participantBuilds) {\n            DefaultBuildActionParameters actionParameters = new DefaultBuildActionParameters(Collections.EMPTY_MAP, Collections.<String, String>emptyMap(), participant.getProjectDir(), LogLevel.INFO, DaemonUsage.EXPLICITLY_DISABLED, false, true, ClassPath.EMPTY);\n\n            StartParameter startParameter = modelAction.getStartParameter().newInstance();\n            startParameter.setProjectDir(participant.getProjectDir());\n\n            ServiceRegistry buildScopedServices = new BuildSessionScopeServices(sharedServices, startParameter, ClassPath.EMPTY);\n\n            BuildModelAction participantAction = new BuildModelAction(startParameter, modelAction.getModelName(), false, modelAction.getClientSubscriptions());\n            try {\n                Map<String, Object> result = Cast.uncheckedCast(buildActionExecuter.execute(participantAction, requestContext, actionParameters, buildScopedServices));\n                for (Map.Entry<String, Object> e : result.entrySet()) {\n                    DefaultProjectIdentifier projectIdentifier = new DefaultProjectIdentifier(participant.getProjectDir(), e.getKey());\n                    Object modelValue = e.getValue();\n                    results.put(projectIdentifier, modelValue);\n                }\n            } catch (Exception e) {\n                File rootDir = participant.getProjectDir();\n                BuildIdentifier buildIdentifier = new DefaultBuildIdentifier(rootDir);\n                results.put(new DefaultProjectIdentifier(buildIdentifier, \":\"), e);\n            }\n        }\n        return results;\n    }","commit_id":"5d7922900aee38616bbfbe5f868d2b51cb7e8ae5","url":"https://github.com/gradle/gradle"},{"original_method":"public void run(BuildAction action, BuildRequestContext requestContext, CompositeBuildActionParameters actionParameters, CompositeBuildController buildController) {\n        if (!(action instanceof BuildModelAction)) {\n            return;\n        }\n        Class<?> modelType = resolveModelType((BuildModelAction) action);\n        Map<Object, Object> results = null;\n        if (modelType != Void.class) {\n            results = new HashMap<Object, Object>();\n\n            results.putAll(fetchCompositeModelsInProcess((BuildModelAction) action, modelType, requestContext, actionParameters.getCompositeParameters().getBuilds(), buildController.getBuildScopeServices()));\n        } else {\n            if (!((BuildModelAction) action).isRunTasks()) {\n                throw new IllegalStateException(\"No tasks defined.\");\n            }\n            executeTasksInProcess(action.getStartParameter(), actionParameters, requestContext, buildController.getBuildScopeServices());\n        }\n        PayloadSerializer payloadSerializer = buildController.getBuildScopeServices().get(PayloadSerializer.class);\n        buildController.setResult(new BuildActionResult(payloadSerializer.serialize(results), null));\n    }","id":30798,"modified_method":"public void run(BuildAction action, BuildRequestContext requestContext, CompositeBuildActionParameters actionParameters, CompositeBuildController buildController) {\n        if (!(action instanceof BuildModelAction)) {\n            return;\n        }\n        BuildModelAction buildModelAction = (BuildModelAction) action;\n        Map<Object, Object> results = null;\n        if (isModelRequest(buildModelAction)) {\n            results = fetchCompositeModelsInProcess(buildModelAction, requestContext, actionParameters.getCompositeParameters().getBuilds(), buildController.getBuildScopeServices());\n        } else {\n            if (!buildModelAction.isRunTasks()) {\n                throw new IllegalStateException(\"No tasks defined.\");\n            }\n            executeTasksInProcess(action.getStartParameter(), actionParameters, requestContext, buildController.getBuildScopeServices());\n        }\n        PayloadSerializer payloadSerializer = buildController.getBuildScopeServices().get(PayloadSerializer.class);\n        buildController.setResult(new BuildActionResult(payloadSerializer.serialize(results), null));\n    }","commit_id":"5d7922900aee38616bbfbe5f868d2b51cb7e8ae5","url":"https://github.com/gradle/gradle"},{"original_method":"public void releaseNetworkAllocation( NetworkToken token ) {\n    LOG.debug( String.format( EucalyptusProperties.DEBUG_FSTRING, EucalyptusProperties.TokenState.returned, token ) );\n    try {\n      Network existingNet = Networks.getInstance( ).lookup( token.getName( ) );\n      existingNet.returnNetworkIndexes( token.getIndexes( ) );      \n      this.releaseNetworkAllocation( token.getName( ) );\n    } catch ( NoSuchElementException e ) {\n    }\n  }","id":30799,"modified_method":"public void releaseNetworkAllocation( NetworkToken token ) {\n    LOG.debug( String.format( EucalyptusProperties.DEBUG_FSTRING, EucalyptusProperties.TokenState.returned, token ) );\n    try {\n      Network existingNet = Networks.getInstance( ).lookup( token.getName( ) );\n      this.releaseNetworkAllocation( token.getName( ) );\n    } catch ( NoSuchElementException e ) {\n    }\n  }","commit_id":"a93e92a7abe3a1fadc2b61c6936cfc242aa555c4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void upstreamMessage( ChannelHandlerContext ctx, MessageEvent e ) {\n    if ( e.getMessage( ) instanceof MappingHttpResponse ) {\n      MappingHttpResponse resp = ( MappingHttpResponse ) e.getMessage( );\n      DescribeNetworksResponseType reply = ( DescribeNetworksResponseType ) resp.getMessage( );\n      for( Network net : Networks.getInstance( ).listValues( ) ) {\n        net.trim( reply.getAddrsPerNetwork( ) );\n      }\n      this.getCluster( ).getState( ).setAddressCapacity( reply.getAddrsPerNetwork( ) );\n      this.getCluster( ).getState( ).setMode( reply.getMode( ) );\n      List<String> active = Lists.newArrayList( );\n      for ( NetworkInfoType netInfo : reply.getActiveNetworks( ) ) {\n        Network net = null;\n        try {\n          net = Networks.getInstance( ).lookup( netInfo.getUserName( ) + \"-\" + netInfo.getNetworkName( ) );\n        } catch ( NoSuchElementException e1 ) {\n          net = new Network( netInfo.getUserName( ), netInfo.getNetworkName( ) );\n        }\n        active.add( net.getName( ) );\n        net.setVlan( netInfo.getVlan() );\n        NetworkToken netToken = new NetworkToken( this.getCluster( ).getName( ), netInfo.getUserName( ), netInfo.getNetworkName( ), netInfo.getVlan( ) );\n        netToken = net.addTokenIfAbsent( netToken );\n      }\n      \n      for( Network net : Networks.getInstance( ).listValues( Networks.State.ACTIVE ) ) {\n        net.trim( reply.getAddrsPerNetwork( ) );\n        if( net.hasToken( this.getCluster( ).getName( ) ) ) continue;\n        try {\n          Clusters.sendClusterEvent( this.getCluster( ), this.getStopCallback( net ) );\n          if( !net.hasTokens( ) ) {\n            Networks.getInstance( ).setState( net.getName( ), Networks.State.DISABLED );\n            this.getCluster( ).getState( ).releaseNetworkAllocation( net.getName( ) );\n          }\n        } catch ( NoSuchElementException e1 ) {\n          LOG.debug( e1, e1 );\n        }\n      }\n      List<Cluster> ccList = Clusters.getInstance( ).listValues( );\n      int ccNum = ccList.size( );\n      for ( Cluster c : ccList ) {\n        ccNum -= c.getState( ).getMode( );\n      }\n      if ( ccNum != 0 ) {\n        EucalyptusProperties.disableNetworking = true;\n      } else {\n        EucalyptusProperties.disableNetworking = false;\n      }\n      this.verified = true;\n    } else {\n      LOG.warn( \"Received unknown message type. \" + e.getMessage( ) );\n    }\n  }","id":30800,"modified_method":"@Override\n  public void upstreamMessage( ChannelHandlerContext ctx, MessageEvent e ) {\n    if ( e.getMessage( ) instanceof MappingHttpResponse ) {\n      MappingHttpResponse resp = ( MappingHttpResponse ) e.getMessage( );\n      DescribeNetworksResponseType reply = ( DescribeNetworksResponseType ) resp.getMessage( );\n      LOG.debug( reply.toString( \"eucalyptus_ucsb_edu\") );\n      for( Network net : Networks.getInstance( ).listValues( ) ) {\n        net.trim( reply.getAddrsPerNetwork( ) );\n      }\n      this.getCluster( ).getState( ).setAddressCapacity( reply.getAddrsPerNetwork( ) );\n      this.getCluster( ).getState( ).setMode( reply.getMode( ) );\n      List<String> active = Lists.newArrayList( );\n      for ( NetworkInfoType netInfo : reply.getActiveNetworks( ) ) {\n        Network net = null;\n        try {\n          net = Networks.getInstance( ).lookup( netInfo.getUserName( ) + \"-\" + netInfo.getNetworkName( ) );\n        } catch ( NoSuchElementException e1 ) {\n          net = new Network( netInfo.getUserName( ), netInfo.getNetworkName( ) );\n        }\n        active.add( net.getName( ) );\n        net.setVlan( netInfo.getVlan() );\n        NetworkToken netToken = new NetworkToken( this.getCluster( ).getName( ), netInfo.getUserName( ), netInfo.getNetworkName( ), netInfo.getVlan( ) );\n        netToken = net.addTokenIfAbsent( netToken );\n      }\n      \n      for( Network net : Networks.getInstance( ).listValues( Networks.State.ACTIVE ) ) {\n        net.trim( reply.getAddrsPerNetwork( ) );\n        if( net.hasToken( this.getCluster( ).getName( ) ) ) continue;\n        try {\n          Clusters.sendClusterEvent( this.getCluster( ), this.getStopCallback( net ) );\n          if( !net.hasTokens( ) ) {\n            Networks.getInstance( ).setState( net.getName( ), Networks.State.DISABLED );\n            this.getCluster( ).getState( ).releaseNetworkAllocation( net.getName( ) );\n          }\n        } catch ( NoSuchElementException e1 ) {\n          LOG.debug( e1, e1 );\n        }\n      }\n      List<Cluster> ccList = Clusters.getInstance( ).listValues( );\n      int ccNum = ccList.size( );\n      for ( Cluster c : ccList ) {\n        ccNum -= c.getState( ).getMode( );\n      }\n      if ( ccNum != 0 ) {\n        EucalyptusProperties.disableNetworking = true;\n      } else {\n        EucalyptusProperties.disableNetworking = false;\n      }\n      this.verified = true;\n    } else {\n      LOG.warn( \"Received unknown message type. \" + e.getMessage( ) );\n    }\n  }","commit_id":"a93e92a7abe3a1fadc2b61c6936cfc242aa555c4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void returnPublicAddress( final VmInstance vm ) {\n    for ( Address address : Addresses.getInstance( ).listValues( ) ) {\n      if ( vm.getInstanceId( ).equals( address.getInstanceId( ) ) ) {\n        if ( address.isSystemAllocated( ) ) {\n          AddressUtil.releaseAddress( address );\n        }\n      } else {\n        try {\n          if( address.isAssigned( ) ) {\n            AddressUtil.unassignAddressFromVm( address, vm );\n          }\n        } catch ( Throwable e ) {\n          LOG.debug( e, e );\n        }\n      }\n    }\n  }","id":30801,"modified_method":"private static void returnPublicAddress( final VmInstance vm ) {\n    try {\n      Address address = Addresses.getInstance( ).lookup( vm.getNetworkConfig( ).getIgnoredPublicIp( ) );\n      if(vm.getNetworkConfig( ).getIpAddress( ).equals( address.getInstanceAddress( ) ) ) {\n        if ( address.isSystemAllocated( ) ) {\n          AddressUtil.releaseAddress( address );\n        } else {\n          try {\n            if ( address.isAssigned( ) ) {\n              AddressUtil.unassignAddressFromVm( address, vm );\n            }\n          } catch ( Throwable e ) {\n            LOG.debug( e, e );\n          }\n        }\n        \n      }\n    } catch ( NoSuchElementException e1 ) {\n      LOG.debug( e1, e1 );\n    }\n  }","commit_id":"a93e92a7abe3a1fadc2b61c6936cfc242aa555c4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static TerminateInstancesResponseType handle( TerminateInstancesType request ) throws Exception {\n    TerminateInstancesResponseType reply = ( TerminateInstancesResponseType ) request.getReply( );\n    reply.set_return( true );\n    \n    if ( request.isAdministrator( ) ) {\n      for ( String instanceId : request.getInstancesSet( ) ) {\n        try {\n          VmInstance v = VmInstances.getInstance( ).lookup( instanceId );\n          reply.getInstancesSet( ).add(\n                                        new TerminateInstancesItemType( v.getInstanceId( ), v.getState( ).getCode( ),\n                                          v.getState( ).getName( ), VmState.SHUTTING_DOWN.getCode( ),\n                                          VmState.SHUTTING_DOWN.getName( ) ) );\n          v.setState( VmState.SHUTTING_DOWN );\n          v.resetStopWatch( );\n          SystemState.returnPublicAddress( v );\n          SystemState.returnNetworkIndex( v );\n          SystemState.cleanUp( v );\n        } catch ( NoSuchElementException e ) {\n          try {\n            VmInstance v = VmInstances.getInstance( ).lookupDisabled( instanceId );\n            v.setState( VmState.BURIED );\n          } catch ( NoSuchElementException e1 ) {\n            LOG.debug( e, e );\n          }\n          //Bug #334650: uncomment the following if it should throw an exception\n          //          throw new EucalyptusCloudException( e.getMessage() );\n        }\n      }\n      return reply;\n    }\n    \n    StateSnapshot state = SystemState.getSnapshot( RULE_FILE );\n    try {\n      QueryResults res = state.findInstances( request.getUserId( ), request.getInstancesSet( ) );\n      if ( res.size( ) == 0 )\n        reply.set_return( false );\n      else {\n        Iterator iter = res.iterator( );\n        while ( iter.hasNext( ) ) {\n          QueryResult result = ( QueryResult ) iter.next( );\n          VmInstance v = ( VmInstance ) result.get( \"vm\" );\n          \n          SystemState.returnPublicAddress( v );\n          SystemState.returnNetworkIndex( v );\n          reply.getInstancesSet( ).add(\n                                        new TerminateInstancesItemType( v.getInstanceId( ), v.getState( ).getCode( ),\n                                          v.getState( ).getName( ), VmState.SHUTTING_DOWN.getCode( ),\n                                          VmState.SHUTTING_DOWN.getName( ) ) );\n          v.setState( VmState.SHUTTING_DOWN );\n          v.resetStopWatch( );\n          SystemState.cleanUp( v );\n        }\n      }\n    } catch ( Exception e ) {\n      LOG.debug( e, e );\n      //Bug #334650: uncomment the following if it should throw an exception\n      //      throw new EucalyptusCloudException( e );\n    } finally {\n      state.destroy( );\n    }\n    return reply;\n  }","id":30802,"modified_method":"public static TerminateInstancesResponseType handle( TerminateInstancesType request ) throws Exception {\n    TerminateInstancesResponseType reply = ( TerminateInstancesResponseType ) request.getReply( );\n    reply.set_return( true );\n    \n    for ( String instanceId : request.getInstancesSet( ) ) {\n      try {\n        VmInstance v = VmInstances.getInstance( ).lookup( instanceId );\n        if ( request.isAdministrator( ) || v.getOwnerId( ).equals( request.getUserId( ) ) ) {\n          reply.getInstancesSet( ).add(\n                                        new TerminateInstancesItemType( v.getInstanceId( ), v.getState( ).getCode( ),\n                                          v.getState( ).getName( ), VmState.SHUTTING_DOWN.getCode( ),\n                                          VmState.SHUTTING_DOWN.getName( ) ) );\n          v.setState( VmState.SHUTTING_DOWN );\n          v.resetStopWatch( );\n          SystemState.returnPublicAddress( v );\n          SystemState.returnNetworkIndex( v );\n          SystemState.cleanUp( v );\n        }\n      } catch ( NoSuchElementException e ) {\n        try {\n          VmInstance v = VmInstances.getInstance( ).lookupDisabled( instanceId );\n          v.setState( VmState.BURIED );\n        } catch ( NoSuchElementException e1 ) {\n          //no such instance.\n        }\n      }\n    }\n    return reply;\n  }","commit_id":"a93e92a7abe3a1fadc2b61c6936cfc242aa555c4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void returnNetworkIndex( final VmInstance vm ) {\n    try {\n      Networks.getInstance( ).lookup( vm.getNetworkNames( ).get( 0 ) ).returnNetworkIndex( vm.getNetworkIndex( ) );\n    } catch ( NoSuchElementException e1 ) {\n      LOG.debug( e1 );\n    }\n  }","id":30803,"modified_method":"private static void returnNetworkIndex( final VmInstance vm ) {\n    try {\n      Networks.getInstance( ).lookup( vm.getNetworkNames( ).get( 0 ) ).returnNetworkIndex( vm.getNetworkIndex( ) );\n    } catch ( NoSuchElementException e1 ) {\n      LOG.debug( e1, e1 );\n    }\n  }","commit_id":"a93e92a7abe3a1fadc2b61c6936cfc242aa555c4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeSecurityGroupsResponseType describe( DescribeSecurityGroupsType request ) throws EucalyptusCloudException {\n    NetworkGroupUtil.makeDefault( request.getUserId( ) );//ensure the default group exists to cover some old broken installs\n    DescribeSecurityGroupsResponseType reply = ( DescribeSecurityGroupsResponseType ) request.getReply();\n    if( request.isAdministrator( ) && !request.getSecurityGroupSet( ).isEmpty( ) ) {\n      try {\n        reply.getSecurityGroupInfo( ).addAll( NetworkGroupUtil.getUserNetworksAdmin( request.getUserId( ), request.getSecurityGroupSet( ) ) );\n      } catch ( Exception e ) {\n        LOG.debug( e, e );\n      }\n    } else {\n      try {\n        reply.getSecurityGroupInfo( ).addAll( NetworkGroupUtil.getUserNetworks( request.getUserId( ), request.getSecurityGroupSet( ) ) );\n      } catch ( Exception e ) {\n        LOG.debug( e, e );\n      }\n    }\n    return reply;\n  }","id":30804,"modified_method":"public DescribeSecurityGroupsResponseType describe( DescribeSecurityGroupsType request ) throws EucalyptusCloudException {\n    NetworkGroupUtil.makeDefault( request.getUserId( ) );//ensure the default group exists to cover some old broken installs\n    DescribeSecurityGroupsResponseType reply = ( DescribeSecurityGroupsResponseType ) request.getReply();\n    if( request.isAdministrator( ) ) {\n      try {\n        reply.getSecurityGroupInfo( ).addAll( NetworkGroupUtil.getUserNetworksAdmin( request.getUserId( ), request.getSecurityGroupSet( ) ) );\n      } catch ( Exception e ) {\n        LOG.debug( e, e );\n      }\n    } else {\n      try {\n        reply.getSecurityGroupInfo( ).addAll( NetworkGroupUtil.getUserNetworks( request.getUserId( ), request.getSecurityGroupSet( ) ) );\n      } catch ( Exception e ) {\n        LOG.debug( e, e );\n      }\n    }\n    return reply;\n  }","commit_id":"27d98dfabdaa258510d2ec9671a32f70a71d1688","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static List<SecurityGroupItemType> getUserNetworksAdmin( String userId, List<String> groupNames ) throws EucalyptusCloudException {\n    List<SecurityGroupItemType> groupInfoList = Lists.newArrayList( );\n    if ( groupNames.isEmpty( ) ) {\n      return NetworkGroupUtil.getUserNetworks( userId, groupNames );\n    } else {\n      for ( String groupName : groupNames ) {\n        if ( NetworkGroupUtil.isUserGroupRef( groupName ) ) {\n          groupInfoList.addAll( NetworkGroupUtil.getUserNetworks( userId, Lists.newArrayList( groupName ) ) );\n        } else {\n          groupInfoList.addAll( NetworkGroupUtil.getUserNetworksAdmin( groupName ) );\n        }\n      }\n    }\n    return groupInfoList;\n  }","id":30805,"modified_method":"public static List<SecurityGroupItemType> getUserNetworksAdmin( String userId, List<String> groupNames ) throws EucalyptusCloudException {\n    List<SecurityGroupItemType> groupInfoList = Lists.newArrayList( );\n    if ( groupNames.isEmpty( ) ) {\n      for( User u : CredentialProvider.getAllUsers( ) ) {\n        groupInfoList.addAll( NetworkGroupUtil.getUserNetworks( u.getUserName( ), groupNames ) );        \n      }\n    } else {\n      for ( String groupName : groupNames ) {\n        if ( NetworkGroupUtil.isUserGroupRef( groupName ) ) {\n          groupInfoList.addAll( NetworkGroupUtil.getUserNetworks( userId, Lists.newArrayList( groupName ) ) );\n        } else {\n          groupInfoList.addAll( NetworkGroupUtil.getUserNetworksAdmin( groupName ) );\n        }\n      }\n    }\n    return groupInfoList;\n  }","commit_id":"27d98dfabdaa258510d2ec9671a32f70a71d1688","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeAvailabilityZonesResponseType DescribeAvailabilityZones( DescribeAvailabilityZonesType request ) {\n    DescribeAvailabilityZonesResponseType reply = ( DescribeAvailabilityZonesResponseType ) request.getReply();\n    if ( request.isAdministrator() && request.getAvailabilityZoneSet().lastIndexOf( \"help\" ) == 0 ) {\n      reply.getAvailabilityZoneInfo().addAll( this.addHelpInfo() );\n      return reply;\n    }\n    for( String clusterName : request.getAvailabilityZoneSet( ) ) {\n      try {\n        Cluster c = Clusters.getInstance( ).lookup( clusterName );\n      } catch ( NoSuchElementException e ) {\n        for( Cluster c : Clusters.getInstance( ).listValues( ) ) {\n          reply.getAvailabilityZoneInfo( ).add( new ClusterInfoType( c.getConfiguration( ).getName( ), c.getConfiguration( ).getHostName( ) ) );\n          NavigableSet<String> tagList = new ConcurrentSkipListSet<String>( request.getAvailabilityZoneSet() );\n          if ( tagList.size() == 1 ) tagList = c.getNodeTags();\n          else\n            tagList.retainAll( c.getNodeTags() );\n          if ( request.isAdministrator() && clusterName.equals( \"verbose\" ) ) {\n            reply.getAvailabilityZoneInfo().addAll( this.addSystemInfo( c ) );\n          } else if ( request.isAdministrator() && clusterName.equals( \"certs\" ) ) {\n            for ( String tag : tagList ) {\n              reply.getAvailabilityZoneInfo( ).addAll( this.addCertInfo( tag, c ) );\n            }\n          } else if ( request.isAdministrator() && clusterName.equals( \"logs\" )  ) {\n            for ( String tag : tagList ) {\n              reply.getAvailabilityZoneInfo().addAll( this.addLogInfo( tag, c ) );\n            }\n          }\n        }\n        if ( request.isAdministrator() && clusterName.equals( \"coredump\" ) ) {\n          DebugUtil.printDebugDetails( );\n          reply.getAvailabilityZoneInfo().addAll( this.dumpState() );\n        }\n      }\n    }\n    return reply;\n  }","id":30806,"modified_method":"public DescribeAvailabilityZonesResponseType DescribeAvailabilityZones( DescribeAvailabilityZonesType request ) {\n    DescribeAvailabilityZonesResponseType reply = ( DescribeAvailabilityZonesResponseType ) request.getReply();\n    if ( request.isAdministrator() && request.getAvailabilityZoneSet().lastIndexOf( \"help\" ) == 0 ) {\n      reply.getAvailabilityZoneInfo().addAll( this.addHelpInfo() );\n      return reply;\n    }\n    if( request.getAvailabilityZoneSet( ).isEmpty( ) ) {\n      for( Cluster c : Clusters.getInstance( ).listValues( ) ) {\n        this.getDescriptionEntry( reply, c, request.isAdministrator( ) );\n      }\n    }\n    for( String clusterName : request.getAvailabilityZoneSet( ) ) {\n      try {\n        this.getDescriptionEntry( reply, Clusters.getInstance( ).lookup( clusterName ), request.isAdministrator( ) );\n      } catch ( NoSuchElementException e ) {\n        if ( clusterName.equals( \"coredump\" ) ) {\n          DebugUtil.printDebugDetails( );\n          reply.getAvailabilityZoneInfo().addAll( this.dumpState() );\n        }\n      }\n    }\n    return reply;\n  }","commit_id":"aa8aced3eac08564906e167e57d7fa7879212343","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void truncatePreds(DTree[] ktrees, int[] leafs,   final IcedHashMap<IcedLong, IcedDouble> minValues,\n                               final IcedHashMap<IcedLong, IcedDouble> maxValues) {\n      assert(_nclass == 1);\n      final DTree tree = ktrees[0];\n      assert (tree != null);\n      IcedLong nidx = new IcedLong(0);\n      //loop over leaf nodes only\n      for (int i = 0; i < tree._len - leafs[0]; i++) {\n        final LeafNode node = ((LeafNode) tree.node(leafs[0] + i));\n        nidx._val = node.nid();\n        double nodeMax = maxValues.get(nidx)._val;\n        if (nodeMax + node._pred > Distribution.MAX_LOG) {\n          node._pred = (float)(Distribution.MAX_LOG - nodeMax);\n        }\n        double nodeMin = minValues.get(nidx)._val;\n        if (nodeMin + node._pred < Distribution.MIN_LOG) {\n          node._pred = (float)(Distribution.MIN_LOG - nodeMin);\n        }\n      }\n    }","id":30807,"modified_method":"private void truncatePreds(DTree[] ktrees, int[] leafs,   final IcedHashMap<IcedLong, IcedDouble> minValues,\n                               final IcedHashMap<IcedLong, IcedDouble> maxValues) {\n      assert(_nclass == 1);\n      final DTree tree = ktrees[0];\n      assert (tree != null);\n      IcedLong nidx = new IcedLong(0);\n      //loop over leaf nodes only\n      for (int i = 0; i < tree._len - leafs[0]; i++) {\n        final LeafNode node = ((LeafNode) tree.node(leafs[0] + i));\n        nidx._val = node.nid();\n        IcedDouble nodeMax = maxValues.get(nidx);\n        if (nodeMax != null) {\n          if (nodeMax._val + node._pred > MAX_LOG_TRUNC) {\n            node._pred = (float) (MAX_LOG_TRUNC - nodeMax._val);\n          }\n        }\n        IcedDouble nodeMin = minValues.get(nidx);\n        if (nodeMin != null) {\n          if (nodeMin._val + node._pred < MIN_LOG_TRUNC) {\n            node._pred = (float) (MIN_LOG_TRUNC - nodeMin._val);\n          }\n        }\n      }\n    }","commit_id":"489a50e261f14d4c85d71370a1b5e2b6505bad6d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map( Chunk chks[] ) {\n        minValues = new IcedHashMap<>();\n        maxValues = new IcedHashMap<>();\n        Chunk ys = chk_resp(chks);\n        Chunk offset = hasOffsetCol() ? chk_offset(chks) : new C0DChunk(0, chks[0]._len);\n        Chunk tr = chk_tree(chks, 0); // Prior tree sums\n        Chunk nids = chk_nids(chks, 0);\n        IcedLong nidx = new IcedLong(0);\n        for( int row = 0; row < tr._len; row++) {\n          if( ys.isNA(row) ) continue;\n          double f = tr.atd(row) + offset.atd(row);\n          nidx._val = nids.at8(row);\n          IcedDouble mins = minValues.get(nidx);\n          double oldMin = mins == null ? Double.MAX_VALUE : mins._val;\n          IcedDouble ff = new IcedDouble(f);\n          if (f < oldMin) {\n            if (mins == null) minValues.put(nidx, ff);\n            else minValues.replace(nidx, ff);\n          }\n          IcedDouble maxs = maxValues.get(nidx);\n          double oldMax = maxs == null ? -Double.MAX_VALUE : maxs._val;\n          if (f > oldMax) {\n            if (maxs == null) maxValues.put(nidx, ff);\n            else maxValues.replace(nidx, ff);\n          }\n        }\n      }","id":30808,"modified_method":"@Override public void map( Chunk chks[] ) {\n        minValues = new IcedHashMap<>();\n        maxValues = new IcedHashMap<>();\n        Chunk ys = chk_resp(chks);\n        Chunk offset = hasOffsetCol() ? chk_offset(chks) : new C0DChunk(0, chks[0]._len);\n        Chunk tr = chk_tree(chks, 0); // Prior tree sums\n        Chunk nids = chk_nids(chks, 0);\n        for( int row = 0; row < tr._len; row++) {\n          if( ys.isNA(row) ) continue;\n          double f = tr.atd(row) + offset.atd(row);\n          IcedLong nidx = new IcedLong(nids.at8(row));\n          IcedDouble mins = minValues.get(nidx);\n          double oldMin = mins == null ? Double.MAX_VALUE : mins._val;\n          if (f < oldMin) {\n            IcedDouble ff = new IcedDouble(f);\n            if (mins == null) minValues.put(nidx, ff);\n            else minValues.replace(nidx, ff);\n          }\n          IcedDouble maxs = maxValues.get(nidx);\n          double oldMax = maxs == null ? -Double.MAX_VALUE : maxs._val;\n          if (f > oldMax) {\n            IcedDouble ff = new IcedDouble(f);\n            if (maxs == null)  maxValues.put(nidx, ff);\n            else maxValues.replace(nidx, ff);\n          }\n        }\n      }","commit_id":"489a50e261f14d4c85d71370a1b5e2b6505bad6d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void buildNextKTrees() {\n      // We're going to build K (nclass) trees - each focused on correcting\n      // errors for a single class.\n      final DTree[] ktrees = new DTree[_nclass];\n\n      // Define a \"working set\" of leaf splits, from here to tree._len\n      int[] leafs = new int[_nclass];\n\n      // ----\n      // ESL2, page 387.  Step 2b ii.\n      // One Big Loop till the ktrees are of proper depth.\n      // Adds a layer to the trees each pass.\n      growTrees(ktrees, leafs);\n\n      // ----\n      // ESL2, page 387.  Step 2b iii.  Compute the gammas (leaf node predictions === fit best constant), and store them back\n      // into the tree leaves.  Includes learn_rate.\n      fitBestConstants(ktrees, leafs, new GammaPass(ktrees, leafs, _parms._distribution).doAll(_train));\n      if (_parms._distribution == Distribution.Family.gamma ||\n              _parms._distribution == Distribution.Family.poisson ||\n              _parms._distribution == Distribution.Family.tweedie ) {\n        ComputeMinMax minMax = new ComputeMinMax().doAll(_train);\n        truncatePreds(ktrees, leafs, minMax.minValues, minMax.maxValues);\n      }\n\n      // ----\n      // ESL2, page 387.  Step 2b iv.  Cache the sum of all the trees, plus the\n      // new tree, in the 'tree' columns.  Also, zap the NIDs for next pass.\n      // Tree <== f(Tree)\n      // Nids <== 0\n      new AddTreeContributions(ktrees).doAll(_train);\n\n      // Grow the model by K-trees\n      _model._output.addKTrees(ktrees);\n    }","id":30809,"modified_method":"private void buildNextKTrees() {\n      // We're going to build K (nclass) trees - each focused on correcting\n      // errors for a single class.\n      final DTree[] ktrees = new DTree[_nclass];\n\n      // Define a \"working set\" of leaf splits, from here to tree._len\n      int[] leafs = new int[_nclass];\n\n      // ----\n      // ESL2, page 387.  Step 2b ii.\n      // One Big Loop till the ktrees are of proper depth.\n      // Adds a layer to the trees each pass.\n      growTrees(ktrees, leafs);\n\n      // ----\n      // ESL2, page 387.  Step 2b iii.  Compute the gammas (leaf node predictions === fit best constant), and store them back\n      // into the tree leaves.  Includes learn_rate.\n      fitBestConstants(ktrees, leafs, new GammaPass(ktrees, leafs, _parms._distribution).doAll(_train));\n      if (_parms._distribution == Distribution.Family.gamma ||\n              _parms._distribution == Distribution.Family.poisson ||\n              _parms._distribution == Distribution.Family.tweedie ) {\n        ComputeMinMax minMax = new ComputeMinMax().doAll(_train);\n        assert(minMax.minValues.size() == minMax.maxValues.size());\n        Log.info(\"Number of leaf nodes: \" + minMax.minValues.size());\n        Log.info(\"Min: \" + java.util.Arrays.deepToString(minMax.minValues.entrySet().toArray()));\n        Log.info(\"Max: \" + java.util.Arrays.deepToString(minMax.maxValues.entrySet().toArray()));\n        truncatePreds(ktrees, leafs, minMax.minValues, minMax.maxValues);\n      }\n\n      // ----\n      // ESL2, page 387.  Step 2b iv.  Cache the sum of all the trees, plus the\n      // new tree, in the 'tree' columns.  Also, zap the NIDs for next pass.\n      // Tree <== f(Tree)\n      // Nids <== 0\n      new AddTreeContributions(ktrees).doAll(_train);\n\n      // Grow the model by K-trees\n      _model._output.addKTrees(ktrees);\n    }","commit_id":"489a50e261f14d4c85d71370a1b5e2b6505bad6d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n      public void reduce(ComputeMinMax mrt) {\n        for (Map.Entry<IcedLong,IcedDouble> e : mrt.minValues.entrySet()) {\n          IcedDouble x = minValues.get(e.getKey());\n          if (x != null) {\n            x._val=Math.min(e.getValue()._val, x._val);\n          } else {\n            minValues.put(e.getKey(), e.getValue());\n          }\n        }\n        for (Map.Entry<IcedLong,IcedDouble> e : mrt.maxValues.entrySet()) {\n          IcedDouble x = maxValues.get(e.getKey());\n          if (x != null) {\n            x._val=Math.max(e.getValue()._val, x._val);\n          } else {\n            maxValues.put(e.getKey(), e.getValue());\n          }\n        }\n        mrt.minValues = null;\n        mrt.maxValues = null;\n      }","id":30810,"modified_method":"@Override\n      public void reduce(ComputeMinMax mrt) {\n        for (Map.Entry<IcedLong,IcedDouble> e : mrt.minValues.entrySet()) {\n          IcedDouble x = minValues.get(e.getKey());\n          if (x != null) {\n            x._val= Math.min(e.getValue()._val, x._val);\n            minValues.replace(e.getKey(), x);\n          } else {\n            assert(minValues.get(e.getKey()) == null);\n            minValues.putIfAbsent(e.getKey(), e.getValue());\n          }\n        }\n        for (Map.Entry<IcedLong,IcedDouble> e : mrt.maxValues.entrySet()) {\n          IcedDouble x = maxValues.get(e.getKey());\n          if (x != null) {\n            x._val= Math.max(e.getValue()._val, x._val);\n            maxValues.replace(e.getKey(), x);\n          } else {\n            assert(maxValues.get(e.getKey()) == null);\n            maxValues.putIfAbsent(e.getKey(), e.getValue());\n          }\n        }\n        mrt.minValues = null;\n        mrt.maxValues = null;\n      }","commit_id":"489a50e261f14d4c85d71370a1b5e2b6505bad6d","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void pingBy(long agentId) {\n        _pingMap.put(agentId, InaccurateClock.getTimeInSeconds());\n    }","id":30811,"modified_method":"public void pingBy(long agentId) {\n        // Update PingMap with the latest time if agent entry exists in the PingMap\n        if (_pingMap.replace(agentId, InaccurateClock.getTimeInSeconds()) == null) {\n            s_logger.info(\"PingMap for agent: \" + agentId + \" will not be updated because agent is no longer in the PingMap\");\n        }\n    }","commit_id":"8ce6eba549bcd3fa007aaf10a29c3a2fef9ffaaa","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * Returns the status icon for this MetaContact.\n     *\n     * @param contact The metaContact for which the status icon is asked.\n     * @return the status icon for this MetaContact.\n     */\n    public ImageIcon getMetaContactStatusIcon(MetaContact contact)\n    {\n        return new ImageIcon(Constants.getStatusIcon(this\n            .getMetaContactStatus(contact)));\n    }","id":30812,"modified_method":"/**\n     * Returns the status icon for this MetaContact.\n     *\n     * @param contact The metaContact for which the status icon is asked.\n     * @return the status icon for this MetaContact.\n     */\n    public ImageIcon getMetaContactStatusIcon(MetaContact contact)\n    {\n        BufferedImage statusImage = Constants.getStatusIcon(this\n                .getMetaContactStatus(contact));\n     \n        WritableRaster raster = statusImage.copyData( null );\n        BufferedImage statusImageCopy = new BufferedImage(\n                statusImage.getColorModel(),\n                raster,\n                statusImage.isAlphaPremultiplied(), null );\n        \n        Graphics g = statusImageCopy.getGraphics();\n        \n        g.drawImage(statusImage, 0, 0, null);\n        \n        if(activeContacts.contains(contact))\n        {   \n            Image msgReceivedImage\n                = ImageLoader.getImage(ImageLoader.MESSAGE_RECEIVED_ICON);\n            \n            g.drawImage(msgReceivedImage, 0,\n                5,\n                null);\n        }\n        \n        ImageIcon statusIcon = new ImageIcon(statusImageCopy);\n        \n        return statusIcon;\n    }","commit_id":"73a0a4408490fe8973b966064bed9acb7ee8bb7f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * When a message is received determines whether to open a new chat window\n     * or chat window tab, or to indicate that a message is received from a\n     * contact which already has an open chat. When the chat is found checks if\n     * in mode \"Auto popup enabled\" and if this is the case shows the message in\n     * the appropriate chat panel.\n     * \n     * @param evt the event containing details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        logger.trace(\"MESSAGE RECEIVED from contact: \"\n            + evt.getSourceContact().getAddress());\n        \n        Contact protocolContact = evt.getSourceContact();\n        Date date = evt.getTimestamp();\n        Message message = evt.getSourceMessage();\n\n        MetaContact metaContact = mainFrame.getContactList()\n                .findMetaContactByContact(protocolContact);\n        \n        ChatPanel chatPanel = chatWindowManager.getContactChat(\n            metaContact, protocolContact, message.getMessageUID());\n                \n        chatPanel.processMessage(protocolContact.getDisplayName(), date,\n            Constants.INCOMING_MESSAGE, message.getContent());            \n        \n        chatWindowManager.openChat(chatPanel, false);\n        \n        GuiActivator.getAudioNotifier()\n            .createAudio(Sounds.INCOMING_MESSAGE).play();\n        \n        chatPanel.treatReceivedMessage(protocolContact);\n    }","id":30813,"modified_method":"/**\n     * When a message is received determines whether to open a new chat window\n     * or chat window tab, or to indicate that a message is received from a\n     * contact which already has an open chat. When the chat is found checks if\n     * in mode \"Auto popup enabled\" and if this is the case shows the message in\n     * the appropriate chat panel.\n     * \n     * @param evt the event containing details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        logger.trace(\"MESSAGE RECEIVED from contact: \"\n            + evt.getSourceContact().getAddress());\n        \n        Contact protocolContact = evt.getSourceContact();\n        Date date = evt.getTimestamp();\n        Message message = evt.getSourceMessage();\n\n        MetaContact metaContact = mainFrame.getContactList()\n                .findMetaContactByContact(protocolContact);\n        \n        if(metaContact != null)\n        {\n            ContactListModel clistModel = (ContactListModel) contactList.getModel();\n            clistModel.addActiveContact(metaContact);\n            contactList.modifyContact(metaContact);\n            \n            ChatPanel chatPanel = chatWindowManager.getContactChat(\n                metaContact, protocolContact, message.getMessageUID());\n                    \n            chatPanel.processMessage(protocolContact.getDisplayName(), date,\n                Constants.INCOMING_MESSAGE, message.getContent());            \n            \n            chatWindowManager.openChat(chatPanel, false);\n            \n            GuiActivator.getAudioNotifier()\n                .createAudio(Sounds.INCOMING_MESSAGE).play();\n            \n            chatPanel.treatReceivedMessage(protocolContact);\n        }\n        else\n        {\n            logger.trace(\"MetaContact not found for protocol contact: \"\n                    + protocolContact + \".\");\n        }\n    }","commit_id":"73a0a4408490fe8973b966064bed9acb7ee8bb7f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of StatusSelector\n     * \n     * @param jdicSystray a reference of the parent <tt>Systray<\/tt>\n     * @param provider the protocol provider\n     * @param presence the presence status\n     */\n    public StatusSelector(SystrayServiceJdicImpl jdicSystray,\n        ProtocolProviderService provider, OperationSetPresence presence,\n        boolean swing)\n    {\n        this.parentSystray = jdicSystray;\n        this.provider = provider;\n        this.presence = presence;\n\n        /* the parent item */\n        {\n            String text = provider.getAccountID().getUserID();\n            if (swing)\n            {\n                JMenu menu = new JMenu(text);\n                menu.setIcon(new ImageIcon(presence.getPresenceStatus()\n                    .getStatusIcon()));\n\n                this.menu = menu;\n            }\n            else\n            {\n                this.menu = new Menu(text);\n            }\n        }\n\n        /* the submenu itself */\n\n        Iterator<PresenceStatus> statusIterator\n            = this.presence.getSupportedStatusSet();\n\n        while (statusIterator.hasNext())\n        {\n            PresenceStatus status = statusIterator.next();\n            String text = status.getStatusName();\n\n            if (menu instanceof Container)\n            {\n                ImageIcon icon = new ImageIcon(status.getStatusIcon());\n                JMenuItem item = new JMenuItem(text, icon);\n\n                item.addActionListener(this);\n\n                ((Container) menu).add(item);\n            }\n            else\n            {\n                MenuItem item = new MenuItem(text);\n                item.addActionListener(this);\n                ((Menu) menu).add(item);\n            }\n        }\n\n        addSeparator();\n\n        StatusSubMenu.addMenuItem(menu, new StatusMessageMenu(provider, swing)\n            .getMenu());\n    }","id":30814,"modified_method":"/**\n     * Creates an instance of StatusSelector\n     * \n     * @param jdicSystray a reference of the parent <tt>Systray<\/tt>\n     * @param provider the protocol provider\n     * @param presence the presence status\n     */\n    public StatusSelector(SystrayServiceJdicImpl jdicSystray,\n        ProtocolProviderService provider, OperationSetPresence presence,\n        boolean swing)\n    {\n        this.parentSystray = jdicSystray;\n        this.provider = provider;\n        this.presence = presence;\n\n        /* the parent item */\n        {\n            String text = provider.getAccountID().getUserID();\n            if (swing)\n            {\n                JMenu menu = new JMenu(text);\n                byte[] icBytes = presence.getPresenceStatus().getStatusIcon();\n                if(icBytes != null)\n                    menu.setIcon(new ImageIcon(icBytes));\n\n                this.menu = menu;\n            }\n            else\n            {\n                this.menu = new Menu(text);\n            }\n        }\n\n        /* the submenu itself */\n\n        Iterator<PresenceStatus> statusIterator\n            = this.presence.getSupportedStatusSet();\n\n        while (statusIterator.hasNext())\n        {\n            PresenceStatus status = statusIterator.next();\n            String text = status.getStatusName();\n\n            if (menu instanceof Container)\n            {\n                JMenuItem item = new JMenuItem(text);\n\n                byte[] icBytes = status.getStatusIcon();\n                if(icBytes != null)\n                    item.setIcon(new ImageIcon(icBytes));\n\n                item.addActionListener(this);\n\n                ((Container) menu).add(item);\n            }\n            else\n            {\n                MenuItem item = new MenuItem(text);\n                item.addActionListener(this);\n                ((Menu) menu).add(item);\n            }\n        }\n\n        addSeparator();\n\n        StatusSubMenu.addMenuItem(menu, new StatusMessageMenu(provider, swing)\n            .getMenu());\n    }","commit_id":"a077246aee527b37ddaef388a7737ea9ecccb1c0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the status icon for this MetaContact.\n     *\n     * @param contact The metaContact for which the status icon is asked.\n     * @return the status icon for this MetaContact.\n     */\n    public ImageIcon getMetaContactStatusIcon(MetaContact contact)\n    {\n        BufferedImage statusImage = Constants.getStatusIcon(this\n                .getMetaContactStatus(contact));\n\n        WritableRaster raster = statusImage.copyData( null );\n        BufferedImage statusImageCopy = new BufferedImage(\n                statusImage.getColorModel(),\n                raster,\n                statusImage.isAlphaPremultiplied(), null );\n\n        Graphics g = statusImageCopy.createGraphics();\n\n        g.drawImage(statusImage, 0, 0, null);\n\n        if(activeContacts.contains(contact))\n        {\n            Image msgReceivedImage\n                = ImageLoader.getImage(ImageLoader.MESSAGE_RECEIVED_ICON);\n\n            g.drawImage(msgReceivedImage, 0,\n                5,\n                null);\n        }\n\n        ImageIcon statusIcon = new ImageIcon(statusImageCopy);\n\n        return statusIcon;\n    }","id":30815,"modified_method":"/**\n     * Returns the status icon for this MetaContact.\n     *\n     * @param contact The metaContact for which the status icon is asked.\n     * @return the status icon for this MetaContact.\n     */\n    public ImageIcon getMetaContactStatusIcon(MetaContact contact)\n    {\n        Image statusImage;\n\n        if(activeContacts.contains(contact))\n        {\n            statusImage = msgReceivedImage;\n        }\n        else\n        {\n            statusImage = Constants.getStatusIcon(this\n                .getMetaContactStatus(contact));\n        }\n\n        statusIcon.setImage(statusImage);\n\n        return statusIcon;\n    }","commit_id":"4c512408d4f1e70a294e84dabb99a0d3637dd05c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Obtains the status icon for the given chat transport and\n     * adds to it the account index information.\n     *\n     * @param chatTransport The chat transport for which to create the image.\n     * @return The indexed status image.\n     */\n    public Image createTransportStatusImage(ChatTransport chatTransport)\n    {\n        return\n            ImageLoader.badgeImageWithProtocolIndex(\n                ImageUtils.getBytesInImage(\n                    chatTransport.getStatus().getStatusIcon()),\n                chatTransport.getProtocolProvider());\n    }","id":30816,"modified_method":"/**\n     * Obtains the status icon for the given chat transport and\n     * adds to it the account index information.\n     *\n     * @param chatTransport The chat transport for which to create the image.\n     * @return The indexed status image.\n     */\n    public Image createTransportStatusImage(ChatTransport chatTransport)\n    {\n        return\n            ImageLoader.getIndexedProtocolImage(\n                ImageUtils.getBytesInImage(\n                    chatTransport.getStatus().getStatusIcon()),\n                chatTransport.getProtocolProvider());\n    }","commit_id":"934f576fa676a13e3fbdfa1fbd611fee6a52f48c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Reloads transport icon.\n         */\n        public void loadSkin()\n        {\n            PresenceStatus status = chatTransport.getStatus();\n            Image statusIcon = null;\n\n            statusIcon = ImageLoader.badgeImageWithProtocolIndex(\n                    ImageUtils.getBytesInImage(\n                            status.getStatusIcon()),\n                            chatTransport.getProtocolProvider());\n\n            if (statusIcon != null)\n                this.setIcon(new ImageIcon(statusIcon));\n        }","id":30817,"modified_method":"/**\n         * Reloads transport icon.\n         */\n        public void loadSkin()\n        {\n            PresenceStatus status = chatTransport.getStatus();\n            Image statusIcon = null;\n\n            statusIcon = ImageLoader.getIndexedProtocolImage(\n                    ImageUtils.getBytesInImage(\n                            status.getStatusIcon()),\n                            chatTransport.getProtocolProvider());\n\n            if (statusIcon != null)\n                this.setIcon(new ImageIcon(statusIcon));\n        }","commit_id":"934f576fa676a13e3fbdfa1fbd611fee6a52f48c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Obtains the indexed status image for the given protocol provider.\n     *\n     * @param pps the protocol provider for which to create the image\n     *\n     * @return the indexed status image\n     */\n    public static ImageIcon getAccountStatusImage(ProtocolProviderService pps)\n    {\n        ImageIcon statusIcon;\n\n        OperationSetPresence presence\n            = pps.getOperationSet(OperationSetPresence.class);\n\n        Image statusImage;\n        if (presence != null)\n        {\n            statusImage = ImageUtils.getBytesInImage(\n                presence.getPresenceStatus().getStatusIcon());\n        }\n        else\n        {\n            statusImage\n                = ImageUtils.getBytesInImage(pps.getProtocolIcon().getIcon(\n                    ProtocolIcon.ICON_SIZE_16x16));\n\n            if (!pps.isRegistered())\n            {\n                statusImage\n                    = LightGrayFilter.createDisabledImage(statusImage);\n            }\n        }\n\n        statusIcon = new ImageIcon(\n            badgeImageWithProtocolIndex(statusImage, pps));\n\n        return statusIcon;\n    }","id":30818,"modified_method":"/**\n     * Obtains the indexed status image for the given protocol provider.\n     *\n     * @param pps the protocol provider for which to create the image\n     *\n     * @return the indexed status image\n     */\n    public static ImageIcon getAccountStatusImage(ProtocolProviderService pps)\n    {\n        ImageIcon statusIcon;\n\n        OperationSetPresence presence\n            = pps.getOperationSet(OperationSetPresence.class);\n\n        Image statusImage;\n        if (presence != null)\n        {\n            statusImage = ImageUtils.getBytesInImage(\n                presence.getPresenceStatus().getStatusIcon());\n        }\n        else\n        {\n            statusImage\n                = ImageUtils.getBytesInImage(pps.getProtocolIcon().getIcon(\n                    ProtocolIcon.ICON_SIZE_16x16));\n\n            if (!pps.isRegistered())\n            {\n                statusImage\n                    = LightGrayFilter.createDisabledImage(statusImage);\n            }\n        }\n\n        statusIcon = new ImageIcon(\n            getIndexedProtocolImage(statusImage, pps));\n\n        return statusIcon;\n    }","commit_id":"934f576fa676a13e3fbdfa1fbd611fee6a52f48c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Badges the given protocol image with an index allowing to distinguish\n     * different accounts from the same protocol.\n     *\n     * @param image the initial image to badge with an index\n     * @param pps the protocol provider service corresponding to the account,\n     * containing the index.\n     * @return the given protocol image with an index allowing to distinguish\n     * different accounts from the same protocol.\n     */\n    public static Image badgeImageWithProtocolIndex(\n            Image image, ProtocolProviderService pps)\n    {\n        int index\n            = GuiActivator.getUIService().getMainFrame().getProviderIndex(pps);\n        Image badged;\n\n        if (index > 0)\n        {\n            BufferedImage buffImage =\n                new BufferedImage(22, 16, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = (Graphics2D) buffImage.getGraphics();\n\n            AntialiasingManager.activateAntialiasing(g);\n            g.setColor(Color.DARK_GRAY);\n            g.setFont(Constants.FONT.deriveFont(Font.BOLD, 9));\n            g.drawImage(image, 0, 0, null);\n            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));\n            g.drawString(Integer.toString(index + 1), 14, 8);\n\n            badged = buffImage;\n        }\n        else\n            badged = image;\n        return badged;\n    }","id":30819,"modified_method":"/**\n     * Returns the given protocol image with an index allowing to distinguish\n     * different accounts from the same protocol.\n     *\n     * @param image the initial image to badge with an index\n     * @param pps the protocol provider service corresponding to the account,\n     * containing the index.\n     * @return the given protocol image with an index allowing to distinguish\n     * different accounts from the same protocol.\n     */\n    public static Image getIndexedProtocolImage(\n            Image image, ProtocolProviderService pps)\n    {\n        int index\n            = GuiActivator.getUIService().getMainFrame().getProviderIndex(pps);\n        Image badged;\n\n        if (index > 0)\n        {\n            BufferedImage buffImage =\n                new BufferedImage(22, 16, BufferedImage.TYPE_INT_ARGB);\n            Graphics2D g = (Graphics2D) buffImage.getGraphics();\n\n            AntialiasingManager.activateAntialiasing(g);\n            g.setColor(Color.DARK_GRAY);\n            g.setFont(Constants.FONT.deriveFont(Font.BOLD, 9));\n            g.drawImage(image, 0, 0, null);\n            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));\n            g.drawString(Integer.toString(index + 1), 14, 8);\n\n            badged = buffImage;\n        }\n        else\n            badged = image;\n        return badged;\n    }","commit_id":"934f576fa676a13e3fbdfa1fbd611fee6a52f48c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Obtains the status icon for the given protocol contact and\n     * adds to it the account index information.\n     * @param protoContact the protocol contact for which to create the image\n     * @return the indexed status image\n     */\n    public Image createContactStatusImage(Contact protoContact)\n    {\n        return\n            ImageLoader.badgeImageWithProtocolIndex(\n                ImageUtils.getBytesInImage(\n                    protoContact.getPresenceStatus().getStatusIcon()),\n                protoContact.getProtocolProvider());\n    }","id":30820,"modified_method":"/**\n     * Obtains the status icon for the given protocol contact and\n     * adds to it the account index information.\n     * @param protoContact the protocol contact for which to create the image\n     * @return the indexed status image\n     */\n    public Image createContactStatusImage(Contact protoContact)\n    {\n        return\n            ImageLoader.getIndexedProtocolImage(\n                ImageUtils.getBytesInImage(\n                    protoContact.getPresenceStatus().getStatusIcon()),\n                protoContact.getProtocolProvider());\n    }","commit_id":"934f576fa676a13e3fbdfa1fbd611fee6a52f48c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the tool tip opened on mouse over.\n     * @return the tool tip opened on mouse over\n     */\n    public ExtendedTooltip getToolTip()\n    {\n        ExtendedTooltip tip = new ExtendedTooltip(true);\n\n        byte[] avatarImage = metaContact.getAvatar();\n\n        if (avatarImage != null && avatarImage.length > 0)\n            tip.setImage(new ImageIcon(avatarImage));\n\n        tip.setTitle(metaContact.getDisplayName());\n\n        Iterator<Contact> i = metaContact.getContacts();\n\n        String statusMessage = null;\n        Contact protocolContact;\n        while (i.hasNext())\n        {\n            protocolContact = i.next();\n\n            ImageIcon protocolStatusIcon\n                = new ImageIcon(\n                    protocolContact.getPresenceStatus().getStatusIcon());\n\n            String contactAddress = protocolContact.getAddress();\n            //String statusMessage = protocolContact.getStatusMessage();\n\n            tip.addLine(protocolStatusIcon, contactAddress);\n\n            // Set the first found status message.\n            if (statusMessage == null\n                && protocolContact.getStatusMessage() != null\n                && protocolContact.getStatusMessage().length() > 0)\n                statusMessage = protocolContact.getStatusMessage();\n        }\n\n        if (statusMessage != null)\n            tip.setBottomText(statusMessage);\n\n        return tip;\n    }","id":30821,"modified_method":"/**\n     * Returns the tool tip opened on mouse over.\n     * @return the tool tip opened on mouse over\n     */\n    public ExtendedTooltip getToolTip()\n    {\n        ExtendedTooltip tip = new ExtendedTooltip(true);\n\n        byte[] avatarImage = metaContact.getAvatar();\n\n        if (avatarImage != null && avatarImage.length > 0)\n            tip.setImage(new ImageIcon(avatarImage));\n\n        tip.setTitle(metaContact.getDisplayName());\n\n        Iterator<Contact> i = metaContact.getContacts();\n\n        String statusMessage = null;\n        Contact protocolContact;\n        while (i.hasNext())\n        {\n            protocolContact = i.next();\n\n            ImageIcon protocolStatusIcon\n                = ImageLoader.getIndexedProtocolIcon(\n                        ImageUtils.getBytesInImage(\n                            protocolContact.getPresenceStatus().getStatusIcon()),\n                        protocolContact.getProtocolProvider());\n\n            String contactAddress = protocolContact.getAddress();\n            //String statusMessage = protocolContact.getStatusMessage();\n\n            tip.addLine(protocolStatusIcon, contactAddress);\n\n            // Set the first found status message.\n            if (statusMessage == null\n                && protocolContact.getStatusMessage() != null\n                && protocolContact.getStatusMessage().length() > 0)\n                statusMessage = protocolContact.getStatusMessage();\n        }\n\n        if (statusMessage != null)\n            tip.setBottomText(statusMessage);\n\n        return tip;\n    }","commit_id":"934f576fa676a13e3fbdfa1fbd611fee6a52f48c","url":"https://github.com/jitsi/jitsi"},{"original_method":"private Map bindLifecycleForPackaging( MavenSession session, String selectedPhase, MavenProject project )\n        throws ArtifactResolutionException, LifecycleExecutionException\n    {\n        Map mappings;\n        String packaging = project.getPackaging();\n        try\n        {\n            LifecycleMapping m = (LifecycleMapping) session.lookup( LifecycleMapping.ROLE, packaging );\n            mappings = m.getPhases();\n        }\n        catch ( ComponentLookupException e )\n        {\n            getLogger().error( \"No lifecycle mapping for type '\" + packaging + \"': using defaults\" );\n            mappings = defaultPhases;\n        }\n\n        Map lifecycleMappings = new HashMap();\n\n        boolean finished = false;\n        for ( Iterator i = phases.iterator(); i.hasNext() && !finished; )\n        {\n            String phase = (String) i.next();\n\n            String phaseTasks = (String) mappings.get( phase );\n\n            if ( phaseTasks != null )\n            {\n                for ( StringTokenizer tok = new StringTokenizer( phaseTasks, \",\" ); tok.hasMoreTokens(); )\n                {\n                    String goal = tok.nextToken().trim();\n\n                    MojoDescriptor mojoDescriptor = getMojoDescriptor( goal, session, project );\n                    addToLifecycleMappings( lifecycleMappings, phase, new MojoExecution( mojoDescriptor ), session\n                        .getSettings() );\n                }\n            }\n\n            if ( phase.equals( selectedPhase ) )\n            {\n                finished = true;\n            }\n        }\n\n        return lifecycleMappings;\n    }","id":30822,"modified_method":"private Map bindLifecycleForPackaging( MavenSession session, String selectedPhase, MavenProject project )\n        throws ArtifactResolutionException, LifecycleExecutionException\n    {\n        Map mappings = findMappingsForLifecycle( session, project );\n\n        Map lifecycleMappings = new HashMap();\n\n        for ( Iterator i = phases.iterator(); i.hasNext(); )\n        {\n            String phase = (String) i.next();\n\n            String phaseTasks = (String) mappings.get( phase );\n\n            if ( phaseTasks != null )\n            {\n                for ( StringTokenizer tok = new StringTokenizer( phaseTasks, \",\" ); tok.hasMoreTokens(); )\n                {\n                    String goal = tok.nextToken().trim();\n\n                    MojoDescriptor mojoDescriptor = getMojoDescriptor( goal, session, project );\n                    addToLifecycleMappings( lifecycleMappings, phase, new MojoExecution( mojoDescriptor ), session\n                        .getSettings() );\n                }\n            }\n\n            if ( phase.equals( selectedPhase ) )\n            {\n                break;\n            }\n        }\n\n        return lifecycleMappings;\n    }","commit_id":"0cc696a40788d34edec8df6c147bc9a2a3f831b2","url":"https://github.com/apache/maven"},{"original_method":"private MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project )\n        throws ArtifactResolutionException, LifecycleExecutionException\n    {\n        String goal = null;\n        Plugin plugin = null;\n\n        PluginDescriptor pluginDescriptor = null;\n\n        StringTokenizer tok = new StringTokenizer( task, \":\" );\n        int numTokens = tok.countTokens();\n        if ( numTokens == 2 )\n        {\n            String prefix = tok.nextToken();\n            goal = tok.nextToken();\n\n            // Steps for retrieving the plugin model instance:\n            // 1. request directly from the plugin collector by prefix\n            pluginDescriptor = pluginManager.getPluginDescriptorForPrefix( prefix );\n            \n            if ( pluginDescriptor != null )\n            {\n                plugin = new Plugin();\n                \n                plugin.setGroupId( pluginDescriptor.getGroupId() );\n                plugin.setArtifactId( pluginDescriptor.getArtifactId() );\n                plugin.setVersion( pluginDescriptor.getVersion() );\n            }\n\n            // 2. use the plugin resolver to resolve the prefix in the search groups\n            if ( plugin == null )\n            {\n                PluginMappingManager mappingManager = session.getPluginMappingManager();\n\n                // don't reassemble the plugin mappings if the session has already been configured with them.\n                if ( mappingManager == null )\n                {\n                    try\n                    {\n                        List pluginGroupIds = session.getSettings().getPluginGroups();\n                        List pluginRepositories = project.getPluginArtifactRepositories();\n                        ArtifactRepository localRepository = session.getLocalRepository();\n\n                        mappingManager = pluginMappingBuilder.loadPluginMappings( pluginGroupIds, pluginRepositories,\n                                                                                  localRepository );\n                        \n                        // lazily configure this on the session.\n                        session.setPluginMappingManager( mappingManager );\n                    }\n                    catch ( RepositoryMetadataManagementException e )\n                    {\n                        throw new LifecycleExecutionException( \"Cannot load plugin mappings.\", e );\n                    }\n                    catch ( PluginMappingManagementException e )\n                    {\n                        throw new LifecycleExecutionException( \"Cannot load plugin mappings.\", e );\n                    }\n                }\n\n                plugin = mappingManager.getByPrefix( prefix );\n            }\n\n            // 3. default to o.a.m.plugins and maven-<prefix>-plugin\n            if ( plugin == null )\n            {\n                plugin = new Plugin();\n                plugin.setGroupId( PluginDescriptor.getDefaultPluginGroupId() );\n                plugin.setArtifactId( PluginDescriptor.getDefaultPluginArtifactId( prefix ) );\n            }\n\n            for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n            {\n                Plugin buildPlugin = (Plugin) i.next();\n\n                if ( buildPlugin.getKey().equals( plugin.getKey() ) )\n                {\n                    plugin = buildPlugin;\n                    break;\n                }\n            }\n        }\n        else if ( numTokens == 4 )\n        {\n            plugin = new Plugin();\n            \n            plugin.setGroupId( tok.nextToken() );\n            plugin.setArtifactId( tok.nextToken() );\n            plugin.setVersion( tok.nextToken() );\n\n            goal = tok.nextToken();\n        }\n        else\n        {\n            String message = \"Invalid task '\" + task + \"': you must specify a valid lifecycle phase, or\"\n                + \" a goal in the format plugin:goal or pluginGroupId:pluginArtifactId:pluginVersion:goal\";\n            throw new LifecycleExecutionException( message );\n        }\n\n        if ( pluginDescriptor == null )\n        {\n            try\n            {\n                pluginDescriptor = pluginManager.verifyPlugin( plugin, project, session.getSettings(), session\n                    .getLocalRepository() );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new LifecycleExecutionException( \"Internal error in the plugin manager\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new LifecycleExecutionException( \"Error resolving plugin version\", e );\n            }\n        }\n\n        injectHandlerPluginConfiguration( project, plugin );\n\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( goal );\n        if ( mojoDescriptor == null )\n        {\n            throw new LifecycleExecutionException( \"Required goal not found: \" + task );\n        }\n\n        return mojoDescriptor;\n    }","id":30823,"modified_method":"private MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project )\n        throws ArtifactResolutionException, LifecycleExecutionException\n    {\n        String goal = null;\n        Plugin plugin = null;\n\n        PluginDescriptor pluginDescriptor = null;\n\n        StringTokenizer tok = new StringTokenizer( task, \":\" );\n        int numTokens = tok.countTokens();\n        if ( numTokens == 2 )\n        {\n            String prefix = tok.nextToken();\n            goal = tok.nextToken();\n\n            // Steps for retrieving the plugin model instance:\n            // 1. request directly from the plugin collector by prefix\n            pluginDescriptor = pluginManager.getPluginDescriptorForPrefix( prefix );\n\n            if ( pluginDescriptor != null )\n            {\n                plugin = new Plugin();\n\n                plugin.setGroupId( pluginDescriptor.getGroupId() );\n                plugin.setArtifactId( pluginDescriptor.getArtifactId() );\n                plugin.setVersion( pluginDescriptor.getVersion() );\n            }\n\n            // 2. use the plugin resolver to resolve the prefix in the search groups\n            if ( plugin == null )\n            {\n                PluginMappingManager mappingManager = getPluginMappingManager( session, project );\n\n                plugin = mappingManager.getByPrefix( prefix );\n            }\n\n            // 3. default to o.a.m.plugins and maven-<prefix>-plugin\n            if ( plugin == null )\n            {\n                plugin = new Plugin();\n                plugin.setGroupId( PluginDescriptor.getDefaultPluginGroupId() );\n                plugin.setArtifactId( PluginDescriptor.getDefaultPluginArtifactId( prefix ) );\n            }\n\n            for ( Iterator i = project.getBuildPlugins().iterator(); i.hasNext(); )\n            {\n                Plugin buildPlugin = (Plugin) i.next();\n\n                if ( buildPlugin.getKey().equals( plugin.getKey() ) )\n                {\n                    plugin = buildPlugin;\n                    break;\n                }\n            }\n        }\n        else if ( numTokens == 4 )\n        {\n            plugin = new Plugin();\n\n            plugin.setGroupId( tok.nextToken() );\n            plugin.setArtifactId( tok.nextToken() );\n            plugin.setVersion( tok.nextToken() );\n\n            goal = tok.nextToken();\n        }\n        else\n        {\n            String message = \"Invalid task '\" + task + \"': you must specify a valid lifecycle phase, or\"\n                + \" a goal in the format plugin:goal or pluginGroupId:pluginArtifactId:pluginVersion:goal\";\n            throw new LifecycleExecutionException( message );\n        }\n\n        if ( pluginDescriptor == null )\n        {\n            try\n            {\n                pluginDescriptor = pluginManager.verifyPlugin( plugin, project, session.getSettings(), session\n                    .getLocalRepository() );\n            }\n            catch ( PluginManagerException e )\n            {\n                throw new LifecycleExecutionException( \"Internal error in the plugin manager\", e );\n            }\n            catch ( PluginVersionResolutionException e )\n            {\n                throw new LifecycleExecutionException( \"Error resolving plugin version\", e );\n            }\n        }\n\n        injectHandlerPluginConfiguration( project, plugin );\n\n        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( goal );\n        if ( mojoDescriptor == null )\n        {\n            throw new LifecycleExecutionException( \"Required goal not found: \" + task );\n        }\n\n        return mojoDescriptor;\n    }","commit_id":"0cc696a40788d34edec8df6c147bc9a2a3f831b2","url":"https://github.com/apache/maven"},{"original_method":"public PluginMappingManager loadPluginMappings( List pluginGroupIds, List pluginRepositories,\n                                                   ArtifactRepository localRepository )\n        throws RepositoryMetadataManagementException, PluginMappingManagementException\n    {\n        PluginMappingManager mappingManager = new PluginMappingManager();\n\n        if ( pluginGroupIds != null )\n        {\n            for ( Iterator it = pluginGroupIds.iterator(); it.hasNext(); )\n            {\n                String groupId = (String) it.next();\n\n                File mappingFile = resolveMappingMetadata( groupId, pluginRepositories, localRepository );\n\n                PluginMap pluginMap = readPluginMap( mappingFile );\n                \n                if ( pluginMap != null )\n                {\n                    mappingManager.addPluginMap( pluginMap );\n                }\n            }\n        }\n\n        return mappingManager;\n    }","id":30824,"modified_method":"public PluginMappingManager loadPluginMappings( List groupIds, List pluginRepositories,\n                                                   ArtifactRepository localRepository )\n        throws RepositoryMetadataManagementException, PluginMappingManagementException\n    {\n        List pluginGroupIds = new ArrayList( groupIds );\n        \n        if ( !pluginGroupIds.contains( \"org.apache.maven.plugins\" ) )\n        {\n            pluginGroupIds.add( \"org.apache.maven.plugins\" );\n        }\n        \n        PluginMappingManager mappingManager = new PluginMappingManager();\n\n        if ( pluginGroupIds != null )\n        {\n            for ( Iterator it = pluginGroupIds.iterator(); it.hasNext(); )\n            {\n                String groupId = (String) it.next();\n\n                try\n                {\n                    File mappingFile = resolveMappingMetadata( groupId, pluginRepositories, localRepository );\n\n                    PluginMap pluginMap = readPluginMap( mappingFile );\n\n                    if ( pluginMap != null )\n                    {\n                        mappingManager.addPluginMap( pluginMap );\n                    }\n                }\n                catch ( RepositoryMetadataManagementException e )\n                {\n                    getLogger().warn( \"Cannot resolve plugin-mapping metadata for groupId: \" + groupId + \" - IGNORING.\" );\n                    \n                    getLogger().debug( \"Error resolving plugin-mapping metadata for groupId: \" + groupId + \".\", e );\n                }\n            }\n        }\n\n        return mappingManager;\n    }","commit_id":"0cc696a40788d34edec8df6c147bc9a2a3f831b2","url":"https://github.com/apache/maven"},{"original_method":"public void resolve( RepositoryMetadata metadata, ArtifactRepository remote, ArtifactRepository local )\n        throws RepositoryMetadataManagementException\n    {\n        File metadataFile = (File) resolved.get( metadata.getRepositoryPath() );\n\n        if ( metadataFile == null )\n        {\n            metadataFile = constructLocalRepositoryFile( metadata, local, remote.getId() );\n\n            if ( remote == null )\n            {\n                throw new RepositoryMetadataManagementException( metadata,\n                                                                 \"Cannot retrieve repository metadata from null repository.\" );\n            }\n            else\n            {\n                try\n                {\n                    wagonManager.getRepositoryMetadata( metadata, remote, metadataFile );\n\n                    metadata.setFile( metadataFile );\n                }\n                catch ( TransferFailedException e )\n                {\n                    throw new RepositoryMetadataManagementException( metadata,\n                                                                     \"Failed to download repository metadata.\", e );\n                }\n                catch ( ResourceDoesNotExistException e )\n                {\n                    throw new RepositoryMetadataManagementException( metadata, \"Remote repository metadata not found.\",\n                                                                     e );\n                }\n            }\n        }\n    }","id":30825,"modified_method":"public void resolve( RepositoryMetadata metadata, ArtifactRepository remote, ArtifactRepository local )\n        throws RepositoryMetadataManagementException\n    {\n        File metadataFile = (File) cachedMetadata.get( metadata.getRepositoryPath() );\n\n        if ( metadataFile == null )\n        {\n            metadataFile = constructLocalRepositoryFile( metadata, local, remote.getId() );\n\n            if ( remote == null )\n            {\n                throw new RepositoryMetadataManagementException( metadata,\n                                                                 \"Cannot retrieve repository metadata from null repository.\" );\n            }\n            else\n            {\n                try\n                {\n                    File tempMetadataFile = File.createTempFile( \"plugins.xml\", null );\n                    \n                    try\n                    {\n                        wagonManager.getRepositoryMetadata( metadata, remote, tempMetadataFile );\n                        \n                        if( !metadataFile.exists() || ( metadataFile.lastModified() <= tempMetadataFile.lastModified() ) )\n                        {\n                            if ( !tempMetadataFile.renameTo( metadataFile ) )\n                            {\n                                FileUtils.copyFile( tempMetadataFile, metadataFile );\n                                \n                                tempMetadataFile.delete();\n                            }\n                        }\n                    }\n                    catch ( ResourceDoesNotExistException e )\n                    {\n                        if ( !metadataFile.exists() )\n                        {\n                            throw new RepositoryMetadataManagementException( metadata, \"Remote repository metadata not found.\",\n                                                                             e );\n                        }\n                        else\n                        {\n                            String message = \"Cannot find \" + metadata + \" in remote repository - Using local copy.\";\n                            \n                            getLogger().info( message );\n                            \n                            getLogger().debug( message, e );\n                        }\n                    }\n                    \n                    metadata.setFile( metadataFile );\n                }\n                catch ( TransferFailedException e )\n                {\n                    throw new RepositoryMetadataManagementException( metadata,\n                                                                     \"Failed to download repository metadata.\", e );\n                }\n                catch ( IOException e )\n                {\n                    throw new RepositoryMetadataManagementException( metadata, \"Error constructing temporary metadata download file.\", e );\n                }\n            }\n        }\n    }","commit_id":"0cc696a40788d34edec8df6c147bc9a2a3f831b2","url":"https://github.com/apache/maven"},{"original_method":"private void getRemoteFile( ArtifactRepository repository, File destination, String remotePath,\n                                TransferListener downloadMonitor )\n        throws TransferFailedException, ResourceDoesNotExistException, ChecksumFailedException\n    {\n        // TODO: better excetpions - transfer failed is not enough?\n\n        Wagon wagon;\n\n        ArtifactRepository mirror = getMirror( repository.getId() );\n        if ( mirror != null )\n        {\n            repository = mirror;\n        }\n\n        String protocol = repository.getProtocol();\n        try\n        {\n            wagon = getWagon( protocol );\n        }\n        catch ( UnsupportedProtocolException e )\n        {\n            throw new TransferFailedException( \"Unsupported Protocol: \", e );\n        }\n\n        if ( downloadMonitor != null )\n        {\n            wagon.addTransferListener( downloadMonitor );\n        }\n\n        // TODO: configure on repository\n        ChecksumObserver md5ChecksumObserver;\n        ChecksumObserver sha1ChecksumObserver;\n        try\n        {\n            md5ChecksumObserver = new ChecksumObserver( \"MD5\" );\n            wagon.addTransferListener( md5ChecksumObserver );\n\n            sha1ChecksumObserver = new ChecksumObserver( \"SHA-1\" );\n            wagon.addTransferListener( sha1ChecksumObserver );\n        }\n        catch ( NoSuchAlgorithmException e )\n        {\n            throw new TransferFailedException( \"Unable to add checksum methods\", e );\n        }\n\n        File temp = new File( destination + \".tmp\" );\n        temp.deleteOnExit();\n\n        try\n        {\n            wagon.connect( new Repository( repository.getId(), repository.getUrl() ),\n                           getAuthenticationInfo( repository.getId() ), getProxy( protocol ) );\n\n            boolean firstRun = true;\n            boolean retry = false;\n\n            // this will run at most twice. The first time, the firstRun flag is turned off, and if the retry flag\n            // is set on the first run, it will be turned off and not re-set on the second try. This is because the\n            // only way the retry flag can be set is if ( firstRun == true ).\n            while ( firstRun || retry )\n            {\n                // reset the retry flag.\n                retry = false;\n\n                // This should take care of creating destination directory now on\n                wagon.get( remotePath, temp );\n\n                // keep the checksum files from showing up on the download monitor...\n                if ( downloadMonitor != null )\n                {\n                    wagon.removeTransferListener( downloadMonitor );\n                }\n\n                // try to verify the SHA-1 checksum for this file.\n                try\n                {\n                    verifyChecksum( sha1ChecksumObserver, destination, remotePath, \".sha1\", wagon );\n                }\n                catch ( WagonException sha1TryException )\n                {\n                    // if we catch a ChecksumFailedException, it means the transfer/read succeeded, but the checksum\n                    // doesn't match. This could be a problem with the server (ibiblio HTTP-200 error page), so we'll\n                    // try this up to two times. On the second try, we'll handle it as a bona-fide error, based on the\n                    // repository's checksum checking policy.\n                    if ( sha1TryException instanceof ChecksumFailedException )\n                    {\n                        // if this is the second try, handle the problem...otherwise, let it try again.\n                        if ( firstRun )\n                        {\n                            retry = true;\n                        }\n                        else\n                        {\n                            handleChecksumFailure( repository, sha1TryException.getMessage(),\n                                                   sha1TryException.getCause() );\n                        }\n                    }\n                    // if this IS NOT a ChecksumFailedException, it was a problem with transfer/read of the checksum\n                    // file...we'll try again with the MD5 checksum.\n                    else\n                    {\n                        try\n                        {\n                            verifyChecksum( md5ChecksumObserver, destination, remotePath, \".md5\", wagon );\n                        }\n                        catch ( WagonException md5TryException )\n                        {\n                            // if we also fail to verify based on the MD5 checksum, and the checksum transfer/read\n                            // succeeded, then we need to determine whether to retry or handle it as a failure.\n                            if ( md5TryException instanceof ChecksumFailedException )\n                            {\n                                // only retry once.\n                                if ( firstRun )\n                                {\n                                    retry = true;\n                                }\n                                else\n                                {\n                                    handleChecksumFailure( repository, md5TryException.getMessage(),\n                                                           md5TryException.getCause() );\n                                }\n                            }\n                            // otherwise, this was a failed transfer, and we don't want to retry.\n                            else\n                            {\n                                handleChecksumFailure( repository, \"Error retrieving checksum file for \" + destination,\n                                                       md5TryException );\n                            }\n                        }\n                    }\n                }\n                finally\n                {\n                    // reinstate the download monitor...\n                    if ( downloadMonitor != null )\n                    {\n                        wagon.addTransferListener( downloadMonitor );\n                    }\n\n                    // unset the firstRun flag, so we don't get caught in an infinite loop...\n                    firstRun = false;\n                }\n            }\n        }\n        catch ( ConnectionException e )\n        {\n            throw new TransferFailedException( \"Connection failed: \", e );\n        }\n        catch ( AuthenticationException e )\n        {\n            throw new TransferFailedException( \"Authentication failed: \", e );\n        }\n        catch ( AuthorizationException e )\n        {\n            throw new TransferFailedException( \"Authorization failed: \", e );\n        }\n        finally\n        {\n            disconnectWagon( wagon );\n\n            releaseWagon( wagon );\n        }\n\n        if ( !temp.exists() )\n        {\n            throw new ResourceDoesNotExistException( \"Downloaded file does not exist: \" + temp );\n        }\n\n        // The temporary file is named destination + \".tmp\" and is done this way to ensure\n        // that the temporary file is in the same file system as the destination because the\n        // File.renameTo operation doesn't really work across file systems.\n        // So we will attempt to do a File.renameTo for efficiency and atomicity, if this fails\n        // then we will use a brute force copy and delete the temporary file.\n\n        if ( !temp.renameTo( destination ) )\n        {\n            try\n            {\n                FileUtils.copyFile( temp, destination );\n\n                temp.delete();\n            }\n            catch ( IOException e )\n            {\n                throw new TransferFailedException( \"Error copying temporary file to the final destination: \", e );\n            }\n        }\n    }","id":30826,"modified_method":"private void getRemoteFile( ArtifactRepository repository, File destination, String remotePath,\n                                TransferListener downloadMonitor )\n        throws TransferFailedException, ResourceDoesNotExistException, ChecksumFailedException\n    {\n        // TODO: better excetpions - transfer failed is not enough?\n\n        Wagon wagon;\n\n        ArtifactRepository mirror = getMirror( repository.getId() );\n        if ( mirror != null )\n        {\n            repository = mirror;\n        }\n\n        String protocol = repository.getProtocol();\n        try\n        {\n            wagon = getWagon( protocol );\n        }\n        catch ( UnsupportedProtocolException e )\n        {\n            throw new TransferFailedException( \"Unsupported Protocol: \", e );\n        }\n\n        if ( downloadMonitor != null )\n        {\n            wagon.addTransferListener( downloadMonitor );\n        }\n\n        // TODO: configure on repository\n        ChecksumObserver md5ChecksumObserver;\n        ChecksumObserver sha1ChecksumObserver;\n        try\n        {\n            md5ChecksumObserver = new ChecksumObserver( \"MD5\" );\n            wagon.addTransferListener( md5ChecksumObserver );\n\n            sha1ChecksumObserver = new ChecksumObserver( \"SHA-1\" );\n            wagon.addTransferListener( sha1ChecksumObserver );\n        }\n        catch ( NoSuchAlgorithmException e )\n        {\n            throw new TransferFailedException( \"Unable to add checksum methods\", e );\n        }\n\n        File temp = new File( destination + \".tmp\" );\n        temp.deleteOnExit();\n\n        try\n        {\n            wagon.connect( new Repository( repository.getId(), repository.getUrl() ),\n                           getAuthenticationInfo( repository.getId() ), getProxy( protocol ) );\n\n            boolean firstRun = true;\n            boolean retry = false;\n\n            // this will run at most twice. The first time, the firstRun flag is turned off, and if the retry flag\n            // is set on the first run, it will be turned off and not re-set on the second try. This is because the\n            // only way the retry flag can be set is if ( firstRun == true ).\n            while ( firstRun || retry )\n            {\n                // reset the retry flag.\n                retry = false;\n\n                // This should take care of creating destination directory now on\n                wagon.get( remotePath, temp );\n\n                // keep the checksum files from showing up on the download monitor...\n                if ( downloadMonitor != null )\n                {\n                    wagon.removeTransferListener( downloadMonitor );\n                }\n\n                // try to verify the SHA-1 checksum for this file.\n                try\n                {\n                    verifyChecksum( sha1ChecksumObserver, temp, remotePath, \".sha1\", wagon );\n                }\n                catch ( WagonException sha1TryException )\n                {\n                    // if we catch a ChecksumFailedException, it means the transfer/read succeeded, but the checksum\n                    // doesn't match. This could be a problem with the server (ibiblio HTTP-200 error page), so we'll\n                    // try this up to two times. On the second try, we'll handle it as a bona-fide error, based on the\n                    // repository's checksum checking policy.\n                    if ( sha1TryException instanceof ChecksumFailedException )\n                    {\n                        // if this is the second try, handle the problem...otherwise, let it try again.\n                        if ( firstRun )\n                        {\n                            retry = true;\n                        }\n                        else\n                        {\n                            handleChecksumFailure( repository, sha1TryException.getMessage(),\n                                                   sha1TryException.getCause() );\n                        }\n                    }\n                    // if this IS NOT a ChecksumFailedException, it was a problem with transfer/read of the checksum\n                    // file...we'll try again with the MD5 checksum.\n                    else\n                    {\n                        try\n                        {\n                            verifyChecksum( md5ChecksumObserver, temp, remotePath, \".md5\", wagon );\n                        }\n                        catch ( WagonException md5TryException )\n                        {\n                            // if we also fail to verify based on the MD5 checksum, and the checksum transfer/read\n                            // succeeded, then we need to determine whether to retry or handle it as a failure.\n                            if ( md5TryException instanceof ChecksumFailedException )\n                            {\n                                // only retry once.\n                                if ( firstRun )\n                                {\n                                    retry = true;\n                                }\n                                else\n                                {\n                                    handleChecksumFailure( repository, md5TryException.getMessage(),\n                                                           md5TryException.getCause() );\n                                }\n                            }\n                            // otherwise, this was a failed transfer, and we don't want to retry.\n                            else\n                            {\n                                handleChecksumFailure( repository, \"Error retrieving checksum file for \" + remotePath,\n                                                       md5TryException );\n                            }\n                        }\n                    }\n                }\n                finally\n                {\n                    // reinstate the download monitor...\n                    if ( downloadMonitor != null )\n                    {\n                        wagon.addTransferListener( downloadMonitor );\n                    }\n\n                    // unset the firstRun flag, so we don't get caught in an infinite loop...\n                    firstRun = false;\n                }\n            }\n        }\n        catch ( ConnectionException e )\n        {\n            throw new TransferFailedException( \"Connection failed: \", e );\n        }\n        catch ( AuthenticationException e )\n        {\n            throw new TransferFailedException( \"Authentication failed: \", e );\n        }\n        catch ( AuthorizationException e )\n        {\n            throw new TransferFailedException( \"Authorization failed: \", e );\n        }\n        finally\n        {\n            disconnectWagon( wagon );\n\n            releaseWagon( wagon );\n        }\n\n        if ( !temp.exists() )\n        {\n            throw new ResourceDoesNotExistException( \"Downloaded file does not exist: \" + temp );\n        }\n\n        // The temporary file is named destination + \".tmp\" and is done this way to ensure\n        // that the temporary file is in the same file system as the destination because the\n        // File.renameTo operation doesn't really work across file systems.\n        // So we will attempt to do a File.renameTo for efficiency and atomicity, if this fails\n        // then we will use a brute force copy and delete the temporary file.\n\n        if ( !temp.renameTo( destination ) )\n        {\n            try\n            {\n                FileUtils.copyFile( temp, destination );\n\n                temp.delete();\n            }\n            catch ( IOException e )\n            {\n                throw new TransferFailedException( \"Error copying temporary file to the final destination: \", e );\n            }\n        }\n    }","commit_id":"0cc696a40788d34edec8df6c147bc9a2a3f831b2","url":"https://github.com/apache/maven"},{"original_method":"public void execute() throws MojoExecutionException\n    {\n        ArtifactRepository distributionRepository = project.getDistributionManagementArtifactRepository();\n        \n        String distributionRepositoryId = distributionRepository.getId();\n\n        List remoteArtifactRepositories = project.getRemoteArtifactRepositories();\n\n        ArtifactRepository readRemoteRepository = null;\n\n        for ( Iterator it = remoteArtifactRepositories.iterator(); it.hasNext(); )\n        {\n            ArtifactRepository currentRepository = (ArtifactRepository) it.next();\n\n            if ( distributionRepositoryId.equals( currentRepository.getId() ) )\n            {\n                readRemoteRepository = currentRepository;\n                \n                break;\n            }\n        }\n        \n        PluginMappingXpp3Reader mappingReader = new PluginMappingXpp3Reader();\n        \n        PluginMap pluginMap = null;\n        \n        RepositoryMetadata metadata = new PluginMappingMetadata( project.getGroupId() );\n        \n        try\n        {\n            repositoryMetadataManager.resolve( metadata, readRemoteRepository, localRepository );\n            \n            Reader reader = null;\n            \n            File metadataFile = metadata.getFile();\n            \n            try\n            {\n                reader = new FileReader( metadataFile );\n\n                pluginMap = mappingReader.read( reader );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot read plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new MojoExecutionException( \"Cannot parse plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n        }\n        catch ( RepositoryMetadataManagementException e )\n        {\n            Throwable cause = e.getCause();\n            \n            if ( cause != null && ( cause instanceof ResourceDoesNotExistException ) )\n            {\n                getLog().info( \"Cannot find \" + metadata + \" on remote repository. Creating a new one.\" );\n                getLog().debug( \"Metadata \" + metadata + \" cannot be resolved.\", e );\n                \n                pluginMap = new PluginMap();\n                pluginMap.setGroupId( project.getGroupId() );\n            }\n            else\n            {\n                throw new MojoExecutionException( \"Failed to resolve \" + metadata, e );\n            }\n        }\n        \n        boolean prefixAlreadyMapped = false;\n        \n        for ( Iterator it = pluginMap.getPlugins().iterator(); it.hasNext(); )\n        {\n            MappedPlugin preExisting = (MappedPlugin) it.next();\n            \n            if ( preExisting.getPrefix().equals( getGoalPrefix() ) )\n            {\n                prefixAlreadyMapped = true;\n                \n                if ( !preExisting.getArtifactId().equals( project.getArtifactId() ) )\n                {\n                    // TODO: In this case, should we rather just replace the existing plugin mapping??\n                    \n                    throw new MojoExecutionException( \"Cannot map plugin to it's prefix in plugins.xml metadata; the prefix: \\'\" + getGoalPrefix() + \"\\' is already mapped to: \" + preExisting.getArtifactId() ); \n                }\n                else\n                {\n                    getLog().info( \"NOT updating plugins.xml metadata; this plugin is already mapped.\" ); \n                }\n                \n                break;\n            }\n        }\n        \n        if ( !prefixAlreadyMapped )\n        {\n            MappedPlugin mappedPlugin = new MappedPlugin();\n            \n            mappedPlugin.setArtifactId( project.getArtifactId() );\n            \n            mappedPlugin.setPrefix( getGoalPrefix() );\n            \n            pluginMap.addPlugin( mappedPlugin );\n            \n            Writer writer = null;\n            try\n            {\n                File updatedMetadataFile = new File( outputDirectory, metadata.getRepositoryPath() ).getAbsoluteFile();\n\n                File dir = updatedMetadataFile.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n                \n                writer = new FileWriter( updatedMetadataFile );\n                \n                PluginMappingXpp3Writer mappingWriter = new PluginMappingXpp3Writer();\n                \n                mappingWriter.write( writer, pluginMap );\n                \n                metadata.setFile( updatedMetadataFile );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Error writing repository metadata to build directory.\", e );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n    }","id":30827,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        ArtifactRepository distributionRepository = project.getDistributionManagementArtifactRepository();\n\n        String distributionRepositoryId = distributionRepository.getId();\n\n        List remoteArtifactRepositories = project.getRemoteArtifactRepositories();\n\n        ArtifactRepository readRemoteRepository = null;\n\n        for ( Iterator it = remoteArtifactRepositories.iterator(); it.hasNext(); )\n        {\n            ArtifactRepository currentRepository = (ArtifactRepository) it.next();\n\n            if ( distributionRepositoryId.equals( currentRepository.getId() ) )\n            {\n                readRemoteRepository = currentRepository;\n\n                break;\n            }\n        }\n\n        PluginMappingXpp3Reader mappingReader = new PluginMappingXpp3Reader();\n\n        PluginMap pluginMap = null;\n\n        RepositoryMetadata metadata = new PluginMappingMetadata( project.getGroupId() );\n\n        try\n        {\n            repositoryMetadataManager.resolve( metadata, readRemoteRepository, localRepository );\n\n            Reader reader = null;\n\n            File metadataFile = metadata.getFile();\n\n            try\n            {\n                reader = new FileReader( metadataFile );\n\n                pluginMap = mappingReader.read( reader );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot read plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new MojoExecutionException( \"Cannot parse plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n        }\n        catch ( RepositoryMetadataManagementException e )\n        {\n            Throwable cause = e.getCause();\n\n            if ( cause != null && ( cause instanceof ResourceDoesNotExistException ) )\n            {\n                getLog().info( \"Cannot find \" + metadata + \" on remote repository. Creating a new one.\" );\n                getLog().debug( \"Metadata \" + metadata + \" cannot be resolved.\", e );\n\n                pluginMap = new PluginMap();\n                pluginMap.setGroupId( project.getGroupId() );\n            }\n            else\n            {\n                throw new MojoExecutionException( \"Failed to resolve \" + metadata, e );\n            }\n        }\n\n        for ( Iterator it = pluginMap.getPlugins().iterator(); it.hasNext(); )\n        {\n            MappedPlugin preExisting = (MappedPlugin) it.next();\n\n            if ( preExisting.getArtifactId().equals( project.getArtifactId() ) )\n            {\n                getLog().info( \"Updating pre-existing plugin-mapping metadata.\" );\n\n                pluginMap.removePlugin( preExisting );\n\n                break;\n            }\n        }\n\n        MappedPlugin mappedPlugin = new MappedPlugin();\n\n        mappedPlugin.setArtifactId( project.getArtifactId() );\n\n        mappedPlugin.setPrefix( getGoalPrefix() );\n\n        mappedPlugin.setPackagingHandlers( extractPackagingHandlers() );\n\n        pluginMap.addPlugin( mappedPlugin );\n\n        Writer writer = null;\n        try\n        {\n            File updatedMetadataFile = new File( metadataDirectory, metadata.getRepositoryPath() ).getAbsoluteFile();\n\n            File dir = updatedMetadataFile.getParentFile();\n\n            if ( !dir.exists() )\n            {\n                dir.mkdirs();\n            }\n\n            writer = new FileWriter( updatedMetadataFile );\n\n            PluginMappingXpp3Writer mappingWriter = new PluginMappingXpp3Writer();\n\n            mappingWriter.write( writer, pluginMap );\n\n            metadata.setFile( updatedMetadataFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error writing repository metadata to build directory.\", e );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","commit_id":"0cc696a40788d34edec8df6c147bc9a2a3f831b2","url":"https://github.com/apache/maven"},{"original_method":"public void addPluginMap( PluginMap pluginMap )\n    {\n        mappings.add( pluginMap );\n        \n        // flush the cache.\n        pluginDefinitionsByPrefix = null;\n    }","id":30828,"modified_method":"public void addPluginMap( PluginMap pluginMap )\n    {\n        mappings.add( pluginMap );\n        \n        // flush the cache.\n        pluginDefinitionsByPrefix = null;\n        pluginDefinitionsByPackaging = null;\n    }","commit_id":"0cc696a40788d34edec8df6c147bc9a2a3f831b2","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Set cluster info in the catalog.\n     * @param leader The leader hostname\n     * @param catalog The catalog to be updated.\n     * @param printLog Whether or not to print cluster configuration.\n     */\n    private static void setClusterInfo(Catalog catalog, DeploymentType deployment,\n                                       boolean printLog) {\n        ClusterType cluster = deployment.getCluster();\n        int hostCount = cluster.getHostcount();\n        int sitesPerHost = cluster.getSitesperhost();\n        int kFactor = cluster.getKfactor();\n\n        ClusterConfig config = new ClusterConfig(hostCount, sitesPerHost, kFactor);\n        if (printLog) {\n            hostLog.l7dlog(Level.INFO,\n                           LogKeys.compiler_VoltCompiler_LeaderAndHostCountAndSitesPerHost.name(),\n                           new Object[] { config.getHostCount(),\n                                          VoltDB.instance().getConfig().m_leader,\n                                          config.getSitesPerHost(),\n                                          config.getReplicationFactor() },\n                           null);\n        }\n        int replicas = config.getReplicationFactor() + 1;\n        int partitionCount = config.getSitesPerHost() * config.getHostCount() / replicas;\n        if (printLog) {\n            hostLog.info(String.format(\"The entire cluster has %d %s of%s %d logical partition%s.\",\n                                       replicas,\n                                       replicas > 1 ? \"copies\" : \"copy\",\n                                       partitionCount > 1 ? \" each of the\" : \"\",\n                                       partitionCount,\n                                       partitionCount > 1 ? \"s\" : \"\"));\n        }\n\n        if (!config.validate()) {\n            hostLog.error(config.getErrorMsg());\n        } else {\n            Cluster catCluster = catalog.getClusters().get(\"cluster\");\n            // copy the deployment info that is currently not recorded anywhere else\n            Deployment catDeploy = catCluster.getDeployment().get(\"deployment\");\n            catDeploy.setHostcount(hostCount);\n            catDeploy.setSitesperhost(sitesPerHost);\n            catDeploy.setKfactor(kFactor);\n            // copy partition detection configuration from xml to catalog\n            if (deployment.getPartitionDetection() != null) {\n                if (deployment.getPartitionDetection().isEnabled()) {\n                    catCluster.setNetworkpartition(true);\n                    CatalogMap<SnapshotSchedule> faultsnapshots = catCluster.getFaultsnapshots();\n                    SnapshotSchedule sched = faultsnapshots.add(\"CLUSTER_PARTITION\");\n                    sched.setPrefix(deployment.getPartitionDetection().getSnapshot().getPrefix());\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is enabled.\");\n                    }\n                }\n                else {\n                    catCluster.setNetworkpartition(false);\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is not enabled.\");\n                    }\n                }\n            }\n            else {\n                // Default partition detection on for IV2\n                if (VoltDB.instance().isIV2Enabled()) {\n                    catCluster.setNetworkpartition(true);\n                    CatalogMap<SnapshotSchedule> faultsnapshots = catCluster.getFaultsnapshots();\n                    SnapshotSchedule sched = faultsnapshots.add(\"CLUSTER_PARTITION\");\n                    sched.setPrefix(\"partition_detection\");\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is enabled.\");\n                    }\n                }\n                else {\n                    catCluster.setNetworkpartition(false);\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is not enabled.\");\n                    }\n                }\n            }\n\n            // copy admin mode configuration from xml to catalog\n            if (deployment.getAdminMode() != null)\n            {\n                catCluster.setAdminport(deployment.getAdminMode().getPort());\n                catCluster.setAdminstartup(deployment.getAdminMode().isAdminstartup());\n            }\n            else\n            {\n                // encode the default values\n                catCluster.setAdminport(VoltDB.DEFAULT_ADMIN_PORT);\n                catCluster.setAdminstartup(false);\n            }\n\n            setSystemSettings(deployment, catDeploy);\n\n            if (deployment.getHeartbeat() != null)\n            {\n                catCluster.setHeartbeattimeout(deployment.getHeartbeat().getTimeout());\n            }\n            else\n            {\n                // default to 10 seconds\n                catCluster.setHeartbeattimeout(10);\n            }\n        }\n    }","id":30829,"modified_method":"/**\n     * Set cluster info in the catalog.\n     * @param leader The leader hostname\n     * @param catalog The catalog to be updated.\n     * @param printLog Whether or not to print cluster configuration.\n     */\n    private static void setClusterInfo(Catalog catalog, DeploymentType deployment,\n                                       boolean printLog) {\n        ClusterType cluster = deployment.getCluster();\n        int hostCount = cluster.getHostcount();\n        int sitesPerHost = cluster.getSitesperhost();\n        int kFactor = cluster.getKfactor();\n\n        ClusterConfig config = new ClusterConfig(hostCount, sitesPerHost, kFactor);\n        if (printLog) {\n            hostLog.l7dlog(Level.INFO,\n                           LogKeys.compiler_VoltCompiler_LeaderAndHostCountAndSitesPerHost.name(),\n                           new Object[] { config.getHostCount(),\n                                          VoltDB.instance().getConfig().m_leader,\n                                          config.getSitesPerHost(),\n                                          config.getReplicationFactor() },\n                           null);\n        }\n        int replicas = config.getReplicationFactor() + 1;\n        int partitionCount = config.getSitesPerHost() * config.getHostCount() / replicas;\n        if (printLog) {\n            hostLog.info(String.format(\"The entire cluster has %d %s of%s %d logical partition%s.\",\n                                       replicas,\n                                       replicas > 1 ? \"copies\" : \"copy\",\n                                       partitionCount > 1 ? \" each of the\" : \"\",\n                                       partitionCount,\n                                       partitionCount > 1 ? \"s\" : \"\"));\n        }\n\n        if (!config.validate()) {\n            hostLog.error(config.getErrorMsg());\n        } else {\n            Cluster catCluster = catalog.getClusters().get(\"cluster\");\n            // copy the deployment info that is currently not recorded anywhere else\n            Deployment catDeploy = catCluster.getDeployment().get(\"deployment\");\n            catDeploy.setHostcount(hostCount);\n            catDeploy.setSitesperhost(sitesPerHost);\n            catDeploy.setKfactor(kFactor);\n            // copy partition detection configuration from xml to catalog\n            String defaultPPDPrefix = \"partition_detection\";\n            if (deployment.getPartitionDetection() != null) {\n                if (deployment.getPartitionDetection().isEnabled()) {\n                    catCluster.setNetworkpartition(true);\n                    CatalogMap<SnapshotSchedule> faultsnapshots = catCluster.getFaultsnapshots();\n                    SnapshotSchedule sched = faultsnapshots.add(\"CLUSTER_PARTITION\");\n                    if (deployment.getPartitionDetection().getSnapshot() != null) {\n                        sched.setPrefix(deployment.getPartitionDetection().getSnapshot().getPrefix());\n                    }\n                    else {\n                        sched.setPrefix(defaultPPDPrefix);\n                    }\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is enabled.\");\n                    }\n                }\n                else {\n                    catCluster.setNetworkpartition(false);\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is not enabled.\");\n                    }\n                }\n            }\n            else {\n                // Default partition detection on for IV2\n                if (VoltDB.instance().isIV2Enabled()) {\n                    catCluster.setNetworkpartition(true);\n                    CatalogMap<SnapshotSchedule> faultsnapshots = catCluster.getFaultsnapshots();\n                    SnapshotSchedule sched = faultsnapshots.add(\"CLUSTER_PARTITION\");\n                    sched.setPrefix(defaultPPDPrefix);\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is enabled.\");\n                    }\n                }\n                else {\n                    catCluster.setNetworkpartition(false);\n                    if (printLog) {\n                        hostLog.info(\"Detection of network partitions in the cluster is not enabled.\");\n                    }\n                }\n            }\n\n            // copy admin mode configuration from xml to catalog\n            if (deployment.getAdminMode() != null)\n            {\n                catCluster.setAdminport(deployment.getAdminMode().getPort());\n                catCluster.setAdminstartup(deployment.getAdminMode().isAdminstartup());\n            }\n            else\n            {\n                // encode the default values\n                catCluster.setAdminport(VoltDB.DEFAULT_ADMIN_PORT);\n                catCluster.setAdminstartup(false);\n            }\n\n            setSystemSettings(deployment, catDeploy);\n\n            if (deployment.getHeartbeat() != null)\n            {\n                catCluster.setHeartbeattimeout(deployment.getHeartbeat().getTimeout());\n            }\n            else\n            {\n                // default to 10 seconds\n                catCluster.setHeartbeattimeout(10);\n            }\n        }\n    }","commit_id":"b2f0096c1ddde600c167147a510b2e3c52f0af52","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * This code is not really tenable, and should be replaced with some\n     * XML normalization code, but for now it should work and be pretty\n     * tolerant of XML documents with different formatting for the same\n     * values.\n     * @return A positive CRC for the deployment contents\n     */\n    static long getDeploymentCRC(DeploymentType deployment) {\n        StringBuilder sb = new StringBuilder(1024);\n\n        sb.append(\" CLUSTER \");\n        ClusterType ct = deployment.getCluster();\n        sb.append(ct.getHostcount()).append(\",\");\n        sb.append(ct.getKfactor()).append(\",\");\n        sb.append(ct.getSitesperhost()).append(\",\");\n\n        sb.append(\" PARTITIONDETECTION \");\n        PartitionDetectionType pdt = deployment.getPartitionDetection();\n        if (pdt != null) {\n            sb.append(pdt.isEnabled()).append(\",\");\n            PartitionDetectionType.Snapshot st = pdt.getSnapshot();\n            assert(st != null);\n            sb.append(st.getPrefix()).append(\",\");\n        }\n\n        sb.append(\" SECURITY \");\n        SecurityType st = deployment.getSecurity();\n        if (st != null) {\n            sb.append(st.isEnabled());\n        }\n\n        sb.append(\" ADMINMODE \");\n        AdminModeType amt = deployment.getAdminMode();\n        if (amt != null)\n        {\n            sb.append(amt.getPort()).append(\",\");\n            sb.append(amt.isAdminstartup()).append(\"\\n\");\n        }\n\n        sb.append(\" HEARTBEATCONFIG \");\n        HeartbeatType hbt = deployment.getHeartbeat();\n        if (hbt != null)\n        {\n            sb.append(hbt.getTimeout()).append(\"\\n\");\n        }\n\n        sb.append(\" USERS \");\n        UsersType ut = deployment.getUsers();\n        if (ut != null) {\n            List<User> users = ut.getUser();\n            for (User u : users) {\n                sb.append(\" USER \");\n                sb.append(u.getName()).append(\",\");\n                sb.append(Arrays.toString(mergeUserRoles(u).toArray()));\n                sb.append(\",\").append(u.getPassword()).append(\",\");\n            }\n        }\n        sb.append(\"\\n\");\n\n        sb.append(\" HTTPD \");\n        HttpdType ht = deployment.getHttpd();\n        if (ht != null) {\n            HttpdType.Jsonapi jt = ht.getJsonapi();\n            if (jt != null) {\n                sb.append(jt.isEnabled()).append(\",\");\n            }\n            sb.append(ht.isEnabled());\n            sb.append(ht.getPort());\n        }\n\n        sb.append(\" SYSTEMSETTINGS \");\n        SystemSettingsType sst = deployment.getSystemsettings();\n        if (sst != null)\n        {\n            sb.append(\" TEMPTABLES \");\n            Temptables ttt = sst.getTemptables();\n            if (ttt != null)\n            {\n                sb.append(ttt.getMaxsize()).append(\"\\n\");\n            }\n        }\n\n        sb.append(\" EXPORT \");\n        ExportType export = deployment.getExport();\n        if( export != null) {\n            sb.append(\" ENABLE \").append(export.isEnabled());\n            // mimic what is done when the catalog is built, which\n            // ignores anything else within the export XML stanza\n            // when enabled is false\n            ExportOnServerType onServer = export.getOnserver();\n            if (onServer != null && export.isEnabled()) {\n                sb.append(\" ONSERVER \");\n                ServerExportEnum exportTo = onServer.getExportto();\n                if (exportTo != null) {\n                    sb.append( \"EXPORTTO \").append(exportTo.name());\n                }\n                ExportConfigurationType config = onServer.getConfiguration();\n                if (config != null) {\n                    List<PropertyType> props = config.getProperty();\n                    if( props != null && !props.isEmpty()) {\n                        sb.append(\" CONFIGURATION\");\n                        int propCnt = 0;\n                        for( PropertyType prop: props) {\n                            if( propCnt++ > 0) {\n                                sb.append(\",\");\n                            }\n                            sb.append(\" \").append(prop.getName());\n                            sb.append(\": \").append(prop.getValue());\n                        }\n                    }\n                }\n            }\n            sb.append(\"\\n\");\n        }\n\n        byte[] data = null;\n        try {\n            data = sb.toString().getBytes(\"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            hostLog.error(\"CRCing deployment file to determine\" +\n                    \" compatibility and determined deployment file is\"+\n                    \" not valid UTF-8. File must be UTF-8 encoded.\");\n            data = new byte[]{0x0}; // should generate a CRC mismatch.\n        }\n\n        PureJavaCrc32 crc = new PureJavaCrc32();\n        crc.update(data);\n\n        long retval = crc.getValue();\n        return Math.abs(retval);\n    }","id":30830,"modified_method":"/**\n     * This code is not really tenable, and should be replaced with some\n     * XML normalization code, but for now it should work and be pretty\n     * tolerant of XML documents with different formatting for the same\n     * values.\n     * @return A positive CRC for the deployment contents\n     */\n    static long getDeploymentCRC(DeploymentType deployment) {\n        StringBuilder sb = new StringBuilder(1024);\n\n        sb.append(\" CLUSTER \");\n        ClusterType ct = deployment.getCluster();\n        sb.append(ct.getHostcount()).append(\",\");\n        sb.append(ct.getKfactor()).append(\",\");\n        sb.append(ct.getSitesperhost()).append(\",\");\n\n        sb.append(\" PARTITIONDETECTION \");\n        PartitionDetectionType pdt = deployment.getPartitionDetection();\n        if (pdt != null) {\n            sb.append(pdt.isEnabled()).append(\",\");\n            PartitionDetectionType.Snapshot st = pdt.getSnapshot();\n            if (st != null) {\n                sb.append(st.getPrefix()).append(\",\");\n            }\n        }\n\n        sb.append(\" SECURITY \");\n        SecurityType st = deployment.getSecurity();\n        if (st != null) {\n            sb.append(st.isEnabled());\n        }\n\n        sb.append(\" ADMINMODE \");\n        AdminModeType amt = deployment.getAdminMode();\n        if (amt != null)\n        {\n            sb.append(amt.getPort()).append(\",\");\n            sb.append(amt.isAdminstartup()).append(\"\\n\");\n        }\n\n        sb.append(\" HEARTBEATCONFIG \");\n        HeartbeatType hbt = deployment.getHeartbeat();\n        if (hbt != null)\n        {\n            sb.append(hbt.getTimeout()).append(\"\\n\");\n        }\n\n        sb.append(\" USERS \");\n        UsersType ut = deployment.getUsers();\n        if (ut != null) {\n            List<User> users = ut.getUser();\n            for (User u : users) {\n                sb.append(\" USER \");\n                sb.append(u.getName()).append(\",\");\n                sb.append(Arrays.toString(mergeUserRoles(u).toArray()));\n                sb.append(\",\").append(u.getPassword()).append(\",\");\n            }\n        }\n        sb.append(\"\\n\");\n\n        sb.append(\" HTTPD \");\n        HttpdType ht = deployment.getHttpd();\n        if (ht != null) {\n            HttpdType.Jsonapi jt = ht.getJsonapi();\n            if (jt != null) {\n                sb.append(jt.isEnabled()).append(\",\");\n            }\n            sb.append(ht.isEnabled());\n            sb.append(ht.getPort());\n        }\n\n        sb.append(\" SYSTEMSETTINGS \");\n        SystemSettingsType sst = deployment.getSystemsettings();\n        if (sst != null)\n        {\n            sb.append(\" TEMPTABLES \");\n            Temptables ttt = sst.getTemptables();\n            if (ttt != null)\n            {\n                sb.append(ttt.getMaxsize()).append(\"\\n\");\n            }\n        }\n\n        sb.append(\" EXPORT \");\n        ExportType export = deployment.getExport();\n        if( export != null) {\n            sb.append(\" ENABLE \").append(export.isEnabled());\n            // mimic what is done when the catalog is built, which\n            // ignores anything else within the export XML stanza\n            // when enabled is false\n            ExportOnServerType onServer = export.getOnserver();\n            if (onServer != null && export.isEnabled()) {\n                sb.append(\" ONSERVER \");\n                ServerExportEnum exportTo = onServer.getExportto();\n                if (exportTo != null) {\n                    sb.append( \"EXPORTTO \").append(exportTo.name());\n                }\n                ExportConfigurationType config = onServer.getConfiguration();\n                if (config != null) {\n                    List<PropertyType> props = config.getProperty();\n                    if( props != null && !props.isEmpty()) {\n                        sb.append(\" CONFIGURATION\");\n                        int propCnt = 0;\n                        for( PropertyType prop: props) {\n                            if( propCnt++ > 0) {\n                                sb.append(\",\");\n                            }\n                            sb.append(\" \").append(prop.getName());\n                            sb.append(\": \").append(prop.getValue());\n                        }\n                    }\n                }\n            }\n            sb.append(\"\\n\");\n        }\n\n        byte[] data = null;\n        try {\n            data = sb.toString().getBytes(\"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            hostLog.error(\"CRCing deployment file to determine\" +\n                    \" compatibility and determined deployment file is\"+\n                    \" not valid UTF-8. File must be UTF-8 encoded.\");\n            data = new byte[]{0x0}; // should generate a CRC mismatch.\n        }\n\n        PureJavaCrc32 crc = new PureJavaCrc32();\n        crc.update(data);\n\n        long retval = crc.getValue();\n        return Math.abs(retval);\n    }","commit_id":"b2f0096c1ddde600c167147a510b2e3c52f0af52","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * The logic execution context to accept and process incomming connection\n     * requests. When a new connection is received a new thread of control is\n     * crated to process the connection. This method encapsulates that control\n     * logic so that it can be executed in it's own java thread.\n     */\n    public void run() {\n        // get the thread context for the ability to stop the process\n        m_context = Thread.currentThread();\n        synchronized (m_context) {\n            m_context.notifyAll();\n        }\n\n        // get the log information\n        ThreadCategory.setPrefix(m_logPrefix);\n        \n        // check to see if the thread has already been stopped.\n        if (m_stop) {\n            log().debug(\"Stop flag set on thread startup\");\n\n            try {\n                if (m_tcpSock != null) {\n                    m_tcpSock.close();\n                }\n\n                log().debug(\"The socket has been closed\");\n            } catch (Exception e) {\n                log().warn(\"An exception occured closing the socket: \" + e, e);\n            }\n\n            log().debug(\"Thread exiting\");\n\n            return;\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"Server connection processor started on \" + m_ipAddress + \":\" + m_tcpPort);\n        }\n\n        /*\n         *\n         * Set the initial timeout on the socket. This allows\n         * the thread to wakeup every 1/2 second and check the\n         * shutdown status.\n         */\n        try {\n            m_tcpSock.setSoTimeout(500);\n        } catch (SocketException e) {\n            if (!m_stop) {\n                log().warn(\"An I/O exception occured setting the socket timeout: \" + e, e);\n            }\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"Thread exiting due to socket error: \" + e, e);\n            }\n\n            return;\n        }\n        \n        // used to avoid seeing the trace message repeatedly\n        boolean ioInterrupted = false;\n\n        /*\n         * Check the status of the fiber and respond\n         * correctly. When the fiber enters a STOPPED or\n         * STOP PENDING state then shutdown occurs by exiting\n         * the while loop\n         */\n        while (m_parent.getStatus() != Fiber.STOPPED && m_parent.getStatus() != Fiber.STOP_PENDING && !m_stop) {\n            try {\n                if (log().isDebugEnabled() && !ioInterrupted) {\n                    log().debug(\"Waiting for new connection\");\n                }\n\n                /*\n                 * Get the newbie socket connection from the client.\n                 * After accepting the connection start up a thread\n                 * to process the request\n                 */\n                Socket newbie = m_tcpSock.accept();\n                ioInterrupted = false; // reset the flag\n\n                // build a connection string for the thread identifier\n                StringBuffer connection = new StringBuffer(newbie.getInetAddress().getHostAddress());\n                connection.append(\":\").append(newbie.getPort());\n\n                if (log().isDebugEnabled()) {\n                    log().debug(\"New connection accepted from \" + connection);\n                }\n\n                // start a new handler\n                TcpStreamHandler handler = new TcpStreamHandler(m_parent, newbie, m_handlers, m_recsPerConn);\n                Thread processor = new Thread(handler, m_parent.getName() + \"[\" + connection + \"]\");\n                synchronized (processor) {\n                    processor.start();\n                    try {\n                        processor.wait();\n                    } catch (InterruptedException e) {\n                        log().warn(\"The thread was interrupted: \" + e, e);\n                    }\n                }\n\n                log().debug(\"A new stream handler thread has been started\");\n\n                // add the handler to the list\n                m_receivers.add(handler);\n            } catch (InterruptedIOException e) {\n                /*\n                 * do nothing on interrupted I/O\n                 * DON'T Continue, the end of the loop\n                 * checks and removes terminated threads\n                 */\n                ioInterrupted = true;\n            } catch (IOException e) {\n                log().error(\"Server Socket I/O Error: \" + e, e);\n                break;\n            }\n\n            /*\n             * Go through the threads in the list of\n             * receivers and find the dead ones. When\n             * they are no longer alive just remove them\n             * from the list.\n             */\n            Iterator<TcpStreamHandler> i = m_receivers.iterator();\n            while (i.hasNext()) {\n                TcpStreamHandler t = i.next();\n                if (!t.isAlive()) {\n                    i.remove();\n                }\n            }\n        }\n\n        // Either a fatal I/O error has occured or the service has been stopped.\n        try {\n            log().debug(\"closing the server socket connection\");\n\n            m_tcpSock.close();\n        } catch (Throwable t) {\n            log().error(\"An I/O Error Occcured Closing the Server Socket: \" + t, t);\n        }\n\n        // Log the termination of this runnable\n        log().debug(\"TCP Server Shutdown\");\n    }","id":30831,"modified_method":"/**\n     * The logic execution context to accept and process incomming connection\n     * requests. When a new connection is received a new thread of control is\n     * crated to process the connection. This method encapsulates that control\n     * logic so that it can be executed in it's own java thread.\n     */\n    public void run() {\n        // get the thread context for the ability to stop the process\n        m_context = Thread.currentThread();\n        synchronized (m_context) {\n            m_context.notifyAll();\n        }\n\n        // get the log information\n        ThreadCategory.setPrefix(m_logPrefix);\n        \n        // check to see if the thread has already been stopped.\n        if (m_stop) {\n            log().debug(\"Stop flag set on thread startup\");\n\n            try {\n                if (m_tcpSock != null) {\n                    m_tcpSock.close();\n                }\n\n                log().debug(\"The socket has been closed\");\n            } catch (Throwable e) {\n                log().warn(\"An exception occured closing the socket: \" + e, e);\n            }\n\n            log().debug(\"Thread exiting\");\n\n            return;\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"Server connection processor started on \" + m_ipAddress + \":\" + m_tcpPort);\n        }\n\n        /*\n         *\n         * Set the initial timeout on the socket. This allows\n         * the thread to wakeup every 1/2 second and check the\n         * shutdown status.\n         */\n        try {\n            m_tcpSock.setSoTimeout(500);\n        } catch (SocketException e) {\n            if (!m_stop) {\n                log().warn(\"An I/O exception occured setting the socket timeout: \" + e, e);\n            }\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"Thread exiting due to socket error: \" + e, e);\n            }\n\n            return;\n        }\n        \n        // used to avoid seeing the trace message repeatedly\n        boolean ioInterrupted = false;\n\n        /*\n         * Check the status of the fiber and respond\n         * correctly. When the fiber enters a STOPPED or\n         * STOP PENDING state then shutdown occurs by exiting\n         * the while loop\n         */\n        while (m_parent.getStatus() != Fiber.STOPPED && m_parent.getStatus() != Fiber.STOP_PENDING && !m_stop) {\n            try {\n                if (log().isDebugEnabled() && !ioInterrupted) {\n                    log().debug(\"Waiting for new connection\");\n                }\n\n                /*\n                 * Get the newbie socket connection from the client.\n                 * After accepting the connection start up a thread\n                 * to process the request\n                 */\n                Socket newbie = m_tcpSock.accept();\n                ioInterrupted = false; // reset the flag\n\n                // build a connection string for the thread identifier\n                StringBuffer connection = new StringBuffer(newbie.getInetAddress().getHostAddress());\n                connection.append(\":\").append(newbie.getPort());\n\n                if (log().isDebugEnabled()) {\n                    log().debug(\"New connection accepted from \" + connection);\n                }\n\n                // start a new handler\n                TcpStreamHandler handler = new TcpStreamHandler(m_parent, newbie, m_handlers, m_recsPerConn);\n                Thread processor = new Thread(handler, m_parent.getName() + \"[\" + connection + \"]\");\n                synchronized (processor) {\n                    processor.start();\n                    try {\n                        processor.wait();\n                    } catch (InterruptedException e) {\n                        log().warn(\"The thread was interrupted: \" + e, e);\n                    }\n                }\n\n                log().debug(\"A new stream handler thread has been started\");\n\n                // add the handler to the list\n                m_receivers.add(handler);\n            } catch (InterruptedIOException e) {\n                /*\n                 * do nothing on interrupted I/O\n                 * DON'T Continue, the end of the loop\n                 * checks and removes terminated threads\n                 */\n                ioInterrupted = true;\n            } catch (IOException e) {\n                log().error(\"Server Socket I/O Error: \" + e, e);\n                break;\n            }\n\n            /*\n             * Go through the threads in the list of\n             * receivers and find the dead ones. When\n             * they are no longer alive just remove them\n             * from the list.\n             */\n            Iterator<TcpStreamHandler> i = m_receivers.iterator();\n            while (i.hasNext()) {\n                TcpStreamHandler t = i.next();\n                if (!t.isAlive()) {\n                    i.remove();\n                }\n            }\n        }\n\n        // Either a fatal I/O error has occured or the service has been stopped.\n        try {\n            log().debug(\"closing the server socket connection\");\n\n            m_tcpSock.close();\n        } catch (Throwable t) {\n            log().error(\"An I/O Error Occcured Closing the Server Socket: \" + t, t);\n        }\n\n        // Log the termination of this runnable\n        log().debug(\"TCP Server Shutdown\");\n    }","commit_id":"98fa90465f5abaefd355b1ddef2b1c1d835ae02f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected XMPPNotificationManager() {\n\n\t\t// get the category logger\n\t\t\n\t\tThreadCategory.setPrefix(LOG4J_CATEGORY);\n\t\t\n\t\t// Load up some properties\n\n\t    File config = null;\n\t    try {\n\t        config = ConfigFileConstants.getFile(ConfigFileConstants.XMPP_CONFIG_FILE_NAME);\n\t    } catch (IOException e) {\n\t        log().warn(ConfigFileConstants.XMPP_CONFIG_FILE_NAME + \" not readable\", e);\n\t    }\n\t\tif (Boolean.getBoolean(\"useSystemXMPPConfig\") || !config.canRead()) {\n\t\t    this.props = System.getProperties();\n\t\t} else {\n\t\t    FileInputStream fis = null;\n\t\t    try {\n\t\t        fis = new FileInputStream(config);\n\t\t        this.props.load(fis);\n\t\t    } catch (IOException e) {\n\t\t        log().warn(\"unable to load \" + config, e);\n\t\t    } finally {\n\t\t        IOUtils.closeQuietly(fis);\n\t\t    }\n\t\t}\n\n\t\txmppServer = this.props.getProperty(\"xmpp.server\");\n\t\txmppServiceName = this.props.getProperty(\"xmpp.servicename\", xmppServer);\n\t\txmppUser = this.props.getProperty(\"xmpp.user\");\n\t\txmppPassword = this.props.getProperty(\"xmpp.pass\");\n\t\txmppPort = Integer.valueOf(this.props.getProperty(\"xmpp.port\", XMPP_PORT));\n\n\t\txmppConfig = new ConnectionConfiguration(xmppServer, xmppPort, xmppServiceName);\n\n\t\tboolean debuggerEnabled = Boolean.parseBoolean(props.getProperty(\"xmpp.debuggerEnabled\"));\n\t\txmppConfig.setDebuggerEnabled(debuggerEnabled);\n\t\tif (debuggerEnabled) {\n\t\t    log().setLevel(Level.DEBUG);\n\t\t}\n\n\t\txmppConfig.setSASLAuthenticationEnabled(Boolean.parseBoolean(props.getProperty(\"xmpp.SASLEnabled\", \"true\")));\n\t\txmppConfig.setSelfSignedCertificateEnabled(Boolean.parseBoolean(props.getProperty(\"xmpp.selfSignedCertificateEnabled\")));\n\n\t\tif (Boolean.parseBoolean(props.getProperty(\"xmpp.TLSEnabled\"))) {\n\t\t\txmppConfig.setSecurityMode(SecurityMode.enabled);\n\t\t} else {\n\t\t    xmppConfig.setSecurityMode(SecurityMode.disabled);\n\t\t}\n\t\tif (this.props.containsKey(\"xmpp.truststorePassword\")) {\n\t\t\txmppConfig.setTruststorePassword(this.props.getProperty(\"xmpp.truststorePassword\"));\n\t\t} else {\n\t\t\txmppConfig.setTruststorePassword(TRUST_STORE_PASSWORD);\n\t\t}\n\n\t\tif (log().isDebugEnabled()) {\n\t\t    log().debug(\"XMPP Manager connection config: \" + xmppConfig.toString());\n\t\t}\n\n        xmpp = new XMPPConnection(xmppConfig);\n\n        // Connect to xmpp server\n\t\tconnectToServer();\n\n\t}","id":30832,"modified_method":"protected XMPPNotificationManager() {\n\n\t\t// get the category logger\n\t\tString oldPrefix = ThreadCategory.getPrefix();\n\t\tThreadCategory.setPrefix(LOG4J_CATEGORY);\n\n\t\ttry {\n\t\t\t// Load up some properties\n\n\t\t\tFile config = null;\n\t\t\ttry {\n\t\t\t\tconfig = ConfigFileConstants.getFile(ConfigFileConstants.XMPP_CONFIG_FILE_NAME);\n\t\t\t} catch (IOException e) {\n\t\t\t\tlog().warn(ConfigFileConstants.XMPP_CONFIG_FILE_NAME + \" not readable\", e);\n\t\t\t}\n\t\t\tif (Boolean.getBoolean(\"useSystemXMPPConfig\") || !config.canRead()) {\n\t\t\t\tthis.props.putAll(System.getProperties());\n\t\t\t} else {\n\t\t\t\tFileInputStream fis = null;\n\t\t\t\ttry {\n\t\t\t\t\tfis = new FileInputStream(config);\n\t\t\t\t\tthis.props.load(fis);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tlog().warn(\"unable to load \" + config, e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog().warn(\"unable to load \" + config, e);\n\t\t\t\t} finally {\n\t\t\t\t\tIOUtils.closeQuietly(fis);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txmppServer = this.props.getProperty(\"xmpp.server\");\n\t\t\txmppServiceName = this.props.getProperty(\"xmpp.servicename\", xmppServer);\n\t\t\txmppUser = this.props.getProperty(\"xmpp.user\");\n\t\t\txmppPassword = this.props.getProperty(\"xmpp.pass\");\n\t\t\txmppPort = Integer.valueOf(this.props.getProperty(\"xmpp.port\", XMPP_PORT));\n\n\t\t\txmppConfig = new ConnectionConfiguration(xmppServer, xmppPort, xmppServiceName);\n\n\t\t\tboolean debuggerEnabled = Boolean.parseBoolean(props.getProperty(\"xmpp.debuggerEnabled\"));\n\t\t\txmppConfig.setDebuggerEnabled(debuggerEnabled);\n\t\t\tif (debuggerEnabled) {\n\t\t\t\tlog().setLevel(Level.DEBUG);\n\t\t\t}\n\n\t\t\txmppConfig.setSASLAuthenticationEnabled(Boolean.parseBoolean(props.getProperty(\"xmpp.SASLEnabled\", \"true\")));\n\t\t\txmppConfig.setSelfSignedCertificateEnabled(Boolean.parseBoolean(props.getProperty(\"xmpp.selfSignedCertificateEnabled\")));\n\n\t\t\tif (Boolean.parseBoolean(props.getProperty(\"xmpp.TLSEnabled\"))) {\n\t\t\t\txmppConfig.setSecurityMode(SecurityMode.enabled);\n\t\t\t} else {\n\t\t\t\txmppConfig.setSecurityMode(SecurityMode.disabled);\n\t\t\t}\n\t\t\tif (this.props.containsKey(\"xmpp.truststorePassword\")) {\n\t\t\t\txmppConfig.setTruststorePassword(this.props.getProperty(\"xmpp.truststorePassword\"));\n\t\t\t} else {\n\t\t\t\txmppConfig.setTruststorePassword(TRUST_STORE_PASSWORD);\n\t\t\t}\n\n\t\t\tif (log().isDebugEnabled()) {\n\t\t\t\tlog().debug(\"XMPP Manager connection config: \" + xmppConfig.toString());\n\t\t\t}\n\n\t\t\txmpp = new XMPPConnection(xmppConfig);\n\n\t\t\t// Connect to xmpp server\n\t\t\tconnectToServer();\n\t\t} finally {\n\t\t\tThreadCategory.setPrefix(oldPrefix);\n\t\t}\n\t}","commit_id":"98fa90465f5abaefd355b1ddef2b1c1d835ae02f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Category log() {\n    \treturn ThreadCategory.getInstance();\n    }","id":30833,"modified_method":"protected Category log() {\n\t\treturn ThreadCategory.getInstance(this.getClass());\n\t}","commit_id":"98fa90465f5abaefd355b1ddef2b1c1d835ae02f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Check if manager is logged in to xmpp server.\n     * \n     * @return true if logged in, false otherwise\n     */\n\n    private void login() {\n        try {\n            if (xmpp.isConnected()) {\n                log().debug(\"XMPP Manager logging in\");\n                xmpp.login(xmppUser, xmppPassword, XMPP_RESOURCE);\n                rooms = new HashMap<String, MultiUserChat>();\n            } else {\n                log().debug(\"XMPP Manager unable to login: Not connected to XMPP server\");\n            }\n        } catch (Exception e) {\n            log().fatal(\"XMPP Manager unable to login: \", e);\n        }\n    }","id":30834,"modified_method":"/**\n     * Check if manager is logged in to xmpp server.\n     * \n     * @return true if logged in, false otherwise\n     */\n\n    private void login() {\n        try {\n            if (xmpp.isConnected()) {\n                log().debug(\"XMPP Manager logging in\");\n                xmpp.login(xmppUser, xmppPassword, XMPP_RESOURCE);\n                rooms.clear();\n            } else {\n                log().debug(\"XMPP Manager unable to login: Not connected to XMPP server\");\n            }\n        } catch (Exception e) {\n            log().fatal(\"XMPP Manager unable to login: \", e);\n        }\n    }","commit_id":"98fa90465f5abaefd355b1ddef2b1c1d835ae02f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"static ModelNode parseHostAccessLog(XMLExtendedStreamReader reader)  throws XMLStreamException {\n        final ModelNode log = new ModelNode();\n        return log;\n    }","id":30835,"modified_method":"static ModelNode parseHostAccessLog(XMLExtendedStreamReader reader)  throws XMLStreamException {\n        final ModelNode log = new ModelNode();\n        log.setEmptyObject();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n            case PATTERN:\n                log.get(PATTERN).set(value);\n                break;\n            case RESOLVE_HOSTS:\n                log.get(RESOLVE_HOSTS).set(value);\n                break;\n            case EXTENDED:\n                log.get(EXTENDED).set(value);\n                break;\n            case PREFIX:\n                log.get(PREFIX).set(value);\n                break;\n            case ROTATE:\n                log.get(ROTATE).set(value);\n                break;\n            default:\n                unexpectedAttribute(reader, i);\n            }\n        }\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n            case WEB_1_0: {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                case DIRECTORY:\n                    final ModelNode directory = new ModelNode();\n                    log.get(DIRECTORY).set(directory);\n                    final int count2 = reader.getAttributeCount();\n                    for (int i = 0; i < count2; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final String value = reader.getAttributeValue(i);\n                        final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                        case PATH:\n                            directory.get(PATH).set(value);\n                            break;\n                        case RELATIVE_TO:\n                            directory.get(RELATIVE_TO).set(value);\n                            break;\n                        default:\n                            unexpectedAttribute(reader, i);\n                        }\n                    }\n                    break;\n                default:\n                    throw unexpectedElement(reader);\n                }\n                break;\n            }\n            default:\n                throw unexpectedElement(reader);\n            }\n        }\n        return log;\n    }","commit_id":"807bdad18a1337b98a56e8fbfb68ad183112f7aa","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void parseHost(XMLExtendedStreamReader reader, final ModelNode address, List<ModelNode> list) throws XMLStreamException {\n        String name = null;\n        String defaultWebModule = null;\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    name = value;\n                    break;\n                case DEFAULT_WEB_MODULE:\n                    defaultWebModule = value;\n                    break;\n                default:\n                    unexpectedAttribute(reader, i);\n            }\n        }\n        if(name == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n\n        final ModelNode host = new ModelNode();\n        host.get(OP).set(ADD);\n        host.get(OP_ADDR).set(address).add(VIRTUAL_SERVER, name);\n        if (defaultWebModule != null) {\n            host.get(DEFAULT_WEB_MODULE).set(defaultWebModule);\n        }\n        list.add(host);\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n            case WEB_1_0: {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                case ALIAS:\n                    host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                    break;\n                case ACCESS_LOG:\n                    final ModelNode log = parseHostAccessLog(reader);\n                    host.get(ACCESS_LOG).set(log);\n                    break;\n                case REWRITE:\n                    final ModelNode rewrite = parseHostRewrite(reader);\n                    host.get(REWRITE).set(rewrite);\n                    break;\n                default:\n                    throw unexpectedElement(reader);\n                }\n                break;\n            }\n            default:\n                throw unexpectedElement(reader);\n            }\n        }\n    }","id":30836,"modified_method":"static void parseHost(XMLExtendedStreamReader reader, final ModelNode address, List<ModelNode> list) throws XMLStreamException {\n        String name = null;\n        String defaultWebModule = null;\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME:\n                    name = value;\n                    break;\n                case DEFAULT_WEB_MODULE:\n                    defaultWebModule = value;\n                    break;\n                default:\n                    unexpectedAttribute(reader, i);\n            }\n        }\n        if(name == null) {\n            throw missingRequired(reader, Collections.singleton(Attribute.NAME));\n        }\n\n        final ModelNode host = new ModelNode();\n        host.get(OP).set(ADD);\n        host.get(OP_ADDR).set(address).add(VIRTUAL_SERVER, name);\n        if (defaultWebModule != null) {\n            host.get(DEFAULT_WEB_MODULE).set(defaultWebModule);\n        }\n        list.add(host);\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n            case WEB_1_0: {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                case ALIAS:\n                    host.get(ALIAS).add(readStringAttributeElement(reader, Attribute.NAME.getLocalName()));\n                    break;\n                case ACCESS_LOG:\n                    final ModelNode log = parseHostAccessLog(reader);\n                    host.get(ACCESS_LOG).set(log);\n                    break;\n                case REWRITE:\n                    final ModelNode rewrite = parseHostRewrite(reader);\n                    host.get(REWRITE).add(rewrite);\n                    break;\n                default:\n                    throw unexpectedElement(reader);\n                }\n                break;\n            }\n            default:\n                throw unexpectedElement(reader);\n            }\n        }\n    }","commit_id":"807bdad18a1337b98a56e8fbfb68ad183112f7aa","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode parseHostRewrite(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final ModelNode rewrite = new ModelNode();\n        return rewrite;\n    }","id":30837,"modified_method":"static ModelNode parseHostRewrite(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final ModelNode rewrite = new ModelNode();\n        rewrite.setEmptyObject();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n            case PATTERN:\n                rewrite.get(PATTERN).set(value);\n                break;\n            case SUBSTITUTION:\n                rewrite.get(SUBSTITUTION).set(value);\n                break;\n            case FLAGS:\n                rewrite.get(REWRITE).set(value);\n                break;\n            default:\n                unexpectedAttribute(reader, i);\n            }\n        }\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n            case WEB_1_0: {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                case CONDITION:\n                    final ModelNode condition = new ModelNode();\n                    final int count2 = reader.getAttributeCount();\n                    for (int i = 0; i < count2; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final String value = reader.getAttributeValue(i);\n                        final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                        case TEST:\n                            condition.get(TEST).set(value);\n                            break;\n                        case PATTERN:\n                            condition.get(PATTERN).set(value);\n                            break;\n                        case FLAGS:\n                            condition.get(FLAGS).set(value);\n                            break;\n                        default:\n                            unexpectedAttribute(reader, i);\n                        }\n                    }\n                    rewrite.get(CONDITION).add(condition);\n                    break;\n                default:\n                    throw unexpectedElement(reader);\n                }\n                break;\n            }\n            default:\n                throw unexpectedElement(reader);\n            }\n        }\n        return rewrite;\n    }","commit_id":"807bdad18a1337b98a56e8fbfb68ad183112f7aa","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode parseSsl(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final ModelNode ssl = new ModelNode();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n            case NAME:\n                ssl.get(NAME).set(value);\n                break;\n            case KEY_ALIAS:\n                ssl.get(KEY_ALIAS).set(value);\n                break;\n            case PASSWORD:\n                ssl.get(PASSWORD).set(value);\n            case CERTIFICATE_KEY_FILE:\n                ssl.get(CERTIFICATE_KEY_FILE).set(value);\n                break;\n            case CIPHER_SUITE:\n                ssl.get(CIPHER_SUITE).set(value);\n                break;\n            case PROTOCOL:\n                ssl.get(PROTOCOL).set(value);\n                break;\n            case VERIFY_CLIENT:\n                ssl.get(VERIFY_CLIENT).set(value);\n                break;\n            case VERIFY_DEPTH:\n                ssl.get(VERIFY_DEPTH).set(value);\n                break;\n            case CERTIFICATE_FILE:\n                ssl.get(CERTIFICATE_FILE).set(value);\n                break;\n            case CA_CERTIFICATE_FILE:\n                ssl.get(CA_CERTIFICATE_FILE).set(value);\n                break;\n            case CA_REVOCATION_URL:\n                ssl.get(CA_REVOCATION_URL).set(value);\n                break;\n            case SESSION_CACHE_SIZE:\n                ssl.get(SESSION_CACHE_SIZE).set(value);\n                break;\n            case SESSION_TIMEOUT:\n                ssl.get(SESSION_TIMEOUT).set(value);\n                break;\n           default:\n                unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n        return ssl;\n    }","id":30838,"modified_method":"static ModelNode parseSsl(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final ModelNode ssl = new ModelNode();\n        ssl.setEmptyObject();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n            case NAME:\n                ssl.get(NAME).set(value);\n                break;\n            case KEY_ALIAS:\n                ssl.get(KEY_ALIAS).set(value);\n                break;\n            case PASSWORD:\n                ssl.get(PASSWORD).set(value);\n            case CERTIFICATE_KEY_FILE:\n                ssl.get(CERTIFICATE_KEY_FILE).set(value);\n                break;\n            case CIPHER_SUITE:\n                ssl.get(CIPHER_SUITE).set(value);\n                break;\n            case PROTOCOL:\n                ssl.get(PROTOCOL).set(value);\n                break;\n            case VERIFY_CLIENT:\n                ssl.get(VERIFY_CLIENT).set(value);\n                break;\n            case VERIFY_DEPTH:\n                ssl.get(VERIFY_DEPTH).set(value);\n                break;\n            case CERTIFICATE_FILE:\n                ssl.get(CERTIFICATE_FILE).set(value);\n                break;\n            case CA_CERTIFICATE_FILE:\n                ssl.get(CA_CERTIFICATE_FILE).set(value);\n                break;\n            case CA_REVOCATION_URL:\n                ssl.get(CA_REVOCATION_URL).set(value);\n                break;\n            case SESSION_CACHE_SIZE:\n                ssl.get(SESSION_CACHE_SIZE).set(value);\n                break;\n            case SESSION_TIMEOUT:\n                ssl.get(SESSION_TIMEOUT).set(value);\n                break;\n           default:\n                unexpectedAttribute(reader, i);\n            }\n        }\n        requireNoContent(reader);\n        return ssl;\n    }","commit_id":"807bdad18a1337b98a56e8fbfb68ad183112f7aa","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Valve createAccessLogValve(final String logDirectory, final ModelNode element) {\n        final AccessLogValve log = new AccessLogValve();\n        log.setDirectory(logDirectory);\n        log.setResolveHosts(element.get(Constants.RESOLVE_HOSTS).asBoolean());\n        log.setRotatable(element.get(Constants.ROTATE).asBoolean());\n        log.setPattern(element.get(Constants.PATTERN).asString());\n        log.setPrefix(element.get(Constants.PREFIX).asString());\n        // TODO extended?\n        return log;\n    }","id":30839,"modified_method":"static Valve createAccessLogValve(final String logDirectory, final ModelNode element) {\n        boolean extended = false;\n        if (element.hasDefined(Constants.EXTENDED)) {\n            extended = element.get(Constants.EXTENDED).asBoolean();\n        }\n        final AccessLogValve log;\n        if (extended) {\n            log = new ExtendedAccessLogValve();\n        } else {\n            log = new AccessLogValve();\n        }\n        log.setDirectory(logDirectory);\n        if (element.hasDefined(Constants.RESOLVE_HOSTS)) log.setResolveHosts(element.get(Constants.RESOLVE_HOSTS).asBoolean());\n        if (element.hasDefined(Constants.ROTATE)) log.setRotatable(element.get(Constants.ROTATE).asBoolean());\n        if (element.hasDefined(Constants.PATTERN)) {\n            log.setPattern(element.get(Constants.PATTERN).asString());\n        } else {\n            log.setPattern(\"common\");\n        }\n        if (element.hasDefined(Constants.PREFIX)) log.setPrefix(element.get(Constants.PREFIX).asString());\n        return log;\n    }","commit_id":"807bdad18a1337b98a56e8fbfb68ad183112f7aa","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute() throws MojoExecutionException\n    {\n        ArtifactRepository distributionRepository = project.getDistributionManagementArtifactRepository();\n        \n        String distributionRepositoryId = distributionRepository.getId();\n\n        List remoteArtifactRepositories = project.getRemoteArtifactRepositories();\n\n        ArtifactRepository readRemoteRepository = null;\n\n        for ( Iterator it = remoteArtifactRepositories.iterator(); it.hasNext(); )\n        {\n            ArtifactRepository currentRepository = (ArtifactRepository) it.next();\n\n            if ( distributionRepositoryId.equals( currentRepository.getId() ) )\n            {\n                readRemoteRepository = currentRepository;\n                \n                break;\n            }\n        }\n        \n        PluginMappingXpp3Reader mappingReader = new PluginMappingXpp3Reader();\n        \n        PluginMap pluginMap = null;\n        \n        RepositoryMetadata metadata = new PluginMappingMetadata( project.getGroupId() );\n        \n        try\n        {\n            repositoryMetadataManager.resolve( metadata, readRemoteRepository, localRepository );\n            \n            Reader reader = null;\n            \n            File metadataFile = metadata.getFile();\n            \n            try\n            {\n                reader = new FileReader( metadataFile );\n\n                pluginMap = mappingReader.read( reader );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot read plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new MojoExecutionException( \"Cannot parse plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n        }\n        catch ( RepositoryMetadataManagementException e )\n        {\n            Throwable cause = e.getCause();\n            \n            if ( cause != null && ( cause instanceof ResourceDoesNotExistException ) )\n            {\n                getLog().info( \"Cannot find \" + metadata + \" on remote repository. Creating a new one.\" );\n                getLog().debug( \"Metadata \" + metadata + \" cannot be resolved.\", e );\n                \n                pluginMap = new PluginMap();\n                pluginMap.setGroupId( project.getGroupId() );\n            }\n            else\n            {\n                throw new MojoExecutionException( \"Failed to resolve \" + metadata, e );\n            }\n        }\n        \n        boolean prefixAlreadyMapped = false;\n        \n        for ( Iterator it = pluginMap.getPlugins().iterator(); it.hasNext(); )\n        {\n            MappedPlugin preExisting = (MappedPlugin) it.next();\n            \n            if ( preExisting.getPrefix().equals( getGoalPrefix() ) )\n            {\n                prefixAlreadyMapped = true;\n                \n                if ( !preExisting.getArtifactId().equals( project.getArtifactId() ) )\n                {\n                    // TODO: In this case, should we rather just replace the existing plugin mapping??\n                    \n                    throw new MojoExecutionException( \"Cannot map plugin to it's prefix in plugins.xml metadata; the prefix: \\'\" + getGoalPrefix() + \"\\' is already mapped to: \" + preExisting.getArtifactId() ); \n                }\n                else\n                {\n                    getLog().info( \"NOT updating plugins.xml metadata; this plugin is already mapped.\" ); \n                }\n                \n                break;\n            }\n        }\n        \n        if ( !prefixAlreadyMapped )\n        {\n            MappedPlugin mappedPlugin = new MappedPlugin();\n            \n            mappedPlugin.setArtifactId( project.getArtifactId() );\n            \n            mappedPlugin.setPrefix( getGoalPrefix() );\n            \n            pluginMap.addPlugin( mappedPlugin );\n            \n            Writer writer = null;\n            try\n            {\n                File updatedMetadataFile = new File( outputDirectory, metadata.getRepositoryPath() ).getAbsoluteFile();\n\n                File dir = updatedMetadataFile.getParentFile();\n\n                if ( !dir.exists() )\n                {\n                    dir.mkdirs();\n                }\n                \n                writer = new FileWriter( updatedMetadataFile );\n                \n                PluginMappingXpp3Writer mappingWriter = new PluginMappingXpp3Writer();\n                \n                mappingWriter.write( writer, pluginMap );\n                \n                metadata.setFile( updatedMetadataFile );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Error writing repository metadata to build directory.\", e );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n    }","id":30840,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        ArtifactRepository distributionRepository = project.getDistributionManagementArtifactRepository();\n\n        String distributionRepositoryId = distributionRepository.getId();\n\n        List remoteArtifactRepositories = project.getRemoteArtifactRepositories();\n\n        ArtifactRepository readRemoteRepository = null;\n\n        for ( Iterator it = remoteArtifactRepositories.iterator(); it.hasNext(); )\n        {\n            ArtifactRepository currentRepository = (ArtifactRepository) it.next();\n\n            if ( distributionRepositoryId.equals( currentRepository.getId() ) )\n            {\n                readRemoteRepository = currentRepository;\n\n                break;\n            }\n        }\n\n        PluginMappingXpp3Reader mappingReader = new PluginMappingXpp3Reader();\n\n        PluginMap pluginMap = null;\n\n        RepositoryMetadata metadata = new PluginMappingMetadata( project.getGroupId() );\n\n        try\n        {\n            repositoryMetadataManager.resolve( metadata, readRemoteRepository, localRepository );\n\n            Reader reader = null;\n\n            File metadataFile = metadata.getFile();\n\n            try\n            {\n                reader = new FileReader( metadataFile );\n\n                pluginMap = mappingReader.read( reader );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot read plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            catch ( XmlPullParserException e )\n            {\n                throw new MojoExecutionException( \"Cannot parse plugin-mapping metadata from file: \" + metadataFile, e );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n        }\n        catch ( RepositoryMetadataManagementException e )\n        {\n            Throwable cause = e.getCause();\n\n            if ( cause != null && ( cause instanceof ResourceDoesNotExistException ) )\n            {\n                getLog().info( \"Cannot find \" + metadata + \" on remote repository. Creating a new one.\" );\n                getLog().debug( \"Metadata \" + metadata + \" cannot be resolved.\", e );\n\n                pluginMap = new PluginMap();\n                pluginMap.setGroupId( project.getGroupId() );\n            }\n            else\n            {\n                throw new MojoExecutionException( \"Failed to resolve \" + metadata, e );\n            }\n        }\n\n        for ( Iterator it = pluginMap.getPlugins().iterator(); it.hasNext(); )\n        {\n            MappedPlugin preExisting = (MappedPlugin) it.next();\n\n            if ( preExisting.getArtifactId().equals( project.getArtifactId() ) )\n            {\n                getLog().info( \"Updating pre-existing plugin-mapping metadata.\" );\n\n                pluginMap.removePlugin( preExisting );\n\n                break;\n            }\n        }\n\n        MappedPlugin mappedPlugin = new MappedPlugin();\n\n        mappedPlugin.setArtifactId( project.getArtifactId() );\n\n        mappedPlugin.setPrefix( getGoalPrefix() );\n\n        mappedPlugin.setPackagingHandlers( extractPackagingHandlers() );\n\n        pluginMap.addPlugin( mappedPlugin );\n\n        Writer writer = null;\n        try\n        {\n            File updatedMetadataFile = new File( metadataDirectory, metadata.getRepositoryPath() ).getAbsoluteFile();\n\n            File dir = updatedMetadataFile.getParentFile();\n\n            if ( !dir.exists() )\n            {\n                dir.mkdirs();\n            }\n\n            writer = new FileWriter( updatedMetadataFile );\n\n            PluginMappingXpp3Writer mappingWriter = new PluginMappingXpp3Writer();\n\n            mappingWriter.write( writer, pluginMap );\n\n            metadata.setFile( updatedMetadataFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error writing repository metadata to build directory.\", e );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }","commit_id":"d137af63f799351e38a0374005fa399ca0e67d1f","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void addMustUnderstandAttribute(Element header,\n                                            QName name,\n                                            SoapVersion version,\n                                            AddressingPropertiesImpl maps) {\n        if (maps.getMustUnderstand().contains(name)) {\n            Element lastAdded = (Element)header.getLastChild();\n            Attr mustUnderstandAttr = \n                lastAdded.getOwnerDocument().createAttributeNS(\n                    version.getNamespace(),\n                    version.getPrefix() + \":mustUnderstand\");\n            mustUnderstandAttr.setTextContent(\"1\");\n            lastAdded.setAttributeNodeNS(mustUnderstandAttr);\n        }\n    }","id":30841,"modified_method":"private void addMustUnderstandAttribute(Element header,\n                                            QName name,\n                                            SoapMessage msg,\n                                            AddressingPropertiesImpl maps) {\n        if (maps.getMustUnderstand().contains(name)) {\n            Element lastAdded = (Element)header.getLastChild();\n            String pfx = msg.getVersion().getPrefix();\n            if (msg.hasAdditionalEnvNs()) {\n                String ns = msg.getVersion().getNamespace();\n                Map<String, String> nsMap = msg.getEnvelopeNs();\n                for (Map.Entry<String, String> entry : nsMap.entrySet()) {\n                    if (ns.equals(entry.getValue())) {\n                        pfx = entry.getKey();\n                    }\n                }\n            }\n            \n            Attr mustUnderstandAttr = \n                lastAdded.getOwnerDocument().createAttributeNS(\n                    msg.getVersion().getNamespace(),\n                    pfx + \":mustUnderstand\");\n            mustUnderstandAttr.setTextContent(\"1\");\n            lastAdded.setAttributeNodeNS(mustUnderstandAttr);\n        }\n    }","commit_id":"d55233653b5442cc976ad7818b3938535d314cc5","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Encode message in exposed version.\n     * \n     * @param maps the MAPs, where getNamespceURI() specifies the WS-Addressing\n     *  version to expose\n     * @param value the value to encode\n     * @param name the QName for the header \n     * @param clz the class\n     * @param header the SOAP header element\n     * @param marshaller the JAXB marshaller to use\n     */\n    private <T> void encodeAsExposed(AddressingPropertiesImpl maps,\n                                     SoapMessage message,\n                                     T value,\n                                     QName name,\n                                     Class<T> clz,\n                                     Element header,\n                                     Marshaller marshaller) throws JAXBException {\n        if (value != null) {\n            LOG.log(Level.INFO,\n                    \"{0} : {1}\",\n                    new Object[] {name.getLocalPart(), getLogText(value)});\n            transformer.encodeAsExposed(maps.getNamespaceURI(),\n                                        value,\n                                        name.getLocalPart(),\n                                        clz,\n                                        header,\n                                        marshaller);\n        }\n        addMustUnderstandAttribute(header,\n                                   name,\n                                   message.getVersion(),\n                                   maps);\n    }","id":30842,"modified_method":"/**\n     * Encode message in exposed version.\n     * \n     * @param maps the MAPs, where getNamespceURI() specifies the WS-Addressing\n     *  version to expose\n     * @param value the value to encode\n     * @param name the QName for the header \n     * @param clz the class\n     * @param header the SOAP header element\n     * @param marshaller the JAXB marshaller to use\n     */\n    private <T> void encodeAsExposed(AddressingPropertiesImpl maps,\n                                     SoapMessage message,\n                                     T value,\n                                     QName name,\n                                     Class<T> clz,\n                                     Element header,\n                                     Marshaller marshaller) throws JAXBException {\n        if (value != null) {\n            LOG.log(Level.INFO,\n                    \"{0} : {1}\",\n                    new Object[] {name.getLocalPart(), getLogText(value)});\n            transformer.encodeAsExposed(maps.getNamespaceURI(),\n                                        value,\n                                        name.getLocalPart(),\n                                        clz,\n                                        header,\n                                        marshaller);\n        }\n        addMustUnderstandAttribute(header,\n                                   name,\n                                   message,\n                                   maps);\n    }","commit_id":"d55233653b5442cc976ad7818b3938535d314cc5","url":"https://github.com/apache/cxf"},{"original_method":"private boolean handleHeaderPart(boolean preexistingHeaders, SoapMessage message) {\n        //add MessagePart to soapHeader if necessary\n        boolean endedHeader = false;\n        Exchange exchange = message.getExchange();\n        BindingOperationInfo bop = (BindingOperationInfo)exchange.get(BindingOperationInfo.class\n                                                                            .getName());\n        if (bop == null) {\n            return endedHeader;\n        }\n        \n        XMLStreamWriter xtw = message.getContent(XMLStreamWriter.class);        \n        boolean startedHeader = false;\n        BindingOperationInfo unwrappedOp = bop;\n        if (bop.isUnwrapped()) {\n            unwrappedOp = bop.getWrappedOperation();\n        }\n        boolean client = isRequestor(message);\n        BindingMessageInfo bmi = client ? unwrappedOp.getInput() : unwrappedOp.getOutput();\n        BindingMessageInfo wrappedBmi = client ? bop.getInput() : bop.getOutput();\n        \n        if (bmi == null) {\n            return endedHeader;\n        }\n        \n        List<MessagePartInfo> parts = wrappedBmi.getMessageInfo().getMessageParts();\n        if (parts.size() > 0) {\n            MessageContentsList objs = MessageContentsList.getContentsList(message);\n            if (objs == null) {\n                return endedHeader;\n            }\n            SoapVersion soapVersion = message.getVersion();\n            List<SoapHeaderInfo> headers = bmi.getExtensors(SoapHeaderInfo.class);\n            if (headers == null) {\n                return endedHeader;\n            }            \n\n            for (SoapHeaderInfo header : headers) {\n                MessagePartInfo part = header.getPart();\n                if (part.getIndex() >= objs.size()) {\n                    // The optional out of band header is not a part of parameters of the method\n                    continue;\n                }\n                Object arg = objs.get(part);\n                objs.remove(part);\n                if (!(startedHeader || preexistingHeaders)) {\n                    try {\n                        xtw.writeStartElement(soapVersion.getPrefix(), \n                                              soapVersion.getHeader().getLocalPart(),\n                                              soapVersion.getNamespace());\n                    } catch (XMLStreamException e) {\n                        throw new SoapFault(new org.apache.cxf.common.i18n.Message(\"XML_WRITE_EXC\", BUNDLE), \n                            e, soapVersion.getSender());\n                    }\n                    startedHeader = true;\n                }\n                DataWriter<XMLStreamWriter> dataWriter = getDataWriter(message);\n                dataWriter.write(arg, header.getPart(), xtw);\n            }\n            \n            if (startedHeader || preexistingHeaders) {\n                try {\n                    xtw.writeEndElement();\n                    endedHeader = true;\n                } catch (XMLStreamException e) {\n                    throw new SoapFault(new org.apache.cxf.common.i18n.Message(\"XML_WRITE_EXC\", BUNDLE), \n                        e, soapVersion.getSender());\n                }\n            }\n        }\n        return endedHeader;\n    }","id":30843,"modified_method":"private boolean handleHeaderPart(boolean preexistingHeaders, SoapMessage message, String soapPrefix) {\n        //add MessagePart to soapHeader if necessary\n        boolean endedHeader = false;\n        Exchange exchange = message.getExchange();\n        BindingOperationInfo bop = (BindingOperationInfo)exchange.get(BindingOperationInfo.class\n                                                                            .getName());\n        if (bop == null) {\n            return endedHeader;\n        }\n        \n        XMLStreamWriter xtw = message.getContent(XMLStreamWriter.class);        \n        boolean startedHeader = false;\n        BindingOperationInfo unwrappedOp = bop;\n        if (bop.isUnwrapped()) {\n            unwrappedOp = bop.getWrappedOperation();\n        }\n        boolean client = isRequestor(message);\n        BindingMessageInfo bmi = client ? unwrappedOp.getInput() : unwrappedOp.getOutput();\n        BindingMessageInfo wrappedBmi = client ? bop.getInput() : bop.getOutput();\n        \n        if (bmi == null) {\n            return endedHeader;\n        }\n        \n        List<MessagePartInfo> parts = wrappedBmi.getMessageInfo().getMessageParts();\n        if (parts.size() > 0) {\n            MessageContentsList objs = MessageContentsList.getContentsList(message);\n            if (objs == null) {\n                return endedHeader;\n            }\n            SoapVersion soapVersion = message.getVersion();\n            List<SoapHeaderInfo> headers = bmi.getExtensors(SoapHeaderInfo.class);\n            if (headers == null) {\n                return endedHeader;\n            }            \n\n            for (SoapHeaderInfo header : headers) {\n                MessagePartInfo part = header.getPart();\n                if (part.getIndex() >= objs.size()) {\n                    // The optional out of band header is not a part of parameters of the method\n                    continue;\n                }\n                Object arg = objs.get(part);\n                objs.remove(part);\n                if (!(startedHeader || preexistingHeaders)) {\n                    try {\n                        xtw.writeStartElement(soapPrefix, \n                                              soapVersion.getHeader().getLocalPart(),\n                                              soapVersion.getNamespace());\n                    } catch (XMLStreamException e) {\n                        throw new SoapFault(new org.apache.cxf.common.i18n.Message(\"XML_WRITE_EXC\", BUNDLE), \n                            e, soapVersion.getSender());\n                    }\n                    startedHeader = true;\n                }\n                DataWriter<XMLStreamWriter> dataWriter = getDataWriter(message);\n                dataWriter.write(arg, header.getPart(), xtw);\n            }\n            \n            if (startedHeader || preexistingHeaders) {\n                try {\n                    xtw.writeEndElement();\n                    endedHeader = true;\n                } catch (XMLStreamException e) {\n                    throw new SoapFault(new org.apache.cxf.common.i18n.Message(\"XML_WRITE_EXC\", BUNDLE), \n                        e, soapVersion.getSender());\n                }\n            }\n        }\n        return endedHeader;\n    }","commit_id":"d55233653b5442cc976ad7818b3938535d314cc5","url":"https://github.com/apache/cxf"},{"original_method":"public SOAPHeaderWriter(XMLStreamWriter writer,\n                                SoapHeader header,\n                                SoapVersion version) {\n            super(writer);\n            soapHeader = header;\n            soapVersion = version;\n        }","id":30844,"modified_method":"public SOAPHeaderWriter(XMLStreamWriter writer,\n                                SoapHeader header,\n                                SoapVersion version,\n                                String pfx) {\n            super(writer);\n            soapHeader = header;\n            soapVersion = version;\n            soapPrefix = pfx;\n        }","commit_id":"d55233653b5442cc976ad7818b3938535d314cc5","url":"https://github.com/apache/cxf"},{"original_method":"private void writeSoapEnvelopeStart(final SoapMessage message) {\n        final SoapVersion soapVersion = message.getVersion();\n        try {            \n            XMLStreamWriter xtw = message.getContent(XMLStreamWriter.class);\n            xtw.setPrefix(soapVersion.getPrefix(), soapVersion.getNamespace());\n            xtw.writeStartElement(soapVersion.getPrefix(), \n                                  soapVersion.getEnvelope().getLocalPart(),\n                                  soapVersion.getNamespace());\n            xtw.writeNamespace(soapVersion.getPrefix(), soapVersion.getNamespace());\n            \n            boolean preexistingHeaders = message.hasHeaders();\n\n            if (preexistingHeaders) {\n                xtw.writeStartElement(soapVersion.getPrefix(), \n                                      soapVersion.getHeader().getLocalPart(),\n                                      soapVersion.getNamespace());   \n                List<Header> hdrList = message.getHeaders();\n                for (Header header : hdrList) {\n                    XMLStreamWriter writer = xtw;\n                    if (header instanceof SoapHeader) {\n                        SoapHeader soapHeader = (SoapHeader)header;\n                        writer = new SOAPHeaderWriter(xtw, soapHeader, soapVersion);\n                    }\n                    DataBinding b = header.getDataBinding();\n                    if (b == null) {\n                        HeaderProcessor hp = bus.getExtension(HeaderManager.class)\n                                .getHeaderProcessor(header.getName().getNamespaceURI());\n                        if (hp != null) {\n                            b = hp.getDataBinding();\n                        }\n                    }\n                    if (b != null) {\n                        MessagePartInfo part = new MessagePartInfo(header.getName(), null);\n                        part.setConcreteName(header.getName());\n                        b.createWriter(XMLStreamWriter.class)\n                            .write(header.getObject(), part, writer);\n                    } else {\n                        Element node = (Element)header.getObject();\n                        StaxUtils.copy(node, writer);\n                    }\n                }\n            }\n            boolean endedHeader = handleHeaderPart(preexistingHeaders, message);\n            if (preexistingHeaders && !endedHeader) {\n                xtw.writeEndElement();\n            }\n\n            xtw.writeStartElement(soapVersion.getPrefix(), \n                                  soapVersion.getBody().getLocalPart(),\n                                  soapVersion.getNamespace());\n            \n            // Interceptors followed such as Wrapped/RPC/Doc Interceptor will write SOAP body\n        } catch (XMLStreamException e) {\n            throw new SoapFault(\n                new org.apache.cxf.common.i18n.Message(\"XML_WRITE_EXC\", BUNDLE), e, soapVersion.getSender());\n        }\n    }","id":30845,"modified_method":"private void writeSoapEnvelopeStart(final SoapMessage message) {\n        final SoapVersion soapVersion = message.getVersion();\n        try {            \n            XMLStreamWriter xtw = message.getContent(XMLStreamWriter.class);\n            String soapPrefix = soapVersion.getPrefix();\n            if (message.hasAdditionalEnvNs()) {\n                Map<String, String> nsMap = message.getEnvelopeNs();\n                for (Map.Entry<String, String> entry : nsMap.entrySet()) {\n                    if (soapVersion.getNamespace().equals(entry.getValue())) {\n                        soapPrefix = entry.getKey();\n                    }\n                }\n                xtw.setPrefix(soapPrefix, soapVersion.getNamespace());\n                xtw.writeStartElement(soapPrefix, \n                                      soapVersion.getEnvelope().getLocalPart(),\n                                      soapVersion.getNamespace());\n                xtw.writeNamespace(soapPrefix, soapVersion.getNamespace());\n                for (Map.Entry<String, String> entry : nsMap.entrySet()) {\n                    if (!soapVersion.getNamespace().equals(entry.getValue())) {\n                        xtw.writeNamespace(entry.getKey(), entry.getValue());\n                    }\n                }                \n            } else {\n                xtw.setPrefix(soapPrefix, soapVersion.getNamespace());\n                xtw.writeStartElement(soapPrefix, \n                                      soapVersion.getEnvelope().getLocalPart(),\n                                      soapVersion.getNamespace());\n                xtw.writeNamespace(soapPrefix, soapVersion.getNamespace());\n            }\n            boolean preexistingHeaders = message.hasHeaders();\n\n            if (preexistingHeaders) {\n                xtw.writeStartElement(soapPrefix, \n                                      soapVersion.getHeader().getLocalPart(),\n                                      soapVersion.getNamespace());   \n                List<Header> hdrList = message.getHeaders();\n                for (Header header : hdrList) {\n                    XMLStreamWriter writer = xtw;\n                    if (header instanceof SoapHeader) {\n                        SoapHeader soapHeader = (SoapHeader)header;\n                        writer = new SOAPHeaderWriter(xtw, soapHeader, soapVersion, soapPrefix);\n                    }\n                    DataBinding b = header.getDataBinding();\n                    if (b == null) {\n                        HeaderProcessor hp = bus.getExtension(HeaderManager.class)\n                                .getHeaderProcessor(header.getName().getNamespaceURI());\n                        if (hp != null) {\n                            b = hp.getDataBinding();\n                        }\n                    }\n                    if (b != null) {\n                        MessagePartInfo part = new MessagePartInfo(header.getName(), null);\n                        part.setConcreteName(header.getName());\n                        b.createWriter(XMLStreamWriter.class)\n                            .write(header.getObject(), part, writer);\n                    } else {\n                        Element node = (Element)header.getObject();\n                        StaxUtils.copy(node, writer);\n                    }\n                }\n            }\n            boolean endedHeader = handleHeaderPart(preexistingHeaders, message, soapPrefix);\n            if (preexistingHeaders && !endedHeader) {\n                xtw.writeEndElement();\n            }\n\n            xtw.writeStartElement(soapPrefix, \n                                  soapVersion.getBody().getLocalPart(),\n                                  soapVersion.getNamespace());\n            \n            // Interceptors followed such as Wrapped/RPC/Doc Interceptor will write SOAP body\n        } catch (XMLStreamException e) {\n            throw new SoapFault(\n                new org.apache.cxf.common.i18n.Message(\"XML_WRITE_EXC\", BUNDLE), e, soapVersion.getSender());\n        }\n    }","commit_id":"d55233653b5442cc976ad7818b3938535d314cc5","url":"https://github.com/apache/cxf"},{"original_method":"private void writeSoapAttributes() throws XMLStreamException {\n            if (!firstDone) {\n                firstDone = true;\n                if (!StringUtils.isEmpty(soapHeader.getActor())) {\n                    super.writeAttribute(soapVersion.getPrefix(),\n                                   soapVersion.getNamespace(),\n                                   soapVersion.getAttrNameRole(),\n                                   soapHeader.getActor());\n                }\n                if (soapHeader.isMustUnderstand()) {\n                    super.writeAttribute(soapVersion.getPrefix(),\n                                   soapVersion.getNamespace(),\n                                   soapVersion.getAttrNameMustUnderstand(),\n                                   \"true\");                                        \n                }\n            }\n        }","id":30846,"modified_method":"private void writeSoapAttributes() throws XMLStreamException {\n            if (!firstDone) {\n                firstDone = true;\n                if (!StringUtils.isEmpty(soapHeader.getActor())) {\n                    super.writeAttribute(soapPrefix,\n                                   soapVersion.getNamespace(),\n                                   soapVersion.getAttrNameRole(),\n                                   soapHeader.getActor());\n                }\n                if (soapHeader.isMustUnderstand()) {\n                    super.writeAttribute(soapPrefix,\n                                   soapVersion.getNamespace(),\n                                   soapVersion.getAttrNameMustUnderstand(),\n                                   \"true\");                                        \n                }\n            }\n        }","commit_id":"d55233653b5442cc976ad7818b3938535d314cc5","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void doBefore() throws IOException\n    {\n        FileUtils.deleteRecursively( new File( \"target/test-data/deletion\" ) );\n        db = new GraphDatabaseFactory().newEmbeddedDatabase( \"target/test-data/deletion\" );\n    }","id":30847,"modified_method":"@BeforeClass\n    public static void doBefore() throws IOException\n    {\n        FileUtils.deleteRecursively( new File( \"target/test-data/deletion\" ) );\n        db = (GraphDatabaseAPI) new GraphDatabaseFactory().newEmbeddedDatabase( \"target/test-data/deletion\" );\n    }","commit_id":"1dcb42f449bc2cf020cb0568b7c074031ac45d68","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void indexDeleteShouldDeleteDirectory()\n    {\n        String indexName = \"index\";\n        String otherIndexName = \"other-index\";\n\n        StringBuffer tempPath = new StringBuffer( ((GraphDatabaseAPI)db).getStoreDir())\n                .append(File.separator).append(\"index\").append(File.separator)\n                .append(\"lucene\").append(File.separator).append(\"node\")\n                .append(File.separator);\n\n        File pathToLuceneIndex = new File( tempPath.toString() + indexName );\n        File pathToOtherLuceneIndex = new File( tempPath.toString() + otherIndexName );\n\n        Transaction tx = db.beginTx();\n        Index<Node> index;\n        try\n        {\n            index = db.index().forNodes( indexName );\n            Index<Node> otherIndex = db.index().forNodes( otherIndexName );\n            Node node = db.createNode();\n            index.add( node, \"someKey\", \"someValue\" );\n            otherIndex.add( node, \"someKey\", \"someValue\" );\n            assertFalse( pathToLuceneIndex.exists() );\n            assertFalse( pathToOtherLuceneIndex.exists() );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n\n        // Here \"index\" and \"other-index\" indexes should exist\n\n        assertTrue( pathToLuceneIndex.exists() );\n        assertTrue( pathToOtherLuceneIndex.exists() );\n        tx = db.beginTx();\n        try\n        {\n            index.delete();\n            assertTrue( pathToLuceneIndex.exists() );\n            assertTrue( pathToOtherLuceneIndex.exists() );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n\n        // Here only \"other-index\" should exist\n\n        assertFalse( pathToLuceneIndex.exists() );\n        assertTrue( pathToOtherLuceneIndex.exists() );\n    }","id":30848,"modified_method":"@Test\n    public void indexDeleteShouldDeleteDirectory()\n    {\n        String indexName = \"index\";\n        String otherIndexName = \"other-index\";\n\n        File indexBaseDir = new File( db.getStoreDir(), \"index\" );\n        File pathToLuceneIndex = LuceneDataSource.getFileDirectory( indexBaseDir,\n                new IndexIdentifier( IndexEntityType.Node, indexName ) );\n        File pathToOtherLuceneIndex = LuceneDataSource.getFileDirectory( indexBaseDir,\n                new IndexIdentifier( IndexEntityType.Node, otherIndexName ) );\n\n        Index<Node> index;\n        try ( Transaction tx = db.beginTx() )\n        {\n            index = db.index().forNodes( indexName );\n            Index<Node> otherIndex = db.index().forNodes( otherIndexName );\n            Node node = db.createNode();\n            index.add( node, \"someKey\", \"someValue\" );\n            otherIndex.add( node, \"someKey\", \"someValue\" );\n            assertFalse( pathToLuceneIndex.exists() );\n            assertFalse( pathToOtherLuceneIndex.exists() );\n            tx.success();\n        }\n\n        // Here \"index\" and \"other-index\" indexes should exist\n\n        assertTrue( pathToLuceneIndex.exists() );\n        assertTrue( pathToOtherLuceneIndex.exists() );\n        try ( Transaction tx = db.beginTx() )\n        {\n            index.delete();\n            assertTrue( pathToLuceneIndex.exists() );\n            assertTrue( pathToOtherLuceneIndex.exists() );\n            tx.success();\n        }\n\n        // Here only \"other-index\" should exist\n\n        assertFalse( pathToLuceneIndex.exists() );\n        assertTrue( pathToOtherLuceneIndex.exists() );\n    }","commit_id":"1dcb42f449bc2cf020cb0568b7c074031ac45d68","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( final String[] args )\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        indexService = graphDb.index().forNodes( \"nodes\" );\n        registerShutdownHook();\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            /*\n             *  (Neo) --> (Trinity)\n             *     \\       ^\n             *      v     /\n             *    (Morpheus) --> (Cypher)\n             *            \\         |\n             *             v        v\n             *            (Agent Smith)\n             */\n            createChain( \"Neo\", \"Trinity\" );\n            createChain( \"Neo\", \"Morpheus\", \"Trinity\" );\n            createChain( \"Morpheus\", \"Cypher\", \"Agent Smith\" );\n            createChain( \"Morpheus\", \"Agent Smith\" );\n            tx.success();\n        }\n\n        // So let's find the shortest path between Neo and Agent Smith\n        Node neo = getOrCreateNode( \"Neo\" );\n        Node agentSmith = getOrCreateNode( \"Agent Smith\" );\n        // START SNIPPET: shortestPathUsage\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                PathExpanders.forTypeAndDirection( KNOWS, Direction.BOTH ), 4 );\n        Path foundPath = finder.findSinglePath( neo, agentSmith );\n        System.out.println( \"Path from Neo to Agent Smith: \"\n                            + Paths.simplePathToString( foundPath, NAME_KEY ) );\n        // END SNIPPET: shortestPathUsage\n\n        System.out.println( \"Shutting down database ...\" );\n        graphDb.shutdown();\n    }","id":30849,"modified_method":"public static void main( final String[] args )\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook();\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            indexService = graphDb.index().forNodes( \"nodes\" );\n            /*\n             *  (Neo) --> (Trinity)\n             *     \\       ^\n             *      v     /\n             *    (Morpheus) --> (Cypher)\n             *            \\         |\n             *             v        v\n             *            (Agent Smith)\n             */\n            createChain( \"Neo\", \"Trinity\" );\n            createChain( \"Neo\", \"Morpheus\", \"Trinity\" );\n            createChain( \"Morpheus\", \"Cypher\", \"Agent Smith\" );\n            createChain( \"Morpheus\", \"Agent Smith\" );\n            tx.success();\n        }\n\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            // So let's find the shortest path between Neo and Agent Smith\n            Node neo = getOrCreateNode( \"Neo\" );\n            Node agentSmith = getOrCreateNode( \"Agent Smith\" );\n            // START SNIPPET: shortestPathUsage\n            PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                    PathExpanders.forTypeAndDirection( KNOWS, Direction.BOTH ), 4 );\n            Path foundPath = finder.findSinglePath( neo, agentSmith );\n            System.out.println( \"Path from Neo to Agent Smith: \"\n                                + Paths.simplePathToString( foundPath, NAME_KEY ) );\n            // END SNIPPET: shortestPathUsage\n        }\n\n        System.out.println( \"Shutting down database ...\" );\n        graphDb.shutdown();\n    }","commit_id":"17efdd561a36ca1552fc4659afca2f687761b773","url":"https://github.com/neo4j/neo4j"},{"original_method":"void createDb()\n    {\n        clearDb();\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook( graphDb );\n        // END SNIPPET: startDb\n\n        // START SNIPPET: transaction\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            // Database operations go here\n            // END SNIPPET: transaction\n            // START SNIPPET: addData\n            firstNode = graphDb.createNode();\n            firstNode.setProperty( \"message\", \"Hello, \" );\n            secondNode = graphDb.createNode();\n            secondNode.setProperty( \"message\", \"World!\" );\n\n            relationship = firstNode.createRelationshipTo( secondNode, RelTypes.KNOWS );\n            relationship.setProperty( \"message\", \"brave Neo4j \" );\n            // END SNIPPET: addData\n\n            // START SNIPPET: readData\n            System.out.print( firstNode.getProperty( \"message\" ) );\n            System.out.print( relationship.getProperty( \"message\" ) );\n            System.out.print( secondNode.getProperty( \"message\" ) );\n            // END SNIPPET: readData\n\n            greeting = ( (String) firstNode.getProperty( \"message\" ) )\n                       + ( (String) relationship.getProperty( \"message\" ) )\n                       + ( (String) secondNode.getProperty( \"message\" ) );\n\n            // START SNIPPET: transaction\n            tx.success();\n        }\n        // END SNIPPET: transaction\n    }","id":30850,"modified_method":"void createDb()\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook( graphDb );\n        // END SNIPPET: startDb\n\n        // START SNIPPET: transaction\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            // Database operations go here\n            // END SNIPPET: transaction\n            // START SNIPPET: addData\n            firstNode = graphDb.createNode();\n            firstNode.setProperty( \"message\", \"Hello, \" );\n            secondNode = graphDb.createNode();\n            secondNode.setProperty( \"message\", \"World!\" );\n\n            relationship = firstNode.createRelationshipTo( secondNode, RelTypes.KNOWS );\n            relationship.setProperty( \"message\", \"brave Neo4j \" );\n            // END SNIPPET: addData\n\n            // START SNIPPET: readData\n            System.out.print( firstNode.getProperty( \"message\" ) );\n            System.out.print( relationship.getProperty( \"message\" ) );\n            System.out.print( secondNode.getProperty( \"message\" ) );\n            // END SNIPPET: readData\n\n            greeting = ( (String) firstNode.getProperty( \"message\" ) )\n                       + ( (String) relationship.getProperty( \"message\" ) )\n                       + ( (String) secondNode.getProperty( \"message\" ) );\n\n            // START SNIPPET: transaction\n            tx.success();\n        }\n        // END SNIPPET: transaction\n    }","commit_id":"17efdd561a36ca1552fc4659afca2f687761b773","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( final String[] args )\n    {\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook();\n        // END SNIPPET: startDb\n\n        // START SNIPPET: addUsers\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            nodeIndex = graphDb.index().forNodes( \"nodes\" );\n            // Create some users and index their names with the IndexService\n            for ( int id = 0; id < 100; id++ )\n            {\n                createAndIndexUser( idToUserName( id ) );\n            }\n            // END SNIPPET: addUsers\n\n            // Find a user through the search index\n            // START SNIPPET: findUser\n            int idToFind = 45;\n            String userName = idToUserName( idToFind );\n            Node foundUser = nodeIndex.get( USERNAME_KEY, userName ).getSingle();\n\n            System.out.println( \"The username of user \" + idToFind + \" is \"\n                + foundUser.getProperty( USERNAME_KEY ) );\n            // END SNIPPET: findUser\n\n            // Delete the persons and remove them from the index\n            for ( Node user : nodeIndex.query( USERNAME_KEY, \"*\" ) )\n            {\n                nodeIndex.remove(  user, USERNAME_KEY,\n                        user.getProperty( USERNAME_KEY ) );\n                user.delete();\n            }\n            tx.success();\n        }\n        shutdown();\n    }","id":30851,"modified_method":"public static void main( final String[] args )\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook();\n        // END SNIPPET: startDb\n\n        // START SNIPPET: addUsers\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            nodeIndex = graphDb.index().forNodes( \"nodes\" );\n            // Create some users and index their names with the IndexService\n            for ( int id = 0; id < 100; id++ )\n            {\n                createAndIndexUser( idToUserName( id ) );\n            }\n            // END SNIPPET: addUsers\n\n            // Find a user through the search index\n            // START SNIPPET: findUser\n            int idToFind = 45;\n            String userName = idToUserName( idToFind );\n            Node foundUser = nodeIndex.get( USERNAME_KEY, userName ).getSingle();\n\n            System.out.println( \"The username of user \" + idToFind + \" is \"\n                + foundUser.getProperty( USERNAME_KEY ) );\n            // END SNIPPET: findUser\n\n            // Delete the persons and remove them from the index\n            for ( Node user : nodeIndex.query( USERNAME_KEY, \"*\" ) )\n            {\n                nodeIndex.remove(  user, USERNAME_KEY,\n                        user.getProperty( USERNAME_KEY ) );\n                user.delete();\n            }\n            tx.success();\n        }\n        shutdown();\n    }","commit_id":"17efdd561a36ca1552fc4659afca2f687761b773","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( final String[] args )\n    {\n        System.out.println( \"Starting database ...\" );\n\n        // START SNIPPET: startDb\n        GraphDatabaseService graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        // END SNIPPET: startDb\n\n        {\n            // START SNIPPET: createIndex\n            IndexDefinition indexDefinition;\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                indexDefinition = schema.indexFor( DynamicLabel.label( \"User\" ) )\n                        .on( \"username\" )\n                        .create();\n                tx.success();\n            }\n            // END SNIPPET: createIndex\n            // START SNIPPET: wait\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                schema.awaitIndexOnline( indexDefinition, 10, TimeUnit.SECONDS );\n            }\n            // END SNIPPET: wait\n        }\n\n        {\n            // START SNIPPET: addUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n\n                // Create some users\n                for ( int id = 0; id < 100; id++ )\n                {\n                    Node userNode = graphDb.createNode( label );\n                    userNode.setProperty( \"username\", \"user\" + id + \"@neo4j.org\" );\n                }\n                System.out.println( \"Users created\" );\n                tx.success();\n            }\n            // END SNIPPET: addUsers\n        }\n\n        {\n            // START SNIPPET: findUsers\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                try ( ResourceIterator<Node> users =\n                        graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ).iterator() )\n                {\n                    ArrayList<Node> userNodes = new ArrayList<>();\n                    while ( users.hasNext() )\n                    {\n                        userNodes.add( users.next() );\n                    }\n\n                    for ( Node node : userNodes )\n                    {\n                        System.out.println( \"The username of user \" + idToFind + \" is \" + node.getProperty( \"username\" ) );\n                    }\n                }\n            }\n            // END SNIPPET: findUsers\n        }\n\n        {\n            // START SNIPPET: resourceIterator\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx();\n                  ResourceIterator<Node> users = graphDb\n                        .findNodesByLabelAndProperty( label, \"username\", nameToFind )\n                        .iterator() )\n            {\n                Node firstUserNode;\n                if ( users.hasNext() )\n                {\n                    firstUserNode = users.next();\n                }\n                users.close();\n            }\n            // END SNIPPET: resourceIterator\n        }\n\n        {\n            // START SNIPPET: updateUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 45;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.setProperty( \"username\", \"user\" + ( idToFind + 1 ) + \"@neo4j.org\" );\n                }\n                tx.success();\n            }\n            // END SNIPPET: updateUsers\n        }\n\n        {\n            // START SNIPPET: deleteUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 46;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.delete();\n                }\n                tx.success();\n            }\n            // END SNIPPET: deleteUsers\n        }\n\n        {\n            // START SNIPPET: dropIndex\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                for ( IndexDefinition indexDefinition : graphDb.schema()\n                        .getIndexes( label ) )\n                {\n                    // There is only one index\n                    indexDefinition.drop();\n                }\n\n                tx.success();\n            }\n            // END SNIPPET: dropIndex\n        }\n\n        System.out.println( \"Shutting down database ...\" );\n        // START SNIPPET: shutdownDb\n        graphDb.shutdown();\n        // END SNIPPET: shutdownDb\n    }","id":30852,"modified_method":"public static void main( final String[] args )\n    {\n        System.out.println( \"Starting database ...\" );\n        deleteFileOrDirectory( new File( DB_PATH ) );\n\n        // START SNIPPET: startDb\n        GraphDatabaseService graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        // END SNIPPET: startDb\n\n        {\n            // START SNIPPET: createIndex\n            IndexDefinition indexDefinition;\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                indexDefinition = schema.indexFor( DynamicLabel.label( \"User\" ) )\n                        .on( \"username\" )\n                        .create();\n                tx.success();\n            }\n            // END SNIPPET: createIndex\n            // START SNIPPET: wait\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                schema.awaitIndexOnline( indexDefinition, 10, TimeUnit.SECONDS );\n            }\n            // END SNIPPET: wait\n        }\n\n        {\n            // START SNIPPET: addUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n\n                // Create some users\n                for ( int id = 0; id < 100; id++ )\n                {\n                    Node userNode = graphDb.createNode( label );\n                    userNode.setProperty( \"username\", \"user\" + id + \"@neo4j.org\" );\n                }\n                System.out.println( \"Users created\" );\n                tx.success();\n            }\n            // END SNIPPET: addUsers\n        }\n\n        {\n            // START SNIPPET: findUsers\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                try ( ResourceIterator<Node> users =\n                        graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ).iterator() )\n                {\n                    ArrayList<Node> userNodes = new ArrayList<>();\n                    while ( users.hasNext() )\n                    {\n                        userNodes.add( users.next() );\n                    }\n\n                    for ( Node node : userNodes )\n                    {\n                        System.out.println( \"The username of user \" + idToFind + \" is \" + node.getProperty( \"username\" ) );\n                    }\n                }\n            }\n            // END SNIPPET: findUsers\n        }\n\n        {\n            // START SNIPPET: resourceIterator\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx();\n                  ResourceIterator<Node> users = graphDb\n                        .findNodesByLabelAndProperty( label, \"username\", nameToFind )\n                        .iterator() )\n            {\n                Node firstUserNode;\n                if ( users.hasNext() )\n                {\n                    firstUserNode = users.next();\n                }\n                users.close();\n            }\n            // END SNIPPET: resourceIterator\n        }\n\n        {\n            // START SNIPPET: updateUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 45;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.setProperty( \"username\", \"user\" + ( idToFind + 1 ) + \"@neo4j.org\" );\n                }\n                tx.success();\n            }\n            // END SNIPPET: updateUsers\n        }\n\n        {\n            // START SNIPPET: deleteUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 46;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.delete();\n                }\n                tx.success();\n            }\n            // END SNIPPET: deleteUsers\n        }\n\n        {\n            // START SNIPPET: dropIndex\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                for ( IndexDefinition indexDefinition : graphDb.schema()\n                        .getIndexes( label ) )\n                {\n                    // There is only one index\n                    indexDefinition.drop();\n                }\n\n                tx.success();\n            }\n            // END SNIPPET: dropIndex\n        }\n\n        System.out.println( \"Shutting down database ...\" );\n        // START SNIPPET: shutdownDb\n        graphDb.shutdown();\n        // END SNIPPET: shutdownDb\n    }","commit_id":"17efdd561a36ca1552fc4659afca2f687761b773","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void setUp() throws IOException\n    {\n        deleteRecursively( new File( MATRIX_DB ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( MATRIX_DB );\n        registerShutdownHook();\n        createNodespace();\n    }","id":30853,"modified_method":"public void setUp()\n    {\n        deleteFileOrDirectory( new File( MATRIX_DB ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( MATRIX_DB );\n        registerShutdownHook();\n        createNodespace();\n    }","commit_id":"17efdd561a36ca1552fc4659afca2f687761b773","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void startLocalShell() throws Exception\n    {\n        graphDb = (GraphDatabaseAPI) new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        createExampleGraph();\n        ShellServer shellServer = new GraphDatabaseShellServer( graphDb );\n        ShellLobby.newClient( shellServer ).grabPrompt();\n        shellServer.shutdown();\n    }","id":30854,"modified_method":"private static void startLocalShell() throws Exception\n    {\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        createExampleGraph();\n        ShellServer shellServer = new GraphDatabaseShellServer( (org.neo4j.kernel.GraphDatabaseAPI) graphDb );\n        ShellLobby.newClient( shellServer ).grabPrompt();\n        shellServer.shutdown();\n    }","commit_id":"17efdd561a36ca1552fc4659afca2f687761b773","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void startRemoteShellAndWait() throws Exception\n    {\n        graphDb = (GraphDatabaseAPI) new GraphDatabaseFactory().newEmbeddedDatabaseBuilder( DB_PATH ).\n                setConfig( ShellSettings.remote_shell_enabled, Settings.TRUE ).\n                newGraphDatabase();\n\n        createExampleGraph();\n        waitForUserInput( \"Remote shell enabled, connect to it by executing\\n\"\n                + \"the shell-client script in a separate terminal.\"\n                + \"The script is located in the bin directory.\\n\"\n                + \"\\nWhen you're done playing around, just press [Enter] \"\n                + \"in this terminal \" );\n    }","id":30855,"modified_method":"private static void startRemoteShellAndWait() throws Exception\n    {\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder( DB_PATH )\n                .\n                setConfig( ShellSettings.remote_shell_enabled, Settings.TRUE ).\n                newGraphDatabase();\n\n        createExampleGraph();\n        waitForUserInput( \"Remote shell enabled, connect to it by executing\\n\"\n                + \"the shell-client script in a separate terminal.\"\n                + \"The script is located in the bin directory.\\n\"\n                + \"\\nWhen you're done playing around, just press [Enter] \"\n                + \"in this terminal \" );\n    }","commit_id":"17efdd561a36ca1552fc4659afca2f687761b773","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( final String[] args )\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        indexService = graphDb.index().forNodes( \"nodes\" );\n        registerShutdownHook();\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            /*\n             *  (Neo) --> (Trinity)\n             *     \\       ^\n             *      v     /\n             *    (Morpheus) --> (Cypher)\n             *            \\         |\n             *             v        v\n             *            (Agent Smith)\n             */\n            createChain( \"Neo\", \"Trinity\" );\n            createChain( \"Neo\", \"Morpheus\", \"Trinity\" );\n            createChain( \"Morpheus\", \"Cypher\", \"Agent Smith\" );\n            createChain( \"Morpheus\", \"Agent Smith\" );\n            tx.success();\n        }\n\n        // So let's find the shortest path between Neo and Agent Smith\n        Node neo = getOrCreateNode( \"Neo\" );\n        Node agentSmith = getOrCreateNode( \"Agent Smith\" );\n        // START SNIPPET: shortestPathUsage\n        PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                PathExpanders.forTypeAndDirection( KNOWS, Direction.BOTH ), 4 );\n        Path foundPath = finder.findSinglePath( neo, agentSmith );\n        System.out.println( \"Path from Neo to Agent Smith: \"\n                            + Paths.simplePathToString( foundPath, NAME_KEY ) );\n        // END SNIPPET: shortestPathUsage\n\n        System.out.println( \"Shutting down database ...\" );\n        graphDb.shutdown();\n    }","id":30856,"modified_method":"public static void main( final String[] args )\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook();\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            indexService = graphDb.index().forNodes( \"nodes\" );\n            /*\n             *  (Neo) --> (Trinity)\n             *     \\       ^\n             *      v     /\n             *    (Morpheus) --> (Cypher)\n             *            \\         |\n             *             v        v\n             *            (Agent Smith)\n             */\n            createChain( \"Neo\", \"Trinity\" );\n            createChain( \"Neo\", \"Morpheus\", \"Trinity\" );\n            createChain( \"Morpheus\", \"Cypher\", \"Agent Smith\" );\n            createChain( \"Morpheus\", \"Agent Smith\" );\n            tx.success();\n        }\n\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            // So let's find the shortest path between Neo and Agent Smith\n            Node neo = getOrCreateNode( \"Neo\" );\n            Node agentSmith = getOrCreateNode( \"Agent Smith\" );\n            // START SNIPPET: shortestPathUsage\n            PathFinder<Path> finder = GraphAlgoFactory.shortestPath(\n                    PathExpanders.forTypeAndDirection( KNOWS, Direction.BOTH ), 4 );\n            Path foundPath = finder.findSinglePath( neo, agentSmith );\n            System.out.println( \"Path from Neo to Agent Smith: \"\n                                + Paths.simplePathToString( foundPath, NAME_KEY ) );\n            // END SNIPPET: shortestPathUsage\n        }\n\n        System.out.println( \"Shutting down database ...\" );\n        graphDb.shutdown();\n    }","commit_id":"ff2073ad10e0811f3c4c26c1ed3027be56cd6848","url":"https://github.com/neo4j/neo4j"},{"original_method":"void createDb()\n    {\n        clearDb();\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook( graphDb );\n        // END SNIPPET: startDb\n\n        // START SNIPPET: transaction\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            // Database operations go here\n            // END SNIPPET: transaction\n            // START SNIPPET: addData\n            firstNode = graphDb.createNode();\n            firstNode.setProperty( \"message\", \"Hello, \" );\n            secondNode = graphDb.createNode();\n            secondNode.setProperty( \"message\", \"World!\" );\n\n            relationship = firstNode.createRelationshipTo( secondNode, RelTypes.KNOWS );\n            relationship.setProperty( \"message\", \"brave Neo4j \" );\n            // END SNIPPET: addData\n\n            // START SNIPPET: readData\n            System.out.print( firstNode.getProperty( \"message\" ) );\n            System.out.print( relationship.getProperty( \"message\" ) );\n            System.out.print( secondNode.getProperty( \"message\" ) );\n            // END SNIPPET: readData\n\n            greeting = ( (String) firstNode.getProperty( \"message\" ) )\n                       + ( (String) relationship.getProperty( \"message\" ) )\n                       + ( (String) secondNode.getProperty( \"message\" ) );\n\n            // START SNIPPET: transaction\n            tx.success();\n        }\n        // END SNIPPET: transaction\n    }","id":30857,"modified_method":"void createDb()\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook( graphDb );\n        // END SNIPPET: startDb\n\n        // START SNIPPET: transaction\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            // Database operations go here\n            // END SNIPPET: transaction\n            // START SNIPPET: addData\n            firstNode = graphDb.createNode();\n            firstNode.setProperty( \"message\", \"Hello, \" );\n            secondNode = graphDb.createNode();\n            secondNode.setProperty( \"message\", \"World!\" );\n\n            relationship = firstNode.createRelationshipTo( secondNode, RelTypes.KNOWS );\n            relationship.setProperty( \"message\", \"brave Neo4j \" );\n            // END SNIPPET: addData\n\n            // START SNIPPET: readData\n            System.out.print( firstNode.getProperty( \"message\" ) );\n            System.out.print( relationship.getProperty( \"message\" ) );\n            System.out.print( secondNode.getProperty( \"message\" ) );\n            // END SNIPPET: readData\n\n            greeting = ( (String) firstNode.getProperty( \"message\" ) )\n                       + ( (String) relationship.getProperty( \"message\" ) )\n                       + ( (String) secondNode.getProperty( \"message\" ) );\n\n            // START SNIPPET: transaction\n            tx.success();\n        }\n        // END SNIPPET: transaction\n    }","commit_id":"ff2073ad10e0811f3c4c26c1ed3027be56cd6848","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( final String[] args )\n    {\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook();\n        // END SNIPPET: startDb\n\n        // START SNIPPET: addUsers\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            nodeIndex = graphDb.index().forNodes( \"nodes\" );\n            // Create some users and index their names with the IndexService\n            for ( int id = 0; id < 100; id++ )\n            {\n                createAndIndexUser( idToUserName( id ) );\n            }\n            // END SNIPPET: addUsers\n\n            // Find a user through the search index\n            // START SNIPPET: findUser\n            int idToFind = 45;\n            String userName = idToUserName( idToFind );\n            Node foundUser = nodeIndex.get( USERNAME_KEY, userName ).getSingle();\n\n            System.out.println( \"The username of user \" + idToFind + \" is \"\n                + foundUser.getProperty( USERNAME_KEY ) );\n            // END SNIPPET: findUser\n\n            // Delete the persons and remove them from the index\n            for ( Node user : nodeIndex.query( USERNAME_KEY, \"*\" ) )\n            {\n                nodeIndex.remove(  user, USERNAME_KEY,\n                        user.getProperty( USERNAME_KEY ) );\n                user.delete();\n            }\n            tx.success();\n        }\n        shutdown();\n    }","id":30858,"modified_method":"public static void main( final String[] args )\n    {\n        deleteFileOrDirectory( new File( DB_PATH ) );\n        // START SNIPPET: startDb\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        registerShutdownHook();\n        // END SNIPPET: startDb\n\n        // START SNIPPET: addUsers\n        try ( Transaction tx = graphDb.beginTx() )\n        {\n            nodeIndex = graphDb.index().forNodes( \"nodes\" );\n            // Create some users and index their names with the IndexService\n            for ( int id = 0; id < 100; id++ )\n            {\n                createAndIndexUser( idToUserName( id ) );\n            }\n            // END SNIPPET: addUsers\n\n            // Find a user through the search index\n            // START SNIPPET: findUser\n            int idToFind = 45;\n            String userName = idToUserName( idToFind );\n            Node foundUser = nodeIndex.get( USERNAME_KEY, userName ).getSingle();\n\n            System.out.println( \"The username of user \" + idToFind + \" is \"\n                + foundUser.getProperty( USERNAME_KEY ) );\n            // END SNIPPET: findUser\n\n            // Delete the persons and remove them from the index\n            for ( Node user : nodeIndex.query( USERNAME_KEY, \"*\" ) )\n            {\n                nodeIndex.remove(  user, USERNAME_KEY,\n                        user.getProperty( USERNAME_KEY ) );\n                user.delete();\n            }\n            tx.success();\n        }\n        shutdown();\n    }","commit_id":"ff2073ad10e0811f3c4c26c1ed3027be56cd6848","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( final String[] args )\n    {\n        System.out.println( \"Starting database ...\" );\n\n        // START SNIPPET: startDb\n        GraphDatabaseService graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        // END SNIPPET: startDb\n\n        {\n            // START SNIPPET: createIndex\n            IndexDefinition indexDefinition;\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                indexDefinition = schema.indexFor( DynamicLabel.label( \"User\" ) )\n                        .on( \"username\" )\n                        .create();\n                tx.success();\n            }\n            // END SNIPPET: createIndex\n            // START SNIPPET: wait\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                schema.awaitIndexOnline( indexDefinition, 10, TimeUnit.SECONDS );\n            }\n            // END SNIPPET: wait\n        }\n\n        {\n            // START SNIPPET: addUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n\n                // Create some users\n                for ( int id = 0; id < 100; id++ )\n                {\n                    Node userNode = graphDb.createNode( label );\n                    userNode.setProperty( \"username\", \"user\" + id + \"@neo4j.org\" );\n                }\n                System.out.println( \"Users created\" );\n                tx.success();\n            }\n            // END SNIPPET: addUsers\n        }\n\n        {\n            // START SNIPPET: findUsers\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                try ( ResourceIterator<Node> users =\n                        graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ).iterator() )\n                {\n                    ArrayList<Node> userNodes = new ArrayList<>();\n                    while ( users.hasNext() )\n                    {\n                        userNodes.add( users.next() );\n                    }\n\n                    for ( Node node : userNodes )\n                    {\n                        System.out.println( \"The username of user \" + idToFind + \" is \" + node.getProperty( \"username\" ) );\n                    }\n                }\n            }\n            // END SNIPPET: findUsers\n        }\n\n        {\n            // START SNIPPET: resourceIterator\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx();\n                  ResourceIterator<Node> users = graphDb\n                        .findNodesByLabelAndProperty( label, \"username\", nameToFind )\n                        .iterator() )\n            {\n                Node firstUserNode;\n                if ( users.hasNext() )\n                {\n                    firstUserNode = users.next();\n                }\n                users.close();\n            }\n            // END SNIPPET: resourceIterator\n        }\n\n        {\n            // START SNIPPET: updateUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 45;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.setProperty( \"username\", \"user\" + ( idToFind + 1 ) + \"@neo4j.org\" );\n                }\n                tx.success();\n            }\n            // END SNIPPET: updateUsers\n        }\n\n        {\n            // START SNIPPET: deleteUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 46;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.delete();\n                }\n                tx.success();\n            }\n            // END SNIPPET: deleteUsers\n        }\n\n        {\n            // START SNIPPET: dropIndex\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                for ( IndexDefinition indexDefinition : graphDb.schema()\n                        .getIndexes( label ) )\n                {\n                    // There is only one index\n                    indexDefinition.drop();\n                }\n\n                tx.success();\n            }\n            // END SNIPPET: dropIndex\n        }\n\n        System.out.println( \"Shutting down database ...\" );\n        // START SNIPPET: shutdownDb\n        graphDb.shutdown();\n        // END SNIPPET: shutdownDb\n    }","id":30859,"modified_method":"public static void main( final String[] args )\n    {\n        System.out.println( \"Starting database ...\" );\n        deleteFileOrDirectory( new File( DB_PATH ) );\n\n        // START SNIPPET: startDb\n        GraphDatabaseService graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        // END SNIPPET: startDb\n\n        {\n            // START SNIPPET: createIndex\n            IndexDefinition indexDefinition;\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                indexDefinition = schema.indexFor( DynamicLabel.label( \"User\" ) )\n                        .on( \"username\" )\n                        .create();\n                tx.success();\n            }\n            // END SNIPPET: createIndex\n            // START SNIPPET: wait\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Schema schema = graphDb.schema();\n                schema.awaitIndexOnline( indexDefinition, 10, TimeUnit.SECONDS );\n            }\n            // END SNIPPET: wait\n        }\n\n        {\n            // START SNIPPET: addUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n\n                // Create some users\n                for ( int id = 0; id < 100; id++ )\n                {\n                    Node userNode = graphDb.createNode( label );\n                    userNode.setProperty( \"username\", \"user\" + id + \"@neo4j.org\" );\n                }\n                System.out.println( \"Users created\" );\n                tx.success();\n            }\n            // END SNIPPET: addUsers\n        }\n\n        {\n            // START SNIPPET: findUsers\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                try ( ResourceIterator<Node> users =\n                        graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ).iterator() )\n                {\n                    ArrayList<Node> userNodes = new ArrayList<>();\n                    while ( users.hasNext() )\n                    {\n                        userNodes.add( users.next() );\n                    }\n\n                    for ( Node node : userNodes )\n                    {\n                        System.out.println( \"The username of user \" + idToFind + \" is \" + node.getProperty( \"username\" ) );\n                    }\n                }\n            }\n            // END SNIPPET: findUsers\n        }\n\n        {\n            // START SNIPPET: resourceIterator\n            Label label = DynamicLabel.label( \"User\" );\n            int idToFind = 45;\n            String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n            try ( Transaction tx = graphDb.beginTx();\n                  ResourceIterator<Node> users = graphDb\n                        .findNodesByLabelAndProperty( label, \"username\", nameToFind )\n                        .iterator() )\n            {\n                Node firstUserNode;\n                if ( users.hasNext() )\n                {\n                    firstUserNode = users.next();\n                }\n                users.close();\n            }\n            // END SNIPPET: resourceIterator\n        }\n\n        {\n            // START SNIPPET: updateUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 45;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.setProperty( \"username\", \"user\" + ( idToFind + 1 ) + \"@neo4j.org\" );\n                }\n                tx.success();\n            }\n            // END SNIPPET: updateUsers\n        }\n\n        {\n            // START SNIPPET: deleteUsers\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                int idToFind = 46;\n                String nameToFind = \"user\" + idToFind + \"@neo4j.org\";\n\n                for ( Node node : graphDb.findNodesByLabelAndProperty( label, \"username\", nameToFind ) )\n                {\n                    node.delete();\n                }\n                tx.success();\n            }\n            // END SNIPPET: deleteUsers\n        }\n\n        {\n            // START SNIPPET: dropIndex\n            try ( Transaction tx = graphDb.beginTx() )\n            {\n                Label label = DynamicLabel.label( \"User\" );\n                for ( IndexDefinition indexDefinition : graphDb.schema()\n                        .getIndexes( label ) )\n                {\n                    // There is only one index\n                    indexDefinition.drop();\n                }\n\n                tx.success();\n            }\n            // END SNIPPET: dropIndex\n        }\n\n        System.out.println( \"Shutting down database ...\" );\n        // START SNIPPET: shutdownDb\n        graphDb.shutdown();\n        // END SNIPPET: shutdownDb\n    }","commit_id":"ff2073ad10e0811f3c4c26c1ed3027be56cd6848","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void setUp() throws IOException\n    {\n        deleteRecursively( new File( MATRIX_DB ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( MATRIX_DB );\n        registerShutdownHook();\n        createNodespace();\n    }","id":30860,"modified_method":"public void setUp()\n    {\n        deleteFileOrDirectory( new File( MATRIX_DB ) );\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( MATRIX_DB );\n        registerShutdownHook();\n        createNodespace();\n    }","commit_id":"ff2073ad10e0811f3c4c26c1ed3027be56cd6848","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void startRemoteShellAndWait() throws Exception\n    {\n        graphDb = (GraphDatabaseAPI) new GraphDatabaseFactory().newEmbeddedDatabaseBuilder( DB_PATH ).\n                setConfig( ShellSettings.remote_shell_enabled, Settings.TRUE ).\n                newGraphDatabase();\n\n        createExampleGraph();\n        waitForUserInput( \"Remote shell enabled, connect to it by executing\\n\"\n                + \"the shell-client script in a separate terminal.\"\n                + \"The script is located in the bin directory.\\n\"\n                + \"\\nWhen you're done playing around, just press [Enter] \"\n                + \"in this terminal \" );\n    }","id":30861,"modified_method":"private static void startRemoteShellAndWait() throws Exception\n    {\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder( DB_PATH )\n                .\n                setConfig( ShellSettings.remote_shell_enabled, Settings.TRUE ).\n                newGraphDatabase();\n\n        createExampleGraph();\n        waitForUserInput( \"Remote shell enabled, connect to it by executing\\n\"\n                + \"the shell-client script in a separate terminal.\"\n                + \"The script is located in the bin directory.\\n\"\n                + \"\\nWhen you're done playing around, just press [Enter] \"\n                + \"in this terminal \" );\n    }","commit_id":"ff2073ad10e0811f3c4c26c1ed3027be56cd6848","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void startLocalShell() throws Exception\n    {\n        graphDb = (GraphDatabaseAPI) new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        createExampleGraph();\n        ShellServer shellServer = new GraphDatabaseShellServer( graphDb );\n        ShellLobby.newClient( shellServer ).grabPrompt();\n        shellServer.shutdown();\n    }","id":30862,"modified_method":"private static void startLocalShell() throws Exception\n    {\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );\n        createExampleGraph();\n        ShellServer shellServer = new GraphDatabaseShellServer( (org.neo4j.kernel.GraphDatabaseAPI) graphDb );\n        ShellLobby.newClient( shellServer ).grabPrompt();\n        shellServer.shutdown();\n    }","commit_id":"ff2073ad10e0811f3c4c26c1ed3027be56cd6848","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n   * Get the commands to run to preinstall a component\n   * For example, MapReduce needs to have certain directories\n   * on the HDFS before JobTracker can be started.\n   * @param cluster the cluster that is being installed\n   * @param role the role that will run the action\n   */\n  public abstract Action preinstallAction(String cluster, \n                              String role) throws IOException;","id":30863,"modified_method":"/**\n   * Get the commands to run to preinstall a component\n   * For example, MapReduce needs to have certain directories\n   * on the HDFS before JobTracker can be started.\n   * @param cluster the cluster that is being installed\n   * @param role the role that will run the action\n   */\n  public abstract Action preStartAction(String cluster, \n                              String role) throws IOException;","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get the role that should run the initialization command.\n   * @return the role name\n   * @throws IOException\n   */\n  public abstract String runPreinstallRole() throws IOException;","id":30864,"modified_method":"/**\n   * Get the role that should run the initialization command.\n   * @return the role name\n   * @throws IOException\n   */\n  public abstract String runPreStartRole() throws IOException;","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"private void checkActionResults(HeartBeat heartbeat,\n      ComponentAndRoleStates installOrStartedComponents) {\n    \n    List<ActionResult> actionResults = heartbeat.getActionResults();\n    \n    for (ActionResult actionResult : actionResults) {\n      if (actionResult.getId().contains(SpecialServiceIDs\n          .SERVICE_AVAILABILITY_CHECK_ID.toString())\n          || actionResult.getId().contains(SpecialServiceIDs\n              .SERVICE_PREINSTALL_CHECK_ID.toString())) {\n        installOrStartedComponents.recordActionId(actionResult.getId(),\n            actionResult);\n      }\n    }   \n  }","id":30865,"modified_method":"private void checkActionResults(HeartBeat heartbeat,\n      ComponentAndRoleStates installOrStartedComponents) {\n    \n    List<ActionResult> actionResults = heartbeat.getActionResults();\n    \n    for (ActionResult actionResult : actionResults) {\n      if (actionResult.getId().contains(SpecialServiceIDs\n          .SERVICE_AVAILABILITY_CHECK_ID.toString())\n          || actionResult.getId().contains(SpecialServiceIDs\n              .SERVICE_PRESTART_CHECK_ID.toString())) {\n        installOrStartedComponents.recordActionId(actionResult.getId(),\n            actionResult);\n      }\n    }   \n  }","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"private static String getSpecialActionID(ClusterIdAndRev clusterIdAndRev, \n      ServiceFSM service, boolean availabilityChecker, \n      boolean preinstallChecker) {\n    String id = clusterIdAndRev.getClusterId() + clusterIdAndRev.getRevision() \n        + service.getServiceName();\n    if (preinstallChecker) {\n      id += SpecialServiceIDs.SERVICE_PREINSTALL_CHECK_ID.toString();\n    }\n    if (availabilityChecker) {\n      id += SpecialServiceIDs.SERVICE_AVAILABILITY_CHECK_ID.toString();\n    }\n    return id;\n  }","id":30866,"modified_method":"private static String getSpecialActionID(ClusterIdAndRev clusterIdAndRev, \n      ServiceFSM service, boolean availabilityChecker, \n      boolean prestartCheck) {\n    String id = clusterIdAndRev.getClusterId() + clusterIdAndRev.getRevision() \n        + service.getServiceName();\n    if (prestartCheck) {\n      id += SpecialServiceIDs.SERVICE_PRESTART_CHECK_ID.toString();\n    }\n    if (availabilityChecker) {\n      id += SpecialServiceIDs.SERVICE_AVAILABILITY_CHECK_ID.toString();\n    }\n    return id;\n  }","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"private void checkAndCreateActions(Cluster cluster,\n      ClusterFSM clusterFsm, ClusterIdAndRev clusterIdAndRev, \n      ServiceFSM service, HeartBeat heartbeat, List<Action> allActions, \n      ComponentAndRoleStates installedOrStartedComponents) \n          throws IOException {\n    //see whether the service is in the STARTED state, and if so,\n    //check whether there is any action-result that indicates success\n    //of the availability check (safemode, etc.)\n    if (service.getServiceState() == ServiceState.STARTED) {\n      String id = getSpecialActionID(clusterIdAndRev, service, true, false);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        //TODO: this needs to be generalized so that it handles the case\n        //where the service is not available for a couple of checkservice\n        //invocations\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runCheckRole();\n        if (installedOrStartedComponents.isRoleInstalled(clusterIdAndRev,role)) {\n          Action action = plugin.checkService(cluster.getName(), role);\n          fillActionDetails(action, clusterIdAndRev.getClusterId(),\n              clusterIdAndRev.getRevision(),service.getServiceName(), role);\n          action.setId(id);\n          action.setKind(Action.Kind.RUN_ACTION);\n          addAction(action, allActions);\n        }\n      }\n    }\n    \n    if (service.getServiceState() == ServiceState.PRESTART) {\n      String id = getSpecialActionID(clusterIdAndRev, service, false, true);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runPreinstallRole();\n        if (installedOrStartedComponents.isRoleInstalled(clusterIdAndRev,role)) {\n          Action action = plugin.preinstallAction(cluster.getName(), role);\n          fillActionDetails(action, clusterIdAndRev.getClusterId(),\n              clusterIdAndRev.getRevision(),service.getServiceName(), role);\n          action.setId(id);\n          action.setKind(Action.Kind.RUN_ACTION);\n          addAction(action, allActions);\n        }\n      }\n    }\n  }","id":30867,"modified_method":"private void checkAndCreateActions(Cluster cluster,\n      ClusterFSM clusterFsm, ClusterIdAndRev clusterIdAndRev, \n      ServiceFSM service, HeartBeat heartbeat, List<Action> allActions, \n      ComponentAndRoleStates installedOrStartedComponents) \n          throws IOException {\n    //see whether the service is in the STARTED state, and if so,\n    //check whether there is any action-result that indicates success\n    //of the availability check (safemode, etc.)\n    if (service.getServiceState() == ServiceState.STARTED) {\n      String id = getSpecialActionID(clusterIdAndRev, service, true, false);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        //TODO: this needs to be generalized so that it handles the case\n        //where the service is not available for a couple of checkservice\n        //invocations\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runCheckRole();\n        if (installedOrStartedComponents.isRoleInstalled(clusterIdAndRev,\n            role)) {\n          Action action = plugin.checkService(cluster.getName(), role);\n          fillActionDetails(action, clusterIdAndRev.getClusterId(),\n              clusterIdAndRev.getRevision(),service.getServiceName(), role);\n          action.setId(id);\n          action.setKind(Action.Kind.RUN_ACTION);\n          addAction(action, allActions);\n        }\n      }\n    }\n    \n    if (service.getServiceState() == ServiceState.PRESTART) {\n      String id = getSpecialActionID(clusterIdAndRev, service, false, true);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runPreStartRole();\n        if (!installedOrStartedComponents.isRoleInstalled(clusterIdAndRev,\n            role)) {\n          createInstallAction(clusterIdAndRev, cluster.getName(), \n              service.getServiceName(), role, plugin,\n              allActions);\n        }\n        Action action = plugin.preStartAction(cluster.getName(), role);\n        fillActionDetails(action, clusterIdAndRev.getClusterId(),\n            clusterIdAndRev.getRevision(),service.getServiceName(), role);\n        action.setId(id);\n        action.setKind(Action.Kind.RUN_ACTION);\n        addAction(action, allActions);\n      }\n    }\n  }","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"public ControllerResponse processHeartBeat(HeartBeat heartbeat) \n      throws Exception {\n    ControllerResponse response = \n        agentToHeartbeatResponseMap.get(heartbeat.getHostname());\n    if (response != null) {\n      if (response.getResponseId() == heartbeat.getResponseId()) {\n        return response; //duplicate heartbeat\n      }\n    }\n\n    short responseId = (short)(heartbeat.getResponseId() + 1);\n\n    String hostname = heartbeat.getHostname();\n    Date heartbeatTime = new Date(System.currentTimeMillis());\n    String clusterName = null;\n    long clusterRev = 0L;\n\n    Nodes.getInstance().checkAndUpdateNode(hostname, heartbeatTime);\n\n    List<Action> allActions = new ArrayList<Action>();\n\n    clusterName = Nodes.getInstance().getNode(hostname)\n        .getNodeState().getClusterName();\n    if (clusterName != null) {\n      clusterRev = Clusters.getInstance().\n          getClusterByName(clusterName).getLatestRevision(); \n    }\n    \n    ComponentAndRoleStates componentStates = \n        new ComponentAndRoleStates();\n    //create some datastructures by looking at agent state\n    inspectAgentState(heartbeat, componentStates);\n    \n    //get the clusters the node belongs to\n    Set<ClusterIdAndRev> clustersNodeBelongsTo = \n        componentStates.getClustersNodeBelongsTo();\n    \n    //if the command-execution takes longer than one heartbeat interval\n    //the check for idleness will prevent the same node getting the same \n    //command more than once. In the future this could be improved\n    //to reflect the command execution state more accurately.\n    if (heartbeat.getIdle()) {  \n      for (ClusterIdAndRev clusterIdAndRev : clustersNodeBelongsTo) {\n        //check whether this node is out-of-sync w.r.t what's running &\n        //installed, or is it compatible\n        if (!isCompatible(clusterIdAndRev.getClusterId(), \n            clusterIdAndRev.getRevision(), clusterName, clusterRev)) {\n          createStopAndUninstallActions(componentStates, allActions, \n              clusterIdAndRev, true);\n          continue;\n        }\n        //get the cluster object corresponding to the clusterId\n        Cluster cluster = Clusters.getInstance()\n            .getClusterByName(clusterIdAndRev.getClusterId());\n        //get the state machine reference to the cluster\n        ClusterFSM clusterFsm = StateMachineInvoker\n            .getStateMachineClusterInstance(clusterIdAndRev.getClusterId());\n\n        //the state machine references to the services\n        List<ServiceFSM> clusterServices = clusterFsm.getServices();\n        //go through all the services, and check which role should be started\n        //TODO: Given that we already look at what is running/installed in \n        //inspectAgentState, maybe we can avoid the following for loop.\n        for (ServiceFSM service : clusterServices) {\n          List<RoleFSM> roles = service.getRoles();\n\n          for (RoleFSM role : roles) {\n            boolean nodePlayingRole = \n                nodePlayingRole(hostname, role.getRoleName());\n            if (nodePlayingRole) {\n              boolean roleInstalled = componentStates.isInstalled(\n                  clusterIdAndRev,\n                  role.getAssociatedService().getServiceName(), \n                  role.getRoleName());     \n              boolean roleServerRunning = componentStates.isStarted(\n                  clusterIdAndRev,\n                  role.getAssociatedService().getServiceName(),\n                  role.getRoleName()) \n                  || componentStates.isStartInProgress(clusterIdAndRev,\n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n              boolean agentRoleStateChanged = componentStates.hasStateChanged(\n                  clusterIdAndRev, role.getAssociatedService().getServiceName(), \n                  role.getRoleName());\n              ComponentPlugin plugin = \n                  cluster.getComponentDefinition(service.getServiceName());\n              \n              //check whether the agent should start any server\n              if (role.shouldStart()) {\n                if (!roleInstalled) {\n                  //send action for creating dir structure\n                  Action action = new Action();\n                  action.setKind(Kind.CREATE_STRUCTURE_ACTION);\n                  fillDetailsAndAddAction(action, allActions, clusterName,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                  \n                  //send action for installing the role\n                  action = plugin.install(cluster.getName(), \n                      role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterName,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                  \n                  //send action for configuring\n                  action = plugin.configure(clusterName, role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterName,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                  continue;\n                }\n                if (role.getRoleName().equals(\"-client\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. They don't have any active servers\n                  //but should be considered active when installed. Setting the \n                  //boolean to true ensures that the FSM gets an event (albeit a fake one).\n                  roleServerRunning = true;\n                }\n                if (!roleServerRunning) {\n                  //TODO: keep track of retries (via checkActionResults)\n                  Action action = \n                      plugin.startServer(cluster.getName(), role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterName,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                }\n                //raise an event to the state machine for a successful \n                //role-start instance\n                if (roleServerRunning && agentRoleStateChanged) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.START_SUCCESS, role));\n                }\n                componentStates.\n                  continueRunning(clusterIdAndRev, \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n              }\n              //check whether the agent should stop any server\n              if (role.shouldStop()) {\n                if (role.getRoleName().contains(\"-client\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. Setting the \n                  //boolean to false ensures that the FSM gets an event (albeit a fake one) \n                  roleServerRunning = false;\n                }\n                if (roleServerRunning) {\n                  //TODO: keep track of retries (via checkActionResults)\n                  addAction(getStopRoleAction(clusterName, \n                      clusterRev, \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName()), allActions);\n                }\n                //raise an event to the state machine for a successful \n                //role-stop instance\n                if (!roleServerRunning && agentRoleStateChanged) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.STOP_SUCCESS, role));\n                }\n                if (roleInstalled && \n                    clusterFsm.getClusterState()\n                    .equals(ClusterState.CLUSTER_STATE_ATTIC)) {\n                  Action action = plugin.uninstall(cluster.getName(), \n                      role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterName, \n                      clusterRev, \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n                }\n              }\n            }\n            //check/create the special component/service-level \n            //actions (like safemode check)\n            checkAndCreateActions(cluster, clusterFsm,clusterIdAndRev, service, heartbeat, \n                allActions, componentStates);\n          }\n        }\n        createStopAndUninstallActions(componentStates, allActions, clusterIdAndRev, false);\n      }\n    }\n    ControllerResponse r = new ControllerResponse();\n    r.setResponseId(responseId);\n    r.setActions(allActions);\n    agentToHeartbeatResponseMap.put(heartbeat.getHostname(), r);\n    return r;\n  }","id":30868,"modified_method":"public ControllerResponse processHeartBeat(HeartBeat heartbeat) \n      throws Exception {\n    ControllerResponse response = \n        agentToHeartbeatResponseMap.get(heartbeat.getHostname());\n    if (response != null) {\n      if (response.getResponseId() == heartbeat.getResponseId()) {\n        return response; //duplicate heartbeat\n      }\n    }\n\n    short responseId = (short)(heartbeat.getResponseId() + 1);\n\n    String hostname = heartbeat.getHostname();\n    Date heartbeatTime = new Date(System.currentTimeMillis());\n    String clusterName = null;\n    long clusterRev = 0L;\n\n    Nodes.getInstance().checkAndUpdateNode(hostname, heartbeatTime);\n\n    List<Action> allActions = new ArrayList<Action>();\n\n    clusterName = Nodes.getInstance().getNode(hostname)\n        .getNodeState().getClusterName();\n    if (clusterName != null) {\n      clusterRev = Clusters.getInstance().\n          getClusterByName(clusterName).getLatestRevision(); \n    }\n    \n    ComponentAndRoleStates componentStates = \n        new ComponentAndRoleStates();\n    //create some datastructures by looking at agent state\n    inspectAgentState(heartbeat, componentStates);\n    \n    //get the clusters the node belongs to\n    Set<ClusterIdAndRev> clustersNodeBelongsTo = \n        componentStates.getClustersNodeBelongsTo();\n    \n    //if the command-execution takes longer than one heartbeat interval\n    //the check for idleness will prevent the same node getting the same \n    //command more than once. In the future this could be improved\n    //to reflect the command execution state more accurately.\n    if (heartbeat.getIdle()) {  \n      for (ClusterIdAndRev clusterIdAndRev : clustersNodeBelongsTo) {\n        //check whether this node is out-of-sync w.r.t what's running &\n        //installed, or is it compatible\n        if (!isCompatible(clusterIdAndRev.getClusterId(), \n            clusterIdAndRev.getRevision(), clusterName, clusterRev)) {\n          createStopAndUninstallActions(componentStates, allActions, \n              clusterIdAndRev, true);\n          continue;\n        }\n        //get the cluster object corresponding to the clusterId\n        Cluster cluster = Clusters.getInstance()\n            .getClusterByName(clusterIdAndRev.getClusterId());\n        //get the state machine reference to the cluster\n        ClusterFSM clusterFsm = StateMachineInvoker\n            .getStateMachineClusterInstance(clusterIdAndRev.getClusterId());\n\n        //the state machine references to the services\n        List<ServiceFSM> clusterServices = clusterFsm.getServices();\n        //go through all the services, and check which role should be started\n        //TODO: Given that we already look at what is running/installed in \n        //inspectAgentState, maybe we can avoid the following for loop.\n        for (ServiceFSM service : clusterServices) {\n          List<RoleFSM> roles = service.getRoles();\n\n          for (RoleFSM role : roles) {\n            boolean nodePlayingRole = \n                nodePlayingRole(hostname, role.getRoleName());\n            if (nodePlayingRole) {\n              boolean roleInstalled = componentStates.isInstalled(\n                  clusterIdAndRev,\n                  role.getAssociatedService().getServiceName(), \n                  role.getRoleName());     \n              boolean roleServerRunning = componentStates.isStarted(\n                  clusterIdAndRev,\n                  role.getAssociatedService().getServiceName(),\n                  role.getRoleName()) \n                  || componentStates.isStartInProgress(clusterIdAndRev,\n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n              boolean agentRoleStateChanged = componentStates.hasStateChanged(\n                  clusterIdAndRev, role.getAssociatedService().getServiceName(), \n                  role.getRoleName());\n              ComponentPlugin plugin = \n                  cluster.getComponentDefinition(service.getServiceName());\n              \n              //check whether the agent should start any server\n              if (role.shouldStart()) {\n                if (!roleInstalled) {\n                  createInstallAction(clusterIdAndRev, cluster.getName(), \n                      service.getServiceName(), role.getRoleName(), plugin,\n                      allActions);\n                  continue;\n                }\n                if (role.getRoleName().equals(\"-client\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. They don't have any active servers\n                  //but should be considered active when installed. Setting the \n                  //boolean to true ensures that the FSM gets an event (albeit a fake one).\n                  roleServerRunning = true;\n                }\n                if (!roleServerRunning) {\n                  //TODO: keep track of retries (via checkActionResults)\n                  Action action = \n                      plugin.startServer(cluster.getName(), role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterName,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                }\n                //raise an event to the state machine for a successful \n                //role-start instance\n                if (roleServerRunning && agentRoleStateChanged) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.START_SUCCESS, role));\n                }\n                componentStates.\n                  continueRunning(clusterIdAndRev, \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n              }\n              //check whether the agent should stop any server\n              if (role.shouldStop()) {\n                if (role.getRoleName().contains(\"-client\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. Setting the \n                  //boolean to false ensures that the FSM gets an event (albeit a fake one) \n                  roleServerRunning = false;\n                }\n                //raise an event to the state machine for a successful \n                //role-stop instance\n                if (!roleServerRunning && agentRoleStateChanged) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.STOP_SUCCESS, role));\n                }\n              }\n            }\n            //check/create the special component/service-level \n            //actions (like safemode check)\n            checkAndCreateActions(cluster, clusterFsm,clusterIdAndRev, service, heartbeat, \n                allActions, componentStates);\n          }\n        }\n        createStopAndUninstallActions(componentStates, allActions, clusterIdAndRev, false);\n      }\n    }\n    ControllerResponse r = new ControllerResponse();\n    r.setResponseId(responseId);\n    r.setActions(allActions);\n    agentToHeartbeatResponseMap.put(heartbeat.getHostname(), r);\n    return r;\n  }","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public String runPreinstallRole() throws IOException {\n    return preinstallRole;\n  }","id":30869,"modified_method":"@Override\n  public String runPreStartRole() throws IOException {\n    return preinstallRole;\n  }","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Action preinstallAction(String cluster, String role) throws IOException {\n    if (preinstallCommand == null) {\n      return null;\n    }\n    Action result = new Action();\n    result.kind = Action.Kind.RUN_ACTION;\n    result.command = new Command(preinstallUser, preinstallCommand, \n                                 new String[]{cluster, role});\n    return result; \n  }","id":30870,"modified_method":"@Override\n  public Action preStartAction(String cluster, String role) throws IOException {\n    if (preinstallCommand == null) {\n      return null;\n    }\n    Action result = new Action();\n    result.kind = Action.Kind.RUN_ACTION;\n    result.command = new Command(preinstallUser, preinstallCommand, \n                                 new String[]{cluster, role});\n    return result; \n  }","commit_id":"f8b1c919d3938f436503733c02ac49670d45cd29","url":"https://github.com/apache/ambari"},{"original_method":"private static String getSpecialActionID(Cluster cluster, \n      ServiceFSM service, boolean availabilityChecker, \n      boolean preinstallChecker) {\n    String id = cluster.getID() + cluster.getLatestRevision() + \n        service.getServiceName();\n    if (preinstallChecker) {\n      id += SpecialServiceIDs.SERVICE_PREINSTALL_CHECK_ID.toString();\n    }\n    if (availabilityChecker) {\n      id += SpecialServiceIDs.SERVICE_AVAILABILITY_CHECK_ID.toString();\n    }\n    return id;\n  }","id":30871,"modified_method":"private static String getSpecialActionID(ClusterIdAndRev clusterIdAndRev, \n      ServiceFSM service, boolean availabilityChecker, \n      boolean preinstallChecker) {\n    String id = clusterIdAndRev.getClusterId() + clusterIdAndRev.getRevision() \n        + service.getServiceName();\n    if (preinstallChecker) {\n      id += SpecialServiceIDs.SERVICE_PREINSTALL_CHECK_ID.toString();\n    }\n    if (availabilityChecker) {\n      id += SpecialServiceIDs.SERVICE_AVAILABILITY_CHECK_ID.toString();\n    }\n    return id;\n  }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"boolean isInstalled(String component, String role) {\n      Map<String, AgentRoleState> startedRoleMap;\n      if ((startedRoleMap = componentRoleMap.get(component)) \n          != null) {\n        AgentRoleState state = startedRoleMap.get(role);\n        return state != null;\n      }\n      return false;\n    }","id":30872,"modified_method":"boolean isInstalled(ClusterIdAndRev clusterIdAndRev, \n        String component, String role) {\n      Map<String,Map<String,RoleStateTracker>> componentsMap = \n          componentRoleMap.get(clusterIdAndRev);\n      if (componentsMap == null) {\n        return false;\n      }\n      Map<String, RoleStateTracker> startedRoleMap;\n      if ((startedRoleMap = componentsMap.get(component)) != null) {\n        RoleStateTracker state = startedRoleMap.get(role);\n        return state != null;\n      }\n      return false;\n    }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"private void checkAndCreateActions(Cluster cluster,\n      ClusterFSM clusterFsm, ServiceFSM service, HeartBeat heartbeat,\n      List<Action> allActions, \n      ComponentAndRoleStates installedOrStartedComponents) \n          throws IOException {\n    //see whether the service is in the STARTED state, and if so,\n    //check whether there is any action-result that indicates success\n    //of the availability check (safemode, etc.)\n    if (service.getServiceState() == ServiceState.STARTED) {\n      String id = getSpecialActionID(cluster, service, true, false);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        //TODO: this needs to be generalized so that it handles the case\n        //where the service is not available for a couple of checkservice\n        //invocations\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runCheckRole();\n        if (installedOrStartedComponents.isRoleInstalled(role)) {\n          Action action = plugin.checkService(cluster.getName(), role);\n          fillActionDetails(action, cluster.getID(),\n              cluster.getLatestRevision(),service.getServiceName(), role);\n          action.setId(id);\n          action.setKind(Action.Kind.RUN_ACTION);\n          addAction(action, allActions);\n        }\n      }\n    }\n    \n    if (service.getServiceState() == ServiceState.PRESTART) {\n      String id = getSpecialActionID(cluster, service, false, true);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runPreinstallRole();\n        if (installedOrStartedComponents.isRoleInstalled(role)) {\n          Action action = plugin.preinstallAction(cluster.getName(), role);\n          fillActionDetails(action, cluster.getID(),\n              cluster.getLatestRevision(),service.getServiceName(), role);\n          action.setId(id);\n          action.setKind(Action.Kind.RUN_ACTION);\n          addAction(action, allActions);\n        }\n      }\n    }\n  }","id":30873,"modified_method":"private void checkAndCreateActions(Cluster cluster,\n      ClusterFSM clusterFsm, ClusterIdAndRev clusterIdAndRev, \n      ServiceFSM service, HeartBeat heartbeat, List<Action> allActions, \n      ComponentAndRoleStates installedOrStartedComponents) \n          throws IOException {\n    //see whether the service is in the STARTED state, and if so,\n    //check whether there is any action-result that indicates success\n    //of the availability check (safemode, etc.)\n    if (service.getServiceState() == ServiceState.STARTED) {\n      String id = getSpecialActionID(clusterIdAndRev, service, true, false);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        //TODO: this needs to be generalized so that it handles the case\n        //where the service is not available for a couple of checkservice\n        //invocations\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.AVAILABLE_CHECK_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runCheckRole();\n        if (installedOrStartedComponents.isRoleInstalled(clusterIdAndRev,role)) {\n          Action action = plugin.checkService(cluster.getName(), role);\n          fillActionDetails(action, clusterIdAndRev.getClusterId(),\n              clusterIdAndRev.getRevision(),service.getServiceName(), role);\n          action.setId(id);\n          action.setKind(Action.Kind.RUN_ACTION);\n          addAction(action, allActions);\n        }\n      }\n    }\n    \n    if (service.getServiceState() == ServiceState.PRESTART) {\n      String id = getSpecialActionID(clusterIdAndRev, service, false, true);\n      ActionResult result = installedOrStartedComponents.getActionResult(id);\n      if (result != null) {\n        //this action ran\n        if (result.getCommandResult().getExitCode() == 0) {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_SUCCESS,\n                  service));\n        } else {\n          StateMachineInvoker.getAMBARIEventHandler().handle(\n              new ServiceEvent(ServiceEventType.PRESTART_FAILURE,\n                  service));\n        }\n      } else {\n        ComponentPlugin plugin = \n            cluster.getComponentDefinition(service.getServiceName());\n        String role = plugin.runPreinstallRole();\n        if (installedOrStartedComponents.isRoleInstalled(clusterIdAndRev,role)) {\n          Action action = plugin.preinstallAction(cluster.getName(), role);\n          fillActionDetails(action, clusterIdAndRev.getClusterId(),\n              clusterIdAndRev.getRevision(),service.getServiceName(), role);\n          action.setId(id);\n          action.setKind(Action.Kind.RUN_ACTION);\n          addAction(action, allActions);\n        }\n      }\n    }\n  }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"boolean isStartInProgress(String component, String role) {\n      Map<String, AgentRoleState> startedServerMap;\n      if ((startedServerMap = componentRoleMap.get(component)) \n          != null) {\n        AgentRoleState state = startedServerMap.get(role);\n        return state.getServerStatus() == AgentRoleState.State.STARTED ||\n            state.getServerStatus() == AgentRoleState.State.STARTING;\n      }\n      return false;\n    }","id":30874,"modified_method":"boolean isStartInProgress(ClusterIdAndRev clusterIdAndRev, \n        String component, String role) {\n      Map<String,Map<String,RoleStateTracker>> componentsMap = \n          componentRoleMap.get(clusterIdAndRev);\n      if (componentsMap == null) {\n        return false;\n      }\n      Map<String, RoleStateTracker> startedServerMap;\n      if ((startedServerMap = componentsMap.get(component)) != null) {\n        RoleStateTracker state = startedServerMap.get(role);\n        if (state != null) {\n          return state.state == AgentRoleState.State.STARTED ||\n              state.state == AgentRoleState.State.STARTING;\n        } else return false;\n      }\n      return false;\n    }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"private void inspectAgentState(HeartBeat heartbeat, \n      ComponentAndRoleStates componentServers)\n          throws IOException {\n    List<AgentRoleState> agentRoleStates = \n        heartbeat.getInstalledRoleStates();\n    for (AgentRoleState agentRoleState : agentRoleStates) {\n      componentServers.recordRoleState(agentRoleState);\n    }\n    checkActionResults(heartbeat, componentServers);\n  }","id":30875,"modified_method":"private List<Cluster> inspectAgentState(HeartBeat heartbeat, \n      ComponentAndRoleStates componentServers)\n          throws IOException {\n    List<AgentRoleState> agentRoleStates = \n        heartbeat.getInstalledRoleStates();\n    List<Cluster> clustersNodeBelongsTo = new ArrayList<Cluster>();\n    for (AgentRoleState agentRoleState : agentRoleStates) {\n      componentServers.recordRoleState(heartbeat.getHostname(),agentRoleState);\n      Cluster c = Clusters.getInstance().\n          getClusterByID(agentRoleState.getClusterId());\n      clustersNodeBelongsTo.add(c);\n    }\n    checkActionResults(heartbeat, componentServers);\n    return clustersNodeBelongsTo;\n  }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"void recordRoleState(AgentRoleState state) {\n      recordState(state.getComponentName(),state.getRoleName(),state);\n    }","id":30876,"modified_method":"private void recordState(ClusterIdAndRev clusterIdAndRev, String component,\n        String roleServer, AgentRoleState state) {\n      Map<String, Map<String, RoleStateTracker>> componentMap = null;\n      \n      if ((componentMap = componentRoleMap.get(clusterIdAndRev))\n          != null) {\n        Map<String,RoleStateTracker> roles = componentMap.get(component);\n        RoleStateTracker roleState = new RoleStateTracker(state.getServerStatus(), \n            state.getClusterId(), state.getClusterDefinitionRevision());\n        if (roles != null) {\n          roles.put(roleServer, roleState);\n        } else {\n          roles = new HashMap<String, RoleStateTracker>();\n          componentMap.put(component, roles);\n        }\n        return;\n      }\n      componentMap = new HashMap<String, Map<String,RoleStateTracker>>();\n      componentRoleMap.put(clusterIdAndRev, componentMap);\n      Map<String,RoleStateTracker> roleMap = new HashMap<String,RoleStateTracker>();\n      \n      roleMap.put(roleServer, \n          new RoleStateTracker(state.getServerStatus(), \n              state.getClusterId(), state.getClusterDefinitionRevision()));\n      componentMap.put(component, roleMap);\n    }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"boolean isRoleInstalled(String role) {\n      //problematic in the case where role is not unique (like 'client')\n      //TODO: no iteration please\n      Set<Map.Entry<String, Map<String, AgentRoleState>>> entrySet = \n          componentRoleMap.entrySet();\n      for (Map.Entry<String, Map<String, AgentRoleState>> entry : entrySet) {\n        if (entry.getValue().containsKey(role)) {\n          return true;\n        }\n      }\n      return false;\n    }","id":30877,"modified_method":"boolean isRoleInstalled(ClusterIdAndRev clusterIdAndRev, String role) {\n      //problematic in the case where role is not unique (like 'client')\n      //TODO: no iteration please\n      Set<Map.Entry<String, Map<String, RoleStateTracker>>> entrySet = \n          componentRoleMap.get(clusterIdAndRev).entrySet();\n      for (Map.Entry<String, Map<String, RoleStateTracker>> entry : entrySet) {\n        if (entry.getValue().containsKey(role)) {\n          return true;\n        }\n      }\n      return false;\n    }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"boolean isStarted(String component, String role) {\n      Map<String, AgentRoleState> startedServerMap;\n      if ((startedServerMap = componentRoleMap.get(component)) \n          != null) {\n        AgentRoleState state = startedServerMap.get(role);\n        return state.getServerStatus() == AgentRoleState.State.STARTED;\n      }\n      return false;\n    }","id":30878,"modified_method":"boolean isStarted(ClusterIdAndRev clusterIdAndRev, String component, \n        String role) {\n      Map<String,Map<String,RoleStateTracker>> componentsMap = \n          componentRoleMap.get(clusterIdAndRev);\n      if (componentsMap == null) {\n        return false;\n      }\n      Map<String, RoleStateTracker> startedServerMap;\n      if ((startedServerMap = componentsMap.get(component)) != null) {\n        RoleStateTracker state = startedServerMap.get(role);\n        if (state == null) \n          return false;\n        return state.state == AgentRoleState.State.STARTED;\n      }\n      return false;\n    }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"public ControllerResponse processHeartBeat(HeartBeat heartbeat) \n      throws Exception {\n    ControllerResponse response = \n        agentToHeartbeatResponseMap.get(heartbeat.getHostname());\n    if (response != null) {\n      if (response.getResponseId() == heartbeat.getResponseId()) {\n        return response; //duplicate heartbeat\n      }\n    }\n\n    short responseId = (short)(heartbeat.getResponseId() + 1);\n\n    String hostname = heartbeat.getHostname();\n    Date heartbeatTime = new Date(System.currentTimeMillis());\n    String clusterId = null;\n\n    Nodes.getInstance().checkAndUpdateNode(hostname, heartbeatTime);\n\n    List<Action> allActions = new ArrayList<Action>();\n\n    clusterId = Nodes.getInstance().getNode(hostname)\n        .getNodeState().getClusterID();\n    \n    if (clusterId != null) {\n      Cluster cluster = \n          Clusters.getInstance().getClusterByID(clusterId);\n\n      if (heartbeat.getIdle()) {\n        //if the command-execution takes longer than one heartbeat interval\n        //the check for idleness will prevent the same node getting the same \n        //command more than once. In the future this could be improved\n        //to reflect the command execution state more accurately.\n\n        ComponentAndRoleStates componentStates = \n            new ComponentAndRoleStates();\n        //get the state machine reference to the cluster\n        ClusterFSM clusterFsm = StateMachineInvoker\n            .getStateMachineClusterInstance(clusterId);\n\n        //create some datastructures by looking at agent state\n        inspectAgentState(heartbeat, componentStates);\n\n        //the state machine references to the services\n        List<ServiceFSM> clusterServices = clusterFsm.getServices();\n        //go through all the services, and check which role should be started\n        //TODO: Given that we already look at what is running/installed in \n        //inspectAgentState, maybe we can avoid the following for loop.\n        for (ServiceFSM service : clusterServices) {\n          List<RoleFSM> roles = service.getRoles();\n\n          for (RoleFSM role : roles) {\n            boolean nodePlayingRole = \n                nodePlayingRole(hostname, role.getRoleName());\n            if (nodePlayingRole) {\n              boolean roleInstalled = componentStates.isInstalled(\n                  role.getAssociatedService().getServiceName(), \n                  role.getRoleName());     \n              boolean roleServerRunning = componentStates.isStarted(\n                  role.getAssociatedService().getServiceName(),\n                  role.getRoleName()) \n                  || componentStates.isStartInProgress(\n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n              ComponentPlugin plugin = \n                  cluster.getComponentDefinition(service.getServiceName());\n              //check whether the agent should start any server\n              if (role.shouldStart()) {\n                if (!roleInstalled) {\n                  //send action for installing the role\n                  Action action = plugin.install(cluster.getName(), \n                      role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterId,\n                      cluster.getLatestRevision(), service.getServiceName(), \n                      role.getRoleName());\n                  //send action for configuring\n                  action = plugin.configure(clusterId, role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterId,\n                      cluster.getLatestRevision(), service.getServiceName(), \n                      role.getRoleName());\n                  continue;\n                }\n                if (role.getRoleName().equals(\"CLIENT\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. They don't have any active servers\n                  //but should be considered active when installed. Setting the \n                  //boolean to true ensures that the FSM gets an event (albeit a fake one).\n                  roleServerRunning = true;\n                }\n                if (!roleServerRunning) {\n                  //TODO: keep track of retries (via checkActionResults)\n                  Action action = \n                      plugin.startServer(cluster.getName(), role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterId,\n                      cluster.getLatestRevision(), service.getServiceName(), \n                      role.getRoleName());\n                }\n                //raise an event to the state machine for a successful \n                //role-start instance\n                if (roleServerRunning) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.START_SUCCESS, role));\n                }\n              }\n              //check whether the agent should stop any server\n              if (role.shouldStop()) {\n                if (role.getRoleName().equals(\"CLIENT\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. Setting the \n                  //boolean to false ensures that the FSM gets an event (albeit a fake one) \n                  roleServerRunning = false;\n                }\n                if (roleServerRunning) {\n                  //TODO: keep track of retries (via checkActionResults)\n                  addAction(getStopRoleAction(cluster.getID(), \n                      cluster.getLatestRevision(), \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName()), allActions);\n                }\n                //raise an event to the state machine for a successful \n                //role-stop instance\n                if (!roleServerRunning) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.STOP_SUCCESS, role));\n                }\n                if (roleInstalled && \n                    clusterFsm.getClusterState()\n                    .equals(ClusterState.CLUSTER_STATE_ATTIC)) {\n                  Action action = plugin.uninstall(cluster.getName(), \n                      role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, cluster.getID(), \n                      cluster.getLatestRevision(), \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n                }\n              }\n            }\n            //check/create the special component/service-level \n            //actions (like safemode check)\n            checkAndCreateActions(cluster, clusterFsm, service, heartbeat, \n                allActions, componentStates);\n          }\n        }\n      }\n    }\n    ControllerResponse r = new ControllerResponse();\n    r.setResponseId(responseId);\n    r.setActions(allActions);\n    agentToHeartbeatResponseMap.put(heartbeat.getHostname(), r);\n    return r;\n  }","id":30879,"modified_method":"public ControllerResponse processHeartBeat(HeartBeat heartbeat) \n      throws Exception {\n    ControllerResponse response = \n        agentToHeartbeatResponseMap.get(heartbeat.getHostname());\n    if (response != null) {\n      if (response.getResponseId() == heartbeat.getResponseId()) {\n        return response; //duplicate heartbeat\n      }\n    }\n\n    short responseId = (short)(heartbeat.getResponseId() + 1);\n\n    String hostname = heartbeat.getHostname();\n    Date heartbeatTime = new Date(System.currentTimeMillis());\n    String clusterId = null;\n    long clusterRev = 0L;\n\n    Nodes.getInstance().checkAndUpdateNode(hostname, heartbeatTime);\n\n    List<Action> allActions = new ArrayList<Action>();\n\n    clusterId = Nodes.getInstance().getNode(hostname)\n        .getNodeState().getClusterID();\n    if (clusterId != null) {\n      clusterRev = Clusters.getInstance().\n          getClusterByID(clusterId).getLatestRevision(); \n    }\n    \n    ComponentAndRoleStates componentStates = \n        new ComponentAndRoleStates();\n    //create some datastructures by looking at agent state\n    inspectAgentState(heartbeat, componentStates);\n    \n    //get the clusters the node belongs to\n    Set<ClusterIdAndRev> clustersNodeBelongsTo = \n        componentStates.getClustersNodeBelongsTo();\n    \n    //if the command-execution takes longer than one heartbeat interval\n    //the check for idleness will prevent the same node getting the same \n    //command more than once. In the future this could be improved\n    //to reflect the command execution state more accurately.\n    if (heartbeat.getIdle()) {  \n      for (ClusterIdAndRev clusterIdAndRev : clustersNodeBelongsTo) {\n        //check whether this node is out-of-sync w.r.t what's running &\n        //installed, or is it compatible\n        if (!isCompatible(clusterIdAndRev.getClusterId(), \n            clusterIdAndRev.getRevision(), clusterId, clusterRev)) {\n          createStopAndUninstallActions(componentStates, allActions, \n              clusterIdAndRev, true);\n          continue;\n        }\n        //get the cluster object corresponding to the clusterId\n        Cluster cluster = Clusters.getInstance()\n            .getClusterByID(clusterIdAndRev.getClusterId());\n        //get the state machine reference to the cluster\n        ClusterFSM clusterFsm = StateMachineInvoker\n            .getStateMachineClusterInstance(clusterIdAndRev.getClusterId());\n\n        //the state machine references to the services\n        List<ServiceFSM> clusterServices = clusterFsm.getServices();\n        //go through all the services, and check which role should be started\n        //TODO: Given that we already look at what is running/installed in \n        //inspectAgentState, maybe we can avoid the following for loop.\n        for (ServiceFSM service : clusterServices) {\n          List<RoleFSM> roles = service.getRoles();\n\n          for (RoleFSM role : roles) {\n            boolean nodePlayingRole = \n                nodePlayingRole(hostname, role.getRoleName());\n            if (nodePlayingRole) {\n              boolean roleInstalled = componentStates.isInstalled(\n                  clusterIdAndRev,\n                  role.getAssociatedService().getServiceName(), \n                  role.getRoleName());     \n              boolean roleServerRunning = componentStates.isStarted(\n                  clusterIdAndRev,\n                  role.getAssociatedService().getServiceName(),\n                  role.getRoleName()) \n                  || componentStates.isStartInProgress(clusterIdAndRev,\n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n              boolean agentRoleStateChanged = componentStates.hasStateChanged(\n                  clusterIdAndRev, role.getAssociatedService().getServiceName(), \n                  role.getRoleName());\n              ComponentPlugin plugin = \n                  cluster.getComponentDefinition(service.getServiceName());\n              \n              //check whether the agent should start any server\n              if (role.shouldStart()) {\n                if (!roleInstalled) {\n                  //send action for creating dir structure\n                  Action action = new Action();\n                  action.setKind(Kind.CREATE_STRUCTURE_ACTION);\n                  fillDetailsAndAddAction(action, allActions, clusterId,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                  \n                  //send action for installing the role\n                  action = plugin.install(cluster.getName(), \n                      role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterId,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                  \n                  //send action for configuring\n                  action = plugin.configure(clusterId, role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterId,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                  continue;\n                }\n                if (role.getRoleName().equals(\"-client\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. They don't have any active servers\n                  //but should be considered active when installed. Setting the \n                  //boolean to true ensures that the FSM gets an event (albeit a fake one).\n                  roleServerRunning = true;\n                }\n                if (!roleServerRunning) {\n                  //TODO: keep track of retries (via checkActionResults)\n                  Action action = \n                      plugin.startServer(cluster.getName(), role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterId,\n                      clusterRev, service.getServiceName(), \n                      role.getRoleName());\n                }\n                //raise an event to the state machine for a successful \n                //role-start instance\n                if (roleServerRunning && agentRoleStateChanged) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.START_SUCCESS, role));\n                }\n                componentStates.\n                  continueRunning(clusterIdAndRev, \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n              }\n              //check whether the agent should stop any server\n              if (role.shouldStop()) {\n                if (role.getRoleName().contains(\"-client\")) { //TODO: have a good place to define this\n                  //Client roles are special cases. Setting the \n                  //boolean to false ensures that the FSM gets an event (albeit a fake one) \n                  roleServerRunning = false;\n                }\n                if (roleServerRunning) {\n                  //TODO: keep track of retries (via checkActionResults)\n                  addAction(getStopRoleAction(clusterId, \n                      clusterRev, \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName()), allActions);\n                }\n                //raise an event to the state machine for a successful \n                //role-stop instance\n                if (!roleServerRunning && agentRoleStateChanged) {\n                  StateMachineInvoker.getAMBARIEventHandler()\n                  .handle(new RoleEvent(RoleEventType.STOP_SUCCESS, role));\n                }\n                if (roleInstalled && \n                    clusterFsm.getClusterState()\n                    .equals(ClusterState.CLUSTER_STATE_ATTIC)) {\n                  Action action = plugin.uninstall(cluster.getName(), \n                      role.getRoleName());\n                  fillDetailsAndAddAction(action, allActions, clusterId, \n                      clusterRev, \n                      role.getAssociatedService().getServiceName(), \n                      role.getRoleName());\n                }\n              }\n            }\n            //check/create the special component/service-level \n            //actions (like safemode check)\n            checkAndCreateActions(cluster, clusterFsm,clusterIdAndRev, service, heartbeat, \n                allActions, componentStates);\n          }\n        }\n        createStopAndUninstallActions(componentStates, allActions, clusterIdAndRev, false);\n      }\n    }\n    ControllerResponse r = new ControllerResponse();\n    r.setResponseId(responseId);\n    r.setActions(allActions);\n    agentToHeartbeatResponseMap.put(heartbeat.getHostname(), r);\n    return r;\n  }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"private void recordState(String component, String roleServer, AgentRoleState state) {\n      Map<String, AgentRoleState> serverStartedMap = null;\n      if ((serverStartedMap = componentRoleMap.get(component))\n          != null) {\n        serverStartedMap.put(roleServer, state);\n        return;\n      }\n      serverStartedMap = new HashMap<String, AgentRoleState>();\n      serverStartedMap.put(roleServer, state);\n      componentRoleMap.put(component, serverStartedMap);\n    }","id":30880,"modified_method":"void recordRoleState(String host, AgentRoleState state) {\n      ClusterIdAndRev clusterIdAndRev = \n          new ClusterIdAndRev(state.getClusterId(),\n              state.getClusterDefinitionRevision());\n      clusterNodeBelongsTo.add(clusterIdAndRev);\n      \n      recordState(clusterIdAndRev,state.getComponentName(),\n          state.getRoleName(),state);\n      \n      List<AgentRoleState> agentRoleStates = null;\n      boolean alreadyPresent = false;\n\n      if ((agentRoleStates = previousStateMap.get(host)) != null) {\n        for (AgentRoleState agentRoleState : agentRoleStates) {\n          if (agentRoleState.roleAttributesEqual(state)) {\n            alreadyPresent = true; \n            if (agentRoleState.getServerStatus() != state.getServerStatus()) { \n              //state of the server is different. Record that.\n              setStateChanged(clusterIdAndRev,state.getComponentName(),\n                  state.getRoleName());\n              agentRoleState.setServerStatus(state.getServerStatus());\n            }\n          }\n        }\n      } else {\n        agentRoleStates = new ArrayList<AgentRoleState>();\n        previousStateMap.put(host, agentRoleStates);\n      }\n      if (!alreadyPresent) {\n        agentRoleStates.add(state); \n      }\n    }","commit_id":"1015b8c8e9e42c24b1fb750f356de15de800201b","url":"https://github.com/apache/ambari"},{"original_method":"/**\r\n     * Creates an <tt>AboutWindow<\/tt> by specifying the parent frame owner.\r\n     * @param owner the parent owner\r\n     */\r\n    public AboutWindow(Frame owner)\r\n    {\r\n        super(owner);\r\n\r\n        ResourceManagementService resources = BrandingActivator.getResources();\r\n\r\n        String applicationName\r\n            = resources.getSettingsString(\"service.gui.APPLICATION_NAME\");\r\n\r\n        this.setTitle(\r\n            resources.getI18NString(\"plugin.branding.ABOUT_WINDOW_TITLE\",\r\n                new String[]{applicationName}));\r\n\r\n        setModal(false);\r\n        setDefaultCloseOperation(DISPOSE_ON_CLOSE);\r\n\r\n        JPanel mainPanel = new WindowBackground();\r\n        mainPanel.setLayout(new BorderLayout());\r\n\r\n        JPanel textPanel = new JPanel();\r\n        textPanel.setPreferredSize(new Dimension(470, 280));\r\n        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\r\n        textPanel.setBorder(BorderFactory\r\n                .createEmptyBorder(15, 15, 15, 15));\r\n        textPanel.setOpaque(false);\r\n\r\n        JLabel titleLabel = null;\r\n        if (isApplicationNameShown())\r\n        {\r\n            titleLabel = new JLabel(applicationName);\r\n            titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 28));\r\n            titleLabel.setForeground(Constants.TITLE_COLOR);\r\n            titleLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        }\r\n\r\n        // Force the use of the custom text field UI in order to fix an\r\n        // incorrect rendering on Ubuntu.\r\n        versionLabel\r\n            = new JTextField(\" \"\r\n                    + System.getProperty(\"sip-communicator.version\"))\r\n        {\r\n            /**\r\n             * Returns the name of the L&F class that renders this component.\r\n             *\r\n             * @return the string \"TreeUI\"\r\n             * @see JComponent#getUIClassID\r\n             * @see UIDefaults#getUI\r\n             */\r\n            @Override\r\n            public String getUIClassID()\r\n            {\r\n                return uiClassID;\r\n            }\r\n        };\r\n\r\n        versionLabel.setBorder(null);\r\n        versionLabel.setOpaque(false);\r\n        versionLabel.setEditable(false);\r\n        versionLabel.setFont(versionLabel.getFont().deriveFont(Font.BOLD, 18));\r\n        versionLabel.setForeground(Constants.TITLE_COLOR);\r\n        versionLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        versionLabel.setHorizontalAlignment(JTextField.RIGHT);\r\n\r\n        int logoAreaFontSize\r\n            = resources.getSettingsInt(\"plugin.branding.ABOUT_LOGO_FONT_SIZE\");\r\n\r\n        // FIXME: the message exceeds the window length\r\n        JTextArea logoArea =\r\n            new JTextArea(resources.getI18NString(\r\n                \"plugin.branding.LOGO_MESSAGE\"));\r\n        logoArea.setFont(\r\n            logoArea.getFont().deriveFont(Font.BOLD, logoAreaFontSize));\r\n        logoArea.setForeground(Constants.TITLE_COLOR);\r\n        logoArea.setOpaque(false);\r\n        logoArea.setLineWrap(true);\r\n        logoArea.setWrapStyleWord(true);\r\n        logoArea.setEditable(false);\r\n        logoArea.setPreferredSize(new Dimension(100, 20));\r\n        logoArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        logoArea.setBorder(BorderFactory\r\n            .createEmptyBorder(30, DEFAULT_TEXT_INDENT, 0, 0));\r\n\r\n        StyledHTMLEditorPane rightsArea = new StyledHTMLEditorPane();\r\n        rightsArea.setContentType(\"text/html\");\r\n\r\n        rightsArea.appendToEnd(resources.getI18NString(\r\n            \"plugin.branding.COPYRIGHT\",\r\n            new String[]\r\n            { Constants.TEXT_COLOR }));\r\n\r\n        rightsArea.setPreferredSize(new Dimension(50, 20));\r\n        rightsArea\r\n                .setBorder(BorderFactory\r\n                    .createEmptyBorder(0, DEFAULT_TEXT_INDENT, 0, 0));\r\n        rightsArea.setOpaque(false);\r\n        rightsArea.setEditable(false);\r\n        rightsArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        rightsArea.addHyperlinkListener(this);\r\n\r\n        StyledHTMLEditorPane licenseArea = new StyledHTMLEditorPane();\r\n        licenseArea.setContentType(\"text/html\");\r\n        licenseArea.appendToEnd(resources.\r\n            getI18NString(\"plugin.branding.LICENSE\",\r\n            new String[]{Constants.TEXT_COLOR}));\r\n\r\n        licenseArea.setPreferredSize(new Dimension(50, 20));\r\n        licenseArea.setBorder(\r\n            BorderFactory.createEmptyBorder(\r\n                resources.getSettingsInt(\"plugin.branding.ABOUT_PARAGRAPH_GAP\"),\r\n                DEFAULT_TEXT_INDENT,\r\n                0, 0));\r\n        licenseArea.setOpaque(false);\r\n        licenseArea.setEditable(false);\r\n        licenseArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        licenseArea.addHyperlinkListener(this);\r\n\r\n        if (titleLabel != null)\r\n            textPanel.add(titleLabel);\r\n\r\n        textPanel.add(versionLabel);\r\n        textPanel.add(logoArea);\r\n        textPanel.add(rightsArea);\r\n        textPanel.add(licenseArea);\r\n\r\n        JButton okButton\r\n            = new JButton(resources.getI18NString(\"service.gui.OK\"));\r\n\r\n        this.getRootPane().setDefaultButton(okButton);\r\n\r\n        okButton.setMnemonic(resources.getI18nMnemonic(\"service.gui.OK\"));\r\n        okButton.addActionListener(this);\r\n\r\n        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));\r\n        buttonPanel.add(okButton);\r\n        buttonPanel.setOpaque(false);\r\n\r\n        mainPanel.add(textPanel, BorderLayout.CENTER);\r\n        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\r\n\r\n        this.getContentPane().add(mainPanel);\r\n\r\n        this.pack();\r\n        this.setResizable(false);\r\n\r\n        setLocationRelativeTo(getParent());\r\n\r\n        this.getRootPane().getActionMap().put(\"close\", new CloseAction());\r\n\r\n        InputMap imap = this.getRootPane().getInputMap(\r\n                JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\r\n\r\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\r\n\r\n        if(OSUtils.IS_MAC)\r\n        {\r\n            imap.put(\r\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.META_DOWN_MASK),\r\n                \"close\");\r\n            imap.put(\r\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK),\r\n                \"close\");\r\n        }\r\n\r\n        WindowUtils.addWindow(this);\r\n    }","id":30881,"modified_method":"/**\r\n     * Creates an <tt>AboutWindow<\/tt> by specifying the parent frame owner.\r\n     * @param owner the parent owner\r\n     */\r\n    public AboutWindow(Frame owner)\r\n    {\r\n        super(owner);\r\n\r\n        ResourceManagementService resources = BrandingActivator.getResources();\r\n\r\n        String applicationName\r\n            = resources.getSettingsString(\"service.gui.APPLICATION_NAME\");\r\n\r\n        this.setTitle(\r\n            resources.getI18NString(\"plugin.branding.ABOUT_WINDOW_TITLE\",\r\n                new String[]{applicationName}));\r\n\r\n        setModal(false);\r\n        setDefaultCloseOperation(DISPOSE_ON_CLOSE);\r\n        setResizable(false);\r\n\r\n        JPanel mainPanel = new WindowBackground();\r\n        mainPanel.setLayout(new BorderLayout());\r\n\r\n        JPanel textPanel = new JPanel();\r\n        textPanel.setPreferredSize(new Dimension(470, 280));\r\n        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\r\n        textPanel.setBorder(BorderFactory\r\n                .createEmptyBorder(15, 15, 15, 15));\r\n        textPanel.setOpaque(false);\r\n\r\n        JLabel titleLabel = null;\r\n        if (isApplicationNameShown())\r\n        {\r\n            titleLabel = new JLabel(applicationName);\r\n            titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 28));\r\n            titleLabel.setForeground(Constants.TITLE_COLOR);\r\n            titleLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        }\r\n\r\n        // Force the use of the custom text field UI in order to fix an\r\n        // incorrect rendering on Ubuntu.\r\n        versionLabel\r\n            = new JTextField(\" \"\r\n                    + System.getProperty(\"sip-communicator.version\"))\r\n        {\r\n            /**\r\n             * Returns the name of the L&F class that renders this component.\r\n             *\r\n             * @return the string \"TreeUI\"\r\n             * @see JComponent#getUIClassID\r\n             * @see UIDefaults#getUI\r\n             */\r\n            @Override\r\n            public String getUIClassID()\r\n            {\r\n                return uiClassID;\r\n            }\r\n        };\r\n\r\n        versionLabel.setBorder(null);\r\n        versionLabel.setOpaque(false);\r\n        versionLabel.setEditable(false);\r\n        versionLabel.setFont(versionLabel.getFont().deriveFont(Font.BOLD, 18));\r\n        versionLabel.setForeground(Constants.TITLE_COLOR);\r\n        versionLabel.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        versionLabel.setHorizontalAlignment(JTextField.RIGHT);\r\n\r\n        int logoAreaFontSize\r\n            = resources.getSettingsInt(\"plugin.branding.ABOUT_LOGO_FONT_SIZE\");\r\n\r\n        // FIXME: the message exceeds the window length\r\n        JTextArea logoArea =\r\n            new JTextArea(resources.getI18NString(\r\n                \"plugin.branding.LOGO_MESSAGE\"));\r\n        logoArea.setFont(\r\n            logoArea.getFont().deriveFont(Font.BOLD, logoAreaFontSize));\r\n        logoArea.setForeground(Constants.TITLE_COLOR);\r\n        logoArea.setOpaque(false);\r\n        logoArea.setLineWrap(true);\r\n        logoArea.setWrapStyleWord(true);\r\n        logoArea.setEditable(false);\r\n        logoArea.setPreferredSize(new Dimension(100, 20));\r\n        logoArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        logoArea.setBorder(BorderFactory\r\n            .createEmptyBorder(30, DEFAULT_TEXT_INDENT, 0, 0));\r\n\r\n        StyledHTMLEditorPane rightsArea = new StyledHTMLEditorPane();\r\n        rightsArea.setContentType(\"text/html\");\r\n\r\n        rightsArea.appendToEnd(resources.getI18NString(\r\n            \"plugin.branding.COPYRIGHT\",\r\n            new String[]\r\n            { Constants.TEXT_COLOR }));\r\n\r\n        rightsArea.setPreferredSize(new Dimension(50, 20));\r\n        rightsArea\r\n                .setBorder(BorderFactory\r\n                    .createEmptyBorder(0, DEFAULT_TEXT_INDENT, 0, 0));\r\n        rightsArea.setOpaque(false);\r\n        rightsArea.setEditable(false);\r\n        rightsArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        rightsArea.addHyperlinkListener(this);\r\n\r\n        StyledHTMLEditorPane licenseArea = new StyledHTMLEditorPane();\r\n        licenseArea.setContentType(\"text/html\");\r\n        licenseArea.appendToEnd(resources.\r\n            getI18NString(\"plugin.branding.LICENSE\",\r\n            new String[]{Constants.TEXT_COLOR}));\r\n\r\n        licenseArea.setPreferredSize(new Dimension(50, 20));\r\n        licenseArea.setBorder(\r\n            BorderFactory.createEmptyBorder(\r\n                resources.getSettingsInt(\"plugin.branding.ABOUT_PARAGRAPH_GAP\"),\r\n                DEFAULT_TEXT_INDENT,\r\n                0, 0));\r\n        licenseArea.setOpaque(false);\r\n        licenseArea.setEditable(false);\r\n        licenseArea.setAlignmentX(Component.RIGHT_ALIGNMENT);\r\n        licenseArea.addHyperlinkListener(this);\r\n\r\n        if (titleLabel != null)\r\n            textPanel.add(titleLabel);\r\n\r\n        textPanel.add(versionLabel);\r\n        textPanel.add(logoArea);\r\n        textPanel.add(rightsArea);\r\n        textPanel.add(licenseArea);\r\n\r\n        JButton okButton\r\n            = new JButton(resources.getI18NString(\"service.gui.OK\"));\r\n\r\n        this.getRootPane().setDefaultButton(okButton);\r\n\r\n        okButton.setMnemonic(resources.getI18nMnemonic(\"service.gui.OK\"));\r\n        okButton.addActionListener(this);\r\n\r\n        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));\r\n        buttonPanel.add(okButton);\r\n        buttonPanel.setOpaque(false);\r\n\r\n        mainPanel.add(textPanel, BorderLayout.CENTER);\r\n        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\r\n\r\n        this.getContentPane().add(mainPanel);\r\n\r\n        this.pack();\r\n\r\n        setLocationRelativeTo(getParent());\r\n\r\n        this.getRootPane().getActionMap().put(\"close\", new CloseAction());\r\n\r\n        InputMap imap = this.getRootPane().getInputMap(\r\n                JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\r\n\r\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\r\n\r\n        if(OSUtils.IS_MAC)\r\n        {\r\n            imap.put(\r\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.META_DOWN_MASK),\r\n                \"close\");\r\n            imap.put(\r\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK),\r\n                \"close\");\r\n        }\r\n\r\n        WindowUtils.addWindow(this);\r\n    }","commit_id":"b5c4487c0de1a9b74690f4afb03d564c813c89d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"private Component createInventoryPanel() {\n        inventoryTable = new JTable();\n        inventoryTable.setBorder( null );\n        inventoryTable.setModel( new DefaultTableModel(\n                                                        new Object[][]{\n                                                        },\n                                                        new String[]{\n                                                                \"Inventory\"\n                                                        }\n                ) );\n        inventoryTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = inventoryTable.rowAtPoint( e.getPoint() );\n                int col = inventoryTable.columnAtPoint( e.getPoint() );\n                Thing t = (Thing) inventoryTable.getModel().getValueAt( row,\n                                                                 col );\n                cmdTextField.setText( cmdTextField.getText() + t.getName() + \" \" );\n                cmd.add( t );\n            }\n        } );\n\n        JScrollPane inventoryPanel = new JScrollPane( inventoryTable );\n        return inventoryPanel;\n    }","id":30882,"modified_method":"private Component createInventoryPanel() {\n        inventoryTable = new JTable();\n        inventoryTable.setBorder( null );\n        inventoryTable.setModel( new NonEditableTableMode(\n                                                        new Object[][]{\n                                                        },\n                                                        new String[]{\n                                                                \"Inventory\"\n                                                        }\n                ) );\n        inventoryTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = inventoryTable.rowAtPoint( e.getPoint() );\n                int col = inventoryTable.columnAtPoint( e.getPoint() );\n                Thing t = (Thing) inventoryTable.getModel().getValueAt( row,\n                                                                 col );\n                cmdTextField.setText( cmdTextField.getText() + t.getName() + \" \" );\n                cmd.add( t );\n            }\n        } );\n\n        JScrollPane inventoryPanel = new JScrollPane( inventoryTable );\n        return inventoryPanel;\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void createCharacterPanel(JPanel parent) {\n        parent.add( createLabel( \"Character\" ),\n                    \"wrap, spanx 3\" );\n        characterSelectCombo = new JComboBox();\n        characterSelectCombo.setModel( new DefaultComboBoxModel( new Object[]{null, null} ) );\n        parent.add( characterSelectCombo,\n                    \"top, left\" );\n\n        Map<String, Character> characterMap = ( Map<String, Character> ) gameEngine.getData().get(\"characters\");\n        Character[] characters = characterMap.values().toArray( new Character[characterMap.size()] );\n\n        characterSelectCombo.setModel( new DefaultComboBoxModel( characters ) );\n        characterSelectCombo.setSelectedItem( characterMap.get(\"hero\"));\n\n        characterSelectCombo.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n\n                Character c = (Character) characterSelectCombo.getSelectedObjects()[0];\n                org.kie.api.runtime.rule.FactHandle fh = gameEngine.getKieSession().getFactHandle(session);\n                session.setCharacter(c);\n                gameEngine.getKieSession().update(fh, session);\n\n                cmd = new ArrayList();\n                cmd.add( LookCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n                gameEngine.receiveMessage( session,\n                                           cmd );\n                cmd = null;\n            }\n        } );\n\n        JTable characterPropertiesTable = new JTable();\n        characterPropertiesTable.setPreferredScrollableViewportSize( new Dimension( 240,\n                                                                                    200 ) );\n        characterPropertiesTable.setBorder( null );\n        characterPropertiesTable.setModel( new DefaultTableModel(\n                                                                  new Object[][]{\n                                                                          {\"strength\", \"100\"},\n                                                                          {\"health\", \"100\"},\n                                                                          {\"coiins\", \"100\"},\n                                                                          {\"speed\", \"100\"},\n                                                                          {\"mana\", \"100\"},\n                                                                  },\n                                                                  new String[]{\n                                                                          \"property\", \"value\"\n                                                                  }\n                ) );\n        JScrollPane characterPropertiesPanel = new JScrollPane( characterPropertiesTable );\n        parent.add( characterPropertiesPanel,\n                    \"top, left, wrap, spanx 2\" );\n    }","id":30883,"modified_method":"private void createCharacterPanel(JPanel parent) {\n        parent.add( createLabel( \"Character\" ),\n                    \"wrap, spanx 3\" );\n        characterSelectCombo = new JComboBox();\n        characterSelectCombo.setModel( new DefaultComboBoxModel( new Object[]{null, null} ) );\n        parent.add( characterSelectCombo,\n                    \"top, left\" );\n\n        Map<String, Character> characterMap = ( Map<String, Character> ) gameEngine.getData().get(\"characters\");\n        Character[] characters = characterMap.values().toArray( new Character[characterMap.size()] );\n\n        characterSelectCombo.setModel( new DefaultComboBoxModel( characters ) );\n        characterSelectCombo.setSelectedItem( characterMap.get(\"hero\"));\n\n        characterSelectCombo.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n\n                Character c = (Character) characterSelectCombo.getSelectedObjects()[0];\n                org.kie.api.runtime.rule.FactHandle fh = gameEngine.getKieSession().getFactHandle(session);\n                session.setCharacter(c);\n                gameEngine.getKieSession().update(fh, session);\n\n                cmd = new ArrayList();\n                cmd.add( LookCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n                gameEngine.receiveMessage( session,\n                                           cmd );\n                cmd = null;\n            }\n        } );\n\n        JTable characterPropertiesTable = new JTable();\n        characterPropertiesTable.setPreferredScrollableViewportSize( new Dimension( 240,\n                                                                                    200 ) );\n        characterPropertiesTable.setBorder( null );\n        characterPropertiesTable.setModel( new NonEditableTableMode(\n                                                                  new Object[][]{\n                                                                          {\"strength\", \"100\"},\n                                                                          {\"health\", \"100\"},\n                                                                          {\"coiins\", \"100\"},\n                                                                          {\"speed\", \"100\"},\n                                                                          {\"mana\", \"100\"},\n                                                                  },\n                                                                  new String[]{\n                                                                          \"property\", \"value\"\n                                                                  }\n                ) );\n        JScrollPane characterPropertiesPanel = new JScrollPane( characterPropertiesTable );\n        parent.add( characterPropertiesPanel,\n                    \"top, left, wrap, spanx 2\" );\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void addRows(List list) {\n            DefaultTableModel model = (DefaultTableModel) jTable.getModel();\n\n\n            if ( model.getRowCount() < list.size() ) {\n                Object[][] exits = new Object[list.size()][];\n                for ( int i = 0, length = model.getRowCount(); i < length; i++ ) {\n                    model.setValueAt( list.get( i ),\n                                      i,\n                                      0 );\n                }\n                for ( int i = model.getRowCount(), length = exits.length; i < length; i++ ) {\n                    model.addRow( new Object[]{list.get( i )} );\n                }\n            } else {\n                Object[][] exits = new Object[list.size()][];\n                for ( int i = 0; i < exits.length; i++ ) {\n                    model.setValueAt( list.get( i ),\n                                      i,\n                                      0 );\n                }\n                int i = exits.length;\n                while ( model.getRowCount() > exits.length ) {\n                    model.removeRow( i );\n                }\n            }\n        }","id":30884,"modified_method":"public void addRows(List list) {\n            DefaultTableModel model = (DefaultTableModel) jTable.getModel();\n\n\n            if ( model.getRowCount() < list.size() ) {\n                Object[][] exits = new Object[list.size()][];\n                for ( int i = 0, length = model.getRowCount(); i < length; i++ ) {\n                    model.setValueAt( list.get( i ),\n                                      i,\n                                      0 );\n                }\n                for ( int i = model.getRowCount(), length = exits.length; i < length; i++ ) {\n                    if ( list.get( i ) == null ) {\n                        continue;\n                    }\n                    model.addRow( new Object[]{list.get( i )} );\n                }\n            } else {\n                Object[][] exits = new Object[list.size()][];\n                for ( int i = 0; i < exits.length; i++ ) {\n                    if ( list.get( i ) == null ) {\n                        continue;\n                    }\n                    model.setValueAt( list.get( i ),\n                                      i,\n                                      0 );\n                }\n                int i = exits.length;\n                while ( model.getRowCount() > exits.length ) {\n                    model.removeRow( i );\n                }\n            }\n        }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public JTableChannel(JTable jTable) {\n            this.jTable = jTable;\n            String name = jTable.getColumnName(0);\n            jTable.getColumn( name ).setCellRenderer(new DefaultTableCellRenderer() {\n                public void setValue(Object value) {\n                    setText(((Thing) value).getName());\n                }\n            });\n\n        }","id":30885,"modified_method":"public JTableChannel(JTable jTable) {\n            this.jTable = jTable;\n            String name = jTable.getColumnName(0);\n\n            jTable.getColumn( name ).setCellRenderer(new DefaultTableCellRenderer() {\n                public void setValue(Object value) {\n                    if ( value == null ) {\n                        return;\n                    } else if ( value instanceof Thing ) {\n                        setText(((Thing) value).getName());\n                    } else {\n                        setText( value.toString() );\n                    }\n                }\n            });\n\n        }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void createBuildActionsPanel(JPanel parent) {\n        parent.add( createLabel( \"Actions\" ),\n                    \"wrap, spanx 3\" );\n\n        JPanel actionsPanel = new JPanel();\n        actionsPanel.setBorder( null );\n        actionsPanel.setLayout( new BoxLayout( actionsPanel,\n                                               BoxLayout.Y_AXIS ) );\n\n        JButton moveBtn = new JButton( \"Move\" );\n        moveBtn.setToolTipText(\"Select one Room from the Exits, then press Send\");\n        actionsPanel.add( moveBtn );\n//        msg = new ACLMessage();\n//        msg.setPerformative( Performative.REQUEST );\n        \n        moveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Move \" );\n                cmd = new ArrayList();\n                cmd.add(MoveCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton pickupBtn = new JButton( \"Pick Up\" );\n        pickupBtn.setToolTipText(\"Select one from the Items list, then press Send\");\n        actionsPanel.add( pickupBtn );\n        pickupBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Pickup \" );\n                cmd = new ArrayList();\n                cmd.add(PickupCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton dropBtn = new JButton( \"Drop\" );\n        dropBtn.setToolTipText(\"Select one from the Inventory, then press Send\");\n        actionsPanel.add( dropBtn );\n        dropBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Drop \" );\n                cmd = new ArrayList();\n                cmd.add(DropCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton giveBtn = new JButton( \"Give\" );\n        giveBtn.setToolTipText(\"Select one from the Inventory, then Select the target Character, then press Send\");\n        actionsPanel.add( giveBtn );\n        giveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {                \n                cmdTextField.setText( \"Request Give \" );\n                cmd = new ArrayList();\n                cmd.add(GiveCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton lookBtn = new JButton( \"Look\" );\n        giveBtn.setToolTipText(\"Just press Send\");\n        actionsPanel.add( lookBtn );\n        lookBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Look \" );\n                cmd = new ArrayList();\n                cmd.add( LookCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        parent.add( actionsPanel,\n                    \"top, left\" );\n\n        thingsTable = new JTable();\n        thingsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                       250 ) );\n        thingsTable.setBorder( null );\n        thingsTable.setModel( new DefaultTableModel(\n                                                     new Object[][]{\n                                                     },\n                                                     new String[]{\n                                                             \"Items\"\n                                                     }\n                ) );\n        thingsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = thingsTable.rowAtPoint( e.getPoint() );\n                int col = thingsTable.columnAtPoint( e.getPoint() );\n                Thing t = (Thing) thingsTable.getModel().getValueAt( row,\n                                                              col );\n                cmdTextField.setText( cmdTextField.getText() + t.getName() + \" \" );\n                cmd.add( t );\n            }\n        } );\n\n        JScrollPane itemsPanel = new JScrollPane( thingsTable );\n        parent.add( itemsPanel,\n                    \"top, left\" );\n\n        exitsTable = new JTable();\n        exitsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                      250 ) );\n        exitsTable.setBorder( null );\n        exitsTable.setModel( new DefaultTableModel(\n                                                    new Object[][]{\n                                                    },\n                                                    new String[]{\n                                                            \"Exits\"\n                                                    }\n                ) );\n\n        exitsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = exitsTable.rowAtPoint( e.getPoint() );\n                int col = exitsTable.columnAtPoint( e.getPoint() );\n                Room r = (Room) exitsTable.getModel().getValueAt( row,\n                                                             col );\n                cmdTextField.setText( cmdTextField.getText() + r.getName() + \" \" );\n                cmd.add( r );\n            }\n        } );\n\n        JScrollPane exitsPanel = new JScrollPane( exitsTable );\n        parent.add( exitsPanel,\n                    \"top, left, wrap\" );\n\n    }","id":30886,"modified_method":"private void createBuildActionsPanel(JPanel parent) {\n        parent.add( createLabel( \"Actions\" ),\n                    \"wrap, spanx 3\" );\n\n        JPanel actionsPanel = new JPanel();\n        actionsPanel.setBorder( null );\n        actionsPanel.setLayout( new BoxLayout( actionsPanel,\n                                               BoxLayout.Y_AXIS ) );\n\n        JButton moveBtn = new JButton( \"Move\" );\n        moveBtn.setToolTipText(\"Select one Room from the Exits, then press Send\");\n        actionsPanel.add( moveBtn );\n//        msg = new ACLMessage();\n//        msg.setPerformative( Performative.REQUEST );\n        \n        moveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Move \" );\n                cmd = new ArrayList();\n                cmd.add(MoveCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton pickupBtn = new JButton( \"Pick Up\" );\n        pickupBtn.setToolTipText(\"Select one from the Items list, then press Send\");\n        actionsPanel.add( pickupBtn );\n        pickupBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Pickup \" );\n                cmd = new ArrayList();\n                cmd.add(PickupCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton dropBtn = new JButton( \"Drop\" );\n        dropBtn.setToolTipText(\"Select one from the Inventory, then press Send\");\n        actionsPanel.add( dropBtn );\n        dropBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Drop \" );\n                cmd = new ArrayList();\n                cmd.add(DropCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton giveBtn = new JButton( \"Give\" );\n        giveBtn.setToolTipText(\"Select one from the Inventory, then Select the target Character, then press Send\");\n        actionsPanel.add( giveBtn );\n        giveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {                \n                cmdTextField.setText( \"Give \" );\n                cmd = new ArrayList();\n                cmd.add(GiveCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton useBtn = new JButton( \"Use\" );\n        useBtn.setToolTipText(\"Select one from the Inventory, then Select the target Thing or Room\");\n        actionsPanel.add( useBtn );\n        useBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Use \" );\n                cmd = new ArrayList();\n                cmd.add(UseCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton lookBtn = new JButton( \"Look\" );\n        giveBtn.setToolTipText(\"Just press Send\");\n        actionsPanel.add( lookBtn );\n        lookBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Look \" );\n                cmd = new ArrayList();\n                cmd.add( LookCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        parent.add( actionsPanel,\n                    \"top, left\" );\n\n        thingsTable = new JTable();\n        thingsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                       250 ) );\n        thingsTable.setBorder( null );\n        thingsTable.setModel( new NonEditableTableMode(\n                                                     new Object[][]{\n                                                     },\n                                                     new String[]{\n                                                             \"Items\"\n                                                     }\n                ) );\n        thingsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = thingsTable.rowAtPoint( e.getPoint() );\n                int col = thingsTable.columnAtPoint( e.getPoint() );\n                Thing t = (Thing) thingsTable.getModel().getValueAt( row,\n                                                              col );\n                cmdTextField.setText( cmdTextField.getText() + t.getName() + \" \" );\n                cmd.add( t );\n            }\n        } );\n\n        JScrollPane itemsPanel = new JScrollPane( thingsTable );\n        parent.add( itemsPanel,\n                    \"top, left\" );\n\n        exitsTable = new JTable();\n        exitsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                      250 ) );\n        exitsTable.setBorder( null );\n        exitsTable.setModel( new NonEditableTableMode(\n                                                    new Object[][]{\n                                                    },\n                                                    new String[]{\n                                                            \"Exits\"\n                                                    }\n                ) );\n\n        exitsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = exitsTable.rowAtPoint( e.getPoint() );\n                int col = exitsTable.columnAtPoint( e.getPoint() );\n                Room r = (Room) exitsTable.getModel().getValueAt( row,\n                                                             col );\n                cmdTextField.setText( cmdTextField.getText() + r.getName() + \" \" );\n                cmd.add( r );\n            }\n        } );\n\n        JScrollPane exitsPanel = new JScrollPane( exitsTable );\n        parent.add( exitsPanel,\n                    \"top, left, wrap\" );\n\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void createGame() {\n\n        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();\n        System.out.println(kc.verify().getMessages().toString());\n        ksession = kc.newKieSession(\"TextAdventureKS\");\n\n        Counter c = new Counter();\n        ksession.setGlobal(\"counter\",\n                           c);\n        Map vars = new HashMap();\n        vars.put(\"c\",\n                 c);\n        try {\n            String mvelContent = new String(IOUtils.toByteArray(getClass().getResource(\"data.mvel\").openStream()), IoUtils.UTF8_CHARSET);\n            data = (Map<String, Map>) MVEL.executeExpression(MVEL.compileExpression(mvelContent), vars);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        for (Object o : data.get(\"rooms\").values()) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"doors\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"characters\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"items\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"keys\" ).values() ) {\n            ksession.insert( o );\n        }\n//\n//        for ( Object o : data.get( \"locks\" ).values() ) {\n//            ksession.insert( o );\n//        }\n\n        for ( Object o : data.get( \"locations\" ).values() ) {\n            ksession.insert( o );\n        }\n    }","id":30887,"modified_method":"public void createGame() {\n\n        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();\n        //System.out.println(kc.verify().getMessages().toString());\n        ksession = kc.newKieSession(\"TextAdventureKS\");\n\n        Counter c = new Counter();\n        ksession.setGlobal(\"counter\",\n                           c);\n        Map vars = new HashMap();\n        vars.put(\"c\",\n                 c);\n        try {\n            String mvelContent = new String(IOUtils.toByteArray(getClass().getResource(\"data.mvel\").openStream()), IoUtils.UTF8_CHARSET);\n            data = (Map<String, Map>) MVEL.executeExpression(MVEL.compileExpression(mvelContent), vars);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        for (Object o : data.get(\"rooms\").values()) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"doors\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"characters\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"items\" ).values() ) {\n            ksession.insert( o );\n        }\n\n//        for ( Object o : data.get( \"keys\" ).values() ) {\n//            ksession.insert( o );\n//        }\n//\n//        for ( Object o : data.get( \"locks\" ).values() ) {\n//            ksession.insert( o );\n//        }\n\n        for ( Object o : data.get( \"locations\" ).values() ) {\n            ksession.insert( o );\n        }\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Canvas getCanvas() {\n        return canvas;\n    }","id":30888,"modified_method":"public JPanel getCanvas() {\n        return panel;\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Initialize the contents of the frame.\n     */\n    public void init() {\n        canvas = new Canvas();\n        canvas.setBackground(Color.BLACK);\n        canvas.setSize(new Dimension(conf.getWindowWidth(), conf.getWindowHeight()));\n\n        KeyListener klistener = new GameKeyListener( ksession.getEntryPoint( \"KeyPressedStream\" ), ksession.getEntryPoint( \"KeyReleasedStream\" ) );\n        canvas.addKeyListener(klistener);\n\n        canvas.addMouseListener(new MouseListener() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                canvas.requestFocus();\n            }\n\n            @Override\n            public void mousePressed(MouseEvent e) {\n\n            }\n\n            @Override\n            public void mouseReleased(MouseEvent e) {\n\n            }\n\n            @Override\n            public void mouseEntered(MouseEvent e) {\n\n            }\n\n            @Override\n            public void mouseExited(MouseEvent e) {\n\n            }\n        });\n\n\n        JFrame frame = new JFrame();\n        frame.setResizable(false);\n        frame.setDefaultCloseOperation(conf.isExitOnClose() ? JFrame.EXIT_ON_CLOSE : JFrame.DISPOSE_ON_CLOSE);\n        frame.setSize(new Dimension(conf.getWindowWidth(), conf.getWindowHeight()));\n        frame.setBackground(Color.BLACK);\n        frame.add(canvas);\n        frame.pack();\n        frame.setVisible(true);\n        frame.setLocationRelativeTo(null); // Center in screen\n\n        canvas.createBufferStrategy(2);\n        canvas.requestFocus();\n    }","id":30889,"modified_method":"/**\n     * Initialize the contents of the frame.\n     */\n    public void init() {\n        frame = new GameFrame();\n        frame.setDefaultCloseOperation(conf.isExitOnClose() ? JFrame.EXIT_ON_CLOSE : JFrame.DISPOSE_ON_CLOSE);\n        frame.setResizable( false );\n        frame.setBackground(Color.BLACK);\n        frame.getContentPane().setBackground(Color.BLACK);\n        frame.setSize(new Dimension(conf.getWindowWidth(), conf.getWindowHeight()));\n\n        panel = new MyJPanel(\"\", Color.BLACK);\n        frame.add( panel );\n        panel.init();\n        panel.getBufferedImage();\n\n        frame.setLocationRelativeTo(null); // Center in screen\n        frame.pack();\n        frame.setVisible( true );\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Graphics getGraphics() {\n        return canvas.getBufferStrategy().getDrawGraphics();\n    }","id":30890,"modified_method":"public Graphics getGraphics() {\n        return panel.getGraphics2D();\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public SensorPanel getSensorPanel() {\n        return sensorPanel;\n    }","id":30891,"modified_method":"public GamePanel getSensorPanel() {\n        return sensorPanel;\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public CavePanel getCavePanel() {\n        return cavePanel;\n    }","id":30892,"modified_method":"public GamePanel getCavePanel() {\n        return cavePanel;\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public SensorPanel drawSensorPanel() {\n        SensorPanel sensorPanel = new SensorPanel( this );\n        FlowLayout flowLayout = (FlowLayout) sensorPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        sensorPanel.setBackground( Color.WHITE );\n        return sensorPanel;\n    }","id":30893,"modified_method":"public GamePanel drawSensorPanel() {\n        GamePanel sensorPanel = new GamePanel(\"sensor\", Color.WHITE ); //new SensorPanel( this );\n        FlowLayout flowLayout = (FlowLayout) sensorPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        sensorPanel.setBackground( Color.WHITE );\n        return sensorPanel;\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setGameView(GameView gameView) {\n        this.gameView = gameView;\n        if ( frame == null ) {\n            initialize();\n        }\n    }","id":30894,"modified_method":"public void setGameView(GameView gameView) {\n        this.gameView = gameView;\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Initialize the contents of the frame.\n     */\n    private void initialize() {\n        frame = new JFrame( \"Wumpus World\" );\n        frame.getContentPane().setBackground( Color.WHITE );\n        frame.setDefaultCloseOperation(wumpusWorldConfiguration.isExitOnClose() ? JFrame.EXIT_ON_CLOSE : JFrame.DISPOSE_ON_CLOSE);\n\n        frame.setSize( 926, 603 );\n        frame.getContentPane().setLayout( new MigLayout(\"\", \"[540px:n][grow,fill]\", \"[30px,top][300px,top][100px,top][grow]\") );\n        \n        JPanel scorePanel = new JPanel();\n        FlowLayout flowLayout = (FlowLayout) scorePanel.getLayout();\n        flowLayout.setAlignment(FlowLayout.LEFT);\n        scorePanel.setBackground(Color.WHITE);\n        frame.getContentPane().add(scorePanel, \"cell 0 0,grow\");\n        \n        JLabel lblScore = new JLabel(\"Score\");\n        scorePanel.add(lblScore);\n        \n        final JTextField txtScore = new JTextField();\n        gameView.getKsession().getChannels().put( \"score\", new Channel() {            \n            public void send(Object object) {\n                txtScore.setText( \"\" + ((Score ) object).getValue() );\n            }\n        } );\n        \n        txtScore.setEditable(false);\n        scorePanel.add(txtScore);\n        txtScore.setColumns(10);\n        \n        JScrollPane scrollPane = new JScrollPane();\n        frame.getContentPane().add(scrollPane, \"cell 1 0 1 4,grow\");\n\n        JPanel actionPanel = new JPanel();\n        actionPanel.setBackground( Color.WHITE );\n        frame.getContentPane().add( actionPanel, \"cell 0 1,grow\" );\n        actionPanel.setLayout( new MigLayout(\"\", \"[200px,left][320px:n]\", \"[grow]\") );\n\n        JPanel controls = new JPanel();\n        controls.setBackground( Color.WHITE );\n        controls.setLayout( new MigLayout( \"\", \"[grow,fill]\", \"[::100px,top][200px,top]\" ) );\n        controls.add( drawActionPanel(), \"cell 0 0,alignx left,aligny top\" );\n\n        controls.add( drawMovePanel(), \"cell 0 1,alignx left,growy\" );\n\n        actionPanel.add( controls, \"cell 0 0,grow\" );\n\n        cavePanel = drawCave();\n        actionPanel.add( cavePanel, \"cell 1 0,grow\" );\n\n        sensorPanel = drawSensorPanel();\n        \n        frame.getContentPane().add( sensorPanel, \"cell 0 2,grow\" );\n        \n        JPanel blank = new JPanel();\n        blank.setBackground(Color.WHITE);\n        frame.getContentPane().add(blank, \"cell 0 3,grow\");\n\n        frame.setLocationRelativeTo(null); // Center in screen\n        frame.setVisible( true );\n        \n        updateCave();\n        updateSensors();\n    }","id":30895,"modified_method":"/**\n     * Initialize the contents of the frame.\n     */\n    private void initialize() {\n        frame = new GameFrame( \"Wumpus World\" );\n        frame.getContentPane().setBackground( Color.WHITE );\n        frame.setDefaultCloseOperation(wumpusWorldConfiguration.isExitOnClose() ? JFrame.EXIT_ON_CLOSE : JFrame.DISPOSE_ON_CLOSE);\n        frame.setLayout(new MigLayout(\"\", \"[540px:n][grow,fill]\", \"[30px,top][300px,top][100px,top][grow]\"));\n        frame.setSize( 926, 603 );\n        frame.setLocationRelativeTo(null); // Center in screen\n        \n        JPanel scorePanel = new JPanel();\n        FlowLayout flowLayout = (FlowLayout) scorePanel.getLayout();\n        flowLayout.setAlignment(FlowLayout.LEFT);\n        scorePanel.setBackground(Color.WHITE);\n        frame.getContentPane().add(scorePanel, \"cell 0 0,grow\");\n        \n        JLabel lblScore = new JLabel(\"Score\");\n        scorePanel.add(lblScore);\n        \n        final JTextField txtScore = new JTextField();\n        gameView.getKsession().getChannels().put( \"score\", new Channel() {            \n            public void send(Object object) {\n                txtScore.setText( \"\" + ((Score ) object).getValue() );\n            }\n        } );\n        \n        txtScore.setEditable(false);\n        scorePanel.add(txtScore);\n        txtScore.setColumns(10);\n        \n        JScrollPane scrollPane = new JScrollPane();\n        frame.getContentPane().add(scrollPane, \"cell 1 0 1 4,grow\");\n\n        JPanel actionPanel = new JPanel();\n        actionPanel.setBackground( Color.WHITE );\n        frame.getContentPane().add(actionPanel, \"cell 0 1,grow\");\n        actionPanel.setLayout( new MigLayout(\"\", \"[200px,left][320px:n]\", \"[grow]\") );\n\n        JPanel controls = new JPanel();\n        controls.setBackground( Color.WHITE );\n        controls.setLayout( new MigLayout( \"\", \"[grow,fill]\", \"[::100px,top][200px,top]\" ) );\n        controls.add( drawActionPanel(), \"cell 0 0,alignx left,aligny top\" );\n\n        controls.add( drawMovePanel(), \"cell 0 1,alignx left,growy\" );\n\n        actionPanel.add( controls, \"cell 0 0,grow\" );\n\n        cavePanel = drawCave();\n        actionPanel.add(cavePanel, \"cell 1 0,grow\" );\n\n        sensorPanel = drawSensorPanel();\n\n        frame.getContentPane().add(sensorPanel, \"cell 0 2,grow\");\n        \n        JPanel blank = new JPanel();\n        blank.setBackground(Color.WHITE);\n        frame.add(blank, \"cell 0 3,grow\");\n\n        frame.setVisible( true );\n\n        cavePanel.getBufferedImage();\n        sensorPanel.getBufferedImage();\n\n        repaint();\n\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public CavePanel drawCave() {\n        CavePanel cavelPanel = new CavePanel( this );\n        FlowLayout flowLayout = (FlowLayout) cavelPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        cavelPanel.setBackground( Color.WHITE );\n        return cavelPanel;\n    }","id":30896,"modified_method":"public GamePanel drawCave() {\n        GamePanel cavelPanel = new GamePanel(\"cave\", Color.WHITE );\n        FlowLayout flowLayout = (FlowLayout) cavelPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        cavelPanel.setBackground( Color.WHITE );\n        return cavelPanel;\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public GameUI(WumpusWorldConfiguration wumpusWorldConfiguration) {\n        this.wumpusWorldConfiguration = wumpusWorldConfiguration;\n    }","id":30897,"modified_method":"/**\n     * @wbp.parser.entryPoint\n     */\n    public GameUI(KieSession ksession, WumpusWorldConfiguration wumpusWorldConfiguration) {\n        this.wumpusWorldConfiguration = wumpusWorldConfiguration;\n        this.gameView = new GameView();\n        this.gameView.setKsession((StatefulKnowledgeSession) ksession);\n        this.gameView.init(50, 50, 3, 20, 5, 5);\n        initialize();\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void drawGame(Ball ball, Bat bat1, Bat bat2, Player p1, Player p2) {\n        clearMovingBall(ball);\n        clearBat(bat1);\n        clearBat(bat2);\n\n        drawScore( p1, 100 );\n        drawScore( p2, pconf.getTableWidth()-120 );\n        drawTable();\n\n        drawBall(ball);\n        drawBat(bat1);\n        drawBat(bat2);\n\n        show();\n    }","id":30898,"modified_method":"public void drawGame(Ball ball, Bat bat1, Bat bat2, Player p1, Player p2) {\n        clearMovingBall(ball);\n        clearBat(bat1);\n        clearBat(bat2);\n\n        drawScore( p1, 100 );\n        drawScore( p2, pconf.getTableWidth()-120 );\n        drawTable();\n\n        drawBall(ball);\n        drawBat(bat1);\n        drawBat(bat2);\n        repaint();\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void init(boolean exitOnClose) {\n        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();\n        System.out.println(kc.verify().getMessages().toString());\n        final KieSession serverKsession = kc.newKieSession( \"WumpusMainKS\");\n        final KieSession clientKsession = kc.newKieSession(\"WumpusClientKS\");\n\n        serverKsession.getChannels().put( \"sensors\", new Channel() {\n            public void send(Object object) {\n                clientKsession.insert( object );\n                clientKsession.fireAllRules();\n            }\n        } );\n\n        clientKsession.getChannels().put( \"commands\", new Channel() {\n            public void send(Object object) {\n                serverKsession.insert( object );\n                serverKsession.fireAllRules();\n            }\n        } );\n\n        WumpusWorldConfiguration wumpusWorldConfiguration = new WumpusWorldConfiguration();\n        wumpusWorldConfiguration.setExitOnClose(exitOnClose);\n        serverKsession.setGlobal(\"wumpusWorldConfiguration\", wumpusWorldConfiguration);\n        serverKsession.setGlobal(\"randomInteger\",new java.util.Random() );\n\n\n        new Thread(new Runnable() {\n            public void run() {\n                serverKsession.fireUntilHalt();\n            }\n        }).start();\n\n        new Thread(new Runnable() {\n            public void run() {\n                clientKsession.fireUntilHalt();\n            }\n        }).start();\n    }","id":30899,"modified_method":"public void init(boolean exitOnClose) {\n        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();\n        final KieSession serverKsession = kc.newKieSession( \"WumpusMainKS\");\n        final KieSession clientKsession = kc.newKieSession(\"WumpusClientKS\");\n\n        serverKsession.getChannels().put( \"sensors\", new Channel() {\n            public void send(Object object) {\n                clientKsession.insert( object );\n                clientKsession.fireAllRules();\n            }\n        } );\n\n        clientKsession.getChannels().put( \"commands\", new Channel() {\n            public void send(Object object) {\n                serverKsession.insert( object );\n                serverKsession.fireAllRules();\n            }\n        } );\n\n        WumpusWorldConfiguration wumpusWorldConfiguration = new WumpusWorldConfiguration();\n        wumpusWorldConfiguration.setExitOnClose(exitOnClose);\n        serverKsession.setGlobal(\"wumpusWorldConfiguration\", wumpusWorldConfiguration);\n        serverKsession.setGlobal(\"randomInteger\",new java.util.Random() );\n\n        GameUI gameUI = new GameUI(serverKsession, wumpusWorldConfiguration);\n        serverKsession.insert(gameUI  );\n        serverKsession.insert(gameUI.getGameView()  );\n\n\n        new Thread(new Runnable() {\n            public void run() {\n                serverKsession.fireUntilHalt();\n            }\n        }).start();\n\n        new Thread(new Runnable() {\n            public void run() {\n                clientKsession.fireUntilHalt();\n            }\n        }).start();\n    }","commit_id":"3dd405f9e3b4f5658c28e9f079c6e7fdeb98f2c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * builds the button row\n     *\n     * @return the panel with the button row\n     */\n    protected JPanel buildButtonRow() {\n        JPanel pnl = new JPanel();\n        pnl.setLayout(new FlowLayout(FlowLayout.CENTER));\n\n        saveAndProceedAction = new SaveAndProceedAction();\n        model.addPropertyChangeListener(saveAndProceedAction);\n        pnl.add(new SideButton(saveAndProceedAction));\n\n        discardAndProceedAction = new DiscardAndProceedAction();\n        model.addPropertyChangeListener(discardAndProceedAction);\n        pnl.add(new SideButton(discardAndProceedAction));\n\n        cancelAction = new CancelAction();\n        pnl.add(new SideButton(cancelAction));\n\n        JPanel pnl2 = new JPanel();\n        pnl2.setLayout(new BorderLayout());\n        pnl2.add(pnlUploadLayers = new UploadAndSaveProgressRenderer(), BorderLayout.CENTER);\n        model.addPropertyChangeListener(pnlUploadLayers);\n        pnl2.add(pnl, BorderLayout.SOUTH);\n        return pnl2;\n    }","id":30900,"modified_method":"/**\n     * builds the button row\n     *\n     * @return the panel with the button row\n     */\n    protected JPanel buildButtonRow() {\n        JPanel pnl = new JPanel();\n        pnl.setLayout(new FlowLayout(FlowLayout.CENTER));\n\n        saveAndProceedAction = new SaveAndProceedAction();\n        model.addPropertyChangeListener(saveAndProceedAction);\n        pnl.add(saveAndProceedActionButton = new SideButton(saveAndProceedAction));\n\n        discardAndProceedAction = new DiscardAndProceedAction();\n        model.addPropertyChangeListener(discardAndProceedAction);\n        pnl.add(new SideButton(discardAndProceedAction));\n\n        cancelAction = new CancelAction();\n        pnl.add(new SideButton(cancelAction));\n\n        JPanel pnl2 = new JPanel();\n        pnl2.setLayout(new BorderLayout());\n        pnl2.add(pnlUploadLayers = new UploadAndSaveProgressRenderer(), BorderLayout.CENTER);\n        model.addPropertyChangeListener(pnlUploadLayers);\n        pnl2.add(pnl, BorderLayout.SOUTH);\n        return pnl2;\n    }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void initForDiscardAndDelete() {\n            putValue(NAME, tr(\"Discard and Delete\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Delete layers without saving. Unsaved changes are lost.\"));\n            putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"delete\"));\n        }","id":30901,"modified_method":"public void initForDiscardAndDelete() {\n            putValue(NAME, tr(\"Delete now!\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Delete layers without saving. Unsaved changes are lost.\"));\n            putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"delete\"));\n        }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void initForSaveAndDelete() {\n            putValue(NAME, tr(\"Save/Upload and Delete\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Save/Upload layers before deleting. Unsaved changes are not lost.\"));\n            putValue(SMALL_ICON, ImageProvider.get(\"dialogs\", \"delete\"));\n        }","id":30902,"modified_method":"public void initForSaveAndDelete() {\n            putValue(NAME, tr(\"Perform actions before deleting\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Save/Upload layers before deleting. Unsaved changes are not lost.\"));\n            putValue(BASE_ICON, ImageProvider.get(\"dialogs\", \"delete\"));\n            redrawIcon();\n        }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void initForSaveAndExit() {\n            putValue(NAME, tr(\"Save/Upload and Exit\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Exit JOSM with saving. Unsaved changes are uploaded and/or saved.\"));\n            putValue(SMALL_ICON, ImageProvider.get(\"exit\"));\n        }","id":30903,"modified_method":"public void initForSaveAndExit() {\n            putValue(NAME, tr(\"Perform actions before exiting\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Exit JOSM with saving. Unsaved changes are uploaded and/or saved.\"));\n            putValue(BASE_ICON, ImageProvider.get(\"exit\"));\n            redrawIcon();\n        }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void initForDiscardAndExit() {\n            putValue(NAME, tr(\"Discard and Exit\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Exit JOSM without saving. Unsaved changes are lost.\"));\n            putValue(SMALL_ICON, ImageProvider.get(\"exit\"));\n        }","id":30904,"modified_method":"public void initForDiscardAndExit() {\n            putValue(NAME, tr(\"Exit now!\"));\n            putValue(SHORT_DESCRIPTION, tr(\"Exit JOSM without saving. Unsaved changes are lost.\"));\n            putValue(SMALL_ICON, ImageProvider.get(\"exit\"));\n        }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"public SaveAndProceedAction() {\n            initForSaveAndExit();\n        }","id":30905,"modified_method":"public SaveAndProceedAction() {\n            // get disabled versions of icons\n            new JLabel(ImageProvider.get(\"save\")).getDisabledIcon().paintIcon(new JPanel(), saveDis.getGraphics(), 0, 0);\n            new JLabel(ImageProvider.get(\"upload\")).getDisabledIcon().paintIcon(new JPanel(), upldDis.getGraphics(), 0, 0);\n            initForSaveAndExit();\n        }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * builds the GUI\n     */\n    protected void build() {\n        WindowGeometry geometry = WindowGeometry.centerOnScreen(new Dimension(600,300));\n        geometry.applySafe(this);\n        getContentPane().setLayout(new BorderLayout());\n\n        model = new SaveLayersModel();\n        SaveLayersTable table;\n        JScrollPane pane = new JScrollPane(table = new SaveLayersTable(model));\n        model.addPropertyChangeListener(table);\n        getContentPane().add(pane, BorderLayout.CENTER);\n        getContentPane().add(buildButtonRow(), BorderLayout.SOUTH);\n        table.getTableHeader().setPreferredSize(new Dimension(table.getTableHeader().getWidth(), 40));\n\n        addWindowListener(new WindowClosingAdapter());\n        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n    }","id":30906,"modified_method":"/**\n     * builds the GUI\n     */\n    protected void build() {\n        WindowGeometry geometry = WindowGeometry.centerOnScreen(new Dimension(600,300));\n        geometry.applySafe(this);\n        getContentPane().setLayout(new BorderLayout());\n\n        model = new SaveLayersModel();\n        SaveLayersTable table = new SaveLayersTable(model);\n        JScrollPane pane = new JScrollPane(table);\n        model.addPropertyChangeListener(table);\n        table.getModel().addTableModelListener(this);\n\n        getContentPane().add(pane, BorderLayout.CENTER);\n        getContentPane().add(buildButtonRow(), BorderLayout.SOUTH);\n\n        addWindowListener(new WindowClosingAdapter());\n        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n    }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public boolean isCellEditable(int row, int column) {\n        return column == 3 || column == 4 || column == 5;\n    }","id":30907,"modified_method":"@Override\n    public boolean isCellEditable(int row, int column) {\n        return column == columnFilename || column == columnActions;\n    }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void setValueAt(Object value, int row, int column) {\n        switch(column) {\n            case 3 /* file name */:\n                this.layerInfo.get(row).setFile((File)value);\n                this.layerInfo.get(row).setDoSaveToFile(true);\n                break;\n            case 4 /* upload */: this.layerInfo.get(row).setDoUploadToServer((Boolean)value);break;\n            case 5 /* save */: this.layerInfo.get(row).setDoSaveToFile((Boolean)value);break;\n        }\n        fireTableDataChanged();\n    }","id":30908,"modified_method":"@Override\n    public void setValueAt(Object value, int row, int column) {\n        switch(column) {\n        case columnFilename:\n            this.layerInfo.get(row).setFile((File)value);\n            this.layerInfo.get(row).setDoSaveToFile(true);\n            break;\n        case columnActions:\n            boolean[] values = (boolean[]) value;\n            this.layerInfo.get(row).setDoUploadToServer(values[0]);\n            this.layerInfo.get(row).setDoSaveToFile(values[1]);\n            break;\n        }\n        fireTableDataChanged();\n    }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"public SaveLayersTable(SaveLayersModel model) {\n        super(model, new SaveLayersTableColumnModel());\n        putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n    }","id":30909,"modified_method":"public SaveLayersTable(SaveLayersModel model) {\n        super(model, new SaveLayersTableColumnModel());\n        putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n        super.setRowHeight(39);\n        super.getTableHeader().setPreferredSize(new Dimension(super.getTableHeader().getWidth(), 24));\n        super.getTableHeader().setReorderingAllowed(false);\n    }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void build() {\n        TableColumn col = null;\n        TableCellRenderer renderer = new SaveLayerInfoCellRenderer();\n        TableCellEditor fileNameEditor = new FilenameCellEditor();\n        TableCellEditor saveFlagEditor = new SaveFlagCellEditor();\n\n        // column 0 - Layer\n        col = new TableColumn(0);\n        col.setHeaderValue(tr(\"Layer\"));\n        col.setResizable(true);\n        col.setCellRenderer(renderer);\n        col.setPreferredWidth(100);\n        addColumn(col);\n\n        // column 1 - Upload required\n        col = new TableColumn(1);\n        col.setHeaderValue(tr(\"Should upload?\"));\n        col.setResizable(true);\n        col.setCellRenderer(renderer);\n        col.setPreferredWidth(50);\n        addColumn(col);\n\n        // column 2 - Save to file required\n        col = new TableColumn(2);\n        col.setHeaderValue(tr(\"Should save?\"));\n        col.setResizable(true);\n        col.setCellRenderer(renderer);\n        col.setPreferredWidth(50);\n        addColumn(col);\n\n        // column 3 - filename\n        col = new TableColumn(3);\n        col.setHeaderValue(tr(\"Filename\"));\n        col.setResizable(true);\n        col.setCellRenderer(renderer);\n        col.setCellEditor(fileNameEditor);\n        col.setPreferredWidth(200);\n        addColumn(col);\n\n        // column 4 - Upload\n        col = new TableColumn(4);\n        col.setHeaderValue(tr(\"Upload\"));\n        col.setResizable(true);\n        col.setCellRenderer(renderer);\n        col.setCellEditor(saveFlagEditor);\n        col.setPreferredWidth(30);\n        addColumn(col);\n\n        // column 5 - Save\n        col = new TableColumn(5);\n        col.setHeaderValue(tr(\"Save\"));\n        col.setResizable(true);\n        col.setCellRenderer(renderer);\n        col.setCellEditor(saveFlagEditor);\n        col.setPreferredWidth(30);\n\n        addColumn(col);\n    }","id":30910,"modified_method":"protected void build() {\n        TableColumn col = null;\n\n        // column 0 - layer name, save path editor\n        LayerNameAndFilePathTableCell lnafptc = new LayerNameAndFilePathTableCell();\n        col = new TableColumn(0); // keep in sync with SaveLayersModel#columnFilename\n        col.setHeaderValue(tr(\"Layer Name and File Path\"));\n        col.setResizable(true);\n        col.setCellRenderer(lnafptc);\n        col.setCellEditor(lnafptc);\n        col.setPreferredWidth(324);\n        addColumn(col);\n\n        // column 1 - actions required\n        col = new TableColumn(1);\n        col.setHeaderValue(tr(\"Recommended Actions\"));\n        col.setResizable(true);\n        col.setCellRenderer(new RecommendedActionsTableCell());\n        col.setPreferredWidth(150);\n        addColumn(col);\n\n        // column 2- actions to take\n        ActionFlagsTableCell aftc = new ActionFlagsTableCell();\n        col = new TableColumn(2); // keep in sync with SaveLayersModel#columnActions\n        col.setHeaderValue(tr(\"Actions To Take\"));\n        col.setResizable(true);\n        col.setCellRenderer(aftc);\n        col.setCellEditor(aftc);\n        col.setPreferredWidth(100);\n\n        addColumn(col);\n    }","commit_id":"f91ef561dc6c9f54a5b9b5841b57ebd456493715","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void rename(String oldName, String newName)\n\t\tthrows SystemException {\n\n\t\tCounterRegister register = getCounterRegister(oldName);\n\n\t\tsynchronized (register) {\n\t\t\tif (_registerLookup.containsKey(newName)) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"Cannot rename \" + oldName + \" to \" + newName);\n\t\t\t}\n\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\tsession = new SessionImpl(\n\t\t\t\t\t_sessionFactory.openSession(connection));\n\n\t\t\t\tCounter counter = (Counter)session.load(Counter.class, oldName);\n\n\t\t\t\tlong currentId = counter.getCurrentId();\n\n\t\t\t\tsession.delete(counter);\n\n\t\t\t\tcounter = new Counter();\n\n\t\t\t\tcounter.setName(newName);\n\t\t\t\tcounter.setCurrentId(currentId);\n\n\t\t\t\tsession.save(counter);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsession.close();\n\t\t\t}\n\n\t\t\tregister.setName(newName);\n\n\t\t\t_registerLookup.put(newName, register);\n\t\t\t_registerLookup.remove(oldName);\n\t\t}\n\t}","id":30911,"modified_method":"public void rename(String oldName, String newName)\n\t\tthrows SystemException {\n\n\t\tCounterRegister register = getCounterRegister(oldName);\n\n\t\tsynchronized (register) {\n\t\t\tif (_registerLookup.containsKey(newName)) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"Cannot rename \" + oldName + \" to \" + newName);\n\t\t\t}\n\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\t\tCounter counter = (Counter)session.load(Counter.class, oldName);\n\n\t\t\t\tlong currentId = counter.getCurrentId();\n\n\t\t\t\tsession.delete(counter);\n\n\t\t\t\tcounter = new Counter();\n\n\t\t\t\tcounter.setName(newName);\n\t\t\t\tcounter.setCurrentId(currentId);\n\n\t\t\t\tsession.save(counter);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsession.close();\n\t\t\t}\n\n\t\t\tregister.setName(newName);\n\n\t\t\t_registerLookup.put(newName, register);\n\t\t\t_registerLookup.remove(oldName);\n\t\t}\n\t}","commit_id":"fc322d5302b5ee09cdcda1f212b096cc886a6a08","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected synchronized CounterRegister createCounterRegister(\n\t\t\tString name, long size)\n\t\tthrows SystemException {\n\n\t\tlong rangeMin = 0;\n\t\tlong rangeMax = 0;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tConnection connection = getConnection();\n\n\t\t\tsession = new SessionImpl(\n\t\t\t\t_sessionFactory.openSession(connection));\n\n\t\t\tCounter counter = (Counter)session.get(\n\t\t\t\tCounter.class, name, LockMode.UPGRADE);\n\n\t\t\tif (counter == null) {\n\t\t\t\trangeMin = _DEFAULT_CURRENT_ID;\n\n\t\t\t\tcounter = new Counter();\n\n\t\t\t\tcounter.setName(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trangeMin = counter.getCurrentId();\n\t\t\t}\n\n\t\t\tif (size >= _DEFAULT_CURRENT_ID) {\n\t\t\t\trangeMin = size;\n\t\t\t}\n\n\t\t\trangeMax = rangeMin + _COUNTER_INCREMENT;\n\n\t\t\tcounter.setCurrentId(rangeMax);\n\n\t\t\tsession.save(counter);\n\t\t\tsession.flush();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\n\t\tCounterRegister register = new CounterRegister(\n\t\t\tname, rangeMin, rangeMax, _COUNTER_INCREMENT);\n\n\t\treturn register;\n\t}","id":30912,"modified_method":"protected synchronized CounterRegister createCounterRegister(\n\t\t\tString name, long size)\n\t\tthrows SystemException {\n\n\t\tlong rangeMin = 0;\n\t\tlong rangeMax = 0;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tConnection connection = getConnection();\n\n\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\tCounter counter = (Counter)session.get(\n\t\t\t\tCounter.class, name, LockMode.UPGRADE);\n\n\t\t\tif (counter == null) {\n\t\t\t\trangeMin = _DEFAULT_CURRENT_ID;\n\n\t\t\t\tcounter = new Counter();\n\n\t\t\t\tcounter.setName(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trangeMin = counter.getCurrentId();\n\t\t\t}\n\n\t\t\tif (size >= _DEFAULT_CURRENT_ID) {\n\t\t\t\trangeMin = size;\n\t\t\t}\n\n\t\t\trangeMax = rangeMin + _COUNTER_INCREMENT;\n\n\t\t\tcounter.setCurrentId(rangeMax);\n\n\t\t\tsession.save(counter);\n\t\t\tsession.flush();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\n\t\tCounterRegister register = new CounterRegister(\n\t\t\tname, rangeMin, rangeMax, _COUNTER_INCREMENT);\n\n\t\treturn register;\n\t}","commit_id":"fc322d5302b5ee09cdcda1f212b096cc886a6a08","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public long increment(String name, int size)\n\t\tthrows SystemException {\n\n\t\tif (size < _MINIMUM_INCREMENT_SIZE) {\n\t\t\tsize = _MINIMUM_INCREMENT_SIZE;\n\t\t}\n\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\tsynchronized (register) {\n\t\t\tlong newValue = register.getCurrentValue() + size;\n\n\t\t\tif (newValue > register.getRangeMax()) {\n\t\t\t\tSession session = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\t\tsession = new SessionImpl(\n\t\t\t\t\t\t_sessionFactory.openSession(connection));\n\n\t\t\t\t\tCounter counter = (Counter)session.get(\n\t\t\t\t\t\tCounter.class, register.getName());\n\n\t\t\t\t\tnewValue = counter.getCurrentId() + 1;\n\n\t\t\t\t\tlong rangeMax =\n\t\t\t\t\t\tcounter.getCurrentId() + register.getRangeSize();\n\n\t\t\t\t\tcounter.setCurrentId(rangeMax);\n\n\t\t\t\t\tsession.save(counter);\n\t\t\t\t\tsession.flush();\n\n\t\t\t\t\tregister.setCurrentValue(newValue);\n\t\t\t\t\tregister.setRangeMax(rangeMax);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow processException(e);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tregister.setCurrentValue(newValue);\n\t\t\t}\n\n\t\t\treturn newValue;\n\t\t}\n\t}","id":30913,"modified_method":"public long increment(String name, int size)\n\t\tthrows SystemException {\n\n\t\tif (size < _MINIMUM_INCREMENT_SIZE) {\n\t\t\tsize = _MINIMUM_INCREMENT_SIZE;\n\t\t}\n\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\tsynchronized (register) {\n\t\t\tlong newValue = register.getCurrentValue() + size;\n\n\t\t\tif (newValue > register.getRangeMax()) {\n\t\t\t\tSession session = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\t\t\tCounter counter = (Counter)session.get(\n\t\t\t\t\t\tCounter.class, register.getName());\n\n\t\t\t\t\tnewValue = counter.getCurrentId() + 1;\n\n\t\t\t\t\tlong rangeMax =\n\t\t\t\t\t\tcounter.getCurrentId() + register.getRangeSize();\n\n\t\t\t\t\tcounter.setCurrentId(rangeMax);\n\n\t\t\t\t\tsession.save(counter);\n\t\t\t\t\tsession.flush();\n\n\t\t\t\t\tregister.setCurrentValue(newValue);\n\t\t\t\t\tregister.setRangeMax(rangeMax);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow processException(e);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tregister.setCurrentValue(newValue);\n\t\t\t}\n\n\t\t\treturn newValue;\n\t\t}\n\t}","commit_id":"fc322d5302b5ee09cdcda1f212b096cc886a6a08","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getNames() throws SystemException {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tConnection connection = getConnection();\n\n\t\t\tsession = new SessionImpl(_sessionFactory.openSession(connection));\n\n\t\t\tList<String> list = new ArrayList<String>();\n\n\t\t\tQuery q = session.createQuery(\"FROM \" + Counter.class.getName());\n\n\t\t\tIterator<Counter> itr = q.iterate();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCounter counter = itr.next();\n\n\t\t\t\tlist.add(counter.getName());\n\t\t\t}\n\n\t\t\treturn ListUtil.sort(list);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\t}","id":30914,"modified_method":"public List<String> getNames() throws SystemException {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tConnection connection = getConnection();\n\n\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\tList<String> list = new ArrayList<String>();\n\n\t\t\tQuery q = session.createQuery(\n\t\t\t\t\"SELECT counter FROM Counter counter\");\n\n\t\t\tIterator<Counter> itr = q.iterate();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCounter counter = itr.next();\n\n\t\t\t\tlist.add(counter.getName());\n\t\t\t}\n\n\t\t\treturn ListUtil.sort(list);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\t}","commit_id":"fc322d5302b5ee09cdcda1f212b096cc886a6a08","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void reset(String name) throws SystemException {\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\tsynchronized (register) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\tsession = new SessionImpl(\n\t\t\t\t\t_sessionFactory.openSession(connection));\n\n\t\t\t\tCounter counter = (Counter)session.load(Counter.class, name);\n\n\t\t\t\tsession.delete(counter);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsession.close();\n\t\t\t}\n\n\t\t\t_registerLookup.remove(name);\n\t\t}\n\t}","id":30915,"modified_method":"public void reset(String name) throws SystemException {\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\tsynchronized (register) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\t\tCounter counter = (Counter)session.load(Counter.class, name);\n\n\t\t\t\tsession.delete(counter);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsession.close();\n\t\t\t}\n\n\t\t\t_registerLookup.remove(name);\n\t\t}\n\t}","commit_id":"fc322d5302b5ee09cdcda1f212b096cc886a6a08","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void start(PipelineContext context) {\n        final State state = (State) getState(context);\n        if (state.started)\n            throw new IllegalStateException(\"ASTChoose Processor already started\");\n\n        // Choose which branch we want to run (we cache the decision)\n        DocumentInfo hrefDocumentInfo = null;\n        int branchIndex = 0;\n        int selectedBranch = -1;\n        for (Iterator i = branchConditions.iterator(); i.hasNext();) {\n            // Evaluate expression\n            final String condition = (String) i.next();\n            if (condition == null) {\n                selectedBranch = branchIndex;\n                break;\n            }\n            // Try to cache the XPath expressions\n//            String xpathExpression = \"boolean(\" + condition + \")\";\n//            XPath xpath = XPathCache.createCacheXPath(context, xpathExpression);\n//\n//            xpath.setFunctionContext(new OXFFunctionContext());\n//            xpath.setNamespaceContext((NamespaceContext) branchNamespaces.get(branchIndex));\n//            if (((Boolean) xpath.evaluate(refNode)).booleanValue()) {\n//                selectedBranch = branchIndex;\n//                break;\n//            }\n            // Lazily read input in case there is only a p:otherwise\n            if (hrefDocumentInfo == null)\n                hrefDocumentInfo = readCacheInputAsTinyTree(context, AbstractChooseProcessor.CHOOSE_DATA_INPUT);\n            PooledXPathExpression expr = null;\n            final Map namespaces = (Map) branchNamespaces.get(branchIndex);\n            try {\n                expr = XPathCache.getXPathExpression(context, hrefDocumentInfo, \"boolean(\" + condition + \")\", namespaces);\n                if( ((Boolean)expr.evaluateSingle()).booleanValue()) {\n                    selectedBranch = branchIndex;\n                    break;\n                }\n                branchIndex++;\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally{\n                try {\n                    if(expr != null)\n                        expr.returnToPool();\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n\n        }\n\n        if (selectedBranch == -1) {\n            // No branch was selected: this is not acceptable if there are output to the choose\n            if (!outputsById.isEmpty() || !outputsByParamRef.isEmpty())\n                throw new ValidationException(\"Condition failed for every branch of choose: \"\n                        + branchConditions.toString(), locationData);\n        } else {\n\n            // Initialize variables depending on selected branch\n            Processor selectedBranchProcessor = (Processor) branchProcessors.get(selectedBranch);\n            Map selectedBranchInputs = (Map) branchInputs.get(selectedBranch);\n            state.selectedBranchOutputs = (Map) branchOutputs.get(selectedBranch);\n\n            // Connect branch inputs\n            for (Iterator i = selectedBranchInputs.keySet().iterator(); i.hasNext();) {\n                String branchInputName = (String) i.next();\n                ProcessorInput branchInput = (ProcessorInput) selectedBranchInputs.get(branchInputName);\n                ProcessorInput chooseInput = getInputByName(branchInputName);\n                branchInput.setOutput(chooseInput.getOutput());\n            }\n\n            // Connect branch outputs, or start processor\n            selectedBranchProcessor.reset(context);\n            if (outputsById.size() == 0 && outputsByParamRef.size() == 0) {\n                selectedBranchProcessor.start(context);\n            }\n            state.started = true;\n        }\n    }","id":30916,"modified_method":"public void start(PipelineContext context) {\n        final State state = (State) getState(context);\n        if (state.started)\n            throw new IllegalStateException(\"ASTChoose Processor already started\");\n\n        // Choose which branch we want to run (we cache the decision)\n        DocumentInfo hrefDocumentInfo = null;\n        int branchIndex = 0;\n        int selectedBranch = -1;\n        for (Iterator i = branchConditions.iterator(); i.hasNext();) {\n            // Evaluate expression\n            final String condition = (String) i.next();\n            if (condition == null) {\n                selectedBranch = branchIndex;\n                break;\n            }\n            // Try to cache the XPath expressions\n//            String xpathExpression = \"boolean(\" + condition + \")\";\n//            XPath xpath = XPathCache.createCacheXPath(context, xpathExpression);\n//\n//            xpath.setFunctionContext(new OXFFunctionContext());\n//            xpath.setNamespaceContext((NamespaceContext) branchNamespaces.get(branchIndex));\n//            if (((Boolean) xpath.evaluate(refNode)).booleanValue()) {\n//                selectedBranch = branchIndex;\n//                break;\n//            }\n            // Lazily read input in case there is only a p:otherwise\n            if (hrefDocumentInfo == null)\n                hrefDocumentInfo = readCacheInputAsTinyTree(context, AbstractChooseProcessor.CHOOSE_DATA_INPUT);\n            PooledXPathExpression expr = null;\n            final Map namespaces = (Map) branchNamespaces.get(branchIndex);\n            try {\n                expr = XPathCache.getXPathExpression(context, hrefDocumentInfo, \"boolean(\" + condition + \")\", namespaces, getLocationData());\n                if( ((Boolean)expr.evaluateSingle()).booleanValue()) {\n                    selectedBranch = branchIndex;\n                    break;\n                }\n                branchIndex++;\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally{\n                try {\n                    if(expr != null)\n                        expr.returnToPool();\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n\n        }\n\n        if (selectedBranch == -1) {\n            // No branch was selected: this is not acceptable if there are output to the choose\n            if (!outputsById.isEmpty() || !outputsByParamRef.isEmpty())\n                throw new ValidationException(\"Condition failed for every branch of choose: \"\n                        + branchConditions.toString(), locationData);\n        } else {\n\n            // Initialize variables depending on selected branch\n            Processor selectedBranchProcessor = (Processor) branchProcessors.get(selectedBranch);\n            Map selectedBranchInputs = (Map) branchInputs.get(selectedBranch);\n            state.selectedBranchOutputs = (Map) branchOutputs.get(selectedBranch);\n\n            // Connect branch inputs\n            for (Iterator i = selectedBranchInputs.keySet().iterator(); i.hasNext();) {\n                String branchInputName = (String) i.next();\n                ProcessorInput branchInput = (ProcessorInput) selectedBranchInputs.get(branchInputName);\n                ProcessorInput chooseInput = getInputByName(branchInputName);\n                branchInput.setOutput(chooseInput.getOutput());\n            }\n\n            // Connect branch outputs, or start processor\n            selectedBranchProcessor.reset(context);\n            if (outputsById.size() == 0 && outputsByParamRef.size() == 0) {\n                selectedBranchProcessor.start(context);\n            }\n            state.started = true;\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(final org.orbeon.oxf.pipeline.api.PipelineContext context, final ContentHandler contentHandler) {\n                final java.util.List services = readServices(readInputAsDOM4J(context, INPUT_INTERFACE));\n\n                readInputAsSAX(context, INPUT_CALL, new ForwardingContentHandler(contentHandler) {\n\n                    Locator locator;\n                    String operationName;\n                    Integer operationTimeout;\n                    ServiceDefinition service;\n                    OperationDefinition operation;\n                    SAXStore parameters;\n\n                    public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n                        if (uri.equals(DELEGATION_NAMESPACE_URI) && localname.equals(\"execute\")) {\n\n                            // Find service\n                            service = null;\n                            String serviceId = attributes.getValue(\"service\");\n                            for ( java.util.Iterator i = services.iterator(); i.hasNext();) {\n                                ServiceDefinition candidateService = (ServiceDefinition) i.next();\n                                if (candidateService.id.equals(serviceId)) {\n                                    service = candidateService;\n                                    break;\n                                }\n                            }\n                            if (service == null)\n                                throw new OXFException(\"Cannot find service with id \\\"\" + serviceId + \"\\\"\");\n\n                            operation = null;\n                            operationName = attributes.getValue(\"operation\");\n\n                            // Find operation for Web service\n                            if (service.type == ServiceDefinition.WEB_SERVICE_TYPE && operationName != null) {\n                                for (java.util.Iterator i = service.operations.iterator(); i.hasNext();) {\n                                    OperationDefinition candidateOperation = (OperationDefinition) i.next();\n                                    if (candidateOperation.name.equals(operationName)) {\n                                        operation = candidateOperation;\n                                        break;\n                                    }\n                                }\n                                if (operation == null)\n                                    throw new ValidationException(\"No operation '\" + operationName + \"' declared\", new LocationData(locator));\n                            }\n\n                            // Get timeout if any\n                            {\n                                final String timeoutAttribute = attributes.getValue(\"timeout\");\n                                if (timeoutAttribute != null) {\n                                    try {\n                                        operationTimeout = new Integer(timeoutAttribute);\n                                    } catch (NumberFormatException e) {\n                                        throw new ValidationException(\"Invalid timeout specified: \" + timeoutAttribute, new LocationData(locator));\n                                    }\n                                    if (operationTimeout.intValue() < 0)\n                                        throw new ValidationException(\"Invalid timeout specified: \" + operationTimeout, new LocationData(locator));\n                                }\n                            }\n\n                            parameters = new SAXStore();\n\n                        } else {\n                            // Store values if we are inside a <delegation:execute>\n                            if (parameters == null) {\n                                super.startElement(uri, localname, qName, attributes);\n                            } else {\n                                parameters.startElement(uri, localname, qName, attributes);\n                            }\n                        }\n                    }\n\n                    public void endElement(String uri, String localname, String qName) {\n                        try {\n                            if (uri.equals(DELEGATION_NAMESPACE_URI)) {\n                                if (localname.equals(\"execute\")) {\n\n                                    if (service.type == ServiceDefinition.WEB_SERVICE_TYPE\n                                            || service.type == ServiceDefinition.BUS_SERVICE_TYPE) {\n\n                                        // Call Web service\n                                        Service axisService = new Service();\n                                        Call call = (Call) axisService.createCall();\n                                        if (operationTimeout != null)\n                                            call.setTimeout(operationTimeout);\n\n                                        // Read all parameters in root node\n                                        final Node rootNode;\n                                        {\n                                            // Read in DOM4j content handler\n                                            final NonLazySAXContentHandler dom4jContentHandler \n                                                = new NonLazySAXContentHandler();\n                                            dom4jContentHandler.startDocument();\n                                            dom4jContentHandler.startElement(\"\", \"dummy\", \"dummy\", XMLUtils.EMPTY_ATTRIBUTES);\n                                            parameters.replay(dom4jContentHandler);\n                                            dom4jContentHandler.endElement(\"\", \"dummy\", \"dummy\");\n                                            dom4jContentHandler.endDocument();\n\n                                            // Convert to DOM\n                                            rootNode = new DOMWriter().write\n                                                    (dom4jContentHandler.getDocument()).getDocumentElement();\n                                        }\n\n                                        // Populate envelope\n                                        SOAPEnvelope requestEnvelope =\n                                                service.soapVersion != null && service.soapVersion.equals(\"1.2\")\n                                                ? new SOAPEnvelope(SOAPConstants.SOAP12_CONSTANTS)\n                                                : new SOAPEnvelope();\n                                        if (service.type == ServiceDefinition.BUS_SERVICE_TYPE || \"document\".equals(service.style)) {\n                                            // Add elements to directly to body\n                                            for (int i = 0; i < rootNode.getChildNodes().getLength(); i++) {\n                                                Node child = rootNode.getChildNodes().item(i);\n                                                if (child instanceof org.w3c.dom.Element)\n                                                    requestEnvelope.addBodyElement(new SOAPBodyElement((org.w3c.dom.Element) child));\n                                            }\n                                        } else {\n                                            // Create body element with operation name, and add elements as children\n                                            final SOAPBodyElement requestBody = new SOAPBodyElement(new PrefixedQName(operation.nsuri, operation.name, \"m\"));\n                                            for (int i = 0; i < rootNode.getChildNodes().getLength(); i++) {\n                                                Node child = rootNode.getChildNodes().item(i);\n                                                if (child instanceof org.w3c.dom.Element) {\n                                                    requestBody.addChild(new MessageElement((org.w3c.dom.Element) child));\n                                                } else if (child instanceof org.w3c.dom.Text) {\n                                                    requestBody.addTextNode(((org.w3c.dom.Text) child).toString());\n                                                } else {\n                                                    throw new OXFException(\"Unsupported node type: \" + child.getClass().getName());\n                                                }\n                                            }\n                                            requestEnvelope.addBodyElement(requestBody);\n                                        }\n\n                                        // Call service\n                                        SOAPEnvelope resultEnvelope = null;\n                                        if (service.type == ServiceDefinition.WEB_SERVICE_TYPE) {\n                                            // Call Web service\n                                            parameters = null;\n                                            call.setTargetEndpointAddress(new URL(service.endpoint));\n                                            if (operation != null && operation.soapAction != null) {\n                                                call.setUseSOAPAction(true);\n                                                call.setSOAPActionURI(operation.soapAction);\n                                            }\n                                            call.setReturnClass(javax.xml.soap.SOAPMessage.class);\n                                            resultEnvelope = call.invoke(requestEnvelope);\n                                        } else {\n                                            // Call bus service\n                                            javax.jms.QueueConnection requestQueueConnection = null;\n                                            javax.jms.QueueSession requestQueueSession = null;\n                                            javax.jms.QueueSender queueSender = null;\n                                            try {\n                                                requestQueueConnection = JMSUtils.getQueueConnection();\n                                                requestQueueSession = requestQueueConnection.createQueueSession(false, javax.jms.Session.AUTO_ACKNOWLEDGE);\n                                                queueSender = requestQueueSession.createSender\n                                                        ((javax.jms.Queue) new InitialContext().lookup(JMSUtils.JNDI_SERVICE_PREFIX + service.name));\n                                                javax.jms.ObjectMessage responseMessage = requestQueueSession.createObjectMessage();\n                                                responseMessage.setObject(requestEnvelope);\n\n                                                // Send message\n                                                if (ServiceDirectory.instance().getServiceByName(service.name).hasOutputs()) {\n                                                    // Response expected\n                                                    javax.jms.QueueConnection responseQueueConnection = null;\n                                                    javax.jms.QueueSession responseQueueSession = null;\n                                                    javax.jms.QueueReceiver queueReceiver = null;\n                                                    try {\n                                                        responseQueueConnection = JMSUtils.getQueueConnection();\n                                                        responseQueueSession = responseQueueConnection.createQueueSession(false, javax.jms.Session.AUTO_ACKNOWLEDGE);\n                                                        javax.jms.Queue temporaryQueue = responseQueueSession.createTemporaryQueue();\n                                                        queueReceiver = responseQueueSession.createReceiver(temporaryQueue);\n                                                        responseMessage.setJMSReplyTo(temporaryQueue);\n                                                        responseQueueConnection.start();\n                                                        queueSender.send(responseMessage);\n                                                        javax.jms.Message message = queueReceiver.receive();\n                                                        resultEnvelope = (SOAPEnvelope) ((javax.jms.ObjectMessage) message).getObject();\n                                                    } finally{\n                                                        if (queueReceiver != null) queueReceiver.close();\n                                                        if (responseQueueSession != null) responseQueueSession.close();\n                                                        if (responseQueueConnection != null) responseQueueConnection.close();\n                                                    }\n\n                                                } else {\n                                                    // No response expected\n                                                    queueSender.send(responseMessage);\n                                                }\n                                            } finally {\n                                                if (queueSender != null) queueSender.close();\n                                                if (requestQueueSession != null) requestQueueSession.close();\n                                                if (requestQueueConnection != null) requestQueueConnection.close();\n                                            }\n\n                                        }\n\n                                        // Handle result\n                                        if (resultEnvelope != null) {\n\n                                            // Throw exception if a fault is returned and the user does not want the fault to be returned\n                                            if (resultEnvelope.getBody().getFault() != null && !service.returnFault) {\n                                                throw new OXFException(\"SOAP Fault. Request:\\n\"\n                                                        + XMLUtils.domToString(requestEnvelope.getAsDocument())\n                                                        + \"\\n\\nResponse:\\n\"\n                                                        + XMLUtils.domToString(resultEnvelope.getAsDocument()));\n                                            }\n\n                                            // Send body from result envelope\n                                            LocationSAXWriter locationSAXWriter = new LocationSAXWriter();\n                                            locationSAXWriter.setContentHandler(contentHandler);\n                                            final NonLazyUserDataDocumentFactory fctry = NonLazyUserDataDocumentFactory.getInstance(null);\n                                            Document resultEnvelopeDOM4j = new DOMReader(fctry).read(resultEnvelope.getAsDocument());\n\n                                            String xpath =\n                                                    operation != null && operation.select != null\n                                                    ? operation.select\n                                                    : service.type == ServiceDefinition.WEB_SERVICE_TYPE\n                                                    ? (\"document\".equals(service.style) ? DEFAULT_SELECT_WEB_SERVICE_DOCUMENT : DEFAULT_SELECT_WEB_SERVICE_RPC)\n                                                    : DEFAULT_SELECT_BUS;\n                                            PooledXPathExpression expr = XPathCache.getXPathExpression(context,\n                                                    new DocumentWrapper(resultEnvelopeDOM4j, null, new Configuration()),\n                                                    xpath,\n                                                    operation != null && operation.select != null\n                                                            ? operation.selectNamespaceContext : null);\n                                            for (java.util.Iterator i = expr.evaluate().iterator(); i.hasNext();) {\n\n                                                // Create document with node from SOAP envelope\n                                                Object result = i.next();\n                                                if (result instanceof Element) {\n                                                    locationSAXWriter.write((Element) result);\n                                                } else if (result instanceof Document) {\n                                                    locationSAXWriter.write(((Document) result).getRootElement());\n                                                } else if (result instanceof Text) {\n                                                    locationSAXWriter.write((Text) result);\n                                                } else {\n                                                    throw new OXFException(\"Unsupported result from select expression: '\" + result.getClass() + \"'\");\n                                                }\n                                            }\n                                        }\n\n                                    } else if (service.type == ServiceDefinition.STATELESS_EJB_TYPE\n                                            || service.type == ServiceDefinition.JAVABEAN_TYPE) {\n\n                                        // Create SAXStore with \"real\" document\n                                        SAXStore parametersWellFormed = new SAXStore();\n                                        parametersWellFormed.startDocument();\n                                        parametersWellFormed.startElement(\"\", \"parameters\", \"parameters\", XMLUtils.EMPTY_ATTRIBUTES);\n                                        parameters.replay(parametersWellFormed);\n                                        parametersWellFormed.endElement(\"\", \"parameters\", \"parameters\");\n                                        parametersWellFormed.endDocument();\n                                        parameters = null;\n\n                                        // Put parameters in DOM\n                                        SAXStoreGenerator saxGenerator = new SAXStoreGenerator(parametersWellFormed);\n                                        DOMSerializer domSerializer = new DOMSerializer();\n                                        PipelineUtils.connect(saxGenerator, \"data\", domSerializer, \"data\");\n                                        final Document parametersDocument;\n                                        {\n                                            final PipelineContext tempContext = new PipelineContext();\n                                            domSerializer.start(tempContext);\n                                            parametersDocument = domSerializer.getDocument(tempContext);\n                                        }\n                                        // Get parameter values and types\n                                        java.util.List parameterTypes = new java.util.ArrayList();\n                                        java.util.List parameterValues = new java.util.ArrayList();\n\n                                        // Go throught elements\n                                        for (java.util.Iterator i = parametersDocument.selectNodes(\"/parameters/*\").iterator(); i.hasNext();) {\n                                            org.dom4j.Element parameterElement = (org.dom4j.Element) i.next();\n                                            String parameterValue = parameterElement.getText();\n                                            String type = parameterElement.attributeValue(xsiType);\n                                            if (type == null || \"xsd:string\".equals(type)) {\n                                                parameterTypes.add(String.class);\n                                                parameterValues.add(parameterValue);\n                                            } else if (\"xsd:double\".equals(type)) {\n                                                parameterTypes.add(Double.TYPE);\n                                                parameterValues.add(new Double(parameterValue));\n                                            }\n                                        }\n\n                                        if (service.type == ServiceDefinition.STATELESS_EJB_TYPE) {\n                                            // Call EJB method\n                                            final Context jndiContext = (Context) context.getAttribute(PipelineContext.JNDI_CONTEXT);\n                                            if (jndiContext == null)\n                                                throw new ValidationException(\"JNDI context not found in pipeline context.\", new LocationData(locator));\n                                            final Object home = jndiContext.lookup(service.jndiName);\n                                            if (home == null)\n                                                throw new ValidationException(\"Home interface not found in JNDI context: \" + service.jndiName, new LocationData(locator));\n                                            final Method create = home.getClass().getDeclaredMethod(\"create\", new Class[]{});\n                                            final Object instance = create.invoke(home, new Object[]{});\n                                            final String result = callMethod(instance.getClass(), operationName, parameterTypes, instance, parameterValues);\n                                            super.characters(result.toCharArray(), 0, result.length());\n                                        } else if (service.type == ServiceDefinition.JAVABEAN_TYPE) {\n                                            // Call JavaBean method\n                                            Class clazz = Class.forName(service.clazz);\n                                            Object instance = clazz.newInstance();\n                                            String result = callMethod(clazz, operationName, parameterTypes,\n                                                    instance, parameterValues);\n                                            super.characters(result.toCharArray(), 0, result.length());\n                                        }\n                                    }\n                                }\n                            } else {\n                                // Store values if we are inside a <delegation:execute>\n                                if (parameters == null) {\n                                    super.endElement(uri, localname, qName);\n                                } else {\n                                    parameters.endElement(uri, localname, qName);\n                                }\n                            }\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    public void characters(char[] chars, int start, int length) throws SAXException {\n                        // Store values if we are inside a <delegation:execute>\n                        if (parameters == null) {\n                            super.characters(chars, start, length);\n                        } else {\n                            parameters.characters(chars, start, length);\n                        }\n                    }\n\n                    public void setDocumentLocator(Locator locator) {\n                        this.locator = locator;\n                    }\n                });\n            };\n        };\n        addOutput(name, output);\n        return output;\n    }","id":30917,"modified_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(final org.orbeon.oxf.pipeline.api.PipelineContext context, final ContentHandler contentHandler) {\n                final java.util.List services = readServices(readInputAsDOM4J(context, INPUT_INTERFACE));\n\n                readInputAsSAX(context, INPUT_CALL, new ForwardingContentHandler(contentHandler) {\n\n                    Locator locator;\n                    String operationName;\n                    Integer operationTimeout;\n                    ServiceDefinition service;\n                    OperationDefinition operation;\n                    SAXStore parameters;\n\n                    public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n                        if (uri.equals(DELEGATION_NAMESPACE_URI) && localname.equals(\"execute\")) {\n\n                            // Find service\n                            service = null;\n                            String serviceId = attributes.getValue(\"service\");\n                            for ( java.util.Iterator i = services.iterator(); i.hasNext();) {\n                                ServiceDefinition candidateService = (ServiceDefinition) i.next();\n                                if (candidateService.id.equals(serviceId)) {\n                                    service = candidateService;\n                                    break;\n                                }\n                            }\n                            if (service == null)\n                                throw new OXFException(\"Cannot find service with id \\\"\" + serviceId + \"\\\"\");\n\n                            operation = null;\n                            operationName = attributes.getValue(\"operation\");\n\n                            // Find operation for Web service\n                            if (service.type == ServiceDefinition.WEB_SERVICE_TYPE && operationName != null) {\n                                for (java.util.Iterator i = service.operations.iterator(); i.hasNext();) {\n                                    OperationDefinition candidateOperation = (OperationDefinition) i.next();\n                                    if (candidateOperation.name.equals(operationName)) {\n                                        operation = candidateOperation;\n                                        break;\n                                    }\n                                }\n                                if (operation == null)\n                                    throw new ValidationException(\"No operation '\" + operationName + \"' declared\", new LocationData(locator));\n                            }\n\n                            // Get timeout if any\n                            {\n                                final String timeoutAttribute = attributes.getValue(\"timeout\");\n                                if (timeoutAttribute != null) {\n                                    try {\n                                        operationTimeout = new Integer(timeoutAttribute);\n                                    } catch (NumberFormatException e) {\n                                        throw new ValidationException(\"Invalid timeout specified: \" + timeoutAttribute, new LocationData(locator));\n                                    }\n                                    if (operationTimeout.intValue() < 0)\n                                        throw new ValidationException(\"Invalid timeout specified: \" + operationTimeout, new LocationData(locator));\n                                }\n                            }\n\n                            parameters = new SAXStore();\n\n                        } else {\n                            // Store values if we are inside a <delegation:execute>\n                            if (parameters == null) {\n                                super.startElement(uri, localname, qName, attributes);\n                            } else {\n                                parameters.startElement(uri, localname, qName, attributes);\n                            }\n                        }\n                    }\n\n                    public void endElement(String uri, String localname, String qName) {\n                        try {\n                            if (uri.equals(DELEGATION_NAMESPACE_URI)) {\n                                if (localname.equals(\"execute\")) {\n\n                                    if (service.type == ServiceDefinition.WEB_SERVICE_TYPE\n                                            || service.type == ServiceDefinition.BUS_SERVICE_TYPE) {\n\n                                        // Call Web service\n                                        Service axisService = new Service();\n                                        Call call = (Call) axisService.createCall();\n                                        if (operationTimeout != null)\n                                            call.setTimeout(operationTimeout);\n\n                                        // Read all parameters in root node\n                                        final Node rootNode;\n                                        {\n                                            // Read in DOM4j content handler\n                                            final NonLazySAXContentHandler dom4jContentHandler \n                                                = new NonLazySAXContentHandler();\n                                            dom4jContentHandler.startDocument();\n                                            dom4jContentHandler.startElement(\"\", \"dummy\", \"dummy\", XMLUtils.EMPTY_ATTRIBUTES);\n                                            parameters.replay(dom4jContentHandler);\n                                            dom4jContentHandler.endElement(\"\", \"dummy\", \"dummy\");\n                                            dom4jContentHandler.endDocument();\n\n                                            // Convert to DOM\n                                            rootNode = new DOMWriter().write\n                                                    (dom4jContentHandler.getDocument()).getDocumentElement();\n                                        }\n\n                                        // Populate envelope\n                                        SOAPEnvelope requestEnvelope =\n                                                service.soapVersion != null && service.soapVersion.equals(\"1.2\")\n                                                ? new SOAPEnvelope(SOAPConstants.SOAP12_CONSTANTS)\n                                                : new SOAPEnvelope();\n                                        if (service.type == ServiceDefinition.BUS_SERVICE_TYPE || \"document\".equals(service.style)) {\n                                            // Add elements to directly to body\n                                            for (int i = 0; i < rootNode.getChildNodes().getLength(); i++) {\n                                                Node child = rootNode.getChildNodes().item(i);\n                                                if (child instanceof org.w3c.dom.Element)\n                                                    requestEnvelope.addBodyElement(new SOAPBodyElement((org.w3c.dom.Element) child));\n                                            }\n                                        } else {\n                                            // Create body element with operation name, and add elements as children\n                                            final SOAPBodyElement requestBody = new SOAPBodyElement(new PrefixedQName(operation.nsuri, operation.name, \"m\"));\n                                            for (int i = 0; i < rootNode.getChildNodes().getLength(); i++) {\n                                                Node child = rootNode.getChildNodes().item(i);\n                                                if (child instanceof org.w3c.dom.Element) {\n                                                    requestBody.addChild(new MessageElement((org.w3c.dom.Element) child));\n                                                } else if (child instanceof org.w3c.dom.Text) {\n                                                    requestBody.addTextNode(((org.w3c.dom.Text) child).toString());\n                                                } else {\n                                                    throw new OXFException(\"Unsupported node type: \" + child.getClass().getName());\n                                                }\n                                            }\n                                            requestEnvelope.addBodyElement(requestBody);\n                                        }\n\n                                        // Call service\n                                        SOAPEnvelope resultEnvelope = null;\n                                        if (service.type == ServiceDefinition.WEB_SERVICE_TYPE) {\n                                            // Call Web service\n                                            parameters = null;\n                                            call.setTargetEndpointAddress(new URL(service.endpoint));\n                                            if (operation != null && operation.soapAction != null) {\n                                                call.setUseSOAPAction(true);\n                                                call.setSOAPActionURI(operation.soapAction);\n                                            }\n                                            call.setReturnClass(javax.xml.soap.SOAPMessage.class);\n                                            resultEnvelope = call.invoke(requestEnvelope);\n                                        } else {\n                                            // Call bus service\n                                            javax.jms.QueueConnection requestQueueConnection = null;\n                                            javax.jms.QueueSession requestQueueSession = null;\n                                            javax.jms.QueueSender queueSender = null;\n                                            try {\n                                                requestQueueConnection = JMSUtils.getQueueConnection();\n                                                requestQueueSession = requestQueueConnection.createQueueSession(false, javax.jms.Session.AUTO_ACKNOWLEDGE);\n                                                queueSender = requestQueueSession.createSender\n                                                        ((javax.jms.Queue) new InitialContext().lookup(JMSUtils.JNDI_SERVICE_PREFIX + service.name));\n                                                javax.jms.ObjectMessage responseMessage = requestQueueSession.createObjectMessage();\n                                                responseMessage.setObject(requestEnvelope);\n\n                                                // Send message\n                                                if (ServiceDirectory.instance().getServiceByName(service.name).hasOutputs()) {\n                                                    // Response expected\n                                                    javax.jms.QueueConnection responseQueueConnection = null;\n                                                    javax.jms.QueueSession responseQueueSession = null;\n                                                    javax.jms.QueueReceiver queueReceiver = null;\n                                                    try {\n                                                        responseQueueConnection = JMSUtils.getQueueConnection();\n                                                        responseQueueSession = responseQueueConnection.createQueueSession(false, javax.jms.Session.AUTO_ACKNOWLEDGE);\n                                                        javax.jms.Queue temporaryQueue = responseQueueSession.createTemporaryQueue();\n                                                        queueReceiver = responseQueueSession.createReceiver(temporaryQueue);\n                                                        responseMessage.setJMSReplyTo(temporaryQueue);\n                                                        responseQueueConnection.start();\n                                                        queueSender.send(responseMessage);\n                                                        javax.jms.Message message = queueReceiver.receive();\n                                                        resultEnvelope = (SOAPEnvelope) ((javax.jms.ObjectMessage) message).getObject();\n                                                    } finally{\n                                                        if (queueReceiver != null) queueReceiver.close();\n                                                        if (responseQueueSession != null) responseQueueSession.close();\n                                                        if (responseQueueConnection != null) responseQueueConnection.close();\n                                                    }\n\n                                                } else {\n                                                    // No response expected\n                                                    queueSender.send(responseMessage);\n                                                }\n                                            } finally {\n                                                if (queueSender != null) queueSender.close();\n                                                if (requestQueueSession != null) requestQueueSession.close();\n                                                if (requestQueueConnection != null) requestQueueConnection.close();\n                                            }\n\n                                        }\n\n                                        // Handle result\n                                        if (resultEnvelope != null) {\n\n                                            // Throw exception if a fault is returned and the user does not want the fault to be returned\n                                            if (resultEnvelope.getBody().getFault() != null && !service.returnFault) {\n                                                throw new OXFException(\"SOAP Fault. Request:\\n\"\n                                                        + XMLUtils.domToString(requestEnvelope.getAsDocument())\n                                                        + \"\\n\\nResponse:\\n\"\n                                                        + XMLUtils.domToString(resultEnvelope.getAsDocument()));\n                                            }\n\n                                            // Send body from result envelope\n                                            LocationSAXWriter locationSAXWriter = new LocationSAXWriter();\n                                            locationSAXWriter.setContentHandler(contentHandler);\n                                            final NonLazyUserDataDocumentFactory fctry = NonLazyUserDataDocumentFactory.getInstance(null);\n                                            Document resultEnvelopeDOM4j = new DOMReader(fctry).read(resultEnvelope.getAsDocument());\n\n                                            String xpath =\n                                                    operation != null && operation.select != null\n                                                    ? operation.select\n                                                    : service.type == ServiceDefinition.WEB_SERVICE_TYPE\n                                                    ? (\"document\".equals(service.style) ? DEFAULT_SELECT_WEB_SERVICE_DOCUMENT : DEFAULT_SELECT_WEB_SERVICE_RPC)\n                                                    : DEFAULT_SELECT_BUS;\n                                            PooledXPathExpression expr = XPathCache.getXPathExpression(context,\n                                                    new DocumentWrapper(resultEnvelopeDOM4j, null, new Configuration()),\n                                                    xpath,\n                                                    operation != null && operation.select != null\n                                                            ? operation.selectNamespaceContext : null, getLocationData());\n                                            for (java.util.Iterator i = expr.evaluate().iterator(); i.hasNext();) {\n\n                                                // Create document with node from SOAP envelope\n                                                Object result = i.next();\n                                                if (result instanceof Element) {\n                                                    locationSAXWriter.write((Element) result);\n                                                } else if (result instanceof Document) {\n                                                    locationSAXWriter.write(((Document) result).getRootElement());\n                                                } else if (result instanceof Text) {\n                                                    locationSAXWriter.write((Text) result);\n                                                } else {\n                                                    throw new OXFException(\"Unsupported result from select expression: '\" + result.getClass() + \"'\");\n                                                }\n                                            }\n                                        }\n\n                                    } else if (service.type == ServiceDefinition.STATELESS_EJB_TYPE\n                                            || service.type == ServiceDefinition.JAVABEAN_TYPE) {\n\n                                        // Create SAXStore with \"real\" document\n                                        SAXStore parametersWellFormed = new SAXStore();\n                                        parametersWellFormed.startDocument();\n                                        parametersWellFormed.startElement(\"\", \"parameters\", \"parameters\", XMLUtils.EMPTY_ATTRIBUTES);\n                                        parameters.replay(parametersWellFormed);\n                                        parametersWellFormed.endElement(\"\", \"parameters\", \"parameters\");\n                                        parametersWellFormed.endDocument();\n                                        parameters = null;\n\n                                        // Put parameters in DOM\n                                        SAXStoreGenerator saxGenerator = new SAXStoreGenerator(parametersWellFormed);\n                                        DOMSerializer domSerializer = new DOMSerializer();\n                                        PipelineUtils.connect(saxGenerator, \"data\", domSerializer, \"data\");\n                                        final Document parametersDocument;\n                                        {\n                                            final PipelineContext tempContext = new PipelineContext();\n                                            domSerializer.start(tempContext);\n                                            parametersDocument = domSerializer.getDocument(tempContext);\n                                        }\n                                        // Get parameter values and types\n                                        java.util.List parameterTypes = new java.util.ArrayList();\n                                        java.util.List parameterValues = new java.util.ArrayList();\n\n                                        // Go throught elements\n                                        for (java.util.Iterator i = parametersDocument.selectNodes(\"/parameters/*\").iterator(); i.hasNext();) {\n                                            org.dom4j.Element parameterElement = (org.dom4j.Element) i.next();\n                                            String parameterValue = parameterElement.getText();\n                                            String type = parameterElement.attributeValue(xsiType);\n                                            if (type == null || \"xsd:string\".equals(type)) {\n                                                parameterTypes.add(String.class);\n                                                parameterValues.add(parameterValue);\n                                            } else if (\"xsd:double\".equals(type)) {\n                                                parameterTypes.add(Double.TYPE);\n                                                parameterValues.add(new Double(parameterValue));\n                                            }\n                                        }\n\n                                        if (service.type == ServiceDefinition.STATELESS_EJB_TYPE) {\n                                            // Call EJB method\n                                            final Context jndiContext = (Context) context.getAttribute(PipelineContext.JNDI_CONTEXT);\n                                            if (jndiContext == null)\n                                                throw new ValidationException(\"JNDI context not found in pipeline context.\", new LocationData(locator));\n                                            final Object home = jndiContext.lookup(service.jndiName);\n                                            if (home == null)\n                                                throw new ValidationException(\"Home interface not found in JNDI context: \" + service.jndiName, new LocationData(locator));\n                                            final Method create = home.getClass().getDeclaredMethod(\"create\", new Class[]{});\n                                            final Object instance = create.invoke(home, new Object[]{});\n                                            final String result = callMethod(instance.getClass(), operationName, parameterTypes, instance, parameterValues);\n                                            super.characters(result.toCharArray(), 0, result.length());\n                                        } else if (service.type == ServiceDefinition.JAVABEAN_TYPE) {\n                                            // Call JavaBean method\n                                            Class clazz = Class.forName(service.clazz);\n                                            Object instance = clazz.newInstance();\n                                            String result = callMethod(clazz, operationName, parameterTypes,\n                                                    instance, parameterValues);\n                                            super.characters(result.toCharArray(), 0, result.length());\n                                        }\n                                    }\n                                }\n                            } else {\n                                // Store values if we are inside a <delegation:execute>\n                                if (parameters == null) {\n                                    super.endElement(uri, localname, qName);\n                                } else {\n                                    parameters.endElement(uri, localname, qName);\n                                }\n                            }\n                        } catch (Exception e) {\n                            throw new OXFException(e);\n                        }\n                    }\n\n                    public void characters(char[] chars, int start, int length) throws SAXException {\n                        // Store values if we are inside a <delegation:execute>\n                        if (parameters == null) {\n                            super.characters(chars, start, length);\n                        } else {\n                            parameters.characters(chars, start, length);\n                        }\n                    }\n\n                    public void setDocumentLocator(Locator locator) {\n                        this.locator = locator;\n                    }\n                });\n            };\n        };\n        addOutput(name, output);\n        return output;\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void initDOMGenerators(PipelineContext context, State state) {\n            if (state.domGenerators == null) {\n\n                // Try to find domGenerators in cache\n                InternalCacheKey internalKey = createInternalKey(context);\n                Object internalValidity = createInternalValidity(context);\n                updateStateWithDOMGeneratorsFromCache(context, state, internalKey, internalValidity);\n\n                // If we can't find domGenerators in cache, create them\n                if (state.domGenerators == null) {\n                    Document dataInput = readInputAsDOM4J(context, getInputByName(FOR_EACH_DATA_INPUT));\n                    state.domGenerators = new ArrayList();\n                    PooledXPathExpression expr = XPathCache.getXPathExpression(context,\n                            new DocumentWrapper(dataInput, null, new Configuration()),\n                            select, namespaceContext);\n                    try {\n                        for (Iterator i = expr.evaluate().iterator(); i.hasNext();) {\n                            Node node = (Node) i.next();\n                            if ( node.getNodeType() != org.dom4j.Node.ELEMENT_NODE )\n                                throw new OXFException(\"Select expression '\" + select\n                                        + \"' did not return a sequence of elements. One node was a '\"\n                                        + node.getNodeTypeName() + \"'\");\n                            final org.dom4j.Element elt = ( org.dom4j.Element )node;\n                            final String sid = Dom4jUtils.makeSystemId( elt );\n                            final DOMGenerator domGenerator = new DOMGenerator\n                                ( elt, \"for each input\", DOMGenerator.ZeroValidity, sid );\n                            domGenerator.createOutput(OUTPUT_DATA);\n                            state.domGenerators.add(domGenerator);\n                        }\n                        if (internalKey != null && internalValidity != null)\n                            ObjectCache.instance().add(context,\n                                    internalKey, internalValidity, state.domGenerators);\n                    } catch (XPathException e) {\n                        throw new OXFException(e);\n                    }\n                }\n            }\n        }","id":30918,"modified_method":"private void initDOMGenerators(PipelineContext context, State state) {\n            if (state.domGenerators == null) {\n\n                // Try to find domGenerators in cache\n                InternalCacheKey internalKey = createInternalKey(context);\n                Object internalValidity = createInternalValidity(context);\n                updateStateWithDOMGeneratorsFromCache(context, state, internalKey, internalValidity);\n\n                // If we can't find domGenerators in cache, create them\n                if (state.domGenerators == null) {\n                    Document dataInput = readInputAsDOM4J(context, getInputByName(FOR_EACH_DATA_INPUT));\n                    state.domGenerators = new ArrayList();\n                    PooledXPathExpression expr = XPathCache.getXPathExpression(context,\n                            new DocumentWrapper(dataInput, null, new Configuration()),\n                            select, namespaceContext, getLocationData());\n                    try {\n                        for (Iterator i = expr.evaluate().iterator(); i.hasNext();) {\n                            Node node = (Node) i.next();\n                            if ( node.getNodeType() != org.dom4j.Node.ELEMENT_NODE )\n                                throw new OXFException(\"Select expression '\" + select\n                                        + \"' did not return a sequence of elements. One node was a '\"\n                                        + node.getNodeTypeName() + \"'\");\n                            final org.dom4j.Element elt = ( org.dom4j.Element )node;\n                            final String sid = Dom4jUtils.makeSystemId( elt );\n                            final DOMGenerator domGenerator = new DOMGenerator\n                                ( elt, \"for each input\", DOMGenerator.ZeroValidity, sid );\n                            domGenerator.createOutput(OUTPUT_DATA);\n                            state.domGenerators.add(domGenerator);\n                        }\n                        if (internalKey != null && internalValidity != null)\n                            ObjectCache.instance().add(context,\n                                    internalKey, internalValidity, state.domGenerators);\n                    } catch (XPathException e) {\n                        throw new OXFException(e);\n                    }\n                }\n            }\n        }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext pipelineContext, final ContentHandler contentHandler) {\n                try {\n                    Element filterElement = readInputAsDOM4J(pipelineContext, INPUT_FILTER).getRootElement();\n                    Document instance = ( Document )readInputAsDOM4J( pipelineContext, INPUT_INSTANCE ).clone();\n                    DocumentWrapper instanceWrapper = new DocumentWrapper(instance,\n                            ((LocationData) instance.getRootElement().getData()).getSystemID(), new Configuration());\n\n                    // Mark all nodes referenced by XPath expressions\n                    final Set markedNodes = new HashSet();\n                    for (Iterator i = filterElement.elements().iterator(); i.hasNext();) {\n                        Element paramElement = (Element) i.next();\n                        Attribute refAttribute = paramElement.attribute(\"ref\");\n                        String excludeRef = refAttribute.getValue();\n                        PooledXPathExpression xpath = XPathCache.getXPathExpression(pipelineContext,\n                                instanceWrapper.wrap(instance), excludeRef,\n                                Dom4jUtils.getNamespaceContextNoDefault(paramElement));\n                        try {\n                            markedNodes.add(xpath.evaluateSingle());\n                        } finally {\n                            if (xpath != null) xpath.returnToPool();\n                        }\n                    }\n\n                    // See if all nodes are marked\n                    final boolean[] allMarked = { true };\n                    instance.accept(new VisitorSupport() {\n                        public void visit(Element node) {\n                            super.visit(node);\n                            if (node.elements().size() == 0 && !markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n\n                        public void visit(Attribute node) {\n                            super.visit(node);\n                            if (!markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n                    });\n\n                    // Output as SAX\n                    contentHandler.startDocument();\n                    contentHandler.startElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT, XMLUtils.EMPTY_ATTRIBUTES);\n                    if (!allMarked[0]) {\n                        // If all the nodes of the instance map to parameters, we don't output the instance parameter\n                        if (removeXXFormsAttributes)\n                            XFormsUtils.removeInstanceAttributes(instanceWrapper);\n                        outputParameter(\"$instance\", XFormsUtils.encodeXML(pipelineContext, instance, false), contentHandler);\n                    }\n                    contentHandler.endElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT);\n                    contentHandler.endDocument();\n\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n        };\n        addOutput(OUTPUT_DATA, output);\n        return output;\n    }","id":30919,"modified_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext pipelineContext, final ContentHandler contentHandler) {\n                try {\n                    Element filterElement = readInputAsDOM4J(pipelineContext, INPUT_FILTER).getRootElement();\n                    Document instance = ( Document )readInputAsDOM4J( pipelineContext, INPUT_INSTANCE ).clone();\n                    DocumentWrapper instanceWrapper = new DocumentWrapper(instance,\n                            ((LocationData) instance.getRootElement().getData()).getSystemID(), new Configuration());\n\n                    // Mark all nodes referenced by XPath expressions\n                    final Set markedNodes = new HashSet();\n                    for (Iterator i = filterElement.elements().iterator(); i.hasNext();) {\n                        Element paramElement = (Element) i.next();\n                        Attribute refAttribute = paramElement.attribute(\"ref\");\n                        String excludeRef = refAttribute.getValue();\n                        PooledXPathExpression xpath = XPathCache.getXPathExpression(pipelineContext,\n                                instanceWrapper.wrap(instance), excludeRef,\n                                Dom4jUtils.getNamespaceContextNoDefault(paramElement), getLocationData());\n                        try {\n                            markedNodes.add(xpath.evaluateSingle());\n                        } finally {\n                            if (xpath != null) xpath.returnToPool();\n                        }\n                    }\n\n                    // See if all nodes are marked\n                    final boolean[] allMarked = { true };\n                    instance.accept(new VisitorSupport() {\n                        public void visit(Element node) {\n                            super.visit(node);\n                            if (node.elements().size() == 0 && !markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n\n                        public void visit(Attribute node) {\n                            super.visit(node);\n                            if (!markedNodes.contains(node))\n                                allMarked[0] = false;\n                        }\n                    });\n\n                    // Output as SAX\n                    contentHandler.startDocument();\n                    contentHandler.startElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT, XMLUtils.EMPTY_ATTRIBUTES);\n                    if (!allMarked[0]) {\n                        // If all the nodes of the instance map to parameters, we don't output the instance parameter\n                        if (removeXXFormsAttributes)\n                            XFormsUtils.removeInstanceAttributes(instanceWrapper);\n                        outputParameter(\"$instance\", XFormsUtils.encodeXML(pipelineContext, instance, false), contentHandler);\n                    }\n                    contentHandler.endElement(\"\", PARAMETERS_ELEMENT, PARAMETERS_ELEMENT);\n                    contentHandler.endDocument();\n\n                } catch (Exception e) {\n                    throw new OXFException(e);\n                }\n            }\n        };\n        addOutput(OUTPUT_DATA, output);\n        return output;\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n        final SQLProcessorInterpreterContext interpreterContext = getInterpreterContext();\n        NamespaceSupport namespaceSupport = interpreterContext.getNamespaceSupport();\n        ContentHandler output = interpreterContext.getOutput();\n\n        namespaceSupport.pushContext();\n        try {\n            String selectString = attributes.getValue(\"select\");\n\n            // Variable context (obsolete)\n            VariableContext variableContext = new VariableContext() {\n                public Object getVariableValue(String namespaceURI, String prefix, String localName) throws UnresolvableException {\n                    if (!SQLProcessor.SQL_NAMESPACE_URI.equals(namespaceURI))\n                        throw new UnresolvableException(\"Unbound variable: {\" + namespaceURI + \"}\" + localName);\n                    if (\"row-position\".equals(localName)) {\n                        return new Integer(interpreterContext.getRowPosition());\n                    } else\n                        throw new UnresolvableException(\"Unbound variable: {\" + namespaceURI + \"}\" + localName);\n                }\n            };\n\n            // Interpret expression\n            Object result = XPathUtils.selectObjectValue(interpreterContext.getCurrentNode(), selectString,\n                    interpreterContext.getPrefixesMap(), variableContext, interpreterContext.getFunctionContext());\n\n            if (\"value-of\".equals(localname) || \"copy-of\".equals(localname)) {\n                // Case of Number and String\n                if (result instanceof Number) {\n                    String stringValue;\n                    if (result instanceof Float || result instanceof Double) {\n                        stringValue = XMLUtils.removeScientificNotation(((Number) result).doubleValue());\n                    } else {\n                        stringValue = Long.toString(((Number) result).longValue());\n                    } // FIXME: what about BigDecimal and BigInteger: can they be returned?\n                    output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                } else if (result instanceof String) {\n                    String stringValue = (String) result;\n                    output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                } else if (result instanceof List) {\n                    if (\"value-of\".equals(localname)) {\n                        // Get string value\n//                            String stringValue = interpreterContext.getInput().createXPath(\".\").valueOf(result);\n//                            String stringValue = XPathCache.createCacheXPath(null, \".\").valueOf(result);\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(interpreterContext.getPipelineContext(),\n                                wrapper.wrap(result), \"string(.)\");\n                        String stringValue;\n                        try {\n                            stringValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                    } else {\n                        LocationSAXWriter saxw = new LocationSAXWriter();\n                        saxw.setContentHandler(output);\n                        for (Iterator i = ((List) result).iterator(); i.hasNext();) {\n                            Node node = (Node) i.next();\n                            saxw.write(node);\n                        }\n                    }\n                } else if (result instanceof Node) {\n                    if (\"value-of\".equals(localname)) {\n                        // Get string value\n//                            String stringValue = interpreterContext.getInput().createXPath(\".\").valueOf(result);\n//                            String stringValue = XPathCache.createCacheXPath(null, \".\").valueOf(result);\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(interpreterContext.getPipelineContext(),\n                                wrapper.wrap(result), \"string(.)\");\n                        String stringValue;\n                        try {\n                            stringValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                    } else {\n                        LocationSAXWriter saxw = new LocationSAXWriter();\n                        saxw.setContentHandler(output);\n                        saxw.write((Node) result);\n                    }\n                } else\n                    throw new OXFException(\"Unexpected XPath result type: \" + result.getClass());\n            } else {\n                throw new OXFException(\"Invalid element: \" + qName);\n            }\n\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(getDocumentLocator()));\n        }\n    }","id":30920,"modified_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n        final SQLProcessorInterpreterContext interpreterContext = getInterpreterContext();\n        NamespaceSupport namespaceSupport = interpreterContext.getNamespaceSupport();\n        ContentHandler output = interpreterContext.getOutput();\n\n        namespaceSupport.pushContext();\n        try {\n            String selectString = attributes.getValue(\"select\");\n\n            // Variable context (obsolete)\n            VariableContext variableContext = new VariableContext() {\n                public Object getVariableValue(String namespaceURI, String prefix, String localName) throws UnresolvableException {\n                    if (!SQLProcessor.SQL_NAMESPACE_URI.equals(namespaceURI))\n                        throw new UnresolvableException(\"Unbound variable: {\" + namespaceURI + \"}\" + localName);\n                    if (\"row-position\".equals(localName)) {\n                        return new Integer(interpreterContext.getRowPosition());\n                    } else\n                        throw new UnresolvableException(\"Unbound variable: {\" + namespaceURI + \"}\" + localName);\n                }\n            };\n\n            // Interpret expression\n            Object result = XPathUtils.selectObjectValue(interpreterContext.getCurrentNode(), selectString,\n                    interpreterContext.getPrefixesMap(), variableContext, interpreterContext.getFunctionContext());\n\n            if (\"value-of\".equals(localname) || \"copy-of\".equals(localname)) {\n                // Case of Number and String\n                if (result instanceof Number) {\n                    String stringValue;\n                    if (result instanceof Float || result instanceof Double) {\n                        stringValue = XMLUtils.removeScientificNotation(((Number) result).doubleValue());\n                    } else {\n                        stringValue = Long.toString(((Number) result).longValue());\n                    } // FIXME: what about BigDecimal and BigInteger: can they be returned?\n                    output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                } else if (result instanceof String) {\n                    String stringValue = (String) result;\n                    output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                } else if (result instanceof List) {\n                    if (\"value-of\".equals(localname)) {\n                        // Get string value\n//                            String stringValue = interpreterContext.getInput().createXPath(\".\").valueOf(result);\n//                            String stringValue = XPathCache.createCacheXPath(null, \".\").valueOf(result);\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(interpreterContext.getPipelineContext(),\n                                wrapper.wrap(result), \"string(.)\", null);\n                        String stringValue;\n                        try {\n                            stringValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                    } else {\n                        LocationSAXWriter saxw = new LocationSAXWriter();\n                        saxw.setContentHandler(output);\n                        for (Iterator i = ((List) result).iterator(); i.hasNext();) {\n                            Node node = (Node) i.next();\n                            saxw.write(node);\n                        }\n                    }\n                } else if (result instanceof Node) {\n                    if (\"value-of\".equals(localname)) {\n                        // Get string value\n//                            String stringValue = interpreterContext.getInput().createXPath(\".\").valueOf(result);\n//                            String stringValue = XPathCache.createCacheXPath(null, \".\").valueOf(result);\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(interpreterContext.getPipelineContext(),\n                                wrapper.wrap(result), \"string(.)\", null);\n                        String stringValue;\n                        try {\n                            stringValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        output.characters(stringValue.toCharArray(), 0, stringValue.length());\n                    } else {\n                        LocationSAXWriter saxw = new LocationSAXWriter();\n                        saxw.setContentHandler(output);\n                        saxw.write((Node) result);\n                    }\n                } else\n                    throw new OXFException(\"Unexpected XPath result type: \" + result.getClass());\n            } else {\n                throw new OXFException(\"Invalid element: \" + qName);\n            }\n\n        } catch (Exception e) {\n            throw new ValidationException(e, new LocationData(getDocumentLocator()));\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext context, ContentHandler contentHandler) {\n\n                try {\n                    // Read binary content of uploaded Excel file\n                    final byte[] fileContent;\n                    {\n                        final String NO_FILE = \"No file was uploaded\";\n                        final Document requestDocument  = readInputAsDOM4J(context, INPUT_REQUEST);\n                        final PooledXPathExpression expr = XPathCache.getXPathExpression(context,\n                                new DocumentWrapper(requestDocument, null, new Configuration()),\n                                \"/request/parameters/parameter[1]/value\");\n\n                        final Element valueElement;\n                        try {\n                             valueElement = (Element) expr.evaluateSingle();\n                        } finally{\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        \n                        if (valueElement == null) throw new OXFException(NO_FILE);\n                        String type = valueElement.attributeValue(XMLConstants.XSI_TYPE_QNAME);\n                        if (type == null) throw new OXFException(NO_FILE);\n\n                        if (type.endsWith(\"anyURI\")) {\n                            // Read file from disk\n                            String url = valueElement.getStringValue();\n                            InputStream urlInputStream = new URL(url).openStream();\n                            byte[] buffer = new byte[1024];\n                            ByteArrayOutputStream fileByteArray = new ByteArrayOutputStream();\n                            int size;\n                            while ((size = urlInputStream.read(buffer)) != -1)\n                                fileByteArray.write(buffer, 0, size);\n                            urlInputStream.close();\n                            fileContent = fileByteArray.toByteArray();\n                        } else {\n                            // Decode base64\n                            fileContent = Base64.decode(valueElement.getStringValue());\n                        }\n                    }\n\n                    // Generate XML from Excel file\n                    final java.io.ByteArrayInputStream bais \n                        = new ByteArrayInputStream( fileContent );\n                    final org.dom4j.Document d = extractFromXLS( bais );\n                    final DOMGenerator domGenerator = new DOMGenerator\n                        ( d, \"xls generator output\", DOMGenerator.ZeroValidity\n                          , DOMGenerator.DefaultContext );\n                    domGenerator.createOutput(OUTPUT_DATA).read(context, contentHandler);\n                } catch (XPathException xpe) {\n                    throw new OXFException(xpe);\n                } catch (IOException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            private Document extractFromXLS(InputStream inputStream) throws IOException {\n\n                // Create workbook\n                HSSFWorkbook workbook = new HSSFWorkbook(new POIFSFileSystem(inputStream));\n\n                // Create document\n                final NonLazyUserDataElement root = new NonLazyUserDataElement( \"workbook\" );\n                final Document resultDocument = new NonLazyUserDataDocument( root );\n\n                // Add elements for each sheet\n                for (int i = 0; i < workbook.getNumberOfSheets(); i++) {\n                    HSSFSheet sheet = workbook.getSheetAt(i);\n\n                    final Element element = new NonLazyUserDataElement(\"sheet\");\n                    resultDocument.getRootElement().add(element);\n\n                    // Go though each cell\n                    XLSUtils.walk(workbook.createDataFormat(), sheet, new XLSUtils.Handler() {\n                        public void cell(HSSFCell cell, String sourceXPath, String targetXPath) {\n                            if (targetXPath != null) {\n                                int cellType = cell.getCellType();\n                                String value = null;\n                                switch (cellType) {\n                                    case HSSFCell.CELL_TYPE_STRING:\n                                    case HSSFCell.CELL_TYPE_BLANK:\n                                        value = cell.getStringCellValue();\n                                        break;\n                                    case HSSFCell.CELL_TYPE_NUMERIC:\n                                        double doubleValue = cell.getNumericCellValue();\n                                        if (((double) ((int) doubleValue)) == doubleValue) {\n                                            // This is an integer\n                                            value = Integer.toString((int) doubleValue);\n                                        } else {\n                                            // This is a floating point number\n                                            value = XMLUtils.removeScientificNotation(doubleValue);\n                                        }\n                                        break;\n                                }\n                                if (value == null)\n                                    throw new OXFException(\"Unkown cell type \" + cellType\n                                            + \" for XPath expression '\" + targetXPath + \"'\");\n                                addToElement(element, targetXPath, value);\n                            }\n                        }\n                    });\n                }\n\n                return resultDocument;\n            }\n\n            private void addToElement(Element element, String xpath, String value) {\n                StringTokenizer elements = new StringTokenizer(xpath, \"/\");\n\n                while (elements.hasMoreTokens()) {\n                    String name = elements.nextToken();\n                    if (elements.hasMoreTokens()) {\n                        // Not the last: try to find sub element, otherwise create\n                        Element child = element.element(name);\n                        if (child == null) {\n                            child = new NonLazyUserDataElement(name);\n                            element.add(child);\n                        }\n                        element = child;\n                    } else {\n                        // Last: add element, set content to value\n                        Element child = new NonLazyUserDataElement(name);\n                        child.add(Dom4jUtils.createText(value));\n                        element.add(child);\n                    }\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","id":30921,"modified_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.ProcessorOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext context, ContentHandler contentHandler) {\n\n                try {\n                    // Read binary content of uploaded Excel file\n                    final byte[] fileContent;\n                    {\n                        final String NO_FILE = \"No file was uploaded\";\n                        final Document requestDocument  = readInputAsDOM4J(context, INPUT_REQUEST);\n                        final PooledXPathExpression expr = XPathCache.getXPathExpression(context,\n                                new DocumentWrapper(requestDocument, null, new Configuration()),\n                                \"/request/parameters/parameter[1]/value\", getLocationData());\n\n                        final Element valueElement;\n                        try {\n                             valueElement = (Element) expr.evaluateSingle();\n                        } finally{\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        \n                        if (valueElement == null) throw new OXFException(NO_FILE);\n                        String type = valueElement.attributeValue(XMLConstants.XSI_TYPE_QNAME);\n                        if (type == null) throw new OXFException(NO_FILE);\n\n                        if (type.endsWith(\"anyURI\")) {\n                            // Read file from disk\n                            String url = valueElement.getStringValue();\n                            InputStream urlInputStream = new URL(url).openStream();\n                            byte[] buffer = new byte[1024];\n                            ByteArrayOutputStream fileByteArray = new ByteArrayOutputStream();\n                            int size;\n                            while ((size = urlInputStream.read(buffer)) != -1)\n                                fileByteArray.write(buffer, 0, size);\n                            urlInputStream.close();\n                            fileContent = fileByteArray.toByteArray();\n                        } else {\n                            // Decode base64\n                            fileContent = Base64.decode(valueElement.getStringValue());\n                        }\n                    }\n\n                    // Generate XML from Excel file\n                    final java.io.ByteArrayInputStream bais \n                        = new ByteArrayInputStream( fileContent );\n                    final org.dom4j.Document d = extractFromXLS( bais );\n                    final DOMGenerator domGenerator = new DOMGenerator\n                        ( d, \"xls generator output\", DOMGenerator.ZeroValidity\n                          , DOMGenerator.DefaultContext );\n                    domGenerator.createOutput(OUTPUT_DATA).read(context, contentHandler);\n                } catch (XPathException xpe) {\n                    throw new OXFException(xpe);\n                } catch (IOException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            private Document extractFromXLS(InputStream inputStream) throws IOException {\n\n                // Create workbook\n                HSSFWorkbook workbook = new HSSFWorkbook(new POIFSFileSystem(inputStream));\n\n                // Create document\n                final NonLazyUserDataElement root = new NonLazyUserDataElement( \"workbook\" );\n                final Document resultDocument = new NonLazyUserDataDocument( root );\n\n                // Add elements for each sheet\n                for (int i = 0; i < workbook.getNumberOfSheets(); i++) {\n                    HSSFSheet sheet = workbook.getSheetAt(i);\n\n                    final Element element = new NonLazyUserDataElement(\"sheet\");\n                    resultDocument.getRootElement().add(element);\n\n                    // Go though each cell\n                    XLSUtils.walk(workbook.createDataFormat(), sheet, new XLSUtils.Handler() {\n                        public void cell(HSSFCell cell, String sourceXPath, String targetXPath) {\n                            if (targetXPath != null) {\n                                int cellType = cell.getCellType();\n                                String value = null;\n                                switch (cellType) {\n                                    case HSSFCell.CELL_TYPE_STRING:\n                                    case HSSFCell.CELL_TYPE_BLANK:\n                                        value = cell.getStringCellValue();\n                                        break;\n                                    case HSSFCell.CELL_TYPE_NUMERIC:\n                                        double doubleValue = cell.getNumericCellValue();\n                                        if (((double) ((int) doubleValue)) == doubleValue) {\n                                            // This is an integer\n                                            value = Integer.toString((int) doubleValue);\n                                        } else {\n                                            // This is a floating point number\n                                            value = XMLUtils.removeScientificNotation(doubleValue);\n                                        }\n                                        break;\n                                }\n                                if (value == null)\n                                    throw new OXFException(\"Unkown cell type \" + cellType\n                                            + \" for XPath expression '\" + targetXPath + \"'\");\n                                addToElement(element, targetXPath, value);\n                            }\n                        }\n                    });\n                }\n\n                return resultDocument;\n            }\n\n            private void addToElement(Element element, String xpath, String value) {\n                StringTokenizer elements = new StringTokenizer(xpath, \"/\");\n\n                while (elements.hasMoreTokens()) {\n                    String name = elements.nextToken();\n                    if (elements.hasMoreTokens()) {\n                        // Not the last: try to find sub element, otherwise create\n                        Element child = element.element(name);\n                        if (child == null) {\n                            child = new NonLazyUserDataElement(name);\n                            element.add(child);\n                        }\n                        element = child;\n                    } else {\n                        // Last: add element, set content to value\n                        Element child = new NonLazyUserDataElement(name);\n                        child.add(Dom4jUtils.createText(value));\n                        element.add(child);\n                    }\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"protected void readInput(final PipelineContext pipelineContext, ProcessorInput input, Config config, OutputStream outputStream) {\n        try {\n            final PatternMatcher matcher = new Perl5Matcher();\n            Document dataDocument = readInputAsDOM4J(pipelineContext, INPUT_DATA);\n            final DocumentWrapper wrapper = new DocumentWrapper(dataDocument, null, new Configuration());\n\n            Document configDocument = readInputAsDOM4J(pipelineContext, INPUT_CONFIG);\n\n            // Read template sheet\n            String templateName = configDocument.getRootElement().attributeValue(\"template\");\n            //String fileName = configDocument.getRootElement().attributeValue(\"filename\");\n            InputStream templateInputStream = URLFactory.createURL(templateName).openStream();\n            final HSSFWorkbook workbook = new HSSFWorkbook(new POIFSFileSystem(templateInputStream));\n            final HSSFDataFormat dataFormat = workbook.createDataFormat();\n            templateInputStream.close();\n\n            int sheetIndex = 0;\n\n            PooledXPathExpression expr = null;\n            List nodes = null;\n            try {\n                expr = XPathCache.getXPathExpression(pipelineContext,\n                        wrapper, \"/workbook/sheet\");\n                nodes = expr.evaluate();\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally {\n                if (expr != null)\n                    expr.returnToPool();\n            }\n            for (Iterator i = nodes.iterator(); i.hasNext();) {\n\n                final Element sheetElement = (Element) i.next();\n                HSSFSheet sheet = workbook.cloneSheet(0);\n                workbook.setSheetName(sheetIndex + 1, sheetElement.attributeValue(\"name\"));\n\n                // Duplicate rows if we find a \"repeat-row\" in the config\n                for (Iterator j = configDocument.selectNodes(\"/config/repeat-row\").iterator(); j.hasNext();) {\n\n                    // Get info about row to repeat\n                    Element repeatRowElement = (Element) j.next();\n                    final int rowNum = Integer.parseInt(repeatRowElement.attributeValue(\"row-num\"));\n                    final String forEach = repeatRowElement.attributeValue(\"for-each\");\n                    HSSFRow templateRow = sheet.getRow(rowNum);\n                    int repeatCount = ((Double) sheetElement.selectObject(\"count(\" + forEach + \")\")).intValue();\n\n                    // Move existing rows lower\n                    int lastRowNum = sheet.getLastRowNum();\n                    for (int k = lastRowNum; k > rowNum; k--) {\n                        HSSFRow sourceRow = sheet.getRow(k);\n                        HSSFRow newRow = sheet.createRow(k + repeatCount - 1);\n                        XLSUtils.copyRow(workbook, newRow, sourceRow);\n                    }\n\n                    // Create rows, copying the template row\n                    for (int k = rowNum + 1; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.createRow(k);\n                        XLSUtils.copyRow(workbook, newRow, templateRow);\n                    }\n\n                    // Modify the XPath expression on each row\n                    for (int k = rowNum; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.getRow(k);\n                        for (short m = 0; m <= newRow.getLastCellNum(); m++) {\n                            HSSFCell cell = newRow.getCell(m);\n                            if (cell != null) {\n                                String currentFormat = dataFormat.getFormat(cell.getCellStyle().getDataFormat());\n                                if (matcher.contains(currentFormat, FORMAT_XPATH)) {\n                                    String newFormat = matcher.getMatch().group(1) + \"\\\"\"\n                                            + forEach + \"[\" + (k - rowNum + 1) + \"]/\" + matcher.getMatch().group(2) + \"\\\"\";\n                                    cell.getCellStyle().setDataFormat(dataFormat.getFormat(newFormat));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Set values in cells with an XPath expression\n                XLSUtils.walk(dataFormat, sheet, new XLSUtils.Handler() {\n                    public void cell(HSSFCell cell, String sourceXPath, String targetXPath) {\n                        if (sourceXPath.charAt(0) == '/')\n                            sourceXPath = sourceXPath.substring(1);\n\n                        // Set cell value\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(pipelineContext,\n                                wrapper.wrap(sheetElement), \"string(\" + sourceXPath + \")\");\n                        String newValue;\n                        try {\n                            newValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        if (newValue == null) {\n                            throw new OXFException(\"Nothing matches the XPath expression '\"\n                                    + sourceXPath + \"' in the input document\");\n                        }\n                        try {\n                            cell.setCellValue(Double.parseDouble(newValue));\n                        } catch (NumberFormatException e) {\n                            cell.setCellValue(newValue);\n                        }\n\n                        // Set cell format\n                        Object element = sheetElement.selectObject(sourceXPath);\n                        if (element instanceof Element) {\n                            // NOTE: We might want to support other properties here\n                            String bold = ((Element) element).attributeValue(\"bold\");\n                            if (bold != null) {\n                                HSSFFont originalFont = workbook.getFontAt(cell.getCellStyle().getFontIndex());\n                                HSSFFont newFont = workbook.createFont();\n                                XLSUtils.copyFont(newFont, originalFont);\n                                if (\"true\".equals(bold))\n                                    newFont.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);\n                                cell.getCellStyle().setFont(newFont);\n                            }\n                        }\n                    }\n                });\n                sheetIndex++;\n            }\n\n            workbook.removeSheetAt(0);\n\n            // Write out the workbook\n            workbook.write(outputStream);\n        } catch (IOException e) {\n            throw new OXFException(e);\n        }\n    }","id":30922,"modified_method":"protected void readInput(final PipelineContext pipelineContext, ProcessorInput input, Config config, OutputStream outputStream) {\n        try {\n            final PatternMatcher matcher = new Perl5Matcher();\n            Document dataDocument = readInputAsDOM4J(pipelineContext, INPUT_DATA);\n            final DocumentWrapper wrapper = new DocumentWrapper(dataDocument, null, new Configuration());\n\n            Document configDocument = readInputAsDOM4J(pipelineContext, INPUT_CONFIG);\n\n            // Read template sheet\n            String templateName = configDocument.getRootElement().attributeValue(\"template\");\n            //String fileName = configDocument.getRootElement().attributeValue(\"filename\");\n            InputStream templateInputStream = URLFactory.createURL(templateName).openStream();\n            final HSSFWorkbook workbook = new HSSFWorkbook(new POIFSFileSystem(templateInputStream));\n            final HSSFDataFormat dataFormat = workbook.createDataFormat();\n            templateInputStream.close();\n\n            int sheetIndex = 0;\n\n            PooledXPathExpression expr = null;\n            List nodes = null;\n            try {\n                expr = XPathCache.getXPathExpression(pipelineContext, wrapper, \"/workbook/sheet\", getLocationData());\n                nodes = expr.evaluate();\n            } catch (XPathException e) {\n                throw new OXFException(e);\n            } finally {\n                if (expr != null)\n                    expr.returnToPool();\n            }\n            for (Iterator i = nodes.iterator(); i.hasNext();) {\n\n                final Element sheetElement = (Element) i.next();\n                HSSFSheet sheet = workbook.cloneSheet(0);\n                workbook.setSheetName(sheetIndex + 1, sheetElement.attributeValue(\"name\"));\n\n                // Duplicate rows if we find a \"repeat-row\" in the config\n                for (Iterator j = configDocument.selectNodes(\"/config/repeat-row\").iterator(); j.hasNext();) {\n\n                    // Get info about row to repeat\n                    Element repeatRowElement = (Element) j.next();\n                    final int rowNum = Integer.parseInt(repeatRowElement.attributeValue(\"row-num\"));\n                    final String forEach = repeatRowElement.attributeValue(\"for-each\");\n                    HSSFRow templateRow = sheet.getRow(rowNum);\n                    int repeatCount = ((Double) sheetElement.selectObject(\"count(\" + forEach + \")\")).intValue();\n\n                    // Move existing rows lower\n                    int lastRowNum = sheet.getLastRowNum();\n                    for (int k = lastRowNum; k > rowNum; k--) {\n                        HSSFRow sourceRow = sheet.getRow(k);\n                        HSSFRow newRow = sheet.createRow(k + repeatCount - 1);\n                        XLSUtils.copyRow(workbook, newRow, sourceRow);\n                    }\n\n                    // Create rows, copying the template row\n                    for (int k = rowNum + 1; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.createRow(k);\n                        XLSUtils.copyRow(workbook, newRow, templateRow);\n                    }\n\n                    // Modify the XPath expression on each row\n                    for (int k = rowNum; k < rowNum + repeatCount; k++) {\n                        HSSFRow newRow = sheet.getRow(k);\n                        for (short m = 0; m <= newRow.getLastCellNum(); m++) {\n                            HSSFCell cell = newRow.getCell(m);\n                            if (cell != null) {\n                                String currentFormat = dataFormat.getFormat(cell.getCellStyle().getDataFormat());\n                                if (matcher.contains(currentFormat, FORMAT_XPATH)) {\n                                    String newFormat = matcher.getMatch().group(1) + \"\\\"\"\n                                            + forEach + \"[\" + (k - rowNum + 1) + \"]/\" + matcher.getMatch().group(2) + \"\\\"\";\n                                    cell.getCellStyle().setDataFormat(dataFormat.getFormat(newFormat));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Set values in cells with an XPath expression\n                XLSUtils.walk(dataFormat, sheet, new XLSUtils.Handler() {\n                    public void cell(HSSFCell cell, String sourceXPath, String targetXPath) {\n                        if (sourceXPath.charAt(0) == '/')\n                            sourceXPath = sourceXPath.substring(1);\n\n                        // Set cell value\n                        PooledXPathExpression expr = XPathCache.getXPathExpression(pipelineContext,\n                                wrapper.wrap(sheetElement), \"string(\" + sourceXPath + \")\", getLocationData());\n                        String newValue;\n                        try {\n                            newValue = (String) expr.evaluateSingle();\n                        } catch (XPathException e) {\n                            throw new OXFException(e);\n                        } finally {\n                            if (expr != null)\n                                expr.returnToPool();\n                        }\n                        if (newValue == null) {\n                            throw new OXFException(\"Nothing matches the XPath expression '\"\n                                    + sourceXPath + \"' in the input document\");\n                        }\n                        try {\n                            cell.setCellValue(Double.parseDouble(newValue));\n                        } catch (NumberFormatException e) {\n                            cell.setCellValue(newValue);\n                        }\n\n                        // Set cell format\n                        Object element = sheetElement.selectObject(sourceXPath);\n                        if (element instanceof Element) {\n                            // NOTE: We might want to support other properties here\n                            String bold = ((Element) element).attributeValue(\"bold\");\n                            if (bold != null) {\n                                HSSFFont originalFont = workbook.getFontAt(cell.getCellStyle().getFontIndex());\n                                HSSFFont newFont = workbook.createFont();\n                                XLSUtils.copyFont(newFont, originalFont);\n                                if (\"true\".equals(bold))\n                                    newFont.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);\n                                cell.getCellStyle().setFont(newFont);\n                            }\n                        }\n                    }\n                });\n                sheetIndex++;\n            }\n\n            workbook.removeSheetAt(0);\n\n            // Write out the workbook\n            workbook.write(outputStream);\n        } catch (IOException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Evaluate an XPath expression on the document.\n     */\n    public static List evaluate(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString,\n                         Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n\n        PooledXPathExpression xpathExpression = null;\n        try {\n            xpathExpression = XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition,\n                xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false);\n            return xpathExpression.evaluateKeepNodeInfo();\n        } catch (Exception e) {\n            throw new ValidationException(\"Exception evaluating XPath expression: \" + xpathString, e, locationData);\n        } finally {\n            if (xpathExpression != null)\n                xpathExpression.returnToPool();\n        }\n    }","id":30923,"modified_method":"/**\n     * Evaluate an XPath expression on the document.\n     */\n    public static List evaluate(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString,\n                         Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n\n        final PooledXPathExpression xpathExpression = XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition,\n                xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false, locationData);\n        try {\n            return xpathExpression.evaluateKeepNodeInfo();\n        } catch (Exception e) {\n            throw handleXPathException(e, xpathString, \"evaluating XPath expression\", locationData);\n        } finally {\n            if (xpathExpression != null)\n                xpathExpression.returnToPool();\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           List contextNodeSet, int contextPosition,\n                                                           String xpathString,\n                                                           Map prefixToURIMap,\n                                                           Map variableToValueMap,\n                                                           FunctionLibrary functionLibrary,\n                                                           String baseURI,\n                                                           boolean isAvt,\n                                                           boolean testNoCache) {\n\n        try {\n            // Find pool from cache\n            final Long validity = new Long(0);\n            final Cache cache = ObjectCache.instance(XPATH_CACHE_NAME, XPATH_CACHE_DEFAULT_SIZE);\n            final FastStringBuffer cacheKeyString = new FastStringBuffer(xpathString);\n            {\n                if (functionLibrary != null) {// This is ok\n                    cacheKeyString.append('|');\n                    cacheKeyString.append(Integer.toString(functionLibrary.hashCode()));\n                }\n            }\n            {\n                // NOTE: It is not clear whether we actually need to cache the expression with a key that depends on\n                // the namespace context. The question is whether XPath \"compilation\" depends on that context. But it is\n                // safe to do so functionally, while not always optimal in memory as you may cache several times the\n                // same expression, except for the namespace context. If we do not cache per the namespace context, then\n                // we need to restore the namespace context before using the expression.\n\n                // TODO: PERF: It turns out that this takes a lot of time.\n                if (prefixToURIMap != null) {\n                    final Map sortedMap = (prefixToURIMap instanceof TreeMap) ? prefixToURIMap : new TreeMap(prefixToURIMap);// this should make sure we always get the keys in the same order\n                    for (Iterator i = sortedMap.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry currentEntry = (Map.Entry) i.next();\n                        cacheKeyString.append('|');\n                        cacheKeyString.append((String) currentEntry.getKey());\n                        cacheKeyString.append('=');\n                        cacheKeyString.append((String) currentEntry.getValue());\n                    }\n                }\n            }\n            {\n                // Add this to the key as evaluating \"name\" as XPath or as AVT is very different!\n                cacheKeyString.append('|');\n                cacheKeyString.append(Boolean.toString(isAvt));\n            }\n\n            final PooledXPathExpression expr;\n            if (testNoCache) {\n                // For testing only: don't get expression from cache\n                final Object o = new XFormsCachePoolableObjetFactory(null, xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, isAvt).makeObject();\n                expr = (PooledXPathExpression) o;\n            } else {\n                // Get or create pool\n                final InternalCacheKey cacheKey = new InternalCacheKey(\"XPath Expression2\", cacheKeyString.toString());\n                ObjectPool pool = (ObjectPool) cache.findValid(pipelineContext, cacheKey, validity);\n                if (pool == null) {\n                    pool = createXPathPool(xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, isAvt);\n                    cache.add(pipelineContext, cacheKey, validity, pool);\n                }\n\n                // Get object from pool\n                final Object o = pool.borrowObject();\n                expr = (PooledXPathExpression) o;\n            }\n\n            // Set context node and position\n            expr.setContextNodeSet(contextNodeSet, contextPosition);\n\n            // Set variables\n            expr.setVariables(variableToValueMap);\n\n            return expr;\n        } catch (Exception e) {\n            throw new ValidationException(\"Exception evaluating XPath expression: \" + xpathString, e, null);\n        }\n    }","id":30924,"modified_method":"private static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           List contextNodeSet, int contextPosition,\n                                                           String xpathString,\n                                                           Map prefixToURIMap,\n                                                           Map variableToValueMap,\n                                                           FunctionLibrary functionLibrary,\n                                                           String baseURI,\n                                                           boolean isAvt,\n                                                           boolean testNoCache,\n                                                           LocationData locationData) {\n\n        try {\n            // Find pool from cache\n            final Long validity = new Long(0);\n            final Cache cache = ObjectCache.instance(XPATH_CACHE_NAME, XPATH_CACHE_DEFAULT_SIZE);\n            final FastStringBuffer cacheKeyString = new FastStringBuffer(xpathString);\n            {\n                if (functionLibrary != null) {// This is ok\n                    cacheKeyString.append('|');\n                    cacheKeyString.append(Integer.toString(functionLibrary.hashCode()));\n                }\n            }\n            {\n                // NOTE: It is not clear whether we actually need to cache the expression with a key that depends on\n                // the namespace context. The question is whether XPath \"compilation\" depends on that context. But it is\n                // safe to do so functionally, while not always optimal in memory as you may cache several times the\n                // same expression, except for the namespace context. If we do not cache per the namespace context, then\n                // we need to restore the namespace context before using the expression.\n\n                // TODO: PERF: It turns out that this takes a lot of time.\n                if (prefixToURIMap != null) {\n                    final Map sortedMap = (prefixToURIMap instanceof TreeMap) ? prefixToURIMap : new TreeMap(prefixToURIMap);// this should make sure we always get the keys in the same order\n                    for (Iterator i = sortedMap.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry currentEntry = (Map.Entry) i.next();\n                        cacheKeyString.append('|');\n                        cacheKeyString.append((String) currentEntry.getKey());\n                        cacheKeyString.append('=');\n                        cacheKeyString.append((String) currentEntry.getValue());\n                    }\n                }\n            }\n            {\n                // Add this to the key as evaluating \"name\" as XPath or as AVT is very different!\n                cacheKeyString.append('|');\n                cacheKeyString.append(Boolean.toString(isAvt));\n            }\n\n            final PooledXPathExpression expr;\n            if (testNoCache) {\n                // For testing only: don't get expression from cache\n                final Object o = new XFormsCachePoolableObjetFactory(null, xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, isAvt).makeObject();\n                expr = (PooledXPathExpression) o;\n            } else {\n                // Get or create pool\n                final InternalCacheKey cacheKey = new InternalCacheKey(\"XPath Expression2\", cacheKeyString.toString());\n                ObjectPool pool = (ObjectPool) cache.findValid(pipelineContext, cacheKey, validity);\n                if (pool == null) {\n                    pool = createXPathPool(xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, isAvt);\n                    cache.add(pipelineContext, cacheKey, validity, pool);\n                }\n\n                // Get object from pool\n                final Object o = pool.borrowObject();\n                expr = (PooledXPathExpression) o;\n            }\n\n            // Set context node and position\n            expr.setContextNodeSet(contextNodeSet, contextPosition);\n\n            // Set variables\n            expr.setVariables(variableToValueMap);\n\n            return expr;\n        } catch (Exception e) {\n            throw handleXPathException(e, xpathString, \"preparing XPath expression\", locationData);\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           NodeInfo contextNode,\n                                                           String xpathString,\n                                                           Map prefixToURIMap,\n                                                           Map variableToValueMap,\n                                                           FunctionLibrary functionLibrary,\n                                                           String baseURI) {\n        final List contextNodeSet = Collections.singletonList(contextNode);\n        return getXPathExpression(pipelineContext, contextNodeSet, 1, xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false);\n     }","id":30925,"modified_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           NodeInfo contextNode,\n                                                           String xpathString,\n                                                           Map prefixToURIMap,\n                                                           Map variableToValueMap,\n                                                           FunctionLibrary functionLibrary,\n                                                           String baseURI,\n                                                           LocationData locationData) {\n        final List contextNodeSet = Collections.singletonList(contextNode);\n        return getXPathExpression(pipelineContext, contextNodeSet, 1, xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false, locationData);\n     }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           NodeInfo contextNode,\n                                                           String xpathString) {\n        return getXPathExpression(pipelineContext, contextNode, xpathString, null, null, null, null);\n    }","id":30926,"modified_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           NodeInfo contextNode,\n                                                           String xpathString,\n                                                           LocationData locationData) {\n        return getXPathExpression(pipelineContext, contextNode, xpathString, null, null, null, null, locationData);\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           NodeInfo contextNode,\n                                                           String xpathString,\n                                                           Map prefixToURIMap) {\n        return getXPathExpression(pipelineContext, contextNode, xpathString, prefixToURIMap, null, null, null);\n    }","id":30927,"modified_method":"public static PooledXPathExpression getXPathExpression(PipelineContext pipelineContext,\n                                                           NodeInfo contextNode,\n                                                           String xpathString,\n                                                           Map prefixToURIMap,\n                                                           LocationData locationData) {\n        return getXPathExpression(pipelineContext, contextNode, xpathString, prefixToURIMap, null, null, null, locationData);\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Evaluate an XPath expression on the document.\n     */\n    public static Object evaluateSingle(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString,\n                                 Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n\n        PooledXPathExpression xpathExpression = null;\n        try {\n            xpathExpression = XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition,\n                xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false);\n            return xpathExpression.evaluateSingleKeepNodeInfo();\n        } catch (XPathException e) {\n            throw new ValidationException(\"Exception evaluating XPath expression: \" + xpathString, e, locationData);\n        } finally {\n            if (xpathExpression != null)\n                xpathExpression.returnToPool();\n        }\n    }","id":30928,"modified_method":"/**\n     * Evaluate an XPath expression on the document.\n     */\n    public static Object evaluateSingle(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString,\n                                 Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n\n        final PooledXPathExpression xpathExpression = XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition,\n                xpathString, prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false, locationData);\n        try {\n            return xpathExpression.evaluateSingleKeepNodeInfo();\n        } catch (XPathException e) {\n            throw handleXPathException(e, xpathString, \"evaluating XPath expression\", locationData);\n        } finally {\n            if (xpathExpression != null)\n                xpathExpression.returnToPool();\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Evaluate an XPath expression on the document as an attribute value template, and return its string value.\n     */\n    public static String evaluateAsAvt(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString, Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n        PooledXPathExpression xpathExpression = null;\n        try {\n            xpathExpression = XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition, xpathString,\n            prefixToURIMap, variableToValueMap, functionLibrary, baseURI, true, false);\n            return xpathExpression.evaluateSingleKeepNodeInfo().toString();\n        } catch (XPathException e) {\n            throw new ValidationException(\"Exception evaluating XPath expression: \" + xpathExpression, e, locationData);\n        } finally {\n            if (xpathExpression != null) xpathExpression.returnToPool();\n        }\n    }","id":30929,"modified_method":"/**\n     * Evaluate an XPath expression on the document as an attribute value template, and return its string value.\n     */\n    public static String evaluateAsAvt(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString, Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n        final PooledXPathExpression xpathExpression = XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition, xpathString,\n                prefixToURIMap, variableToValueMap, functionLibrary, baseURI, true, false, locationData);\n        try {\n            return xpathExpression.evaluateSingleKeepNodeInfo().toString();\n        } catch (XPathException e) {\n            throw handleXPathException(e, xpathString, \"evaluating XPath expression\", locationData);\n        } finally {\n            if (xpathExpression != null) xpathExpression.returnToPool();\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Evaluate an XPath expression on the document and return its string value.\n     */\n    public static String evaluateAsString(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString, Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n        PooledXPathExpression xpathExpression = null;\n        try {\n            xpathExpression =  XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition, \"string(subsequence(\" + xpathString + \", 1, 1))\",\n            prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false);\n            return xpathExpression.evaluateSingleKeepNodeInfo().toString();\n        } catch (XPathException e) {\n            throw new ValidationException(\"Exception evaluating XPath expression: \" + xpathExpression, e, locationData);\n        } finally {\n            if (xpathExpression != null) xpathExpression.returnToPool();\n        }\n    }","id":30930,"modified_method":"/**\n     * Evaluate an XPath expression on the document and return its string value.\n     */\n    public static String evaluateAsString(PipelineContext pipelineContext, List contextNodeSet, int contextPosition, String xpathString, Map prefixToURIMap, Map variableToValueMap, FunctionLibrary functionLibrary, String baseURI, LocationData locationData) {\n        final PooledXPathExpression xpathExpression =  XPathCache.getXPathExpression(pipelineContext, contextNodeSet, contextPosition, \"string(subsequence(\" + xpathString + \", 1, 1))\",\n                prefixToURIMap, variableToValueMap, functionLibrary, baseURI, false, false, locationData);\n        try {\n            return xpathExpression.evaluateSingleKeepNodeInfo().toString();\n        } catch (XPathException e) {\n            throw handleXPathException(e, xpathString, \"evaluating XPath expression\", locationData);\n        } finally {\n            if (xpathExpression != null) xpathExpression.returnToPool();\n        }\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.CacheableTransformerOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext context, ContentHandler contentHandler) {\n\n               Config config = (Config) readCacheInputAsObject(context, getInputByName(INPUT_CONFIG), new CacheableInputReader() {\n                    public Object read(PipelineContext context, final ProcessorInput input) {\n                        Document config = readInputAsDOM4J(context, INPUT_CONFIG);\n\n                        // Get declared namespaces\n                        Map namespaces = new HashMap();\n                        for (Iterator i = config.getRootElement().selectNodes(\"/config/namespace\").iterator(); i.hasNext();) {\n                            Element namespaceElement = (Element) i.next();\n                            namespaces.put(namespaceElement.attributeValue(\"prefix\"),\n                                    namespaceElement.attributeValue(\"uri\"));\n                        }\n                        return  new Config(namespaces, (String) config.selectObject(\"string(/config/xpath)\"));\n                    }\n                });\n\n                DocumentWrapper wrapper = new DocumentWrapper(readCacheInputAsDOM4J(context, INPUT_DATA), null, new Configuration());\n                PooledXPathExpression xpath = null;\n                try {\n                    final String baseURI = (locationData == null) ? null : locationData.getSystemID();\n                    xpath = XPathCache.getXPathExpression(context, wrapper, config.getExpression(), config.getNamespaces(), null, null, baseURI);\n                    List results = xpath.evaluate();\n                    contentHandler.startDocument();\n                    // WARNING: Here we break the rule that processors must output valid XML documents, because\n                    // we potentially output several root nodes. This works because the XPathProcessor is always\n                    // connected to an aggregator, which adds a new root node.\n                    for (Iterator i = results.iterator(); i.hasNext();) {\n                        Object result = i.next();\n                        if (result == null) continue;\n                        String strVal = null;\n\n                        if (result instanceof org.dom4j.Element || result instanceof org.dom4j.Document) {\n                            // If element or document, serialize it to content handler\n                            final org.dom4j.Element elt = result instanceof org.dom4j.Element\n                                    ? (org.dom4j.Element) result\n                                    : ((org.dom4j.Document) result).getRootElement();\n                            final String sid = Dom4jUtils.makeSystemId(elt);\n                            final DOMGenerator domGenerator = new DOMGenerator\n                                    (elt, \"xpath result doc\", DOMGenerator.ZeroValidity, sid);\n                            final ProcessorOutput domOutput = domGenerator.createOutput(OUTPUT_DATA);\n                            domOutput.read(context, new ForwardingContentHandler(contentHandler) {\n                                public void startDocument() {\n                                }\n\n                                public void endDocument() {\n                                }\n                            });\n                        } else if (result instanceof NodeInfo) {\n                            final NodeInfo nodeInfo = (NodeInfo) result;\n                            TransformerUtils.writeTinyTree(nodeInfo, new ForwardingContentHandler(contentHandler) {\n                                public void startDocument() {\n                                }\n\n                                public void endDocument() {\n                                }\n                            });\n                        } else if (result instanceof DefaultProcessingInstruction) {\n                            DefaultProcessingInstruction processingInstruction = (DefaultProcessingInstruction) result;\n                            contentHandler.processingInstruction(processingInstruction.getTarget(), processingInstruction.getText());\n                        } else if (result instanceof DefaultText) {\n                            strVal = ((DefaultText) result).getText();\n                        } else if (result instanceof String) {\n                            strVal = (String) result;\n                        } else if (result instanceof Double) {\n                            final double d = ((Double) result).doubleValue();\n                            strVal = XMLUtils.removeScientificNotation(d);\n                        } else if (result instanceof Boolean) {\n                            strVal = ((Boolean) result).toString();\n                        } else if (result instanceof org.orbeon.saxon.om.FastStringBuffer) {\n                            strVal = result.toString();\n                        } else {\n                            String message = \"Unsupported type returned by XPath expression: \"\n                                    + (result == null ? \"null\" : result.getClass().getName());\n                            throw new ValidationException(message, locationData);\n                        }\n\n                        // Send string representation of simple type to content handler\n                        if (strVal != null) {\n                            final char[] ch = strVal.toCharArray();\n                            final int len = strVal.length();\n                            contentHandler.characters( ch, 0, len );\n                        }\n                    }\n                    contentHandler.endDocument();\n                } catch (XPathException xpe) {\n                    throw new OXFException(xpe);\n                } catch (SAXException e) {\n                    throw new ValidationException(e, locationData);\n                }finally{\n                    if(xpath != null)\n                        xpath.returnToPool();\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","id":30931,"modified_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.CacheableTransformerOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext context, ContentHandler contentHandler) {\n\n               Config config = (Config) readCacheInputAsObject(context, getInputByName(INPUT_CONFIG), new CacheableInputReader() {\n                    public Object read(PipelineContext context, final ProcessorInput input) {\n                        Document config = readInputAsDOM4J(context, INPUT_CONFIG);\n\n                        // Get declared namespaces\n                        Map namespaces = new HashMap();\n                        for (Iterator i = config.getRootElement().selectNodes(\"/config/namespace\").iterator(); i.hasNext();) {\n                            Element namespaceElement = (Element) i.next();\n                            namespaces.put(namespaceElement.attributeValue(\"prefix\"),\n                                    namespaceElement.attributeValue(\"uri\"));\n                        }\n                        return  new Config(namespaces, (String) config.selectObject(\"string(/config/xpath)\"));\n                    }\n                });\n\n                DocumentWrapper wrapper = new DocumentWrapper(readCacheInputAsDOM4J(context, INPUT_DATA), null, new Configuration());\n                PooledXPathExpression xpath = null;\n                try {\n                    final String baseURI = (locationData == null) ? null : locationData.getSystemID();\n                    xpath = XPathCache.getXPathExpression(context, wrapper, config.getExpression(), config.getNamespaces(), null, null, baseURI, locationData);\n                    List results = xpath.evaluate();\n                    contentHandler.startDocument();\n                    // WARNING: Here we break the rule that processors must output valid XML documents, because\n                    // we potentially output several root nodes. This works because the XPathProcessor is always\n                    // connected to an aggregator, which adds a new root node.\n                    for (Iterator i = results.iterator(); i.hasNext();) {\n                        Object result = i.next();\n                        if (result == null) continue;\n                        String strVal = null;\n\n                        if (result instanceof org.dom4j.Element || result instanceof org.dom4j.Document) {\n                            // If element or document, serialize it to content handler\n                            final org.dom4j.Element elt = result instanceof org.dom4j.Element\n                                    ? (org.dom4j.Element) result\n                                    : ((org.dom4j.Document) result).getRootElement();\n                            final String sid = Dom4jUtils.makeSystemId(elt);\n                            final DOMGenerator domGenerator = new DOMGenerator\n                                    (elt, \"xpath result doc\", DOMGenerator.ZeroValidity, sid);\n                            final ProcessorOutput domOutput = domGenerator.createOutput(OUTPUT_DATA);\n                            domOutput.read(context, new ForwardingContentHandler(contentHandler) {\n                                public void startDocument() {\n                                }\n\n                                public void endDocument() {\n                                }\n                            });\n                        } else if (result instanceof NodeInfo) {\n                            final NodeInfo nodeInfo = (NodeInfo) result;\n                            TransformerUtils.writeTinyTree(nodeInfo, new ForwardingContentHandler(contentHandler) {\n                                public void startDocument() {\n                                }\n\n                                public void endDocument() {\n                                }\n                            });\n                        } else if (result instanceof DefaultProcessingInstruction) {\n                            DefaultProcessingInstruction processingInstruction = (DefaultProcessingInstruction) result;\n                            contentHandler.processingInstruction(processingInstruction.getTarget(), processingInstruction.getText());\n                        } else if (result instanceof DefaultText) {\n                            strVal = ((DefaultText) result).getText();\n                        } else if (result instanceof String) {\n                            strVal = (String) result;\n                        } else if (result instanceof Double) {\n                            final double d = ((Double) result).doubleValue();\n                            strVal = XMLUtils.removeScientificNotation(d);\n                        } else if (result instanceof Boolean) {\n                            strVal = ((Boolean) result).toString();\n                        } else if (result instanceof org.orbeon.saxon.om.FastStringBuffer) {\n                            strVal = result.toString();\n                        } else {\n                            String message = \"Unsupported type returned by XPath expression: \"\n                                    + (result == null ? \"null\" : result.getClass().getName());\n                            throw new ValidationException(message, locationData);\n                        }\n\n                        // Send string representation of simple type to content handler\n                        if (strVal != null) {\n                            final char[] ch = strVal.toCharArray();\n                            final int len = strVal.length();\n                            contentHandler.characters( ch, 0, len );\n                        }\n                    }\n                    contentHandler.endDocument();\n                } catch (XPathException xpe) {\n                    throw new OXFException(xpe);\n                } catch (SAXException e) {\n                    throw new ValidationException(e, locationData);\n                }finally{\n                    if(xpath != null)\n                        xpath.returnToPool();\n                }\n            }\n        };\n        addOutput(name, output);\n        return output;\n    }","commit_id":"f965f4e6201399f1fcbe7661e4912f3d0712fd6d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void mergeEnumerablePropertySource(EnumerablePropertySource enumerablePropertySource) {\n        Map<String, Object> map = new LinkedHashMap<String, Object>();\n        for(String propertyName : enumerablePropertySource.getPropertyNames()) {\n            Object value = enumerablePropertySource.getProperty(propertyName);\n            if(value instanceof ConfigObject) {\n                if(((ConfigObject)value).isEmpty()) continue;\n            }\n            if(value instanceof CharSequence) {\n                value = resolvePlaceholders(value.toString());\n            }\n            if(prefix != null) {\n                map.put(prefix + '.' + propertyName, value);\n            }\n            else {\n                map.put(propertyName, value);\n            }\n        }\n\n        configMap.merge(map, true);\n    }","id":30932,"modified_method":"private void mergeEnumerablePropertySource(EnumerablePropertySource enumerablePropertySource) {\n        Map<String, Object> map = new LinkedHashMap<String, Object>();\n        final boolean isNavigable = enumerablePropertySource instanceof NavigableMapPropertySource;\n        final String[] propertyNames = isNavigable ? ((NavigableMapPropertySource)enumerablePropertySource).getNavigablePropertyNames() : enumerablePropertySource.getPropertyNames();\n        for(String propertyName : propertyNames) {\n            Object value;\n            if(isNavigable) {\n                value = ((NavigableMapPropertySource)enumerablePropertySource).getNavigableProperty(propertyName);\n            }\n            else {\n                value = enumerablePropertySource.getProperty(propertyName);\n            }\n            if(value instanceof ConfigObject) {\n                if(((ConfigObject)value).isEmpty()) continue;\n            }\n            if(value instanceof CharSequence) {\n                value = resolvePlaceholders(value.toString());\n            }\n            if(prefix != null) {\n                map.put(prefix + '.' + propertyName, value);\n            }\n            else {\n                map.put(propertyName, value);\n            }\n        }\n\n        configMap.merge(map, true);\n    }","commit_id":"6d18f8326b06a020aeb36f483dfb0cacceef010f","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Check to see if this property source contains a property with the given name, or\n\t * any underscore / uppercase variation thereof. Return the resolved name if one is\n\t * found or otherwise the original name. Never returns {@code null}.\n\t */\n\tprivate String resolvePropertyName(String name) {\n\t\tAssert.notNull(name, \"Property name must not be null\");\n\t\tif (ObjectUtils.containsElement(getPropertyNames(), name)) {\n\t\t\treturn name;\n\t\t}\n\n\t\tString usName = name.replace('.', '_');\n\t\tif (!name.equals(usName) && ObjectUtils.containsElement(getPropertyNames(), usName)) {\n\t\t\treturn usName;\n\t\t}\n\n\t\tString ucName = name.toUpperCase();\n\t\tif (!name.equals(ucName)) {\n\t\t\tif (ObjectUtils.containsElement(getPropertyNames(), ucName)) {\n\t\t\t\treturn ucName;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString usUcName = ucName.replace('.', '_');\n\t\t\t\tif (!ucName.equals(usUcName) && ObjectUtils.containsElement(getPropertyNames(), usUcName)) {\n\t\t\t\t\treturn usUcName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn name;\n\t}","id":30933,"modified_method":"/**\n\t * Check to see if this property source contains a property with the given name, or\n\t * any underscore / uppercase variation thereof. Return the resolved name if one is\n\t * found or otherwise the original name. Never returns {@code null}.\n\t */\n\tprivate String resolvePropertyName(String name) {\n\t\tAssert.notNull(name, \"Property name must not be null\");\n\t\ttry {\n\t\t\tString[] propertyNames = (this.usePropertyNames ? getPropertyNames() : null);\n\t\t\tif (containsProperty(propertyNames, name)) {\n\t\t\t\treturn name;\n\t\t\t}\n\n\t\t\tString usName = name.replace('.', '_');\n\t\t\tif (!name.equals(usName) && containsProperty(propertyNames, usName)) {\n\t\t\t\treturn usName;\n\t\t\t}\n\n\t\t\tString ucName = name.toUpperCase();\n\t\t\tif (!name.equals(ucName)) {\n\t\t\t\tif (containsProperty(propertyNames, ucName)) {\n\t\t\t\t\treturn ucName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString usUcName = ucName.replace('.', '_');\n\t\t\t\t\tif (!ucName.equals(usUcName) && containsProperty(propertyNames, usUcName)) {\n\t\t\t\t\t\treturn usUcName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn name;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tif (this.usePropertyNames) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.usePropertyNames = true;\n\t\t\t\treturn resolvePropertyName(name);\n\t\t\t}\n\t\t}\n\t}","commit_id":"752574de1d529eb9eff413b0bffc2c51b5180012","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Read an event from the repository.\n     * @return\n     * @throws RepositoryException\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */\n    protected Event readEvent(Node eventNode)\n    throws RepositoryException, ClassNotFoundException {\n        final String topic = eventNode.getProperty(EventHelper.NODE_PROPERTY_TOPIC).getString();\n        final Map<String, Object> properties = EventUtil.readProperties(eventNode,\n                EventHelper.NODE_PROPERTY_PROPERTIES,\n                IGNORE_PREFIXES);\n\n        final Dictionary<String, Object> eventProps = new Hashtable<String, Object>(properties);\n        this.addEventProperties(eventNode, eventProps);\n        try {\n            final Event event = new Event(topic, eventProps);\n            return event;\n        } catch (IllegalArgumentException iae) {\n            // this exception occurs if the topic is not correct (it should never happen,\n            // but you never know)\n            throw new RepositoryException(\"Unable to read event: \" + iae.getMessage(), iae);\n        }\n    }","id":30934,"modified_method":"/**\n     * Read an event from the repository.\n     * @return\n     * @throws RepositoryException\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */\n    protected Event readEvent(Node eventNode)\n    throws RepositoryException, ClassNotFoundException {\n        final String topic = eventNode.getProperty(EventHelper.NODE_PROPERTY_TOPIC).getString();\n        final EventPropertiesMap eventProps = EventUtil.readProperties(eventNode,\n                EventHelper.NODE_PROPERTY_PROPERTIES,\n                IGNORE_PREFIXES);\n\n        this.addEventProperties(eventNode, eventProps);\n        try {\n            final Event event = new Event(topic, eventProps);\n            return event;\n        } catch (IllegalArgumentException iae) {\n            // this exception occurs if the topic is not correct (it should never happen,\n            // but you never know)\n            throw new RepositoryException(\"Unable to read event: \" + iae.getMessage(), iae);\n        }\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    public int hashCode() {\n        return this.event.hashCode();\n    }","id":30935,"modified_method":"/**\n     * @see java.lang.Object#hashCode()\n     */\n    public int hashCode() {\n        return delegatee.hashCode();\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#isEmpty()\n     */\n    public boolean isEmpty() {\n        return this.isEmpty;\n    }","id":30936,"modified_method":"/**\n     * @see java.util.Dictionary#isEmpty()\n     */\n    public boolean isEmpty() {\n        return delegatee.isEmpty();\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#size()\n     */\n    public int size() {\n        return (this.isEmpty ? 0 : this.event.getPropertyNames().length);\n    }","id":30937,"modified_method":"/**\n     * @see java.util.Dictionary#size()\n     */\n    public int size() {\n        return delegatee.size();\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"public EventPropertiesMap(final Event event) {\n        this.event = event;\n        this.isEmpty = (event.getPropertyNames() == null || event.getPropertyNames().length == 0);\n    }","id":30938,"modified_method":"/**\n     * Construct a new map out of an event object.\n     * The resulting map is unmodifiable.\n     * @param event The event object.\n     */\n    public EventPropertiesMap(final Event event) {\n        // create a map out of the event properties\n        final Map<String, Object> props = new HashMap<String, Object>();\n        if ( event.getPropertyNames() != null ) {\n            for(final String key : event.getPropertyNames() ) {\n                props.put(key, event.getProperty(key));\n            }\n        }\n        this.delegatee = Collections.unmodifiableMap(props);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#containsValue(java.lang.Object)\n     */\n    public boolean containsValue(Object value) {\n        if ( this.isEmpty ) {\n            return false;\n        }\n        final String[] names = this.event.getPropertyNames();\n        for(final String name : names) {\n            if ( this.event.getProperty(name).equals(value) ) {\n                return true;\n            }\n        }\n        return false;\n    }","id":30939,"modified_method":"/**\n     * @see java.util.Map#containsValue(java.lang.Object)\n     */\n    public boolean containsValue(Object value) {\n        return delegatee.containsValue(value);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#putAll(java.util.Map)\n     */\n    public void putAll(Map<? extends String, ? extends Object> t) {\n        throw new UnsupportedOperationException(\"putAll is not supported.\");\n    }","id":30940,"modified_method":"/**\n     * @see java.util.Map#putAll(java.util.Map)\n     */\n    public void putAll(Map<? extends String, ? extends Object> t) {\n        delegatee.putAll(t);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#keySet()\n     */\n    public Set<String> keySet() {\n        if ( this.isEmpty ) {\n            return Collections.emptySet();\n        }\n        final Set<String> set = new HashSet<String>();\n        set.addAll(Arrays.asList(this.event.getPropertyNames()));\n        return set;\n    }","id":30941,"modified_method":"/**\n     * @see java.util.Map#keySet()\n     */\n    public Set<String> keySet() {\n        return delegatee.keySet();\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#put(java.lang.Object, java.lang.Object)\n     */\n    public Object put(String key, Object value) {\n        throw new UnsupportedOperationException(\"put is not supported.\");\n    }","id":30942,"modified_method":"/**\n     * @see java.util.Dictionary#put(java.lang.Object, java.lang.Object)\n     */\n    public Object put(String key, Object value) {\n        return delegatee.put(key, value);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#entrySet()\n     */\n    public Set<Map.Entry<String, Object>> entrySet() {\n        if ( this.isEmpty ) {\n            return Collections.emptySet();\n        }\n        final Set<Map.Entry<String, Object>> set = new HashSet<Map.Entry<String,Object>>();\n        final String[] names = event.getPropertyNames();\n        for(final String key : names) {\n            set.add(new PropertyEntry(key, this.event.getProperty(key)));\n        }\n        return set;\n    }","id":30943,"modified_method":"/**\n     * @see java.util.Map#entrySet()\n     */\n    public Set<java.util.Map.Entry<String, Object>> entrySet() {\n        return delegatee.entrySet();\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#clear()\n     */\n    public void clear() {\n        throw new UnsupportedOperationException(\"clear is not supported.\");\n    }","id":30944,"modified_method":"/**\n     * @see java.util.Map#clear()\n     */\n    public void clear() {\n        delegatee.clear();\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#values()\n     */\n    public Collection<Object> values() {\n        if ( this.isEmpty ) {\n            return Collections.emptySet();\n        }\n        final Set<Object> set = new HashSet<Object>();\n        final String[] names = this.event.getPropertyNames();\n        for(final String name : names) {\n            set.add(this.event.getProperty(name));\n        }\n        return set;\n    }","id":30945,"modified_method":"/**\n     * @see java.util.Map#values()\n     */\n    public Collection<Object> values() {\n        return delegatee.values();\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#containsKey(java.lang.Object)\n     */\n    public boolean containsKey(Object key) {\n        if ( this.isEmpty || key == null ) {\n            return false;\n        }\n        final String[] names = this.event.getPropertyNames();\n        for(final String name : names) {\n            if ( name.equals(key) ) {\n                return true;\n            }\n        }\n        return false;\n    }","id":30946,"modified_method":"/**\n     * @see java.util.Map#containsKey(java.lang.Object)\n     */\n    public boolean containsKey(Object key) {\n        return delegatee.containsKey(key);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#remove(java.lang.Object)\n     */\n    public Object remove(Object key) {\n        throw new UnsupportedOperationException(\"remove is not supported.\");\n    }","id":30947,"modified_method":"/**\n     * @see java.util.Dictionary#remove(java.lang.Object)\n     */\n    public Object remove(Object key) {\n        return delegatee.remove(key);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.util.Map#get(java.lang.Object)\n     */\n    public Object get(Object key) {\n        return (this.isEmpty || key == null ? null : this.event.getProperty(key.toString()));\n    }","id":30948,"modified_method":"/**\n     * @see java.util.Dictionary#get(java.lang.Object)\n     */\n    public Object get(Object key) {\n        return delegatee.get(key);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    public boolean equals(Object o) {\n        if ( o instanceof EventPropertiesMap ) {\n            return this.event.equals(((EventPropertiesMap)o).event);\n        }\n        return false;\n    }","id":30949,"modified_method":"/**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    public boolean equals(Object o) {\n        return delegatee.equals(o);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Read properties from a repository node and create a property map.\n     * @throws RepositoryException\n     * @throws ClassNotFoundException\n     */\n    public static Map<String, Object> readProperties(final Node node,\n                                                     final String binPropertyName,\n                                                     final List<String> ignorePrefixes)\n    throws RepositoryException, ClassNotFoundException {\n        final Map<String, Object> properties = new HashMap<String, Object>();\n\n        // check the properties blob\n        if ( node.hasProperty(binPropertyName) ) {\n            try {\n                final ObjectInputStream ois = new ObjectInputStream(node.getProperty(binPropertyName).getStream());\n                int length = ois.readInt();\n                for(int i=0;i<length;i++) {\n                    final String key = (String)ois.readObject();\n                    final Object value = ois.readObject();\n                    properties.put(key, value);\n                }\n            } catch (IOException ioe) {\n                throw new RepositoryException(\"Unable to deserialize event properties.\", ioe);\n            }\n        }\n        // now all properties that have been set directly\n        final PropertyIterator pI = node.getProperties();\n        while ( pI.hasNext() ) {\n            final Property p = pI.nextProperty();\n            if ( !p.getName().startsWith(\"jcr:\") &&\n                 (ignorePrefixes == null || !ignorePrefixes.contains(p.getName())))  {\n                final String name = ISO9075.decode(p.getName());\n                final Value value = p.getValue();\n                final Object o;\n                switch (value.getType()) {\n                    case PropertyType.BOOLEAN:\n                        o = value.getBoolean(); break;\n                    case PropertyType.DATE:\n                        o = value.getDate(); break;\n                    case PropertyType.DOUBLE:\n                        o = value.getDouble(); break;\n                    case PropertyType.LONG:\n                        o = value.getLong(); break;\n                    case PropertyType.STRING:\n                        o = value.getString(); break;\n                    default: // this should never happen - we convert to a string...\n                        o = value.getString();\n                }\n                properties.put(name, o);\n            }\n        }\n        return properties;\n    }","id":30950,"modified_method":"/**\n     * Read properties from a repository node and create a property map.\n     * @throws RepositoryException\n     * @throws ClassNotFoundException\n     */\n    public static EventPropertiesMap readProperties(final Node node,\n                                                    final String binPropertyName,\n                                                    final List<String> ignorePrefixes)\n    throws RepositoryException, ClassNotFoundException {\n        final Map<String, Object> properties = new HashMap<String, Object>();\n\n        // check the properties blob\n        if ( node.hasProperty(binPropertyName) ) {\n            try {\n                final ObjectInputStream ois = new ObjectInputStream(node.getProperty(binPropertyName).getStream());\n                int length = ois.readInt();\n                for(int i=0;i<length;i++) {\n                    final String key = (String)ois.readObject();\n                    final Object value = ois.readObject();\n                    properties.put(key, value);\n                }\n            } catch (IOException ioe) {\n                throw new RepositoryException(\"Unable to deserialize event properties.\", ioe);\n            }\n        }\n        // now all properties that have been set directly\n        final PropertyIterator pI = node.getProperties();\n        while ( pI.hasNext() ) {\n            final Property p = pI.nextProperty();\n            if ( !p.getName().startsWith(\"jcr:\") &&\n                 (ignorePrefixes == null || !ignorePrefixes.contains(p.getName())))  {\n                final String name = ISO9075.decode(p.getName());\n                final Value value = p.getValue();\n                final Object o;\n                switch (value.getType()) {\n                    case PropertyType.BOOLEAN:\n                        o = value.getBoolean(); break;\n                    case PropertyType.DATE:\n                        o = value.getDate(); break;\n                    case PropertyType.DOUBLE:\n                        o = value.getDouble(); break;\n                    case PropertyType.LONG:\n                        o = value.getLong(); break;\n                    case PropertyType.STRING:\n                        o = value.getString(); break;\n                    default: // this should never happen - we convert to a string...\n                        o = value.getString();\n                }\n                properties.put(name, o);\n            }\n        }\n        return new EventPropertiesMap(properties);\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Add all java properties as properties to the node.\n     * If the name and the value of a map entry can easily converted into\n     * a repository property, it is directly added. All other java\n     * properties are stored in one binary property.\n     *\n     * @param node The node where all properties are added to\n     * @param properties The map of properties.\n     * @param ignoreProps optional list of property which should be ignored\n     * @param binPropertyName The name of the binary property.\n     * @throws RepositoryException\n     */\n    public static void addProperties(final Node node,\n                                     final Map<String, Object> properties,\n                                     final List<String> ignoreProps,\n                                     final String binPropertyName)\n    throws RepositoryException {\n        if ( properties != null ) {\n            // check which props we can write directly and\n            // which we need to write as a binary blob\n            final List<String> propsAsBlob = new ArrayList<String>();\n\n            final Iterator<Map.Entry<String, Object>> i = properties.entrySet().iterator();\n            while ( i.hasNext() ) {\n                final Map.Entry<String, Object> current = i.next();\n\n                if (ignoreProps == null || !ignoreProps.contains(current.getKey()) ) {\n                    // sanity check\n                    if ( current.getValue() != null ) {\n                        if ( !setProperty(current.getKey(), current.getValue(), node) ) {\n                            propsAsBlob.add(current.getKey());\n                        }\n                    }\n                }\n            }\n            // write the remaining properties as a blob\n            if ( propsAsBlob.size() > 0 ) {\n                try {\n                    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    final ObjectOutputStream oos = new ObjectOutputStream(baos);\n                    oos.writeInt(propsAsBlob.size());\n                    for(final String propName : propsAsBlob) {\n                        oos.writeObject(propName);\n                        oos.writeObject(properties.get(propName));\n                    }\n                    oos.close();\n                    node.setProperty(binPropertyName, new ByteArrayInputStream(baos.toByteArray()));\n                } catch (IOException ioe) {\n                    throw new RepositoryException(\"Unable to serialize properties.\", ioe);\n                }\n            }\n        }\n    }","id":30951,"modified_method":"/**\n     * Add all java properties as properties to the node.\n     * If the name and the value of a map entry can easily converted into\n     * a repository property, it is directly added. All other java\n     * properties are stored in one binary property.\n     *\n     * @param node The node where all properties are added to\n     * @param properties The map of properties.\n     * @param ignoreProps optional list of property which should be ignored\n     * @param binPropertyName The name of the binary property.\n     * @throws RepositoryException\n     */\n    public static void addProperties(final Node node,\n                                     final EventPropertiesMap properties,\n                                     final List<String> ignoreProps,\n                                     final String binPropertyName)\n    throws RepositoryException {\n        if ( properties != null ) {\n            // check which props we can write directly and\n            // which we need to write as a binary blob\n            final List<String> propsAsBlob = new ArrayList<String>();\n\n            final Iterator<Map.Entry<String, Object>> i = properties.entrySet().iterator();\n            while ( i.hasNext() ) {\n                final Map.Entry<String, Object> current = i.next();\n\n                if (ignoreProps == null || !ignoreProps.contains(current.getKey()) ) {\n                    // sanity check\n                    if ( current.getValue() != null ) {\n                        if ( !setProperty(current.getKey(), current.getValue(), node) ) {\n                            propsAsBlob.add(current.getKey());\n                        }\n                    }\n                }\n            }\n            // write the remaining properties as a blob\n            if ( propsAsBlob.size() > 0 ) {\n                try {\n                    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    final ObjectOutputStream oos = new ObjectOutputStream(baos);\n                    oos.writeInt(propsAsBlob.size());\n                    for(final String propName : propsAsBlob) {\n                        oos.writeObject(propName);\n                        oos.writeObject(properties.get(propName));\n                    }\n                    oos.close();\n                    node.setProperty(binPropertyName, new ByteArrayInputStream(baos.toByteArray()));\n                } catch (IOException ioe) {\n                    throw new RepositoryException(\"Unable to serialize properties.\", ioe);\n                }\n            }\n        }\n    }","commit_id":"8a752d43c9ddb3bfdf251420dfffff70aabd89cc","url":"https://github.com/apache/sling"},{"original_method":"private boolean isInNestedEditingContext() {\n\t  EOEditingContext attachmentEc = editingContext();\n\t  // NOTE: (code snippet borrowed from ERXGenericRecord)\n\t  return (attachmentEc.parentObjectStore() instanceof EOEditingContext && \n\t\t\t  ((EOEditingContext)attachmentEc.parentObjectStore()).objectForGlobalID(attachmentEc.globalIDForObject(this)) != null);\n  }","id":30952,"modified_method":"private boolean isInNestedEditingContext() {\n\t  return isInNestedEditingContext(editingContext());\n  }","commit_id":"2f44bc43636e02ec7d3a474d1c2e90ebc4879fad","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n  public void didDelete(EOEditingContext ec) {\n    super.didDelete(ec);\n    if (!isInNestedEditingContext()) {\n    \ttry {\n    \t\tERAttachmentProcessor.processorForType(this).deleteAttachment(this);\n    \t}\n    \tcatch (Throwable e) {\n    \t\tERAttachment.log.error(\"Failed to delete attachment '\" + primaryKey() + \"'.\", e);\n    \t}\n    }\n  }","id":30953,"modified_method":"@Override\n  public void didDelete(EOEditingContext ec) {\n    super.didDelete(ec);\n    if (!isInNestedEditingContext(ec)) {\n    \ttry {\n    \t\tERAttachmentProcessor.processorForType(this).deleteAttachment(this);\n    \t}\n    \tcatch (Throwable e) {\n    \t\tERAttachment.log.error(\"Failed to delete attachment '\" + primaryKey() + \"'.\", e);\n    \t}\n    }\n  }","commit_id":"2f44bc43636e02ec7d3a474d1c2e90ebc4879fad","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void updateSourceObject(NSArray newValues) {\n        // If no selections are choosen then newValues is null.\n        newValues = newValues != null ? newValues : NSArray.EmptyArray;\n        String masterKey = _localRelationshipKey();\n        Object aSourceObject = _localSourceObject();\n        boolean isDictionary = (aSourceObject instanceof NSMutableDictionary);\n        NSMutableDictionary _dictionary = (isDictionary) ? (NSMutableDictionary)aSourceObject : null;\n        EOEnterpriseObject _eo = !(isDictionary) ? (EOEnterpriseObject)aSourceObject : null;\n        newValues = ERXEOControlUtilities.localInstancesOfObjects(_eo.editingContext(), newValues);\n        // Need to handle the keyPath situation.\n        if (_eo != null && masterKey.indexOf(\".\") != -1) {\n            String partialKeyPath=ERXStringUtilities.keyPathWithoutLastProperty(masterKey);\n            _eo = (EOEnterpriseObject)_eo.valueForKeyPath(partialKeyPath);\n            masterKey = ERXStringUtilities.lastPropertyKeyInKeyPath(masterKey);\n        }\n        NSArray currentValues = (NSArray)NSKeyValueCodingAdditions.Utility.valueForKeyPath(_eo, masterKey);\n        NSMutableArray mutableCurrentValues;\n        if(currentValues instanceof NSMutableArray) {\n            mutableCurrentValues = (NSMutableArray)currentValues;\n        } else {\n            mutableCurrentValues = currentValues.mutableClone();\n            NSKeyValueCodingAdditions.Utility.takeValueForKeyPath(_eo, mutableCurrentValues, masterKey);\n        }\n        int count = mutableCurrentValues.count();\n        EOEnterpriseObject o;\n        for (int i = count - 1; i >= 0; i--) {\n            o = (EOEnterpriseObject)mutableCurrentValues.objectAtIndex(i);\n            if ((null==newValues) || (newValues.indexOfIdenticalObject(o) == NSArray.NotFound)) { // not found\n                if (isDictionary) {\n                    mutableCurrentValues.removeObject(o);\n                }\n                else {\n                    _eo.removeObjectFromBothSidesOfRelationshipWithKey(o, masterKey);\n                }\n            }\n        }\n        count = newValues.count();\n        if ((isDictionary) && (mutableCurrentValues==null)) {\n            mutableCurrentValues = new NSMutableArray(count);\n            _dictionary.setObjectForKey(currentValues, masterKey);\n        }\n        for (int i = count - 1; i >= 0; i--) {\n            o = (EOEnterpriseObject)newValues.objectAtIndex(i);\n            if ((null==mutableCurrentValues) || (mutableCurrentValues.indexOfIdenticalObject(o) == NSArray.NotFound)) {  // not found\n                if (isDictionary) {\n                    mutableCurrentValues.addObject(o);\n                } else {\n                    _eo.addObjectToBothSidesOfRelationshipWithKey(o, masterKey);\n                }\n            }\n        }\n    }","id":30954,"modified_method":"public void updateSourceObject(NSArray newValues) {\n        // If no selections are choosen then newValues is null.\n        newValues = newValues != null ? newValues : NSArray.EmptyArray;\n        String masterKey = _localRelationshipKey();\n        Object aSourceObject = _localSourceObject();\n        boolean isDictionary = (aSourceObject instanceof NSMutableDictionary);\n        NSMutableDictionary _dictionary = (isDictionary) ? (NSMutableDictionary)aSourceObject : null;\n        EOEnterpriseObject _eo = !(isDictionary) ? (EOEnterpriseObject)aSourceObject : null;\n        EOEditingContext ec;\n        if(_localSourceObjectIsEO() && _eo.editingContext() != null)\n            ec = _eo.editingContext();\n        else\n            ec = session().defaultEditingContext();\n        newValues = ERXEOControlUtilities.localInstancesOfObjects(ec, newValues);\n        // Need to handle the keyPath situation.\n        if (_eo != null && masterKey.indexOf(\".\") != -1) {\n            String partialKeyPath=ERXStringUtilities.keyPathWithoutLastProperty(masterKey);\n            _eo = (EOEnterpriseObject)_eo.valueForKeyPath(partialKeyPath);\n            masterKey = ERXStringUtilities.lastPropertyKeyInKeyPath(masterKey);\n        }\n        NSArray currentValues = (NSArray)NSKeyValueCodingAdditions.Utility.valueForKeyPath(aSourceObject, masterKey);\n        NSMutableArray mutableCurrentValues;\n        if(currentValues instanceof NSMutableArray) {\n            mutableCurrentValues = (NSMutableArray)currentValues;\n        } else {\n            if(currentValues != null) {\n                mutableCurrentValues = currentValues.mutableClone();\n            } else {\n                mutableCurrentValues = new NSMutableArray();\n            }\n            NSKeyValueCodingAdditions.Utility.takeValueForKeyPath(aSourceObject, mutableCurrentValues, masterKey);\n        }\n        int count = mutableCurrentValues.count();\n        EOEnterpriseObject o;\n        for (int i = count - 1; i >= 0; i--) {\n            o = (EOEnterpriseObject)mutableCurrentValues.objectAtIndex(i);\n            if ((null==newValues) || (newValues.indexOfIdenticalObject(o) == NSArray.NotFound)) { // not found\n                if (isDictionary) {\n                    mutableCurrentValues.removeObject(o);\n                }\n                else {\n                    _eo.removeObjectFromBothSidesOfRelationshipWithKey(o, masterKey);\n                }\n            }\n        }\n        count = newValues.count();\n        if ((isDictionary) && (mutableCurrentValues==null)) {\n            mutableCurrentValues = new NSMutableArray(count);\n            _dictionary.setObjectForKey(currentValues, masterKey);\n        }\n        for (int i = count - 1; i >= 0; i--) {\n            o = (EOEnterpriseObject)newValues.objectAtIndex(i);\n            if ((null==mutableCurrentValues) || (mutableCurrentValues.indexOfIdenticalObject(o) == NSArray.NotFound)) {  // not found\n                if (isDictionary) {\n                    mutableCurrentValues.addObject(o);\n                } else {\n                    _eo.addObjectToBothSidesOfRelationshipWithKey(o, masterKey);\n                }\n            }\n        }\n    }","commit_id":"071123679adde7ffd977d8cfcca4b39374af230f","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray theList() {\n        NSMutableArray aSortedArray;\n        NSArray anUnsortedArray;\n        if (_privateList()==null) {\n            EODataSource aDataSource = _localDataSource();\n            // Need to make sure that the eos are in the right editingContext.\n            anUnsortedArray = ERXEOControlUtilities.localInstancesOfObjects(((EOEnterpriseObject)sourceObject()).editingContext(), aDataSource.fetchObjects());\n            // 81398 sort contents\n            aSortedArray = new NSMutableArray(anUnsortedArray);\n\n            ERXArrayUtilities.sortArrayWithKey(aSortedArray, _localSortKey());\n\n            // if there is a value on the EO, then we need to make sure that the list's EOs are in the same EC\n            // otherwise the popup selection will be wrong (will default to the first element)\n            // this happens for ex on a wizard page with a popup. Select sth in the popup, but leave a mandatory field blank\n            // click next --> the page comes back with the error, but the popup lost the selection you made\n            if (_localSourceObject() instanceof EOEnterpriseObject &&\n                ((EOEnterpriseObject)_localSourceObject()).valueForKeyPath(_localRelationshipKey()) != null) {\n                NSMutableArray localArray= new NSMutableArray();\n                EOEnterpriseObject eo;\n                EOEditingContext ec = ((EOEnterpriseObject)_localSourceObject()).editingContext();\n                for (Enumeration e = aSortedArray.objectEnumerator(); e.hasMoreElements();) {\n                    eo = (EOEnterpriseObject)e.nextElement();\n                    localArray.addObject((ec != eo.editingContext() && ERXEOControlUtilities.localInstanceOfObject(ec, eo) != null ?\n                                          ERXEOControlUtilities.localInstanceOfObject(ec, eo) : eo));\n                }\n                aSortedArray=localArray;\n            }\n            set_privateList(aSortedArray);\n        }\n        return _privateList();\n    }","id":30955,"modified_method":"public NSArray theList() {\n        NSMutableArray aSortedArray;\n        NSArray anUnsortedArray;\n        if (_privateList()==null) {\n            EODataSource aDataSource = _localDataSource();\n            // Need to make sure that the eos are in the right editingContext.\n            EOEditingContext ec;\n            \n            if(_localSourceObjectIsEO() && ((EOEnterpriseObject)_sourceObject).editingContext() != null)\n                ec = ((EOEnterpriseObject)_sourceObject).editingContext();\n            else\n                ec = session().defaultEditingContext();\n            anUnsortedArray = ERXEOControlUtilities.localInstancesOfObjects(ec, aDataSource.fetchObjects());\n            // 81398 sort contents\n            aSortedArray = new NSMutableArray(anUnsortedArray);\n\n            ERXArrayUtilities.sortArrayWithKey(aSortedArray, _localSortKey());\n\n            // if there is a value on the EO, then we need to make sure that the list's EOs are in the same EC\n            // otherwise the popup selection will be wrong (will default to the first element)\n            // this happens for ex on a wizard page with a popup. Select sth in the popup, but leave a mandatory field blank\n            // click next --> the page comes back with the error, but the popup lost the selection you made\n            if (_localSourceObject() instanceof EOEnterpriseObject &&\n                ((EOEnterpriseObject)_localSourceObject()).valueForKeyPath(_localRelationshipKey()) != null) {\n                NSMutableArray localArray= new NSMutableArray();\n                EOEnterpriseObject eo;\n                for (Enumeration e = aSortedArray.objectEnumerator(); e.hasMoreElements();) {\n                    eo = (EOEnterpriseObject)e.nextElement();\n                    localArray.addObject((ec != eo.editingContext() && ERXEOControlUtilities.localInstanceOfObject(ec, eo) != null ?\n                                          ERXEOControlUtilities.localInstanceOfObject(ec, eo) : eo));\n                }\n                aSortedArray=localArray;\n            }\n            set_privateList(aSortedArray);\n        }\n        return _privateList();\n    }","commit_id":"071123679adde7ffd977d8cfcca4b39374af230f","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static ERXDatabaseContextDelegate defaultDelegate() {\n        if (_defaultDelegate == null) {\n            _defaultDelegate = new ERXDatabaseContextDelegate();\n            cat.info(\"created default delegate\");\n            ERXRetainer.retain(_defaultDelegate); // Retaining the delegate on the ObjC side.  This might not be necessary.\n        }\n        return _defaultDelegate;\n    }","id":30956,"modified_method":"/** Returns the singleton of the database context delegate */\n    public static ERXDatabaseContextDelegate defaultDelegate() {\n        if (_defaultDelegate == null) {\n            _defaultDelegate = new ERXDatabaseContextDelegate();\n            cat.info(\"Created default delegate\");\n            ERXRetainer.retain(_defaultDelegate); // Retaining the delegate on the ObjC side.  This might not be necessary.\n        }\n        return _defaultDelegate;\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSDictionary databaseContextNewPrimaryKey(EODatabaseContext aDatabaseContext, Object object, EOEntity anEntity) {\n        return object instanceof ERXGeneratesPrimaryKeyInterface ? ((ERXGeneratesPrimaryKeyInterface)object).primaryKeyDictionary(true) : null;\n    }","id":30957,"modified_method":"/**\n     * Provides the ability for new enterprise objects that implement the interface {@link ERXGeneratesPrimaryKeyInterface}\n     * to provide their own primary key dictionary. If the enterprise object implements the above interface then the\n     * method <code>primaryKeyDictionary(true)<\/code> will be called on the object. If the object returns null then a\n     * primary key will be generated for the object in the usual fashion.\n     * @param databaseContext databasecontext\n     * @param object the new enterprise object\n     * @param entity the entity of the object\n     * @return primary key dictionary to be used or null if a primary key should be generated for the object.\n     */\n    public NSDictionary databaseContextNewPrimaryKey(EODatabaseContext databaseContext, Object object, EOEntity entity) {\n        return object instanceof ERXGeneratesPrimaryKeyInterface ? ((ERXGeneratesPrimaryKeyInterface)object).primaryKeyDictionary(true) : null;\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean databaseContextShouldHandleDatabaseException(EODatabaseContext dbc, Exception e) throws Throwable {\n        EOAdaptor adaptor=dbc.adaptorContext().adaptor();\n        boolean shouldHandleConnection = false;\n        if(e instanceof EOGeneralAdaptorException)\n            cat.info(((EOGeneralAdaptorException)e).userInfo());\n        else\n            cat.info(e);\n        if (adaptor.isDroppedConnectionException(e))\n            shouldHandleConnection = true;\n        else if (e.toString().indexOf(\"ORA-01041\")!=-1) {\n            // just returning true here does not seem to do the trick. why !?!?\n            cat.error(\"ORA-01041 detecting -- forcing reconnect\");\n            dbc.database().handleDroppedConnection();\n            shouldHandleConnection = false;\n        } else {\n            if(e instanceof EOGeneralAdaptorException)\n                cat.info(((EOGeneralAdaptorException)e).userInfo());\n            throw e;\n        }\n        return shouldHandleConnection;\n    }","id":30958,"modified_method":"/**\n     * Allows custom handling of dropped connection exceptions. This was needed in WebObjects 4.5 because the\n     * OracleEOAdaptor wouldn't correctly handle all exceptions of dropped connections. This may not be needed\n     * now.\n     * @param dbc current database context\n     * @param e throw exception\n     * @return if the exception is one of the bad ones that isn't handled then the method <code>handleDroppedConnection<\/code>\n     *         is called directly on the database object of the context and <code>false<\/code> is returned otherwise <code>true<\/code>.\n     */\n    // CHECKME: Is this still needed now?\n    public boolean databaseContextShouldHandleDatabaseException(EODatabaseContext dbc, Exception e) throws Throwable {\n        EOAdaptor adaptor=dbc.adaptorContext().adaptor();\n        boolean shouldHandleConnection = false;\n        if(e instanceof EOGeneralAdaptorException)\n            cat.error(((EOGeneralAdaptorException)e).userInfo());\n        else\n            cat.error(e);\n        if (adaptor.isDroppedConnectionException(e))\n            shouldHandleConnection = true;\n        // FIXME: Should provide api to extend the list of bad exceptions.\n        else if (e.toString().indexOf(\"ORA-01041\")!=-1) {\n            // just returning true here does not seem to do the trick. why !?!?\n            cat.error(\"ORA-01041 detecting -- forcing reconnect\");\n            dbc.database().handleDroppedConnection();\n            shouldHandleConnection = false;\n        } else {\n            if(e instanceof EOGeneralAdaptorException)\n                cat.info(((EOGeneralAdaptorException)e).userInfo());\n            throw e;\n        }\n        return shouldHandleConnection;\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void databaseContextDidSelectObjects(EODatabaseContext dc,\n                                                EOFetchSpecification fs,\n                                                EODatabaseChannel channel) {\n        if (dbCat.isDebugEnabled()) {\n            dbCat.debug(\"databaseContextDidSelectObjects \"+fs);\n        }\n    }","id":30959,"modified_method":"/**\n     * This delegate method is called every time a fault is fired that needs\n     * to go to the database. All we have added is logging statement of the\n     * debug priority. This way during runtime a developer can toggle the\n     * logger priority settting on and off to see what faults are firing. Also\n     * note that when using {@link ERXPatternLayout} one can set the option to\n     * see full backtraces to the calling method. With this option specified\n     * a developer can see exactly which methods are firing faults.\n     * @param dc the databasecontext\n     * @param fs the fetchspecification\n     * @param channel the databasechannel\n     */\n    public void databaseContextDidSelectObjects(EODatabaseContext dc,\n                                                EOFetchSpecification fs,\n                                                EODatabaseChannel channel) {\n        if (dbCat.isDebugEnabled()) {\n            dbCat.debug(\"databaseContextDidSelectObjects \"+fs);\n        }\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean databaseContextFailedToFetchObject(EODatabaseContext context, Object object, EOGlobalID gid) {\n        if (object!=null) {\n            EOEditingContext ec = ((EOEnterpriseObject)object).editingContext();\n\n            // we need to refault the object before raising, otherwise, if the caller traps\n            // the exception, it will be a successful lookup the next time a fault with the\n            // same global id fires.  NOTE: refaulting in a sharedEditingContext is illegal,\n            // so we specifically check for that special case.\n\n            if (!(ec instanceof EOSharedEditingContext)) {\n                context.refaultObject((EOEnterpriseObject)object, gid, ec);\n            }\n        }\n        throw new RuntimeException(\"NSObjectNotAvailableException No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gid);            \n    }","id":30960,"modified_method":"/**\n     * This is Kelly Hawks' fix for the missing to one relationship. \n     * Delegate on EODatabaseContext that gets called when a to-one fault cannot find its data in\n     * the database. The object that is returned is a cleared fault.\n     * We raise here to restore the functionality that existed prior to WebObjects 4.5.\n     * Whenever a fault fails for a globalID (i.e. the object is NOT found in the database), we raise\n     * an {@link EOObjectNotAvailableException}.\n     * @param context database context\n     * @param object object that is firing the fault for a given to-one relationship\n     * @param gid global id that wasn't found in the database.\n     */\n    public boolean databaseContextFailedToFetchObject(EODatabaseContext context, Object object, EOGlobalID gid) {\n        if (object!=null) {\n            EOEditingContext ec = ((EOEnterpriseObject)object).editingContext();\n\n            // we need to refault the object before raising, otherwise, if the caller traps\n            // the exception, it will be a successful lookup the next time a fault with the\n            // same global id fires.  NOTE: refaulting in a sharedEditingContext is illegal,\n            // so we specifically check for that special case.\n\n            if (!(ec instanceof EOSharedEditingContext)) {\n                context.refaultObject((EOEnterpriseObject)object, gid, ec);\n            }\n        }\n        throw new EOObjectNotAvailableException(\"No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gid);            \n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXFileNotificationCenter() {\n        if (!WOApplication.application().isCachingEnabled()) {\n            ERXRetainer.retain(this);\n            cat.debug(\"Caching disabled.  Registering for notification: \" + ERXApplication.WORequestHandlerDidHandleRequestNotification);\n            NSNotificationCenter.defaultCenter().addObserver(this,\n                                                             new NSSelector(\"checkIfFilesHaveChanged\",\n                                                                            ERXConstant.NotificationClassArray),\n                                                             ERXApplication.WORequestHandlerDidHandleRequestNotification,\n                                                             null);            \n            cachingEnabled = false;\n        }\n    }","id":30961,"modified_method":"/**\n     * Default constructor. If WOCaching is disabled (we take this to mean we are in developement)\n     * then this object will register for the notification {@link WORequestHandler$DidHandleRequestNotification}\n     * which will enable it to check if files have changed at the end of every request-response\n     * loop. If WOCaching is enabled then this object will not register for anything and will generate\n     * warning messages if observers are registered with caching enabled.\n     */\n    public ERXFileNotificationCenter() {\n        if (!WOApplication.application().isCachingEnabled()) {\n            ERXRetainer.retain(this);\n            cat.debug(\"Caching disabled.  Registering for notification: \" + ERXApplication.WORequestHandlerDidHandleRequestNotification);\n            NSNotificationCenter.defaultCenter().addObserver(this,\n                                                             new NSSelector(\"checkIfFilesHaveChanged\",\n                                                                            ERXConstant.NotificationClassArray),\n                                                             ERXApplication.WORequestHandlerDidHandleRequestNotification,\n                                                             null);            \n            cachingEnabled = false;\n        }\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void finalize() throws Throwable {\n        NSNotificationCenter.defaultCenter().removeObserver(this);\n        super.finalize();\n    }","id":30962,"modified_method":"/**\n     * When the file notification center is garbage collected it removes itself\n     * as an observer from the {@link NSNotificationCenter}. Not doing this will cause exceptions.\n     */\n    public void finalize() throws Throwable {\n        NSNotificationCenter.defaultCenter().removeObserver(this);\n        super.finalize();\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public _ObserverSelectorHolder(Object obs, NSSelector sel) {\n            observer = obs;\n            selector = sel;            \n        }","id":30963,"modified_method":"/** Constructs a holder given an observer and a selector */\n        public _ObserverSelectorHolder(Object obs, NSSelector sel) {\n            observer = obs;\n            selector = sel;            \n        }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void checkIfFilesHaveChanged(NSNotification n) {\n        if (cat.isDebugEnabled()) cat.debug(\"Checking if files have changed\");\n        for (Enumeration e = _lastModifiedByFilePath.keyEnumerator(); e.hasMoreElements();) {\n            File file = new File((String)e.nextElement());\n            if (file.exists() && hasFileChanged(file)) {\n                fileHasChanged(file);\n            }\n        }\n    }","id":30964,"modified_method":"/**\n     * Notified by the NSNotificationCenter at the end of every request-response\n     * loop. It is here that all of the currently watched files are checked to\n     * see if they have any changes.\n     * @param NSNotification notification posted from the NSNotificationCenter.\n     */\n    public void checkIfFilesHaveChanged(NSNotification n) {\n        if (cat.isDebugEnabled()) cat.debug(\"Checking if files have changed\");\n        for (Enumeration e = _lastModifiedByFilePath.keyEnumerator(); e.hasMoreElements();) {\n            File file = new File((String)e.nextElement());\n            if (file.exists() && hasFileChanged(file)) {\n                fileHasChanged(file);\n            }\n        }\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static ERXFileNotificationCenter defaultCenter() {\n        if (_defaultCenter == null)\n            _defaultCenter = new ERXFileNotificationCenter();\n        return _defaultCenter;\n    }","id":30965,"modified_method":"/**\n     * @return the singleton instance of file notification center\n     */\n    public static ERXFileNotificationCenter defaultCenter() {\n        if (_defaultCenter == null)\n            _defaultCenter = new ERXFileNotificationCenter();\n        return _defaultCenter;\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void addObserver(Object observer, NSSelector selector, String filePath) {\n        if (filePath == null)\n            throw new RuntimeException(\"Attempting to register observer for null filePath.\");\n        addObserver(observer, selector, new File(filePath));        \n    }","id":30966,"modified_method":"/**\n     * Used to register file observers for a particular file.\n     * @param observer object to be notified when a file changes\n     * @param selector selector to be invoked on the observer when\n     *        the file changes.\n     * @param filePath location of the file\n     */\n    public void addObserver(Object observer, NSSelector selector, String filePath) {\n        if (filePath == null)\n            throw new RuntimeException(\"Attempting to register observer for null filePath.\");\n        addObserver(observer, selector, new File(filePath));        \n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean equals(Object osh) {\n            return osh != null && osh instanceof _ObserverSelectorHolder && ((_ObserverSelectorHolder)osh).selector.equals(selector) &&\n            ((_ObserverSelectorHolder)osh).observer.equals(observer);\n        }","id":30967,"modified_method":"/**\n         * Overridden to return true if the object being compared has the same observer-selector pair.\n         * @param osh object to be compared\n         * @return result of comparison\n         */\n        public boolean equals(Object osh) {\n            return osh != null && osh instanceof _ObserverSelectorHolder && ((_ObserverSelectorHolder)osh).selector.equals(selector) &&\n            ((_ObserverSelectorHolder)osh).observer.equals(observer);\n        }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void registerLastModifiedDateForFile(File file) {\n        if (file != null || !file.exists())\n            _lastModifiedByFilePath.setObjectForKey(new Long(file.lastModified()), file.getAbsolutePath());\n    }","id":30968,"modified_method":"/**\n     * Records the last modified date of the file for future comparison.\n     * @param file file to record the last modified date\n     */\n    public void registerLastModifiedDateForFile(File file) {\n        if (file != null || !file.exists())\n            _lastModifiedByFilePath.setObjectForKey(new Long(file.lastModified()), file.getAbsolutePath());\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void addObserver(Object observer, NSSelector selector, File file) {\n        if (file == null || !file.exists())\n            throw new RuntimeException(\"Attempting to register a null file. \" + (file != null ? \" File path: \" + file.getAbsolutePath() : null));\n        if (observer == null)\n            throw new RuntimeException(\"Attempting to register null observer for file: \" + file);\n        if (selector == null)\n            throw new RuntimeException(\"Attempting to register null selector for file: \" + file);\n        if (cachingEnabled)\n            cat.warn(\"Registering an observer when WOCaching is enabled.  This observer will not ever by default be called: \" + file);\n        String filePath = file.getAbsolutePath();\n        if (cat.isDebugEnabled())\n            cat.debug(\"Registering Observer for file at path: \" + filePath);\n        // Register last modified date.\n        registerLastModifiedDateForFile(file);\n        // FIXME: This retains the observer.  This is not ideal.  With 5.0 we can use a ReferenceQueue to maintain weak references.\n        NSMutableSet observerSet = (NSMutableSet)_observersByFilePath.objectForKey(filePath);\n        if (observerSet == null) {\n            observerSet = new NSMutableSet();\n            _observersByFilePath.setObjectForKey(observerSet, filePath);\n        }\n        observerSet.addObject(new _ObserverSelectorHolder(observer, selector));\n    }","id":30969,"modified_method":"/**\n     * Used to register file observers for a particular file.\n     * @param observer object to be notified when a file changes\n     * @param selector selector to be invoked on the observer when\n     *        the file changes.\n     * @param file file to watch for changes\n     */\n    public void addObserver(Object observer, NSSelector selector, File file) {\n        if (file == null || !file.exists())\n            throw new RuntimeException(\"Attempting to register a null file. \" + (file != null ? \" File path: \" + file.getAbsolutePath() : null));\n        if (observer == null)\n            throw new RuntimeException(\"Attempting to register null observer for file: \" + file);\n        if (selector == null)\n            throw new RuntimeException(\"Attempting to register null selector for file: \" + file);\n        if (cachingEnabled)\n            cat.warn(\"Registering an observer when WOCaching is enabled.  This observer will not ever by default be called: \" + file);\n        String filePath = file.getAbsolutePath();\n        if (cat.isDebugEnabled())\n            cat.debug(\"Registering Observer for file at path: \" + filePath);\n        // Register last modified date.\n        registerLastModifiedDateForFile(file);\n        // FIXME: This retains the observer.  This is not ideal.  With the 1.3 JDK we can use a ReferenceQueue to maintain weak references.\n        NSMutableSet observerSet = (NSMutableSet)_observersByFilePath.objectForKey(filePath);\n        if (observerSet == null) {\n            observerSet = new NSMutableSet();\n            _observersByFilePath.setObjectForKey(observerSet, filePath);\n        }\n        observerSet.addObject(new _ObserverSelectorHolder(observer, selector));\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean hasFileChanged(File file) {\n        if (file == null)\n            throw new RuntimeException(\"Attempting to check if a null file has been changed\");\n        Long lastModified = (Long)_lastModifiedByFilePath.objectForKey(file.getAbsolutePath());\n        return lastModified == null || file.lastModified() > lastModified.longValue();\n    }","id":30970,"modified_method":"/**\n     * Compares the last modified date of the file with the last recorded modification date.\n     * @param file file to compare last modified date.\n     * @return if the file has changed since the last time the <code>lastModified<\/code> value\n     *         was recorded.\n     */\n    public boolean hasFileChanged(File file) {\n        if (file == null)\n            throw new RuntimeException(\"Attempting to check if a null file has been changed\");\n        Long lastModified = (Long)_lastModifiedByFilePath.objectForKey(file.getAbsolutePath());\n        return lastModified == null || file.lastModified() > lastModified.longValue();\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void fileHasChanged(File file) {\n        NSMutableSet observers = (NSMutableSet)_observersByFilePath.objectForKey(file.getAbsolutePath());\n        if (observers == null)\n            cat.warn(\"Unable to find observers for file: \" + file);\n        else {\n            NSNotification notification = new NSNotification(FileDidChange, file);\n            for (Enumeration e = observers.objectEnumerator(); e.hasMoreElements();) {\n                _ObserverSelectorHolder holder = (_ObserverSelectorHolder)e.nextElement();\n                try {\n                    holder.selector.invoke(holder.observer, notification);\n                } catch (Exception ex) {\n                    cat.error(\"Catching exception when invoking method on observer: \" + ex.toString()+\" - \"+ERXUtilities.stackTrace(ex));\n                }\n            }\n            registerLastModifiedDateForFile(file);            \n        }\n    }","id":30971,"modified_method":"/**\n     * Only used internally. Notifies all of the observers who have been registered for the\n     * given file.\n     * @param file file that has changed\n     */\n    protected void fileHasChanged(File file) {\n        NSMutableSet observers = (NSMutableSet)_observersByFilePath.objectForKey(file.getAbsolutePath());\n        if (observers == null)\n            cat.warn(\"Unable to find observers for file: \" + file);\n        else {\n            NSNotification notification = new NSNotification(FileDidChange, file);\n            for (Enumeration e = observers.objectEnumerator(); e.hasMoreElements();) {\n                _ObserverSelectorHolder holder = (_ObserverSelectorHolder)e.nextElement();\n                try {\n                    holder.selector.invoke(holder.observer, notification);\n                } catch (Exception ex) {\n                    cat.error(\"Catching exception when invoking method on observer: \" + ex.toString()+\" - \"+ERXUtilities.stackTrace(ex));\n                }\n            }\n            registerLastModifiedDateForFile(file);            \n        }\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object rawPrimaryKey() { return ERXExtensions.rawPrimaryKeyForObject(this); }","id":30972,"modified_method":"/**\n     * Gives the raw primary key of the object. This could be anything from\n     * an NSData to a BigDecimal.\n     * @return the raw primary key of this object.\n     */\n    public Object rawPrimaryKey() { return ERXExtensions.rawPrimaryKeyForObject(this); }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void removeObjectsFromBothSidesOfRelationshipWithKey(NSArray objects, String key) {\n        if (objects != null && objects.count() > 0) {\n            for (Enumeration e = objects.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)e.nextElement();\n                removeObjectFromBothSidesOfRelationshipWithKey(eo, key);\n             }\n        }\n    }","id":30973,"modified_method":"/**\n     * Removes a collection of objects to a given relationship by calling\n     * <code>removeObjectFromBothSidesOfRelationshipWithKey<\/code> for all\n     * objects in the collection.\n     * @param objects objects to be removed from both sides of the given relationship\n     * @param key relationship key\n     */\n    public void removeObjectsFromBothSidesOfRelationshipWithKey(NSArray objects, String key) {\n        if (objects != null && objects.count() > 0) {\n            for (Enumeration e = objects.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)e.nextElement();\n                removeObjectFromBothSidesOfRelationshipWithKey(eo, key);\n             }\n        }\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean canUpdate() { return true; }","id":30974,"modified_method":"/**\n      * Implementation of {@link ERXGuardedObjectInterface}. This is checked\n      * before the object is deleted in the <code>willUpdate<\/code> method\n      * which is in turn called by {@link ERXEditingContextDelegate}. The default\n      * implementation returns <code>true<\/code>.\n      */\n    public boolean canUpdate() { return true; }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void addObjectsToBothSidesOfRelationshipWithKey(NSArray objects, String key) {\n        if (objects != null && objects.count() > 0) {\n            for (Enumeration e = objects.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)e.nextElement();\n                addObjectToBothSidesOfRelationshipWithKey(eo, key);\n            }\n        }\n    }","id":30975,"modified_method":"/**\n     * Adds a collection of objects to a given relationship by calling\n     * <code>addObjectToBothSidesOfRelationshipWithKey<\/code> for all\n     * objects in the collection.\n     * @param objects objects to add to both sides of the given relationship\n     * @param key relationship key\n     */\n    public void addObjectsToBothSidesOfRelationshipWithKey(NSArray objects, String key) {\n        if (objects != null && objects.count() > 0) {\n            for (Enumeration e = objects.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)e.nextElement();\n                addObjectToBothSidesOfRelationshipWithKey(eo, key);\n            }\n        }\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object committedSnapshotValueForKey(String key) {\n        return (editingContext().committedSnapshotForObject(this)).objectForKey(key);\n    }","id":30976,"modified_method":"/**\n     * Determines what the value of the given key is in the committed\n     * snapshot\n     * @param key to be checked in committed snapshot\n     * @return the committed snapshot value for the given key\n     */\n    public Object committedSnapshotValueForKey(String key) {\n        return (editingContext().committedSnapshotForObject(this)).objectForKey(key);\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSDictionary changesFromCommittedSnapshot() {\n        return changesFromSnapshot(editingContext().committedSnapshotForObject(this));\n    }","id":30977,"modified_method":"/**\n     * Computes the current set of changes that this object has from the\n     * currently committed snapshot.\n     * @return a dictionary holding the changed values from the currently\n     *         committed snapshot.\n     */\n    public NSDictionary changesFromCommittedSnapshot() {\n        return changesFromSnapshot(editingContext().committedSnapshotForObject(this));\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean parentObjectStoreIsObjectStoreCoordinator() { return editingContext().parentObjectStore() instanceof EOObjectStoreCoordinator; }","id":30978,"modified_method":"/**\n     * Simple method that will return if the parent object store of this object's editing\n     * context is an instance of {@link EOObjectStoreCoordinator}. The reason this is important\n     * is because if this condition evaluates to true then when changes are saved in this\n     * editing context they will be propogated to the database.\n     * @return if the parent object store of this object's editing context is an EOObjectStoreCoordinator.\n     */\n    public boolean parentObjectStoreIsObjectStoreCoordinator() { return editingContext().parentObjectStore() instanceof EOObjectStoreCoordinator; }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean canDelete() { return true; }","id":30979,"modified_method":"/**\n     * Implementation of {@link ERXGuardedObjectInterface}. This is checked\n     * before the object is deleted in the <code>willDelete<\/code> method\n     * which is in turn called by {@link ERXEditingContextDelegate}. The default\n     * implementation returns <code>true<\/code>.\n     */\n    public boolean canDelete() { return true; }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isDeletedEO() {\n        cat.debug(\"editingContext() = \"+editingContext());\n        cat.debug(\"deleted objects = \"+editingContext().deletedObjects());\n        cat.debug(\"this = \"+this);\n        return editingContext() != null && editingContext().deletedObjects().containsObject(this);\n    }","id":30980,"modified_method":"public boolean isDeletedEO() {\n        if (cat.isDebugEnabled())\n            cat.debug(\"editingContext() = \" + editingContext() + \" this object: \" + this);\n        return editingContext() != null && editingContext().deletedObjects().containsObject(this);\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String primaryKey() {\n        return ERXExtensions.primaryKeyForObject(this);\n    }","id":30981,"modified_method":"/**\n     * Primary key of the object as a String.\n     * @return primary key for the given object as a String\n     */\n    public String primaryKey() {\n        return ERXExtensions.primaryKeyForObject(this);\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXMailTo(WOContext aContext) {\n        super(aContext);\n    }","id":30982,"modified_method":"/** Default constructor */\n    public ERXMailTo(WOContext aContext) {\n        super(aContext);\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isStateless() { return true; }","id":30983,"modified_method":"/** component is stateless */\n    public boolean isStateless() { return true; }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String href() {\n        String result=null;\n        String email=(String)valueForBinding(\"email\");\n        if (email!=null) result=\"mailto:\"+email;\n        return result;\n    }","id":30984,"modified_method":"/**\n     * Generates the href link from email binding of the form:\n     * \"<a href=mailto:foo@bar.com>\".\n     * @return generated href\n     */\n    public String href() {\n        String result=null;\n        String email=(String)valueForBinding(\"email\");\n        if (email!=null) result=\"mailto:\"+email;\n        return result;\n    }","commit_id":"4fd4ec8616e4ea7378b824ba95552b8cb5db5635","url":"https://github.com/wocommunity/wonder"},{"original_method":"@DB\r\n    @Override\r\n    @ActionEvent(eventType = EventTypes.EVENT_ACL_ROLE_CREATE, eventDescription = \"Creating Acl Role\", create = true)\r\n    public AclRole createAclRole(Long domainId, String aclRoleName, String description, Long parentRoleId) {\r\n        Account caller = CallContext.current().getCallingAccount();\r\n        if (!_accountMgr.isRootAdmin(caller.getAccountId())) {\r\n            // domain admin can only create role for his domain\r\n            if (domainId != null && caller.getDomainId() != domainId.longValue()) {\r\n                throw new PermissionDeniedException(\"Can't create acl role in domain \" + domainId + \", permission denied\");\r\n            }\r\n        }\r\n        // check if the role is already existing\r\n        AclRole ro = _aclRoleDao.findByName(domainId, aclRoleName);\r\n        if (ro != null) {\r\n            throw new InvalidParameterValueException(\r\n                    \"Unable to create acl role with name \" + aclRoleName\r\n                            + \" already exisits for domain \" + domainId);\r\n        }\r\n\r\n        Transaction txn = Transaction.currentTxn();\r\n        txn.start();\r\n        AclRoleVO rvo = new AclRoleVO(aclRoleName, description);\r\n        if (domainId != null) {\r\n            rvo.setDomainId(domainId);\r\n        }\r\n        AclRole role = _aclRoleDao.persist(rvo);\r\n        if (parentRoleId != null) {\r\n            // copy parent role permissions\r\n            List<AclRolePermissionVO> perms = _rolePermissionDao.listByRole(parentRoleId);\r\n            if (perms != null) {\r\n                for (AclRolePermissionVO perm : perms) {\r\n                    perm.setAclRoleId(role.getId());\r\n                    _rolePermissionDao.persist(perm);\r\n                }\r\n            }\r\n        }\r\n        txn.commit();\r\n\r\n        return role;\r\n    }","id":30985,"modified_method":"@DB\r\n    @Override\r\n    @ActionEvent(eventType = EventTypes.EVENT_ACL_ROLE_CREATE, eventDescription = \"Creating Acl Role\", create = true)\r\n    public AclRole createAclRole(Long domainId, String aclRoleName, String description, Long parentRoleId) {\r\n        Account caller = CallContext.current().getCallingAccount();\r\n        if (domainId == null) {\r\n            domainId = caller.getDomainId();\r\n        }\r\n        if (!_accountMgr.isRootAdmin(caller.getAccountId())) {\r\n            // domain admin can only create role for his domain\r\n            if (caller.getDomainId() != domainId.longValue()) {\r\n                throw new PermissionDeniedException(\"Can't create acl role in domain \" + domainId + \", permission denied\");\r\n            }\r\n        }\r\n        // check if the role is already existing\r\n        AclRole ro = _aclRoleDao.findByName(domainId, aclRoleName);\r\n        if (ro != null) {\r\n            throw new InvalidParameterValueException(\r\n                    \"Unable to create acl role with name \" + aclRoleName\r\n                            + \" already exisits for domain \" + domainId);\r\n        }\r\n\r\n        Transaction txn = Transaction.currentTxn();\r\n        txn.start();\r\n        AclRoleVO rvo = new AclRoleVO(aclRoleName, description);\r\n        rvo.setDomainId(domainId);\r\n        AclRole role = _aclRoleDao.persist(rvo);\r\n        if (parentRoleId != null) {\r\n            // copy parent role permissions\r\n            List<AclRolePermissionVO> perms = _rolePermissionDao.listByRole(parentRoleId);\r\n            if (perms != null) {\r\n                for (AclRolePermissionVO perm : perms) {\r\n                    perm.setAclRoleId(role.getId());\r\n                    _rolePermissionDao.persist(perm);\r\n                }\r\n            }\r\n        }\r\n        txn.commit();\r\n\r\n        return role;\r\n    }","commit_id":"21dc2bef2a2dcf9d0a27c328acbb1d9391922780","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\r\n    @Override\r\n    @ActionEvent(eventType = EventTypes.EVENT_ACL_GROUP_CREATE, eventDescription = \"Creating Acl Group\", create = true)\r\n    public AclGroup createAclGroup(Long domainId, String aclGroupName, String description) {\r\n        Account caller = CallContext.current().getCallingAccount();\r\n        if (!_accountMgr.isRootAdmin(caller.getAccountId())) {\r\n            // domain admin can only create role for his domain\r\n            if (domainId != null && caller.getDomainId() != domainId.longValue()) {\r\n                throw new PermissionDeniedException(\"Can't create acl group in domain \" + domainId + \", permission denied\");\r\n            }\r\n        }\r\n        // check if the role is already existing\r\n        AclGroup grp = _aclGroupDao.findByName(domainId, aclGroupName);\r\n        if (grp != null) {\r\n            throw new InvalidParameterValueException(\r\n                    \"Unable to create acl group with name \" + aclGroupName\r\n                            + \" already exisits for domain \" + domainId);\r\n        }\r\n        AclGroupVO rvo = new AclGroupVO(aclGroupName, description);\r\n        if (domainId != null) {\r\n            rvo.setDomainId(domainId);\r\n        }\r\n\r\n        return _aclGroupDao.persist(rvo);\r\n    }","id":30986,"modified_method":"@DB\r\n    @Override\r\n    @ActionEvent(eventType = EventTypes.EVENT_ACL_GROUP_CREATE, eventDescription = \"Creating Acl Group\", create = true)\r\n    public AclGroup createAclGroup(Long domainId, String aclGroupName, String description) {\r\n        Account caller = CallContext.current().getCallingAccount();\r\n        if (domainId == null) {\r\n            domainId = caller.getDomainId(); // use caller's domain id\r\n        }\r\n        if (!_accountMgr.isRootAdmin(caller.getAccountId())) {\r\n            // domain admin can only create role for his domain\r\n            if (caller.getDomainId() != domainId.longValue()) {\r\n                throw new PermissionDeniedException(\"Can't create acl group in domain \" + domainId + \", permission denied\");\r\n            }\r\n        }\r\n        // check if the role is already existing\r\n        AclGroup grp = _aclGroupDao.findByName(domainId, aclGroupName);\r\n        if (grp != null) {\r\n            throw new InvalidParameterValueException(\r\n                    \"Unable to create acl group with name \" + aclGroupName\r\n                            + \" already exisits for domain \" + domainId);\r\n        }\r\n        AclGroupVO rvo = new AclGroupVO(aclGroupName, description);\r\n        rvo.setDomainId(domainId);\r\n\r\n        return _aclGroupDao.persist(rvo);\r\n    }","commit_id":"21dc2bef2a2dcf9d0a27c328acbb1d9391922780","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        return Account.ACCOUNT_ID_SYSTEM;\n    }","id":30987,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        return CallContext.current().getCallingAccount().getId();\n    }","commit_id":"21dc2bef2a2dcf9d0a27c328acbb1d9391922780","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        return Account.ACCOUNT_ID_SYSTEM;\n    }","id":30988,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        return CallContext.current().getCallingAccount().getId();\n    }","commit_id":"21dc2bef2a2dcf9d0a27c328acbb1d9391922780","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean execute() {\n\t\tGson gson = GsonHelper.getBuilder().create();\n\t\tAsyncJobManager asyncMgr = getAsyncJobMgr();\n\t\tAsyncJobVO job = getJob();\n\t\tManagementServer managementServer = asyncMgr.getExecutorContext().getManagementServer();\n\t\tLong param = gson.fromJson(job.getCmdInfo(), Long.class);\n\t\tLong userId = job.getUserId();\n\t\t\n\t\ttry {\n\t\t\tboolean result = managementServer.cancelPrimaryStorageMaintenance(param.longValue(), userId.longValue());\n\t\t\tif(result)\n\t\t\t{\n\t\t\t\tStoragePoolVO primaryStorage = managementServer.findPoolById(param);\n\t\t\t\t\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_SUCCEEDED, 0, \n\t\t\t\t\t\tcomposeResultObject(primaryStorage,managementServer));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStoragePoolVO primaryStorage = managementServer.findPoolById(param);\n\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, \n\t\t\t\t\t\tcomposeResultObject(primaryStorage,managementServer));\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\ts_logger.warn(\"Unable to prepare maintenance: \" + e.getMessage(), e);\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, \n\t\t\t\t\te.getMessage());\n\t\t}\n\t\treturn true;\n\t}","id":30989,"modified_method":"public boolean execute() {\n\t\tGson gson = GsonHelper.getBuilder().create();\n\t\tAsyncJobManager asyncMgr = getAsyncJobMgr();\n\t\tAsyncJobVO job = getJob();\n\t\tManagementServer managementServer = asyncMgr.getExecutorContext().getManagementServer();\n\t\tLong param = gson.fromJson(job.getCmdInfo(), Long.class);\n\t\tLong userId = job.getUserId();\n\t\t/*\n\t\ttry {\n\t\t\tboolean result = managementServer.cancelPrimaryStorageMaintenance(param.longValue(), userId.longValue());\n\t\t\tif(result)\n\t\t\t{\n\t\t\t\tStoragePoolVO primaryStorage = managementServer.findPoolById(param);\n\t\t\t\t\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_SUCCEEDED, 0, \n\t\t\t\t\t\tcomposeResultObject(primaryStorage,managementServer));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStoragePoolVO primaryStorage = managementServer.findPoolById(param);\n\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, \n\t\t\t\t\t\tcomposeResultObject(primaryStorage,managementServer));\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\ts_logger.warn(\"Unable to prepare maintenance: \" + e.getMessage(), e);\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, \n\t\t\t\t\te.getMessage());\n\t\t}\n\t\t*/\n\t\treturn true;\n\t}","commit_id":"19413d0becff5c611d3ac519ed8d3a581865b3e5","url":"https://github.com/apache/cloudstack"},{"original_method":"private PrimaryStorageResultObject composeResultObject(StoragePoolVO storagePoolVO, ManagementServer managementServer)\n\t    {\n\n\t    \tPrimaryStorageResultObject primaryStorageRO = new PrimaryStorageResultObject();\n\n\t    \tprimaryStorageRO.setId(storagePoolVO.getId());\n\t    \t\n\t    \tprimaryStorageRO.setName(storagePoolVO.getName());\n\t    \tprimaryStorageRO.setType(storagePoolVO.getPoolType().toString());\n\t    \tprimaryStorageRO.setState(storagePoolVO.getStatus().toString());\n\t    \tprimaryStorageRO.setIpAddress(storagePoolVO.getHostAddress());\n            primaryStorageRO.setZoneId(storagePoolVO.getDataCenterId());\n            primaryStorageRO.setZoneName(managementServer.getDataCenterBy(storagePoolVO.getDataCenterId()).getName());\n\n            if (storagePoolVO.getPodId() != null && managementServer.findHostPodById(storagePoolVO.getPodId()) != null) {\n            \tprimaryStorageRO.setPodId(storagePoolVO.getPodId());\n            \tprimaryStorageRO.setPodName((managementServer.findHostPodById(storagePoolVO.getPodId())).getName());\n            }\n            \n            if (storagePoolVO.getCreated() != null) {\n                primaryStorageRO.setCreated(storagePoolVO.getCreated());\n            }\n            primaryStorageRO.setDiskSizeTotal(storagePoolVO.getCapacityBytes());\n            \n            StorageStats stats = managementServer.getStoragePoolStatistics(storagePoolVO.getId());\n            long capacity = storagePoolVO.getCapacityBytes();\n            long available = storagePoolVO.getAvailableBytes() ;\n            long used = capacity - available;\n\n            if (stats != null) {\n                used = stats.getByteUsed();\n                available = capacity - used;\n            }\n            \n            primaryStorageRO.setDiskSizeAllocated(used);\n            if (storagePoolVO.getClusterId() != null) \n            {\n            \tClusterVO cluster = managementServer.findClusterById(storagePoolVO.getClusterId());\n            \tprimaryStorageRO.setClusterId(storagePoolVO.getClusterId());\n            \tprimaryStorageRO.setClusterName(cluster.getName());\n            }\n            \n            primaryStorageRO.setTags(managementServer.getStoragePoolTags(storagePoolVO.getId()));\n            return primaryStorageRO;\n\n\t    }","id":30990,"modified_method":"private PrimaryStorageResultObject composeResultObject(StoragePoolVO storagePoolVO, ManagementServer managementServer)\n\t    {\n\n\t    \tPrimaryStorageResultObject primaryStorageRO = new PrimaryStorageResultObject();\n\n\t    \tprimaryStorageRO.setId(storagePoolVO.getId());\n\t    \t\n\t    \tprimaryStorageRO.setName(storagePoolVO.getName());\n\t    \tprimaryStorageRO.setType(storagePoolVO.getPoolType().toString());\n\t    \tprimaryStorageRO.setState(storagePoolVO.getStatus().toString());\n\t    \tprimaryStorageRO.setIpAddress(storagePoolVO.getHostAddress());\n            primaryStorageRO.setZoneId(storagePoolVO.getDataCenterId());\n//            primaryStorageRO.setZoneName(managementServer.getDataCenterBy(storagePoolVO.getDataCenterId()).getName());\n\n            if (storagePoolVO.getPodId() != null && managementServer.findHostPodById(storagePoolVO.getPodId()) != null) {\n            \tprimaryStorageRO.setPodId(storagePoolVO.getPodId());\n            \tprimaryStorageRO.setPodName((managementServer.findHostPodById(storagePoolVO.getPodId())).getName());\n            }\n            \n            if (storagePoolVO.getCreated() != null) {\n                primaryStorageRO.setCreated(storagePoolVO.getCreated());\n            }\n            primaryStorageRO.setDiskSizeTotal(storagePoolVO.getCapacityBytes());\n            \n//            StorageStats stats = managementServer.getStoragePoolStatistics(storagePoolVO.getId());\n            long capacity = storagePoolVO.getCapacityBytes();\n            long available = storagePoolVO.getAvailableBytes() ;\n            long used = capacity - available;\n\n//            if (stats != null) {\n//                used = stats.getByteUsed();\n//                available = capacity - used;\n//            }\n            \n            primaryStorageRO.setDiskSizeAllocated(used);\n            if (storagePoolVO.getClusterId() != null) \n            {\n//            \tClusterVO cluster = managementServer.findClusterById(storagePoolVO.getClusterId());\n            \tprimaryStorageRO.setClusterId(storagePoolVO.getClusterId());\n//            \tprimaryStorageRO.setClusterName(cluster.getName());\n            }\n            \n//            primaryStorageRO.setTags(managementServer.getStoragePoolTags(storagePoolVO.getId()));\n            return primaryStorageRO;\n\n\t    }","commit_id":"19413d0becff5c611d3ac519ed8d3a581865b3e5","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean execute() {\r\n    \tGson gson = GsonHelper.getBuilder().create();\r\n    \tAsyncJobManager asyncMgr = getAsyncJobMgr();\r\n    \tAsyncJobVO job = getJob();\r\n    \tManagementServer managementServer = asyncMgr.getExecutorContext().getManagementServer();\r\n    \tCreateOrUpdateRuleParam param = gson.fromJson(job.getCmdInfo(), CreateOrUpdateRuleParam.class);\r\n    \t\r\n    \ttry {\r\n    \t\tif(s_logger.isDebugEnabled())\r\n    \t\t\ts_logger.debug(\"Executing createOrUpdateRule, uid: \" + job.getUserId() + \", pfservice id: \" + param.getSecurityGroupId()\r\n    \t\t\t\t+ \", addr: \" + param.getAddress() + \", port: \" + param.getPort() + \", private IP: \" + param.getPrivateIpAddress()\r\n    \t\t\t\t+ \", private port: \" + param.getPrivatePort() + \", protocol: \" + param.getProtocol() + \", algorithm: \" + param.getAlgorithm());\r\n    \t\t\r\n    \t\tNetworkRuleConfigVO rule = managementServer.createOrUpdateRule(job.getUserId(), param.getSecurityGroupId(), \r\n\t\t\t\tparam.getAddress(), param.getPort(), param.getPrivateIpAddress(), param.getPrivatePort(),\r\n\t\t\t\tparam.getProtocol(), param.getAlgorithm());\r\n\t\t\t\r\n    \t\tif(rule != null) {\r\n        \t\tif(s_logger.isDebugEnabled())\r\n        \t\t\ts_logger.debug(\"createOrUpdateRule executed successfully, complete async-execution\");\r\n        \t\t\t\t\t\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_SUCCEEDED, 0, \r\n\t\t\t\t\tcomposeResultObject(managementServer, param, rule));\r\n\t\t\t\t\r\n    \t\t} else {\r\n    \t\t\ts_logger.warn(\"createOrUpdateRule execution failed: null rule object is returned, complete async-execution\");\r\n    \t\t\t\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, \"operation failed\");\r\n    \t\t}\r\n\t\t} catch (InvalidParameterValueException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.PARAM_ERROR, e.getMessage());\r\n\t\t} catch (PermissionDeniedException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.PARAM_ERROR, e.getMessage());\r\n\t\t} catch (NetworkRuleConflictException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tif(param.isForwarding())\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(),\r\n\t\t\t\t\tAsyncJobResult.STATUS_FAILED, BaseCmd.NET_CONFLICT_IPFW_RULE_ERROR, e.getMessage());\r\n\t\t\telse\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(),\r\n\t\t\t\t\tAsyncJobResult.STATUS_FAILED, BaseCmd.NET_CONFLICT_LB_RULE_ERROR, e.getMessage());\r\n\t\t} catch (InternalErrorException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, e.getMessage());\r\n\t\t} catch(Exception e) {\r\n\t\t\ts_logger.warn(\"Unable to creat or update rule: \" + e.getMessage(), e);\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, e.getMessage());\r\n\t\t}\r\n\t\treturn true;\r\n\t}","id":30991,"modified_method":"public boolean execute() {\r\n    \tGson gson = GsonHelper.getBuilder().create();\r\n    \tAsyncJobManager asyncMgr = getAsyncJobMgr();\r\n    \tAsyncJobVO job = getJob();\r\n    \tManagementServer managementServer = asyncMgr.getExecutorContext().getManagementServer();\r\n    \tCreateOrUpdateRuleParam param = gson.fromJson(job.getCmdInfo(), CreateOrUpdateRuleParam.class);\r\n\n    \t/*\r\n    \ttry {\r\n    \t\tif(s_logger.isDebugEnabled())\r\n    \t\t\ts_logger.debug(\"Executing createOrUpdateRule, uid: \" + job.getUserId() + \", pfservice id: \" + param.getSecurityGroupId()\r\n    \t\t\t\t+ \", addr: \" + param.getAddress() + \", port: \" + param.getPort() + \", private IP: \" + param.getPrivateIpAddress()\r\n    \t\t\t\t+ \", private port: \" + param.getPrivatePort() + \", protocol: \" + param.getProtocol() + \", algorithm: \" + param.getAlgorithm());\r\n    \t\t\r\n    \t\tNetworkRuleConfigVO rule = managementServer.createOrUpdateRule(job.getUserId(), param.getSecurityGroupId(), \r\n\t\t\t\tparam.getAddress(), param.getPort(), param.getPrivateIpAddress(), param.getPrivatePort(),\r\n\t\t\t\tparam.getProtocol(), param.getAlgorithm());\r\n\t\t\t\r\n    \t\tif(rule != null) {\r\n        \t\tif(s_logger.isDebugEnabled())\r\n        \t\t\ts_logger.debug(\"createOrUpdateRule executed successfully, complete async-execution\");\r\n        \t\t\t\t\t\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), AsyncJobResult.STATUS_SUCCEEDED, 0, \r\n\t\t\t\t\tcomposeResultObject(managementServer, param, rule));\r\n\t\t\t\t\r\n    \t\t} else {\r\n    \t\t\ts_logger.warn(\"createOrUpdateRule execution failed: null rule object is returned, complete async-execution\");\r\n    \t\t\t\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, \"operation failed\");\r\n    \t\t}\r\n\t\t} catch (InvalidParameterValueException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.PARAM_ERROR, e.getMessage());\r\n\t\t} catch (PermissionDeniedException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.PARAM_ERROR, e.getMessage());\r\n\t\t} catch (NetworkRuleConflictException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tif(param.isForwarding())\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(),\r\n\t\t\t\t\tAsyncJobResult.STATUS_FAILED, BaseCmd.NET_CONFLICT_IPFW_RULE_ERROR, e.getMessage());\r\n\t\t\telse\r\n\t\t\t\tasyncMgr.completeAsyncJob(getJob().getId(),\r\n\t\t\t\t\tAsyncJobResult.STATUS_FAILED, BaseCmd.NET_CONFLICT_LB_RULE_ERROR, e.getMessage());\r\n\t\t} catch (InternalErrorException e) {\r\n\t\t\tif(s_logger.isDebugEnabled())\r\n\t\t\t\ts_logger.debug(\"Unable to creat or update rule: \" + e.getMessage());\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, e.getMessage());\r\n\t\t} catch(Exception e) {\r\n\t\t\ts_logger.warn(\"Unable to creat or update rule: \" + e.getMessage(), e);\r\n\t\t\tasyncMgr.completeAsyncJob(getJob().getId(), \r\n\t    \t\tAsyncJobResult.STATUS_FAILED, BaseCmd.INTERNAL_ERROR, e.getMessage());\r\n\t\t}\n\t\t*/\r\n\t\treturn true;\r\n\t}","commit_id":"19413d0becff5c611d3ac519ed8d3a581865b3e5","url":"https://github.com/apache/cloudstack"},{"original_method":"private CreatePrivateTemplateResultObject composeResultObject(VMTemplateVO template, VMTemplateHostVO templateHostRef, Long dataCenterId) {\n\t\tCreatePrivateTemplateResultObject resultObject = new CreatePrivateTemplateResultObject();\n\t\t\n\t\tresultObject.setId(template.getId());\n\t\tresultObject.setName(template.getName());\n\t\tresultObject.setDisplayText(template.getDisplayText());\n\t\tresultObject.setPublic(template.isPublicTemplate());\n\t\tresultObject.setCreated(templateHostRef.getCreated());\n\t\tresultObject.setReady(templateHostRef != null && templateHostRef.getDownloadState() == Status.DOWNLOADED);\n\t\tresultObject.setPasswordEnabled(template.getEnablePassword());\n\t\tresultObject.setCrossZones(template.isCrossZones());\n\t\tManagementServer managerServer = getAsyncJobMgr().getExecutorContext().getManagementServer();\n\t\tGuestOS os = managerServer.findGuestOSById(template.getGuestOSId());\n        if (os != null) {\n        \tresultObject.setOsTypeId(os.getId());\n        \tresultObject.setOsTypeName(os.getDisplayName());\n        } else {\n        \tresultObject.setOsTypeId(-1L);\n        \tresultObject.setOsTypeName(\"\");\n        }\n        \n        Account owner = managerServer.findAccountById(template.getAccountId());\n        if (owner != null) {\n        \tresultObject.setAccount(owner.getAccountName());\n        \tresultObject.setDomainId(owner.getDomainId());\n        \tresultObject.setDomainName(managerServer.findDomainIdById(owner.getDomainId()).getName());\n        }\n\n        \n    \tDataCenterVO zone = managerServer.findDataCenterById(dataCenterId);\n    \tif (zone != null) {\n    \t\tresultObject.setZoneId(zone.getId());\n    \t\tresultObject.setZoneName(zone.getName());\n    \t}\n        \t\n\t\treturn resultObject;\n\t}","id":30992,"modified_method":"private CreatePrivateTemplateResultObject composeResultObject(VMTemplateVO template, VMTemplateHostVO templateHostRef, Long dataCenterId) {\n\t\tCreatePrivateTemplateResultObject resultObject = new CreatePrivateTemplateResultObject();\n\t\t\n\t\tresultObject.setId(template.getId());\n\t\tresultObject.setName(template.getName());\n\t\tresultObject.setDisplayText(template.getDisplayText());\n\t\tresultObject.setPublic(template.isPublicTemplate());\n\t\tresultObject.setCreated(templateHostRef.getCreated());\n\t\tresultObject.setReady(templateHostRef != null && templateHostRef.getDownloadState() == Status.DOWNLOADED);\n\t\tresultObject.setPasswordEnabled(template.getEnablePassword());\n\t\tresultObject.setCrossZones(template.isCrossZones());\n\t\tManagementServer managerServer = getAsyncJobMgr().getExecutorContext().getManagementServer();\n//\t\tGuestOS os = managerServer.findGuestOSById(template.getGuestOSId());\n//        if (os != null) {\n//        \tresultObject.setOsTypeId(os.getId());\n//        \tresultObject.setOsTypeName(os.getDisplayName());\n//        } else {\n//        \tresultObject.setOsTypeId(-1L);\n//        \tresultObject.setOsTypeName(\"\");\n//        }\n        \n        Account owner = managerServer.findAccountById(template.getAccountId());\n        if (owner != null) {\n        \tresultObject.setAccount(owner.getAccountName());\n        \tresultObject.setDomainId(owner.getDomainId());\n//        \tresultObject.setDomainName(managerServer.findDomainIdById(owner.getDomainId()).getName());\n        }\n\n        \n    \tDataCenterVO zone = managerServer.findDataCenterById(dataCenterId);\n    \tif (zone != null) {\n    \t\tresultObject.setZoneId(zone.getId());\n    \t\tresultObject.setZoneName(zone.getName());\n    \t}\n        \t\n\t\treturn resultObject;\n\t}","commit_id":"19413d0becff5c611d3ac519ed8d3a581865b3e5","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean execute() {\n    \tGson gson = GsonHelper.getBuilder().create();\n    \tAsyncJobManager asyncMgr = getAsyncJobMgr();\n    \tAsyncJobVO job = getJob();\n\n\t\tif(getSyncSource() == null) {\n\t\t    CreatePrivateTemplateParam param = gson.fromJson(job.getCmdInfo(), CreatePrivateTemplateParam.class);\n\t    \tasyncMgr.syncAsyncJobExecution(job.getId(), \"Volume\", param.getVolumeId());\n\t    \t\n\t    \t// always true if it does not have sync-source\n\t    \treturn true;\n\t\t} else {\n\t    \tCreatePrivateTemplateParam param = gson.fromJson(job.getCmdInfo(), CreatePrivateTemplateParam.class);\n\t    \t\n\t    \tAsyncJobExecutorContext asyncJobExecutorContext = asyncMgr.getExecutorContext();\n\t    \tManagementServer managerServer = asyncJobExecutorContext.getManagementServer();\n\t    \tAccountManager accountManager = asyncJobExecutorContext.getAccountMgr();\n\t    \tUserVmManager vmMgr = asyncJobExecutorContext.getVmMgr();\n\t    \t\n\t    \tLong snapshotId = param.getSnapshotId();\n\t    \tLong volumeId = param.getVolumeId();\n\t    \tmanagerServer.saveStartedEvent(param.getUserId(), param.getAccountId(), EventTypes.EVENT_TEMPLATE_CREATE, \"Creating Template: \" +param.getName(), param.getEventId());\n\t    \t// By default, assume failure\n\t    \tString details = \"Could not create private template from \";\n\t    \tif (snapshotId != null) {\n\t    \t    details += \"snapshot with id: \" + snapshotId;\n\t    \t}\n\t    \telse {\n\t    \t    details += \"volume with id: \" + volumeId;\n\t    \t}\n\t    \t// Job details\n\t    \tLong jobId = getJob().getId();\n\t    \tint jobStatus = AsyncJobResult.STATUS_FAILED;\n            int resultCode = BaseCmd.INTERNAL_ERROR;\n            Object resultObject = null;\n\t\t\ttry {\n\t\t        // Check that the resource limit for templates won't be exceeded\n\t\t\t\tVolumeVO volume = managerServer.findAnyVolumeById(volumeId);\n\t\t\t\t\n\t\t\t\tif (volume == null) {\n\t\t\t\t\tthrow new InvalidParameterValueException(\"Could not find active volume with ID \" + volumeId);\n\t\t\t\t}\n\t\t\t\t\n\t\t    \tAccountVO account = (AccountVO) managerServer.findAccountById(volume.getAccountId());\n\t\t        if (accountManager.resourceLimitExceeded(account, ResourceType.template)) {\n\t\t            details += \", reason: The maximum number of templates for the specified account has been exceeded.\";\n\t\t        }\n\t\t        else {\n                    VMTemplateVO template = vmMgr.createPrivateTemplateRecord(param.getUserId(),\n                                                                              param.getVolumeId(),\n                                                                              param.getName(),\n                                                                              param.getDescription(),\n                                                                              param.getGuestOsId(),\n                                                                              param.getRequiresHvm(),\n                                                                              param.getBits(),\n                                                                              param.isPasswordEnabled(),\n                                                                              param.isPublic(),\n                                                                              param.isFeatured());\n    \n    \t\t    \tif (template != null) {\n        \t\t    \t\n                    \tif(s_logger.isInfoEnabled())\n                    \t\ts_logger.info(\"CreatePrivateTemplate created a new instance \" + template.getId() \n                    \t\t\t+ \", update async job-\" + job.getId() + \" progress status\");\n        \n                    \tasyncMgr.updateAsyncJobAttachment(job.getId(), \"vm_template\", template.getId());\n                    \tasyncMgr.updateAsyncJobStatus(job.getId(), BaseCmd.PROGRESS_INSTANCE_CREATED, template.getId());\n                    \tSnapshot snapshot = null;\n        \t    \t        \n            \t        if (snapshotId == null) {\n            \t            // We are create private template from volume. Create a snapshot, copy the vhd chain of the disk to secondary storage. \n            \t            // For template snapshot, we use a separate snapshot method.\n            \t            snapshot = vmMgr.createTemplateSnapshot(param.getUserId(), param.getVolumeId());\n            \t        }\n            \t        else {\n            \t            // We are creating a private template from an already present snapshot. \n            \t            // This snapshot is already backed up on secondary storage.\n            \t            snapshot = managerServer.findSnapshotById(snapshotId);\n            \t        }\n            \t        \n                        if (snapshot == null) {\n                            details += \", reason: Failed to create snapshot for basis of private template\";\n                        } else {\n                            param.setSnapshotId(snapshot.getId());\n            \t\t    \t\n            \t\t\t\ttemplate = managerServer.createPrivateTemplate(template, \n            \t\t\t\t                                               param.getUserId(), \n            \t\t\t\t\t\t                                       param.getSnapshotId(), \n            \t\t\t\t\t\t                                       param.getName(), \n            \t\t\t\t\t\t                                       param.getDescription());\n            \t\t\t\t            \t\t\t\t            \t\t\t\n            \t\t\t\tif(template != null) {\n            \t\t\t\t\tVMTemplateHostVO templateHostRef = managerServer.findTemplateHostRef(template.getId(), volume.getDataCenterId());\n            \t\t\t\t    jobStatus = AsyncJobResult.STATUS_SUCCEEDED;\n            \t\t\t\t    resultCode = 0;\n            \t\t\t\t    details = null;\n            \t\t\t\t    String eventParams = \"id=\"+template.getId()+\"\\nname=\" + template.getName() +\"\\nsize=\"+volume.getSize();\n            \t\t\t\t    managerServer.saveEvent(param.getUserId(), param.getAccountId(), EventVO.LEVEL_INFO, EventTypes.EVENT_TEMPLATE_CREATE, \"Successfully created Template \" +param.getName(), eventParams ,param.getEventId());\n            \t\t\t\t    resultObject = composeResultObject(template, templateHostRef, volume.getDataCenterId());\n            \t\t\t\t} \n            \t\t\t\t\n            \t\t\t\t// Irrespective of whether the template was created or not, \n            \t\t\t\t// cleanup the snapshot taken for this template. (If this template is created from a volume and not a snapshot) \n            \t\t\t\tif(snapshotId == null) {\n            \t\t\t\t    // Template was created from volume\n            \t\t\t\t    // and snapshot is not null.\n            \t\t\t\t    managerServer.destroyTemplateSnapshot(param.getUserId(), snapshot.getId());\n            \t\t\t\t}\n                        }\n    \t\t    \t}\n\t\t        }\n\t\t\t} catch (InvalidParameterValueException e) {\n\t\t\t    details += \", reason: \" + e.getMessage();\n\t\t\t\ts_logger.error(details, e);\n\t\t\t\tresultCode = BaseCmd.PARAM_ERROR;\n\t\t\t} catch (Exception e) {\n\t            details += \", reason: \" + e.getMessage();\n\t            s_logger.error(details, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (jobStatus == AsyncJobResult.STATUS_FAILED) {\n\t\t\t    resultObject = details;\n\t\t\t    managerServer.saveEvent(param.getUserId(), param.getAccountId(), EventVO.LEVEL_ERROR, EventTypes.EVENT_TEMPLATE_CREATE, details, \"\" ,param.getEventId());\n\t\t\t}\n\t        asyncMgr.completeAsyncJob(jobId, jobStatus, resultCode, resultObject);\n\t    \treturn true;\n\t\t}\n\t}","id":30993,"modified_method":"public boolean execute() {\n    \tGson gson = GsonHelper.getBuilder().create();\n    \tAsyncJobManager asyncMgr = getAsyncJobMgr();\n    \tAsyncJobVO job = getJob();\n\n    \t/*\n\t\tif(getSyncSource() == null) {\n\t\t    CreatePrivateTemplateParam param = gson.fromJson(job.getCmdInfo(), CreatePrivateTemplateParam.class);\n\t    \tasyncMgr.syncAsyncJobExecution(job.getId(), \"Volume\", param.getVolumeId());\n\t    \t\n\t    \t// always true if it does not have sync-source\n\t    \treturn true;\n\t\t} else {\n\t    \tCreatePrivateTemplateParam param = gson.fromJson(job.getCmdInfo(), CreatePrivateTemplateParam.class);\n\t    \t\n\t    \tAsyncJobExecutorContext asyncJobExecutorContext = asyncMgr.getExecutorContext();\n\t    \tManagementServer managerServer = asyncJobExecutorContext.getManagementServer();\n\t    \tAccountManager accountManager = asyncJobExecutorContext.getAccountMgr();\n\t    \tUserVmManager vmMgr = asyncJobExecutorContext.getVmMgr();\n\t    \t\n\t    \tLong snapshotId = param.getSnapshotId();\n\t    \tLong volumeId = param.getVolumeId();\n\t    \tmanagerServer.saveStartedEvent(param.getUserId(), param.getAccountId(), EventTypes.EVENT_TEMPLATE_CREATE, \"Creating Template: \" +param.getName(), param.getEventId());\n\t    \t// By default, assume failure\n\t    \tString details = \"Could not create private template from \";\n\t    \tif (snapshotId != null) {\n\t    \t    details += \"snapshot with id: \" + snapshotId;\n\t    \t}\n\t    \telse {\n\t    \t    details += \"volume with id: \" + volumeId;\n\t    \t}\n\t    \t// Job details\n\t    \tLong jobId = getJob().getId();\n\t    \tint jobStatus = AsyncJobResult.STATUS_FAILED;\n            int resultCode = BaseCmd.INTERNAL_ERROR;\n            Object resultObject = null;\n\t\t\ttry {\n\t\t        // Check that the resource limit for templates won't be exceeded\n\t\t\t\tVolumeVO volume = managerServer.findAnyVolumeById(volumeId);\n\t\t\t\t\n\t\t\t\tif (volume == null) {\n\t\t\t\t\tthrow new InvalidParameterValueException(\"Could not find active volume with ID \" + volumeId);\n\t\t\t\t}\n\t\t\t\t\n\t\t    \tAccountVO account = (AccountVO) managerServer.findAccountById(volume.getAccountId());\n\t\t        if (accountManager.resourceLimitExceeded(account, ResourceType.template)) {\n\t\t            details += \", reason: The maximum number of templates for the specified account has been exceeded.\";\n\t\t        }\n\t\t        else {\n                    VMTemplateVO template = vmMgr.createPrivateTemplateRecord(param.getUserId(),\n                                                                              param.getVolumeId(),\n                                                                              param.getName(),\n                                                                              param.getDescription(),\n                                                                              param.getGuestOsId(),\n                                                                              param.getRequiresHvm(),\n                                                                              param.getBits(),\n                                                                              param.isPasswordEnabled(),\n                                                                              param.isPublic(),\n                                                                              param.isFeatured());\n    \n    \t\t    \tif (template != null) {\n        \t\t    \t\n                    \tif(s_logger.isInfoEnabled())\n                    \t\ts_logger.info(\"CreatePrivateTemplate created a new instance \" + template.getId() \n                    \t\t\t+ \", update async job-\" + job.getId() + \" progress status\");\n        \n                    \tasyncMgr.updateAsyncJobAttachment(job.getId(), \"vm_template\", template.getId());\n                    \tasyncMgr.updateAsyncJobStatus(job.getId(), BaseCmd.PROGRESS_INSTANCE_CREATED, template.getId());\n                    \tSnapshot snapshot = null;\n        \t    \t        \n            \t        if (snapshotId == null) {\n            \t            // We are create private template from volume. Create a snapshot, copy the vhd chain of the disk to secondary storage. \n            \t            // For template snapshot, we use a separate snapshot method.\n            \t            snapshot = vmMgr.createTemplateSnapshot(param.getUserId(), param.getVolumeId());\n            \t        }\n            \t        else {\n            \t            // We are creating a private template from an already present snapshot. \n            \t            // This snapshot is already backed up on secondary storage.\n            \t            snapshot = managerServer.findSnapshotById(snapshotId);\n            \t        }\n            \t        \n                        if (snapshot == null) {\n                            details += \", reason: Failed to create snapshot for basis of private template\";\n                        } else {\n                            param.setSnapshotId(snapshot.getId());\n            \t\t    \t\n            \t\t\t\ttemplate = managerServer.createPrivateTemplate(template, \n            \t\t\t\t                                               param.getUserId(), \n            \t\t\t\t\t\t                                       param.getSnapshotId(), \n            \t\t\t\t\t\t                                       param.getName(), \n            \t\t\t\t\t\t                                       param.getDescription());\n            \t\t\t\t            \t\t\t\t            \t\t\t\n            \t\t\t\tif(template != null) {\n            \t\t\t\t\tVMTemplateHostVO templateHostRef = managerServer.findTemplateHostRef(template.getId(), volume.getDataCenterId());\n            \t\t\t\t    jobStatus = AsyncJobResult.STATUS_SUCCEEDED;\n            \t\t\t\t    resultCode = 0;\n            \t\t\t\t    details = null;\n            \t\t\t\t    String eventParams = \"id=\"+template.getId()+\"\\nname=\" + template.getName() +\"\\nsize=\"+volume.getSize();\n            \t\t\t\t    managerServer.saveEvent(param.getUserId(), param.getAccountId(), EventVO.LEVEL_INFO, EventTypes.EVENT_TEMPLATE_CREATE, \"Successfully created Template \" +param.getName(), eventParams ,param.getEventId());\n            \t\t\t\t    resultObject = composeResultObject(template, templateHostRef, volume.getDataCenterId());\n            \t\t\t\t} \n            \t\t\t\t\n            \t\t\t\t// Irrespective of whether the template was created or not, \n            \t\t\t\t// cleanup the snapshot taken for this template. (If this template is created from a volume and not a snapshot) \n            \t\t\t\tif(snapshotId == null) {\n            \t\t\t\t    // Template was created from volume\n            \t\t\t\t    // and snapshot is not null.\n            \t\t\t\t    managerServer.destroyTemplateSnapshot(param.getUserId(), snapshot.getId());\n            \t\t\t\t}\n                        }\n    \t\t    \t}\n\t\t        }\n\t\t\t} catch (InvalidParameterValueException e) {\n\t\t\t    details += \", reason: \" + e.getMessage();\n\t\t\t\ts_logger.error(details, e);\n\t\t\t\tresultCode = BaseCmd.PARAM_ERROR;\n\t\t\t} catch (Exception e) {\n\t            details += \", reason: \" + e.getMessage();\n\t            s_logger.error(details, e);\n\t\t\t}\n\t\t\t\n\t\t\tif (jobStatus == AsyncJobResult.STATUS_FAILED) {\n\t\t\t    resultObject = details;\n\t\t\t    managerServer.saveEvent(param.getUserId(), param.getAccountId(), EventVO.LEVEL_ERROR, EventTypes.EVENT_TEMPLATE_CREATE, details, \"\" ,param.getEventId());\n\t\t\t}\n\t        asyncMgr.completeAsyncJob(jobId, jobStatus, resultCode, resultObject);\n\t    \treturn true;\n\t\t}\n\t\t*/\n    \treturn true;\n\t}","commit_id":"19413d0becff5c611d3ac519ed8d3a581865b3e5","url":"https://github.com/apache/cloudstack"},{"original_method":"private CreateSnapshotResultObject composeResultObject(Snapshot snapshot) {\n\t\tCreateSnapshotResultObject resultObject = new CreateSnapshotResultObject();\n\t\tManagementServer managementServer = getAsyncJobMgr().getExecutorContext().getManagementServer();\n\t\tVolumeVO volume = managementServer.findVolumeById(snapshot.getVolumeId());\n\t\t\n\t\tresultObject.setId(snapshot.getId());\n\t\tlong domainId = -1;\n\t\tAccount account = getAsyncJobMgr().getExecutorContext().getAccountDao().findById(snapshot.getAccountId());\n\t\tif(account != null)\n\t\t{\n\t\t\tresultObject.setAccountName(account.getAccountName());\n\t\t\tdomainId = account.getDomainId();\n\t\t\t\n\t\t\tif(domainId != -1)\n\t\t\t{\n\t\t\t\tresultObject.setDomainId(domainId);\n\t\t\t\tresultObject.setDomainName(getAsyncJobMgr().getExecutorContext().getManagementServer().findDomainIdById(domainId).getName());\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tString snapshotTypeStr = SnapshotType.values()[snapshot.getSnapshotType()].name();\n\t\tresultObject.setSnapshotType(snapshotTypeStr);\n\t\tresultObject.setVolumeId(snapshot.getVolumeId());\n\t\tresultObject.setVolumeName(volume.getName());\n\t\tresultObject.setVolumeType(volume.getVolumeType());\n\t\tresultObject.setCreated(snapshot.getCreated());\n\t\tresultObject.setName(snapshot.getName());\n\t\treturn resultObject;\n\t}","id":30994,"modified_method":"private CreateSnapshotResultObject composeResultObject(Snapshot snapshot) {\n\t\tCreateSnapshotResultObject resultObject = new CreateSnapshotResultObject();\n\t\tManagementServer managementServer = getAsyncJobMgr().getExecutorContext().getManagementServer();\n//\t\tVolumeVO volume = managementServer.findVolumeById(snapshot.getVolumeId());\n\t\t\n\t\tresultObject.setId(snapshot.getId());\n\t\tlong domainId = -1;\n\t\tAccount account = getAsyncJobMgr().getExecutorContext().getAccountDao().findById(snapshot.getAccountId());\n\t\tif(account != null)\n\t\t{\n\t\t\tresultObject.setAccountName(account.getAccountName());\n\t\t\tdomainId = account.getDomainId();\n\t\t\t\n\t\t\tif(domainId != -1)\n\t\t\t{\n\t\t\t\tresultObject.setDomainId(domainId);\n//\t\t\t\tresultObject.setDomainName(getAsyncJobMgr().getExecutorContext().getManagementServer().findDomainIdById(domainId).getName());\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tString snapshotTypeStr = SnapshotType.values()[snapshot.getSnapshotType()].name();\n\t\tresultObject.setSnapshotType(snapshotTypeStr);\n\t\tresultObject.setVolumeId(snapshot.getVolumeId());\n//\t\tresultObject.setVolumeName(volume.getName());\n//\t\tresultObject.setVolumeType(volume.getVolumeType());\n\t\tresultObject.setCreated(snapshot.getCreated());\n\t\tresultObject.setName(snapshot.getName());\n\t\treturn resultObject;\n\t}","commit_id":"19413d0becff5c611d3ac519ed8d3a581865b3e5","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean execute() {\n    \tAsyncJobManager asyncMgr = getAsyncJobMgr();\n    \tAsyncJobVO job = getJob();\n    \tGson gson = GsonHelper.getBuilder().create();\n    \t\n\t\tif (getSyncSource() == null) {\n\t    \tSnapshotOperationParam param = gson.fromJson(job.getCmdInfo(), SnapshotOperationParam.class);\n\t    \tasyncMgr.syncAsyncJobExecution(job.getId(), \"Volume\", param.getVolumeId());\n\t    \t\n\t    \t// always true if it does not have sync-source\n\t    \treturn true;\n\t\t} else {\n\t    \tSnapshotOperationParam param = gson.fromJson(job.getCmdInfo(), SnapshotOperationParam.class);\n\t    \tSnapshotManager snapshotManager = asyncMgr.getExecutorContext().getSnapshotMgr();\n\t    \tlong volumeId = param.getVolumeId();\n\t    \tList<Long> policyIds = param.getPolicyIds();\n\t    \tlong snapshotId = 0;\n\t    \tlong userId = param.getUserId();\n\t    \t\n\t    \t// By default assume that everything has failed.\n            boolean backedUp = false;\n\t    \tLong jobId = getJob().getId();\n            int result = AsyncJobResult.STATUS_FAILED;\n            int errorCode = BaseCmd.INTERNAL_ERROR;\n            Object resultObject = \"Failed to create snapshot.\";\n            \n\t    \ttry {\n\t    \t    SnapshotVO snapshot = snapshotManager.createSnapshot(userId, param.getVolumeId(), param.getPolicyIds());\n\n\t\t    \tif (snapshot != null && snapshot.getStatus() == Snapshot.Status.CreatedOnPrimary) {\n\t\t\t\t    snapshotId = snapshot.getId();\n\t\t\t\t    asyncMgr.updateAsyncJobStatus(jobId, BaseCmd.PROGRESS_INSTANCE_CREATED, snapshotId);\n\t\t\t\t    backedUp = snapshotManager.backupSnapshotToSecondaryStorage(userId, snapshot);\n\t\t\t\t    if (backedUp) {\n\t\t\t\t        result = AsyncJobResult.STATUS_SUCCEEDED;\n\t\t\t\t        errorCode = 0; // Success\n\t\t\t\t        resultObject = composeResultObject(snapshot);\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t        // More specific error\n\t\t\t\t        resultObject = \"Created snapshot: \" + snapshotId + \" on primary but failed to backup on secondary\";\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t} catch(Exception e) {\n\t    \t    resultObject = \"Unable to create snapshot: \" + e.getMessage();\n\t    \t\ts_logger.warn(resultObject, e);\n\t    \t}\n\n\t\t\t// In all cases, ensure that we call completeAsyncJob to the asyncMgr.\n\t    \tasyncMgr.completeAsyncJob(jobId, result, errorCode, resultObject);\n\t    \t\n\t    \t// Cleanup jobs to do after the snapshot has been created.\n\t    \tsnapshotManager.postCreateSnapshot(userId, volumeId, snapshotId, policyIds, backedUp);\n\t    \treturn true;\n\t\t}\n\t}","id":30995,"modified_method":"public boolean execute() {\n    \tAsyncJobManager asyncMgr = getAsyncJobMgr();\n    \tAsyncJobVO job = getJob();\n    \tGson gson = GsonHelper.getBuilder().create();\n    \t\n    \t/*\n\t\tif (getSyncSource() == null) {\n\t    \tSnapshotOperationParam param = gson.fromJson(job.getCmdInfo(), SnapshotOperationParam.class);\n\t    \tasyncMgr.syncAsyncJobExecution(job.getId(), \"Volume\", param.getVolumeId());\n\t    \t\n\t    \t// always true if it does not have sync-source\n\t    \treturn true;\n\t\t} else {\n\t    \tSnapshotOperationParam param = gson.fromJson(job.getCmdInfo(), SnapshotOperationParam.class);\n\t    \tSnapshotManager snapshotManager = asyncMgr.getExecutorContext().getSnapshotMgr();\n\t    \tlong volumeId = param.getVolumeId();\n\t    \tList<Long> policyIds = param.getPolicyIds();\n\t    \tlong snapshotId = 0;\n\t    \tlong userId = param.getUserId();\n\t    \t\n\t    \t// By default assume that everything has failed.\n            boolean backedUp = false;\n\t    \tLong jobId = getJob().getId();\n            int result = AsyncJobResult.STATUS_FAILED;\n            int errorCode = BaseCmd.INTERNAL_ERROR;\n            Object resultObject = \"Failed to create snapshot.\";\n            \n\t    \ttry {\n\t    \t    SnapshotVO snapshot = snapshotManager.createSnapshot(userId, param.getVolumeId(), param.getPolicyIds());\n\n\t\t    \tif (snapshot != null && snapshot.getStatus() == Snapshot.Status.CreatedOnPrimary) {\n\t\t\t\t    snapshotId = snapshot.getId();\n\t\t\t\t    asyncMgr.updateAsyncJobStatus(jobId, BaseCmd.PROGRESS_INSTANCE_CREATED, snapshotId);\n\t\t\t\t    backedUp = snapshotManager.backupSnapshotToSecondaryStorage(userId, snapshot);\n\t\t\t\t    if (backedUp) {\n\t\t\t\t        result = AsyncJobResult.STATUS_SUCCEEDED;\n\t\t\t\t        errorCode = 0; // Success\n\t\t\t\t        resultObject = composeResultObject(snapshot);\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t        // More specific error\n\t\t\t\t        resultObject = \"Created snapshot: \" + snapshotId + \" on primary but failed to backup on secondary\";\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t} catch(Exception e) {\n\t    \t    resultObject = \"Unable to create snapshot: \" + e.getMessage();\n\t    \t\ts_logger.warn(resultObject, e);\n\t    \t}\n\n\t\t\t// In all cases, ensure that we call completeAsyncJob to the asyncMgr.\n\t    \tasyncMgr.completeAsyncJob(jobId, result, errorCode, resultObject);\n\t    \t\n\t    \t// Cleanup jobs to do after the snapshot has been created.\n\t    \tsnapshotManager.postCreateSnapshot(userId, volumeId, snapshotId, policyIds, backedUp);\n\t    \treturn true;\n\t\t}\n\t\t*/\n    \treturn true;\n\t}","commit_id":"19413d0becff5c611d3ac519ed8d3a581865b3e5","url":"https://github.com/apache/cloudstack"},{"original_method":"public NSArray sortOrderings() {\n        NSArray sortOrderings=null;\n        if (userPreferencesCanSpecifySorting()) {\n            NSKeyValueCoding userPreferences=(NSKeyValueCoding)d2wContext().valueForKey(\"userPreferences\");\n            if (userPreferences!=null) {\n                String key=ERXExtensions.userPreferencesKeyFromContext(\"sortOrdering\", d2wContext());\n                // sort ordering prefs are expected in the form vfk sortOrdering.<pageConfigName>\n                sortOrderings=(NSArray)userPreferences.valueForKey(key);\n                if (log.isDebugEnabled()) log.debug(\"Found sort Orderings in user prefs \"+ sortOrderings);\n            }\n        }\n        if (sortOrderings==null) {\n            NSArray sortOrderingDefinition=(NSArray)d2wContext().valueForKey(\"defaultSortOrdering\");\n            if (sortOrderingDefinition!=null) {\n                NSMutableArray so=new NSMutableArray();\n                NSArray displayPropertyKeys = (NSArray)d2wContext().valueForKey(\"displayPropertyKeys\");\n                for (int i=0; i< sortOrderingDefinition.count();) {\n                    String sortKey=(String)sortOrderingDefinition.objectAtIndex(i++);\n                    String sortSelectorKey=(String)sortOrderingDefinition.objectAtIndex(i++);\n                    if(displayPropertyKeys.containsObject(sortKey)) {\n                        EOSortOrdering sortOrdering=new EOSortOrdering(sortKey,\n                                                                       ERXArrayUtilities.sortSelectorWithKey(sortSelectorKey));\n                        so.addObject(sortOrdering);\n                    } else {\n                        log.warn(\"Sort key '\"+sortKey+\"' is not in display keys\");\n                    }\n                }\n                sortOrderings=so;\n                if (log.isDebugEnabled()) log.debug(\"Found sort Orderings in rules \"+ sortOrderings);\n            }\n        }\n        return sortOrderings;\n    }","id":30996,"modified_method":"public NSArray sortOrderings() {\n        NSArray sortOrderings=null;\n        if (userPreferencesCanSpecifySorting()) {\n            NSKeyValueCoding userPreferences=(NSKeyValueCoding)d2wContext().valueForKey(\"userPreferences\");\n            if (userPreferences!=null) {\n                String key=ERXExtensions.userPreferencesKeyFromContext(\"sortOrdering\", d2wContext());\n                // sort ordering prefs are expected in the form vfk sortOrdering.<pageConfigName>\n                sortOrderings=(NSArray)userPreferences.valueForKey(key);\n                if (log.isDebugEnabled()) log.debug(\"Found sort Orderings in user prefs \"+ sortOrderings);\n            }\n        }\n        if (sortOrderings==null) {\n            NSArray sortOrderingDefinition=(NSArray)d2wContext().valueForKey(\"defaultSortOrdering\");\n            if (sortOrderingDefinition!=null) {\n                NSMutableArray so=new NSMutableArray();\n                NSArray displayPropertyKeys = (NSArray)d2wContext().valueForKey(\"displayPropertyKeys\");\n                for (int i=0; i< sortOrderingDefinition.count();) {\n                    String sortKey=(String)sortOrderingDefinition.objectAtIndex(i++);\n                    String sortSelectorKey=(String)sortOrderingDefinition.objectAtIndex(i++);\n                    if(displayPropertyKeys.containsObject(sortKey) || entity().anyAttributeNamed(sortKey) != null) {\n                        EOSortOrdering sortOrdering=new EOSortOrdering(sortKey,\n                                                                       ERXArrayUtilities.sortSelectorWithKey(sortSelectorKey));\n                        so.addObject(sortOrdering);\n                    } else {\n                        log.warn(\"Sort key '\"+sortKey+\"' is not in display keys\");\n                    }\n                }\n                sortOrderings=so;\n                if (log.isDebugEnabled()) log.debug(\"Found sort Orderings in rules \"+ sortOrderings);\n            }\n        }\n        return sortOrderings;\n    }","commit_id":"1c49e520308988f60c66e11d50b3b2ad11d70792","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isLeaf() {\n    boolean leaf;\n    NSArray nodes = nodes();\n    if (_nodeIndex >= nodes.count() - 1) {\n      leaf = true;\n    }\n    else {\n      Object nextNode = nodes.objectAtIndex(_nodeIndex + 1);\n      Object nextParent = treeModel().parentTreeNode(nextNode);\n      leaf = (nextParent == _item);\n    }\n    if (leaf) {\n      leaf = treeModel().childrenTreeNodes(_item).count() == 0;\n    }\n    return leaf;\n  }","id":30997,"modified_method":"public boolean isLeaf() {\n    return treeModel().isLeaf(_item);\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void _fillInOpenNodes(Object node, NSMutableArray nodes) {\n    nodes.add(node);\n    if (treeModel().isExpanded(node)) {\n      NSArray childrenTreeNodes = treeModel().childrenTreeNodes(node);\n      int childTreeNodeCount = childrenTreeNodes.count();\n      for (int childTreeNodeNum = 0; childTreeNodeNum < childTreeNodeCount; childTreeNodeNum++) {\n        Object childNode = childrenTreeNodes.objectAtIndex(childTreeNodeNum);\n        _fillInOpenNodes(childNode, nodes);\n      }\n    }\n  }","id":30998,"modified_method":"protected void _fillInOpenNodes(Object node, NSMutableArray nodes) {\n    nodes.add(node);\n    if (treeModel().isExpanded(node)) {\n      NSArray childrenTreeNodes = treeModel().childrenTreeNodes(node);\n      if (childrenTreeNodes != null) {\n        int childTreeNodeCount = childrenTreeNodes.count();\n        for (int childTreeNodeNum = 0; childTreeNodeNum < childTreeNodeCount; childTreeNodeNum++) {\n          Object childNode = childrenTreeNodes.objectAtIndex(childTreeNodeNum);\n          _fillInOpenNodes(childNode, nodes);\n        }\n      }\n    }\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setExpanded(Object treeNode, boolean expanded) {\n    treeModel().setExpanded(treeNode, expanded);\n  }","id":30999,"modified_method":"public void setRootExpanded(boolean rootExpanded) {\n    treeModel().setRootExpanded(rootExpanded);\n  }","commit_id":"0838b96cc85130bd5f62c55dba808ef762511863","url":"https://github.com/wocommunity/wonder"}]