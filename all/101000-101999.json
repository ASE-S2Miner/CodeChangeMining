[{"original_method":"private void generateSetter(JetNamedDeclaration p, PropertyDescriptor propertyDescriptor, JetPropertyAccessor setter) {\n        //TODO: Now it's not enough information to properly resolve property from bytecode without generated getter and setter\n        if (/*setter != null && setter.getBodyExpression() != null\n            || isExternallyAccessible(propertyDescriptor) &&*/ propertyDescriptor.isVar()) {\n            JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n            PropertySetterDescriptor setterDescriptor = propertyDescriptor.getSetter();\n            setterDescriptor = setterDescriptor != null ? setterDescriptor : DescriptorResolver.createDefaultSetter(propertyDescriptor);\n            functionCodegen.generateMethod(setter != null ? setter : p,\n                                           signature.getJvmMethodSignature(),\n                                           true,\n                                           signature.getPropertyTypeKotlinSignature(),\n                                           setterDescriptor);\n        }\n    }","id":101000,"modified_method":"private void generateSetter(JetNamedDeclaration p, PropertyDescriptor propertyDescriptor, JetPropertyAccessor setter) {\n        boolean defaultSetter = setter == null || setter.getBodyExpression() == null;\n\n        //TODO: Now it's not enough information to properly resolve property from bytecode without generated getter and setter\n        if (/*!defaultSetter || isExternallyAccessible(propertyDescriptor) &&*/ propertyDescriptor.isVar()) {\n            JvmPropertyAccessorSignature signature = typeMapper.mapSetterSignature(propertyDescriptor, kind);\n            PropertySetterDescriptor setterDescriptor = propertyDescriptor.getSetter();\n            setterDescriptor = setterDescriptor != null ? setterDescriptor : DescriptorResolver.createDefaultSetter(propertyDescriptor);\n\n            if (kind != OwnerKind.TRAIT_IMPL || !defaultSetter) {\n                functionCodegen.generateMethod(setter != null ? setter : p,\n                                               signature.getJvmMethodSignature(),\n                                               true,\n                                               signature.getPropertyTypeKotlinSignature(),\n                                               setterDescriptor);\n            }\n        }\n    }","commit_id":"099fa6c11efa0855f997021270b0164a56913bc9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateGetter(JetNamedDeclaration p, PropertyDescriptor propertyDescriptor, JetPropertyAccessor getter) {\n        //TODO: Now it's not enough information to properly resolve property from bytecode without generated getter and setter\n        //if (getter != null && getter.getBodyExpression() != null || isExternallyAccessible(propertyDescriptor)) {\n            JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n            PropertyGetterDescriptor getterDescriptor = propertyDescriptor.getGetter();\n            getterDescriptor = getterDescriptor != null ? getterDescriptor : DescriptorResolver.createDefaultGetter(propertyDescriptor);\n            functionCodegen.generateMethod(getter != null ? getter : p,\n                                           signature.getJvmMethodSignature(),\n                                           true,\n                                           signature.getPropertyTypeKotlinSignature(),\n                                           getterDescriptor);\n        //}\n    }","id":101001,"modified_method":"private void generateGetter(JetNamedDeclaration p, PropertyDescriptor propertyDescriptor, JetPropertyAccessor getter) {\n        boolean defaultGetter = getter == null || getter.getBodyExpression() == null;\n\n        //TODO: Now it's not enough information to properly resolve property from bytecode without generated getter and setter\n        //if (!defaultGetter || isExternallyAccessible(propertyDescriptor)) {\n        JvmPropertyAccessorSignature signature = typeMapper.mapGetterSignature(propertyDescriptor, kind);\n        PropertyGetterDescriptor getterDescriptor = propertyDescriptor.getGetter();\n        getterDescriptor = getterDescriptor != null ? getterDescriptor : DescriptorResolver.createDefaultGetter(propertyDescriptor);\n\n        if (kind != OwnerKind.TRAIT_IMPL || !defaultGetter) {\n            functionCodegen.generateMethod(getter != null ? getter : p,\n                                           signature.getJvmMethodSignature(),\n                                           true,\n                                           signature.getPropertyTypeKotlinSignature(),\n                                           getterDescriptor);\n        }\n        //}\n    }","commit_id":"099fa6c11efa0855f997021270b0164a56913bc9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void appendElementReference(final StringBuffer buf, RefElement refElement, String linkText, @NonNls String frameName) {    \n    if (myExporter == null) {\n      appendElementReference(buf, ((RefElementImpl) refElement).getURL().toString(), linkText, frameName);\n    }\n    else {\n      appendElementReference(buf, myExporter.getURL(refElement), linkText, frameName);\n    }\n  }","id":101002,"modified_method":"public void appendElementReference(final StringBuffer buf, RefElement refElement, String linkText, @NonNls String frameName) {    \n    if (myExporter == null) {\n      final URL url = ((RefElementImpl)refElement).getURL();\n      if (url != null) {\n        appendElementReference(buf, url.toString(), linkText, frameName);\n      }\n    }\n    else {\n      appendElementReference(buf, myExporter.getURL(refElement), linkText, frameName);\n    }\n  }","commit_id":"ad231fc283a32a1f8bbae1991da8a5b297967d7c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void appendResolution(StringBuffer buf, InspectionTool tool, RefEntity where) {\n    if (myExporter != null) return;\n    if (where instanceof RefElement && !((RefElement)where).isValid()) return;\n    QuickFixAction[] quickFixes = tool.getQuickFixes(new RefEntity[] {where});\n    if (quickFixes != null) {\n      boolean listStarted = false;\n      for (int i = 0; i < quickFixes.length; i++) {\n        QuickFixAction quickFix = quickFixes[i];\n        final String text = quickFix.getText(where);\n        if (text == null) continue;\n        if (!listStarted) {\n          appendHeading(buf, InspectionsBundle.message(\"inspection.problem.resolution\"));\n          startList(buf);\n          listStarted = true;\n        }\n        startListItem(buf);\n        appendQuickFix(buf, text, i);\n        doneListItem(buf);\n      }\n\n      if (listStarted) {\n        doneList(buf);\n      }\n    }\n  }","id":101003,"modified_method":"protected void appendResolution(StringBuffer buf, InspectionTool tool, RefEntity where) {\n    if (myExporter != null) return;\n    if (where instanceof RefElement && !where.isValid()) return;\n    QuickFixAction[] quickFixes = tool.getQuickFixes(new RefEntity[] {where});\n    if (quickFixes != null) {\n      boolean listStarted = false;\n      for (int i = 0; i < quickFixes.length; i++) {\n        QuickFixAction quickFix = quickFixes[i];\n        final String text = quickFix.getText(where);\n        if (text == null) continue;\n        if (!listStarted) {\n          appendHeading(buf, InspectionsBundle.message(\"inspection.problem.resolution\"));\n          startList(buf);\n          listStarted = true;\n        }\n        startListItem(buf);\n        appendQuickFix(buf, text, i);\n        doneListItem(buf);\n      }\n\n      if (listStarted) {\n        doneList(buf);\n      }\n    }\n  }","commit_id":"ad231fc283a32a1f8bbae1991da8a5b297967d7c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void appendQuickFix(@NonNls final StringBuffer buf, String text, int index) {\n    if (myExporter == null) {\n      buf.append(FONT_OPENING);\n      buf.append(CLOSE_TAG);\n      buf.append(\"<a HREF=\\\"file://bred.txt#invoke:\" + index);\n      buf.append(\"\\\">\");\n      buf.append(text);\n      buf.append(\"<\/a><\/font>\");\n    }\n  }","id":101004,"modified_method":"protected void appendQuickFix(@NonNls final StringBuffer buf, String text, int index) {\n    if (myExporter == null) {\n      buf.append(FONT_OPENING);\n      buf.append(CLOSE_TAG);\n      buf.append(\"<a HREF=\\\"file://bred.txt#invoke:\").append(index);\n      buf.append(\"\\\">\");\n      buf.append(text);\n      buf.append(\"<\/a><\/font>\");\n    }\n  }","commit_id":"ad231fc283a32a1f8bbae1991da8a5b297967d7c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void hyperlinkUpdate(HyperlinkEvent e) {\n      if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n        JEditorPane pane = (JEditorPane)e.getSource();\n        if (e instanceof HTMLFrameHyperlinkEvent) {\n          HTMLFrameHyperlinkEvent evt = (HTMLFrameHyperlinkEvent)e;\n          HTMLDocument doc = (HTMLDocument)pane.getDocument();\n          doc.processHTMLFrameHyperlinkEvent(evt);\n        }\n        else {\n          BrowserUtil.launchBrowser(e.getURL().toString());\n        }\n      }\n    }","id":101005,"modified_method":"public void hyperlinkUpdate(HyperlinkEvent e) {\n      if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n        JEditorPane pane = (JEditorPane)e.getSource();\n        if (e instanceof HTMLFrameHyperlinkEvent) {\n          HTMLFrameHyperlinkEvent evt = (HTMLFrameHyperlinkEvent)e;\n          HTMLDocument doc = (HTMLDocument)pane.getDocument();\n          doc.processHTMLFrameHyperlinkEvent(evt);\n        }\n        else {\n          URL url = e.getURL();\n          if( url != null )\n            BrowserUtil.launchBrowser( url.toString() );\n        }\n      }\n    }","commit_id":"0363bdfb01b79db64524f1f65787668ea821e403","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addAuthors(Document document, Element parentElement, Extension extension)\n    {\n        List<ExtensionAuthor> authors = extension.getAuthors();\n        if (!authors.isEmpty()) {\n            Element dependenciesElement = document.createElement(ELEMENT_AUTHORS);\n            parentElement.appendChild(dependenciesElement);\n\n            for (ExtensionAuthor author : authors) {\n                Element dependencyElement = document.createElement(ELEMENT_AAUTHOR);\n                dependenciesElement.appendChild(dependencyElement);\n\n                addElement(document, dependencyElement, ELEMENT_AANAME, author.getName());\n                addElement(document, dependencyElement, ELEMENT_AAURL, author.getURL().toString());\n            }\n        }\n    }","id":101006,"modified_method":"private void addAuthors(Document document, Element parentElement, Extension extension)\n    {\n        List<ExtensionAuthor> authors = extension.getAuthors();\n        if (!authors.isEmpty()) {\n            Element dependenciesElement = document.createElement(ELEMENT_AUTHORS);\n            parentElement.appendChild(dependenciesElement);\n\n            for (ExtensionAuthor author : authors) {\n                Element dependencyElement = document.createElement(ELEMENT_AAUTHOR);\n                dependenciesElement.appendChild(dependencyElement);\n\n                addElement(document, dependencyElement, ELEMENT_AANAME, author.getName());\n\n                URL authorURL = author.getURL();\n                if (authorURL != null) {\n                    addElement(document, dependencyElement, ELEMENT_AAURL, authorURL.toString());\n                }\n            }\n        }\n    }","commit_id":"28e3f25ee2fb56c2888beb1c6ad7498c0c55ea44","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void run(BuildExperimentSpec experiment, MeasuredOperationList results) {\n        System.out.println();\n        System.out.println(String.format(\"%s ...\", experiment.getDisplayName()));\n        System.out.println();\n\n        File workingDirectory = experiment.getInvocation().getWorkingDirectory();\n        final List<String> additionalJvmOpts = dataCollector.getAdditionalJvmOpts(workingDirectory);\n        final List<String> additionalArgs = new ArrayList<String>(dataCollector.getAdditionalArgs(workingDirectory));\n        additionalArgs.add(\"-PbuildExperimentDisplayName=\" + experiment.getDisplayName());\n        if (System.getProperty(\"org.gradle.performance.heapdump\") != null) {\n            additionalArgs.add(\"-Pheapdump\");\n        }\n\n        GradleInvocationSpec buildSpec = experiment.getInvocation().withAdditionalJvmOpts(additionalJvmOpts).withAdditionalArgs(additionalArgs);\n        File projectDir = buildSpec.getWorkingDirectory();\n        GradleSession session = executerProvider.session(buildSpec);\n\n        session.prepare();\n        try {\n            int warmUpCount = warmupsForExperiment(experiment);\n            for (int i = 0; i < warmUpCount; i++) {\n                System.out.println();\n                System.out.println(String.format(\"Warm-up #%s\", i + 1));\n                runOnce(session, experiment, new MeasuredOperationList(), projectDir, Phase.WARMUP, i + 1, warmUpCount);\n            }\n            waitForMillis(experiment, experiment.getSleepAfterWarmUpMillis());\n            int invocationCount = invocationsForExperiment(experiment);\n            for (int i = 0; i < invocationCount; i++) {\n                if (i > 0) {\n                    waitForMillis(experiment, experiment.getSleepAfterTestRoundMillis());\n                }\n                System.out.println();\n                System.out.println(String.format(\"Test run #%s\", i + 1));\n                runOnce(session, experiment, results, projectDir, Phase.MEASUREMENT, i + 1, invocationCount);\n            }\n        } finally {\n            session.cleanup();\n        }\n    }","id":101007,"modified_method":"public void run(BuildExperimentSpec experiment, MeasuredOperationList results) {\n        System.out.println();\n        System.out.println(String.format(\"%s ...\", experiment.getDisplayName()));\n        System.out.println();\n\n        InvocationSpec invocationSpec = experiment.getInvocation();\n        if (invocationSpec instanceof GradleInvocationSpec) {\n            GradleInvocationSpec invocation = (GradleInvocationSpec) invocationSpec;\n            File workingDirectory = invocation.getWorkingDirectory();\n            final List<String> additionalJvmOpts = dataCollector.getAdditionalJvmOpts(workingDirectory);\n            final List<String> additionalArgs = new ArrayList<String>(dataCollector.getAdditionalArgs(workingDirectory));\n            additionalArgs.add(\"-PbuildExperimentDisplayName=\" + experiment.getDisplayName());\n            if (System.getProperty(\"org.gradle.performance.heapdump\") != null) {\n                additionalArgs.add(\"-Pheapdump\");\n            }\n\n            GradleInvocationSpec buildSpec = invocation.withAdditionalJvmOpts(additionalJvmOpts).withAdditionalArgs(additionalArgs);\n            File projectDir = buildSpec.getWorkingDirectory();\n            GradleSession session = executerProvider.session(buildSpec);\n\n            session.prepare();\n            try {\n                int warmUpCount = warmupsForExperiment(experiment);\n                for (int i = 0; i < warmUpCount; i++) {\n                    System.out.println();\n                    System.out.println(String.format(\"Warm-up #%s\", i + 1));\n                    runOnce(session, experiment, new MeasuredOperationList(), projectDir, Phase.WARMUP, i + 1, warmUpCount);\n                }\n                waitForMillis(experiment, experiment.getSleepAfterWarmUpMillis());\n                int invocationCount = invocationsForExperiment(experiment);\n                for (int i = 0; i < invocationCount; i++) {\n                    if (i > 0) {\n                        waitForMillis(experiment, experiment.getSleepAfterTestRoundMillis());\n                    }\n                    System.out.println();\n                    System.out.println(String.format(\"Test run #%s\", i + 1));\n                    runOnce(session, experiment, results, projectDir, Phase.MEASUREMENT, i + 1, invocationCount);\n                }\n            } finally {\n                session.cleanup();\n            }\n        }\n    }","commit_id":"9da3914ea942ddf56defb4a641994ac85888c53a","url":"https://github.com/gradle/gradle"},{"original_method":"private void waitForMillis(BuildExperimentSpec experiment, long sleepTimeMillis) {\n        if (experiment.getInvocation().getBuildWillRunInDaemon() && sleepTimeMillis > 0L) {\n            System.out.println();\n            System.out.println(String.format(\"Waiting %d ms\", sleepTimeMillis));\n            try {\n                Thread.sleep(sleepTimeMillis);\n            } catch (InterruptedException e) {\n                throw UncheckedException.throwAsUncheckedException(e);\n            }\n        }\n    }","id":101008,"modified_method":"protected void waitForMillis(BuildExperimentSpec experiment, long sleepTimeMillis) {\n        InvocationSpec invocation = experiment.getInvocation();\n        if (invocation instanceof GradleInvocationSpec) {\n            if (((GradleInvocationSpec) invocation).getBuildWillRunInDaemon() && sleepTimeMillis > 0L) {\n                System.out.println();\n                System.out.println(String.format(\"Waiting %d ms\", sleepTimeMillis));\n                try {\n                    Thread.sleep(sleepTimeMillis);\n                } catch (InterruptedException e) {\n                    throw UncheckedException.throwAsUncheckedException(e);\n                }\n            }\n        }\n    }","commit_id":"9da3914ea942ddf56defb4a641994ac85888c53a","url":"https://github.com/gradle/gradle"},{"original_method":"private int warmupsForExperiment(BuildExperimentSpec experiment) {\n        if (experiment.getWarmUpCount() != null) {\n            return experiment.getWarmUpCount();\n        }\n        // Use more invocations to warmup when using the daemon, to allow the JVM to warm things up\n        if (experiment.getInvocation().getBuildWillRunInDaemon()) {\n            return 3;\n        }\n        return 1;\n    }","id":101009,"modified_method":"protected int warmupsForExperiment(BuildExperimentSpec experiment) {\n        if (experiment.getWarmUpCount() != null) {\n            return experiment.getWarmUpCount();\n        }\n        // Use more invocations to warmup when using the daemon, to allow the JVM to warm things up\n        InvocationSpec invocation = experiment.getInvocation();\n        if (invocation instanceof GradleInvocationSpec) {\n            if (((GradleInvocationSpec) invocation).getBuildWillRunInDaemon()) {\n                return 3;\n            }\n        }\n        return 1;\n    }","commit_id":"9da3914ea942ddf56defb4a641994ac85888c53a","url":"https://github.com/gradle/gradle"},{"original_method":"private Integer invocationsForExperiment(BuildExperimentSpec experiment) {\n        if (experiment.getInvocationCount() != null) {\n            return experiment.getInvocationCount();\n        }\n        // Take more samples when using the daemon, as execution time tends to be spiky\n        if (experiment.getInvocation().getBuildWillRunInDaemon()) {\n            return 8;\n        }\n        return 5;\n    }","id":101010,"modified_method":"protected Integer invocationsForExperiment(BuildExperimentSpec experiment) {\n        if (experiment.getInvocationCount() != null) {\n            return experiment.getInvocationCount();\n        }\n        // Take more samples when using the daemon, as execution time tends to be spiky\n        InvocationSpec invocation = experiment.getInvocation();\n        if (invocation instanceof GradleInvocationSpec) {\n            if (((GradleInvocationSpec) invocation).getBuildWillRunInDaemon()) {\n                return 8;\n            }\n        }\n        return 5;\n    }","commit_id":"9da3914ea942ddf56defb4a641994ac85888c53a","url":"https://github.com/gradle/gradle"},{"original_method":"/**\r\n   * Sends an email. Supports the following configuration: subject, message, to, cc, bcc, date, attachments\r\n   * \r\n   * @param iMessage\r\n   *          Configuration as Map<String,Object>\r\n   * @throws AddressException\r\n   * @throws MessagingException\r\n   * @throws ParseException\r\n   */\r\n  public void send(final Map<String, Object> iMessage) throws AddressException, MessagingException, ParseException {\r\n    final String profileName = (String) iMessage.get(\"profile\");\r\n\r\n    final OMailProfile profile = profiles.get(profileName);\r\n    if (profile == null)\r\n      throw new IllegalArgumentException(\"Mail profile '\" + profileName + \"' is not configured on server\");\r\n\r\n    // creates a new session with an authenticator\r\n    Authenticator auth = new OSMTPAuthenticator((String) profile.getProperty(\"mail.smtp.user\"),\r\n        (String) profile.getProperty(\"mail.smtp.password\"));\r\n    Session session = Session.getInstance(profile, auth);\r\n\r\n    // creates a new e-mail message\r\n    MimeMessage msg = new MimeMessage(session);\r\n\r\n    msg.setFrom(new InternetAddress((String) iMessage.get(\"from\")));\r\n\r\n    InternetAddress[] toAddresses = { new InternetAddress((String) iMessage.get(\"to\")) };\r\n    msg.setRecipients(Message.RecipientType.TO, toAddresses);\r\n    String cc = (String) iMessage.get(\"cc\");\r\n    if (cc != null && !cc.isEmpty()) {\r\n      InternetAddress[] ccAddresses = { new InternetAddress(cc) };\r\n      msg.setRecipients(Message.RecipientType.CC, ccAddresses);\r\n    }\r\n    String bcc = (String) iMessage.get(\"bcc\");\r\n    if (bcc != null && !bcc.isEmpty()) {\r\n      InternetAddress[] bccAddresses = { new InternetAddress(bcc) };\r\n      msg.setRecipients(Message.RecipientType.BCC, bccAddresses);\r\n    }\r\n    msg.setSubject((String) iMessage.get(\"subject\"));\r\n\r\n    // DATE\r\n    Object date = iMessage.get(\"date\");\r\n    final Date sendDate;\r\n    if (date == null)\r\n      // NOT SPECIFIED = NOW\r\n      sendDate = new Date();\r\n    else if (date instanceof Date)\r\n      // PASSED\r\n      sendDate = (Date) date;\r\n    else {\r\n      // FORMAT IT\r\n      String dateFormat = (String) profile.getProperty(\"mail.date.format\");\r\n      if (dateFormat == null)\r\n        dateFormat = \"yyyy-MM-dd HH:mm:ss\";\r\n      sendDate = new SimpleDateFormat(dateFormat).parse(date.toString());\r\n    }\r\n    msg.setSentDate(sendDate);\r\n\r\n    // creates message part\r\n    MimeBodyPart messageBodyPart = new MimeBodyPart();\r\n    messageBodyPart.setContent(iMessage.get(\"message\"), \"text/html\");\r\n\r\n    // creates multi-part\r\n    Multipart multipart = new MimeMultipart();\r\n    multipart.addBodyPart(messageBodyPart);\r\n\r\n    final String[] attachments = (String[]) iMessage.get(\"attachments\");\r\n    // adds attachments\r\n    if (attachments != null && attachments.length > 0) {\r\n      for (String filePath : attachments) {\r\n        addAttachment(multipart, filePath);\r\n      }\r\n    }\r\n\r\n    // sets the multi-part as e-mail's content\r\n    msg.setContent(multipart);\r\n\r\n    // sends the e-mail\r\n    Transport.send(msg);\r\n  }","id":101011,"modified_method":"/**\r\n   * Sends an email. Supports the following configuration: subject, message, to, cc, bcc, date, attachments\r\n   * \r\n   * @param iMessage\r\n   *          Configuration as Map<String,Object>\r\n   * @throws AddressException\r\n   * @throws MessagingException\r\n   * @throws ParseException\r\n   */\r\n  public void send(final Map<String, Object> iMessage) throws AddressException, MessagingException, ParseException {\r\n    if (iMessage == null)\r\n      throw new IllegalArgumentException(\"Configuration is null\");\r\n\r\n    final String profileName = (String) iMessage.get(\"profile\");\r\n\r\n    final OMailProfile profile = profiles.get(profileName);\r\n    if (profile == null)\r\n      throw new IllegalArgumentException(\"Mail profile '\" + profileName + \"' is not configured on server\");\r\n\r\n    // creates a new session with an authenticator\r\n    Authenticator auth = new OSMTPAuthenticator((String) profile.getProperty(\"mail.smtp.user\"),\r\n        (String) profile.getProperty(\"mail.smtp.password\"));\r\n    final Session session = Session.getInstance(profile, auth);\r\n\r\n    // creates a new e-mail message\r\n    MimeMessage msg = new MimeMessage(session);\r\n\r\n    final String from;\r\n    if (iMessage.containsKey(\"from\"))\r\n      // GET THE 'FROM' FROM THE MESSAGE\r\n      from = (String) iMessage.get(\"from\");\r\n    else\r\n      // GET THE 'FROM' FROM PROFILE\r\n      from = (String) profile.getProperty(\"mail.from\");\r\n\r\n    if (from != null)\r\n      msg.setFrom(new InternetAddress(from));\r\n\r\n    final String to = (String) iMessage.get(\"to\");\r\n    if (to != null && !to.isEmpty())\r\n      msg.setRecipients(Message.RecipientType.TO, getEmails(to));\r\n\r\n    final String cc = (String) iMessage.get(\"cc\");\r\n    if (cc != null && !cc.isEmpty())\r\n      msg.setRecipients(Message.RecipientType.CC, getEmails(cc));\r\n\r\n    final String bcc = (String) iMessage.get(\"bcc\");\r\n    if (bcc != null && !bcc.isEmpty())\r\n      msg.setRecipients(Message.RecipientType.BCC, getEmails(bcc));\r\n\r\n    msg.setSubject((String) iMessage.get(\"subject\"));\r\n\r\n    // DATE\r\n    Object date = iMessage.get(\"date\");\r\n    final Date sendDate;\r\n    if (date == null)\r\n      // NOT SPECIFIED = NOW\r\n      sendDate = new Date();\r\n    else if (date instanceof Date)\r\n      // PASSED\r\n      sendDate = (Date) date;\r\n    else {\r\n      // FORMAT IT\r\n      String dateFormat = (String) profile.getProperty(\"mail.date.format\");\r\n      if (dateFormat == null)\r\n        dateFormat = \"yyyy-MM-dd HH:mm:ss\";\r\n      sendDate = new SimpleDateFormat(dateFormat).parse(date.toString());\r\n    }\r\n    msg.setSentDate(sendDate);\r\n\r\n    // creates message part\r\n    MimeBodyPart messageBodyPart = new MimeBodyPart();\r\n    messageBodyPart.setContent(iMessage.get(\"message\"), \"text/html\");\r\n\r\n    // creates multi-part\r\n    Multipart multipart = new MimeMultipart();\r\n    multipart.addBodyPart(messageBodyPart);\r\n\r\n    final String[] attachments = (String[]) iMessage.get(\"attachments\");\r\n    // adds attachments\r\n    if (attachments != null && attachments.length > 0) {\r\n      for (String filePath : attachments) {\r\n        addAttachment(multipart, filePath);\r\n      }\r\n    }\r\n\r\n    // sets the multi-part as e-mail's content\r\n    msg.setContent(multipart);\r\n\r\n    // sends the e-mail\r\n    Transport.send(msg);\r\n  }","commit_id":"296eadcb35ca381bc200fb79cb94e1a2380e1d0a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void config(final OServer oServer, final OServerParameterConfiguration[] iParams) {\r\n    for (OServerParameterConfiguration param : iParams) {\r\n      if (param.name.equalsIgnoreCase(\"enabled\")) {\r\n        if (!Boolean.parseBoolean(param.value))\r\n          // DISABLE IT\r\n          return;\r\n      } else if (param.name.startsWith(CONFIG_PROFILE_PREFIX)) {\r\n        final String parts = param.name.substring(CONFIG_PROFILE_PREFIX.length());\r\n        int pos = parts.indexOf('.');\r\n        if (pos == -1)\r\n          continue;\r\n\r\n        final String profileName = parts.substring(0, pos);\r\n        final String profileParam = parts.substring(pos + 1);\r\n\r\n        OMailProfile profile = profiles.get(profileName);\r\n        if (profile == null) {\r\n          profile = new OMailProfile();\r\n          profiles.put(profileName, profile);\r\n        }\r\n\r\n        if (profileParam.startsWith(CONFIG_MAIL_PREFIX)) {\r\n          profile.put(profileParam, param.value);\r\n        }\r\n      }\r\n    }\r\n\r\n    OLogManager.instance().info(this, \"Mail plugin installed and active. Loaded %d profile(s): %s\", profiles.size(),\r\n        profiles.keySet());\r\n  }","id":101012,"modified_method":"@Override\r\n  public void config(final OServer oServer, final OServerParameterConfiguration[] iParams) {\r\n    for (OServerParameterConfiguration param : iParams) {\r\n      if (param.name.equalsIgnoreCase(\"enabled\")) {\r\n        if (!Boolean.parseBoolean(param.value))\r\n          // DISABLE IT\r\n          return;\r\n      } else if (param.name.startsWith(CONFIG_PROFILE_PREFIX)) {\r\n        final String parts = param.name.substring(CONFIG_PROFILE_PREFIX.length());\r\n        int pos = parts.indexOf('.');\r\n        if (pos == -1)\r\n          continue;\r\n\r\n        final String profileName = parts.substring(0, pos);\r\n        final String profileParam = parts.substring(pos + 1);\r\n\r\n        OMailProfile profile = profiles.get(profileName);\r\n        if (profile == null) {\r\n          profile = new OMailProfile();\r\n          profiles.put(profileName, profile);\r\n        }\r\n\r\n        if (profileParam.startsWith(CONFIG_MAIL_PREFIX)) {\r\n          profile.put(profileParam, param.value);\r\n        }\r\n      }\r\n    }\r\n\r\n    OLogManager.instance().info(this, \"Installing Mail plugin, loaded %d profile(s): %s\", profiles.size(), profiles.keySet());\r\n  }","commit_id":"296eadcb35ca381bc200fb79cb94e1a2380e1d0a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Sends an email. Supports the following configuration: subject, message, to, cc, bcc, date, attachments\r\n   * \r\n   * @param iMessage\r\n   *          Configuration as Map<String,Object>\r\n   * @throws AddressException\r\n   * @throws MessagingException\r\n   * @throws ParseException\r\n   */\r\n  public void send(final Map<String, Object> iMessage) throws AddressException, MessagingException, ParseException {\r\n    final String profileName = (String) iMessage.get(\"profile\");\r\n\r\n    final OMailProfile profile = profiles.get(profileName);\r\n    if (profile == null)\r\n      throw new IllegalArgumentException(\"Mail profile '\" + profileName + \"' is not configured on server\");\r\n\r\n    // creates a new session with an authenticator\r\n    Authenticator auth = new OSMTPAuthenticator((String) profile.getProperty(\"mail.smtp.user\"),\r\n        (String) profile.getProperty(\"mail.smtp.password\"));\r\n    Session session = Session.getInstance(profile, auth);\r\n\r\n    // creates a new e-mail message\r\n    MimeMessage msg = new MimeMessage(session);\r\n\r\n    msg.setFrom(new InternetAddress((String) profile.getProperty(\"mail.smtp.user\")));\r\n    InternetAddress[] toAddresses = { new InternetAddress((String) iMessage.get(\"to\")) };\r\n    msg.setRecipients(Message.RecipientType.TO, toAddresses);\r\n    InternetAddress[] ccAddresses = { new InternetAddress((String) iMessage.get(\"cc\")) };\r\n    msg.setRecipients(Message.RecipientType.CC, ccAddresses);\r\n    InternetAddress[] bccAddresses = { new InternetAddress((String) iMessage.get(\"bcc\")) };\r\n    msg.setRecipients(Message.RecipientType.BCC, bccAddresses);\r\n    msg.setSubject((String) iMessage.get(\"subject\"));\r\n\r\n    // DATE\r\n    Object date = iMessage.get(\"date\");\r\n    final Date sendDate;\r\n    if (date == null)\r\n      // NOT SPECIFIED = NOW\r\n      sendDate = new Date();\r\n    else if (date instanceof Date)\r\n      // PASSED\r\n      sendDate = (Date) date;\r\n    else {\r\n      // FORMAT IT\r\n      String dateFormat = (String) profile.getProperty(\"mail.date.format\");\r\n      if (dateFormat == null)\r\n        dateFormat = \"yyyy-MM-dd HH:mm:ss\";\r\n      sendDate = new SimpleDateFormat(dateFormat).parse(date.toString());\r\n    }\r\n    msg.setSentDate(sendDate);\r\n\r\n    // creates message part\r\n    MimeBodyPart messageBodyPart = new MimeBodyPart();\r\n    messageBodyPart.setContent(iMessage.get(\"message\"), \"text/html\");\r\n\r\n    // creates multi-part\r\n    Multipart multipart = new MimeMultipart();\r\n    multipart.addBodyPart(messageBodyPart);\r\n\r\n    final String[] attachments = (String[]) iMessage.get(\"attachments\");\r\n    // adds attachments\r\n    if (attachments != null && attachments.length > 0) {\r\n      for (String filePath : attachments) {\r\n        addAttachment(multipart, filePath);\r\n      }\r\n    }\r\n\r\n    // sets the multi-part as e-mail's content\r\n    msg.setContent(multipart);\r\n\r\n    // sends the e-mail\r\n    Transport.send(msg);\r\n  }","id":101013,"modified_method":"/**\r\n   * Sends an email. Supports the following configuration: subject, message, to, cc, bcc, date, attachments\r\n   * \r\n   * @param iMessage\r\n   *          Configuration as Map<String,Object>\r\n   * @throws AddressException\r\n   * @throws MessagingException\r\n   * @throws ParseException\r\n   */\r\n  public void send(final Map<String, Object> iMessage) throws AddressException, MessagingException, ParseException {\r\n    final String profileName = (String) iMessage.get(\"profile\");\r\n\r\n    final OMailProfile profile = profiles.get(profileName);\r\n    if (profile == null)\r\n      throw new IllegalArgumentException(\"Mail profile '\" + profileName + \"' is not configured on server\");\r\n\r\n    // creates a new session with an authenticator\r\n    Authenticator auth = new OSMTPAuthenticator((String) profile.getProperty(\"mail.smtp.user\"),\r\n        (String) profile.getProperty(\"mail.smtp.password\"));\r\n    Session session = Session.getInstance(profile, auth);\r\n\r\n    // creates a new e-mail message\r\n    MimeMessage msg = new MimeMessage(session);\r\n\r\n    msg.setFrom(new InternetAddress((String) iMessage.get(\"from\")));\r\n\r\n\tInternetAddress[] toAddresses = { new InternetAddress(\r\n\t\t\t(String) iMessage.get(\"to\")) };\r\n\tmsg.setRecipients(Message.RecipientType.TO, toAddresses);\r\n\tString cc = (String) iMessage.get(\"cc\");\r\n\tif (cc != null && !cc.isEmpty()) {\r\n\t\tInternetAddress[] ccAddresses = { new InternetAddress(cc) };\r\n\t\tmsg.setRecipients(Message.RecipientType.CC, ccAddresses);\r\n\t}\r\n\tString bcc = (String) iMessage.get(\"bcc\");\r\n\tif (bcc != null && !bcc.isEmpty()) {\r\n\t\tInternetAddress[] bccAddresses = { new InternetAddress(bcc) };\r\n\t\tmsg.setRecipients(Message.RecipientType.BCC, bccAddresses);\r\n\t}\r\n\tmsg.setSubject((String) iMessage.get(\"subject\"));\r\n\r\n    // DATE\r\n    Object date = iMessage.get(\"date\");\r\n    final Date sendDate;\r\n    if (date == null)\r\n      // NOT SPECIFIED = NOW\r\n      sendDate = new Date();\r\n    else if (date instanceof Date)\r\n      // PASSED\r\n      sendDate = (Date) date;\r\n    else {\r\n      // FORMAT IT\r\n      String dateFormat = (String) profile.getProperty(\"mail.date.format\");\r\n      if (dateFormat == null)\r\n        dateFormat = \"yyyy-MM-dd HH:mm:ss\";\r\n      sendDate = new SimpleDateFormat(dateFormat).parse(date.toString());\r\n    }\r\n    msg.setSentDate(sendDate);\r\n\r\n    // creates message part\r\n    MimeBodyPart messageBodyPart = new MimeBodyPart();\r\n    messageBodyPart.setContent(iMessage.get(\"message\"), \"text/html\");\r\n\r\n    // creates multi-part\r\n    Multipart multipart = new MimeMultipart();\r\n    multipart.addBodyPart(messageBodyPart);\r\n\r\n    final String[] attachments = (String[]) iMessage.get(\"attachments\");\r\n    // adds attachments\r\n    if (attachments != null && attachments.length > 0) {\r\n      for (String filePath : attachments) {\r\n        addAttachment(multipart, filePath);\r\n      }\r\n    }\r\n\r\n    // sets the multi-part as e-mail's content\r\n    msg.setContent(multipart);\r\n\r\n    // sends the e-mail\r\n    Transport.send(msg);\r\n  }","commit_id":"f95237c262047ddcd57c739bc10b9baba83b9b9a","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Gets the module authors\n     * @return The list of module authors, or empty list of no authors could be found\n     */\n    public List<String> getModuleAuthors() {\n        ArrayList<String> authors = new ArrayList<String>();\n        for (Annotation ann : moduleDescriptor.getAnnotations()) {\n            if (ann.getName().equals(\"by\")) {\n                authors.addAll(ann.getPositionalArguments());\n            }\n        }\n        return authors;\n    }","id":101014,"modified_method":"/**\n     * Gets the module authors\n     * @return The list of module authors, or empty list of no authors could be found\n     */\n    public List<String> getModuleAuthors() {\n        ArrayList<String> authors = new ArrayList<String>();\n        for (Annotation ann : moduleDescriptor.getAnnotations()) {\n            if (ann.getName().equals(\"by\")) {\n                for (String author : ann.getPositionalArguments()) {\n                    authors.add(removeQuotes(author));\n                }\n            }\n        }\n        return authors;\n    }","commit_id":"5570d502a295c39b9fb7eab83c632b9a6768175c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Gets the module license\n     * @return The module version, or null if no version could be found\n     */\n    public String getModuleLicense() {\n        for (Annotation ann : moduleDescriptor.getAnnotations()) {\n            if (ann.getName().equals(\"license\")) {\n                List<String> args = ann.getPositionalArguments();\n                if (args != null && !args.isEmpty()) {\n                    return args.get(0);\n                }\n            }\n        }\n        return null;\n    }","id":101015,"modified_method":"/**\n     * Gets the module license\n     * @return The module version, or null if no version could be found\n     */\n    public String getModuleLicense() {\n        for (Annotation ann : moduleDescriptor.getAnnotations()) {\n            if (ann.getName().equals(\"license\")) {\n                List<String> args = ann.getPositionalArguments();\n                if (args != null && !args.isEmpty()) {\n                    return removeQuotes(args.get(0));\n                }\n            }\n        }\n        return null;\n    }","commit_id":"5570d502a295c39b9fb7eab83c632b9a6768175c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/** Returns the list of authors specified in the module through \"by\" annotations. */\n    public static List<String> getAuthors(Module module) {\n        ArrayList<String> moduleAuthors = new ArrayList<>();\n        for (Annotation a : module.getAnnotations()) {\n            if (a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty() && a.getName().equals(\"by\")) {\n                moduleAuthors.addAll(a.getPositionalArguments());\n            }\n        }\n        return moduleAuthors;\n    }","id":101016,"modified_method":"/** Returns the list of authors specified in the module through \"by\" annotations. */\n    public static List<String> getAuthors(Module module) {\n        ArrayList<String> moduleAuthors = new ArrayList<>();\n        for (Annotation a : module.getAnnotations()) {\n            if (a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty() && a.getName().equals(\"by\")) {\n                for (String author : a.getPositionalArguments()) {\n                    moduleAuthors.add(unquote(author));\n                }\n            }\n        }\n        return moduleAuthors;\n    }","commit_id":"98d313c0e05218cf6ffc39b548405fff86233569","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static String getDoc(Package pkg) {\n        for (Annotation a : pkg.getAnnotations()) {\n            if (a.getName().equals(\"doc\") && a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty()) {\n                return a.getPositionalArguments().get(0);\n            }\n        }\n        return \"\";\n    }","id":101017,"modified_method":"public static String getDoc(Package pkg) {\n        for (Annotation a : pkg.getAnnotations()) {\n            if (a.getName().equals(\"doc\") && a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty()) {\n                return unquote(a.getPositionalArguments().get(0));\n            }\n        }\n        return \"\";\n    }","commit_id":"98d313c0e05218cf6ffc39b548405fff86233569","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static String getDoc(Module module) {\n        for (Annotation a : module.getAnnotations()) {\n            if (a.getName().equals(\"doc\") && a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty()) {\n                return a.getPositionalArguments().get(0);\n            }\n        }\n        return \"\";\n    }","id":101018,"modified_method":"public static String getDoc(Module module) {\n        for (Annotation a : module.getAnnotations()) {\n            if (a.getName().equals(\"doc\") && a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty()) {\n                return unquote(a.getPositionalArguments().get(0));\n            }\n        }\n        return \"\";\n    }","commit_id":"98d313c0e05218cf6ffc39b548405fff86233569","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static String unquote(String string) {\n        return string.substring(1, string.length() - 1);\n    }","id":101019,"modified_method":"/** Remove quotes from a string, if it starts and ends with them. */\n    public static String unquote(String string) {\n        if (string.length() >= 2 && string.charAt(0) == '\"' && string.charAt(string.length()-1) == '\"') {\n            return string.substring(1, string.length() - 1);\n        }\n        return string;\n    }","commit_id":"98d313c0e05218cf6ffc39b548405fff86233569","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/** Returns the list of authors specified in the package through \"by\" annotations. */\n    public static List<String> getAuthors(Package module) {\n        ArrayList<String> moduleAuthors = new ArrayList<>();\n        for (Annotation a : module.getAnnotations()) {\n            if (a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty() && a.getName().equals(\"by\")) {\n                moduleAuthors.addAll(a.getPositionalArguments());\n            }\n        }\n        return moduleAuthors;\n    }","id":101020,"modified_method":"/** Returns the list of authors specified in the package through \"by\" annotations. */\n    public static List<String> getAuthors(Package module) {\n        ArrayList<String> moduleAuthors = new ArrayList<>();\n        for (Annotation a : module.getAnnotations()) {\n            if (a.getPositionalArguments() != null && !a.getPositionalArguments().isEmpty() && a.getName().equals(\"by\")) {\n                for (String author : a.getPositionalArguments()) {\n                    moduleAuthors.add(unquote(author));\n                }\n            }\n        }\n        return moduleAuthors;\n    }","commit_id":"98d313c0e05218cf6ffc39b548405fff86233569","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            // Find the two permanents to meld.\r\n            UUID sourceId = source.getSourceId();\r\n            FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent(\"creature named \" + meldWithName);\r\n            filter.add(new NamePredicate(meldWithName));\r\n            TargetPermanent target = new TargetControlledCreaturePermanent(filter);\r\n            Set<UUID> meldWithList = target.possibleTargets(sourceId, source.getControllerId(), game);\r\n            UUID meldWithId;\r\n            if (meldWithList.size() == 1) {\r\n                meldWithId = meldWithList.iterator().next();\r\n            }\r\n            else {\r\n                controller.choose(Outcome.BoostCreature, target, sourceId, game);\r\n                meldWithId = target.getFirstTarget();\r\n            }\r\n            // Exile the two permanents to meld.\r\n            Permanent sourcePermanent = game.getPermanent(sourceId);\r\n            Permanent meldWithPermanent = game.getPermanent(meldWithId);\r\n            sourcePermanent.moveToExile(null, \"\", sourceId, game);\r\n            meldWithPermanent.moveToExile(null, \"\", sourceId, game);\r\n            // Create the meld card and move it to the battlefield.\r\n            Card sourceCard = game.getExile().getCard(sourceId, game);\r\n            Card meldWithCard = game.getExile().getCard(meldWithId, game);\r\n            if (!sourceCard.isCopy() && !meldWithCard.isCopy()) {\r\n                meldCard.setOwnerId(controller.getId());\r\n                meldCard.setTopHalfCard(meldWithCard, game);\r\n                meldCard.setbottomHalfCard(sourceCard, game);\r\n                meldCard.setMelded(true);\r\n                game.addMeldCard(meldCard.getId(), meldCard);\r\n                game.getState().addCard(meldCard);\r\n                meldCard.moveToZone(Zone.BATTLEFIELD, sourceId, game, false);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":101021,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            // Find the two permanents to meld.\r\n            UUID sourceId = source.getSourceId();\r\n            FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent(\"creature named \" + meldWithName);\r\n            filter.add(new NamePredicate(meldWithName));\r\n            TargetPermanent target = new TargetControlledCreaturePermanent(filter);\r\n            Set<UUID> meldWithList = target.possibleTargets(sourceId, source.getControllerId(), game);\r\n            if (meldWithList.isEmpty()) {\r\n                return false; // possible permanent has left the battlefield meanwhile\r\n            }\r\n            UUID meldWithId;\r\n            if (meldWithList.size() == 1) {\r\n                meldWithId = meldWithList.iterator().next();\r\n            } else {\r\n                controller.choose(Outcome.BoostCreature, target, sourceId, game);\r\n                meldWithId = target.getFirstTarget();\r\n            }\r\n            // Exile the two permanents to meld.\r\n            Permanent sourcePermanent = game.getPermanent(sourceId);\r\n            Permanent meldWithPermanent = game.getPermanent(meldWithId);\r\n            if (sourcePermanent != null && meldWithPermanent != null) {\r\n                sourcePermanent.moveToExile(null, \"\", sourceId, game);\r\n                meldWithPermanent.moveToExile(null, \"\", sourceId, game);\r\n                // Create the meld card and move it to the battlefield.\r\n                Card sourceCard = game.getExile().getCard(sourceId, game);\r\n                Card meldWithCard = game.getExile().getCard(meldWithId, game);\r\n                if (!sourceCard.isCopy() && !meldWithCard.isCopy()) {\r\n                    meldCard.setOwnerId(controller.getId());\r\n                    meldCard.setTopHalfCard(meldWithCard, game);\r\n                    meldCard.setbottomHalfCard(sourceCard, game);\r\n                    meldCard.setMelded(true);\r\n                    game.addMeldCard(meldCard.getId(), meldCard);\r\n                    game.getState().addCard(meldCard);\r\n                    meldCard.moveToZone(Zone.BATTLEFIELD, sourceId, game, false);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"aa58c76ba92243a66b2643bc1d0b2d507b3e3413","url":"https://github.com/magefree/mage"},{"original_method":"public ExileFromZoneTargetEffect(Zone zone, UUID exileId, String exileName, FilterCard filter) {\n        super(Outcome.Exile);\n        this.zone = zone;\n        this.filter = filter;\n        this.exileId = exileId;\n        this.exileName = exileName;\n        setText();\n    }","id":101022,"modified_method":"public ExileFromZoneTargetEffect(Zone zone, UUID exileId, String exileName, FilterCard filter) {\n        this(zone, exileId, exileName, filter, 1);\n    }","commit_id":"f9c6762c113787e97309bb643740bdec6f134498","url":"https://github.com/magefree/mage"},{"original_method":"public ExileFromZoneTargetEffect(final ExileFromZoneTargetEffect effect) {\n        super(effect);\n        this.zone = effect.zone;\n        this.filter = effect.filter.copy();\n        this.exileId = effect.exileId;\n        this.exileName = effect.exileName;\n    }","id":101023,"modified_method":"public ExileFromZoneTargetEffect(final ExileFromZoneTargetEffect effect) {\n        super(effect);\n        this.zone = effect.zone;\n        this.filter = effect.filter.copy();\n        this.exileId = effect.exileId;\n        this.exileName = effect.exileName;\n        this.amount = effect.amount;\n    }","commit_id":"f9c6762c113787e97309bb643740bdec6f134498","url":"https://github.com/magefree/mage"},{"original_method":"private void setText() {\n        staticText = \"Target player exiles a \" + filter.getMessage() + \" from his or her \" + zone.toString();\n    }","id":101024,"modified_method":"private void setText() {\n        if (amount == 1)\n            staticText = \"Target player exiles a \" + filter.getMessage() + \" from his or her \" + zone.toString();\n        else\n            staticText = \"Target player exiles \" + amount + \" \" + filter.getMessage() + \" from his or her \" + zone.toString();\n    }","commit_id":"f9c6762c113787e97309bb643740bdec6f134498","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(targetPointer.getFirst(source));\n        if (player != null) {\n            Target target;\n            Card card = null;\n            switch (zone) {\n                case HAND:\n                    target = new TargetCardInHand(filter);\n                    player.choose(Outcome.Exile, target, game);\n                    card = player.getHand().get(target.getFirstTarget(), game);\n                    break;\n                case GRAVEYARD:\n                    target = new TargetCardInGraveyard(filter);\n                    player.choose(Outcome.Exile, target, game);\n                    card = player.getGraveyard().get(target.getFirstTarget(), game);\n                    break;\n                default:\n                    \n            }\n\t\t\tif (card != null) {\n                card.moveToExile(exileId, exileName, source.getSourceId(), game);\n\t\t\t\treturn true;\n\t\t\t}\n        }\n        return false;\n\t}","id":101025,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(targetPointer.getFirst(source));\n        if (player != null) {\n            Target target = null;\n            switch (zone) {\n                case HAND:\n                    target = new TargetCardInHand(Math.min(player.getHand().count(filter, game), amount), filter);                    \n                    break;\n                case GRAVEYARD:\n                    target = new TargetCardInGraveyard(Math.min(player.getGraveyard().count(filter, game), amount), filter);\n                    break;\n                default:\n            }\n            if (target != null && target.canChoose(player.getId(), game)) {\n                if (target.choose(Outcome.Exile, player.getId(), game)) {\n                    for (UUID cardId: target.getTargets()) {\n                        Card card = game.getCard(cardId);\n                        if (card != null)\n                            card.moveToExile(exileId, exileName, source.getSourceId(), game);\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n\t}","commit_id":"f9c6762c113787e97309bb643740bdec6f134498","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean isChosen() {\n\t\tif (maxNumberOfTargets != 0 && targets.size() == maxNumberOfTargets)\n\t\t\treturn true;\n\t\treturn chosen;\n\t}","id":101026,"modified_method":"@Override\n\tpublic boolean isChosen() {\n        if (maxNumberOfTargets == 0 && minNumberOfTargets == 0)\n            return true;\n\t\tif (maxNumberOfTargets != 0 && targets.size() == maxNumberOfTargets)\n\t\t\treturn true;\n\t\treturn chosen;\n\t}","commit_id":"f9c6762c113787e97309bb643740bdec6f134498","url":"https://github.com/magefree/mage"},{"original_method":"void createInstance(Class type) {\n        WeldContainer weld = new Weld().initialize();\n        CreationalContext ctx = weld.getBeanManager().createCreationalContext(null);\n        for (Bean bean : weld.getBeanManager().getBeans(type)) {\n             weld.getBeanManager().getReference(bean, type, ctx);\n        }\n    }","id":101027,"modified_method":"void createInstance(Class type) {\n        WeldContainer weld = new Weld()\n                .disableDiscovery()\n                .extensions(new Fabric8Extension())\n                .beanClasses(ClientProducer.class, MyFactory.class, MyBean.class)\n                .alternatives(ClientProducer.class)\n                .initialize();\n        CreationalContext ctx = weld.getBeanManager().createCreationalContext(null);\n        for (Bean bean : weld.getBeanManager().getBeans(type)) {\n             weld.getBeanManager().getReference(bean, type, ctx);\n        }\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Produces\n    @Alternative\n    public KubernetesClient getKubernetesClient() throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n\n        mock.getMasterUrl().andReturn(new URL(\"https://kubernetes.default.svc\")).anyTimes();\n        mock.rootPaths().andReturn(new RootPathsBuilder()\n                .addToPaths(\"/api\",\n                        \"/api/v1beta3\",\n                        \"/api/v1\",\n                        \"/controllers\",\n                        \"/healthz\",\n                        \"/healthz/ping\",\n                        \"/logs/\",\n                        \"/metrics\",\n                        \"/ready\",\n                        \"/osapi\",\n                        \"/osapi/v1beta3\",\n                        \"/oapi\",\n                        \"/oapi/v1\",\n                        \"/swaggerapi/\")\n                .build()).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service1\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service1\").endMetadata()\n                        .withNewSpec()\n                            .addNewPort()\n                                .withProtocol(\"TCP\")\n                                .withPort(80)\n                                .withNewTargetPort(9090)\n                            .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                .build()\n        ).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service2\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service2\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(80)\n                        .withNewTargetPort(8080)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service3\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service3\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(443)\n                        .withNewTargetPort(443)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n\n        mock.services().inNamespace(\"default\").withName(\"multiport\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"multiport\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                            .withName(\"port1\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8081)\n                            .withNewTargetPort(8081)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port2\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8082)\n                            .withNewTargetPort(8082)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port2\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8083)\n                            .withNewTargetPort(8083)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n\n        mock.endpoints().inNamespace(\"default\").list().andReturn(new EndpointsListBuilder().build()).anyTimes();\n        mock.adapt(OpenShiftClient.class).andReturn(getOpenShiftClient()).anyTimes();\n\n        mock.getNamespace().andAnswer(new IAnswer<String>() {\n            @Override\n            public String answer() throws Throwable {\n                return Utils.getEnvVar(\"KUBERNETES_NAMESPACE\", null);\n            }\n        }).anyTimes();\n\n        return mock.replay();\n    }","id":101028,"modified_method":"@Produces\n    @Alternative\n    public KubernetesClient getKubernetesClient() throws MalformedURLException {\n        KubernetesMockClient mock = new KubernetesMockClient();\n\n        mock.getMasterUrl().andReturn(new URL(\"https://kubernetes.default.svc\")).anyTimes();\n        mock.rootPaths().andReturn(new RootPathsBuilder()\n                .addToPaths(\"/api\",\n                        \"/api/v1beta3\",\n                        \"/api/v1\",\n                        \"/controllers\",\n                        \"/healthz\",\n                        \"/healthz/ping\",\n                        \"/logs/\",\n                        \"/metrics\",\n                        \"/ready\",\n                        \"/osapi\",\n                        \"/osapi/v1beta3\",\n                        \"/oapi\",\n                        \"/oapi/v1\",\n                        \"/swaggerapi/\")\n                .build()).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service1\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service1\").endMetadata()\n                        .withNewSpec()\n                            .addNewPort()\n                                .withProtocol(\"TCP\")\n                                .withPort(80)\n                                .withNewTargetPort(9090)\n                            .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                .build()\n        ).anyTimes();\n\n        //Services\n        mock.services().inNamespace(\"default\").withName(\"service2\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service2\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(80)\n                        .withNewTargetPort(8080)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n        mock.services().inNamespace(\"default\").withName(\"service3\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"service3\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                        .withProtocol(\"TCP\")\n                        .withPort(443)\n                        .withNewTargetPort(443)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n\n        mock.services().inNamespace(\"default\").withName(\"multiport\").get().andReturn(\n                new ServiceBuilder()\n                        .withNewMetadata().withName(\"multiport\").endMetadata()\n                        .withNewSpec()\n                        .addNewPort()\n                            .withName(\"port1\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8081)\n                            .withNewTargetPort(8081)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port2\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8082)\n                            .withNewTargetPort(8082)\n                        .endPort()\n                        .addNewPort()\n                            .withName(\"port2\")\n                            .withProtocol(\"TCP\")\n                            .withPort(8083)\n                            .withNewTargetPort(8083)\n                        .endPort()\n                        .withPortalIP(\"172.30.17.2\")\n                        .endSpec()\n                        .build()\n        ).anyTimes();\n\n        //Endpoints\n        Endpoints service1Endpoints = new EndpointsBuilder()\n                .withNewMetadata()\n                    .withName(\"service1\")\n                    .withNamespace(\"default\")\n                .endMetadata()\n                .addNewSubset()\n                .addNewPort()\n                .withName(\"port\")\n                .withPort(8080)\n                .endPort()\n                .addNewAddresse()\n                .withIp(\"172.30.17.2\")\n                .endAddresse()\n                .endSubset()\n                .build();\n\n        mock.endpoints().inNamespace(\"default\").withName(\"service1\").get().andReturn(\n                service1Endpoints\n        ).anyTimes();\n\n        mock.endpoints().inNamespace(\"default\").list().andReturn(new EndpointsListBuilder().addToItems(service1Endpoints).build()).anyTimes();\n        mock.adapt(OpenShiftClient.class).andReturn(getOpenShiftClient()).anyTimes();\n\n        mock.getNamespace().andAnswer(new IAnswer<String>() {\n            @Override\n            public String answer() throws Throwable {\n                return Utils.getEnvVar(\"KUBERNETES_NAMESPACE\", null);\n            }\n        }).anyTimes();\n\n        return mock.replay();\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public <T, X> void onInjectionPoint(@Observes ProcessInjectionPoint<T, X> event, BeanManager beanManager) {\n        final InjectionPoint injectionPoint = event.getInjectionPoint();\n        if (isServiceInjectionPoint(injectionPoint)) {\n            Annotated annotated = injectionPoint.getAnnotated();\n            Alias alias = annotated.getAnnotation(Alias.class);\n            ServiceName name = annotated.getAnnotation(ServiceName.class);\n            PortName port = annotated.getAnnotation(PortName.class);\n            Protocol protocol = annotated.getAnnotation(Protocol.class);\n            External external = annotated.getAnnotation(External.class);\n            \n            Boolean serviceEndpoint = annotated.getAnnotation(Endpoint.class) != null;\n\n            String serviceName = name.value();\n            String serviceProtocol = protocol != null ? protocol.value() : \"tcp\";\n            String serviceAlias = alias != null ? alias.value() : null;\n            String servicePort = port != null ? port.value() : null;\n            Boolean serviceExternal = external != null && external.value();\n            \n            Type type = annotated.getBaseType();\n            if (type instanceof ParameterizedType && Instance.class.equals(((ParameterizedType)type).getRawType())) {\n                type =  ((ParameterizedType) type).getActualTypeArguments()[0];\n            }\n\n            if (type.equals(String.class)) {\n                ServiceUrlBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceExternal);\n            } else if (serviceEndpoint && isGenericOf(type, List.class, String.class)) {\n                ServiceUrlCollectionBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceEndpoint, Types.LIST_OF_STRINGS);\n            } else if (serviceEndpoint && isGenericOf(type, List.class, null)) {\n                //TODO: Integrate with Factories(?)\n            } else if (serviceEndpoint && isGenericOf(type, Set.class, String.class)) {\n                ServiceUrlCollectionBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceEndpoint, Types.SET_OF_STRINGS);\n            } else if (serviceEndpoint && isGenericOf(type, Set.class, null)) {\n                //TODO: Integrate with Factories(?)\n            } else {\n                ServiceBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceExternal, (Class) type);\n            }\n\n            if (protocol == null) {\n                setDefaultProtocol(event);\n            }\n            if (port == null) {\n                setDefaultPort(event);\n            }\n            if (external == null) {\n                setExternalFalse(event);\n            }\n        } else if (isConfigurationInjectionPoint(injectionPoint)) {\n            Annotated annotated = injectionPoint.getAnnotated();\n            Configuration configuration = annotated.getAnnotation(Configuration.class);\n            Type type = injectionPoint.getType();\n            String configurationId = configuration.value();\n            ConfigurationBean.getBean(configurationId, (Class) type);\n        }\n    }","id":101029,"modified_method":"public <T, X> void onInjectionPoint(@Observes ProcessInjectionPoint<T, X> event, BeanManager beanManager) {\n        final InjectionPoint injectionPoint = event.getInjectionPoint();\n        if (isServiceInjectionPoint(injectionPoint)) {\n            Annotated annotated = injectionPoint.getAnnotated();\n            Alias alias = annotated.getAnnotation(Alias.class);\n            ServiceName name = annotated.getAnnotation(ServiceName.class);\n            PortName port = annotated.getAnnotation(PortName.class);\n            Protocol protocol = annotated.getAnnotation(Protocol.class);\n            External external = annotated.getAnnotation(External.class);\n            \n            Boolean serviceEndpoint = annotated.getAnnotation(Endpoint.class) != null;\n\n            String serviceName = name.value();\n            String serviceProtocol = protocol != null ? protocol.value() : \"tcp\";\n            String serviceAlias = alias != null ? alias.value() : null;\n            String servicePort = port != null ? port.value() : null;\n            Boolean serviceExternal = external != null && external.value();\n            \n            Type type = annotated.getBaseType();\n            if (type instanceof ParameterizedType && Instance.class.equals(((ParameterizedType)type).getRawType())) {\n                type =  ((ParameterizedType) type).getActualTypeArguments()[0];\n            }\n\n            if (type.equals(String.class)) {\n                ServiceUrlBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceEndpoint, serviceExternal);\n            } else if (isGenericOf(type, List.class, String.class)) {\n                ServiceUrlCollectionBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceEndpoint, Types.LIST_OF_STRINGS);\n            } else if (isGenericOf(type, List.class, null)) {\n                //TODO: Integrate with Factories(?)\n            } else if (isGenericOf(type, Set.class, String.class)) {\n                ServiceUrlCollectionBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceEndpoint, Types.SET_OF_STRINGS);\n            } else if (isGenericOf(type, Set.class, null)) {\n                //TODO: Integrate with Factories(?)\n            } else if (type instanceof Class) {\n                ServiceBean.getBean(serviceName, serviceProtocol, serviceAlias, servicePort, serviceExternal, (Class) type);\n            } else {\n                throw new RuntimeException(String.format(INJECTION_POINT_UNKNOWN_TYPE, injectionPoint.getBean().getBeanClass(), type));\n            }\n\n            if (protocol == null) {\n                setDefaultProtocol(event);\n            }\n            if (port == null) {\n                setDefaultPort(event);\n            }\n            if (external == null) {\n                setExternalFalse(event);\n            }\n        } else if (isConfigurationInjectionPoint(injectionPoint)) {\n            Annotated annotated = injectionPoint.getAnnotated();\n            Configuration configuration = annotated.getAnnotation(Configuration.class);\n            Type type = injectionPoint.getType();\n            String configurationId = configuration.value();\n            ConfigurationBean.getBean(configurationId, (Class) type);\n        }\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Get Service URL from the context or create a producer. \n     * @param serviceId\n     * @param serviceProtocol \n     * @param context\n     * @return\n     */\n    private String getServiceUrl(String serviceId, String serviceProtocol, String servicePort, CreationalContext context) {\n        try {\n            return (String) BeanProvider.getContextualReference((Class) String.class, Qualifiers.create(serviceId, serviceProtocol, servicePort, false, serviceExternal));\n        } catch (IllegalStateException e) {\n            //Contextual Refernece not found, let's fallback to Configuration Producer.\n            Producer<String> producer = ServiceUrlBean.anyBean(serviceId, serviceProtocol, servicePort, serviceExternal).getProducer();\n            if (producer != null) {\n                return ServiceUrlBean.anyBean(serviceId, serviceProtocol, servicePort, serviceExternal).getProducer().produce(context);\n            } else {\n                throw new IllegalStateException(\"Could not find producer for service:\" + serviceId + \" protocol:\" + serviceProtocol);\n            }\n        }\n    }","id":101030,"modified_method":"/**\n     * Get Service URL from the context or create a producer. \n     * @param serviceId\n     * @param serviceProtocol \n     * @param context\n     * @return\n     */\n    private String getServiceUrl(String serviceId, String serviceProtocol, String servicePort, CreationalContext context) {\n        try {\n            return (String) BeanProvider.getContextualReference((Class) String.class, Qualifiers.create(serviceId, serviceProtocol, servicePort, false, serviceExternal));\n        } catch (IllegalStateException e) {\n            //Contextual Refernece not found, let's fallback to Configuration Producer.\n            Producer<String> producer = ServiceUrlBean.anyBean(serviceId, serviceProtocol, servicePort, false, serviceExternal).getProducer();\n            if (producer != null) {\n                return ServiceUrlBean.anyBean(serviceId, serviceProtocol, servicePort, false, serviceExternal).getProducer().produce(context);\n            } else {\n                throw new IllegalStateException(\"Could not find producer for service:\" + serviceId + \" protocol:\" + serviceProtocol);\n            }\n        }\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"void createInstance(Class type) {\n        WeldContainer weld = new Weld().initialize();\n        CreationalContext ctx = weld.getBeanManager().createCreationalContext(null);\n        for (Bean bean : weld.getBeanManager().getBeans(type)) {\n             weld.getBeanManager().getReference(bean, type, ctx);\n        }\n    }","id":101031,"modified_method":"void createInstance(Class type) {\n        WeldContainer weld = new Weld()\n                .disableDiscovery()\n                .extensions(new Fabric8Extension())\n                .beanClasses(ClientProducer.class, MyBean.class)\n                .alternatives(ClientProducer.class)\n                .initialize();\n        CreationalContext ctx = weld.getBeanManager().createCreationalContext(null);\n        for (Bean bean : weld.getBeanManager().getBeans(type)) {\n            weld.getBeanManager().getReference(bean, type, ctx);\n        }\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n        public int hashCode() {\n            int result = serviceName != null ? serviceName.hashCode() : 0;\n            result = 31 * result + (serviceProtocol != null ? serviceProtocol.hashCode() : 0);\n            result = 31 * result + (serviceAlias != null ? serviceAlias.hashCode() : 0);\n            result = 31 * result + (servicePort != null ? servicePort.hashCode() : 0);\n            result = 31 * result + (serviceExternal != null ? serviceExternal.hashCode() : 0);\n            return result;\n        }","id":101032,"modified_method":"@Override\n        public int hashCode() {\n            int result = serviceName != null ? serviceName.hashCode() : 0;\n            result = 31 * result + (serviceProtocol != null ? serviceProtocol.hashCode() : 0);\n            result = 31 * result + (serviceAlias != null ? serviceAlias.hashCode() : 0);\n            result = 31 * result + (servicePort != null ? servicePort.hashCode() : 0);\n            result = 31 * result + (serviceEndpoint != null ? serviceEndpoint.hashCode() : 0);\n            result = 31 * result + (serviceExternal != null ? serviceExternal.hashCode() : 0);\n            return result;\n        }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private ServiceUrlBean(String serviceName, String serviceProtocol, String serviceAlias, String servicePort, Boolean serviceExternal) {\n        super(serviceAlias, String.class, new ServiceUrlProducer(serviceName, serviceProtocol, servicePort, serviceExternal), Qualifiers.create(serviceName, serviceProtocol, servicePort, false, serviceExternal));\n        this.serviceName = serviceName;\n        this.serviceProtocol = serviceProtocol;\n        this.serviceAlias = serviceAlias;\n        this.servicePort = servicePort;\n        this.serviceExternal = serviceExternal;\n    }","id":101033,"modified_method":"private ServiceUrlBean(String serviceName, String serviceProtocol, String serviceAlias, String servicePort, Boolean serviceEndpoint, Boolean serviceExternal) {\n        super(serviceAlias, String.class,\n                serviceEndpoint ? new FirstEndpointProducer(serviceName, serviceProtocol) : new ServiceUrlProducer(serviceName, serviceProtocol, servicePort, serviceExternal) ,\n                Qualifiers.create(serviceName, serviceProtocol, servicePort, serviceEndpoint, serviceExternal));\n        this.serviceName = serviceName;\n        this.serviceProtocol = serviceProtocol;\n        this.serviceAlias = serviceAlias;\n        this.servicePort = servicePort;\n        this.serviceEndpoint = serviceEndpoint;\n        this.serviceExternal = serviceExternal;\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private Key(String serviceName, String serviceProtocol, String serviceAlias, String servicePort, Boolean serviceExternal) {\n            this.serviceName = serviceName;\n            this.serviceProtocol = serviceProtocol;\n            this.serviceAlias = serviceAlias;\n            this.servicePort = servicePort;\n            this.serviceExternal = serviceExternal;\n        }","id":101034,"modified_method":"private Key(String serviceName, String serviceProtocol, String serviceAlias, String servicePort, Boolean serviceEndpoint, Boolean serviceExternal) {\n            this.serviceName = serviceName;\n            this.serviceProtocol = serviceProtocol;\n            this.serviceAlias = serviceAlias;\n            this.servicePort = servicePort;\n            this.serviceEndpoint = serviceEndpoint;\n            this.serviceExternal = serviceExternal;\n        }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Key key = (Key) o;\n\n            if (serviceName != null ? !serviceName.equals(key.serviceName) : key.serviceName != null) return false;\n            if (serviceProtocol != null ? !serviceProtocol.equals(key.serviceProtocol) : key.serviceProtocol != null) return false;\n            if (serviceAlias != null ? !serviceAlias.equals(key.serviceAlias) : key.serviceAlias != null) return false;\n            if (servicePort != null ? !servicePort.equals(key.servicePort) : key.servicePort != null) return false;\n            if (serviceExternal != null ? !serviceExternal.equals(key.serviceExternal) : key.serviceExternal != null) return false;\n            return true;\n        }","id":101035,"modified_method":"@Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Key key = (Key) o;\n\n            if (serviceName != null ? !serviceName.equals(key.serviceName) : key.serviceName != null) return false;\n            if (serviceProtocol != null ? !serviceProtocol.equals(key.serviceProtocol) : key.serviceProtocol != null) return false;\n            if (serviceAlias != null ? !serviceAlias.equals(key.serviceAlias) : key.serviceAlias != null) return false;\n            if (servicePort != null ? !servicePort.equals(key.servicePort) : key.servicePort != null) return false;\n            if (serviceEndpoint != null ? !serviceEndpoint.equals(key.serviceEndpoint) : key.serviceEndpoint != null) return false;\n            if (serviceExternal != null ? !serviceExternal.equals(key.serviceExternal) : key.serviceExternal != null) return false;\n            return true;\n        }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static ServiceUrlBean getBean(String name, String protocol, String alias, String port, Boolean external) {\n        String serviceAlias = alias != null ? alias :\n                (external ? \"external-\" : \"\") + name + \"-\" + protocol + \"-\" + port + SUFFIX;\n        Key key = new Key(name, protocol, serviceAlias, port, external);\n        if (BEANS.containsKey(key)) {\n            return BEANS.get(key);\n        }\n        ServiceUrlBean bean = new ServiceUrlBean(name, protocol, serviceAlias, port, external);\n        BEANS.put(key, bean);\n        return bean;\n    }","id":101036,"modified_method":"public static ServiceUrlBean getBean(String name, String protocol, String alias, String port, Boolean endpoint, Boolean external) {\n        String serviceAlias = alias != null ? alias :\n                (external ? \"external-\" : \"\") + name + \"-\" + protocol + \"-\" + port + (endpoint ? \"-endpoint\" : \"\") + SUFFIX;\n        Key key = new Key(name, protocol, serviceAlias, port, endpoint, external);\n        if (BEANS.containsKey(key)) {\n            return BEANS.get(key);\n        }\n        ServiceUrlBean bean = new ServiceUrlBean(name, protocol, serviceAlias, port, endpoint, external);\n        BEANS.put(key, bean);\n        return bean;\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static ServiceUrlBean anyBean(String id, String protocol, String port, Boolean external) {\n        for (Map.Entry<Key, ServiceUrlBean> entry : BEANS.entrySet()) {\n           Key key = entry.getKey();\n           if (key.serviceName.equals(id) && key.serviceProtocol.equals(protocol)) {\n               return entry.getValue();\n           }\n        }\n        return getBean(id, protocol, null, port, external);\n    }","id":101037,"modified_method":"public static ServiceUrlBean anyBean(String id, String protocol, String port, Boolean endpoint, Boolean external) {\n        for (Map.Entry<Key, ServiceUrlBean> entry : BEANS.entrySet()) {\n           Key key = entry.getKey();\n           if (key.serviceName.equals(id) && key.serviceProtocol.equals(protocol)) {\n               return entry.getValue();\n           }\n        }\n        return getBean(id, protocol, null, port, endpoint, external);\n    }","commit_id":"26d8ae32f38a2cd94825908763df67757281ce31","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public int compareTo(ContentName o) {\n\t\tif (this == o)\n\t\t\treturn 0;\n\t\tint len = (this.count() > o.count()) ? this.count() : o.count();\n\t\tint componentResult = 0;\n\t\tfor (int i=0; i < len; ++i) {\n\t\t\tcomponentResult = DataUtils.compare(this.component(i), o.component(i));\n\t\t\tif (0 != componentResult)\n\t\t\t\treturn componentResult;\n\t\t}\n\t\tif (this.count() < o.count())\n\t\t\treturn -1;\n\t\telse if (this.count() > o.count())\n\t\t\treturn 1;\n\t\treturn 0;\n\t}","id":101038,"modified_method":"public int compareTo(ContentName o) {\n\t\tif (this == o)\n\t\t\treturn 0;\n        int thisCount = this.count();\n        int oCount = o.count();\n\t\tint len = (thisCount > oCount) ? thisCount : oCount;\n\t\tint componentResult = 0;\n\t\tfor (int i=0; i < len; ++i) {\n\t\t\tcomponentResult = DataUtils.compare(this.component(i), o.component(i));\n\t\t\tif (0 != componentResult)\n\t\t\t\treturn componentResult;\n\t\t}\n\t\tif (thisCount < oCount)\n\t\t\treturn -1;\n\t\telse if (thisCount > oCount)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}","commit_id":"f71819356e5a0d9ad18b5d61c59d294370fb2797","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n     * Initializes database\n\t * @param noCheck If true, don't check for holes etc.\n\t * @param wipe If true, wipe the database first.\n     * @param the directory where the store is located\n\t * @throws IOException \n\t * @throws DatabaseException \n     * @throws FileNotFoundException if the dir does not exist and could not be created\n     */\n\tpublic BerkeleyDBFreenetStore(Environment env, String prefix, File storeFile, File fixSecondaryFile, long maxChkBlocks, int blockSize, int headerSize, boolean throwOnTooFewKeys, boolean noCheck, boolean wipe, SemiOrderedShutdownHook storeShutdownHook) throws IOException, DatabaseException {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tthis.dataBlockSize = blockSize;\n\t\tthis.headerBlockSize = headerSize;\n\t\tthis.freeBlocks = new SortedLongSet();\n\t\t\n\t\tthis.maxChkBlocks=maxChkBlocks;\n\t\t\n\t\tenvironment = env;\n\t\t\n\t\t// Initialize CHK database\n\t\tDatabaseConfig dbConfig = new DatabaseConfig();\n\t\tdbConfig.setAllowCreate(true);\n\t\tdbConfig.setTransactional(true);\n\t\tif(wipe) {\n\t\t\twipeOldDatabases(prefix);\n\t\t}\n\t\t\n\t\tchkDB = environment.openDatabase(null,prefix+\"CHK\",dbConfig);\n\n\t\tthis.fixSecondaryFile = fixSecondaryFile;\n\t\tif(fixSecondaryFile.exists()) {\n\t\t\tfixSecondaryFile.delete();\n\t\t\tLogger.error(this, \"Recreating secondary databases\");\n\t\t\tLogger.error(this, \"This may take some time...\");\n\t\t\tSystem.err.println(\"Recreating secondary databases\");\n\t\t\tSystem.err.println(\"This may take some time...\");\n\t\t\tWrapperManager.signalStarting((int)(Math.min(Integer.MAX_VALUE, 5*60*1000+chkDB.count()*100))); \n\t\t\t// Of course it's not a solution but a quick fix\n\t\t\t// Integer.MAX_VALUE seems to trigger an overflow or whatever ...\n\t\t\t// Either we find out what the maximum value is and we do a static method somewhere ensuring\n\t\t\t// it won't overflow ... or we debug the wrapper.\n\t\t\t// NB: it might be a wrapper-version-missmatch problem (nextgens)\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_accessTime\", false);\n\t\t\t\t} catch (DatabaseNotFoundException e) {\n\t\t\t\t\t// Cool!\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_blockNum\", false);\n\t\t\t\t} catch (DatabaseNotFoundException e) {\n\t\t\t\t\t// Cool!\n\t\t\t\t}\n\t\t\t} catch (DatabaseException e) {\n\t\t\t\tclose(false);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Initialize secondary CHK database sorted on accesstime\n\t\tSecondaryDatabase atime = null;\n\t\tSecondaryConfig secDbConfig = new SecondaryConfig();\n\t\tsecDbConfig.setAllowCreate(chkDB.count() == 0);\n\t\tsecDbConfig.setSortedDuplicates(true);\n\t\tsecDbConfig.setTransactional(true);\n\t\tsecDbConfig.setAllowPopulate(false);\n\t\tstoreBlockTupleBinding = new StoreBlockTupleBinding();\n\t\tAccessTimeKeyCreator accessTimeKeyCreator = \n\t\t\tnew AccessTimeKeyCreator(storeBlockTupleBinding);\n\t\tsecDbConfig.setKeyCreator(accessTimeKeyCreator);\n\t\ttry {\n\t\ttry {\n\t\t\tatime = environment.openSecondaryDatabase\n\t\t\t\t\t\t\t\t(null, prefix+\"CHK_accessTime\", chkDB, secDbConfig);\n\t\t\tif(atime.count() < chkDB.count()) {\n\t\t\t\tSystem.err.println(\"Access times database: \"+atime.count()+\" but main database: \"+chkDB.count());\n\t\t\t\tthrow new DatabaseException(\"Needs repopulation\");\n\t\t\t}\n\t\t} catch (DatabaseException e) {\n\t\t\tWrapperManager.signalStarting((int)(Math.min(Integer.MAX_VALUE, 5*60*1000+chkDB.count()*100))); \n\t\t\t// Of course it's not a solution but a quick fix\n\t\t\t// Integer.MAX_VALUE seems to trigger an overflow or whatever ...\n\t\t\t// Either we find out what the maximum value is and we do a static method somewhere ensuring\n\t\t\t// it won't overflow ... or we debug the wrapper.\n\t\t\t// NB: it might be a wrapper-version-missmatch problem (nextgens)\n\t\t\tif(atime != null) atime.close();\n\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_accessTime\", false);\n\t\t\tSystem.err.println(\"Reconstructing access times index...\");\n\t\t\tLogger.error(this, \"Reconstructing access times index...\");\n\t\t\tsecDbConfig.setAllowCreate(true);\n\t\t\tsecDbConfig.setAllowPopulate(true);\n\t\t\tatime = environment.openSecondaryDatabase\n\t\t\t\t\t\t\t\t(null, prefix+\"CHK_accessTime\", chkDB, secDbConfig);\n\t\t}\n\t\t} catch (DatabaseException e1) {\n\t\t\tclose(false);\n\t\t\tthrow e1;\n\t\t}\n\t\tchkDB_accessTime = atime;\n\t\t\n\t\t// Initialize other secondary database sorted on block number\n//\t\ttry {\n//\t\t\tenvironment.removeDatabase(null, \"CHK_blockNum\");\n//\t\t} catch (DatabaseNotFoundException e) { };\n\t\tSecondaryConfig blockNoDbConfig = new SecondaryConfig();\n\t\tblockNoDbConfig.setAllowCreate(chkDB.count() == 0);\n\t\tblockNoDbConfig.setSortedDuplicates(false);\n\t\tblockNoDbConfig.setAllowPopulate(false);\n\t\tblockNoDbConfig.setTransactional(true);\n\t\t\n\t\tBlockNumberKeyCreator bnkc = \n\t\t\tnew BlockNumberKeyCreator(storeBlockTupleBinding);\n\t\tblockNoDbConfig.setKeyCreator(bnkc);\n\t\tSecondaryDatabase blockNums = null;\n\t\ttry {\n\t\ttry {\n\t\t\tSystem.err.println(\"Opening block db index\");\n\t\t\tblockNums = environment.openSecondaryDatabase\n\t\t\t\t(null, prefix+\"CHK_blockNum\", chkDB, blockNoDbConfig);\n\t\t\tif(blockNums.count() < chkDB.count()) {\n\t\t\t\tSystem.err.println(\"Block nums database: \"+atime.count()+\" but main database: \"+chkDB.count());\n\t\t\t\tthrow new DatabaseException(\"Needs repopulation\");\n\t\t\t}\n\t\t} catch (DatabaseException e) {\n\t\t\tWrapperManager.signalStarting((int)(Math.min(Integer.MAX_VALUE, 5*60*1000+chkDB.count()*100))); \n\t\t\t// Of course it's not a solution but a quick fix\n\t\t\t// Integer.MAX_VALUE seems to trigger an overflow or whatever ...\n\t\t\t// Either we find out what the maximum value is and we do a static method somewhere ensuring\n\t\t\t// it won't overflow ... or we debug the wrapper.\n\t\t\t// NB: it might be a wrapper-version-missmatch problem (nextgens)\n\t\t\tif(blockNums != null) blockNums.close();\n\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_blockNum\", false);\n\t\t\tSystem.err.println(\"Reconstructing block numbers index...\");\n\t\t\tLogger.error(this, \"Reconstructing block numbers index...\");\n\t\t\tSystem.err.println(\"Creating new block DB index\");\n\t\t\tblockNoDbConfig.setSortedDuplicates(false);\n\t\t\tblockNoDbConfig.setAllowCreate(true);\n\t\t\tblockNoDbConfig.setAllowPopulate(true);\n\t\t\tblockNums = environment.openSecondaryDatabase\n\t\t\t\t(null, prefix+\"CHK_blockNum\", chkDB, blockNoDbConfig);\n\t\t}\n\t\t} catch (DatabaseException e1) {\n\t\t\tclose(false);\n\t\t\tthrow e1;\n\t\t}\n\t\t\n\t\tchkDB_blockNum = blockNums;\n\t\t\n\t\t// Initialize the store file\n\t\ttry {\n\t\t\tif(!storeFile.exists())\n\t\t\t\tif(!storeFile.createNewFile())\n\t\t\t\t\tthrow new DatabaseException(\"can't create a new file !\");\n\t\t\tchkStore = new RandomAccessFile(storeFile,\"rw\");\n\t\t\t\n\t\t\tboolean dontCheckForHolesShrinking = false;\n\t\t\t\n\t\t\tlong chkBlocksInDatabase = chkDB.count();\n\t\t\tchkBlocksInStore = chkBlocksInDatabase;\n\t\t\tlong chkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\tlastRecentlyUsed = getMaxRecentlyUsed();\n\n\t\t\tSystem.out.println(\"Keys in store: db \"+chkBlocksInDatabase+\" file \"+chkBlocksFromFile+\" / max \"+maxChkBlocks);\n\t\t\t\n\t\t\tif(chkBlocksInDatabase > chkBlocksFromFile) {\n\t\t\t\tSystem.out.println(\"More keys in database than in store, checking for holes...\");\n\t\t\t\tdontCheckForHolesShrinking = true;\n\t\t\t\tcheckForHoles(chkBlocksFromFile, false);\n\t\t\t}\n\t\t\t\n\t\t\tif(((chkBlocksInStore == 0) && (chkBlocksFromFile != 0)) ||\n\t\t\t\t\t(((chkBlocksInStore + 10) * 1.1) < chkBlocksFromFile)) {\n\t\t\t\tif(throwOnTooFewKeys) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclose(false);\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLogger.error(this, \"Failed to close: \"+t, t);\n\t\t\t\t\t\tSystem.err.println(\"Failed to close: \"+t);\n\t\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new DatabaseException(\"Keys in database: \"+chkBlocksInStore+\" but keys in file: \"+chkBlocksFromFile);\n\t\t\t\t} else if(!noCheck) {\n\t\t\t\t\tlong len = checkForHoles(chkBlocksFromFile, false);\n\t\t\t\t\tdontCheckForHolesShrinking = true;\n\t\t\t\t\tif(len < chkBlocksFromFile) {\n\t\t\t\t\t\tSystem.err.println(\"Truncating to \"+len+\" as no non-holes after that point\");\n\t\t\t\t\t\tchkStore.setLength(len * (dataBlockSize + headerBlockSize));\n\t\t\t\t\t\tchkBlocksInStore = len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchkBlocksInStore = Math.max(chkBlocksInStore, chkBlocksFromFile);\n\t\t\tif(logMINOR) Logger.minor(this, \"Keys in store: \"+chkBlocksInStore);\n\t\t\t\n\t\t\tif(!noCheck) {\n\t\t\t\tmaybeOfflineShrink(dontCheckForHolesShrinking);\n\t\t\t\tchkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\t\tchkBlocksInStore = Math.max(chkBlocksInStore, chkBlocksFromFile);\n\t\t\t}\n\t\t\t\n//\t\t\t Add shutdownhook\n\t\t\tstoreShutdownHook.addEarlyJob(new ShutdownHook());\n\t\t} catch (DatabaseException t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tclose(false);\n\t\t\tthrow t;\n\t\t} catch (IOException t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tclose(false);\n\t\t\tthrow t;\n\t\t}\n\t}","id":101039,"modified_method":"/**\n     * Initializes database\n\t * @param noCheck If true, don't check for holes etc.\n\t * @param wipe If true, wipe the database first.\n     * @param the directory where the store is located\n\t * @throws IOException \n\t * @throws DatabaseException \n     * @throws FileNotFoundException if the dir does not exist and could not be created\n     */\n\tpublic BerkeleyDBFreenetStore(Environment env, String prefix, File storeFile, File fixSecondaryFile, long maxChkBlocks, int blockSize, int headerSize, boolean throwOnTooFewKeys, boolean noCheck, boolean wipe, SemiOrderedShutdownHook storeShutdownHook) throws IOException, DatabaseException {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tthis.dataBlockSize = blockSize;\n\t\tthis.headerBlockSize = headerSize;\n\t\tthis.freeBlocks = new SortedLongSet();\n\t\t\n\t\tthis.maxChkBlocks=maxChkBlocks;\n\t\t\n\t\tenvironment = env;\n\t\t\n\t\t// Initialize CHK database\n\t\tDatabaseConfig dbConfig = new DatabaseConfig();\n\t\tdbConfig.setAllowCreate(true);\n\t\tdbConfig.setTransactional(true);\n\t\tif(wipe) {\n\t\t\twipeOldDatabases(prefix);\n\t\t}\n\t\t\n\t\tchkDB = environment.openDatabase(null,prefix+\"CHK\",dbConfig);\n\n\t\tthis.fixSecondaryFile = fixSecondaryFile;\n\t\tif(fixSecondaryFile.exists()) {\n\t\t\tfixSecondaryFile.delete();\n\t\t\tLogger.error(this, \"Recreating secondary databases\");\n\t\t\tLogger.error(this, \"This may take some time...\");\n\t\t\tSystem.err.println(\"Recreating secondary databases\");\n\t\t\tSystem.err.println(\"This may take some time...\");\n\t\t\tWrapperManager.signalStarting((int)(Math.min(Integer.MAX_VALUE, 5*60*1000+chkDB.count()*100))); \n\t\t\t// Of course it's not a solution but a quick fix\n\t\t\t// Integer.MAX_VALUE seems to trigger an overflow or whatever ...\n\t\t\t// Either we find out what the maximum value is and we do a static method somewhere ensuring\n\t\t\t// it won't overflow ... or we debug the wrapper.\n\t\t\t// NB: it might be a wrapper-version-missmatch problem (nextgens)\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_accessTime\", false);\n\t\t\t\t} catch (DatabaseNotFoundException e) {\n\t\t\t\t\t// Cool!\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_blockNum\", false);\n\t\t\t\t} catch (DatabaseNotFoundException e) {\n\t\t\t\t\t// Cool!\n\t\t\t\t}\n\t\t\t} catch (DatabaseException e) {\n\t\t\t\tclose(false);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Initialize secondary CHK database sorted on accesstime\n\t\tSecondaryDatabase atime = null;\n\t\tSecondaryConfig secDbConfig = new SecondaryConfig();\n\t\tsecDbConfig.setAllowCreate(chkDB.count() == 0);\n\t\tsecDbConfig.setSortedDuplicates(true);\n\t\tsecDbConfig.setTransactional(true);\n\t\tsecDbConfig.setAllowPopulate(false);\n\t\tstoreBlockTupleBinding = new StoreBlockTupleBinding();\n\t\tAccessTimeKeyCreator accessTimeKeyCreator = \n\t\t\tnew AccessTimeKeyCreator(storeBlockTupleBinding);\n\t\tsecDbConfig.setKeyCreator(accessTimeKeyCreator);\n\t\ttry {\n\t\ttry {\n\t\t\tatime = environment.openSecondaryDatabase\n\t\t\t\t\t\t\t\t(null, prefix+\"CHK_accessTime\", chkDB, secDbConfig);\n\t\t\tlong chkDBCount = chkDB.count();\n\t\t\tlong atimeCount = atime.count();\n\t\t\tif(atimeCount < chkDBCount) {\n\t\t\t\tSystem.err.println(\"Access times database: \"+atimeCount+\" but main database: \"+chkDBCount);\n\t\t\t\tthrow new DatabaseException(\"Needs repopulation\");\n\t\t\t}\n\t\t} catch (DatabaseException e) {\n\t\t\tWrapperManager.signalStarting((int)(Math.min(Integer.MAX_VALUE, 5*60*1000+chkDB.count()*100))); \n\t\t\t// Of course it's not a solution but a quick fix\n\t\t\t// Integer.MAX_VALUE seems to trigger an overflow or whatever ...\n\t\t\t// Either we find out what the maximum value is and we do a static method somewhere ensuring\n\t\t\t// it won't overflow ... or we debug the wrapper.\n\t\t\t// NB: it might be a wrapper-version-missmatch problem (nextgens)\n\t\t\tif(atime != null) atime.close();\n\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_accessTime\", false);\n\t\t\tSystem.err.println(\"Reconstructing access times index...\");\n\t\t\tLogger.error(this, \"Reconstructing access times index...\");\n\t\t\tsecDbConfig.setAllowCreate(true);\n\t\t\tsecDbConfig.setAllowPopulate(true);\n\t\t\tatime = environment.openSecondaryDatabase\n\t\t\t\t\t\t\t\t(null, prefix+\"CHK_accessTime\", chkDB, secDbConfig);\n\t\t}\n\t\t} catch (DatabaseException e1) {\n\t\t\tclose(false);\n\t\t\tthrow e1;\n\t\t}\n\t\tchkDB_accessTime = atime;\n\t\t\n\t\t// Initialize other secondary database sorted on block number\n//\t\ttry {\n//\t\t\tenvironment.removeDatabase(null, \"CHK_blockNum\");\n//\t\t} catch (DatabaseNotFoundException e) { };\n\t\tSecondaryConfig blockNoDbConfig = new SecondaryConfig();\n\t\tblockNoDbConfig.setAllowCreate(chkDB.count() == 0);\n\t\tblockNoDbConfig.setSortedDuplicates(false);\n\t\tblockNoDbConfig.setAllowPopulate(false);\n\t\tblockNoDbConfig.setTransactional(true);\n\t\t\n\t\tBlockNumberKeyCreator bnkc = \n\t\t\tnew BlockNumberKeyCreator(storeBlockTupleBinding);\n\t\tblockNoDbConfig.setKeyCreator(bnkc);\n\t\tSecondaryDatabase blockNums = null;\n\t\ttry {\n\t\ttry {\n\t\t\tSystem.err.println(\"Opening block db index\");\n\t\t\tblockNums = environment.openSecondaryDatabase\n\t\t\t\t(null, prefix+\"CHK_blockNum\", chkDB, blockNoDbConfig);\n\t\t\tlong blockNumsCount = blockNums.count();\n\t\t\tlong chkDBCount = chkDB.count();\n\t\t\tif(blockNumsCount < chkDBCount) {\n\t\t\t\tSystem.err.println(\"Block nums database: \"+atime.count()+\" but main database: \"+chkDB.count());\n\t\t\t\tthrow new DatabaseException(\"Needs repopulation\");\n\t\t\t}\n\t\t} catch (DatabaseException e) {\n\t\t\tWrapperManager.signalStarting((int)(Math.min(Integer.MAX_VALUE, 5*60*1000+chkDB.count()*100))); \n\t\t\t// Of course it's not a solution but a quick fix\n\t\t\t// Integer.MAX_VALUE seems to trigger an overflow or whatever ...\n\t\t\t// Either we find out what the maximum value is and we do a static method somewhere ensuring\n\t\t\t// it won't overflow ... or we debug the wrapper.\n\t\t\t// NB: it might be a wrapper-version-missmatch problem (nextgens)\n\t\t\tif(blockNums != null) blockNums.close();\n\t\t\tenvironment.truncateDatabase(null, prefix+\"CHK_blockNum\", false);\n\t\t\tSystem.err.println(\"Reconstructing block numbers index...\");\n\t\t\tLogger.error(this, \"Reconstructing block numbers index...\");\n\t\t\tSystem.err.println(\"Creating new block DB index\");\n\t\t\tblockNoDbConfig.setSortedDuplicates(false);\n\t\t\tblockNoDbConfig.setAllowCreate(true);\n\t\t\tblockNoDbConfig.setAllowPopulate(true);\n\t\t\tblockNums = environment.openSecondaryDatabase\n\t\t\t\t(null, prefix+\"CHK_blockNum\", chkDB, blockNoDbConfig);\n\t\t}\n\t\t} catch (DatabaseException e1) {\n\t\t\tclose(false);\n\t\t\tthrow e1;\n\t\t}\n\t\t\n\t\tchkDB_blockNum = blockNums;\n\t\t\n\t\t// Initialize the store file\n\t\ttry {\n\t\t\tif(!storeFile.exists())\n\t\t\t\tif(!storeFile.createNewFile())\n\t\t\t\t\tthrow new DatabaseException(\"can't create a new file !\");\n\t\t\tchkStore = new RandomAccessFile(storeFile,\"rw\");\n\t\t\t\n\t\t\tboolean dontCheckForHolesShrinking = false;\n\t\t\t\n\t\t\tlong chkBlocksInDatabase = chkDB.count();\n\t\t\tchkBlocksInStore = chkBlocksInDatabase;\n\t\t\tlong chkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\tlastRecentlyUsed = getMaxRecentlyUsed();\n\n\t\t\tSystem.out.println(\"Keys in store: db \"+chkBlocksInDatabase+\" file \"+chkBlocksFromFile+\" / max \"+maxChkBlocks);\n\t\t\t\n\t\t\tif(chkBlocksInDatabase > chkBlocksFromFile) {\n\t\t\t\tSystem.out.println(\"More keys in database than in store, checking for holes...\");\n\t\t\t\tdontCheckForHolesShrinking = true;\n\t\t\t\tcheckForHoles(chkBlocksFromFile, false);\n\t\t\t}\n\t\t\t\n\t\t\tif(((chkBlocksInStore == 0) && (chkBlocksFromFile != 0)) ||\n\t\t\t\t\t(((chkBlocksInStore + 10) * 1.1) < chkBlocksFromFile)) {\n\t\t\t\tif(throwOnTooFewKeys) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclose(false);\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLogger.error(this, \"Failed to close: \"+t, t);\n\t\t\t\t\t\tSystem.err.println(\"Failed to close: \"+t);\n\t\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new DatabaseException(\"Keys in database: \"+chkBlocksInStore+\" but keys in file: \"+chkBlocksFromFile);\n\t\t\t\t} else if(!noCheck) {\n\t\t\t\t\tlong len = checkForHoles(chkBlocksFromFile, false);\n\t\t\t\t\tdontCheckForHolesShrinking = true;\n\t\t\t\t\tif(len < chkBlocksFromFile) {\n\t\t\t\t\t\tSystem.err.println(\"Truncating to \"+len+\" as no non-holes after that point\");\n\t\t\t\t\t\tchkStore.setLength(len * (dataBlockSize + headerBlockSize));\n\t\t\t\t\t\tchkBlocksInStore = len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchkBlocksInStore = Math.max(chkBlocksInStore, chkBlocksFromFile);\n\t\t\tif(logMINOR) Logger.minor(this, \"Keys in store: \"+chkBlocksInStore);\n\t\t\t\n\t\t\tif(!noCheck) {\n\t\t\t\tmaybeOfflineShrink(dontCheckForHolesShrinking);\n\t\t\t\tchkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\t\tchkBlocksInStore = Math.max(chkBlocksInStore, chkBlocksFromFile);\n\t\t\t}\n\t\t\t\n//\t\t\t Add shutdownhook\n\t\t\tstoreShutdownHook.addEarlyJob(new ShutdownHook());\n\t\t} catch (DatabaseException t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tclose(false);\n\t\t\tthrow t;\n\t\t} catch (IOException t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tclose(false);\n\t\t\tthrow t;\n\t\t}\n\t}","commit_id":"9bce4de67b9a31f76311f0467092b101228f0d38","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\t\tpublic int compareTo(ContentName o) {\n\t\t\tif (this == o)\n\t\t\t\treturn 0;\n\t\t\tif (count() < o.count())\n\t\t\t\treturn -1;\n\t\t\telse if (count() > o.count())\n\t\t\t\treturn 1;\n\t\t\treturn super.compareTo(o);\n\t\t}","id":101040,"modified_method":"@Override\n\t\tpublic int compareTo(ContentName o) {\n\t\t\tif (this == o)\n\t\t\t\treturn 0;\n\t\t\tint thisCount = count();\n\t\t\tint oCount = o.count();\n\t\t\tif (thisCount == oCount)\n\t\t\t\treturn super.compareTo(o);\n\t\t\tif (thisCount < oCount)\n\t\t\t\treturn -1;\n\t\t\telse \n\t\t\t\treturn 1;\n\t\t}","commit_id":"822d96b0aefa0f416398987a59ef3af6bd7adbe7","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void storeEnvelopes(\n\t\t\tlong folderId, IMAPFolder imapFolder, Message[] jxMessages)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\ttry {\n\t\t\tFetchProfile fetchProfile = new FetchProfile();\n\n\t\t\tfetchProfile.add(UIDFolder.FetchProfileItem.UID);\n\t\t\tfetchProfile.add(UIDFolder.FetchProfileItem.ENVELOPE);\n\n\t\t\timapFolder.fetch(jxMessages, fetchProfile);\n\n\t\t\tfor (Message jxMessage : jxMessages) {\n\t\t\t\tString sender = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getFrom());\n\t\t\t\tString to = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getRecipients(RecipientType.TO));\n\t\t\t\tString cc = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getRecipients(RecipientType.CC));\n\t\t\t\tString bcc = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getRecipients(RecipientType.BCC));\n\t\t\t\tDate sentDate = jxMessage.getSentDate();\n\t\t\t\tString subject = jxMessage.getSubject();\n\t\t\t\tlong remoteMessageId = imapFolder.getUID(jxMessage);\n\n\t\t\t\tMessageLocalServiceUtil.addMessage(\n\t\t\t\t\t_user.getUserId(), folderId, sender, to, cc, bcc,\n\t\t\t\t\tsentDate, subject, StringPool.BLANK, StringPool.BLANK,\n\t\t\t\t\tremoteMessageId);\n\t\t\t}\n\n\t\t\tcom.liferay.mail.model.Folder folder =\n\t\t\t\tFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\tFolderLocalServiceUtil.updateFolder(\n\t\t\t\tfolderId, folder.getFullName(), folder.getDisplayName(),\n\t\t\t\timapFolder.getMessageCount());\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new MailException(me);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch.stop();\n\n\t\t\t_log.debug(\n\t\t\t\t\"Downloaded \" + jxMessages.length + \" messages from folder \" +\n\t\t\t\t\timapFolder.getFullName() + \" completed in \" +\n\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t}\n\t}","id":101041,"modified_method":"public void storeEnvelopes(\n\t\t\tlong folderId, IMAPFolder imapFolder, Message[] jxMessages)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\ttry {\n\t\t\tFetchProfile fetchProfile = new FetchProfile();\n\n\t\t\tfetchProfile.add(UIDFolder.FetchProfileItem.UID);\n\t\t\tfetchProfile.add(UIDFolder.FetchProfileItem.ENVELOPE);\n\n\t\t\timapFolder.fetch(jxMessages, fetchProfile);\n\n\t\t\tfor (Message jxMessage : jxMessages) {\n\t\t\t\tString sender = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getFrom());\n\t\t\t\tString to = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getRecipients(RecipientType.TO));\n\t\t\t\tString cc = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getRecipients(RecipientType.CC));\n\t\t\t\tString bcc = InternetAddressUtil.toString(\n\t\t\t\t\tjxMessage.getRecipients(RecipientType.BCC));\n\t\t\t\tDate sentDate = jxMessage.getSentDate();\n\t\t\t\tString subject = jxMessage.getSubject();\n\t\t\t\tlong remoteMessageId = imapFolder.getUID(jxMessage);\n\n\t\t\t\tcom.liferay.mail.model.Message message =\n\t\t\t\t\tMessageLocalServiceUtil.getMessage(\n\t\t\t\t\t\tfolderId, remoteMessageId);\n\n\t\t\t\tif (message == null) {\n\t\t\t\t\tMessageLocalServiceUtil.addMessage(\n\t\t\t\t\t\t_user.getUserId(), folderId, sender, to, cc, bcc,\n\t\t\t\t\t\tsentDate, subject, StringPool.BLANK, StringPool.BLANK,\n\t\t\t\t\t\tremoteMessageId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcom.liferay.mail.model.Folder folder =\n\t\t\t\tFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\tFolderLocalServiceUtil.updateFolder(\n\t\t\t\tfolderId, folder.getFullName(), folder.getDisplayName(),\n\t\t\t\timapFolder.getMessageCount());\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new MailException(me);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch.stop();\n\n\t\t\t_log.debug(\n\t\t\t\t\"Downloaded \" + jxMessages.length + \" messages from folder \" +\n\t\t\t\t\timapFolder.getFullName() + \" completed in \" +\n\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t}\n\t}","commit_id":"6665c2c39ddd1ac817298ef42af0ed8e2259b5d0","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void storeEnvelopes(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tIMAPFolder imapFolder = null;\n\n\t\ttry {\n\t\t\timapFolder = openFolder(folderId);\n\n\t\t\tcom.liferay.mail.model.Folder folder =\n\t\t\t\tFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\tint messageCount = imapFolder.getMessageCount();\n\n\t\t\tFolderLocalServiceUtil.updateFolder(\n\t\t\t\tfolderId, folder.getFullName(), folder.getDisplayName(),\n\t\t\t\tmessageCount);\n\n\t\t\tif (messageCount == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMessage oldestJxMessage = getMessage(folderId, imapFolder, true);\n\t\t\tMessage newestJxMessage = getMessage(folderId, imapFolder, false);\n\n\t\t\tMessage[] jxMessages = new Message[0];\n\n\t\t\tif ((oldestJxMessage == null) && (newestJxMessage == null)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Downloading messages from folder \" +\n\t\t\t\t\t\t\timapFolder.getFullName() + \" for the first time\");\n\t\t\t\t}\n\n\t\t\t\tint startingMessageNumber =\n\t\t\t\t\tmessageCount - PortletPropsValues.MESSAGES_SYNC_COUNT;\n\n\t\t\t\tif (startingMessageNumber < 1) {\n\t\t\t\t\tstartingMessageNumber = 1;\n\t\t\t\t}\n\n\t\t\t\tjxMessages = imapFolder.getMessages(\n\t\t\t\t\tstartingMessageNumber, messageCount);\n\n\t\t\t\tstoreEnvelopes(folderId, imapFolder, jxMessages);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint newestMessageNumber = newestJxMessage.getMessageNumber();\n\n\t\t\t\tif (newestMessageNumber != messageCount) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Downloading new messages from folder \" +\n\t\t\t\t\t\t\t\timapFolder.getFullName());\n\t\t\t\t\t}\n\n\t\t\t\t\tjxMessages = imapFolder.getMessages(\n\t\t\t\t\t\tnewestMessageNumber + 1, messageCount);\n\n\t\t\t\t\tstoreEnvelopes(folderId, imapFolder, jxMessages);\n\t\t\t\t}\n\n\t\t\t\tint oldestMessageNumber = oldestJxMessage.getMessageNumber();\n\n\t\t\t\tif (oldestMessageNumber != 1) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Downloading old messages from folder \" +\n\t\t\t\t\t\t\t\timapFolder.getFullName());\n\t\t\t\t\t}\n\n\t\t\t\t\tint startingMessageNumber =\n\t\t\t\t\t\toldestMessageNumber -\n\t\t\t\t\t\t\tPortletPropsValues.MESSAGES_SYNC_COUNT;\n\n\t\t\t\t\tif (startingMessageNumber < 1) {\n\t\t\t\t\t\tstartingMessageNumber = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tjxMessages = imapFolder.getMessages(\n\t\t\t\t\t\tstartingMessageNumber, oldestMessageNumber - 1);\n\n\t\t\t\t\tstoreEnvelopes(folderId, imapFolder, jxMessages);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new MailException(me);\n\t\t}\n\t\tfinally {\n\t\t\tcloseFolder(imapFolder, false);\n\t\t}\n\t}","id":101042,"modified_method":"public void storeEnvelopes(long folderId, boolean allMessages)\n\t\tthrows PortalException, SystemException {\n\n\t\tIMAPFolder imapFolder = null;\n\n\t\ttry {\n\t\t\timapFolder = openFolder(folderId);\n\n\t\t\tcom.liferay.mail.model.Folder folder =\n\t\t\t\tFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\tint messageCount = imapFolder.getMessageCount();\n\n\t\t\tFolderLocalServiceUtil.updateFolder(\n\t\t\t\tfolderId, folder.getFullName(), folder.getDisplayName(),\n\t\t\t\tmessageCount);\n\n\t\t\tif (messageCount == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tMessage oldestJxMessage = getMessage(folderId, imapFolder, true);\n\t\t\tMessage newestJxMessage = getMessage(folderId, imapFolder, false);\n\n\t\t\tMessage[] jxMessages = new Message[0];\n\n\t\t\tif (allMessages) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Downloading all messages from folder \" +\n\t\t\t\t\t\t\timapFolder.getFullName());\n\t\t\t\t}\n\n\t\t\t\tjxMessages = imapFolder.getMessages();\n\t\t\t}\n\t\t\telse if ((oldestJxMessage == null) && (newestJxMessage == null)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Downloading messages from folder \" +\n\t\t\t\t\t\t\timapFolder.getFullName() + \" for the first time\");\n\t\t\t\t}\n\n\t\t\t\tint startingMessageNumber =\n\t\t\t\t\tmessageCount - PortletPropsValues.MESSAGES_SYNC_COUNT;\n\n\t\t\t\tif (startingMessageNumber < 1) {\n\t\t\t\t\tstartingMessageNumber = 1;\n\t\t\t\t}\n\n\t\t\t\tjxMessages = imapFolder.getMessages(\n\t\t\t\t\tstartingMessageNumber, messageCount);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint newestMessageNumber = newestJxMessage.getMessageNumber();\n\t\t\t\tint oldestMessageNumber = oldestJxMessage.getMessageNumber();\n\n\t\t\t\tif (newestMessageNumber != messageCount) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Downloading new messages from folder \" +\n\t\t\t\t\t\t\t\timapFolder.getFullName());\n\t\t\t\t\t}\n\n\t\t\t\t\tjxMessages = imapFolder.getMessages(\n\t\t\t\t\t\tnewestMessageNumber + 1, messageCount);\n\t\t\t\t}\n\t\t\t\telse if (oldestMessageNumber != 1) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Downloading old messages from folder \" +\n\t\t\t\t\t\t\t\timapFolder.getFullName());\n\t\t\t\t\t}\n\n\t\t\t\t\tint startingMessageNumber =\n\t\t\t\t\t\toldestMessageNumber -\n\t\t\t\t\t\t\tPortletPropsValues.MESSAGES_SYNC_COUNT;\n\n\t\t\t\t\tif (startingMessageNumber < 1) {\n\t\t\t\t\t\tstartingMessageNumber = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tjxMessages = imapFolder.getMessages(\n\t\t\t\t\t\tstartingMessageNumber, oldestMessageNumber - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstoreEnvelopes(folderId, imapFolder, jxMessages);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new MailException(me);\n\t\t}\n\t\tfinally {\n\t\t\tcloseFolder(imapFolder, false);\n\t\t}\n\t}","commit_id":"6665c2c39ddd1ac817298ef42af0ed8e2259b5d0","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void synchronize() throws PortalException, SystemException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Synchronizing account\");\n\t\t}\n\n\t\tList<javax.mail.Folder> jxFolders = _imapAccessor.getFolders();\n\n\t\tlong draftFolderId = account.getDraftFolderId();\n\t\tlong inboxFolderId = account.getInboxFolderId();\n\t\tlong sentFolderId = account.getSentFolderId();\n\t\tlong trashFolderId = account.getTrashFolderId();\n\n\t\tboolean initialSynchronization = false;\n\n\t\tif (inboxFolderId == 0) {\n\t\t\tinitialSynchronization = true;\n\t\t}\n\n\t\tfor (javax.mail.Folder jxFolder : jxFolders) {\n\t\t\tFolder folder = null;\n\n\t\t\ttry {\n\t\t\t\tfolder = FolderLocalServiceUtil.getFolder(\n\t\t\t\t\taccount.getAccountId(), jxFolder.getFullName());\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tfolder = FolderLocalServiceUtil.addFolder(\n\t\t\t\t\tuser.getUserId(), account.getAccountId(),\n\t\t\t\t\tjxFolder.getFullName(), jxFolder.getName(), 0);\n\t\t\t}\n\n\t\t\tString folderName = jxFolder.getName().toLowerCase();\n\n\t\t\tif ((draftFolderId == 0) && folderName.contains(\"draft\")) {\n\t\t\t\tdraftFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((inboxFolderId == 0) && folderName.contains(\"inbox\")) {\n\t\t\t\tinboxFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((sentFolderId == 0) && folderName.contains(\"sent\")) {\n\t\t\t\tsentFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((trashFolderId == 0) && folderName.contains(\"trash\")) {\n\t\t\t\ttrashFolderId = folder.getFolderId();\n\t\t\t}\n\t\t}\n\n\t\tAccountLocalServiceUtil.updateFolders(\n\t\t\taccount.getAccountId(), inboxFolderId, draftFolderId, sentFolderId,\n\t\t\ttrashFolderId);\n\n\t\tif (!initialSynchronization) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Synchronizing all folders for accountId \" +\n\t\t\t\t\t\taccount.getAccountId());\n\t\t\t}\n\n\t\t\tList<Folder> folders = FolderLocalServiceUtil.getFolders(\n\t\t\t\taccount.getAccountId());\n\n\t\t\tfor (Folder folder : folders) {\n\t\t\t\tsynchronizeFolder(folder.getFolderId());\n\t\t\t}\n\t\t}\n\t}","id":101043,"modified_method":"public void synchronize() throws PortalException, SystemException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Synchronizing account\");\n\t\t}\n\n\t\tList<javax.mail.Folder> jxFolders = _imapAccessor.getFolders();\n\n\t\tlong draftFolderId = account.getDraftFolderId();\n\t\tlong inboxFolderId = account.getInboxFolderId();\n\t\tlong sentFolderId = account.getSentFolderId();\n\t\tlong trashFolderId = account.getTrashFolderId();\n\n\t\tboolean initialSynchronization = false;\n\n\t\tif (inboxFolderId == 0) {\n\t\t\tinitialSynchronization = true;\n\t\t}\n\n\t\tfor (javax.mail.Folder jxFolder : jxFolders) {\n\t\t\tFolder folder = null;\n\n\t\t\ttry {\n\t\t\t\tfolder = FolderLocalServiceUtil.getFolder(\n\t\t\t\t\taccount.getAccountId(), jxFolder.getFullName());\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tfolder = FolderLocalServiceUtil.addFolder(\n\t\t\t\t\tuser.getUserId(), account.getAccountId(),\n\t\t\t\t\tjxFolder.getFullName(), jxFolder.getName(), 0);\n\t\t\t}\n\n\t\t\tString folderName = jxFolder.getName().toLowerCase();\n\n\t\t\tif ((draftFolderId == 0) && folderName.contains(\"draft\")) {\n\t\t\t\tdraftFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((inboxFolderId == 0) && folderName.contains(\"inbox\")) {\n\t\t\t\tinboxFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((sentFolderId == 0) && folderName.contains(\"sent\")) {\n\t\t\t\tsentFolderId = folder.getFolderId();\n\t\t\t}\n\t\t\telse if ((trashFolderId == 0) && folderName.contains(\"trash\")) {\n\t\t\t\ttrashFolderId = folder.getFolderId();\n\t\t\t}\n\t\t}\n\n\t\tAccountLocalServiceUtil.updateFolders(\n\t\t\taccount.getAccountId(), inboxFolderId, draftFolderId, sentFolderId,\n\t\t\ttrashFolderId);\n\n\t\tif (!initialSynchronization) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Synchronizing all folders for accountId \" +\n\t\t\t\t\t\taccount.getAccountId());\n\t\t\t}\n\n\t\t\tList<Folder> folders = FolderLocalServiceUtil.getFolders(\n\t\t\t\taccount.getAccountId());\n\n\t\t\tfor (Folder folder : folders) {\n\t\t\t\t_imapAccessor.storeEnvelopes(folder.getFolderId(), true);\n\t\t\t}\n\t\t}\n\t}","commit_id":"6665c2c39ddd1ac817298ef42af0ed8e2259b5d0","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void synchronizeFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Synchronizing folder \" + folderId);\n\t\t}\n\n\t\t_imapAccessor.storeEnvelopes(folderId);\n\t}","id":101044,"modified_method":"public void synchronizeFolder(long folderId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Synchronizing folder \" + folderId);\n\t\t}\n\n\t\t_imapAccessor.storeEnvelopes(folderId, false);\n\t}","commit_id":"6665c2c39ddd1ac817298ef42af0ed8e2259b5d0","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n     * Builds the bundle for a given module.\n     *\n     * @param module            the module\n     * @param progressIndicator the progress indicator\n     * @param compileContext\n     * @throws IOException in case something goes wrong.\n     */\n    private static void buildBundle(final Module module, final ProgressIndicator progressIndicator,\n                                    final CompileContext compileContext)\n            throws IOException {\n      String messagePrefix = \"[\"+module.getName()+\"] \";\n      progressIndicator.setText(\"Building bundle for module \" + module.getName());\n      // create the jar file\n      final File jarFile = new File(VfsUtil.urlToPath(getJarFileName(module)));\n      FileUtil.delete(jarFile);\n\n      if (!FileUtil.createParentDirs(jarFile)) {\n          compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Cannot create path to \" + jarFile.getPath(),null, 0,0);\n          return;\n        }\n\n        final VirtualFile moduleOutputDir = new ReadAction<VirtualFile>() {\n            protected void run(Result<VirtualFile> result) {\n                result.setResult(getModuleOutputUrl(module));\n            }\n        }.execute().getResultObject();\n\n        final BndWrapper wrapper = new BndWrapper();\n      OsmorcFacet osmorcFacet = OsmorcFacet.getInstance(module);\n      final OsmorcFacetConfiguration configuration = osmorcFacet.getConfiguration();\n        final List<String> classPaths = new ArrayList<String>();\n\n        if (moduleOutputDir != null) {\n            classPaths.add(moduleOutputDir.getUrl());\n        }\n\n\n      // build a bnd file or use a provided one.\n        String bndFileUrl = \"\";\n        Map<String, String> additionalProperties = new HashMap<String, String>();\n        if (configuration.isOsmorcControlsManifest() || configuration.isUseBndFile() || configuration.isUseBundlorFile() ) {\n            if (configuration.isUseBndFile()) {\n                File bndFile = findFileInModuleContentRoots(configuration.getBndFileLocation(), module);\n                if (bndFile == null || !bndFile.exists()) {\n                    compileContext.addMessage(CompilerMessageCategory.ERROR,\n                            String.format(messagePrefix + \"The bnd file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                    configuration.getBndFileLocation(), module.getName()),\n                            configuration.getBndFileLocation(), 0, 0);\n                    return;\n                } else {\n                    bndFileUrl = VfsUtil.pathToUrl(bndFile.getPath());\n                }\n            } else if ( configuration.isUseBundlorFile() ) {\n              // bundlor, in this case we use bnd for creating the jar only, and later run bundlor to\n              // do the manifest magic.\n              bndFileUrl = makeBndFile(module, \"\", compileContext);\n              if ( bndFileUrl == null ) {\n                  // couldnt create bnd file.\n                  return;\n              }\n\n            } else {\n                // fully osmorc controlled, no bnd file.\n                bndFileUrl = makeBndFile(module, configuration.asBndFile(), compileContext);\n              if ( bndFileUrl == null ) {\n                  // couldnt create bnd file.\n                  return;\n              }\n            }\n        } else {\n            boolean manifestExists = false;\n            VirtualFile manifestFile = osmorcFacet.getManifestFile();\n            if (manifestFile != null) {\n              String manifestFilePath = manifestFile.getPath();\n              if (manifestFilePath != null) {\n                bndFileUrl = makeBndFile(module, \"-manifest \" + manifestFilePath + \"\\n\", compileContext);\n                manifestExists = true;\n              }\n            }\n            if (!manifestExists) {\n                compileContext.addMessage(CompilerMessageCategory.ERROR,\n                        messagePrefix + \"Manifest file for module \" + module.getName() + \": '\" + osmorcFacet.getManifestLocation() +\n                                \"' does not exist or cannot be found. Check that file exists and is not excluded from the module.\", null, 0, 0);\n                return;\n            }\n        }\n\n        if (configuration.isManifestManuallyEdited() || configuration.isOsmorcControlsManifest() ) {\n            // in this case we manually add all the classpaths as resources\n            StringBuilder pathBuilder = new StringBuilder();\n            // add all the classpaths to include resources, so stuff from the project gets copied over.\n            // XXX: one could argue if this should be done for a non-osmorc build\n            for (int i = 0; i < classPaths.size(); i++) {\n                String classPath = classPaths.get(i);\n                String relPath = FileUtil.getRelativePath(new File(VfsUtil.urlToPath(bndFileUrl)),\n                        new File(VfsUtil.urlToPath(classPath)));\n                if (i != 0) {\n                    pathBuilder.append(\",\");\n                }\n                pathBuilder.append(relPath);\n            }\n\n            // now include the paths from the configuration\n            List<Pair<String, String>> list = configuration.getAdditionalJARContents();\n            for (Pair<String, String> stringStringPair : list) {\n                pathBuilder.append(\",\").append(stringStringPair.second).append(\" = \").append(stringStringPair.first);\n            }\n\n            // and tell bnd what resources to include\n            String includedResources = configuration.getAdditionalPropertiesAsMap().get(\"Include-Resource\");\n            if ( includedResources == null ) {\n              includedResources = pathBuilder.toString();\n            }\n            else {\n               includedResources = includedResources + \",\" + pathBuilder.toString();\n            }\n            additionalProperties.put(\"Include-Resource\", includedResources);\n\n            if (!configuration.isIgnorePatternValid()) {\n                compileContext.addMessage(CompilerMessageCategory.ERROR,\n                        messagePrefix  + \"The file ignore pattern in the facet configuration is invalid.\", null, 0, 0);\n                return;\n            }\n\n            // add the ignore pattern for the resources\n            if (!\"\".equals(configuration.getIgnoreFilePattern())) {\n                additionalProperties.put(\"-donotcopy\", configuration.getIgnoreFilePattern());\n            }\n\n        }\n\n        String outputPath = jarFile.getPath();\n        if ( configuration.isUseBundlorFile() ) {\n          // we create a temp jar file in this case.\n          outputPath += \".tmp.jar\";\n        }\n\n        wrapper.build(module, compileContext, bndFileUrl, ArrayUtil.toStringArray(classPaths), outputPath, additionalProperties);\n\n        // if we use bundlor, let bundlor work on the generated file.\n        if ( configuration.isUseBundlorFile() ) {\n             File bundlorFile = findFileInModuleContentRoots(configuration.getBundlorFileLocation(), module);\n                if (bundlorFile == null || !bundlorFile.exists()) {\n                    compileContext.addMessage(CompilerMessageCategory.ERROR,\n                            String.format(messagePrefix  + \"The Bundlor file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                    configuration.getBundlorFileLocation(), module.getName()),\n                            configuration.getBundlorFileLocation(), 0, 0);\n                    return;\n                }\n           BundlorWrapper bw = new BundlorWrapper();\n           try {\n               if (!bw.wrapModule(compileContext, outputPath, jarFile.getPath(), bundlorFile.getPath())) {\n\n                   compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Bundlifying the file \" + jarFile.getPath() + \" with Bundlor failed.\", null, 0,0);\n                   return;\n               }\n           } finally {\n               // delete the tmp jar\n               File tempJar = new File(outputPath);\n               if ( tempJar.exists() ) {\n                 if (!tempJar.delete()) {\n                   compileContext.addMessage(CompilerMessageCategory.WARNING, messagePrefix + \"Could not delete temporary file: \" + tempJar.getPath(), null, 0,0);\n                 }\n               }\n           }\n        }\n\n        if (!configuration.isUseBndFile() && !configuration.isUseBundlorFile()) {\n            // finally bundlify all the libs for this one\n            bundlifyLibraries(module, progressIndicator, compileContext);\n        }\n    }","id":101045,"modified_method":"/**\n   * Builds the bundle for a given module.\n   *\n   * @param module            the module\n   * @param progressIndicator the progress indicator\n   * @param compileContext\n   * @throws IOException in case something goes wrong.\n   */\n  private static void buildBundle(final Module module, final ProgressIndicator progressIndicator,\n                                  final CompileContext compileContext)\n    throws IOException {\n    String messagePrefix = \"[\" + module.getName() + \"] \";\n    progressIndicator.setText(\"Building bundle for module \" + module.getName());\n    // create the jar file\n    final File jarFile = new File(VfsUtil.urlToPath(getJarFileName(module)));\n    FileUtil.delete(jarFile);\n\n    if (!FileUtil.createParentDirs(jarFile)) {\n      compileContext.addMessage(CompilerMessageCategory.ERROR, messagePrefix + \"Cannot create path to \" + jarFile.getPath(), null, 0, 0);\n      return;\n    }\n\n    final VirtualFile moduleOutputDir = new ReadAction<VirtualFile>() {\n      protected void run(Result<VirtualFile> result) {\n        result.setResult(getModuleOutputUrl(module));\n      }\n    }.execute().getResultObject();\n\n    final BndWrapper wrapper = new BndWrapper();\n    OsmorcFacet osmorcFacet = OsmorcFacet.getInstance(module);\n    final OsmorcFacetConfiguration configuration = osmorcFacet.getConfiguration();\n    final List<String> classPaths = new ArrayList<String>();\n\n    if (moduleOutputDir != null) {\n      classPaths.add(moduleOutputDir.getUrl());\n    }\n\n\n    // build a bnd file or use a provided one.\n    String bndFileUrl = \"\";\n    Map<String, String> additionalProperties = new HashMap<String, String>();\n    if (configuration.isOsmorcControlsManifest() || configuration.isUseBndFile() || configuration.isUseBundlorFile()) {\n      if (configuration.isUseBndFile()) {\n        File bndFile = findFileInModuleContentRoots(configuration.getBndFileLocation(), module);\n        if (bndFile == null || !bndFile.exists()) {\n          compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                    String.format(messagePrefix + \"The bnd file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                                  configuration.getBndFileLocation(), module.getName()),\n                                    configuration.getBndFileLocation(), 0, 0);\n          return;\n        }\n        else {\n          bndFileUrl = VfsUtil.pathToUrl(bndFile.getPath());\n        }\n      }\n      else if (configuration.isUseBundlorFile()) {\n        // bundlor, in this case we use bnd for creating the jar only, and later run bundlor to\n        // do the manifest magic.\n        bndFileUrl = makeBndFile(module, \"\", compileContext);\n        if (bndFileUrl == null) {\n          // couldnt create bnd file.\n          return;\n        }\n      }\n      else {\n        // fully osmorc controlled, no bnd file.\n        bndFileUrl = makeBndFile(module, configuration.asBndFile(), compileContext);\n        if (bndFileUrl == null) {\n          // couldnt create bnd file.\n          return;\n        }\n      }\n    }\n    else {\n      boolean manifestExists = false;\n      VirtualFile manifestFile = osmorcFacet.getManifestFile();\n      if (manifestFile != null) {\n        String manifestFilePath = manifestFile.getPath();\n        if (manifestFilePath != null) {\n          bndFileUrl = makeBndFile(module, \"-manifest \" + manifestFilePath + \"\\n\", compileContext);\n          manifestExists = true;\n        }\n      }\n      if (!manifestExists) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix +\n                                  \"Manifest file for module \" +\n                                  module.getName() +\n                                  \": '\" +\n                                  osmorcFacet.getManifestLocation() +\n                                  \"' does not exist or cannot be found. Check that file exists and is not excluded from the module.\", null,\n                                  0, 0);\n        return;\n      }\n    }\n\n    if (configuration.isManifestManuallyEdited() || configuration.isOsmorcControlsManifest()) {\n      // in this case we manually add all the classpaths as resources\n      StringBuilder pathBuilder = new StringBuilder();\n      // add all the classpaths to include resources, so stuff from the project gets copied over.\n      // XXX: one could argue if this should be done for a non-osmorc build\n      for (int i = 0; i < classPaths.size(); i++) {\n        String classPath = classPaths.get(i);\n        String relPath = FileUtil.getRelativePath(new File(VfsUtil.urlToPath(bndFileUrl)),\n                                                  new File(VfsUtil.urlToPath(classPath)));\n        if (i != 0) {\n          pathBuilder.append(\",\");\n        }\n        pathBuilder.append(relPath);\n      }\n\n      // now include the paths from the configuration\n      List<Pair<String, String>> list = configuration.getAdditionalJARContents();\n      for (Pair<String, String> stringStringPair : list) {\n        pathBuilder.append(\",\").append(stringStringPair.second).append(\" = \").append(stringStringPair.first);\n      }\n\n      // and tell bnd what resources to include\n      String includedResources = configuration.getAdditionalPropertiesAsMap().get(\"Include-Resource\");\n      if (includedResources == null) {\n        includedResources = pathBuilder.toString();\n      }\n      else {\n        includedResources = includedResources + \",\" + pathBuilder.toString();\n      }\n      additionalProperties.put(\"Include-Resource\", includedResources);\n\n      if (!configuration.isIgnorePatternValid()) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  messagePrefix + \"The file ignore pattern in the facet configuration is invalid.\", null, 0, 0);\n        return;\n      }\n\n      // add the ignore pattern for the resources\n      if (!configuration.getIgnoreFilePattern().isEmpty()) {\n        additionalProperties.put(\"-donotcopy\", configuration.getIgnoreFilePattern());\n      }\n    }\n\n    String outputPath = jarFile.getPath();\n    if (configuration.isUseBundlorFile()) {\n      // we create a temp jar file in this case.\n      outputPath += \".tmp.jar\";\n    }\n\n    wrapper.build(module, compileContext, bndFileUrl, ArrayUtil.toStringArray(classPaths), outputPath, additionalProperties);\n\n    // if we use bundlor, let bundlor work on the generated file.\n    if (configuration.isUseBundlorFile()) {\n      File bundlorFile = findFileInModuleContentRoots(configuration.getBundlorFileLocation(), module);\n      if (bundlorFile == null || !bundlorFile.exists()) {\n        compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                  String.format(messagePrefix + \"The Bundlor file \\\"%s\\\" for module \\\"%s\\\" does not exist.\",\n                                                configuration.getBundlorFileLocation(), module.getName()),\n                                  configuration.getBundlorFileLocation(), 0, 0);\n        return;\n      }\n      BundlorWrapper bw = new BundlorWrapper();\n      try {\n        if (!bw.wrapModule(compileContext, outputPath, jarFile.getPath(), bundlorFile.getPath())) {\n\n          compileContext.addMessage(CompilerMessageCategory.ERROR,\n                                    messagePrefix + \"Bundlifying the file \" + jarFile.getPath() + \" with Bundlor failed.\", null, 0, 0);\n          return;\n        }\n      }\n      finally {\n        // delete the tmp jar\n        File tempJar = new File(outputPath);\n        if (tempJar.exists()) {\n          if (!tempJar.delete()) {\n            compileContext\n              .addMessage(CompilerMessageCategory.WARNING, messagePrefix + \"Could not delete temporary file: \" + tempJar.getPath(), null, 0,\n                          0);\n          }\n        }\n      }\n    }\n\n    if (!configuration.isUseBndFile() && !configuration.isUseBundlorFile()) {\n      // finally bundlify all the libs for this one\n      bundlifyLibraries(module, progressIndicator, compileContext);\n    }\n  }","commit_id":"06baab307bec46414becf306a5e461ee21bd3e10","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n    static VirtualFile getModuleOutputUrl(Module module) {\n        final CompilerModuleExtension extension = CompilerModuleExtension.getInstance(module);\n        if (extension != null) {\n            return extension.getCompilerOutputPath();\n        }\n        return null;\n    }","id":101046,"modified_method":"/**\n   * Returns a virtual file representing the module's output path.\n   *\n   * @param module the module\n   * @return the module's output url or null if it could not be determined.\n   */\n  @Nullable\n  static VirtualFile getModuleOutputUrl(@NotNull Module module) {\n    final CompilerModuleExtension extension = CompilerModuleExtension.getInstance(module);\n    if (extension != null) {\n      return extension.getCompilerOutputPath();\n    }\n    return null;\n  }","commit_id":"06baab307bec46414becf306a5e461ee21bd3e10","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n    private static String makeBndFile(Module module, String contents, CompileContext compileContext) throws IOException {\n        final String outputPath = getOutputPath(module, compileContext);\n        if ( outputPath == null ) {\n          return null;\n        }\n        File tmpFile = FileUtil.createTempFile(new File(outputPath), \"osmorc\", \".bnd\", true);\n        // create one\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile));\n        bos.write(contents.getBytes());\n        bos.close();\n        tmpFile.deleteOnExit();\n        return VfsUtil.pathToUrl(tmpFile.getPath());\n\n    }","id":101047,"modified_method":"@Nullable\n  private static String makeBndFile(Module module, String contents, CompileContext compileContext) throws IOException {\n    final String outputPath = getOutputPath(module, compileContext);\n    if (outputPath == null) {\n      return null;\n    }\n    File tmpFile = FileUtil.createTempFile(new File(outputPath), \"osmorc\", \".bnd\", true);\n    // create one\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile));\n    try {\n      bos.write(contents.getBytes());\n    }\n    finally {\n      bos.close();\n    }\n    tmpFile.deleteOnExit();\n    return VfsUtil.pathToUrl(tmpFile.getPath());\n  }","commit_id":"06baab307bec46414becf306a5e461ee21bd3e10","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n    private static String getOutputPath(final Module m, CompileContext context) {\n        final CompilerModuleExtension extension = CompilerModuleExtension.getInstance(m);\n        VirtualFile moduleCompilerOutputPath = extension.getCompilerOutputPath();\n\n        String path;\n        if (moduleCompilerOutputPath == null) {\n            // get the url\n            String outputPathUrl = extension.getCompilerOutputUrl();\n\n            // create the paths\n            // FIX  \t IDEADEV-40112\n            File f = new File(VfsUtil.urlToPath(outputPathUrl));\n            if (!f.exists() && !f.mkdirs()) {\n                context.addMessage(CompilerMessageCategory.ERROR, OsmorcBundle.getTranslation(\"faceteditor.cannot.create.outputpath\"), null, 0,0);\n                return null;\n            }\n\n            path = f.getParentFile().getPath() + File.separator + \"bundles\";\n        }\n        else {\n            path = moduleCompilerOutputPath.getParent().getPath() + File.separator + \"bundles\";\n        }\n\n        File f = new File(path);\n        if (!f.exists()) {\n            if (!f.mkdirs()) {\n              context.addMessage(CompilerMessageCategory.ERROR, \"Could not create output path: \" + path + \" Please check file permissions.\", null, 0,0 );\n              return null;\n            }\n        }\n        return path;\n    }","id":101048,"modified_method":"/**\n   * Tries to determine the compiler output path of the given module\n   *\n   * @param m       the module\n   * @param context the compile context\n   * @return the compiler output path or null, if it cannot be determined.\n   */\n  @Nullable\n  private static String getOutputPath(final @NotNull Module m, @NotNull CompileContext context) {\n    final CompilerModuleExtension extension = CompilerModuleExtension.getInstance(m);\n    if (extension == null) {\n      context.addMessage(CompilerMessageCategory.WARNING, \"Unable to determine the compiler output path for module \" + m.getName(),\n                         null, 0, 0);\n      return null;\n    }\n    VirtualFile moduleCompilerOutputPath = extension.getCompilerOutputPath();\n\n    String path;\n    if (moduleCompilerOutputPath == null) {\n      // get the url\n      String outputPathUrl = extension.getCompilerOutputUrl();\n\n      // create the paths\n      // FIX  \t IDEADEV-40112\n      File f = new File(VfsUtil.urlToPath(outputPathUrl));\n      if (!f.exists() && !f.mkdirs()) {\n        context.addMessage(CompilerMessageCategory.ERROR, \"Cannot create compiler output path!\", null, 0, 0);\n        return null;\n      }\n\n      path = f.getParentFile().getPath() + File.separator + \"bundles\";\n    }\n    else {\n      path = moduleCompilerOutputPath.getParent().getPath() + File.separator + \"bundles\";\n    }\n\n    File f = new File(path);\n    if (!f.exists()) {\n      if (!f.mkdirs()) {\n        context\n          .addMessage(CompilerMessageCategory.ERROR, \"Could not create output path: \" + path + \" Please check file permissions.\", null, 0,\n                      0);\n        return null;\n      }\n    }\n    return path;\n  }","commit_id":"06baab307bec46414becf306a5e461ee21bd3e10","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Asserts:\n     * <p/>\n     * <ul>\n     * <li><code>string.length != null<\/code>\n     * <li><code>string.length > 0<\/code>\n     * <\/ul>\n     */\n    private boolean validateStringNotEmpty( String fieldName, ModelValidationResult result, String string )\n    {\n        if ( !validateNotNull( fieldName, result, string ) )\n        {\n            return false;\n        }\n\n        if ( string.length() > 0 )\n        {\n            return true;\n        }\n\n        result.addMessage( \"'\" + fieldName + \"' is missing.\" );\n\n        return false;\n    }","id":101049,"modified_method":"private boolean validateStringNotEmpty( String fieldName, ModelValidationResult result, String string )\n    {\n        return validateStringNotEmpty( fieldName, result, string, null );\n    }","commit_id":"34d4cc14fcca6a4d8e75d2e4499b78a942540446","url":"https://github.com/apache/maven"},{"original_method":"public ModelValidationResult validate( Model model )\n    {\n        ModelValidationResult result = new ModelValidationResult();\n\n        validateStringNotEmpty( \"modelVersion\", result, model.getModelVersion() );\n\n        validateId( \"groupId\", result, model.getGroupId() );\n\n        validateId( \"artifactId\", result, model.getArtifactId() );\n\n        validateStringNotEmpty( \"packaging\", result, model.getPackaging() );\n\n        validateStringNotEmpty( \"version\", result, model.getVersion() );\n\n        for ( Iterator it = model.getDependencies().iterator(); it.hasNext(); )\n        {\n            Dependency d = (Dependency) it.next();\n\n            validateId( \"dependencies.dependency.artifactId\", result, d.getArtifactId() );\n\n            validateId( \"dependencies.dependency.groupId\", result, d.getGroupId() );\n\n            validateStringNotEmpty( \"dependencies.dependency.type\", result, d.getType() );\n\n            validateStringNotEmpty( \"dependencies.dependency.version\", result, d.getVersion() );\n\n            if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isEmpty( d.getSystemPath() ) )\n            {\n                result.addMessage( \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n            }\n            else if ( !Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isNotEmpty( d.getSystemPath() ) )\n            {\n                result.addMessage(\n                    \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n            }\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if ( mgmt != null )\n        {\n            for ( Iterator it = mgmt.getDependencies().iterator(); it.hasNext(); )\n            {\n                Dependency d = (Dependency) it.next();\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.artifactId\", result,\n                                                  d.getArtifactId() );\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.groupId\", result,\n                                                  d.getGroupId() );\n\n                if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isEmpty( d.getSystemPath() ) )\n                {\n                    result.addMessage(\n                        \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n                }\n                else if ( !Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isNotEmpty( d.getSystemPath() ) )\n                {\n                    result.addMessage(\n                        \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n                }\n            }\n        }\n\n        Build build = model.getBuild();\n        if ( build != null )\n        {\n            for ( Iterator it = build.getPlugins().iterator(); it.hasNext(); )\n            {\n                Plugin p = (Plugin) it.next();\n\n                validateStringNotEmpty( \"build.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"build.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n\n            for ( Iterator it = build.getResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.resources.resource.directory\", result, r.getDirectory() );\n            }\n\n            for ( Iterator it = build.getTestResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.testResources.testResource.directory\", result, r.getDirectory() );\n            }\n        }\n\n        Reporting reporting = model.getReporting();\n        if ( reporting != null )\n        {\n            for ( Iterator it = reporting.getPlugins().iterator(); it.hasNext(); )\n            {\n                ReportPlugin p = (ReportPlugin) it.next();\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n        }\n\n        validateRepositories( result, model.getRepositories(), \"repositories.repository\" );\n\n        validateRepositories( result, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n\n        forcePluginExecutionIdCollision( model, result );\n\n        return result;\n    }","id":101050,"modified_method":"public ModelValidationResult validate( Model model )\n    {\n        ModelValidationResult result = new ModelValidationResult();\n\n        validateStringNotEmpty( \"modelVersion\", result, model.getModelVersion() );\n\n        validateId( \"groupId\", result, model.getGroupId() );\n\n        validateId( \"artifactId\", result, model.getArtifactId() );\n\n        validateStringNotEmpty( \"packaging\", result, model.getPackaging() );\n\n        validateStringNotEmpty( \"version\", result, model.getVersion() );\n\n        for ( Iterator it = model.getDependencies().iterator(); it.hasNext(); )\n        {\n            Dependency d = (Dependency) it.next();\n\n            validateId( \"dependencies.dependency.artifactId\", result, d.getArtifactId() );\n\n            validateId( \"dependencies.dependency.groupId\", result, d.getGroupId() );\n\n            validateStringNotEmpty( \"dependencies.dependency.type\", result, d.getType(), dependencySourceHint( d ) );\n\n            validateStringNotEmpty( \"dependencies.dependency.version\", result, d.getVersion(), dependencySourceHint( d ) );\n\n            if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isEmpty( d.getSystemPath() ) )\n            {\n                result.addMessage( \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n            }\n            else if ( !Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isNotEmpty( d.getSystemPath() ) )\n            {\n                result.addMessage(\n                    \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n            }\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if ( mgmt != null )\n        {\n            for ( Iterator it = mgmt.getDependencies().iterator(); it.hasNext(); )\n            {\n                Dependency d = (Dependency) it.next();\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.artifactId\", result,\n                                                  d.getArtifactId() );\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.groupId\", result,\n                                                  d.getGroupId() );\n\n                if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isEmpty( d.getSystemPath() ) )\n                {\n                    result.addMessage(\n                        \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n                }\n                else if ( !Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isNotEmpty( d.getSystemPath() ) )\n                {\n                    result.addMessage(\n                        \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n                }\n            }\n        }\n\n        Build build = model.getBuild();\n        if ( build != null )\n        {\n            for ( Iterator it = build.getPlugins().iterator(); it.hasNext(); )\n            {\n                Plugin p = (Plugin) it.next();\n\n                validateStringNotEmpty( \"build.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"build.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n\n            for ( Iterator it = build.getResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.resources.resource.directory\", result, r.getDirectory() );\n            }\n\n            for ( Iterator it = build.getTestResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.testResources.testResource.directory\", result, r.getDirectory() );\n            }\n        }\n\n        Reporting reporting = model.getReporting();\n        if ( reporting != null )\n        {\n            for ( Iterator it = reporting.getPlugins().iterator(); it.hasNext(); )\n            {\n                ReportPlugin p = (ReportPlugin) it.next();\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n        }\n\n        validateRepositories( result, model.getRepositories(), \"repositories.repository\" );\n\n        validateRepositories( result, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n\n        forcePluginExecutionIdCollision( model, result );\n\n        return result;\n    }","commit_id":"34d4cc14fcca6a4d8e75d2e4499b78a942540446","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Asserts:\n     * <p/>\n     * <ul>\n     * <li><code>string != null<\/code>\n     * <\/ul>\n     */\n    private boolean validateNotNull( String fieldName, ModelValidationResult result, Object object )\n    {\n        if ( object != null )\n        {\n            return true;\n        }\n\n        result.addMessage( \"'\" + fieldName + \"' is missing.\" );\n\n        return false;\n    }","id":101051,"modified_method":"/**\n     * Asserts:\n     * <p/>\n     * <ul>\n     * <li><code>string != null<\/code>\n     * <\/ul>\n     */\n    private boolean validateNotNull( String fieldName, ModelValidationResult result, Object object, String sourceHint )\n    {\n        if ( object != null )\n        {\n            return true;\n        }\n\n        if ( sourceHint != null )\n        {\n            result.addMessage( \"'\" + fieldName + \"' is missing for \" + sourceHint );\n        }\n        else\n        {\n            result.addMessage( \"'\" + fieldName + \"' is missing.\" );\n        }\n\n        return false;\n    }","commit_id":"34d4cc14fcca6a4d8e75d2e4499b78a942540446","url":"https://github.com/apache/maven"},{"original_method":"public void testMissingDependencyVersion()\n        throws Exception\n    {\n        ModelValidationResult result = validate( \"missing-dependency-version-pom.xml\" );\n\n        assertEquals( 1, result.getMessageCount() );\n\n        assertTrue( result.getMessage( 0 ).indexOf( \"'dependencies.dependency.version' is missing.\" ) > -1 );\n    }","id":101052,"modified_method":"public void testMissingDependencyVersion()\n        throws Exception\n    {\n        ModelValidationResult result = validate( \"missing-dependency-version-pom.xml\" );\n\n        assertEquals( 1, result.getMessageCount() );\n\n        assertTrue( result.getMessage( 0 ).indexOf( \"'dependencies.dependency.version' is missing\" ) > -1 );\n    }","commit_id":"34d4cc14fcca6a4d8e75d2e4499b78a942540446","url":"https://github.com/apache/maven"},{"original_method":"@Nullable\n  private DependencyRule readRule(Element ruleElement) {\n    String fromScope = ruleElement.getAttributeValue(FROM_SCOPE_KEY);\n    String toScope = ruleElement.getAttributeValue(TO_SCOPE_KEY);\n    String denyRule = ruleElement.getAttributeValue(IS_DENY_KEY);\n    if (fromScope == null || toScope == null || denyRule == null) return null;\n    return new DependencyRule(getScope(fromScope), getScope(toScope), Boolean.valueOf(denyRule).booleanValue());\n  }","id":101053,"modified_method":"@Nullable\n  private DependencyRule readRule(Element ruleElement) {\n    String fromScope = ruleElement.getAttributeValue(FROM_SCOPE_KEY);\n    String toScope = ruleElement.getAttributeValue(TO_SCOPE_KEY);\n    String denyRule = ruleElement.getAttributeValue(IS_DENY_KEY);\n    if (fromScope == null || toScope == null || denyRule == null) return null;\n    final NamedScope fromNamedScope = getScope(fromScope);\n    final NamedScope toNamedScope = getScope(toScope);\n    if (fromNamedScope == null || toNamedScope == null) return null;\n    return new DependencyRule(fromNamedScope, toNamedScope, Boolean.valueOf(denyRule).booleanValue());\n  }","commit_id":"ffb753de9fdcf1cf808e7f2bcd0cd1d66adb27a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processQuery(@NotNull final ReferencesSearch.SearchParameters p, @NotNull final Processor<PsiReference> consumer) {\n    final PsiElement refElement = p.getElementToSearch();\n    if (!refElement.isValid() || !(refElement instanceof PsiLocalVariable || refElement instanceof PsiParameter)) return;\n\n    final String name = ((PsiVariable)refElement).getName();\n    if (name == null) return;\n\n    final SearchScope scope = p.getEffectiveSearchScope();\n    if (!(scope instanceof LocalSearchScope)) return;\n\n    PsiTreeUtil.processElements(new PsiElementProcessor() {\n      @Override\n      public boolean execute(@NotNull final PsiElement element) {\n        if (element instanceof PsiJavaCodeReferenceElement) {\n          final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)element;\n          if (!ref.isQualified() && name.equals(ref.getText()) &&\n              ref.resolve() == null && ref.advancedResolve(true).getElement() == refElement) {\n            consumer.process(ref);\n          }\n        }\n        return true;\n      }\n    }, ((LocalSearchScope)scope).getScope());\n  }","id":101054,"modified_method":"@Override\n  public void processQuery(@NotNull final ReferencesSearch.SearchParameters p, @NotNull final Processor<PsiReference> consumer) {\n    final PsiElement refElement = p.getElementToSearch();\n    if (!refElement.isValid() || !(refElement instanceof PsiLocalVariable || refElement instanceof PsiParameter)) return;\n\n    final String name = ((PsiVariable)refElement).getName();\n    if (name == null) return;\n\n    final SearchScope scope = p.getEffectiveSearchScope();\n    if (!(scope instanceof LocalSearchScope)) return;\n\n    PsiElement[] elements = ((LocalSearchScope)scope).getScope();\n    if (elements == null || elements.length == 0) return;\n\n    PsiElementProcessor processor = new PsiElementProcessor() {\n      @Override\n      public boolean execute(@NotNull final PsiElement element) {\n        if (element instanceof PsiJavaCodeReferenceElement) {\n          final PsiJavaCodeReferenceElement ref = (PsiJavaCodeReferenceElement)element;\n          if (!ref.isQualified() && name.equals(ref.getText()) &&\n              ref.resolve() == null && ref.advancedResolve(true).getElement() == refElement) {\n            consumer.process(ref);\n          }\n        }\n        return true;\n      }\n    };\n\n    for (PsiElement element : elements) {\n      if (element.getLanguage().isKindOf(JavaLanguage.INSTANCE)) {\n        PsiTreeUtil.processElements(element, processor);\n      }\n    }\n  }","commit_id":"d36b2ecf4486b1be6fc86c152602c1f5b1cf6c13","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private DependencyDTO buildFrom(DependencyNode node) {\n        Artifact artifact = node.getArtifact();\n        if (artifact != null) {\n            DependencyDTO answer = new DependencyDTO();\n            answer.setGroupId(artifact.getGroupId());\n            answer.setArtifactId(artifact.getArtifactId());\n            answer.setVersion(artifact.getVersion());\n            answer.setClassifier(artifact.getClassifier());\n            answer.setScope(artifact.getScope());\n            answer.setType(artifact.getType());\n            answer.setOptional(artifact.isOptional());\n\n            String type = answer.getType();\n            if (type != null && type.equals(\"pom\")) {\n                getLog().debug(\"Ignoring pom.xml for \" + answer);\n                return null;\n            }\n            int state = node.getState();\n            if (state != DependencyNode.INCLUDED) {\n                getLog().debug(\"Ignoring \" + node);\n                return null;\n            }\n            List children = node.getChildren();\n            for (Object child : children) {\n                if (child instanceof DependencyNode) {\n                    DependencyNode childNode = (DependencyNode) child;\n                    if (childNode.getState() == DependencyNode.INCLUDED) {\n                        DependencyDTO childDTO = buildFrom(childNode);\n                        if (childDTO != null) {\n                            answer.addChild(childDTO);\n                        }\n                    }\n                }\n            }\n            return answer;\n        }\n        return null;\n    }","id":101055,"modified_method":"private DependencyDTO buildFrom(DependencyNode node) {\n        Artifact artifact = node.getArtifact();\n        if (artifact != null) {\n            DependencyDTO answer = new DependencyDTO();\n            answer.setGroupId(artifact.getGroupId());\n            answer.setArtifactId(artifact.getArtifactId());\n            answer.setVersion(artifact.getVersion());\n            answer.setClassifier(artifact.getClassifier());\n            String scope = artifact.getScope();\n            answer.setScope(scope);\n            answer.setType(artifact.getType());\n            answer.setOptional(artifact.isOptional());\n\n            String type = answer.getType();\n            if (type != null && type.equals(\"pom\")) {\n                getLog().debug(\"Ignoring pom.xml for \" + answer);\n                return null;\n            }\n            int state = node.getState();\n            if (state != DependencyNode.INCLUDED) {\n                getLog().debug(\"Ignoring \" + node);\n                return null;\n            }\n            if (isWarProject()) {\n                if (scope != null && !scope.equals(\"provided\")) {\n                    getLog().debug(\"WAR packaging so ignoring non-provided scope \" + scope + \" for \" + node);\n                    return null;\n                }\n            }\n            List children = node.getChildren();\n            for (Object child : children) {\n                if (child instanceof DependencyNode) {\n                    DependencyNode childNode = (DependencyNode) child;\n                    if (childNode.getState() == DependencyNode.INCLUDED) {\n                        DependencyDTO childDTO = buildFrom(childNode);\n                        if (childDTO != null) {\n                            answer.addChild(childDTO);\n                        }\n                    }\n                }\n            }\n            return answer;\n        }\n        return null;\n    }","commit_id":"b726c094c0391237af33fe7744384316c88101df","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private AccessMode update( String user, String password, String newPassword ) throws AuthenticationException\n    {\n        authSubject = authManager.login( user, password );\n        switch ( authSubject.getAuthenticationResult() )\n        {\n        case SUCCESS:\n        case PASSWORD_CHANGE_REQUIRED:\n            try\n            {\n                authManager.setPassword( authSubject, user, newPassword );\n            }\n            catch ( AuthorizationViolationException e )\n            {\n                throw new AuthenticationException( Status.Security.Forbidden, identifier.get(), e.getMessage(), e );\n            }\n            catch ( IOException e )\n            {\n                throw new AuthenticationException( Status.Security.Unauthorized, identifier.get(), e.getMessage(), e );\n            }\n            break;\n        default:\n            throw new AuthenticationException( Status.Security.Unauthorized, identifier.get() );\n        }\n        return authSubject;\n    }","id":101056,"modified_method":"private AccessMode update( String user, String password, String newPassword ) throws AuthenticationException\n    {\n        authSubject = authManager.login( user, password );\n        switch ( authSubject.getAuthenticationResult() )\n        {\n        case SUCCESS:\n        case PASSWORD_CHANGE_REQUIRED:\n            try\n            {\n                authSubject.setPassword( newPassword );\n            }\n            catch ( AuthorizationViolationException e )\n            {\n                throw new AuthenticationException( Status.Security.Forbidden, identifier.get(), e.getMessage(), e );\n            }\n            catch ( IOException e )\n            {\n                throw new AuthenticationException( Status.Security.Unauthorized, identifier.get(), e.getMessage(), e );\n            }\n            break;\n        default:\n            throw new AuthenticationException( Status.Security.Unauthorized, identifier.get() );\n        }\n        return authSubject;\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFailOnMalformedToken() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.authenticate( anyString(), anyString() ) ).thenReturn( AuthenticationResult.SUCCESS );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage(\n                \"The value associated with the key `principal` must be a String but was: SingletonList\" );\n\n        // When\n        authentication\n                .authenticate( map( \"scheme\", \"basic\", \"principal\", singletonList( \"bob\" ), \"credentials\", \"secret\" ) );\n    }","id":101057,"modified_method":"@Test\n    public void shouldFailOnMalformedToken() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.SUCCESS );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage(\n                \"The value associated with the key `principal` must be a String but was: SingletonList\" );\n\n        // When\n        authentication\n                .authenticate( map( \"scheme\", \"basic\", \"principal\", singletonList( \"bob\" ), \"credentials\", \"secret\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFailOnUnknownScheme() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.authenticate( anyString(), anyString() ) ).thenReturn( AuthenticationResult.SUCCESS );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage( \"Authentication token must contain: 'scheme : basic'\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"UNKNOWN\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","id":101058,"modified_method":"@Test\n    public void shouldFailOnUnknownScheme() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.SUCCESS );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage( \"Authentication token must contain: 'scheme : basic'\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"UNKNOWN\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotDoAnythingOnSuccess() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier  );\n        when( manager.authenticate( anyString(), anyString() ) ).thenReturn( AuthenticationResult.SUCCESS );\n\n        //Expect nothing\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","id":101059,"modified_method":"@Test\n    public void shouldNotDoAnythingOnSuccess() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier  );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.SUCCESS );\n\n        //Expect nothing\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldThrowAndLogOnFailure() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        Log log = mock( Log.class );\n        LogProvider logProvider = mock( LogProvider.class );\n        when( logProvider.getLog( BasicAuthentication.class ) ).thenReturn( log );\n        BasicAuthentication authentication = new BasicAuthentication( manager, logProvider, identifier );\n        when( manager.authenticate( anyString(), anyString() ) ).thenReturn( AuthenticationResult.FAILURE );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage( \"The client is unauthorized due to authentication failure.\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n\n        //Then\n        verify( log ).warn( \"Failed authentication attempt for 'bob')\" );\n    }","id":101060,"modified_method":"@Test\n    public void shouldThrowAndLogOnFailure() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        Log log = mock( Log.class );\n        LogProvider logProvider = mock( LogProvider.class );\n        when( logProvider.getLog( BasicAuthentication.class ) ).thenReturn( log );\n        BasicAuthentication authentication = new BasicAuthentication( manager, logProvider, identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.FAILURE );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage( \"The client is unauthorized due to authentication failure.\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n\n        //Then\n        verify( log ).warn( \"Failed authentication attempt for 'bob')\" );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldIndicateThatCredentialsExpired() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.authenticate( anyString(), anyString() ) )\n                .thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.CredentialsExpired ) );\n        exception.expectMessage( \"The credentials have expired and need to be updated.\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","id":101061,"modified_method":"@Test\n    public void shouldIndicateThatCredentialsExpired() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        // Expect\n        // TODO: For now the server just returns OK when a password change is required, but this should be changed to an appropriate message\n        //exception.expect( AuthenticationException.class );\n        //exception.expect( hasStatus( Status.Security.CredentialsExpired ) );\n        //exception.expectMessage( \"The credentials have expired and need to be updated.\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotBeAbleToUpdateCredentialsIfOldCredentialsAreInvalid() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.authenticate( anyString(), anyString() ) ).thenReturn( AuthenticationResult.FAILURE );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage( \"The client is unauthorized due to authentication failure.\" );\n\n        // When\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\",\n                \"new_credentials\", \"secret2\" ) );\n    }","id":101062,"modified_method":"@Test\n    public void shouldNotBeAbleToUpdateCredentialsIfOldCredentialsAreInvalid() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.FAILURE );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.Unauthorized ) );\n        exception.expectMessage( \"The client is unauthorized due to authentication failure.\" );\n\n        // When\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\",\n                \"new_credentials\", \"secret2\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBeAbleToUpdateExpiredCredentials() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.authenticate( anyString(), anyString() ) )\n                .thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        //Expect nothing\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\",\n                \"new_credentials\", \"secret2\" ) );\n    }","id":101063,"modified_method":"@Test\n    public void shouldBeAbleToUpdateExpiredCredentials() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        //Expect nothing\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\",\n                \"new_credentials\", \"secret2\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBeAbleToUpdateCredentials() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.authenticate( anyString(), anyString() ) ).thenReturn( AuthenticationResult.SUCCESS );\n\n        //Expect nothing\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\",\n                \"new_credentials\", \"secret2\" ) );\n    }","id":101064,"modified_method":"@Test\n    public void shouldBeAbleToUpdateCredentials() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.SUCCESS );\n\n        //Expect nothing\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\",\n                \"new_credentials\", \"secret2\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFailWhenTooManyAttempts() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.authenticate( anyString(), anyString() ) ).thenReturn( AuthenticationResult.TOO_MANY_ATTEMPTS );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.AuthenticationRateLimit ) );\n        exception.expectMessage( \"The client has provided incorrect authentication details too many times in a row.\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","id":101065,"modified_method":"@Test\n    public void shouldFailWhenTooManyAttempts() throws AuthenticationException\n    {\n        // Given\n        BasicAuthManager manager = mock( BasicAuthManager.class );\n        BasicAuthSubject authSubject = mock( BasicAuthSubject.class );\n        BasicAuthentication authentication = new BasicAuthentication( manager, mock( LogProvider.class ), identifier );\n        when( manager.login( anyString(), anyString() ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.TOO_MANY_ATTEMPTS );\n\n        // Expect\n        exception.expect( AuthenticationException.class );\n        exception.expect( hasStatus( Status.Security.AuthenticationRateLimit ) );\n        exception.expectMessage( \"The client has provided incorrect authentication details too many times in a row.\" );\n\n        // When\n        authentication.authenticate( map( \"scheme\", \"basic\", \"principal\", \"bob\", \"credentials\", \"secret\" ) );\n    }","commit_id":"07f60d3d7429f023d82bcd29e7eb6e3366ce51d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    @Ignore\n    public void shouldNotAllowDataAccessForUnauthorizedUser() throws Exception\n    {\n        // Given\n        startServerWithConfiguredUser(); // TODO: The user for this test should not have read access\n\n        // When\n        HTTP.Response response =\n                HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"secret\" ) ).POST(\n                        server.baseUri().resolve( \"authentication\" ).toString(),\n                        HTTP.RawPayload.quotedJson( \"{'username':'neo4j', 'password':'secret'}\" )\n                );\n\n        // When & then\n        assertEquals( 403, HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"secret\" ) )\n                .POST( server.baseUri().resolve( \"db/data/node\" ).toString(),\n                        RawPayload.quotedJson( \"{'name':'jake'}\" ) ).status() );\n        assertEquals( 403, HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"secret\" ) )\n                .GET( server.baseUri().resolve( \"db/data/node/1234\" ).toString() ).status() );\n        assertEquals( 403, HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"secret\" ) )\n                .POST( server.baseUri().resolve( \"db/data/transaction/commit\" ).toString(),\n                        RawPayload.quotedJson( \"{'statements':[{'statement':'MATCH (n) RETURN n'}]}\" ) ).status() );\n    }","id":101066,"modified_method":"@Test\n    public void shouldNotAllowDataAccessForUnauthorizedUser() throws Exception\n    {\n        // Given\n        startServer( true ); // The user should not have read access before changing the password\n\n        // When\n        HTTP.Response response =\n                HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"neo4j\" ) ).POST(\n                        server.baseUri().resolve( \"authentication\" ).toString(),\n                        HTTP.RawPayload.quotedJson( \"{'username':'neo4j', 'password':'neo4j'}\" )\n                );\n\n        // When & then\n        assertEquals( 403, HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"neo4j\" ) )\n                .POST( server.baseUri().resolve( \"db/data/node\" ).toString(),\n                        RawPayload.quotedJson( \"{'name':'jake'}\" ) ).status() );\n        assertEquals( 403, HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"neo4j\" ) )\n                .GET( server.baseUri().resolve( \"db/data/node/1234\" ).toString() ).status() );\n        assertEquals( 403, HTTP.withHeaders( HttpHeaders.AUTHORIZATION, challengeResponse( \"neo4j\", \"neo4j\" ) )\n                .POST( server.baseUri().resolve( \"db/data/transaction/commit\" ).toString(),\n                        RawPayload.quotedJson( \"{'statements':[{'statement':'MATCH (n) RETURN n'}]}\" ) ).status() );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void validateResponseType( ServletResponse response ) throws ServletException\n    {\n        if ( !( response instanceof HttpServletResponse ) )\n        {\n            throw new ServletException( format( \"Expected HttpServletResponse, received [%s]\",\n                    response.getClass()\n                            .getCanonicalName() ) );\n        }\n    }","id":101067,"modified_method":"protected void validateResponseType( ServletResponse response ) throws ServletException\n    {\n        if ( !( response instanceof HttpServletResponse ) )\n        {\n            throw new ServletException( format( \"Expected HttpServletResponse, received [%s]\",\n                    response.getClass()\n                            .getCanonicalName() ) );\n        }\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void validateRequestType( ServletRequest request ) throws ServletException\n    {\n        if ( !( request instanceof HttpServletRequest ) )\n        {\n            throw new ServletException( format( \"Expected HttpServletRequest, received [%s]\", request.getClass()\n                    .getCanonicalName() ) );\n        }\n    }","id":101068,"modified_method":"protected void validateRequestType( ServletRequest request ) throws ServletException\n    {\n        if ( !( request instanceof HttpServletRequest) )\n        {\n            throw new ServletException( format( \"Expected HttpServletRequest, received [%s]\", request.getClass()\n                    .getCanonicalName() ) );\n        }\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static ThrowingConsumer<HttpServletResponse, IOException> error( int code, Object body )\n    {\n        return (response) ->\n        {\n            response.setStatus( code );\n            response.addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n            response.getOutputStream().write( JsonHelper.createJsonFrom( body ).getBytes( StandardCharsets.UTF_8 ) );\n        };\n    }","id":101069,"modified_method":"protected static ThrowingConsumer<HttpServletResponse, IOException> error( int code, Object body )\n    {\n        return (response) ->\n        {\n            response.setStatus( code );\n            response.addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n            response.getOutputStream().write( JsonHelper.createJsonFrom( body ).getBytes( StandardCharsets.UTF_8 ) );\n        };\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static ThrowingConsumer<HttpServletResponse, IOException> unauthorizedAccess( final String message )\n    {\n        return error( 403,\n                map( \"errors\", singletonList( map(\n                        \"code\", Status.Security.Forbidden.code().serialize(),\n                        \"message\", String.format(\"Unauthorized access violation: %s.\", message ) ) ) ) );\n    }","id":101070,"modified_method":"protected static ThrowingConsumer<HttpServletResponse, IOException> unauthorizedAccess( final String message )\n    {\n        return error( 403,\n                map( \"errors\", singletonList( map(\n                        \"code\", Status.Security.Forbidden.code().serialize(),\n                        \"message\", String.format(\"Unauthorized access violation: %s.\", message ) ) ) ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotAuthorizeWhenTooManyAttemptsMade() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.authenticate( \"foo\", \"bar\" ) ).thenReturn( AuthenticationResult.TOO_MANY_ATTEMPTS );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 429 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Security.AuthenticationRateLimit\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"Too many failed authentication requests. Please wait 5 seconds and try again.\\\"\" ) );\n    }","id":101071,"modified_method":"@Test\n    public void shouldNotAuthorizeWhenTooManyAttemptsMade() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        AuthSubject authSubject = mock( AuthSubject.class );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.login( \"foo\", \"bar\" ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.TOO_MANY_ATTEMPTS );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 429 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Security.AuthenticationRateLimit\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"Too many failed authentication requests. Please wait 5 seconds and try again.\\\"\" ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAuthorizeWhenValidCredentialsSupplied() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.authenticate( \"foo\", \"bar\" ) ).thenReturn( AuthenticationResult.SUCCESS );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain ).doFilter( eq( new AuthorizedRequestWrapper( BASIC_AUTH, \"foo\", servletRequest ) ), same( servletResponse ) );\n    }","id":101072,"modified_method":"@Test\n    public void shouldAuthorizeWhenValidCredentialsSupplied() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        AuthSubject authSubject = mock( AuthSubject.class );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.login( \"foo\", \"bar\" ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.SUCCESS );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain ).doFilter( eq( new AuthorizedRequestWrapper( BASIC_AUTH, \"foo\", servletRequest,\n                AccessMode.Static.FULL ) ), same( servletResponse ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRequireAuthorizationForNonWhitelistedUris() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider, Pattern.compile( \"/\" ), Pattern.compile( \"/browser.*\" ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 401 );\n        verify( servletResponse ).addHeader( HttpHeaders.WWW_AUTHENTICATE, \"Basic realm=\\\"Neo4j\\\"\" );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError\" +\".Security.Unauthorized\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"No authentication header supplied.\\\"\" ) );\n    }","id":101073,"modified_method":"@Test\n    public void shouldRequireAuthorizationForNonWhitelistedUris() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter\n                filter = new AuthorizationEnabledFilter( () -> authManager, logProvider, Pattern.compile( \"/\" ), Pattern.compile( \"/browser.*\" ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 401 );\n        verify( servletResponse ).addHeader( HttpHeaders.WWW_AUTHENTICATE, \"Basic realm=\\\"Neo4j\\\"\" );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError\" +\".Security.Unauthorized\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"No authentication header supplied.\\\"\" ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAuthorizeWhenPasswordChangeRequiredForWhitelistedPath() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/user/foo\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.authenticate( \"foo\", \"bar\" ) ).thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain ).doFilter( eq( new AuthorizedRequestWrapper( BASIC_AUTH, \"foo\", servletRequest ) ), same( servletResponse ) );\n    }","id":101074,"modified_method":"@Test\n    public void shouldAuthorizeWhenPasswordChangeRequiredForWhitelistedPath() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        AuthSubject authSubject = mock( AuthSubject.class );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/user/foo\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.login( \"foo\", \"bar\" ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain ).doFilter( eq( new AuthorizedRequestWrapper( BASIC_AUTH, \"foo\", servletRequest,\n                AccessMode.Static.FULL ) ), same( servletResponse ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldIncludeCrippledAuthHeaderIfBrowserIsTheOneCalling() throws Throwable\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider, Pattern.compile( \"/\" ), Pattern.compile( \"/browser.*\" ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( \"X-Ajax-Browser-Auth\" )).thenReturn( \"true\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 401 );\n        verify( servletResponse ).addHeader( HttpHeaders.WWW_AUTHENTICATE, \"None\" );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError\" +\".Security.Unauthorized\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"No authentication header supplied.\\\"\" ) );\n    }","id":101075,"modified_method":"@Test\n    public void shouldIncludeCrippledAuthHeaderIfBrowserIsTheOneCalling() throws Throwable\n    {\n        // Given\n        final AuthorizationEnabledFilter\n                filter = new AuthorizationEnabledFilter( () -> authManager, logProvider, Pattern.compile( \"/\" ), Pattern.compile( \"/browser.*\" ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( \"X-Ajax-Browser-Auth\" )).thenReturn( \"true\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 401 );\n        verify( servletResponse ).addHeader( HttpHeaders.WWW_AUTHENTICATE, \"None\" );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError\" +\".Security.Unauthorized\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"No authentication header supplied.\\\"\" ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRequireValidAuthorizationHeader() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"NOT A VALID VALUE\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 400 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Request.InvalidFormat\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"Invalid authentication header.\\\"\" ) );\n    }","id":101076,"modified_method":"@Test\n    public void shouldRequireValidAuthorizationHeader() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"NOT A VALID VALUE\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 400 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Request.InvalidFormat\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"Invalid authentication header.\\\"\" ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowOptionsRequests() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider );\n        when( servletRequest.getMethod() ).thenReturn( \"OPTIONS\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain ).doFilter( same( servletRequest ), same( servletResponse ) );\n    }","id":101077,"modified_method":"@Test\n    public void shouldAllowOptionsRequests() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider );\n        when( servletRequest.getMethod() ).thenReturn( \"OPTIONS\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain ).doFilter( same( servletRequest ), same( servletResponse ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotAuthorizeInvalidCredentials() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( servletRequest.getRemoteAddr() ).thenReturn( \"remote_ip_address\" );\n        when( authManager.authenticate( \"foo\", \"bar\" ) ).thenReturn( AuthenticationResult.FAILURE );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        logProvider.assertExactly(\n                inLog( AuthorizationFilter.class ).warn( \"Failed authentication attempt for '%s' from %s\", \"foo\", \"remote_ip_address\" )\n        );\n        verify( servletResponse ).setStatus( 401 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Security.Unauthorized\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"Invalid username or password.\\\"\" ) );\n    }","id":101078,"modified_method":"@Test\n    public void shouldNotAuthorizeInvalidCredentials() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        AuthSubject authSubject = mock( AuthSubject.class );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( servletRequest.getRemoteAddr() ).thenReturn( \"remote_ip_address\" );\n        when( authManager.login( \"foo\", \"bar\" ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.FAILURE );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        logProvider.assertExactly(\n                inLog( AuthorizationEnabledFilter.class ).warn( \"Failed authentication attempt for '%s' from %s\", \"foo\", \"remote_ip_address\" )\n        );\n        verify( servletResponse ).setStatus( 401 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Security.Unauthorized\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"Invalid username or password.\\\"\" ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldWhitelistMatchingUris() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider,\n                Pattern.compile( \"/\" ), Pattern.compile( \"/browser.*\" ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/\", \"/browser/index.html\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain, times( 2 ) ).doFilter( same( servletRequest ), same( servletResponse ) );\n    }","id":101079,"modified_method":"@Test\n    public void shouldWhitelistMatchingUris() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider,\n                Pattern.compile( \"/\" ), Pattern.compile( \"/browser.*\" ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/\", \"/browser/index.html\" );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verify( filterChain, times( 2 ) ).doFilter( same( servletRequest ), same( servletResponse ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotAuthorizeWhenPasswordChangeRequired() throws Exception\n    {\n        // Given\n        final AuthorizationFilter filter = new AuthorizationFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getRequestURL() ).thenReturn( new StringBuffer( \"http://bar.baz:7474/db/data/\" ) );\n        when( servletRequest.getRequestURI() ).thenReturn( \"/db/data/\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.authenticate( \"foo\", \"bar\" ) ).thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 403 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"password_change\\\" : \\\"http://bar.baz:7474/user/foo/password\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Security.Forbidden\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"User is required to change their password.\\\"\" ) );\n    }","id":101080,"modified_method":"@Test\n    public void shouldNotAuthorizeWhenPasswordChangeRequired() throws Exception\n    {\n        // Given\n        final AuthorizationEnabledFilter filter = new AuthorizationEnabledFilter( () -> authManager, logProvider );\n        String credentials = Base64.encodeBase64String( \"foo:bar\".getBytes( StandardCharsets.UTF_8 ) );\n        AuthSubject authSubject = mock( AuthSubject.class );\n        when( servletRequest.getMethod() ).thenReturn( \"GET\" );\n        when( servletRequest.getContextPath() ).thenReturn( \"/db/data\" );\n        when( servletRequest.getRequestURL() ).thenReturn( new StringBuffer( \"http://bar.baz:7474/db/data/\" ) );\n        when( servletRequest.getRequestURI() ).thenReturn( \"/db/data/\" );\n        when( servletRequest.getHeader( HttpHeaders.AUTHORIZATION ) ).thenReturn( \"BASIC \" + credentials );\n        when( authManager.login( \"foo\", \"bar\" ) ).thenReturn( authSubject );\n        when( authSubject.getAuthenticationResult() ).thenReturn( AuthenticationResult.PASSWORD_CHANGE_REQUIRED );\n\n        // When\n        filter.doFilter( servletRequest, servletResponse, filterChain );\n\n        // Then\n        verifyNoMoreInteractions( filterChain );\n        verify( servletResponse ).setStatus( 403 );\n        verify( servletResponse ).addHeader( HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\" );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"password_change\\\" : \\\"http://bar.baz:7474/user/foo/password\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"code\\\" : \\\"Neo.ClientError.Security.Forbidden\\\"\" ) );\n        assertThat( outputStream.toString( StandardCharsets.UTF_8.name() ), containsString( \"\\\"message\\\" : \\\"User is required to change their password.\\\"\" ) );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void start()\n    {\n        if ( config.get( GraphDatabaseSettings.auth_enabled ) )\n        {\n            final AuthorizationFilter authorizationFilter = new AuthorizationFilter( authManagerSupplier, logProvider, uriWhitelist );\n            webServer.addFilter( authorizationFilter, \"/*\" );\n        }\n    }","id":101081,"modified_method":"@Override\n    public void start()\n    {\n        final Filter authorizationFilter;\n\n        if ( config.get( GraphDatabaseSettings.auth_enabled ) )\n        {\n            authorizationFilter = new AuthorizationEnabledFilter( authManagerSupplier, logProvider, uriWhitelist );\n        }\n        else\n        {\n            authorizationFilter = new AuthorizationDisabledFilter();\n        }\n\n        webServer.addFilter( authorizationFilter, \"/*\" );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"public AuthorizedRequestWrapper( final String authType, final String username, final HttpServletRequest request )\n    {\n        super( request );\n        this.authType = authType;\n        this.principle = new DelegatingPrinciple( username );\n    }","id":101082,"modified_method":"public AuthorizedRequestWrapper( final String authType, final String username, final HttpServletRequest request,\n            AccessMode accessMode )\n    {\n        super( request );\n        this.authType = authType;\n        this.principle = new DelegatingPrinciple( username, accessMode );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"private DelegatingPrinciple( String username )\n        {\n            this.username = username;\n        }","id":101083,"modified_method":"private DelegatingPrinciple( String username, AccessMode accessMode )\n        {\n            this.username = username;\n            this.accessMode = accessMode;\n        }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void dispatch( Object o, final HttpContext httpContext )\n    {\n        RepresentationWriteHandler representationWriteHandler = DO_NOTHING;\n\n        AccessMode mode = AccessMode.Static.FULL;\n\n        if ( o instanceof RestfulGraphDatabase )\n        {\n            RestfulGraphDatabase restfulGraphDatabase = (RestfulGraphDatabase) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.implicit, mode );\n\n            restfulGraphDatabase.getOutputFormat().setRepresentationWriteHandler( representationWriteHandler = new\n                    CommitOnSuccessfulStatusCodeRepresentationWriteHandler( httpContext, transaction ));\n        }\n        else if ( o instanceof BatchOperationService )\n        {\n            BatchOperationService batchOperationService = (BatchOperationService) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.explicit, mode );\n\n            batchOperationService.setRepresentationWriteHandler( representationWriteHandler = new\n                    CommitOnSuccessfulStatusCodeRepresentationWriteHandler( httpContext, transaction ) );\n        }\n        else if ( o instanceof CypherService )\n        {\n            CypherService cypherService = (CypherService) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.explicit, mode );\n\n            cypherService.getOutputFormat().setRepresentationWriteHandler( representationWriteHandler = new\n                    CommitOnSuccessfulStatusCodeRepresentationWriteHandler( httpContext, transaction ) );\n        }\n        else if ( o instanceof DatabaseMetadataService )\n        {\n            DatabaseMetadataService databaseMetadataService = (DatabaseMetadataService) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.implicit, mode );\n\n            databaseMetadataService.setRepresentationWriteHandler( representationWriteHandler = new\n                    RepresentationWriteHandler()\n            {\n                @Override\n                public void onRepresentationStartWriting()\n                {\n                    // do nothing\n                }\n\n                @Override\n                public void onRepresentationWritten()\n                {\n                    // doesn't need to commit\n                }\n\n                @Override\n                public void onRepresentationFinal()\n                {\n                    transaction.close();\n                }\n            } );\n        }\n        else if ( o instanceof ExtensionService )\n        {\n            ExtensionService extensionService = (ExtensionService) o;\n            extensionService.getOutputFormat().setRepresentationWriteHandler( representationWriteHandler = new\n                    RepresentationWriteHandler()\n            {\n                Transaction transaction;\n\n                @Override\n                public void onRepresentationStartWriting()\n                {\n                    transaction = database.getGraph().beginTransaction( KernelTransaction.Type.implicit, mode );\n                }\n\n                @Override\n                public void onRepresentationWritten()\n                {\n                    // doesn't need to commit\n                }\n\n                @Override\n                public void onRepresentationFinal()\n                {\n                    if ( transaction != null )\n                    {\n                        transaction.close();\n                    }\n                }\n            } );\n        }\n\n        try\n        {\n            requestDispatcher.dispatch( o, httpContext );\n        }\n        catch ( RuntimeException e )\n        {\n            representationWriteHandler.onRepresentationFinal();\n\n            throw e;\n        }\n    }","id":101084,"modified_method":"@Override\n    public void dispatch( Object o, final HttpContext httpContext )\n    {\n        RepresentationWriteHandler representationWriteHandler = DO_NOTHING;\n\n        AccessMode mode = AuthorizedRequestWrapper.getAccessModeFromHttpContext( httpContext );\n\n        if ( o instanceof RestfulGraphDatabase )\n        {\n            RestfulGraphDatabase restfulGraphDatabase = (RestfulGraphDatabase) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.implicit, mode );\n\n            restfulGraphDatabase.getOutputFormat().setRepresentationWriteHandler( representationWriteHandler = new\n                    CommitOnSuccessfulStatusCodeRepresentationWriteHandler( httpContext, transaction ));\n        }\n        else if ( o instanceof BatchOperationService )\n        {\n            BatchOperationService batchOperationService = (BatchOperationService) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.explicit, mode );\n\n            batchOperationService.setRepresentationWriteHandler( representationWriteHandler = new\n                    CommitOnSuccessfulStatusCodeRepresentationWriteHandler( httpContext, transaction ) );\n        }\n        else if ( o instanceof CypherService )\n        {\n            CypherService cypherService = (CypherService) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.explicit, mode );\n\n            cypherService.getOutputFormat().setRepresentationWriteHandler( representationWriteHandler = new\n                    CommitOnSuccessfulStatusCodeRepresentationWriteHandler( httpContext, transaction ) );\n        }\n        else if ( o instanceof DatabaseMetadataService )\n        {\n            DatabaseMetadataService databaseMetadataService = (DatabaseMetadataService) o;\n\n            final Transaction transaction = database.getGraph().beginTransaction( KernelTransaction.Type.implicit, mode );\n\n            databaseMetadataService.setRepresentationWriteHandler( representationWriteHandler = new\n                    RepresentationWriteHandler()\n            {\n                @Override\n                public void onRepresentationStartWriting()\n                {\n                    // do nothing\n                }\n\n                @Override\n                public void onRepresentationWritten()\n                {\n                    // doesn't need to commit\n                }\n\n                @Override\n                public void onRepresentationFinal()\n                {\n                    transaction.close();\n                }\n            } );\n        }\n        else if ( o instanceof ExtensionService )\n        {\n            ExtensionService extensionService = (ExtensionService) o;\n            extensionService.getOutputFormat().setRepresentationWriteHandler( representationWriteHandler = new\n                    RepresentationWriteHandler()\n            {\n                Transaction transaction;\n\n                @Override\n                public void onRepresentationStartWriting()\n                {\n                    transaction = database.getGraph().beginTransaction( KernelTransaction.Type.implicit, mode );\n                }\n\n                @Override\n                public void onRepresentationWritten()\n                {\n                    // doesn't need to commit\n                }\n\n                @Override\n                public void onRepresentationFinal()\n                {\n                    if ( transaction != null )\n                    {\n                        transaction.close();\n                    }\n                }\n            } );\n        }\n\n        try\n        {\n            requestDispatcher.dispatch( o, httpContext );\n        }\n        catch ( RuntimeException e )\n        {\n            representationWriteHandler.onRepresentationFinal();\n\n            throw e;\n        }\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@POST\n    @Path(\"/commit\")\n    @Consumes({MediaType.APPLICATION_JSON})\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response commitNewTransaction( final InputStream input, @Context final UriInfo uriInfo,\n                                          @Context final HttpServletRequest request )\n    {\n        final TransactionHandle transactionHandle;\n        try\n        {\n            transactionHandle = facade.newTransactionHandle( uriScheme, true, AccessMode.Static.FULL );\n        }\n        catch ( TransactionLifecycleException e )\n        {\n            return invalidTransaction( e, uriInfo.getBaseUri() );\n        }\n        final StreamingOutput streamingResults =\n                executeStatementsAndCommit( input, transactionHandle, uriInfo.getBaseUri(), request );\n        return okResponse( streamingResults );\n    }","id":101085,"modified_method":"@POST\n    @Path(\"/commit\")\n    @Consumes({MediaType.APPLICATION_JSON})\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response commitNewTransaction( final InputStream input, @Context final UriInfo uriInfo,\n                                          @Context final HttpServletRequest request )\n    {\n        final TransactionHandle transactionHandle;\n        try\n        {\n            AccessMode accessMode = AuthorizedRequestWrapper.getAccessModeFromHttpServletRequest( request );\n            transactionHandle = facade.newTransactionHandle( uriScheme, true, accessMode );\n        }\n        catch ( TransactionLifecycleException e )\n        {\n            return invalidTransaction( e, uriInfo.getBaseUri() );\n        }\n        final StreamingOutput streamingResults =\n                executeStatementsAndCommit( input, transactionHandle, uriInfo.getBaseUri(), request );\n        return okResponse( streamingResults );\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"@POST\n    @Consumes({MediaType.APPLICATION_JSON})\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response executeStatementsInNewTransaction( final InputStream input, @Context final UriInfo uriInfo,\n                                                       @Context final HttpServletRequest request )\n    {\n        try\n        {\n            usage.get( features ).flag( http_tx_endpoint );\n            TransactionHandle transactionHandle = facade.newTransactionHandle( uriScheme, false, AccessMode.Static.FULL );\n            return createdResponse( transactionHandle, executeStatements( input, transactionHandle, uriInfo.getBaseUri(), request ) );\n        }\n        catch ( TransactionLifecycleException e )\n        {\n            return invalidTransaction( e, uriInfo.getBaseUri() );\n        }\n    }","id":101086,"modified_method":"@POST\n    @Consumes({MediaType.APPLICATION_JSON})\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response executeStatementsInNewTransaction( final InputStream input, @Context final UriInfo uriInfo,\n                                                       @Context final HttpServletRequest request )\n    {\n        try\n        {\n            usage.get( features ).flag( http_tx_endpoint );\n            AccessMode accessMode = AuthorizedRequestWrapper.getAccessModeFromHttpServletRequest( request );\n            TransactionHandle transactionHandle = facade.newTransactionHandle( uriScheme, false, accessMode );\n            return createdResponse( transactionHandle, executeStatements( input, transactionHandle, uriInfo.getBaseUri(), request ) );\n        }\n        catch ( TransactionLifecycleException e )\n        {\n            return invalidTransaction( e, uriInfo.getBaseUri() );\n        }\n    }","commit_id":"921bd8c07775ee081c2e9de8f017fa06e6713a36","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean accept(File file, Context context) {\n    return !fileType.equals(context.fileType()) || !pattern.match(context.fileRelativePath());\n  }","id":101087,"modified_method":"public boolean accept(File file, Context context) {\n    WildcardPattern[] inclusionPatterns = (context.fileType() == FileType.TEST ? testInclusions : sourceInclusions);\n    for (WildcardPattern pattern : inclusionPatterns) {\n      if (!pattern.match(context.fileRelativePath())) {\n        return false;\n      }\n    }\n    WildcardPattern[] exclusionPatterns = (context.fileType() == FileType.TEST ? testExclusions : sourceExclusions);\n    for (WildcardPattern pattern : exclusionPatterns) {\n      if (pattern.match(context.fileRelativePath())) {\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"ExclusionFileFilter(FileType fileType, String pattern) {\n    this.fileType = fileType;\n    this.pattern = WildcardPattern.create(StringUtils.trim(pattern));\n  }","id":101088,"modified_method":"public ExclusionFileFilter(Settings settings) {\n    sourceInclusions = ExclusionPatterns.sourceInclusions(settings);\n    log(\"Included sources: \", sourceInclusions);\n\n    testInclusions = ExclusionPatterns.testInclusions(settings);\n    log(\"Included tests: \", sourceInclusions);\n\n    sourceExclusions = ExclusionPatterns.sourceExclusions(settings);\n    log(\"Excluded sources: \", sourceExclusions);\n\n    testExclusions = ExclusionPatterns.testExclusions(settings);\n    log(\"Excluded tests: \", sourceExclusions);\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_trim_pattern() throws IOException {\n    ExclusionFileFilter filter = new ExclusionFileFilter(FileFilter.FileType.SOURCE, \"   **/*Dao.java  \");\n    assertThat(filter.pattern().toString()).isEqualTo(\"**/*Dao.java\");\n  }","id":101089,"modified_method":"@Test\n  public void should_trim_pattern() throws IOException {\n    Settings settings = new Settings();\n    settings.setProperty(CoreProperties.PROJECT_EXCLUSIONS_PROPERTY, \"   **/*Dao.java   \");\n    ExclusionFileFilter filter = new ExclusionFileFilter(settings);\n\n    assertThat(filter.sourceExclusions()[0].toString()).isEqualTo(\"**/*Dao.java\");\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initBinaryDirs(ProjectDefinition module, PathResolver pathResolver, DefaultModuleFileSystem.Builder builder) {\n    for (String path : module.getBinaries()) {\n      builder.addBinaryDir(pathResolver.relativeFile(module.getBaseDir(), path));\n    }\n  }","id":101090,"modified_method":"private void initBinaryDirs(ProjectDefinition module, PathResolver pathResolver, DefaultModuleFileSystem.Builder builder) {\n    for (String path : module.getBinaries()) {\n      File dir = pathResolver.relativeFile(module.getBaseDir(), path);\n      LOG.info(\"Binary dir: \" + dir.getAbsolutePath());\n      builder.addBinaryDir(dir);\n    }\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initTests(ProjectDefinition module, PathResolver pathResolver, DefaultModuleFileSystem.Builder builder) {\n    for (String testPath : module.getTestDirs()) {\n      builder.addTestDir(pathResolver.relativeFile(module.getBaseDir(), testPath));\n    }\n    List<File> testFiles = pathResolver.relativeFiles(module.getBaseDir(), module.getTestFiles());\n    if (!testFiles.isEmpty()) {\n      builder.addFileFilter(new WhiteListFileFilter(FileFilter.FileType.TEST, ImmutableSet.copyOf(testFiles)));\n    }\n  }","id":101091,"modified_method":"private void initTests(ProjectDefinition module, PathResolver pathResolver, DefaultModuleFileSystem.Builder builder) {\n    if (!module.getTestDirs().isEmpty()) {\n      Log.info(\"Test dirs:\");\n      for (String testPath : module.getTestDirs()) {\n        File dir = pathResolver.relativeFile(module.getBaseDir(), testPath);\n        LOG.info(\"  \" + dir.getAbsolutePath());\n        builder.addTestDir(dir);\n      }\n    }\n    List<File> testFiles = pathResolver.relativeFiles(module.getBaseDir(), module.getTestFiles());\n    if (!testFiles.isEmpty()) {\n      Log.info(\"Test files:\");\n      for (File testFile : testFiles) {\n        LOG.info(\"  \" + testFile.getAbsolutePath());\n      }\n      builder.addFileFilter(new WhiteListFileFilter(FileFilter.FileType.TEST, ImmutableSet.copyOf(testFiles)));\n    }\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ModuleFileSystem provide(ProjectDefinition module, PathResolver pathResolver, TempDirectories tempDirectories,\n                                  LanguageFileFilters languageFileFilters, Settings settings, FileFilter[] pluginFileFilters) {\n    if (singleton == null) {\n      DefaultModuleFileSystem.Builder builder = new DefaultModuleFileSystem.Builder();\n\n      // dependencies\n      builder.pathResolver(pathResolver);\n      builder.languageFileFilters(languageFileFilters);\n\n      // files and directories\n      // TODO should the basedir always exist ? If yes, then we check also check that it's a dir but not a file\n      builder.baseDir(module.getBaseDir());\n      builder.sourceCharset(guessCharset(settings));\n      builder.workingDir(guessWorkingDir(module, tempDirectories));\n      initBinaryDirs(module, pathResolver, builder);\n      initSources(module, pathResolver, builder);\n      initTests(module, pathResolver, builder);\n\n      // file filters\n      initPluginFilters(builder, pluginFileFilters);\n      initSourceInclusions(builder, settings);\n      initTestInclusions(builder, settings);\n\n      singleton = builder.build();\n    }\n    return singleton;\n  }","id":101092,"modified_method":"public ModuleFileSystem provide(ProjectDefinition module, PathResolver pathResolver, TempDirectories tempDirectories,\n                                  LanguageFileFilters languageFileFilters, Settings settings, FileFilter[] pluginFileFilters) {\n    if (singleton == null) {\n      DefaultModuleFileSystem.Builder builder = new DefaultModuleFileSystem.Builder();\n\n      // dependencies\n      builder.pathResolver(pathResolver);\n      builder.languageFileFilters(languageFileFilters);\n\n      // files and directories\n      // TODO should the basedir always exist ? If yes, then we check also check that it's a dir but not a file\n      builder.baseDir(module.getBaseDir());\n      builder.sourceCharset(guessCharset(settings));\n      builder.workingDir(guessWorkingDir(module, tempDirectories));\n      initBinaryDirs(module, pathResolver, builder);\n      initSources(module, pathResolver, builder);\n      initTests(module, pathResolver, builder);\n\n      // file filters\n      initCustomFilters(builder, pluginFileFilters);\n      singleton = builder.build();\n    }\n    return singleton;\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initSources(ProjectDefinition module, PathResolver pathResolver, DefaultModuleFileSystem.Builder builder) {\n    for (String sourcePath : module.getSourceDirs()) {\n      builder.addSourceDir(pathResolver.relativeFile(module.getBaseDir(), sourcePath));\n    }\n    List<File> sourceFiles = pathResolver.relativeFiles(module.getBaseDir(), module.getSourceFiles());\n    if (!sourceFiles.isEmpty()) {\n      builder.addFileFilter(new WhiteListFileFilter(FileFilter.FileType.SOURCE, ImmutableSet.copyOf(sourceFiles)));\n    }\n  }","id":101093,"modified_method":"private void initSources(ProjectDefinition module, PathResolver pathResolver, DefaultModuleFileSystem.Builder builder) {\n    if (!module.getSourceDirs().isEmpty()) {\n      LOG.info(\"Source dirs: \");\n      for (String sourcePath : module.getSourceDirs()) {\n        File dir = pathResolver.relativeFile(module.getBaseDir(), sourcePath);\n        LOG.info(\"  \" + dir.getAbsolutePath());\n        builder.addSourceDir(dir);\n      }\n    }\n    List<File> sourceFiles = pathResolver.relativeFiles(module.getBaseDir(), module.getSourceFiles());\n    if (!sourceFiles.isEmpty()) {\n      LOG.info(\"Source files: \");\n      for (File sourceFile : sourceFiles) {\n        LOG.info(\"  \" + sourceFile.getAbsolutePath());\n      }\n      builder.addFileFilter(new WhiteListFileFilter(FileFilter.FileType.SOURCE, ImmutableSet.copyOf(sourceFiles)));\n    }\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void initPluginFilters(DefaultModuleFileSystem.Builder builder, FileFilter[] pluginFileFilters) {\n    for (FileFilter pluginFileFilter : pluginFileFilters) {\n      builder.addFileFilter(pluginFileFilter);\n    }\n  }","id":101094,"modified_method":"private void initCustomFilters(DefaultModuleFileSystem.Builder builder, FileFilter[] pluginFileFilters) {\n    for (FileFilter pluginFileFilter : pluginFileFilters) {\n      builder.addFileFilter(pluginFileFilter);\n    }\n  }","commit_id":"c4a856c5a291d373fff2549e085fd8bd4c275e9a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"Vlan(OnmsVlan vlan)\n    {\n        m_nodeId = vlan.getNode().getId();\n        m_vlanId = vlan.getVlanId();\n        m_vlanname = vlan.getVlanName();\n        m_vlantype = VlanType.getVlanTypeString(vlan.getVlanType().getIntCode());\n        m_vlanstatus = VlanStatus.getVlanStatusString(vlan.getVlanStatus().getIntCode());\n        m_lastPollTime = Util.formatDateToUIString(vlan.getLastPollTime()); \n        m_status = StatusType.getStatusString(vlan.getStatus().getCharCode());\n    }","id":101095,"modified_method":"Vlan(OnmsVlan vlan)\n    {\n        m_nodeId = vlan.getNode().getId();\n        m_vlanId = vlan.getVlanId();\n        m_vlanname = vlan.getVlanName();\n        m_vlantype = VlanType.getVlanTypeString(vlan.getVlanType() == null ? VlanType.UNKNOWN.getIntCode() : vlan.getVlanType().getIntCode());\n        m_vlanstatus = VlanStatus.getVlanStatusString(vlan.getVlanStatus() == null ? VlanStatus.UNKNOWN.getIntCode() : vlan.getVlanStatus().getIntCode());\n        m_lastPollTime = Util.formatDateToUIString(vlan.getLastPollTime()); \n        m_status = StatusType.getStatusString(vlan.getStatus() == null ? StatusType.UNKNOWN.getCharCode() : vlan.getStatus().getCharCode());\n    }","commit_id":"79039fd2ade7f8f9e7c6ccaf6c6ce3982fd35c8b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"Vlan(OnmsVlan vlan)\n    {\n        m_nodeId = vlan.getNode().getId();\n        m_vlanId = vlan.getVlanId();\n        m_vlanname = vlan.getVlanName();\n        m_vlantype = VlanType.getVlanTypeString(vlan.getVlanType().getIntCode());\n        m_vlanstatus = VlanStatus.getVlanStatusString(vlan.getVlanStatus().getIntCode());\n        m_lastPollTime = Util.formatDateToUIString(vlan.getLastPollTime()); \n        m_status = StatusType.getStatusString(vlan.getStatus().getCharCode());\n    }","id":101096,"modified_method":"Vlan(OnmsVlan vlan)\n    {\n        m_nodeId = vlan.getNode().getId();\n        m_vlanId = vlan.getVlanId();\n        m_vlanname = vlan.getVlanName();\n        m_vlantype = VlanType.getVlanTypeString(vlan.getVlanType() == null ? VlanType.UNKNOWN.getIntCode() : vlan.getVlanType().getIntCode());\n        m_vlanstatus = VlanStatus.getVlanStatusString(vlan.getVlanStatus() == null ? VlanStatus.UNKNOWN.getIntCode() : vlan.getVlanStatus().getIntCode());\n        m_lastPollTime = Util.formatDateToUIString(vlan.getLastPollTime()); \n        m_status = StatusType.getStatusString(vlan.getStatus() == null ? StatusType.UNKNOWN.getCharCode() : vlan.getStatus().getCharCode());\n    }","commit_id":"0de78ed3133e019b0415147b306514a15fb434e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void updateMethod(SNode sourceMethod, SNode method) {\n    super.updateMethod(sourceMethod, method);\n    SNode defaultReturnExpr = Type_Behavior.call_createDefaultTypeExpression_3359611512358152580(SLinkOperations.getTarget(method, \"returnType\", true));\n    if ((defaultReturnExpr != null)) {\n      SLinkOperations.addChild(SLinkOperations.getTarget(method, \"body\", true), \"statement\", this.getReturnStatement(defaultReturnExpr));\n    }\n  }","id":101097,"modified_method":"public void updateMethod(SNode sourceMethod, SNode method) {\n    super.updateMethod(sourceMethod, method);\n    SNode defaultReturnExpr = Type_Behavior.call_createDefaultTypeExpression_3359611512358152580(SLinkOperations.getTarget(method, \"returnType\", true));\n    if ((defaultReturnExpr != null)) {\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(this.getReturnStatement(defaultReturnExpr));\n    }\n  }","commit_id":"68aabd23b879ef22969eedf9bfccdea5f19e8007","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void updateMethod(SNode sourceMethod, SNode method) {\n    super.updateMethod(sourceMethod, method);\n    if (this.myCheckBox.isSelected()) {\n      SLinkOperations.addChild(method, \"annotation\", new _Quotations.QuotationClass_1().createNode());\n    }\n\n    Iterable<SNode> paramList = ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return new _Quotations.QuotationClass_9().createNode(it);\n      }\n    });\n    SNode superCallExpr = new _Quotations.QuotationClass_3().createNode(sourceMethod, Sequence.fromIterable(paramList).toListSequence());\n\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, \"returnType\", true), \"jetbrains.mps.baseLanguage.structure.VoidType\")) {\n      SLinkOperations.addChild(SLinkOperations.getTarget(method, \"body\", true), \"statement\", new _Quotations.QuotationClass_2().createNode(superCallExpr));\n    } else {\n      SLinkOperations.addChild(SLinkOperations.getTarget(method, \"body\", true), \"statement\", this.getReturnStatement(superCallExpr));\n    }\n  }","id":101098,"modified_method":"public void updateMethod(SNode sourceMethod, SNode method) {\n    super.updateMethod(sourceMethod, method);\n    if (this.myCheckBox.isSelected()) {\n      ListSequence.fromList(SLinkOperations.getTargets(method, \"annotation\", true)).addElement(new _Quotations.QuotationClass_1().createNode());\n    }\n\n    Iterable<SNode> paramList = ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return new _Quotations.QuotationClass_9().createNode(it);\n      }\n    });\n    SNode superCallExpr = new _Quotations.QuotationClass_3().createNode(sourceMethod, Sequence.fromIterable(paramList).toListSequence());\n\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, \"returnType\", true), \"jetbrains.mps.baseLanguage.structure.VoidType\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(new _Quotations.QuotationClass_2().createNode(superCallExpr));\n    } else {\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(this.getReturnStatement(superCallExpr));\n    }\n  }","commit_id":"68aabd23b879ef22969eedf9bfccdea5f19e8007","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void updateMethod(SNode sourceMethod, SNode method) {\n    super.updateMethod(sourceMethod, method);\n    Iterable<SNode> paramList = ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return new _Quotations.QuotationClass_7().createNode(it);\n      }\n    });\n    SNode superCallExpr = new _Quotations.QuotationClass_6().createNode(Sequence.fromIterable(paramList).toListSequence(), sourceMethod);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, \"returnType\", true), \"jetbrains.mps.baseLanguage.structure.VoidType\")) {\n      SLinkOperations.addChild(SLinkOperations.getTarget(method, \"body\", true), \"statement\", new _Quotations.QuotationClass_8().createNode(superCallExpr));\n    } else {\n      SLinkOperations.addChild(SLinkOperations.getTarget(method, \"body\", true), \"statement\", this.getReturnStatement(superCallExpr));\n    }\n  }","id":101099,"modified_method":"public void updateMethod(SNode sourceMethod, SNode method) {\n    super.updateMethod(sourceMethod, method);\n    Iterable<SNode> paramList = ListSequence.fromList(SLinkOperations.getTargets(method, \"parameter\", true)).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return new _Quotations.QuotationClass_7().createNode(it);\n      }\n    });\n    SNode superCallExpr = new _Quotations.QuotationClass_6().createNode(Sequence.fromIterable(paramList).toListSequence(), sourceMethod);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method, \"returnType\", true), \"jetbrains.mps.baseLanguage.structure.VoidType\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(new _Quotations.QuotationClass_8().createNode(superCallExpr));\n    } else {\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(method, \"body\", true), \"statement\", true)).addElement(this.getReturnStatement(superCallExpr));\n    }\n  }","commit_id":"68aabd23b879ef22969eedf9bfccdea5f19e8007","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Set<Capability> getMatchingHostCapabilities(Module fragment)\n    {\n        // Find the fragment's host requirement.\n        Requirement hostReq = getFragmentHostRequirement(fragment);\n\n        // Create a list of all matching hosts for this fragment.\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null)\n        {\n            if (!((BundleProtectionDomain) fragment.getSecurityContext()).impliesDirect(\n                new BundlePermission(fragment.getSymbolicName(), BundlePermission.FRAGMENT)))\n            {\n                return new HashSet<Capability>();\n            }\n        }\n\n        Set<Capability> hostCaps = m_hostCapSet.match(hostReq.getFilter(), true);\n\n        for (Iterator<Capability> it = hostCaps.iterator(); it.hasNext(); )\n        {\n            Capability hostCap = it.next();\n\n            // Only look at unresolved hosts, since we don't support\n            // dynamic attachment of fragments.\n// TODO: FELIX3 - This is potentially too narrow, since it won't allow\n//       attaching with updated modules.\n            if (hostCap.getModule().isResolved()\n                || ((BundleImpl) hostCap.getModule().getBundle()).isStale()\n                || ((BundleImpl) hostCap.getModule().getBundle()).isRemovalPending())\n            {\n                it.remove();\n            }\n            else if (sm != null)\n            {\n                if (!((BundleProtectionDomain) hostCap.getModule()\n                    .getSecurityContext()).impliesDirect(\n                        new BundlePermission(hostCap.getModule().getSymbolicName(),\n                            BundlePermission.HOST)))\n                {\n                    it.remove();\n                }\n            }\n        }\n\n        return hostCaps;\n    }","id":101100,"modified_method":"private Set<Capability> getMatchingHostCapabilities(Module fragment)\n    {\n        // Find the fragment's host requirement.\n        Requirement hostReq = getFragmentHostRequirement(fragment);\n\n        // Create a list of all matching hosts for this fragment.\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null)\n        {\n            if (!((BundleProtectionDomain) fragment.getSecurityContext()).impliesDirect(\n                new BundlePermission(fragment.getSymbolicName(), BundlePermission.FRAGMENT)))\n            {\n                return new HashSet<Capability>();\n            }\n        }\n\n        Set<Capability> hostCaps = m_capSets.get(Capability.HOST_NAMESPACE).match(hostReq.getFilter(), true);\n\n        for (Iterator<Capability> it = hostCaps.iterator(); it.hasNext(); )\n        {\n            Capability hostCap = it.next();\n\n            // Only look at unresolved hosts, since we don't support\n            // dynamic attachment of fragments.\n// TODO: FELIX3 - This is potentially too narrow, since it won't allow\n//       attaching with updated modules.\n            if (hostCap.getModule().isResolved()\n                || ((BundleImpl) hostCap.getModule().getBundle()).isStale()\n                || ((BundleImpl) hostCap.getModule().getBundle()).isRemovalPending())\n            {\n                it.remove();\n            }\n            else if (sm != null)\n            {\n                if (!((BundleProtectionDomain) hostCap.getModule()\n                    .getSecurityContext()).impliesDirect(\n                        new BundlePermission(hostCap.getModule().getSymbolicName(),\n                            BundlePermission.HOST)))\n                {\n                    it.remove();\n                }\n            }\n        }\n\n        return hostCaps;\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"public Set<Capability> getCandidates(Module module, Requirement req, boolean obeyMandatory)\n    {\n        Set<Capability> result = new TreeSet<Capability>(new CandidateComparator());\n\n        if (req.getNamespace().equals(Capability.MODULE_NAMESPACE))\n        {\n            result.addAll(m_modCapSet.match(req.getFilter(), obeyMandatory));\n        }\n        else if (req.getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n        {\n            result.addAll(m_pkgCapSet.match(req.getFilter(), obeyMandatory));\n        }\n\n        return result;\n    }","id":101101,"modified_method":"public Set<Capability> getCandidates(Module module, Requirement req, boolean obeyMandatory)\n    {\n        Set<Capability> result = new TreeSet<Capability>(new CandidateComparator());\n\n        CapabilitySet capSet = m_capSets.get(req.getNamespace());\n        if (capSet != null)\n        {\n            result.addAll(capSet.match(req.getFilter(), obeyMandatory));\n        }\n\n        return result;\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"private void addHost(Module host)\n    {\n        // When a module is added, we first need to pre-merge any potential fragments\n        // into the host and then second create an aggregated list of unresolved\n        // capabilities to simplify later processing when resolving bundles.\n        m_modules.add(host);\n        List<Capability> caps = Util.getCapabilityByNamespace(host, Capability.HOST_NAMESPACE);\n        if (caps.size() > 0)\n        {\n            m_hostCapSet.addCapability(caps.get(0));\n        }\n\n        //\n        // First, merge applicable fragments.\n        //\n\n        List<Module> fragments = getMatchingFragments(host);\n\n        // Attach any fragments we found for this host.\n        if (fragments.size() > 0)\n        {\n            // Attach the fragments to the host.\n            try\n            {\n                ((ModuleImpl) host).attachFragments(fragments);\n            }\n            catch (Exception ex)\n            {\n                // Try to clean up by removing all fragments.\n                try\n                {\n                    ((ModuleImpl) host).attachFragments(null);\n                }\n                catch (Exception ex2)\n                {\n                    // Ignore\n                }\n                m_logger.log(Logger.LOG_ERROR,\n                    \"Serious error attaching fragments.\", ex);\n            }\n        }\n\n        //\n        // Second, index module's capabilities.\n        //\n\n        caps = host.getCapabilities();\n\n        // Add exports to unresolved package map.\n        addCapabilities(caps);\n    }","id":101102,"modified_method":"private void addHost(Module host)\n    {\n        // When a module is added, we first need to pre-merge any potential fragments\n        // into the host and then second create an aggregated list of unresolved\n        // capabilities to simplify later processing when resolving bundles.\n        m_modules.add(host);\n        List<Capability> caps = Util.getCapabilityByNamespace(host, Capability.HOST_NAMESPACE);\n        if (caps.size() > 0)\n        {\n            m_capSets.get(Capability.HOST_NAMESPACE).addCapability(caps.get(0));\n        }\n\n        //\n        // First, merge applicable fragments.\n        //\n\n        List<Module> fragments = getMatchingFragments(host);\n\n        // Attach any fragments we found for this host.\n        if (fragments.size() > 0)\n        {\n            // Attach the fragments to the host.\n            try\n            {\n                ((ModuleImpl) host).attachFragments(fragments);\n            }\n            catch (Exception ex)\n            {\n                // Try to clean up by removing all fragments.\n                try\n                {\n                    ((ModuleImpl) host).attachFragments(null);\n                }\n                catch (Exception ex2)\n                {\n                    // Ignore\n                }\n                m_logger.log(Logger.LOG_ERROR,\n                    \"Serious error attaching fragments.\", ex);\n            }\n        }\n\n        //\n        // Second, index module's capabilities.\n        //\n\n        caps = host.getCapabilities();\n\n        // Add exports to unresolved package map.\n        addCapabilities(caps);\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"private void removeCapabilities(List<Capability> caps)\n    {\n        if (caps != null)\n        {\n            for (Capability cap : caps)\n            {\n                if (cap.getNamespace().equals(Capability.MODULE_NAMESPACE))\n                {\n                    m_modCapSet.removeCapability(cap);\n                }\n                else if (cap.getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n                {\n                    m_pkgCapSet.removeCapability(cap);\n                }\n            }\n        }\n    }","id":101103,"modified_method":"private void removeCapabilities(List<Capability> caps)\n    {\n        if (caps != null)\n        {\n            for (Capability cap : caps)\n            {\n                CapabilitySet capSet = m_capSets.get( cap.getNamespace() );\n                if (capSet != null)\n                {\n                    capSet.removeCapability(cap);\n                }\n            }\n        }\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"public FelixResolverState(Logger logger, String fwkExecEnvStr)\n    {\n        m_logger = logger;\n        m_modules = new ArrayList<Module>();\n\n        m_fwkExecEnvStr = (fwkExecEnvStr != null) ? fwkExecEnvStr.trim() : null;\n        m_fwkExecEnvSet = parseExecutionEnvironments(fwkExecEnvStr);\n\n        List<String> indices = new ArrayList<String>();\n        indices.add(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE);\n        m_modCapSet = new CapabilitySet(indices);\n\n        indices = new ArrayList<String>();\n        indices.add(Capability.PACKAGE_ATTR);\n        m_pkgCapSet = new CapabilitySet(indices);\n\n        indices = new ArrayList<String>();\n        indices.add(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE);\n        m_hostCapSet = new CapabilitySet(indices);\n    }","id":101104,"modified_method":"public FelixResolverState(Logger logger, String fwkExecEnvStr)\n    {\n        m_logger = logger;\n        m_modules = new ArrayList<Module>();\n        m_capSets = new HashMap<String, CapabilitySet>();\n\n        m_fwkExecEnvStr = (fwkExecEnvStr != null) ? fwkExecEnvStr.trim() : null;\n        m_fwkExecEnvSet = parseExecutionEnvironments(fwkExecEnvStr);\n\n        List<String> indices = new ArrayList<String>();\n        indices.add(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE);\n        m_capSets.put( Capability.MODULE_NAMESPACE,  new CapabilitySet(indices) );\n\n        indices = new ArrayList<String>();\n        indices.add(Capability.PACKAGE_ATTR);\n        m_capSets.put( Capability.PACKAGE_NAMESPACE,  new CapabilitySet(indices) );\n\n        indices = new ArrayList<String>();\n        indices.add(Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE);\n        m_capSets.put( Capability.HOST_NAMESPACE,  new CapabilitySet(indices) );\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"private void addCapabilities(List<Capability> caps)\n    {\n        if (caps != null)\n        {\n            for (Capability cap : caps)\n            {\n                if (cap.getNamespace().equals(Capability.MODULE_NAMESPACE))\n                {\n                    m_modCapSet.addCapability(cap);\n                }\n                else if (cap.getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n                {\n                    m_pkgCapSet.addCapability(cap);\n                }\n            }\n        }\n    }","id":101105,"modified_method":"private void addCapabilities(List<Capability> caps)\n    {\n        if (caps != null)\n        {\n            for (Capability cap : caps)\n            {\n                CapabilitySet capSet = m_capSets.get( cap.getNamespace() );\n                if (capSet == null)\n                {\n                    capSet = new CapabilitySet(null);\n                    m_capSets.put(cap.getNamespace(), capSet);\n                }\n                capSet.addCapability(cap);\n            }\n        }\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"private void removeHost(Module host)\n    {\n        // We need remove the host's exports from the \"resolved\" and\n        // \"unresolved\" package maps, remove its dependencies on fragments\n        // and exporters, and remove it from the module list.\n        m_modules.remove(host);\n        List<Capability> caps = Util.getCapabilityByNamespace(host, Capability.HOST_NAMESPACE);\n        if (caps.size() > 0)\n        {\n            m_hostCapSet.removeCapability(caps.get(0));\n        }\n\n        // Remove exports from package maps.\n        caps = host.getCapabilities();\n        removeCapabilities(caps);\n\n        // Set fragments to null, which will remove the module from all\n        // of its dependent fragment modules.\n        try\n        {\n            ((ModuleImpl) host).attachFragments(null);\n        }\n        catch (Exception ex)\n        {\n            m_logger.log(Logger.LOG_ERROR, \"Error detaching fragments.\", ex);\n        }\n        // Set wires to null, which will remove the module from all\n        // of its dependent modules.\n        ((ModuleImpl) host).setWires(null);\n    }","id":101106,"modified_method":"private void removeHost(Module host)\n    {\n        // We need remove the host's exports from the \"resolved\" and\n        // \"unresolved\" package maps, remove its dependencies on fragments\n        // and exporters, and remove it from the module list.\n        m_modules.remove(host);\n        List<Capability> caps = Util.getCapabilityByNamespace(host, Capability.HOST_NAMESPACE);\n        if (caps.size() > 0)\n        {\n            m_capSets.get(Capability.HOST_NAMESPACE).removeCapability(caps.get(0));\n        }\n\n        // Remove exports from package maps.\n        caps = host.getCapabilities();\n        removeCapabilities(caps);\n\n        // Set fragments to null, which will remove the module from all\n        // of its dependent fragment modules.\n        try\n        {\n            ((ModuleImpl) host).attachFragments(null);\n        }\n        catch (Exception ex)\n        {\n            m_logger.log(Logger.LOG_ERROR, \"Error detaching fragments.\", ex);\n        }\n        // Set wires to null, which will remove the module from all\n        // of its dependent modules.\n        ((ModuleImpl) host).setWires(null);\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"public synchronized void moduleResolved(Module module)\n    {\n        if (module.isResolved())\n        {\n            // Loop through the module's package wires and determine if any\n            // of them overlap any of the packages exported by the module.\n            // If so, then the framework must have chosen to have the module\n            // import rather than export the package, so we need to remove the\n            // corresponding package capability from the package capability set.\n            List<Wire> wires = module.getWires();\n            List<Capability> caps = module.getCapabilities();\n            for (int wireIdx = 0; (wires != null) && (wireIdx < wires.size()); wireIdx++)\n            {\n                Wire wire = wires.get(wireIdx);\n                if (wire.getCapability().getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n                {\n                    for (int capIdx = 0;\n                        (caps != null) && (capIdx < caps.size());\n                        capIdx++)\n                    {\n                        if (caps.get(capIdx).getNamespace().equals(Capability.PACKAGE_NAMESPACE)\n                            && wire.getCapability().getAttribute(Capability.PACKAGE_ATTR).getValue()\n                                .equals(caps.get(capIdx).getAttribute(Capability.PACKAGE_ATTR).getValue()))\n                        {\n                            m_pkgCapSet.removeCapability(caps.get(capIdx));\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }","id":101107,"modified_method":"public synchronized void moduleResolved(Module module)\n    {\n        if (module.isResolved())\n        {\n            // Loop through the module's package wires and determine if any\n            // of them overlap any of the packages exported by the module.\n            // If so, then the framework must have chosen to have the module\n            // import rather than export the package, so we need to remove the\n            // corresponding package capability from the package capability set.\n            List<Wire> wires = module.getWires();\n            List<Capability> caps = module.getCapabilities();\n            for (int wireIdx = 0; (wires != null) && (wireIdx < wires.size()); wireIdx++)\n            {\n                Wire wire = wires.get(wireIdx);\n                if (wire.getCapability().getNamespace().equals(Capability.PACKAGE_NAMESPACE))\n                {\n                    for (int capIdx = 0;\n                        (caps != null) && (capIdx < caps.size());\n                        capIdx++)\n                    {\n                        if (caps.get(capIdx).getNamespace().equals(Capability.PACKAGE_NAMESPACE)\n                            && wire.getCapability().getAttribute(Capability.PACKAGE_ATTR).getValue()\n                                .equals(caps.get(capIdx).getAttribute(Capability.PACKAGE_ATTR).getValue()))\n                        {\n                            m_capSets.get(Capability.PACKAGE_NAMESPACE).removeCapability(caps.get(capIdx));\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"9a10cc75194cc23a4ff8c742593eda15d5ebd974","url":"https://github.com/apache/felix"},{"original_method":"private void initEnv()\r\n  {\r\n    env = TokenSequencePattern.getNewEnv();\r\n    env.setDefaultResultsAnnotationExtractor(TimeExpression.TimeExpressionConverter);\r\n    env.setDefaultTokensAnnotationKey(CoreAnnotations.NumerizedTokensAnnotation.class);\r\n    env.setDefaultResultAnnotationKey(TimeExpression.Annotation.class);\r\n    env.setDefaultNestedResultsAnnotationKey(TimeExpression.ChildrenAnnotation.class);\r\n    env.setDefaultTokensAggregators(CoreMapAttributeAggregator.DEFAULT_NUMERIC_TOKENS_AGGREGATORS);\r\n\r\n    env.bind(\"nested\", TimeExpression.ChildrenAnnotation.class);\r\n    env.bind(\"time\", new TimeFormatter.TimePatternExtractRuleCreator());\r\n    // Do case insensitive matching\r\n    env.setDefaultStringPatternFlags(Pattern.CASE_INSENSITIVE);\r\n\r\n    env.bind(\"options\", options);\r\n    env.bind(\"TIME_REF\", SUTime.TIME_REF);\r\n    env.bind(\"TIME_REF_UNKNOWN\", SUTime.TIME_REF_UNKNOWN);\r\n    env.bind(\"TIME_UNKNOWN\", SUTime.TIME_UNKNOWN);\r\n    env.bind(\"TIME_NONE\", SUTime.TIME_NONE);\r\n    env.bind(\"ERA_AD\", SUTime.ERA_AD);\r\n    env.bind(\"ERA_BC\", SUTime.ERA_BC);\r\n    env.bind(\"ERA_UNKNOWN\", SUTime.ERA_UNKNOWN);\r\n    env.bind(\"HALFDAY_AM\", SUTime.HALFDAY_AM);\r\n    env.bind(\"HALFDAY_PM\", SUTime.HALFDAY_PM);\r\n    env.bind(\"HALFDAY_UNKNOWN\", SUTime.HALFDAY_UNKNOWN);\r\n    env.bind(\"RESOLVE_TO_THIS\", SUTime.RESOLVE_TO_THIS);\r\n    env.bind(\"RESOLVE_TO_PAST\", SUTime.RESOLVE_TO_PAST);\r\n    env.bind(\"RESOLVE_TO_FUTURE\", SUTime.RESOLVE_TO_FUTURE);\r\n    env.bind(\"RESOLVE_TO_CLOSEST\", SUTime.RESOLVE_TO_CLOSEST);\r\n\r\n    env.bind(\"numcomptype\", CoreAnnotations.NumericCompositeTypeAnnotation.class);\r\n    env.bind(\"numcompvalue\", CoreAnnotations.NumericCompositeValueAnnotation.class);\r\n\r\n    env.bind(\"temporal\", TimeExpression.Annotation.class);\r\n//    env.bind(\"tags\", SequenceMatchRules.Tags.TagsAnnotation.class);\r\n    env.bind(\"::IS_TIMEX_DATE\", new TimexTypeMatchNodePattern(SUTime.TimexType.DATE));\r\n    env.bind(\"::IS_TIMEX_DURATION\", new TimexTypeMatchNodePattern(SUTime.TimexType.DURATION));\r\n    env.bind(\"::IS_TIMEX_TIME\", new TimexTypeMatchNodePattern(SUTime.TimexType.TIME));\r\n    env.bind(\"::IS_TIMEX_SET\", new TimexTypeMatchNodePattern(SUTime.TimexType.SET));\r\n    env.bind(\"::IS_TIME_UNIT\", new MatchedExpressionValueTypeMatchNodePattern(\"TIMEUNIT\"));\r\n    env.bind(\"::MONTH\", new MatchedExpressionValueTypeMatchNodePattern(\"MONTH_OF_YEAR\"));\r\n    env.bind(\"::DAYOFWEEK\", new MatchedExpressionValueTypeMatchNodePattern(\"DAY_OF_WEEK\"));\r\n\r\n    // BINDINGS for parsing from file!!!!!!!\r\n    for (SUTime.TemporalOp t:SUTime.TemporalOp.values()) {\r\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.TemporalOp>(\"TemporalOp\", t));\r\n    }\r\n    for (SUTime.TimeUnit t: SUTime.TimeUnit.values()) {\r\n      if (!t.equals(SUTime.TimeUnit.UNKNOWN)) {\r\n        //env.bind(t.name(), new SequenceMatchRules.PrimitiveValue<SUTime.Temporal>(\"DURATION\", t.getDuration(), \"TIMEUNIT\"));\r\n        env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.Temporal>(\"TIMEUNIT\", t.getDuration()));\r\n      }\r\n    }\r\n    for (SUTime.StandardTemporalType t: SUTime.StandardTemporalType.values()) {\r\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.StandardTemporalType>(\"TemporalType\", t));\r\n    }\r\n    env.bind(\"Duration\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"Duration\") {\r\n              private SUTime.Temporal addEndPoints(SUTime.Duration d, SUTime.Time beginTime, SUTime.Time endTime)\r\n              {\r\n                SUTime.Temporal t = d;\r\n                if (d != null && (beginTime != null || endTime != null)) {\r\n                  SUTime.Time b = beginTime;\r\n                  SUTime.Time e = endTime;\r\n                  // New so we get different time ids\r\n                  if (b == SUTime.TIME_REF_UNKNOWN) {\r\n                    b = new SUTime.RefTime(\"UNKNOWN\");\r\n                  } else if (b == SUTime.TIME_UNKNOWN) {\r\n                    b = new SUTime.SimpleTime(\"UNKNOWN\");\r\n                  }\r\n                  if (e == SUTime.TIME_REF_UNKNOWN) {\r\n                    e = new SUTime.RefTime(\"UNKNOWN\");\r\n                  } else if (e == SUTime.TIME_UNKNOWN) {\r\n                    e = new SUTime.SimpleTime(\"UNKNOWN\");\r\n                  }\r\n                  t = new SUTime.Range(b,e,d);\r\n                }\r\n                return t;\r\n              }\r\n\r\n              public boolean checkArgs(List<Value> in) {\r\n                // TODO: Check args\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() == 2) {\r\n                  SUTime.Duration d = (SUTime.Duration) in.get(0).get();\r\n                  if (in.get(1).get() instanceof Number) {\r\n                    int m = ((Number) in.get(1).get()).intValue();\r\n                    return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(m));\r\n                  } else if (in.get(1).get() instanceof String){\r\n                    Number n = Integer.parseInt((String) in.get(1).get());\r\n                    if (n != null) {\r\n                      return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(n.intValue()));\r\n                    } else {\r\n                      return null;\r\n                    }\r\n                  } else {\r\n                    throw new IllegalArgumentException(\"Invalid arguments to \" + name);\r\n                  }\r\n                } else if (in.size() == 5 || in.size() == 3) {\r\n                  // TODO: Handle Strings...\r\n                  List<? extends CoreMap> durationStartTokens = (List<? extends CoreMap>) in.get(0).get();\r\n                  Number durationStartVal = (durationStartTokens != null)? durationStartTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\r\n                  List<? extends CoreMap> durationEndTokens = (List<? extends CoreMap>) in.get(1).get();\r\n                  Number durationEndVal = (durationEndTokens != null)? durationEndTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\r\n                  // TODO: This should already be in durations....\r\n                  List<? extends CoreMap> durationUnitTokens = (List<? extends CoreMap>) in.get(2).get();\r\n                  //String durationUnitString = (durationUnitTokens != null)? durationUnitTokens.get(0).get(CoreAnnotations.TextAnnotation.class):null;\r\n                  //SUTime.Duration durationUnit = getDuration(durationUnitString);\r\n                  TimeExpression te = (durationUnitTokens != null)? durationUnitTokens.get(0).get(TimeExpression.Annotation.class):null;\r\n                  SUTime.Duration durationUnit = (SUTime.Duration) te.getTemporal();\r\n\r\n                  // TODO: Handle inexactness\r\n                  // Create duration range...\r\n                  SUTime.Duration durationStart = (durationStartVal != null)? durationUnit.multiplyBy(durationStartVal.intValue()):null;\r\n                  SUTime.Duration durationEnd = (durationEndVal != null)? durationUnit.multiplyBy(durationEndVal.intValue()):null;\r\n                  SUTime.Duration duration = durationStart;\r\n                  if (duration == null) {\r\n                    if (durationEnd != null) {\r\n                      duration = durationEnd;\r\n                    } else {\r\n                      duration = new SUTime.InexactDuration(durationUnit);\r\n                    }\r\n                  }\r\n                  else if (durationEnd != null) { duration = new SUTime.DurationRange(durationStart, durationEnd); }\r\n\r\n                  // Add begin and end times\r\n                  SUTime.Time beginTime = (in.size() > 3)? (SUTime.Time) in.get(3).get():null;\r\n                  SUTime.Time endTime = (in.size() > 4)? (SUTime.Time) in.get(4).get():null;\r\n                  SUTime.Temporal temporal = addEndPoints(duration, beginTime, endTime);\r\n                  if (temporal instanceof SUTime.Range) {\r\n                    return new Expressions.PrimitiveValue(\"RANGE\", temporal);\r\n                  } else {\r\n                    return new Expressions.PrimitiveValue(\"DURATION\", temporal);\r\n                  }\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n    env.bind(\"DayOfWeek\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"DayOfWeek\") {\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() != 1) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() == 1) {\r\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.DAY_OF_WEEK.name(),\r\n                          SUTime.StandardTemporalType.DAY_OF_WEEK.createTemporal(((Number) in.get(0).get()).intValue()));\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n    env.bind(\"MonthOfYear\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"MonthOfYear\") {\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() != 1) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() == 1) {\r\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.MONTH_OF_YEAR.name(),\r\n                          SUTime.StandardTemporalType.MONTH_OF_YEAR.createTemporal(((Number) in.get(0).get()).intValue()));\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n    env.bind(\"MakePeriodicTemporalSet\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"MakePeriodicTemporalSet\") {\r\n              // First argument is the temporal acting as the base of the periodic set\r\n              // Second argument is the quantifier (string)\r\n              // Third argument is the multiple (how much to scale the natural period)\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() < 3) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null ||\r\n                        (!(in.get(0).get() instanceof SUTime.Temporal) && !(in.get(0).get() instanceof TimeExpression))) {\r\n                  return false;\r\n                }\r\n                if (in.get(1) == null ||\r\n                        (!(in.get(1).get() instanceof String) && !(in.get(1).get() instanceof List))) {\r\n                  return false;\r\n                }\r\n                if (in.get(2) == null || !(in.get(2).get() instanceof Number)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() >= 1) {\r\n                  SUTime.Temporal temporal = null;\r\n                  Object t = in.get(0).get();\r\n                  if (t instanceof SUTime.Temporal) {\r\n                    temporal = (SUTime.Temporal) in.get(0).get();\r\n                  } else if (t instanceof TimeExpression) {\r\n                    temporal = ((TimeExpression) t).getTemporal();\r\n                  } else {\r\n                    throw new IllegalArgumentException(\"Type mismatch on arg0: Cannot apply \" + this + \" to \" + in);\r\n                  }\r\n                  String quant = null;\r\n                  int scale = 1;\r\n                  if (in.size() >= 2 && in.get(1) != null) {\r\n                    Object arg1 = in.get(1).get();\r\n                    if (arg1 instanceof String) {\r\n                      quant = (String) arg1;\r\n                    } else if (arg1 instanceof List) {\r\n                      List<CoreMap> cms = (List<CoreMap>) arg1;\r\n                      quant = ChunkAnnotationUtils.getTokenText(cms, CoreAnnotations.TextAnnotation.class);\r\n                      if (quant != null) {\r\n                        quant = quant.toLowerCase();\r\n                      }\r\n                    } else {\r\n                      throw new IllegalArgumentException(\"Type mismatch on arg1: Cannot apply \" + this + \" to \" + in);\r\n                    }\r\n                  }\r\n                  if (in.size() >= 3 && in.get(2) != null) {\r\n                    Number arg2 = (Number) in.get(2).get();\r\n                    if (arg2 != null) {\r\n                      scale = arg2.intValue();\r\n                    }\r\n                  }\r\n                  SUTime.Duration period = temporal.getPeriod();\r\n                  if (period != null & scale != 1) {\r\n                    period = period.multiplyBy(scale);\r\n                  }\r\n                  return new Expressions.PrimitiveValue(\"PeriodicTemporalSet\",\r\n                          new SUTime.PeriodicTemporalSet(temporal,period,quant,null/*\"P1X\"*/));\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n\r\n    env.bind(\"TemporalCompose\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"TemporalCompose\") {\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() < 1) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null || !(in.get(0).get() instanceof SUTime.TemporalOp)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() > 1) {\r\n                  SUTime.TemporalOp op = (SUTime.TemporalOp) in.get(0).get();\r\n                  boolean allTemporalArgs = true;\r\n                  Object[] args = new Object[in.size()-1];\r\n                  for (int i = 0; i < args.length; i++) {\r\n                    Value v = in.get(i+1);\r\n                    if (v != null) {\r\n                      args[i] = v.get();\r\n                      if (args[i] instanceof MatchedExpression) {\r\n                        Value v2 = ((MatchedExpression) args[i]).getValue();\r\n                        args[i] = (v2 != null)? v2.get():null;\r\n                      }\r\n                      if (args[i] != null && !(args[i] instanceof SUTime.Temporal)) {\r\n                        allTemporalArgs = false;\r\n                      }\r\n                    }\r\n                  }\r\n                  if (allTemporalArgs) {\r\n                    SUTime.Temporal[] temporalArgs = new SUTime.Temporal[args.length];\r\n                    for (int i = 0; i < args.length; i++) {\r\n                      temporalArgs[i] = (SUTime.Temporal) args[i];\r\n                    }\r\n                    return new Expressions.PrimitiveValue(null, op.apply(temporalArgs));\r\n                  } else {\r\n                    return new Expressions.PrimitiveValue(null, op.apply(args));\r\n                  }\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n  }","id":101108,"modified_method":"private void initEnv()\n  {\n    env = TokenSequencePattern.getNewEnv();\n    env.setDefaultResultsAnnotationExtractor(TimeExpression.TimeExpressionConverter);\n    env.setDefaultTokensAnnotationKey(CoreAnnotations.NumerizedTokensAnnotation.class);\n    env.setDefaultResultAnnotationKey(TimeExpression.Annotation.class);\n    env.setDefaultNestedResultsAnnotationKey(TimeExpression.ChildrenAnnotation.class);\n    env.setDefaultTokensAggregators(CoreMapAttributeAggregator.DEFAULT_NUMERIC_TOKENS_AGGREGATORS);\n\n    env.bind(\"nested\", TimeExpression.ChildrenAnnotation.class);\n    env.bind(\"time\", new TimeFormatter.TimePatternExtractRuleCreator());\n    // Do case insensitive matching\n    env.setDefaultStringPatternFlags(Pattern.CASE_INSENSITIVE);\n\n    env.bind(\"options\", options);\n    env.bind(\"TIME_REF\", SUTime.TIME_REF);\n    env.bind(\"TIME_REF_UNKNOWN\", SUTime.TIME_REF_UNKNOWN);\n    env.bind(\"TIME_UNKNOWN\", SUTime.TIME_UNKNOWN);\n    env.bind(\"TIME_NONE\", SUTime.TIME_NONE);\n    env.bind(\"ERA_AD\", SUTime.ERA_AD);\n    env.bind(\"ERA_BC\", SUTime.ERA_BC);\n    env.bind(\"ERA_UNKNOWN\", SUTime.ERA_UNKNOWN);\n    env.bind(\"HALFDAY_AM\", SUTime.HALFDAY_AM);\n    env.bind(\"HALFDAY_PM\", SUTime.HALFDAY_PM);\n    env.bind(\"HALFDAY_UNKNOWN\", SUTime.HALFDAY_UNKNOWN);\n    env.bind(\"RESOLVE_TO_THIS\", SUTime.RESOLVE_TO_THIS);\n    env.bind(\"RESOLVE_TO_PAST\", SUTime.RESOLVE_TO_PAST);\n    env.bind(\"RESOLVE_TO_FUTURE\", SUTime.RESOLVE_TO_FUTURE);\n    env.bind(\"RESOLVE_TO_CLOSEST\", SUTime.RESOLVE_TO_CLOSEST);\n\n    env.bind(\"numcomptype\", CoreAnnotations.NumericCompositeTypeAnnotation.class);\n    env.bind(\"numcompvalue\", CoreAnnotations.NumericCompositeValueAnnotation.class);\n\n    env.bind(\"temporal\", TimeExpression.Annotation.class);\n//    env.bind(\"tags\", SequenceMatchRules.Tags.TagsAnnotation.class);\n    env.bind(\"::IS_TIMEX_DATE\", new TimexTypeMatchNodePattern(SUTime.TimexType.DATE));\n    env.bind(\"::IS_TIMEX_DURATION\", new TimexTypeMatchNodePattern(SUTime.TimexType.DURATION));\n    env.bind(\"::IS_TIMEX_TIME\", new TimexTypeMatchNodePattern(SUTime.TimexType.TIME));\n    env.bind(\"::IS_TIMEX_SET\", new TimexTypeMatchNodePattern(SUTime.TimexType.SET));\n    env.bind(\"::IS_TIME_UNIT\", new MatchedExpressionValueTypeMatchNodePattern(\"TIMEUNIT\"));\n    env.bind(\"::MONTH\", new MatchedExpressionValueTypeMatchNodePattern(\"MONTH_OF_YEAR\"));\n    env.bind(\"::DAYOFWEEK\", new MatchedExpressionValueTypeMatchNodePattern(\"DAY_OF_WEEK\"));\n\n    // BINDINGS for parsing from file!!!!!!!\n    for (SUTime.TemporalOp t:SUTime.TemporalOp.values()) {\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.TemporalOp>(\"TemporalOp\", t));\n    }\n    for (SUTime.TimeUnit t: SUTime.TimeUnit.values()) {\n      if (!t.equals(SUTime.TimeUnit.UNKNOWN)) {\n        //env.bind(t.name(), new SequenceMatchRules.PrimitiveValue<SUTime.Temporal>(\"DURATION\", t.getDuration(), \"TIMEUNIT\"));\n        env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.Temporal>(\"TIMEUNIT\", t.getDuration()));\n      }\n    }\n    for (SUTime.StandardTemporalType t: SUTime.StandardTemporalType.values()) {\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.StandardTemporalType>(\"TemporalType\", t));\n    }\n    env.bind(\"Duration\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"Duration\") {\n              private SUTime.Temporal addEndPoints(SUTime.Duration d, SUTime.Time beginTime, SUTime.Time endTime)\n              {\n                SUTime.Temporal t = d;\n                if (d != null && (beginTime != null || endTime != null)) {\n                  SUTime.Time b = beginTime;\n                  SUTime.Time e = endTime;\n                  // New so we get different time ids\n                  if (b == SUTime.TIME_REF_UNKNOWN) {\n                    b = new SUTime.RefTime(\"UNKNOWN\");\n                  } else if (b == SUTime.TIME_UNKNOWN) {\n                    b = new SUTime.SimpleTime(\"UNKNOWN\");\n                  }\n                  if (e == SUTime.TIME_REF_UNKNOWN) {\n                    e = new SUTime.RefTime(\"UNKNOWN\");\n                  } else if (e == SUTime.TIME_UNKNOWN) {\n                    e = new SUTime.SimpleTime(\"UNKNOWN\");\n                  }\n                  t = new SUTime.Range(b,e,d);\n                }\n                return t;\n              }\n\n              public boolean checkArgs(List<Value> in) {\n                // TODO: Check args\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() == 2) {\n                  SUTime.Duration d = (SUTime.Duration) in.get(0).get();\n                  if (in.get(1).get() instanceof Number) {\n                    int m = ((Number) in.get(1).get()).intValue();\n                    return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(m));\n                  } else if (in.get(1).get() instanceof String){\n                    Number n = Integer.parseInt((String) in.get(1).get());\n                    if (n != null) {\n                      return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(n.intValue()));\n                    } else {\n                      return null;\n                    }\n                  } else {\n                    throw new IllegalArgumentException(\"Invalid arguments to \" + name);\n                  }\n                } else if (in.size() == 5 || in.size() == 3) {\n                  // TODO: Handle Strings...\n                  List<? extends CoreMap> durationStartTokens = (List<? extends CoreMap>) in.get(0).get();\n                  Number durationStartVal = (durationStartTokens != null)? durationStartTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\n                  List<? extends CoreMap> durationEndTokens = (List<? extends CoreMap>) in.get(1).get();\n                  Number durationEndVal = (durationEndTokens != null)? durationEndTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\n                  // TODO: This should already be in durations....\n                  List<? extends CoreMap> durationUnitTokens = (List<? extends CoreMap>) in.get(2).get();\n                  //String durationUnitString = (durationUnitTokens != null)? durationUnitTokens.get(0).get(CoreAnnotations.TextAnnotation.class):null;\n                  //SUTime.Duration durationUnit = getDuration(durationUnitString);\n                  TimeExpression te = (durationUnitTokens != null)? durationUnitTokens.get(0).get(TimeExpression.Annotation.class):null;\n                  SUTime.Duration durationUnit = (SUTime.Duration) te.getTemporal();\n\n                  // TODO: Handle inexactness\n                  // Create duration range...\n                  SUTime.Duration durationStart = (durationStartVal != null)? durationUnit.multiplyBy(durationStartVal.intValue()):null;\n                  SUTime.Duration durationEnd = (durationEndVal != null)? durationUnit.multiplyBy(durationEndVal.intValue()):null;\n                  SUTime.Duration duration = durationStart;\n                  if (duration == null) {\n                    if (durationEnd != null) {\n                      duration = durationEnd;\n                    } else {\n                      duration = new SUTime.InexactDuration(durationUnit);\n                    }\n                  }\n                  else if (durationEnd != null) { duration = new SUTime.DurationRange(durationStart, durationEnd); }\n\n                  // Add begin and end times\n                  SUTime.Time beginTime = (in.size() > 3)? (SUTime.Time) in.get(3).get():null;\n                  SUTime.Time endTime = (in.size() > 4)? (SUTime.Time) in.get(4).get():null;\n                  SUTime.Temporal temporal = addEndPoints(duration, beginTime, endTime);\n                  if (temporal instanceof SUTime.Range) {\n                    return new Expressions.PrimitiveValue(\"RANGE\", temporal);\n                  } else {\n                    return new Expressions.PrimitiveValue(\"DURATION\", temporal);\n                  }\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n    env.bind(\"DayOfWeek\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"DayOfWeek\") {\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() != 1) {\n                  return false;\n                }\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() == 1) {\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.DAY_OF_WEEK.name(),\n                          SUTime.StandardTemporalType.DAY_OF_WEEK.createTemporal(((Number) in.get(0).get()).intValue()));\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n    env.bind(\"MonthOfYear\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"MonthOfYear\") {\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() != 1) {\n                  return false;\n                }\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() == 1) {\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.MONTH_OF_YEAR.name(),\n                          SUTime.StandardTemporalType.MONTH_OF_YEAR.createTemporal(((Number) in.get(0).get()).intValue()));\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n    env.bind(\"MakePeriodicTemporalSet\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"MakePeriodicTemporalSet\") {\n              // First argument is the temporal acting as the base of the periodic set\n              // Second argument is the quantifier (string)\n              // Third argument is the multiple (how much to scale the natural period)\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() < 3) {\n                  return false;\n                }\n                if (in.get(0) == null ||\n                        (!(in.get(0).get() instanceof SUTime.Temporal) && !(in.get(0).get() instanceof TimeExpression))) {\n                  return false;\n                }\n                if (in.get(1) == null ||\n                        (!(in.get(1).get() instanceof String) && !(in.get(1).get() instanceof List))) {\n                  return false;\n                }\n                if (in.get(2) == null || !(in.get(2).get() instanceof Number)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() >= 1) {\n                  SUTime.Temporal temporal = null;\n                  Object t = in.get(0).get();\n                  if (t instanceof SUTime.Temporal) {\n                    temporal = (SUTime.Temporal) in.get(0).get();\n                  } else if (t instanceof TimeExpression) {\n                    temporal = ((TimeExpression) t).getTemporal();\n                  } else {\n                    throw new IllegalArgumentException(\"Type mismatch on arg0: Cannot apply \" + this + \" to \" + in);\n                  }\n                  String quant = null;\n                  int scale = 1;\n                  if (in.size() >= 2 && in.get(1) != null) {\n                    Object arg1 = in.get(1).get();\n                    if (arg1 instanceof String) {\n                      quant = (String) arg1;\n                    } else if (arg1 instanceof List) {\n                      List<CoreMap> cms = (List<CoreMap>) arg1;\n                      quant = ChunkAnnotationUtils.getTokenText(cms, CoreAnnotations.TextAnnotation.class);\n                      if (quant != null) {\n                        quant = quant.toLowerCase();\n                      }\n                    } else {\n                      throw new IllegalArgumentException(\"Type mismatch on arg1: Cannot apply \" + this + \" to \" + in);\n                    }\n                  }\n                  if (in.size() >= 3 && in.get(2) != null) {\n                    Number arg2 = (Number) in.get(2).get();\n                    if (arg2 != null) {\n                      scale = arg2.intValue();\n                    }\n                  }\n                  SUTime.Duration period = temporal.getPeriod();\n                  if (period != null && scale != 1) {\n                    period = period.multiplyBy(scale);\n                  }\n                  return new Expressions.PrimitiveValue(\"PeriodicTemporalSet\",\n                          new SUTime.PeriodicTemporalSet(temporal,period,quant,null/*\"P1X\"*/));\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n\n    env.bind(\"TemporalCompose\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"TemporalCompose\") {\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() < 1) {\n                  return false;\n                }\n                if (in.get(0) == null || !(in.get(0).get() instanceof SUTime.TemporalOp)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() > 1) {\n                  SUTime.TemporalOp op = (SUTime.TemporalOp) in.get(0).get();\n                  boolean allTemporalArgs = true;\n                  Object[] args = new Object[in.size()-1];\n                  for (int i = 0; i < args.length; i++) {\n                    Value v = in.get(i+1);\n                    if (v != null) {\n                      args[i] = v.get();\n                      if (args[i] instanceof MatchedExpression) {\n                        Value v2 = ((MatchedExpression) args[i]).getValue();\n                        args[i] = (v2 != null)? v2.get():null;\n                      }\n                      if (args[i] != null && !(args[i] instanceof SUTime.Temporal)) {\n                        allTemporalArgs = false;\n                      }\n                    }\n                  }\n                  if (allTemporalArgs) {\n                    SUTime.Temporal[] temporalArgs = new SUTime.Temporal[args.length];\n                    for (int i = 0; i < args.length; i++) {\n                      temporalArgs[i] = (SUTime.Temporal) args[i];\n                    }\n                    return new Expressions.PrimitiveValue(null, op.apply(temporalArgs));\n                  } else {\n                    return new Expressions.PrimitiveValue(null, op.apply(args));\n                  }\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n  }","commit_id":"10dc0a06af8226fb4ed7a9601c239c71f9477cb9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Return the TIMEX string for the time given\n   */\n  public static String timexTimeValue(ReadableDateTime time){\n    return new StringBuilder()\n        .append(time.getYear()).append(\"-\")                    //year\n        .append(zeroPad(time.getMonthOfYear(),2)).append(\"-\")  //month\n        .append(zeroPad(time.getDayOfMonth(),2)).append(\"T\")   //day\n        .append(zeroPad(time.getHourOfDay(),2)).append(\":\")    //hour\n        .append(zeroPad(time.getMinuteOfHour(),2))             //minute\n        .toString();\n  }","id":101109,"modified_method":"/**\n   * Return the TIMEX string for the time given\n   */\n  public static String timexTimeValue(ReadableDateTime time){\n    return String.valueOf(time.getYear()) + '-' + zeroPad(time.getMonthOfYear(), 2) + '-' + zeroPad(time.getDayOfMonth(), 2) + 'T' + zeroPad(time.getHourOfDay(), 2) + ':' + zeroPad(time.getMinuteOfHour(), 2);\n  }","commit_id":"10dc0a06af8226fb4ed7a9601c239c71f9477cb9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static Object standardDeviation(List<Integer> branchingFactors, double mean) {\n    double variance = 0.0;\n    for (int i : branchingFactors) {\n      variance += (i-mean)*(i-mean);\n    }\n    return Math.sqrt(variance / (branchingFactors.size()-1));\n  }","id":101110,"modified_method":"private static double standardDeviation(List<Integer> branchingFactors, double mean) {\n    double variance = 0.0;\n    for (int i : branchingFactors) {\n      variance += (i-mean)*(i-mean);\n    }\n    return Math.sqrt(variance / (branchingFactors.size()-1));\n  }","commit_id":"10dc0a06af8226fb4ed7a9601c239c71f9477cb9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void initEnv()\r\n  {\r\n    env = TokenSequencePattern.getNewEnv();\r\n    env.setDefaultResultsAnnotationExtractor(TimeExpression.TimeExpressionConverter);\r\n    env.setDefaultTokensAnnotationKey(CoreAnnotations.NumerizedTokensAnnotation.class);\r\n    env.setDefaultResultAnnotationKey(TimeExpression.Annotation.class);\r\n    env.setDefaultNestedResultsAnnotationKey(TimeExpression.ChildrenAnnotation.class);\r\n    env.setDefaultTokensAggregators(CoreMapAttributeAggregator.DEFAULT_NUMERIC_TOKENS_AGGREGATORS);\r\n\r\n    env.bind(\"nested\", TimeExpression.ChildrenAnnotation.class);\r\n    env.bind(\"time\", new TimeFormatter.TimePatternExtractRuleCreator());\r\n    // Do case insensitive matching\r\n    env.setDefaultStringPatternFlags(Pattern.CASE_INSENSITIVE);\r\n\r\n    env.bind(\"options\", options);\r\n    env.bind(\"TIME_REF\", SUTime.TIME_REF);\r\n    env.bind(\"TIME_REF_UNKNOWN\", SUTime.TIME_REF_UNKNOWN);\r\n    env.bind(\"TIME_UNKNOWN\", SUTime.TIME_UNKNOWN);\r\n    env.bind(\"TIME_NONE\", SUTime.TIME_NONE);\r\n    env.bind(\"ERA_AD\", SUTime.ERA_AD);\r\n    env.bind(\"ERA_BC\", SUTime.ERA_BC);\r\n    env.bind(\"ERA_UNKNOWN\", SUTime.ERA_UNKNOWN);\r\n    env.bind(\"HALFDAY_AM\", SUTime.HALFDAY_AM);\r\n    env.bind(\"HALFDAY_PM\", SUTime.HALFDAY_PM);\r\n    env.bind(\"HALFDAY_UNKNOWN\", SUTime.HALFDAY_UNKNOWN);\r\n    env.bind(\"RESOLVE_TO_THIS\", SUTime.RESOLVE_TO_THIS);\r\n    env.bind(\"RESOLVE_TO_PAST\", SUTime.RESOLVE_TO_PAST);\r\n    env.bind(\"RESOLVE_TO_FUTURE\", SUTime.RESOLVE_TO_FUTURE);\r\n    env.bind(\"RESOLVE_TO_CLOSEST\", SUTime.RESOLVE_TO_CLOSEST);\r\n\r\n    env.bind(\"numcomptype\", CoreAnnotations.NumericCompositeTypeAnnotation.class);\r\n    env.bind(\"numcompvalue\", CoreAnnotations.NumericCompositeValueAnnotation.class);\r\n\r\n    env.bind(\"temporal\", TimeExpression.Annotation.class);\r\n//    env.bind(\"tags\", SequenceMatchRules.Tags.TagsAnnotation.class);\r\n    env.bind(\"::IS_TIMEX_DATE\", new TimexTypeMatchNodePattern(SUTime.TimexType.DATE));\r\n    env.bind(\"::IS_TIMEX_DURATION\", new TimexTypeMatchNodePattern(SUTime.TimexType.DURATION));\r\n    env.bind(\"::IS_TIMEX_TIME\", new TimexTypeMatchNodePattern(SUTime.TimexType.TIME));\r\n    env.bind(\"::IS_TIMEX_SET\", new TimexTypeMatchNodePattern(SUTime.TimexType.SET));\r\n    env.bind(\"::IS_TIME_UNIT\", new MatchedExpressionValueTypeMatchNodePattern(\"TIMEUNIT\"));\r\n    env.bind(\"::MONTH\", new MatchedExpressionValueTypeMatchNodePattern(\"MONTH_OF_YEAR\"));\r\n    env.bind(\"::DAYOFWEEK\", new MatchedExpressionValueTypeMatchNodePattern(\"DAY_OF_WEEK\"));\r\n\r\n    // BINDINGS for parsing from file!!!!!!!\r\n    for (SUTime.TemporalOp t:SUTime.TemporalOp.values()) {\r\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.TemporalOp>(\"TemporalOp\", t));\r\n    }\r\n    for (SUTime.TimeUnit t: SUTime.TimeUnit.values()) {\r\n      if (!t.equals(SUTime.TimeUnit.UNKNOWN)) {\r\n        //env.bind(t.name(), new SequenceMatchRules.PrimitiveValue<SUTime.Temporal>(\"DURATION\", t.getDuration(), \"TIMEUNIT\"));\r\n        env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.Temporal>(\"TIMEUNIT\", t.getDuration()));\r\n      }\r\n    }\r\n    for (SUTime.StandardTemporalType t: SUTime.StandardTemporalType.values()) {\r\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.StandardTemporalType>(\"TemporalType\", t));\r\n    }\r\n    env.bind(\"Duration\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"Duration\") {\r\n              private SUTime.Temporal addEndPoints(SUTime.Duration d, SUTime.Time beginTime, SUTime.Time endTime)\r\n              {\r\n                SUTime.Temporal t = d;\r\n                if (d != null && (beginTime != null || endTime != null)) {\r\n                  SUTime.Time b = beginTime;\r\n                  SUTime.Time e = endTime;\r\n                  // New so we get different time ids\r\n                  if (b == SUTime.TIME_REF_UNKNOWN) {\r\n                    b = new SUTime.RefTime(\"UNKNOWN\");\r\n                  } else if (b == SUTime.TIME_UNKNOWN) {\r\n                    b = new SUTime.SimpleTime(\"UNKNOWN\");\r\n                  }\r\n                  if (e == SUTime.TIME_REF_UNKNOWN) {\r\n                    e = new SUTime.RefTime(\"UNKNOWN\");\r\n                  } else if (e == SUTime.TIME_UNKNOWN) {\r\n                    e = new SUTime.SimpleTime(\"UNKNOWN\");\r\n                  }\r\n                  t = new SUTime.Range(b,e,d);\r\n                }\r\n                return t;\r\n              }\r\n\r\n              public boolean checkArgs(List<Value> in) {\r\n                // TODO: Check args\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() == 2) {\r\n                  SUTime.Duration d = (SUTime.Duration) in.get(0).get();\r\n                  if (in.get(1).get() instanceof Number) {\r\n                    int m = ((Number) in.get(1).get()).intValue();\r\n                    return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(m));\r\n                  } else if (in.get(1).get() instanceof String){\r\n                    Number n = Integer.parseInt((String) in.get(1).get());\r\n                    if (n != null) {\r\n                      return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(n.intValue()));\r\n                    } else {\r\n                      return null;\r\n                    }\r\n                  } else {\r\n                    throw new IllegalArgumentException(\"Invalid arguments to \" + name);\r\n                  }\r\n                } else if (in.size() == 5 || in.size() == 3) {\r\n                  // TODO: Handle Strings...\r\n                  List<? extends CoreMap> durationStartTokens = (List<? extends CoreMap>) in.get(0).get();\r\n                  Number durationStartVal = (durationStartTokens != null)? durationStartTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\r\n                  List<? extends CoreMap> durationEndTokens = (List<? extends CoreMap>) in.get(1).get();\r\n                  Number durationEndVal = (durationEndTokens != null)? durationEndTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\r\n                  // TODO: This should already be in durations....\r\n                  List<? extends CoreMap> durationUnitTokens = (List<? extends CoreMap>) in.get(2).get();\r\n                  //String durationUnitString = (durationUnitTokens != null)? durationUnitTokens.get(0).get(CoreAnnotations.TextAnnotation.class):null;\r\n                  //SUTime.Duration durationUnit = getDuration(durationUnitString);\r\n                  TimeExpression te = (durationUnitTokens != null)? durationUnitTokens.get(0).get(TimeExpression.Annotation.class):null;\r\n                  SUTime.Duration durationUnit = (SUTime.Duration) te.getTemporal();\r\n\r\n                  // TODO: Handle inexactness\r\n                  // Create duration range...\r\n                  SUTime.Duration durationStart = (durationStartVal != null)? durationUnit.multiplyBy(durationStartVal.intValue()):null;\r\n                  SUTime.Duration durationEnd = (durationEndVal != null)? durationUnit.multiplyBy(durationEndVal.intValue()):null;\r\n                  SUTime.Duration duration = durationStart;\r\n                  if (duration == null) {\r\n                    if (durationEnd != null) {\r\n                      duration = durationEnd;\r\n                    } else {\r\n                      duration = new SUTime.InexactDuration(durationUnit);\r\n                    }\r\n                  }\r\n                  else if (durationEnd != null) { duration = new SUTime.DurationRange(durationStart, durationEnd); }\r\n\r\n                  // Add begin and end times\r\n                  SUTime.Time beginTime = (in.size() > 3)? (SUTime.Time) in.get(3).get():null;\r\n                  SUTime.Time endTime = (in.size() > 4)? (SUTime.Time) in.get(4).get():null;\r\n                  SUTime.Temporal temporal = addEndPoints(duration, beginTime, endTime);\r\n                  if (temporal instanceof SUTime.Range) {\r\n                    return new Expressions.PrimitiveValue(\"RANGE\", temporal);\r\n                  } else {\r\n                    return new Expressions.PrimitiveValue(\"DURATION\", temporal);\r\n                  }\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n    env.bind(\"DayOfWeek\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"DayOfWeek\") {\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() != 1) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() == 1) {\r\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.DAY_OF_WEEK.name(),\r\n                          SUTime.StandardTemporalType.DAY_OF_WEEK.createTemporal(((Number) in.get(0).get()).intValue()));\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n    env.bind(\"MonthOfYear\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"MonthOfYear\") {\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() != 1) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() == 1) {\r\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.MONTH_OF_YEAR.name(),\r\n                          SUTime.StandardTemporalType.MONTH_OF_YEAR.createTemporal(((Number) in.get(0).get()).intValue()));\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n    env.bind(\"MakePeriodicTemporalSet\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"MakePeriodicTemporalSet\") {\r\n              // First argument is the temporal acting as the base of the periodic set\r\n              // Second argument is the quantifier (string)\r\n              // Third argument is the multiple (how much to scale the natural period)\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() < 3) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null ||\r\n                        (!(in.get(0).get() instanceof SUTime.Temporal) && !(in.get(0).get() instanceof TimeExpression))) {\r\n                  return false;\r\n                }\r\n                if (in.get(1) == null ||\r\n                        (!(in.get(1).get() instanceof String) && !(in.get(1).get() instanceof List))) {\r\n                  return false;\r\n                }\r\n                if (in.get(2) == null || !(in.get(2).get() instanceof Number)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() >= 1) {\r\n                  SUTime.Temporal temporal = null;\r\n                  Object t = in.get(0).get();\r\n                  if (t instanceof SUTime.Temporal) {\r\n                    temporal = (SUTime.Temporal) in.get(0).get();\r\n                  } else if (t instanceof TimeExpression) {\r\n                    temporal = ((TimeExpression) t).getTemporal();\r\n                  } else {\r\n                    throw new IllegalArgumentException(\"Type mismatch on arg0: Cannot apply \" + this + \" to \" + in);\r\n                  }\r\n                  String quant = null;\r\n                  int scale = 1;\r\n                  if (in.size() >= 2 && in.get(1) != null) {\r\n                    Object arg1 = in.get(1).get();\r\n                    if (arg1 instanceof String) {\r\n                      quant = (String) arg1;\r\n                    } else if (arg1 instanceof List) {\r\n                      List<CoreMap> cms = (List<CoreMap>) arg1;\r\n                      quant = ChunkAnnotationUtils.getTokenText(cms, CoreAnnotations.TextAnnotation.class);\r\n                      if (quant != null) {\r\n                        quant = quant.toLowerCase();\r\n                      }\r\n                    } else {\r\n                      throw new IllegalArgumentException(\"Type mismatch on arg1: Cannot apply \" + this + \" to \" + in);\r\n                    }\r\n                  }\r\n                  if (in.size() >= 3 && in.get(2) != null) {\r\n                    Number arg2 = (Number) in.get(2).get();\r\n                    if (arg2 != null) {\r\n                      scale = arg2.intValue();\r\n                    }\r\n                  }\r\n                  SUTime.Duration period = temporal.getPeriod();\r\n                  if (period != null & scale != 1) {\r\n                    period = period.multiplyBy(scale);\r\n                  }\r\n                  return new Expressions.PrimitiveValue(\"PeriodicTemporalSet\",\r\n                          new SUTime.PeriodicTemporalSet(temporal,period,quant,null/*\"P1X\"*/));\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n\r\n    env.bind(\"TemporalCompose\", new Expressions.PrimitiveValue<ValueFunction>(\r\n            Expressions.TYPE_FUNCTION,\r\n            new ValueFunctions.NamedValueFunction(\"TemporalCompose\") {\r\n              public boolean checkArgs(List<Value> in) {\r\n                if (in.size() < 1) {\r\n                  return false;\r\n                }\r\n                if (in.get(0) == null || !(in.get(0).get() instanceof SUTime.TemporalOp)) {\r\n                  return false;\r\n                }\r\n                return true;\r\n              }\r\n              public Value apply(Env env, List<Value> in) {\r\n                if (in.size() > 1) {\r\n                  SUTime.TemporalOp op = (SUTime.TemporalOp) in.get(0).get();\r\n                  boolean allTemporalArgs = true;\r\n                  Object[] args = new Object[in.size()-1];\r\n                  for (int i = 0; i < args.length; i++) {\r\n                    Value v = in.get(i+1);\r\n                    if (v != null) {\r\n                      args[i] = v.get();\r\n                      if (args[i] instanceof MatchedExpression) {\r\n                        Value v2 = ((MatchedExpression) args[i]).getValue();\r\n                        args[i] = (v2 != null)? v2.get():null;\r\n                      }\r\n                      if (args[i] != null && !(args[i] instanceof SUTime.Temporal)) {\r\n                        allTemporalArgs = false;\r\n                      }\r\n                    }\r\n                  }\r\n                  if (allTemporalArgs) {\r\n                    SUTime.Temporal[] temporalArgs = new SUTime.Temporal[args.length];\r\n                    for (int i = 0; i < args.length; i++) {\r\n                      temporalArgs[i] = (SUTime.Temporal) args[i];\r\n                    }\r\n                    return new Expressions.PrimitiveValue(null, op.apply(temporalArgs));\r\n                  } else {\r\n                    return new Expressions.PrimitiveValue(null, op.apply(args));\r\n                  }\r\n                } else {\r\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\r\n                }\r\n              }\r\n            }\r\n    ));\r\n  }","id":101111,"modified_method":"private void initEnv()\n  {\n    env = TokenSequencePattern.getNewEnv();\n    env.setDefaultResultsAnnotationExtractor(TimeExpression.TimeExpressionConverter);\n    env.setDefaultTokensAnnotationKey(CoreAnnotations.NumerizedTokensAnnotation.class);\n    env.setDefaultResultAnnotationKey(TimeExpression.Annotation.class);\n    env.setDefaultNestedResultsAnnotationKey(TimeExpression.ChildrenAnnotation.class);\n    env.setDefaultTokensAggregators(CoreMapAttributeAggregator.DEFAULT_NUMERIC_TOKENS_AGGREGATORS);\n\n    env.bind(\"nested\", TimeExpression.ChildrenAnnotation.class);\n    env.bind(\"time\", new TimeFormatter.TimePatternExtractRuleCreator());\n    // Do case insensitive matching\n    env.setDefaultStringPatternFlags(Pattern.CASE_INSENSITIVE);\n\n    env.bind(\"options\", options);\n    env.bind(\"TIME_REF\", SUTime.TIME_REF);\n    env.bind(\"TIME_REF_UNKNOWN\", SUTime.TIME_REF_UNKNOWN);\n    env.bind(\"TIME_UNKNOWN\", SUTime.TIME_UNKNOWN);\n    env.bind(\"TIME_NONE\", SUTime.TIME_NONE);\n    env.bind(\"ERA_AD\", SUTime.ERA_AD);\n    env.bind(\"ERA_BC\", SUTime.ERA_BC);\n    env.bind(\"ERA_UNKNOWN\", SUTime.ERA_UNKNOWN);\n    env.bind(\"HALFDAY_AM\", SUTime.HALFDAY_AM);\n    env.bind(\"HALFDAY_PM\", SUTime.HALFDAY_PM);\n    env.bind(\"HALFDAY_UNKNOWN\", SUTime.HALFDAY_UNKNOWN);\n    env.bind(\"RESOLVE_TO_THIS\", SUTime.RESOLVE_TO_THIS);\n    env.bind(\"RESOLVE_TO_PAST\", SUTime.RESOLVE_TO_PAST);\n    env.bind(\"RESOLVE_TO_FUTURE\", SUTime.RESOLVE_TO_FUTURE);\n    env.bind(\"RESOLVE_TO_CLOSEST\", SUTime.RESOLVE_TO_CLOSEST);\n\n    env.bind(\"numcomptype\", CoreAnnotations.NumericCompositeTypeAnnotation.class);\n    env.bind(\"numcompvalue\", CoreAnnotations.NumericCompositeValueAnnotation.class);\n\n    env.bind(\"temporal\", TimeExpression.Annotation.class);\n//    env.bind(\"tags\", SequenceMatchRules.Tags.TagsAnnotation.class);\n    env.bind(\"::IS_TIMEX_DATE\", new TimexTypeMatchNodePattern(SUTime.TimexType.DATE));\n    env.bind(\"::IS_TIMEX_DURATION\", new TimexTypeMatchNodePattern(SUTime.TimexType.DURATION));\n    env.bind(\"::IS_TIMEX_TIME\", new TimexTypeMatchNodePattern(SUTime.TimexType.TIME));\n    env.bind(\"::IS_TIMEX_SET\", new TimexTypeMatchNodePattern(SUTime.TimexType.SET));\n    env.bind(\"::IS_TIME_UNIT\", new MatchedExpressionValueTypeMatchNodePattern(\"TIMEUNIT\"));\n    env.bind(\"::MONTH\", new MatchedExpressionValueTypeMatchNodePattern(\"MONTH_OF_YEAR\"));\n    env.bind(\"::DAYOFWEEK\", new MatchedExpressionValueTypeMatchNodePattern(\"DAY_OF_WEEK\"));\n\n    // BINDINGS for parsing from file!!!!!!!\n    for (SUTime.TemporalOp t:SUTime.TemporalOp.values()) {\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.TemporalOp>(\"TemporalOp\", t));\n    }\n    for (SUTime.TimeUnit t: SUTime.TimeUnit.values()) {\n      if (!t.equals(SUTime.TimeUnit.UNKNOWN)) {\n        //env.bind(t.name(), new SequenceMatchRules.PrimitiveValue<SUTime.Temporal>(\"DURATION\", t.getDuration(), \"TIMEUNIT\"));\n        env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.Temporal>(\"TIMEUNIT\", t.getDuration()));\n      }\n    }\n    for (SUTime.StandardTemporalType t: SUTime.StandardTemporalType.values()) {\n      env.bind(t.name(), new Expressions.PrimitiveValue<SUTime.StandardTemporalType>(\"TemporalType\", t));\n    }\n    env.bind(\"Duration\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"Duration\") {\n              private SUTime.Temporal addEndPoints(SUTime.Duration d, SUTime.Time beginTime, SUTime.Time endTime)\n              {\n                SUTime.Temporal t = d;\n                if (d != null && (beginTime != null || endTime != null)) {\n                  SUTime.Time b = beginTime;\n                  SUTime.Time e = endTime;\n                  // New so we get different time ids\n                  if (b == SUTime.TIME_REF_UNKNOWN) {\n                    b = new SUTime.RefTime(\"UNKNOWN\");\n                  } else if (b == SUTime.TIME_UNKNOWN) {\n                    b = new SUTime.SimpleTime(\"UNKNOWN\");\n                  }\n                  if (e == SUTime.TIME_REF_UNKNOWN) {\n                    e = new SUTime.RefTime(\"UNKNOWN\");\n                  } else if (e == SUTime.TIME_UNKNOWN) {\n                    e = new SUTime.SimpleTime(\"UNKNOWN\");\n                  }\n                  t = new SUTime.Range(b,e,d);\n                }\n                return t;\n              }\n\n              public boolean checkArgs(List<Value> in) {\n                // TODO: Check args\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() == 2) {\n                  SUTime.Duration d = (SUTime.Duration) in.get(0).get();\n                  if (in.get(1).get() instanceof Number) {\n                    int m = ((Number) in.get(1).get()).intValue();\n                    return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(m));\n                  } else if (in.get(1).get() instanceof String){\n                    Number n = Integer.parseInt((String) in.get(1).get());\n                    if (n != null) {\n                      return new Expressions.PrimitiveValue(\"DURATION\", d.multiplyBy(n.intValue()));\n                    } else {\n                      return null;\n                    }\n                  } else {\n                    throw new IllegalArgumentException(\"Invalid arguments to \" + name);\n                  }\n                } else if (in.size() == 5 || in.size() == 3) {\n                  // TODO: Handle Strings...\n                  List<? extends CoreMap> durationStartTokens = (List<? extends CoreMap>) in.get(0).get();\n                  Number durationStartVal = (durationStartTokens != null)? durationStartTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\n                  List<? extends CoreMap> durationEndTokens = (List<? extends CoreMap>) in.get(1).get();\n                  Number durationEndVal = (durationEndTokens != null)? durationEndTokens.get(0).get(CoreAnnotations.NumericCompositeValueAnnotation.class):null;\n                  // TODO: This should already be in durations....\n                  List<? extends CoreMap> durationUnitTokens = (List<? extends CoreMap>) in.get(2).get();\n                  //String durationUnitString = (durationUnitTokens != null)? durationUnitTokens.get(0).get(CoreAnnotations.TextAnnotation.class):null;\n                  //SUTime.Duration durationUnit = getDuration(durationUnitString);\n                  TimeExpression te = (durationUnitTokens != null)? durationUnitTokens.get(0).get(TimeExpression.Annotation.class):null;\n                  SUTime.Duration durationUnit = (SUTime.Duration) te.getTemporal();\n\n                  // TODO: Handle inexactness\n                  // Create duration range...\n                  SUTime.Duration durationStart = (durationStartVal != null)? durationUnit.multiplyBy(durationStartVal.intValue()):null;\n                  SUTime.Duration durationEnd = (durationEndVal != null)? durationUnit.multiplyBy(durationEndVal.intValue()):null;\n                  SUTime.Duration duration = durationStart;\n                  if (duration == null) {\n                    if (durationEnd != null) {\n                      duration = durationEnd;\n                    } else {\n                      duration = new SUTime.InexactDuration(durationUnit);\n                    }\n                  }\n                  else if (durationEnd != null) { duration = new SUTime.DurationRange(durationStart, durationEnd); }\n\n                  // Add begin and end times\n                  SUTime.Time beginTime = (in.size() > 3)? (SUTime.Time) in.get(3).get():null;\n                  SUTime.Time endTime = (in.size() > 4)? (SUTime.Time) in.get(4).get():null;\n                  SUTime.Temporal temporal = addEndPoints(duration, beginTime, endTime);\n                  if (temporal instanceof SUTime.Range) {\n                    return new Expressions.PrimitiveValue(\"RANGE\", temporal);\n                  } else {\n                    return new Expressions.PrimitiveValue(\"DURATION\", temporal);\n                  }\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n    env.bind(\"DayOfWeek\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"DayOfWeek\") {\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() != 1) {\n                  return false;\n                }\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() == 1) {\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.DAY_OF_WEEK.name(),\n                          SUTime.StandardTemporalType.DAY_OF_WEEK.createTemporal(((Number) in.get(0).get()).intValue()));\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n    env.bind(\"MonthOfYear\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"MonthOfYear\") {\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() != 1) {\n                  return false;\n                }\n                if (in.get(0) == null || !(in.get(0).get() instanceof Number)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() == 1) {\n                  return new Expressions.PrimitiveValue(SUTime.StandardTemporalType.MONTH_OF_YEAR.name(),\n                          SUTime.StandardTemporalType.MONTH_OF_YEAR.createTemporal(((Number) in.get(0).get()).intValue()));\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n    env.bind(\"MakePeriodicTemporalSet\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"MakePeriodicTemporalSet\") {\n              // First argument is the temporal acting as the base of the periodic set\n              // Second argument is the quantifier (string)\n              // Third argument is the multiple (how much to scale the natural period)\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() < 3) {\n                  return false;\n                }\n                if (in.get(0) == null ||\n                        (!(in.get(0).get() instanceof SUTime.Temporal) && !(in.get(0).get() instanceof TimeExpression))) {\n                  return false;\n                }\n                if (in.get(1) == null ||\n                        (!(in.get(1).get() instanceof String) && !(in.get(1).get() instanceof List))) {\n                  return false;\n                }\n                if (in.get(2) == null || !(in.get(2).get() instanceof Number)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() >= 1) {\n                  SUTime.Temporal temporal = null;\n                  Object t = in.get(0).get();\n                  if (t instanceof SUTime.Temporal) {\n                    temporal = (SUTime.Temporal) in.get(0).get();\n                  } else if (t instanceof TimeExpression) {\n                    temporal = ((TimeExpression) t).getTemporal();\n                  } else {\n                    throw new IllegalArgumentException(\"Type mismatch on arg0: Cannot apply \" + this + \" to \" + in);\n                  }\n                  String quant = null;\n                  int scale = 1;\n                  if (in.size() >= 2 && in.get(1) != null) {\n                    Object arg1 = in.get(1).get();\n                    if (arg1 instanceof String) {\n                      quant = (String) arg1;\n                    } else if (arg1 instanceof List) {\n                      List<CoreMap> cms = (List<CoreMap>) arg1;\n                      quant = ChunkAnnotationUtils.getTokenText(cms, CoreAnnotations.TextAnnotation.class);\n                      if (quant != null) {\n                        quant = quant.toLowerCase();\n                      }\n                    } else {\n                      throw new IllegalArgumentException(\"Type mismatch on arg1: Cannot apply \" + this + \" to \" + in);\n                    }\n                  }\n                  if (in.size() >= 3 && in.get(2) != null) {\n                    Number arg2 = (Number) in.get(2).get();\n                    if (arg2 != null) {\n                      scale = arg2.intValue();\n                    }\n                  }\n                  SUTime.Duration period = temporal.getPeriod();\n                  if (period != null && scale != 1) {\n                    period = period.multiplyBy(scale);\n                  }\n                  return new Expressions.PrimitiveValue(\"PeriodicTemporalSet\",\n                          new SUTime.PeriodicTemporalSet(temporal,period,quant,null/*\"P1X\"*/));\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n\n    env.bind(\"TemporalCompose\", new Expressions.PrimitiveValue<ValueFunction>(\n            Expressions.TYPE_FUNCTION,\n            new ValueFunctions.NamedValueFunction(\"TemporalCompose\") {\n              public boolean checkArgs(List<Value> in) {\n                if (in.size() < 1) {\n                  return false;\n                }\n                if (in.get(0) == null || !(in.get(0).get() instanceof SUTime.TemporalOp)) {\n                  return false;\n                }\n                return true;\n              }\n              public Value apply(Env env, List<Value> in) {\n                if (in.size() > 1) {\n                  SUTime.TemporalOp op = (SUTime.TemporalOp) in.get(0).get();\n                  boolean allTemporalArgs = true;\n                  Object[] args = new Object[in.size()-1];\n                  for (int i = 0; i < args.length; i++) {\n                    Value v = in.get(i+1);\n                    if (v != null) {\n                      args[i] = v.get();\n                      if (args[i] instanceof MatchedExpression) {\n                        Value v2 = ((MatchedExpression) args[i]).getValue();\n                        args[i] = (v2 != null)? v2.get():null;\n                      }\n                      if (args[i] != null && !(args[i] instanceof SUTime.Temporal)) {\n                        allTemporalArgs = false;\n                      }\n                    }\n                  }\n                  if (allTemporalArgs) {\n                    SUTime.Temporal[] temporalArgs = new SUTime.Temporal[args.length];\n                    for (int i = 0; i < args.length; i++) {\n                      temporalArgs[i] = (SUTime.Temporal) args[i];\n                    }\n                    return new Expressions.PrimitiveValue(null, op.apply(temporalArgs));\n                  } else {\n                    return new Expressions.PrimitiveValue(null, op.apply(args));\n                  }\n                } else {\n                  throw new IllegalArgumentException(\"Invalid number of arguments to \" + name);\n                }\n              }\n            }\n    ));\n  }","commit_id":"9308ab94fe494751c6fd5bccc1583b73a2b61b0a","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Return the TIMEX string for the time given\n   */\n  public static String timexTimeValue(ReadableDateTime time){\n    return new StringBuilder()\n        .append(time.getYear()).append(\"-\")                    //year\n        .append(zeroPad(time.getMonthOfYear(),2)).append(\"-\")  //month\n        .append(zeroPad(time.getDayOfMonth(),2)).append(\"T\")   //day\n        .append(zeroPad(time.getHourOfDay(),2)).append(\":\")    //hour\n        .append(zeroPad(time.getMinuteOfHour(),2))             //minute\n        .toString();\n  }","id":101112,"modified_method":"/**\n   * Return the TIMEX string for the time given\n   */\n  public static String timexTimeValue(ReadableDateTime time){\n    return String.valueOf(time.getYear()) + '-' + zeroPad(time.getMonthOfYear(), 2) + '-' + zeroPad(time.getDayOfMonth(), 2) + 'T' + zeroPad(time.getHourOfDay(), 2) + ':' + zeroPad(time.getMinuteOfHour(), 2);\n  }","commit_id":"9308ab94fe494751c6fd5bccc1583b73a2b61b0a","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static Object standardDeviation(List<Integer> branchingFactors, double mean) {\n    double variance = 0.0;\n    for (int i : branchingFactors) {\n      variance += (i-mean)*(i-mean);\n    }\n    return Math.sqrt(variance / (branchingFactors.size()-1));\n  }","id":101113,"modified_method":"private static double standardDeviation(List<Integer> branchingFactors, double mean) {\n    double variance = 0.0;\n    for (int i : branchingFactors) {\n      variance += (i-mean)*(i-mean);\n    }\n    return Math.sqrt(variance / (branchingFactors.size()-1));\n  }","commit_id":"9308ab94fe494751c6fd5bccc1583b73a2b61b0a","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** This method is a HACK: it is designed to work around the current bug in NM tags created  at CRD \n\t * \n\t * @param r SAM record that must specify an alignment\n\t * @return number of errors (number of mismatches plus total length of all insertions/deletions\n\t * @throws RuntimeException\n\t */\n\tprivate static int numErrors(SAMRecord r) throws RuntimeException {\n\t\t\n\t\t// NM currently stores the total number of mismatches in all blocks + 1\n\t\tint errs = numMismatches(r);\n\t\t\n\t\t// now we have to add the total length of all indels:\n\t\tCigar c = r.getCigar();\n\t\tfor ( int i = 0 ; i < c.numCigarElements() ; i++ ) {\n\t\t\tCigarElement ce = c.getCigarElement(i);\n\t\t\tswitch( ce.getOperator()) {\n\t\t\tcase M : break; // we already have correct number of mismatches\n\t\t\tcase I : \n\t\t\tcase D :\n\t\t\t\t\terrs += ce.getLength();\n\t\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException(\"Unrecognized cigar element\");\n\t\t\t}\n\t\t}\n\t\treturn errs;\n\t}","id":101114,"modified_method":"/** This method is a HACK: it is designed to work around the current bug in NM tags created  at CRD \n\t * \n\t * @param r SAM record that must specify an alignment\n\t * @return number of errors (number of mismatches plus total length of all insertions/deletions\n\t * @throws RuntimeException\n\t */\n    private static int numErrors(SAMRecord r, ReferenceSequence refseq) throws RuntimeException {\n\t\t\n\t\t// NM currently stores the total number of mismatches in all blocks + 1\n        int errs = numMismatches(r,refseq);\n\t\t\n\t\t// now we have to add the total length of all indels:\n\t\tCigar c = r.getCigar();\n\t\tfor ( int i = 0 ; i < c.numCigarElements() ; i++ ) {\n\t\t\tCigarElement ce = c.getCigarElement(i);\n\t\t\tswitch( ce.getOperator()) {\n\t\t\tcase M : break; // we already have correct number of mismatches\n\t\t\tcase I : \n\t\t\tcase D :\n\t\t\t\t\terrs += ce.getLength();\n\t\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException(\"Unrecognized cigar element\");\n\t\t\t}\n\t\t}\n\t\treturn errs;\n\t}","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected int doWork() {\n\n        System.out.println(\"I am at version 0.3\");\n        GenomeLoc location = null;\n        if ( GENOME_LOCATION != null ) {\n            location = GenomeLoc.parseGenomeLoc(GENOME_LOCATION);\n        }\n\n\t\tif ( ! ERR_MODE.equals(\"MM\") && ! ERR_MODE.equals(\"MG\") && ! ERR_MODE.equals(\"ERR\") ) {\n\t\t\tSystem.out.println(\"Unknown value specified for ERR_MODE\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tfinal SAMFileReader samReader = new SAMFileReader(getInputFile(INPUT_FILE,\"/broad/1KG/\"));\n        samReader.setValidationStringency(SAMFileReader.ValidationStringency.SILENT);\n\n        setContigOrdering(samReader);\n\n        ReferenceSequenceFileWalker reference = new ReferenceSequenceFileWalker(\n                    new File(\"/seq/references/Homo_sapiens_assembly18/v0/Homo_sapiens_assembly18.fasta\")\n            );\n\n\n        ReferenceSequence contig_seq = null;\n\n\t\tIndelRecordPileCollector col = null;\n        PassThroughWriter ptWriter = new PassThroughWriter(OUT1,samReader.getFileHeader());\n        PileBuilder pileBuilder = null;\n        if ( ! CONTROL_RUN ) pileBuilder = new PileBuilder(OUT2,samReader.getFileHeader(),ptWriter);\n\n\t\ttry {\n            if ( CONTROL_RUN ) col = new IndelRecordPileCollector(ptWriter, new DiscardingPileReceiver() );\n\t\t\telse col = new IndelRecordPileCollector(ptWriter, pileBuilder );\n\t\t} catch(Exception e) { System.err.println(e.getMessage()); }\n\t\tif ( col == null ) return 1; \n\n        col.setControlRun(CONTROL_RUN);\n\n        if ( ! CONTROL_RUN ) {\n            if ( VERBOSITY_LEVEL == null ) VERBOSITY_LEVEL = new String(\"SILENT\");\n            if ( VERBOSITY_LEVEL.toUpperCase().equals(\"SILENT\")) pileBuilder.setVerbosity(pileBuilder.SILENT);\n            else if ( VERBOSITY_LEVEL.toUpperCase().equals(\"PILESUMMARY\") ) pileBuilder.setVerbosity(pileBuilder.PILESUMMARY);\n            else if ( VERBOSITY_LEVEL.toUpperCase().equals(\"ALIGNMENTS\") ) pileBuilder.setVerbosity(pileBuilder.ALIGNMENTS);\n            else {\n                System.out.println(\"Unrecognized VERBOSITY_LEVEL setting.\");\n                return 1;\n            }\n        }\n\n        String cur_contig = null;\n        int counter = 0;\n\n        for ( SAMRecord r : samReader ) {\n\n            if ( r.getReadUnmappedFlag() ) continue; \n        \tif ( r.getReferenceName() != cur_contig) {\n        \t\tcur_contig = r.getReferenceName();\n        \t\tSystem.out.println(\"Contig \"+cur_contig);\n                // if contig is specified and we are past that contig, we are done:\n                if ( location != null && GenomeLoc.compareContigs(cur_contig, location.getContig()) == 1 ) break;\n                if ( location == null || GenomeLoc.compareContigs(cur_contig, location.getContig()) == 0 ) {\n                    contig_seq = reference.get(r.getReferenceIndex());\n                    String refstr = new String(contig_seq.getBases());\n                    col.setReferenceSequence(refstr);\n                    if (!CONTROL_RUN) pileBuilder.setReferenceSequence(refstr);\n                    System.out.println(\"loaded contig \"+cur_contig+\" (index=\"+r.getReferenceIndex()+\"); length=\"+contig_seq.getBases().length+\" tst=\"+contig_seq.toString());\n                }\n            }\n\n            // if contig is specified and wqe did not reach it yet, skip the records until we reach that contig:\n        \tif ( location != null && GenomeLoc.compareContigs(cur_contig, location.getContig()) == -1 ) continue;\n\n\n            if ( location != null && r.getAlignmentEnd() < location.getStart() ) continue;\n\n            // if stop position is specified and we are past that, stop reading:\n        \tif ( location != null && r.getAlignmentStart() > location.getStop() ) break;\n\n        \tif ( cur_contig.equals(\"chrM\") || GenomeLoc.compareContigs(cur_contig,\"chrY\")==1 ) continue; // skip chrM and unplaced contigs for now\n        \t\n        \tint err = -1;\n/*\n            System.out.println(\"MM:     \"+numMismatches(r));\n            System.out.println(\"direct: \"+numMismatchesDirect(r,contig_seq));\n            System.out.print(\"  \");\n            for ( int i = r.getAlignmentStart() - 1 ; i < r.getAlignmentEnd() ; i++ ) System.out.print((char)contig_seq.getBases()[i]);\n            System.out.println();\n            System.out.println((r.getReadNegativeStrandFlag()?\"<-\":\"->\")+r.getReadString());\n            System.out.println(\"cigar: \"+r.getCigarString());\n            System.out.println();\n            if (counter++ == 20 ) break;\n            continue;\n*/\n\n        \tif ( ERR_MODE.equals(\"MM\")) err = numMismatches(r);\n        \telse if ( ERR_MODE.equals(\"ERR\")) err = numErrors(r);\n        \telse if ( ERR_MODE.equals(\"MG\")) err = numMismatchesGaps(r);\n        \tif ( err > MAX_ERRS.intValue() ) continue;\n//        \tcounter++;\n//        \tif ( counter % 1000000 == 0 ) System.out.println(counter+\" records; \"+col.memStatsString());\n        \tcol.receive(r);\n\n        }\n        \n        if ( ! CONTROL_RUN ) {\n            pileBuilder.printStats();\n            pileBuilder.close();\n        }\n        System.out.println(\"done.\");\n        col.printLengthHistograms();\n        samReader.close();\n        ptWriter.close();\n        return 0;\n\t}","id":101115,"modified_method":"protected int doWork() {\n\n        int discarded_count = 0;\n\n        ReferenceSequenceFileWalker reference = new ReferenceSequenceFileWalker(\n                    REF_FILE\n            );\n\n        if ( reference.getSequenceDictionary() == null ) {\n            System.out.println(\"No reference sequence dictionary found. Abort.\");\n        }\n\n        GenomeLoc.setupRefContigOrdering(reference.getSequenceDictionary());\n        GenomeLoc location = null;\n        if ( GENOME_LOCATION != null ) {\n            location = GenomeLoc.parseGenomeLoc(GENOME_LOCATION);\n        }\n        \n        if ( ! ERR_MODE.equals(\"MM\") && ! ERR_MODE.equals(\"MG\") && ! ERR_MODE.equals(\"ERR\") && ! ERR_MODE.equals(\"MC\") ) {\n            System.out.println(\"Unknown value specified for ERR_MODE: \"+ERR_MODE);\n            return 1;\n        }\n\n        final SAMFileReader samReader = new SAMFileReader(getInputFile(INPUT_FILE,\"/broad/1KG/\"));\n        samReader.setValidationStringency(SAMFileReader.ValidationStringency.SILENT);\n\n        //        setContigOrdering(samReader);\n\n\n        ReferenceSequence contig_seq = null;\n\n        IndelRecordPileCollector col = null;\n        PassThroughWriter ptWriter = new PassThroughWriter(OUT1,samReader.getFileHeader());\n        PileBuilder pileBuilder = null;\n        if ( ! CONTROL_RUN ) pileBuilder = new PileBuilder(OUT2,samReader.getFileHeader(),ptWriter);\n\n        try {\n            if ( CONTROL_RUN ) col = new IndelRecordPileCollector(ptWriter, new DiscardingPileReceiver() );\n            else col = new IndelRecordPileCollector(ptWriter, pileBuilder );\n        } catch(Exception e) { System.err.println(e.getMessage()); }\n        if ( col == null ) return 1; \n\n        col.setControlRun(CONTROL_RUN);\n\n        if ( ! CONTROL_RUN ) {\n            if ( VERBOSITY_LEVEL == null ) VERBOSITY_LEVEL = new String(\"SILENT\");\n            if ( VERBOSITY_LEVEL.toUpperCase().equals(\"SILENT\")) pileBuilder.setVerbosity(pileBuilder.SILENT);\n            else if ( VERBOSITY_LEVEL.toUpperCase().equals(\"PILESUMMARY\") ) pileBuilder.setVerbosity(pileBuilder.PILESUMMARY);\n            else if ( VERBOSITY_LEVEL.toUpperCase().equals(\"ALIGNMENTS\") ) pileBuilder.setVerbosity(pileBuilder.ALIGNMENTS);\n            else {\n                System.out.println(\"Unrecognized VERBOSITY_LEVEL setting.\");\n                return 1;\n            }\n        }\n\n        String cur_contig = null;\n        int counter = 0;\n\n        for ( SAMRecord r : samReader ) {\n\n            if ( r.getReadUnmappedFlag() ) continue; \n            if ( r.getReferenceName() != cur_contig) {\n                cur_contig = r.getReferenceName();\n                System.out.println(\"Contig \"+cur_contig);\n                // if contig is specified and we are past that contig, we are done:\n                if ( location != null && GenomeLoc.compareContigs(cur_contig, location.getContig()) == 1 ) break;\n                if ( location == null || GenomeLoc.compareContigs(cur_contig, location.getContig()) == 0 ) {\n                    contig_seq = reference.get(r.getReferenceIndex());\n                    String refstr = new String(contig_seq.getBases());\n                    col.setReferenceSequence(refstr);\n                    if (!CONTROL_RUN) pileBuilder.setReferenceSequence(refstr);\n                    System.out.println(\"loaded contig \"+cur_contig+\" (index=\"+r.getReferenceIndex()+\"); length=\"+contig_seq.getBases().length+\" tst=\"+contig_seq.toString());\n                }\n            }\n\n            // if contig is specified and we did not reach it yet, skip the records until we reach that contig:\n            if ( location != null && GenomeLoc.compareContigs(cur_contig, location.getContig()) == -1 ) continue;\n\n\n            if ( location != null && r.getAlignmentEnd() < location.getStart() ) continue;\n\n            // if stop position is specified and we are past that, stop reading:\n            if ( location != null && r.getAlignmentStart() > location.getStop() ) break;\n\n            //    if ( cur_contig.equals(\"chrM\") || GenomeLoc.compareContigs(cur_contig,\"chrY\") > 0 ) continue; // skip chrM and unplaced contigs for now\n\n            // we currently do not know how to deal with cigars containing elements other than M,I,D, so \n            // let's just skip the reads that contain those other elements (clipped reads?)\n            Cigar c = r.getCigar();\n            boolean cigar_acceptable = true;\n            for ( int z = 0 ; z < c.numCigarElements() ; z++ ) {\n                CigarElement ce = c.getCigarElement(z);\n                switch ( ce.getOperator() ) {\n                case M:\n                case I:\n                case D: break;\n                default: cigar_acceptable = false;\n                }\n            }\n            if ( ! cigar_acceptable ) continue;\n\n            int err = -1;\n/*\n            System.out.println(\"MM:     \"+numMismatches(r));\n            System.out.println(\"direct: \"+numMismatchesDirect(r,contig_seq));\n            System.out.print(\"  \");\n            for ( int i = r.getAlignmentStart() - 1 ; i < r.getAlignmentEnd() ; i++ ) System.out.print((char)contig_seq.getBases()[i]);\n            System.out.println();\n            System.out.println((r.getReadNegativeStrandFlag()?\"<-\":\"->\")+r.getReadString());\n            System.out.println(\"cigar: \"+r.getCigarString());\n            System.out.println();\n            if (counter++ == 20 ) break;\n            continue;\n*/\n\n            if ( ERR_MODE.equals(\"MM\")) err = numMismatches(r,contig_seq);\n            else if ( ERR_MODE.equals(\"MC\") ) err = AlignmentUtils.numMismatches(r,contig_seq);\n            else if ( ERR_MODE.equals(\"ERR\")) err = numErrors(r,contig_seq);\n            else if ( ERR_MODE.equals(\"MG\")) err = numMismatchesGaps(r,contig_seq);\n            if ( err > MAX_ERRS.intValue() ) continue;\n            //        \tcounter++;\n            //        \tif ( counter % 1000000 == 0 ) System.out.println(counter+\" records; \"+col.memStatsString());\n            col.receive(r);\n\n        }\n        \n        if ( ! CONTROL_RUN ) {\n            pileBuilder.printStats();\n            pileBuilder.close();\n        }\n        System.out.println(\"done.\");\n        col.printLengthHistograms();\n        samReader.close();\n        ptWriter.close();\n        return 0;\n    }","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** This method is a HACK: it is designed to work around the current bug in NM tags created  at CRD */\n\tprivate static int numMismatches(SAMRecord r) throws RuntimeException {\n\t\t\n\t\t// NM currently stores the total number of mismatches in all blocks + 1\n\t\treturn ((Integer)r.getAttribute(\"NM\")).intValue() - 1;\n\t\t\n\t}","id":101116,"modified_method":"/** This method is a HACK: it is designed to work around the current bug in NM tags created  at CRD */\n    private static int numMismatches(SAMRecord r, ReferenceSequence refseq) throws RuntimeException {\n\t\t\n        // NM currently stores the total number of mismatches in all blocks + 1\n        Integer i = (Integer)r.getAttribute(\"NM\");\n        if ( i == null ) return AlignmentUtils.numMismatches(r,refseq);\n        return ((Integer)r.getAttribute(\"NM\")).intValue() - 1;\n\t\t\n    }","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void setDefaultContigOrdering() {\n        Map<String,Integer> rco = new HashMap<String,Integer>();\n        rco.put(\"chrM\",0);\n        for ( int i = 1 ; i <= 22 ; i++ ) rco.put(\"chr\"+i,i);\n        rco.put(\"chrX\",23);\n        rco.put(\"chrY\",24);\n    }","id":101117,"modified_method":"private void setDefaultContigOrdering() {\n        Map<String,Integer> rco = new HashMap<String,Integer>();\n        rco.put(\"chrM\",0);\n        for ( int i = 1 ; i <= 22 ; i++ ) rco.put(Integer.toString(i),i);//rco.put(\"chr\"+i,i);\n        rco.put(\"chrX\",23);\n        rco.put(\"chrY\",24);\n    }","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** This method is a HACK: it is designed to work around the current bug in NM tags created  at CRD \n\t * \n\t * @param r SAM record that must specify an alignment\n\t * @return number of errors (number of mismatches plus total number of all insertions/deletions (each insertion or\n\t * deletion will be counted as a single error regardless of the length)\n\t * @throws RuntimeException\n\t */\n\tprivate static int numMismatchesGaps(SAMRecord r) throws RuntimeException {\n\t\t\n\t\t// NM currently stores the total number of mismatches in all blocks + 1\n\t\tint errs = numMismatches(r);\n\t\t\n\t\t// now we have to add the total length of all indels:\n\t\tCigar c = r.getCigar();\n\t\tfor ( int i = 0 ; i < c.numCigarElements() ; i++ ) {\n\t\t\tCigarElement ce = c.getCigarElement(i);\n\t\t\tswitch( ce.getOperator()) {\n\t\t\tcase M : break; // we already have correct number of mismatches\n\t\t\tcase I : \n\t\t\tcase D :\n\t\t\t\t\terrs++;\n\t\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException(\"Unrecognized cigar element\");\n\t\t\t}\n\t\t}\n\t\treturn errs;\n\t}","id":101118,"modified_method":"/** This method is a HACK: it is designed to work around the current bug in NM tags created  at CRD \n\t * \n\t * @param r SAM record that must specify an alignment\n\t * @return number of errors (number of mismatches plus total number of all insertions/deletions (each insertion or\n\t * deletion will be counted as a single error regardless of the length)\n\t * @throws RuntimeException\n\t */\n    private static int numMismatchesGaps(SAMRecord r,ReferenceSequence refseq) throws RuntimeException {\n\t\t\n\t\t// NM currently stores the total number of mismatches in all blocks + 1\n        int errs = numMismatches(r,refseq);\n\t\t\n\t\t// now we have to add the total length of all indels:\n\t\tCigar c = r.getCigar();\n\t\tfor ( int i = 0 ; i < c.numCigarElements() ; i++ ) {\n\t\t\tCigarElement ce = c.getCigarElement(i);\n\t\t\tswitch( ce.getOperator()) {\n\t\t\tcase M : break; // we already have correct number of mismatches\n\t\t\tcase I : \n\t\t\tcase D :\n\t\t\t\t\terrs++;\n\t\t\t\t\tbreak;\n\t\t\tdefault: throw new RuntimeException(\"Unrecognized cigar element\");\n\t\t\t}\n\t\t}\n\t\treturn errs;\n\t}","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** This is the main interface method of the collector: it receives alignments, inspects them, detects indels,\n     *  updates and purges the read pile it keeps and emits alignments as needed.\n     * Depending on the state, the following behaviors are possible\n     *\n     * <ul>\n     *  <li> If the collector is in wait state (no indels seen recently): all\n     *       alignments that end prior to the start of currently inspected alignment can not overlap\n     *       with any future indels, including those that may be present in the current alignment; these records\n     *       get purged from the pile and emitted immediately. Current alignment gets added to the pile.\n     *       If current alignment has indels, collector switches into 'active' state.\n     *  <li> in active state: if the current alignment starts sufficiently far away from the last indel seen,\n     *       examine the currently held pile closely, split into a few separate piles/indel trains if needed, emit and\n     *       completely purge the pile, add alignment to the pile, switch to wait state if alignment has no indels or\n     *       stay in active state if it does. Otherwise (alignment too close to last indel),\n     *       just add alignment to the pile, since it is yet impossible to tell whether new indels are coming soon and\n     *       indel train will need to be extended; if alignment does have indels of its own, add them\n     *       to the current indel train\n     * <\/ul>\n     *\n     * This method checks that records arrive in reference-sorted order and throws RuntimeException if out-of-order\n     * record arrives.\n     *\n     * @param r\n     * @throws RuntimeException\n     */\n    public void receive(final SAMRecord r) throws RuntimeException {\n\t\t\n\t\tif ( r.getReadUnmappedFlag() ) return; // read did not align, nothing to do\n\n        if ( controlRun ) {\n            defaultReceiver.receive(r);\n            return;\n        }\n\n\t\tint currContig = r.getReferenceIndex();\n\t\tint currPos = r.getAlignmentStart();\n\t\t\n\t\tif ( currContig < mLastContig ) throw new RuntimeException(\"SAM file is not ordered by contigs\");\n\t\tif ( currContig == mLastContig && currPos < mLastStartOnRef ) throw new RuntimeException(\"SAM file is not ordered by start positions\");\n\t\t\n\t\tif ( currContig > mLastContig ) {\n\t\t\t// we jumped onto a new contig; emit everything we might have been building and purge the piles:\n\t\t\temit();\n\t\t} else { // still on the same contig:\n\n            switch (mState) {\n\t\t\t            // everything ending up to currPos is guaranteed to have no overlaps with indels yet to come\n\t\t\t    case WAIT_STATE: purgeRecordsEndingAtOrBefore(currPos); break;\n\n                       // next indel can start only after currPos (whether it is in the current read or in the\n                       // reads yet to come). If it is far enough from the last indel we have seen, we can emit\n                case ACTIVE_STATE: if ( currPos - mAllIndels.last().getObject().getStop() > mIndelSeparation ) emit(); break;\n                default: throw new RuntimeException(\"Unknown state\");\n            }\n        }\n\n        // does nothing if alignment has no indels, otherwise adds the indels to the list and (re)sets state to 'active'\n        extractIndelsAndUpdateState(r.getCigar(),currPos);\n\n\t\tif ( ! avoiding_region && mAllIndels.size() > 20 ) avoiding_region = true;\n\n\t\tif ( ! avoiding_region ) mRecordPile.add(r); // add new record if this is not some crazy region\n\n\t\tmLastContig = currContig;\n\t\tmLastStartOnRef = currPos;\n\t\t\n\t}","id":101119,"modified_method":"/** This is the main interface method of the collector: it receives alignments, inspects them, detects indels,\n     *  updates and purges the read pile it keeps and emits alignments as needed.\n     * Depending on the state, the following behaviors are possible\n     *\n     * <ul>\n     *  <li> If the collector is in wait state (no indels seen recently): all\n     *       alignments that end prior to the start of currently inspected alignment can not overlap\n     *       with any future indels, including those that may be present in the current alignment; these records\n     *       get purged from the pile and emitted immediately. Current alignment gets added to the pile.\n     *       If current alignment has indels, collector switches into 'active' state.\n     *  <li> in active state: if the current alignment starts sufficiently far away from the last indel seen,\n     *       examine the currently held pile closely, split into a few separate piles/indel trains if needed, emit and\n     *       completely purge the pile, add alignment to the pile, switch to wait state if alignment has no indels or\n     *       stay in active state if it does. Otherwise (alignment too close to last indel),\n     *       just add alignment to the pile, since it is yet impossible to tell whether new indels are coming soon and\n     *       indel train will need to be extended; if alignment does have indels of its own, add them\n     *       to the current indel train\n     * <\/ul>\n     *\n     * This method checks that records arrive in reference-sorted order and throws RuntimeException if out-of-order\n     * record arrives.\n     *\n     * @param r\n     * @throws RuntimeException\n     */\n    public void receive(final SAMRecord r) throws RuntimeException {\n\t\t\n        if ( r.getReadUnmappedFlag() ) return; // read did not align, nothing to do\n\n        if ( controlRun ) {\n            defaultReceiver.receive(r);\n            return;\n        }\n\n        int currContig = r.getReferenceIndex();\n        int currPos = r.getAlignmentStart();\n\t\t\n        if ( currContig < mLastContig ) throw new RuntimeException(\"SAM file is not ordered by contigs\");\n        if ( currContig == mLastContig && currPos < mLastStartOnRef ) throw new RuntimeException(\"SAM file is not ordered by start positions\");\n\t\n        if ( currContig > mLastContig ) {\n            // we jumped onto a new contig; emit everything we might have been building and purge the piles:\n            emit();\n        } else { // still on the same contig:\n\n            switch (mState) {\n                // everything ending up to currPos is guaranteed to have no overlaps with indels yet to come\n            case WAIT_STATE: purgeRecordsEndingAtOrBefore(currPos); break;\n                \n                // next indel can start only after currPos (whether it is in the current read or in the\n                // reads yet to come). If it is far enough from the last indel we have seen, we can emit\n            case ACTIVE_STATE: if ( currPos - mAllIndels.last().getObject().getStop() > mIndelSeparation ) emit(); break;\n            default: throw new RuntimeException(\"Unknown state\");\n            }\n        }\n\n        // does nothing if alignment has no indels, otherwise adds the indels to the list and (re)sets state to 'active'\n        extractIndelsAndUpdateState(r.getCigar(),currPos);\n\n        if ( mState == ACTIVE_STATE && ( ! avoiding_region ) && ( mAllIndels.size() > 20 || mRecordPile.size() > 1000 ) ) avoiding_region = true;\n\n        if ( ! avoiding_region ) mRecordPile.add(r); // add new record if this is not some crazy region\n\n        mLastContig = currContig;\n        mLastStartOnRef = currPos;\n\t\t\n    }","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Emits all reads from the currently held pile, cleans the pile and fully reinitializes wait state\n     * (clears indel list etc).\n     *\n     * If the current state is 'wait', simply sends all the records from the pile to nonindelReceiver before\n     * the cleanup. If the state is 'active', then performs final inspection of the pile built over a train of indels,\n     * splits the train (and the pile) into multiple trains/piles as needed (i.e. if there are pairs of adjacent\n     * indels that are not overlapped by any read), and emits the final piles of records into indelReceiver.\n      */\n\tprivate void emit() {\n\n\t\tif ( mState == WAIT_STATE || avoiding_region ) {\n            if ( avoiding_region )  {\n                long start = mAllIndels.first().getObject().getStart();\n                long stop = mAllIndels.last().getObject().getStop();\n                System.out.println(\"Genomic region \"+mLastContig+\":\"+ start + \"-\"+ stop +\n                                   \" was ignored: \"+mAllIndels.size() +\" unique indels with average distance of \"+\n                                   ((double)(stop - start))/((double)mAllIndels.size()-1) +\n                                   \" bases between indels\");\n            }\n\n\t\t\t// no indels or avoiding indels in bad region: send all records to defaultReceiver and clear the pile\n            for ( SAMRecord r : mRecordPile ) {\n                defaultReceiver.receive(r);\n            }\n            setWaitState();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// last minute cleanup:\n\t\t// at this stage we have all the indels collected conservatively (in a sense\n\t\t// that they can be farther away than it is needed) - this means that there actually\n\t\t// can be more than one pile in what we have stored. Also, we can still have gapless reads\n\t\t// at the ends of the piles that do not really overlap with indel sites.\n\t\t\n\t\tif ( mAllIndels.size() == 0 ) throw new RuntimeException(\"Attempt to emit pile with no indels\");\n\n\t\tHistogramAsNeeded(mAllIndels);\n\n\n        // indels are in a sorted map, and reads were added to the pile in the order they were received (also sorted).\n        // we will traverse the two collections in parallel and detect exactly where we can break the indel train into\n        // subtrains\n        Iterator<CountedObject<Indel> > i_iter = mAllIndels.iterator();\n\n        // will keep list of indels and list of records, respectively, in one final train\n        List< CountedObject<Indel> > finalTrain = new ArrayList<CountedObject<Indel>>();\n        List< SAMRecord > finalPile = new ArrayList<SAMRecord>();\n\n        long curr_stop = -1; // the rightmost stop position among all the alignments seen so far\n\n        CountedObject<Indel> indel = i_iter.next(); // we checked that list of indels contains at least one element!\n\n        SAMRecord record ;\n\n        while ( indel != null ) {\n\n            // first, if we just started new indel train, then emit into defaultReceiver all alignments\n            // that end prior to the first indel in the train:\n            if ( finalTrain.size() == 0 ) purgeRecordsEndingAtOrBefore(indel.getObject().getStart() - 1);\n\n            finalTrain.add(indel);\n\n            Iterator<SAMRecord> r_iter = mRecordPile.iterator();\n\n            if ( r_iter.hasNext() ) record = r_iter.next();\n            else record = null;\n\n            // record now contains first alignment that ends in or after the indel, or null if there are no more records\n\n            // now collect all the alignments that overlap with the current indel (start before or inside) and\n            // record the rightmost alignment stop position:\n            while ( record != null && record.getAlignmentStart() <= indel.getObject().getStop() ) {\n                finalPile.add(record);\n                r_iter.remove(); // remove from the original pile the record we just moved to the current final pile\n                curr_stop = Math.max(curr_stop, record.getAlignmentEnd());\n                if ( r_iter.hasNext() ) record = r_iter.next();\n                else record = null;\n            }\n\n            // record is now the first alignment that starts after the indel, or null if there are no more records\n\n            // we are done with current indel, get next one if any:\n            if ( i_iter.hasNext() ) {\n                indel = i_iter.next();\n            } else indel = null;\n            if ( indel == null || curr_stop < indel.getObject().getStart() ) {\n                // if there are no more indels or\n                // all alignments that overlapped with the previous indel ended before the current indel started,\n                // this means that the current train and pile of reads overlapping with it are fully built\n                // and can be emitted\n\n                if ( shouldAcceptForOutput(finalTrain ) ) {\n                     System.out.print(mLastContig+\":\"+ finalTrain.get(0).getObject().getStart() + \"-\" +\n                             finalTrain.get(finalTrain.size()-1).getObject().getStop() + \" \" +\n                             finalTrain.size() + \" indels; \");\n                     System.out.print(finalPile.size() + \" reads in the pile;\")  ;\n                     System.out.println(formatRange(finalTrain));\n                     indelPileReceiver.receive(finalPile);\n                } else {\n                    for ( SAMRecord r : finalPile ) {\n                        defaultReceiver.receive(r);\n                    }\n                }\n                finalPile.clear();\n                finalTrain.clear();\n                curr_stop = -1;\n            } // ELSE: otherwise we have reads that overlap with both previous and current indel, so we just continue\n              // with building the indel train\n        }\n\n        setWaitState();\n\t}","id":101120,"modified_method":"/** Emits all reads from the currently held pile, cleans the pile and fully reinitializes wait state\n     * (clears indel list etc).\n     *\n     * If the current state is 'wait', simply sends all the records from the pile to nonindelReceiver before\n     * the cleanup. If the state is 'active', then performs final inspection of the pile built over a train of indels,\n     * splits the train (and the pile) into multiple trains/piles as needed (i.e. if there are pairs of adjacent\n     * indels that are not overlapped by any read), and emits the final piles of records into indelReceiver.\n      */\n    private void emit() {\n\n        if ( mState == WAIT_STATE || avoiding_region ) {\n            if ( avoiding_region )  {\n                long start = mAllIndels.first().getObject().getStart();\n                long stop = mAllIndels.last().getObject().getStop();\n                System.out.println(\"Genomic region \"+mLastContig+\":\"+ start + \"-\"+ stop +\n                                   \" was ignored: \");\n                System.out.println(\"   \"+mAllIndels.size() +\" unique indels with average distance of \"+\n                                   ((double)(stop - start))/((double)mAllIndels.size()-1) +\n                                   \" bases between indels\");\n                System.out.println(\"   \"+mRecordPile.size() +\" reads collected before aborting\");\n            }\n\n            // no indels or avoiding indels in bad region: send all records to defaultReceiver and clear the pile\n            for ( SAMRecord r : mRecordPile ) {\n                defaultReceiver.receive(r);\n            }\n            setWaitState();\n            return;\n        }\n        \n        // last minute cleanup:\n        // at this stage we have all the indels collected conservatively (in a sense\n        // that they can be farther away than it is needed) - this means that there actually\n        // can be more than one pile in what we have stored. Also, we can still have gapless reads\n        // at the ends of the piles that do not really overlap with indel sites.\n\t\n        if ( mAllIndels.size() == 0 ) throw new RuntimeException(\"Attempt to emit pile with no indels\");\n        \n        HistogramAsNeeded(mAllIndels);\n\n\n        // indels are in a sorted map, and reads were added to the pile in the order they were received (also sorted).\n        // we will traverse the two collections in parallel and detect exactly where we can break the indel train into\n        // subtrains\n        Iterator<CountedObject<Indel> > i_iter = mAllIndels.iterator();\n\n        // will keep list of indels and list of records, respectively, in one final train\n        List< CountedObject<Indel> > finalTrain = new ArrayList<CountedObject<Indel>>();\n        List< SAMRecord > finalPile = new ArrayList<SAMRecord>();\n\n        long curr_stop = -1; // the rightmost stop position among all the alignments seen so far\n\n        CountedObject<Indel> indel = i_iter.next(); // we checked that list of indels contains at least one element!\n\n        SAMRecord record ;\n\n        while ( indel != null ) {\n\n            // first, if we just started new indel train, then emit into defaultReceiver all alignments\n            // that end prior to the first indel in the train:\n            if ( finalTrain.size() == 0 ) purgeRecordsEndingAtOrBefore(indel.getObject().getStart() - 1);\n\n            finalTrain.add(indel);\n\n            Iterator<SAMRecord> r_iter = mRecordPile.iterator();\n\n            if ( r_iter.hasNext() ) record = r_iter.next();\n            else record = null;\n\n            // record now contains first alignment that ends in or after the indel, or null if there are no more records\n\n            // now collect all the alignments that overlap with the current indel (start before or inside) and\n            // record the rightmost alignment stop position:\n            while ( record != null && record.getAlignmentStart() <= indel.getObject().getStop() ) {\n                finalPile.add(record);\n                r_iter.remove(); // remove from the original pile the record we just moved to the current final pile\n                curr_stop = Math.max(curr_stop, record.getAlignmentEnd());\n                if ( r_iter.hasNext() ) record = r_iter.next();\n                else record = null;\n            }\n\n            // record is now the first alignment that starts after the indel, or null if there are no more records\n\n            // we are done with current indel, get next one if any:\n            if ( i_iter.hasNext() ) {\n                indel = i_iter.next();\n            } else indel = null;\n            if ( indel == null || curr_stop < indel.getObject().getStart() ) {\n                // if there are no more indels or\n                // all alignments that overlapped with the previous indel ended before the current indel started,\n                // this means that the current train and pile of reads overlapping with it are fully built\n                // and can be emitted\n\n                if ( shouldAcceptForOutput(finalTrain ) ) {\n                     System.out.print(mLastContig+\":\"+ finalTrain.get(0).getObject().getStart() + \"-\" +\n                             finalTrain.get(finalTrain.size()-1).getObject().getStop() + \" \" +\n                             finalTrain.size() + \" indels; \");\n                     System.out.print(finalPile.size() + \" reads in the pile;\")  ;\n                     System.out.println(formatRange(finalTrain));\n                     indelPileReceiver.receive(finalPile);\n                } else {\n                    for ( SAMRecord r : finalPile ) {\n                        defaultReceiver.receive(r);\n                    }\n                }\n                finalPile.clear();\n                finalTrain.clear();\n                curr_stop = -1;\n            } // ELSE: otherwise we have reads that overlap with both previous and current indel, so we just continue\n              // with building the indel train\n        }\n\n        setWaitState();\n    }","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n\tpublic TrioConcordanceRecord map(RefMetaDataTracker rodData, char ref, LocusContext context) {\n\t\t\n\t\tTrioConcordanceRecord t = new TrioConcordanceRecord();\n\t\t\n//\t\tString outLine = new String(context.getLocation() + \" REF: \"+ref + \" RODS:\" + rodData.getAllRods().size());\n\t\t\n\t\tAllelicVariant mom = (rodSAMPileup)rodData.lookup(\"mother\", null);\n\t\tAllelicVariant dad = (rodSAMPileup)rodData.lookup(\"father\", null);\n\t\tAllelicVariant kid = (rodSAMPileup)rodData.lookup(\"daughter\", null);\n\t\t\n\t\tif ( ! hasCall(mom)  || ! hasCall(dad) || ! hasCall(kid) ) return t; // at least one person is not called; nothing to do, bail out\n\t\t\t\n\t\t// proceed only if we got confident calls\n\t\t\t\n        t.assessed_loci = 1;\n\t\t\t\n\t\tif ( ! mom.isBiallelic() || ! dad.isBiallelic() || ! kid.isBiallelic() ) {\n\t\t\tt.non_biallelic = 1; // we currently ignore non-biallelic sites\n\t\t\treturn t;\n\t\t}\n\t\t\n\t\t// ok, we got a call and it is biallelic (at most)\n\t\t\n\t\tif ( mom.isReference() && dad.isReference() && kid.isReference() ) { // got all refs, we are done\n\t\t\tt.consistent_ref = 1;\n\t\t\treturn t;\n\t\t}\n\n\t\t// by now we know that there's a SNP\n\t\t\n\t\tString kid_allele_1 = kid.getGenotype().get(0);\n\t\tString kid_allele_2 = kid.getGenotype().get(1);\n\t\tList<String> mom_alleles = mom.getGenotype();\n\t\tList<String> dad_alleles = dad.getGenotype();\n\t\t\n\t\t// kid must have one allele from mom and one allele from dad if it's not X chromosome!\n\t\t\n\t\tif ( mom_alleles.contains(kid_allele_1) && dad_alleles.contains(kid_allele_2) ||\n\t\t\t\tmom_alleles.contains(kid_allele_2) && dad_alleles.contains(kid_allele_1) ) {\n\t\t\tt.consistent_snp = 1;\n\t\t\t\n\t\t\tlogger.info(\"consistent SNP at \"+context.getLocation() + \n\t\t\t\t\t\"(\"+ref+\") \" + mom_alleles.get(0)+\"/\" +mom_alleles.get(1) + \"  \" +\n\t\t\t\t\tdad_alleles.get(0)+\"/\" +dad_alleles.get(1) + \"  \" +\n\t\t\t\t\tkid_allele_1+\"/\" +kid_allele_2  \n\t\t\t\t\t);\n\t\t\treturn t;\n\t    }\n\t\t\n\t\t// snp is inconsistent\n\t\t\n\t\tt.inconsistent_snp = 1;\n\t\tlogger.info(\"INconsistent SNP at \"+context.getLocation() + \n\t\t\t\t\"(\"+ref+\") \" + mom_alleles.get(0)+\"/\" +mom_alleles.get(1) + \"  \" +\n\t\t\t\tdad_alleles.get(0)+\"/\" +dad_alleles.get(1) + \"  \" +\n\t\t\t\tkid_allele_1+\"/\" +kid_allele_2  \n\t\t\t\t);\n\t\t\n\t\treturn t;\n\t\t\n\t}","id":101121,"modified_method":"@Override\n\tpublic TrioConcordanceRecord map(RefMetaDataTracker rodData, char ref, LocusContext context) {\n\t\t\n\t\tTrioConcordanceRecord t = new TrioConcordanceRecord();\n\t\t\n//\t\tString outLine = new String(context.getLocation() + \" REF: \"+ref + \" RODS:\" + rodData.getAllRods().size());\n\t\t\n\t\tAllelicVariant mom = (rodSAMPileup)rodData.lookup(\"mother\", null);\n\t\tAllelicVariant dad = (rodSAMPileup)rodData.lookup(\"father\", null);\n\t\tAllelicVariant kid = (rodSAMPileup)rodData.lookup(\"daughter\", null);\n\t\t\n\t\tif ( hasCall(mom)) t.mom_assessed = 1;\n\t\tif ( hasCall(dad)) t.dad_assessed = 1;\n\t\tif ( hasCall(kid)) t.kid_assessed = 1;\n\t\t\n\t\tif ( hasCall(mom) && mom.isIndel() ) System.out.println(\"GOT INDEL: \"+mom.toString());\n\t\t\n\t\tif (( t.mom_assessed + t.dad_assessed + t.kid_assessed) != 3 ) return t; // at least one person is not called; nothing to do, bail out\n\t\t\t\n\t\t// proceed only if we got confident calls\n\t\t\t\n        t.assessed_loci = 1;\n\t\t\t\n\t\tif ( ! mom.isBiallelic() || ! dad.isBiallelic() || ! kid.isBiallelic() ) {\n\t\t\tt.non_biallelic = 1; // we currently ignore non-biallelic sites\n\t\t\treturn t;\n\t\t}\n\t\t\n\t\t// ok, we got a call and it is biallelic (at most)\n\t\t\n\t\tif ( mom.isReference() && dad.isReference() && kid.isReference() ) { // got all refs, we are done\n\t\t\tt.consistent_ref = 1;\n\t\t\treturn t;\n\t\t}\n\n\t\t// by now we know that there's a SNP\n\t\t\n\t\tString kid_allele_1 = kid.getGenotype().get(0);\n\t\tString kid_allele_2 = kid.getGenotype().get(1);\n\t\tList<String> mom_alleles = mom.getGenotype();\n\t\tList<String> dad_alleles = dad.getGenotype();\n\t\t\n\t\t// kid must have one allele from mom and one allele from dad if it's not X chromosome!\n\t\t\n\t\tif ( mom_alleles.contains(kid_allele_1) && dad_alleles.contains(kid_allele_2) ||\n\t\t\t\tmom_alleles.contains(kid_allele_2) && dad_alleles.contains(kid_allele_1) ) {\n\t\t\tt.consistent_snp = 1;\n\t\t\t\n//\t\t\tlogger.info(\"consistent SNP at \"+context.getLocation() + \n//\t\t\t\t\t\"(\"+ref+\") \" + mom_alleles.get(0)+\"/\" +mom_alleles.get(1) + \"  \" +\n//\t\t\t\t\tdad_alleles.get(0)+\"/\" +dad_alleles.get(1) + \"  \" +\n//\t\t\t\t\tkid_allele_1+\"/\" +kid_allele_2  \n//\t\t\t\t\t);\n\t\t\treturn t;\n\t    }\n\t\t\n\t\t// snp is inconsistent\n\t\t\n\t\tt.inconsistent_snp = 1;\n\t\tlogger.info(\"INconsistent SNP at \"+context.getLocation() + \n\t\t\t\t\"(\"+ref+\") \" + mom_alleles.get(0)+\"/\" +mom_alleles.get(1) + \"  \" +\n\t\t\t\tdad_alleles.get(0)+\"/\" +dad_alleles.get(1) + \"  \" +\n\t\t\t\tkid_allele_1+\"/\" +kid_allele_2  \n\t\t\t\t);\n\t\t\n\t\treturn t;\n\t\t\n\t}","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String toString() {\n\t\treturn String.format(\"assessed: %d; reference: %d (%3.2f);  total snp: %d;  consistent snp: %d (%3.2f); multiallelic: %d (%3.2f); \" , \n\t\t\t\tassessed_loci, consistent_ref, ((double)consistent_ref*100.00)/assessed_loci,totalSNP(), consistent_snp, ((double)consistent_snp*100.0)/totalSNP(),\n\t\t\t\tnon_biallelic, ((double)non_biallelic*100.0)/totalSNP());\n\t}","id":101122,"modified_method":"public String toString() {\n\t\treturn String.format(\"%ntotal assessed in trio: %d%n   reference: %d (%3.2f)%n   total snp: %d%n      consistent snp: %d (%3.2f)%n      multiallelic: %d (%3.2f)%nper trio individual:%n   assessed:%n      mother: %d%n      father: %d%n      daughter: %d%n\" , \n\t\t\t\tassessed_loci, consistent_ref, ((double)consistent_ref*100.00)/assessed_loci,totalSNP(), consistent_snp, ((double)consistent_snp*100.0)/totalSNP(),\n\t\t\t\tnon_biallelic, ((double)non_biallelic*100.0)/totalSNP(),mom_assessed,dad_assessed,kid_assessed);\n//\t\treturn String.format(\"total assessed in trio: %d%n   reference: %d (%3.2f)%n   total snp: %d%n      consistent snp: %d (%3.2f)%n      multiallelic: %d (%3.2f)\" , \n//\t\t\t\tassessed_loci, consistent_ref, ((double)consistent_ref*100.00)/assessed_loci,totalSNP(), consistent_snp, ((double)consistent_snp*100.0)/totalSNP(),\n//\t\t\t\tnon_biallelic, ((double)non_biallelic*100.0)/totalSNP());\n\t}","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"public TrioConcordanceRecord add(TrioConcordanceRecord other) {\n\t\tthis.assessed_loci += other.assessed_loci;\n\t\tthis.consistent_ref += other.consistent_ref;\n\t\tthis.consistent_snp += other.consistent_snp;\n\t\tthis.inconsistent_snp += other.inconsistent_snp;\n\t\tthis.inconsistent_snp_in_parent += other.inconsistent_snp_in_parent;\n\t\tthis.inconsistent_snp_in_kid += other.inconsistent_snp_in_kid;\n\t\tthis.consistent_indels += other.consistent_indels;\n\t\tthis.inconsistent_indels += other.inconsistent_indels;\n\t\tthis.inconsistent_indels_in_parent += other.inconsistent_indels_in_parent;\n\t\tthis.inconsistent_indels_in_kid += other.inconsistent_indels_in_kid;\n\t\tthis.non_biallelic += other.non_biallelic;\n\t\t\n\t\treturn this;\n\t}","id":101123,"modified_method":"public TrioConcordanceRecord add(TrioConcordanceRecord other) {\n\t\tthis.assessed_loci += other.assessed_loci;\n\t\tthis.consistent_ref += other.consistent_ref;\n\t\tthis.consistent_snp += other.consistent_snp;\n\t\tthis.inconsistent_snp += other.inconsistent_snp;\n\t\tthis.inconsistent_snp_in_parent += other.inconsistent_snp_in_parent;\n\t\tthis.inconsistent_snp_in_kid += other.inconsistent_snp_in_kid;\n\t\tthis.consistent_indels += other.consistent_indels;\n\t\tthis.inconsistent_indels += other.inconsistent_indels;\n\t\tthis.inconsistent_indels_in_parent += other.inconsistent_indels_in_parent;\n\t\tthis.inconsistent_indels_in_kid += other.inconsistent_indels_in_kid;\n\t\tthis.non_biallelic += other.non_biallelic;\n\t\tthis.mom_assessed += other.mom_assessed;\n\t\tthis.dad_assessed += other.dad_assessed;\n\t\tthis.kid_assessed += other.kid_assessed;\n\t\tthis.mom_ref += other.mom_ref;\n\t\tthis.dad_ref += other.dad_ref;\n\t\tthis.kid_ref += other.kid_ref;\n\t\tthis.mom_snp += other.mom_snp;\n\t\tthis.dad_snp += other.dad_snp;\n\t\tthis.kid_snp += other.kid_snp;\n\t\t\n\t\treturn this;\n\t}","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String toMediumString() {\n        String s = String.format(\"%s:%s:%s\", getLocation().toString(), name, observedString);\n        if ( isSNP() ) s += \": SNP\";\n        else {\n        \tif ( isInsertion() ) s += \": Insertoin\";\n        \telse {\n        \t\tif ( isDeletion() ) s+= \": Deletion\";\n        \t\telse {\n        \t\t\tif ( isIndel() ) s+=\": Indel\";\n        \t\t\telse s+=\": Reference\";\n        \t\t}\n        \t}\n        }\n        return s;        \n    }","id":101124,"modified_method":"public String toMediumString() {\n    \t\n        String s = null;\n        if ( refBaseChar == '*' ) s = String.format(\"%s:%s:%s\", getLocation().toString(), name,observedString);\n        else s = String.format(\"%s:%s:%s/%s\", getLocation().toString(), name, observedAlleles.get(0),observedAlleles.get(1));\n        if ( isSNP() ) s += \": SNP\";\n        else {\n        \tif ( isInsertion() ) s += \": Insertion\";\n        \telse {\n        \t\tif ( isDeletion() ) s+= \": Deletion\";\n        \t\telse {\n        \t\t\tif ( isIndel() ) s+=\": Indel\";\n        \t\t\telse s+=\": Reference\";\n        \t\t}\n        \t}\n        }\n        return s;        \n    }","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void parseLine(final String[] parts) {\n//    \t          0          1             2         3                  4         5            6         7\n//    \t*     chrX     466           T         Y                170      170       88      32 ... (piles of read bases  and quals follow)\n//    \t *    chrX    141444     *     +CA/+CA       32       468     255     25     +CA     *       5       2       12      6\n       try {\n    \t   \n            String contig = parts[0];\n            long start = Long.parseLong(parts[1]) ;\n            \n            consensusScore = Double.parseDouble(parts[4]);\n            variantScore = Double.parseDouble(parts[5]);\n\n            refBaseChar = Character.toUpperCase(parts[2].charAt(0));\n            \n            parts[3] = parts[3].toUpperCase();\n            observedString = parts[3];\n            \n            observedAlleles = new ArrayList<String>(2);\n            \n            if ( refBaseChar == '*' ) {\n            \tparseIndels(parts[3]) ;\n            \tif ( varType == DELETION_VARIANT ) loc = new GenomeLoc(contig, start, start+eventLength);\n            \telse loc = new GenomeLoc(contig, start, start); // if it's not a deletion and we are biallelic, this got to be an insertion; otherwise the state is inconsistent!!!! \n            }\n            else {\n            \t// if the variant is a SNP or a reference base (i.e. no variant at all)\n            \tassert parts[3].length() == 1 : \"non-indel genotype is expected to be represented by a single letter\";\n            \trefBases = parts[2].toUpperCase();\n            \teventLength = 1;\n            \tloc = new GenomeLoc(contig, start, start+1);\n\n            \tchar ch = parts[3].charAt(0);\n            \t\n            \tswitch ( ch ) {\n            \tcase 'A':  observedAlleles.add(baseA); observedAlleles.add(baseA); break;\n            \tcase 'C':  observedAlleles.add(baseC); observedAlleles.add(baseC); break;\n            \tcase 'G':  observedAlleles.add(baseG); observedAlleles.add(baseG); break;\n            \tcase 'T':   observedAlleles.add(baseT); observedAlleles.add(baseT); break;\n            \tcase 'M': observedAlleles.add(baseA); observedAlleles.add(baseC); break;\n            \tcase 'R': observedAlleles.add(baseA); observedAlleles.add(baseG); break;\n            \tcase 'W': observedAlleles.add(baseA); observedAlleles.add(baseT); break;\n            \tcase 'S': observedAlleles.add(baseC); observedAlleles.add(baseG); break;\n            \tcase 'Y': observedAlleles.add(baseC); observedAlleles.add(baseT); break;\n            \tcase 'K': observedAlleles.add(baseG); observedAlleles.add(baseT); break;\n            \t}\n            \tif ( observedAlleles.get(0).charAt(0) == refBaseChar && observedAlleles.get(1).charAt(0) == refBaseChar ) varType = NO_VARIANT;\n            \telse {\n            \t\t// we know that at least one allele is non-ref;\n            \t\t// if one is ref and the other is non-ref, or if both are non ref but they are the same (i.e.\n            \t\t// homozygous non-ref), we still have 2 allelic variants at the site (e.g. one ref and one nonref)\n            \t\tvarType = SNP_VARIANT;\n                \tif ( observedAlleles.get(0).charAt(0) == refBaseChar || \n                \t\t\tobservedAlleles.get(1).charAt(0) == refBaseChar ||\n                \t\t\tobservedAlleles.get(0) == observedAlleles.get(1)\n                \t   ) nNonref = 1;\n                \telse nNonref = 2; // if both observations differ from ref and they are not equal to one another, then we get multiallelic site...\n            \t}\n            }\n        } catch ( RuntimeException e ) {\n            System.out.printf(\"  Exception caught during parsing Pileup line:  %s%n\", Utils.join(\" <=> \", parts));\n            throw e;\n        }\n        if ( nNonref > 1 ) System.out.println(\"SAM pileup: WARNING: multi-allelic variant at \"+ loc.toString());\n    }","id":101125,"modified_method":"@Override\n    public void parseLine(final String[] parts) {\n//    \t          0          1             2         3                  4         5            6         7\n//    \t*     chrX     466           T         Y                170      170       88      32 ... (piles of read bases  and quals follow)\n//    \t *    chrX    141444     *     +CA/+CA       32       468     255     25     +CA     *       5       2       12      6\n       try {\n    \t   \n            String contig = parts[0];\n            long start = Long.parseLong(parts[1]) ;\n            \n            consensusScore = Double.parseDouble(parts[4]);\n            variantScore = Double.parseDouble(parts[5]);\n\n            refBaseChar = Character.toUpperCase(parts[2].charAt(0));\n            \n            parts[3] = parts[3].toUpperCase();\n            observedString = parts[3];\n            \n            observedAlleles = new ArrayList<String>(2);\n            \n            if ( refBaseChar == '*' ) {\n            \tparseIndels(parts[3]) ;\n            \tif ( varType == DELETION_VARIANT ) loc = new GenomeLoc(contig, start, start+eventLength);\n            \telse loc = new GenomeLoc(contig, start, start); // if it's not a deletion and we are biallelic, this got to be an insertion; otherwise the state is inconsistent!!!! \n            }\n            else {\n            \t// if the variant is a SNP or a reference base (i.e. no variant at all)\n            \tassert parts[3].length() == 1 : \"non-indel genotype is expected to be represented by a single letter\";\n            \trefBases = parts[2].toUpperCase();\n            \teventLength = 1;\n            \tloc = new GenomeLoc(contig, start, start+1);\n\n            \tchar ch = parts[3].charAt(0);\n            \t\n            \tswitch ( ch ) {\n            \tcase 'A':  observedAlleles.add(baseA); observedAlleles.add(baseA); break;\n            \tcase 'C':  observedAlleles.add(baseC); observedAlleles.add(baseC); break;\n            \tcase 'G':  observedAlleles.add(baseG); observedAlleles.add(baseG); break;\n            \tcase 'T':   observedAlleles.add(baseT); observedAlleles.add(baseT); break;\n            \tcase 'M': observedAlleles.add(baseA); observedAlleles.add(baseC); break;\n            \tcase 'R': observedAlleles.add(baseA); observedAlleles.add(baseG); break;\n            \tcase 'W': observedAlleles.add(baseA); observedAlleles.add(baseT); break;\n            \tcase 'S': observedAlleles.add(baseC); observedAlleles.add(baseG); break;\n            \tcase 'Y': observedAlleles.add(baseC); observedAlleles.add(baseT); break;\n            \tcase 'K': observedAlleles.add(baseG); observedAlleles.add(baseT); break;\n            \t}\n            \tif ( observedAlleles.get(0).charAt(0) == refBaseChar && observedAlleles.get(1).charAt(0) == refBaseChar ) varType = NO_VARIANT;\n            \telse {\n            \t\t// we know that at least one allele is non-ref;\n            \t\t// if one is ref and the other is non-ref, or if both are non ref but they are the same (i.e.\n            \t\t// homozygous non-ref), we still have 2 allelic variants at the site (e.g. one ref and one nonref)\n            \t\tvarType = SNP_VARIANT;\n                \tif ( observedAlleles.get(0).charAt(0) == refBaseChar || \n                \t\t\tobservedAlleles.get(1).charAt(0) == refBaseChar ||\n                \t\t\tobservedAlleles.get(0) == observedAlleles.get(1)\n                \t   ) nNonref = 1;\n                \telse nNonref = 2; // if both observations differ from ref and they are not equal to one another, then we get multiallelic site...\n            \t}\n            }\n        } catch ( RuntimeException e ) {\n            System.out.printf(\"  Exception caught during parsing Pileup line:  %s%n\", Utils.join(\" <=> \", parts));\n            throw e;\n        }\n        if ( nNonref > 1 ) System.out.println(\"SAM pileup: WARNING: multi-allelic variant :  (\"+refBaseChar+\") -->\"+toMediumString());\n    }","commit_id":"b4136b6d6e40175b34dffeba560c9f4cb2d64b79","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void addTransforms(List<ETLStage> stageConfigs, List<Transformation> pipeline,\n                               List<StageMetrics> stageMetrics, List<String> transformIds,\n                               MapReduceContext context) throws Exception {\n      Preconditions.checkArgument(stageConfigs.size() == transformIds.size());\n\n      for (int i = 0; i < stageConfigs.size(); i++) {\n        ETLStage stageConfig = stageConfigs.get(i);\n        String transformId = transformIds.get(i);\n        Transform transform = context.newPluginInstance(transformId);\n        BatchTransformContext transformContext = new BatchTransformContext(context, mapperMetrics, transformId);\n        LOG.debug(\"Transform Stage : {}\", stageConfig.getName());\n        LOG.debug(\"Transform Class : {}\", transform.getClass().getName());\n        transform.initialize(transformContext);\n        pipeline.add(transform);\n        transforms.add(transform);\n        stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.TRANSFORM, stageConfig.getName()));\n      }\n    }","id":101126,"modified_method":"private void addTransforms(List<ETLStage> stageConfigs, List<Transformation> pipeline,\n                               List<StageMetrics> stageMetrics, List<String> transformIds,\n                               MapReduceContext context) throws Exception {\n      Preconditions.checkArgument(stageConfigs.size() == transformIds.size());\n\n      for (int i = 0; i < stageConfigs.size(); i++) {\n        ETLStage stageConfig = stageConfigs.get(i);\n        String transformId = transformIds.get(i);\n        Transform transform = context.newPluginInstance(transformId);\n        BatchTransformContext transformContext = new BatchTransformContext(context, mapperMetrics, transformId);\n        LOG.debug(\"Transform Stage : {}\", stageConfig.getName());\n        LOG.debug(\"Transform Class : {}\", transform.getClass().getName());\n        transform.initialize(transformContext);\n        pipeline.add(transform);\n        transforms.add(transform);\n        stageMetrics.add(new StageMetrics(mapperMetrics, PluginID.from(transformId)));\n      }\n    }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void initialize(MapReduceContext context) throws Exception {\n      Map<String, String> runtimeArgs = context.getRuntimeArguments();\n      ETLBatchConfig etlConfig = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n      String sourcePluginId = runtimeArgs.get(Constants.Source.PLUGINID);\n      String sinkPluginId = runtimeArgs.get(Constants.Sink.PLUGINID);\n      List<String> transformIds = GSON.fromJson(runtimeArgs.get(Constants.Transform.PLUGINIDS), STRING_LIST_TYPE);\n\n\n      List<ETLStage> stageList = etlConfig.getTransforms();\n      List<Transformation> pipeline = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      List<StageMetrics> stageMetrics = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      transforms = Lists.newArrayListWithCapacity(stageList.size());\n\n      BatchSource source = context.newPluginInstance(sourcePluginId);\n      BatchSourceContext batchSourceContext = new MapReduceSourceContext(context, mapperMetrics, sourcePluginId);\n      source.initialize(batchSourceContext);\n      pipeline.add(source);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SOURCE, etlConfig.getSource().getName()));\n\n      addTransforms(stageList, pipeline, stageMetrics, transformIds, context);\n\n      BatchSink sink = context.newPluginInstance(sinkPluginId);\n      BatchSinkContext batchSinkContext = new MapReduceSinkContext(context, mapperMetrics, sinkPluginId);\n      sink.initialize(batchSinkContext);\n      pipeline.add(sink);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SINK, etlConfig.getSink().getName()));\n\n      transformExecutor = new TransformExecutor<>(pipeline, stageMetrics);\n    }","id":101127,"modified_method":"@Override\n    public void initialize(MapReduceContext context) throws Exception {\n      Map<String, String> runtimeArgs = context.getRuntimeArguments();\n      ETLBatchConfig etlConfig = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n      String sourcePluginId = runtimeArgs.get(Constants.Source.PLUGINID);\n      String sinkPluginId = runtimeArgs.get(Constants.Sink.PLUGINID);\n      List<String> transformIds = GSON.fromJson(runtimeArgs.get(Constants.Transform.PLUGINIDS), STRING_LIST_TYPE);\n\n\n      List<ETLStage> stageList = etlConfig.getTransforms();\n      List<Transformation> pipeline = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      List<StageMetrics> stageMetrics = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      transforms = Lists.newArrayListWithCapacity(stageList.size());\n\n      BatchSource source = context.newPluginInstance(sourcePluginId);\n      BatchSourceContext batchSourceContext = new MapReduceSourceContext(context, mapperMetrics, sourcePluginId);\n      source.initialize(batchSourceContext);\n      pipeline.add(source);\n      stageMetrics.add(new StageMetrics(mapperMetrics, PluginID.from(sourcePluginId)));\n\n      addTransforms(stageList, pipeline, stageMetrics, transformIds, context);\n\n      BatchSink sink = context.newPluginInstance(sinkPluginId);\n      BatchSinkContext batchSinkContext = new MapReduceSinkContext(context, mapperMetrics, sinkPluginId);\n      sink.initialize(batchSinkContext);\n      pipeline.add(sink);\n      stageMetrics.add(new StageMetrics(mapperMetrics, PluginID.from(sinkPluginId)));\n\n      transformExecutor = new TransformExecutor<>(pipeline, stageMetrics);\n    }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configureAdapter(String adapterName, T etlConfig, AdapterConfigurer configurer) throws Exception {\n    ETLStage sourceConfig = etlConfig.getSource();\n    ETLStage sinkConfig = etlConfig.getSink();\n    List<ETLStage> transformConfigs = etlConfig.getTransforms();\n    String sourcePluginId = String.format(\"%s%s%s\", Constants.Source.PLUGINTYPE, Constants.ID_SEPARATOR,\n                                          sourceConfig.getName());\n    String sinkPluginId = String.format(\"%s%s%s\", Constants.Sink.PLUGINTYPE, Constants.ID_SEPARATOR,\n                                        sinkConfig.getName());\n\n    // Instantiate Source, Transforms, Sink stages.\n    // Use the plugin name as the plugin id for source and sink stages since there can be only one source and one sink.\n    PluginProperties sourceProperties = getPluginProperties(sourceConfig);\n    PipelineConfigurable source = configurer.usePlugin(Constants.Source.PLUGINTYPE, sourceConfig.getName(),\n                                                       sourcePluginId, sourceProperties);\n    if (source == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Source.PLUGINTYPE, sourceConfig.getName()));\n    }\n\n    PluginProperties sinkProperties = getPluginProperties(sinkConfig);\n    PipelineConfigurable sink = configurer.usePlugin(Constants.Sink.PLUGINTYPE, sinkConfig.getName(), sinkPluginId,\n                                                     sinkProperties);\n    if (sink == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Sink.PLUGINTYPE, sinkConfig.getName()));\n    }\n\n    // Store transform id list to be serialized and passed to the driver program\n    List<String> transformIds = Lists.newArrayListWithCapacity(transformConfigs.size());\n    List<Transformation> transforms = Lists.newArrayListWithCapacity(transformConfigs.size());\n    for (int i = 0; i < transformConfigs.size(); i++) {\n      ETLStage transformConfig = transformConfigs.get(i);\n\n      // Generate a transformId based on transform name and the array index (since there could\n      // multiple transforms - ex, N filter transforms in the same pipeline)\n      String transformId = String.format(\"%s%s%d\", transformConfig.getName(), Constants.ID_SEPARATOR, i);\n      PluginProperties transformProperties = getPluginProperties(transformConfig);\n      Transform transformObj = configurer.usePlugin(Constants.Transform.PLUGINTYPE, transformConfig.getName(),\n                                                    transformId, transformProperties);\n      if (transformObj == null) {\n        throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                         Constants.Transform.PLUGINTYPE, transformConfig.getName()));\n      }\n\n      transformIds.add(transformId);\n      transforms.add(transformObj);\n    }\n\n    // Validate Source -> Transform -> Sink hookup\n    validateStages(source, sink, transforms);\n\n    configure(source, configurer, sourcePluginId);\n    configure(sink, configurer, sinkPluginId);\n\n    configurer.addRuntimeArgument(Constants.ADAPTER_NAME, adapterName);\n    configurer.addRuntimeArgument(Constants.Source.PLUGINID, sourcePluginId);\n    configurer.addRuntimeArgument(Constants.Sink.PLUGINID, sinkPluginId);\n    configurer.addRuntimeArgument(Constants.Transform.PLUGINIDS, GSON.toJson(transformIds));\n\n    Resources resources = etlConfig.getResources();\n    if (resources != null) {\n      configurer.setResources(resources);\n    }\n  }","id":101128,"modified_method":"@Override\n  public void configureAdapter(String adapterName, T etlConfig, AdapterConfigurer configurer) throws Exception {\n    ETLStage sourceConfig = etlConfig.getSource();\n    ETLStage sinkConfig = etlConfig.getSink();\n    List<ETLStage> transformConfigs = etlConfig.getTransforms();\n    String sourcePluginId = PluginID.from(Constants.Source.PLUGINTYPE, sourceConfig.getName(), 1).getID();\n    String sinkPluginId =\n      PluginID.from(Constants.Sink.PLUGINTYPE,  sinkConfig.getName(), 2 + transformConfigs.size()).getID();\n\n    // Instantiate Source, Transforms, Sink stages.\n    // Use the plugin name as the plugin id for source and sink stages since there can be only one source and one sink.\n    PluginProperties sourceProperties = getPluginProperties(sourceConfig);\n    PipelineConfigurable source = configurer.usePlugin(Constants.Source.PLUGINTYPE, sourceConfig.getName(),\n                                                       sourcePluginId, sourceProperties);\n    if (source == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Source.PLUGINTYPE, sourceConfig.getName()));\n    }\n\n    PluginProperties sinkProperties = getPluginProperties(sinkConfig);\n    PipelineConfigurable sink = configurer.usePlugin(Constants.Sink.PLUGINTYPE, sinkConfig.getName(),\n                                                     sinkPluginId, sinkProperties);\n    if (sink == null) {\n      throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                       Constants.Sink.PLUGINTYPE, sinkConfig.getName()));\n    }\n\n    // Store transform id list to be serialized and passed to the driver program\n    List<String> transformIds = Lists.newArrayListWithCapacity(transformConfigs.size());\n    List<Transformation> transforms = Lists.newArrayListWithCapacity(transformConfigs.size());\n    for (int i = 0; i < transformConfigs.size(); i++) {\n      ETLStage transformConfig = transformConfigs.get(i);\n\n      // Generate a transformId based on transform name and the array index (since there could\n      // multiple transforms - ex, N filter transforms in the same pipeline)\n      // stage number starts from 1, plus source is always #1, so add 2 for stage number.\n      String transformId = PluginID.from(Constants.Transform.PLUGINTYPE, transformConfig.getName(), 2 + i).getID();\n      PluginProperties transformProperties = getPluginProperties(transformConfig);\n      Transform transformObj = configurer.usePlugin(Constants.Transform.PLUGINTYPE, transformConfig.getName(),\n                                                    transformId, transformProperties);\n      if (transformObj == null) {\n        throw new IllegalArgumentException(String.format(\"No Plugin of type '%s' named '%s' was found\",\n                                                         Constants.Transform.PLUGINTYPE, transformConfig.getName()));\n      }\n\n      transformIds.add(transformId);\n      transforms.add(transformObj);\n    }\n\n    // Validate Source -> Transform -> Sink hookup\n    validateStages(source, sink, transforms);\n\n    configure(source, configurer, sourcePluginId);\n    configure(sink, configurer, sinkPluginId);\n\n    configurer.addRuntimeArgument(Constants.ADAPTER_NAME, adapterName);\n    configurer.addRuntimeArgument(Constants.Source.PLUGINID, sourcePluginId);\n    configurer.addRuntimeArgument(Constants.Sink.PLUGINID, sinkPluginId);\n    configurer.addRuntimeArgument(Constants.Transform.PLUGINIDS, GSON.toJson(transformIds));\n\n    Resources resources = etlConfig.getResources();\n    if (resources != null) {\n      configurer.setResources(resources);\n    }\n  }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"private List<Transformation> initializeTransforms(WorkerContext context, List<ETLStage> stages) throws Exception {\n    List<String> transformIds = GSON.fromJson(context.getRuntimeArguments().get(Constants.Transform.PLUGINIDS),\n                                              STRING_LIST_TYPE);\n    List<Transformation> transforms = Lists.newArrayList();\n\n    Preconditions.checkArgument(transformIds != null);\n    Preconditions.checkArgument(stages.size() == transformIds.size());\n    transformMetrics = Lists.newArrayListWithCapacity(stages.size());\n    for (int i = 0; i < stages.size(); i++) {\n      ETLStage stage = stages.get(i);\n      String transformId = transformIds.get(i);\n      try {\n        Transform transform = context.newPluginInstance(transformId);\n        RealtimeTransformContext transformContext = new RealtimeTransformContext(context, metrics, transformId);\n        LOG.debug(\"Transform Stage : {}\", stage.getName());\n        LOG.debug(\"Transform Class : {}\", transform.getClass().getName());\n        transform.initialize(transformContext);\n        transforms.add(transform);\n        transformMetrics.add(new StageMetrics(metrics, StageMetrics.Type.TRANSFORM, stage.getName()));\n      } catch (InstantiationException e) {\n        LOG.error(\"Unable to instantiate Transform : {}\", stage.getName(), e);\n        Throwables.propagate(e);\n      }\n    }\n    return transforms;\n  }","id":101129,"modified_method":"private List<Transformation> initializeTransforms(WorkerContext context, List<ETLStage> stages) throws Exception {\n    List<String> transformIds = GSON.fromJson(context.getRuntimeArguments().get(Constants.Transform.PLUGINIDS),\n                                              STRING_LIST_TYPE);\n    List<Transformation> transforms = Lists.newArrayList();\n\n    Preconditions.checkArgument(transformIds != null);\n    Preconditions.checkArgument(stages.size() == transformIds.size());\n    transformMetrics = Lists.newArrayListWithCapacity(stages.size());\n    for (int i = 0; i < stages.size(); i++) {\n      ETLStage stage = stages.get(i);\n      String transformId = transformIds.get(i);\n      try {\n        Transform transform = context.newPluginInstance(transformId);\n        RealtimeTransformContext transformContext = new RealtimeTransformContext(context, metrics, transformId);\n        LOG.debug(\"Transform Stage : {}\", stage.getName());\n        LOG.debug(\"Transform Class : {}\", transform.getClass().getName());\n        transform.initialize(transformContext);\n        transforms.add(transform);\n        transformMetrics.add(new StageMetrics(metrics, PluginID.from(transformId)));\n      } catch (InstantiationException e) {\n        LOG.error(\"Unable to instantiate Transform : {}\", stage.getName(), e);\n        Throwables.propagate(e);\n      }\n    }\n    return transforms;\n  }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"private void initializeSource(WorkerContext context, ETLStage stage) throws Exception {\n    String sourcePluginId = context.getRuntimeArguments().get(Constants.Source.PLUGINID);\n    source = context.newPluginInstance(sourcePluginId);\n    RealtimeContext sourceContext = new WorkerRealtimeContext(context, metrics, sourcePluginId);\n    LOG.debug(\"Source Stage : {}\", stage.getName());\n    LOG.debug(\"Source Class : {}\", source.getClass().getName());\n    source.initialize(sourceContext);\n    sourceEmitter = new DefaultEmitter(new StageMetrics(metrics, StageMetrics.Type.SOURCE, stage.getName()));\n  }","id":101130,"modified_method":"private void initializeSource(WorkerContext context, ETLStage stage) throws Exception {\n    String sourcePluginId = context.getRuntimeArguments().get(Constants.Source.PLUGINID);\n    source = context.newPluginInstance(sourcePluginId);\n    RealtimeContext sourceContext = new WorkerRealtimeContext(context, metrics, sourcePluginId);\n    LOG.debug(\"Source Stage : {}\", stage.getName());\n    LOG.debug(\"Source Class : {}\", source.getClass().getName());\n    source.initialize(sourceContext);\n    sourceEmitter = new DefaultEmitter(new StageMetrics(metrics, PluginID.from(sourcePluginId)));\n  }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  private void initializeSink(WorkerContext context, ETLStage stage) throws Exception {\n    String sinkPluginId = context.getRuntimeArguments().get(Constants.Sink.PLUGINID);\n    sink = context.newPluginInstance(sinkPluginId);\n    RealtimeContext sinkContext = new WorkerRealtimeContext(context, metrics, sinkPluginId);\n    LOG.debug(\"Sink Stage : {}\", stage.getName());\n    LOG.debug(\"Sink Class : {}\", sink.getClass().getName());\n    sink.initialize(sinkContext);\n    sink = new TrackedRealtimeSink(sink, metrics, stage.getName());\n  }","id":101131,"modified_method":"@SuppressWarnings(\"unchecked\")\n  private void initializeSink(WorkerContext context, ETLStage stage) throws Exception {\n    String sinkPluginId = context.getRuntimeArguments().get(Constants.Sink.PLUGINID);\n    sink = context.newPluginInstance(sinkPluginId);\n    RealtimeContext sinkContext = new WorkerRealtimeContext(context, metrics, sinkPluginId);\n    LOG.debug(\"Sink Stage : {}\", stage.getName());\n    LOG.debug(\"Sink Class : {}\", sink.getClass().getName());\n    sink.initialize(sinkContext);\n    sink = new TrackedRealtimeSink(sink, metrics, PluginID.from(sinkPluginId));\n  }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"public StageMetrics(Metrics metrics, Type stageType, String name) {\n    this.metrics = metrics;\n    this.prefix = stageType.toString() + \".\" + name + \".\";\n  }","id":101132,"modified_method":"public StageMetrics(Metrics metrics, PluginID id) {\n    this.metrics = metrics;\n    this.prefix = id.getMetricsContext() + \".\";\n  }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"public TrackedRealtimeSink(RealtimeSink<T> sink, Metrics metrics, String name) {\n    this.sink = sink;\n    this.metrics = new StageMetrics(metrics, StageMetrics.Type.SINK, name);\n  }","id":101133,"modified_method":"public TrackedRealtimeSink(RealtimeSink<T> sink, Metrics metrics, PluginID id) {\n    this.sink = sink;\n    this.metrics = new StageMetrics(metrics, id);\n  }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTransforms() throws Exception {\n    MockMetrics mockMetrics = new MockMetrics();\n    List<Transformation> transforms = Lists.<Transformation>newArrayList(\n      new IntToDouble(), new Filter(100d), new DoubleToString());\n    List<StageMetrics> stageMetrics = Lists.newArrayList(\n      new StageMetrics(mockMetrics, StageMetrics.Type.SOURCE, \"first\"),\n      new StageMetrics(mockMetrics, StageMetrics.Type.TRANSFORM, \"second\"),\n      new StageMetrics(mockMetrics, StageMetrics.Type.SINK, \"third\")\n    );\n    TransformExecutor<Integer, String> executor = new TransformExecutor<>(transforms, stageMetrics);\n\n    List<String> results = Lists.newArrayList(executor.runOneIteration(1));\n    Assert.assertTrue(results.isEmpty());\n    Assert.assertEquals(3, mockMetrics.getCount(\"source.first.records.out\"));\n    Assert.assertEquals(0, mockMetrics.getCount(\"transform.second.records.out\"));\n    Assert.assertEquals(0, mockMetrics.getCount(\"sink.third.records.out\"));\n\n    results = Lists.newArrayList(executor.runOneIteration(10));\n    Assert.assertEquals(1, results.size());\n    Assert.assertEquals(\"1000.0\", results.get(0));\n    Assert.assertEquals(6, mockMetrics.getCount(\"source.first.records.out\"));\n    Assert.assertEquals(1, mockMetrics.getCount(\"transform.second.records.out\"));\n    Assert.assertEquals(1, mockMetrics.getCount(\"sink.third.records.out\"));\n\n    results = Lists.newArrayList(executor.runOneIteration(100));\n    Assert.assertEquals(2, results.size());\n    Assert.assertEquals(\"1000.0\", results.get(0));\n    Assert.assertEquals(\"10000.0\", results.get(1));\n    Assert.assertEquals(9, mockMetrics.getCount(\"source.first.records.out\"));\n    Assert.assertEquals(3, mockMetrics.getCount(\"transform.second.records.out\"));\n    Assert.assertEquals(3, mockMetrics.getCount(\"sink.third.records.out\"));\n  }","id":101134,"modified_method":"@Test\n  public void testTransforms() throws Exception {\n    MockMetrics mockMetrics = new MockMetrics();\n    List<Transformation> transforms = Lists.<Transformation>newArrayList(\n      new IntToDouble(), new Filter(100d), new DoubleToString());\n    List<StageMetrics> stageMetrics = Lists.newArrayList(\n      new StageMetrics(mockMetrics, PluginID.from(Constants.Source.PLUGINTYPE, \"first\", 1)),\n      new StageMetrics(mockMetrics, PluginID.from(Constants.Transform.PLUGINTYPE, \"second\", 2)),\n      new StageMetrics(mockMetrics, PluginID.from(Constants.Sink.PLUGINTYPE, \"third\", 3))\n    );\n    TransformExecutor<Integer, String> executor = new TransformExecutor<>(transforms, stageMetrics);\n\n    List<String> results = Lists.newArrayList(executor.runOneIteration(1));\n    Assert.assertTrue(results.isEmpty());\n    Assert.assertEquals(3, mockMetrics.getCount(\"source.first.1.records.out\"));\n    Assert.assertEquals(0, mockMetrics.getCount(\"transform.second.2.records.out\"));\n    Assert.assertEquals(0, mockMetrics.getCount(\"sink.third.3.records.out\"));\n\n    results = Lists.newArrayList(executor.runOneIteration(10));\n    Assert.assertEquals(1, results.size());\n    Assert.assertEquals(\"1000.0\", results.get(0));\n    Assert.assertEquals(6, mockMetrics.getCount(\"source.first.1.records.out\"));\n    Assert.assertEquals(1, mockMetrics.getCount(\"transform.second.2.records.out\"));\n    Assert.assertEquals(1, mockMetrics.getCount(\"sink.third.3.records.out\"));\n\n    results = Lists.newArrayList(executor.runOneIteration(100));\n    Assert.assertEquals(2, results.size());\n    Assert.assertEquals(\"1000.0\", results.get(0));\n    Assert.assertEquals(\"10000.0\", results.get(1));\n    Assert.assertEquals(9, mockMetrics.getCount(\"source.first.1.records.out\"));\n    Assert.assertEquals(3, mockMetrics.getCount(\"transform.second.2.records.out\"));\n    Assert.assertEquals(3, mockMetrics.getCount(\"sink.third.3.records.out\"));\n  }","commit_id":"c46b2fd1e4344f4ba66a24ba270246344b20a1cc","url":"https://github.com/caskdata/cdap"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem, Sequence resultSequence)\n\t\tthrows XPathException {\n\t\ttry {\n\t\t\t// Save the local variable stack\n\t\t\tLocalVariable mark = context.markLocalVariables(false);\n\t\t\t\n\t\t\t// evaluate input sequence\n\t\t\tSequence in = inputSequence.eval(null, null);\n\t\t\t\n\t\t\t// Declare the iteration variable\n\t\t\tLocalVariable var = new LocalVariable(QName.parse(context, varName, null));\n\t\t\tvar.setSequenceType(sequenceType);\n\t\t\tcontext.declareVariable(var);\n\t\t\tclearContext(in);\n\t\t\tvar.setValue(in);\n\t\t\tvar.checkType();\n\t\t\t\n\t\t\tSequence filtered = null;\n\t\t\tif (whereExpr != null) {\n\t\t\t\tfiltered = applyWhereExpression(null);\n\t\t\t\t// TODO: don't use returnsType here\n\t\t\t\tif (filtered.getItemType() == Type.BOOLEAN) {\n\t\t\t\t\tif (!filtered.effectiveBooleanValue())\n\t\t\t\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t\t\t} else if (filtered.getLength() == 0)\n\t\t\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t\t}\n\t\t\t\n\t\t\t// Check if we can speed up the processing of the \"order by\" clause.\n\t\t\tboolean fastOrderBy = checkOrderSpecs(in);\n\t\t\t\n\t\t\t//\tPreorderedValueSequence applies the order specs to all items\n\t\t\t// in one single processing step\n\t\t\tif(fastOrderBy) {\n\t\t\t\tin = new PreorderedValueSequence(orderSpecs, in.toNodeSet());\n\t\t\t}\n\t\t\t\n\t\t\t// Otherwise, if there's an order by clause, wrap the result into\n\t\t\t// an OrderedValueSequence. OrderedValueSequence will compute\n\t\t\t// order expressions for every item when it is added to the result sequence.\n\t\t\tif(resultSequence == null) {\n\t\t\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t\t\tresultSequence = new OrderedValueSequence(orderSpecs, in.getLength());\n\t\t\t\telse\n\t\t\t\t\tresultSequence = new ValueSequence();\n\t\t\t}\n\t\t\t\n\t\t\tif(returnExpr instanceof BindingExpression) {\n\t\t\t\t((BindingExpression)returnExpr).eval(null, null, resultSequence);\n\t\t\t} else {\n\t\t\t\tin = returnExpr.eval(null);\n\t\t\t\tresultSequence.addAll(in);\n\t\t\t}\n\t\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t\t((OrderedValueSequence)resultSequence).sort();\n\t\t\t\n\t\t\t// Restore the local variable stack\n\t\t\tcontext.popLocalVariables(mark);\n\t\t} catch (XPathException e) {\n\t\t\t// add stack trace information (line numbers)\n\t\t\tthrow new XPathException(getASTNode(), e.getMessage(), e);\n\t\t}\n\t\treturn resultSequence;\n\t}","id":101135,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem, Sequence resultSequence)\n\t\tthrows XPathException {\n\t\ttry {\n\t\t\t// Save the local variable stack\n\t\t\tLocalVariable mark = context.markLocalVariables(false);\n\t\t\t\n\t\t\t// evaluate input sequence\n\t\t\tSequence in = inputSequence.eval(null, null);\n\t\t\t\n\t\t\t// Declare the iteration variable\n\t\t\tLocalVariable var = new LocalVariable(QName.parse(context, varName, null));\n\t\t\tvar.setSequenceType(sequenceType);\n\t\t\tcontext.declareVariable(var);\n\t\t\tclearContext(in);\n\t\t\tvar.setValue(in);\n\t\t\tvar.checkType();\n\t\t\t\n\t\t\tSequence filtered = null;\n\t\t\tif (whereExpr != null) {\n\t\t\t\tfiltered = applyWhereExpression(null);\n\t\t\t\t// TODO: don't use returnsType here\n\t\t\t\tif (filtered.getItemType() == Type.BOOLEAN) {\n\t\t\t\t\tif (!filtered.effectiveBooleanValue())\n\t\t\t\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t\t\t} else if (filtered.getLength() == 0)\n\t\t\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t\t}\n\t\t\t\n\t\t\t// Check if we can speed up the processing of the \"order by\" clause.\n\t\t\tboolean fastOrderBy = checkOrderSpecs(in);\n\t\t\t\n\t\t\t//\tPreorderedValueSequence applies the order specs to all items\n\t\t\t// in one single processing step\n\t\t\tif(fastOrderBy) {\n\t\t\t\tin = new PreorderedValueSequence(orderSpecs, in.toNodeSet());\n\t\t\t}\n\t\t\t\n\t\t\t// Otherwise, if there's an order by clause, wrap the result into\n\t\t\t// an OrderedValueSequence. OrderedValueSequence will compute\n\t\t\t// order expressions for every item when it is added to the result sequence.\n\t\t\tif(resultSequence == null) {\n\t\t\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t\t\tresultSequence = new OrderedValueSequence(orderSpecs, in.getLength());\n\t\t\t\telse\n\t\t\t\t\tresultSequence = new ValueSequence();\n\t\t\t}\n\t\t\t\n\t\t\tif(returnExpr instanceof BindingExpression) {\n\t\t\t\t((BindingExpression)returnExpr).eval(null, null, resultSequence);\n\t\t\t} else {\n\t\t\t\tin = returnExpr.eval(null);\n\t\t\t\tresultSequence.addAll(in);\n\t\t\t}\n\t\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t\t((OrderedValueSequence)resultSequence).sort();\n\t\t\t\n\t\t\t// Restore the local variable stack\n\t\t\tcontext.popLocalVariables(mark);\n\t\t} catch (XPathException e) {\n\t\t\t// add stack trace information (line numbers)\n            if (e.getLine() == 0)\n                e.setASTNode(getASTNode());\n            throw e;\n\t\t}\n\t\treturn resultSequence;\n\t}","commit_id":"bab8495c5a2cd1d9b7e5e8cb05e3eecc7ecf2020","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }       \n        \n\t    List args = getParameterValues(contextSequence, contextItem);\n\t\tboolean cacheIsValid = false;\n\t\tif(cachedArgs != null)\n\t\t    cacheIsValid = compareArguments(cachedArgs, args);\n\t\tif(cacheIsValid) {\n\t\t    // if the expression occurs in a nested context, we might have cached the\n            // document set\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().end(this, \"fn:collection: loading documents\", cached);                 \n\t\t    return cached;\n        }\n        \n\t\t// check if the loaded documents should remain locked\n        boolean lockOnLoad = context.lockDocumentsOnLoad();\n        \n         // build the document set\n\t\tDocumentSet docs = new DocumentSet(521);\n\t    try {\n\t\t\tfor (int i = 0; i < args.size(); i++) {\n\t\t\t\tString next = (String)args.get(i);\n\t\t\t    Collection coll = context.getBroker().getCollection(XmldbURI.xmldbUriFor(next));            \n\t\t\t    if(coll != null)\n\t\t\t    \tcoll.allDocs(context.getBroker(), docs, includeSubCollections, true);          \n\t\t\t}\n        } catch (URISyntaxException e) {\n            throw new XPathException(getASTNode(), \"Invalid resource uri\",e);\n        }\n        // iterate through all docs and create the node set\n\t\tNodeSet result = new ExtArrayNodeSet(docs.getLength(), 1);\n\t\tLock dlock;\n\t\tDocumentImpl doc;\n\t\tfor (Iterator i = docs.iterator(); i.hasNext();) {\n\t\t    doc = (DocumentImpl)i.next();\n\t\t    dlock = doc.getUpdateLock();\n\t\t    try {\n\t\t        dlock.acquire(Lock.READ_LOCK);\n\t\t        result.add(new NodeProxy(doc)); // , -1, Node.DOCUMENT_NODE));\n                if(lockOnLoad) {\n                    LOG.debug(\"Locking document: \" + doc.getURI());\n                    context.getLockedDocuments().add(doc);\n                }\n\t\t    } catch (LockException e) {\n                LOG.info(\"Could not acquire read lock on document \" + doc.getURI());\n            } finally {\n                if(!lockOnLoad)\n                    dlock.release(Lock.READ_LOCK);\n\t\t    }\n\t\t}\n\t\tcached = result;\n\t\tcachedArgs = args;\n        cachedDocs = docs;\n        registerUpdateListener();\n        \n        if (context.getProfiler().isEnabled())           \n               context.getProfiler().end(this, \"\", result);\n       \n\t\treturn result;\n\t}","id":101136,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }       \n        \n\t    List args = getParameterValues(contextSequence, contextItem);\n\t\tboolean cacheIsValid = false;\n\t\tif(cachedArgs != null)\n\t\t    cacheIsValid = compareArguments(cachedArgs, args);\n\t\tif(cacheIsValid) {\n\t\t    // if the expression occurs in a nested context, we might have cached the\n            // document set\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().end(this, \"fn:collection: loading documents\", cached);                 \n\t\t    return cached;\n        }\n        \n\t\t// check if the loaded documents should remain locked\n        boolean lockOnLoad = context.lockDocumentsOnLoad();\n        \n         // build the document set\n\t\tDocumentSet docs = new DocumentSet(521);\n\t    try {\n\t\t\tfor (int i = 0; i < args.size(); i++) {\n\t\t\t\tString next = (String)args.get(i);\n\t\t\t    Collection coll = context.getBroker().getCollection(new AnyURIValue(next).toXmldbURI());            \n\t\t\t    if(coll != null)\n\t\t\t    \tcoll.allDocs(context.getBroker(), docs, includeSubCollections, true);          \n\t\t\t}\n        } catch (XPathException e) { //From AnyURIValue constructor\n        \te.setASTNode(getASTNode());\n            throw e;\n        }\n        // iterate through all docs and create the node set\n\t\tNodeSet result = new ExtArrayNodeSet(docs.getLength(), 1);\n\t\tLock dlock;\n\t\tDocumentImpl doc;\n\t\tfor (Iterator i = docs.iterator(); i.hasNext();) {\n\t\t    doc = (DocumentImpl)i.next();\n\t\t    dlock = doc.getUpdateLock();\n\t\t    try {\n\t\t        dlock.acquire(Lock.READ_LOCK);\n\t\t        result.add(new NodeProxy(doc)); // , -1, Node.DOCUMENT_NODE));\n                if(lockOnLoad) {\n                    LOG.debug(\"Locking document: \" + doc.getURI());\n                    context.getLockedDocuments().add(doc);\n                }\n\t\t    } catch (LockException e) {\n                LOG.info(\"Could not acquire read lock on document \" + doc.getURI());\n            } finally {\n                if(!lockOnLoad)\n                    dlock.release(Lock.READ_LOCK);\n\t\t    }\n\t\t}\n\t\tcached = result;\n\t\tcachedArgs = args;\n        cachedDocs = docs;\n        registerUpdateListener();\n        \n        if (context.getProfiler().isEnabled())           \n               context.getProfiler().end(this, \"\", result);\n       \n\t\treturn result;\n\t}","commit_id":"1fd165b221ea632c9f34db277718f325c77e3f6d","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t    DocumentSet docs = null;\n\t    Sequence result = null;\n\t    // check if the loaded documents should remain locked\n        boolean lockOnLoad = context.lockDocumentsOnLoad();\n        boolean cacheIsValid = false;\n\t    if (getArgumentCount() == 0) {\n\t        if(cached != null) {\n\t            result = cached;\n\t            docs = cachedDocs;\n\t        } else {\n\t\t        docs = new DocumentSet();\n\t\t        context.getBroker().getAllXMLResources(docs);\n\t        }\n\t    } else {\n\t\t    List args = getParameterValues(contextSequence, contextItem);\n\t\t\tif(cachedArgs != null)\n\t\t\t    cacheIsValid = compareArguments(cachedArgs, args);\n\t\t\tif(cacheIsValid) {\n\t\t\t    result = cached;\n\t\t\t    docs = cachedDocs;\n\t\t\t} else {\n\t\t\t\tdocs = new DocumentSet();\n\t\t\t\tfor(int i = 0; i < args.size(); i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tXmldbURI next = XmldbURI.xmldbUriFor((String)args.get(i));\n\t\t\t\t\t\tif(next.getCollectionPath().length() == 0) {\n\t\t\t\t\t\t\tthrow new XPathException(\"Invalid argument to fn:doc function: empty string is not allowed here.\");\n\t\t\t\t\t\t}\n\t                    if(next.numSegments()==1) {                     \n\t\t\t\t\t\t\tnext = context.getBaseURI().append(next);\n\t                    }\n\t\t\t\t\t\tDocumentImpl doc = (DocumentImpl) context.getBroker().getXMLResource(next);\n\t\t\t\t\t\tif(doc != null) {\n\t\t\t\t\t\t    if(!doc.getPermissions().validate(context.getUser(), Permission.READ))\n\t\t\t\t\t\t\t    throw new XPathException(\"Insufficient privileges to read resource \" + next);\n\t\t\t\t\t\t\tdocs.add(doc);\n\t\t\t\t\t\t}\n\t\t\t        } catch (URISyntaxException e) {\n\t\t\t            throw new XPathException(getASTNode(), \"Invalid resource uri\",e);\n\t\t\t        } catch (PermissionDeniedException e) {\n\t\t\t\t\t\tthrow new XPathException(\"Permission denied: unable to load document \" + (String)args.get(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcachedArgs = args;\n\t\t\t}\n\t    }\n\t    try {\n            if(!cacheIsValid)\n                // wait for pending updates\n                docs.lock(false);\n\t        // wait for pending updates\n\t\t\tif(result == null) {\n\t\t\t    result = new ExtArrayNodeSet(docs.getLength(), 1);\n                DocumentImpl doc;\n\t\t\t\tfor (Iterator i = docs.iterator(); i.hasNext();) {\n                    doc = (DocumentImpl) i.next();\n\t\t\t\t\tresult.add(new NodeProxy(doc)); //, -1, Node.DOCUMENT_NODE));\n                    if(lockOnLoad) {\n                        context.getLockedDocuments().add(doc);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t    } catch (LockException e) {\n            throw new XPathException(getASTNode(), \"Could not acquire lock on document set.\");\n        } finally {\n            if(!(cacheIsValid || lockOnLoad))\n                // release all locks\n                docs.unlock(false);\n\t    }\n\t\tcached = result;\n\t\tcachedDocs = docs;\n\t\tregisterUpdateListener();\n\t\treturn result;\n\t}","id":101137,"modified_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t    DocumentSet docs = null;\n\t    Sequence result = null;\n\t    // check if the loaded documents should remain locked\n        boolean lockOnLoad = context.lockDocumentsOnLoad();\n        boolean cacheIsValid = false;\n\t    if (getArgumentCount() == 0) {\n\t        if(cached != null) {\n\t            result = cached;\n\t            docs = cachedDocs;\n\t        } else {\n\t\t        docs = new DocumentSet();\n\t\t        context.getBroker().getAllXMLResources(docs);\n\t        }\n\t    } else {\n\t\t    List args = getParameterValues(contextSequence, contextItem);\n\t\t\tif(cachedArgs != null)\n\t\t\t    cacheIsValid = compareArguments(cachedArgs, args);\n\t\t\tif(cacheIsValid) {\n\t\t\t    result = cached;\n\t\t\t    docs = cachedDocs;\n\t\t\t} else {\n\t\t\t\tdocs = new DocumentSet();\n\t\t\t\tfor(int i = 0; i < args.size(); i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString next = (String)args.get(i);\n\t\t\t\t\t\tXmldbURI nextUri = new AnyURIValue(next).toXmldbURI();\n\t\t\t\t\t\tif(nextUri.getCollectionPath().length() == 0) {\n\t\t\t\t\t\t\tthrow new XPathException(\"Invalid argument to fn:doc function: empty string is not allowed here.\");\n\t\t\t\t\t\t}\n\t                    if(nextUri.numSegments()==1) {                     \n\t                    \tnextUri = context.getBaseURI().toXmldbURI().resolveCollectionPath(nextUri);\n\t                    }\n\t\t\t\t\t\tDocumentImpl doc = (DocumentImpl) context.getBroker().getXMLResource(nextUri);\n\t\t\t\t\t\tif(doc != null) {\n\t\t\t\t\t\t    if(!doc.getPermissions().validate(context.getUser(), Permission.READ))\n\t\t\t\t\t\t\t    throw new XPathException(\"Insufficient privileges to read resource \" + next);\n\t\t\t\t\t\t\tdocs.add(doc);\n\t\t\t\t\t\t}\n\t\t\t        } catch (XPathException e) { //From AnyURIValue constructor\n\t\t\t        \te.setASTNode(getASTNode());\n\t\t\t            throw e;\n\t\t\t        } catch (PermissionDeniedException e) {\n\t\t\t\t\t\tthrow new XPathException(\"Permission denied: unable to load document \" + (String)args.get(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcachedArgs = args;\n\t\t\t}\n\t    }\n\t    try {\n            if(!cacheIsValid)\n                // wait for pending updates\n                docs.lock(false);\n\t        // wait for pending updates\n\t\t\tif(result == null) {\n\t\t\t    result = new ExtArrayNodeSet(docs.getLength(), 1);\n                DocumentImpl doc;\n\t\t\t\tfor (Iterator i = docs.iterator(); i.hasNext();) {\n                    doc = (DocumentImpl) i.next();\n\t\t\t\t\tresult.add(new NodeProxy(doc)); //, -1, Node.DOCUMENT_NODE));\n                    if(lockOnLoad) {\n                        context.getLockedDocuments().add(doc);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t    } catch (LockException e) {\n            throw new XPathException(getASTNode(), \"Could not acquire lock on document set.\");\n        } finally {\n            if(!(cacheIsValid || lockOnLoad))\n                // release all locks\n                docs.unlock(false);\n\t    }\n\t\tcached = result;\n\t\tcachedDocs = docs;\n\t\tregisterUpdateListener();\n\t\treturn result;\n\t}","commit_id":"1fd165b221ea632c9f34db277718f325c77e3f6d","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n        }\n        \n        Sequence result;\n        if (args.length == 0)\n            result = new AnyURIValue(context.getBaseURI());\n        else if (args[0].isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n            NodeValue node = (NodeValue) args[0].itemAt(0);\n            if (node.getImplementationType() == NodeValue.IN_MEMORY_NODE)\n                result = new AnyURIValue(context.getBaseURI());\n            else {\n                NodeProxy proxy = (NodeProxy) node;\n                result = new AnyURIValue(proxy.getDocument().getURI());\n            }\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result);        \n        \n        return result;        \n    }","id":101138,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n        }\n        \n        Sequence result;\n        if (args.length == 0)\n            result = context.getBaseURI();\n        else if (args[0].isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n            NodeValue node = (NodeValue) args[0].itemAt(0);\n            if (node.getImplementationType() == NodeValue.IN_MEMORY_NODE)\n                result = context.getBaseURI();\n            else {\n                NodeProxy proxy = (NodeProxy) node;\n                result = new AnyURIValue(proxy.getDocument().getURI());\n            }\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result);        \n        \n        return result;        \n    }","commit_id":"1fd165b221ea632c9f34db277718f325c77e3f6d","url":"https://github.com/eXist-db/exist"},{"original_method":"private double computeAverage(long totalOperationTime) {\n        return (totalOperationTime / (double) (times)) / 1000;\n    }","id":101139,"modified_method":"private double computeAverage(long totalOperationTime) {\n    return (totalOperationTime / (double) (threadsNumber * iterationsNumber)) / 1000;\n  }","commit_id":"e93f4539091295ba397ac8e7bb254bb7e64ae292","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Adds the output of a single executor. It will be called N times\n     * (where N is the number of threads defined for the test by the number of iterations)\n     *\n     * @param operationsExecutorResults\n     */\n    public void addThreadResults(OOperationsExecutorResults operationsExecutorResults) {\n        operationsExecutorCreatesResults.add(operationsExecutorResults.getCreatesTime());\n        operationsExecutorReadsResults.add(operationsExecutorResults.getReadsTime());\n        operationsExecutorUpdatesResults.add(operationsExecutorResults.getUpdatesTime());\n        operationsExecutorDeletesResults.add(operationsExecutorResults.getDeletesTime());\n        counter++;\n    }","id":101140,"modified_method":"/**\n   * Adds the output of a single executor. It will be called N times\n   * (where N is the number of threads defined for the test by the number of iterations)\n   *\n   * @param operationsExecutorResults\n   */\n  public void addThreadResults(OOperationsExecutorResults operationsExecutorResults) {\n    operationsExecutorCreatesResults.add(operationsExecutorResults.getCreatesTime());\n    operationsExecutorReadsResults.add(operationsExecutorResults.getReadsTime());\n    operationsExecutorUpdatesResults.add(operationsExecutorResults.getUpdatesTime());\n    operationsExecutorDeletesResults.add(operationsExecutorResults.getDeletesTime());\n  }","commit_id":"e93f4539091295ba397ac8e7bb254bb7e64ae292","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public String toString() {\n\n        StringBuilder results = new StringBuilder();\n        results.append(\"OrientDB Stress Test v\")\n                .append(OConstants.VERSION)\n                .append(\"\\n\")\n                .append(getParameters())\n                .append(\"\\n\");\n\n        if (totalTime != 0) {\n            results.append(\"\\nTotal execution time: \")\n                    .append(String.format(\"%.2f\", totalTime / 1000f))\n                    .append(\" seconds.\");\n        }\n\n        times = threadsNumber * iterationsNumber;\n        long totalCreatesTime = 1;\n        long totalReadsTime = 1;\n        long totalUpdatesTime = 1;\n        long totalDeletesTime = 1;\n\n        for (int j = 0; j < operationsExecutorCreatesResults.size(); j++) {\n            totalCreatesTime += operationsExecutorCreatesResults.get(j);\n            totalReadsTime += operationsExecutorReadsResults.get(j);\n            totalUpdatesTime += operationsExecutorUpdatesResults.get(j);\n            totalDeletesTime += operationsExecutorDeletesResults.get(j);\n        }\n\n        final double averageCreatesTime = computeAverage(totalCreatesTime);\n        final double averageReadsTime = computeAverage(totalReadsTime);\n        final double averageUpdatesTime = computeAverage(totalUpdatesTime);\n        final double averageDeletesTime = computeAverage(totalDeletesTime);\n\n        final int createsPercentile = getPercentile(averageCreatesTime, operationsExecutorCreatesResults);\n        final int readsPercentile = getPercentile(averageReadsTime, operationsExecutorReadsResults);\n        final int updatesPercentile = getPercentile(averageUpdatesTime, operationsExecutorUpdatesResults);\n        final int deletesPercentile = getPercentile(averageDeletesTime, operationsExecutorDeletesResults);\n\n        final long createsThroughput = (int) ((operationsSet.getNumberOfCreates() / (float) averageCreatesTime));\n        final long readsThroughput = (int) ((operationsSet.getNumberOfReads() / (float) averageReadsTime));\n        final long updatesThroughput = (int) ((operationsSet.getNumberOfUpdates() / (float) averageUpdatesTime));\n        final long deletesThroughput = (int) ((operationsSet.getNumberOfDeletes() / (float) averageDeletesTime));\n\n        results.append(String.format(OPERATION_RESULT, operationsSet.getNumberOfCreates(), \"Creates\", averageCreatesTime, createsPercentile, createsThroughput))\n                .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfReads(), \"Reads\", averageReadsTime, readsPercentile, readsThroughput))\n                .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfReads(), \"Updates\", averageUpdatesTime, updatesPercentile, updatesThroughput))\n                .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfReads(), \"Deletes\", averageDeletesTime, deletesPercentile, deletesThroughput))\n                .append(\"\\n\");\n\n        return results.toString();\n    }","id":101141,"modified_method":"@Override\n  public String toString() {\n\n    StringBuilder results = new StringBuilder();\n    results.append(\"OrientDB Stress Test v\").append(OConstants.VERSION).append(\"\\n\").append(getParameters()).append(\"\\n\");\n\n    if (totalTime != 0) {\n      results.append(\"\\nTotal execution time: \").append(String.format(\"%.2f\", totalTime / 1000f)).append(\" seconds.\");\n    }\n\n    long totalCreatesTime = 1;\n    long totalReadsTime = 1;\n    long totalUpdatesTime = 1;\n    long totalDeletesTime = 1;\n\n    for (int j = 0; j < operationsExecutorCreatesResults.size(); j++) {\n      totalCreatesTime += operationsExecutorCreatesResults.get(j);\n      totalReadsTime += operationsExecutorReadsResults.get(j);\n      totalUpdatesTime += operationsExecutorUpdatesResults.get(j);\n      totalDeletesTime += operationsExecutorDeletesResults.get(j);\n    }\n\n    averageCreatesTime = computeAverage(totalCreatesTime);\n    averageReadsTime = computeAverage(totalReadsTime);\n    averageUpdatesTime = computeAverage(totalUpdatesTime);\n    averageDeletesTime = computeAverage(totalDeletesTime);\n\n    createsPercentile = getPercentile(averageCreatesTime, operationsExecutorCreatesResults);\n    readsPercentile = getPercentile(averageReadsTime, operationsExecutorReadsResults);\n    updatesPercentile = getPercentile(averageUpdatesTime, operationsExecutorUpdatesResults);\n    deletesPercentile = getPercentile(averageDeletesTime, operationsExecutorDeletesResults);\n\n    createsThroughput = (int) ((operationsSet.getNumberOfCreates() / (float) averageCreatesTime));\n    readsThroughput = (int) ((operationsSet.getNumberOfReads() / (float) averageReadsTime));\n    updatesThroughput = (int) ((operationsSet.getNumberOfUpdates() / (float) averageUpdatesTime));\n    deletesThroughput = (int) ((operationsSet.getNumberOfDeletes() / (float) averageDeletesTime));\n\n    results.append(\n        String.format(OPERATION_RESULT, operationsSet.getNumberOfCreates(), \"Creates\", averageCreatesTime, createsPercentile, createsThroughput))\n        .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfReads(), \"Reads\", averageReadsTime, readsPercentile, readsThroughput))\n        .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfUpdates(), \"Updates\", averageUpdatesTime, updatesPercentile, updatesThroughput))\n        .append(String.format(OPERATION_RESULT, operationsSet.getNumberOfDeletes(), \"Deletes\", averageDeletesTime, deletesPercentile, deletesThroughput))\n        .append(\"\\n\");\n\n    return results.toString();\n  }","commit_id":"e93f4539091295ba397ac8e7bb254bb7e64ae292","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OStressTester(ODatabaseIdentifier databaseIdentifier, OOperationsSet operationsSet, int iterationsNumber,\n      int threadsNumber, int txNumber) throws Exception {\n    this.operationsSet = operationsSet;\n    this.iterationsNumber = iterationsNumber;\n    this.threadsNumber = threadsNumber;\n    this.databaseIdentifier = databaseIdentifier;\n    this.txNumber = txNumber;\n    stressTestResults = new OStressTestResults(operationsSet, databaseIdentifier.getMode(), threadsNumber, iterationsNumber);\n    consoleProgressWriter = new OConsoleWriter(operationsSet, threadsNumber, iterationsNumber);\n  }","id":101142,"modified_method":"public OStressTester(ODatabaseIdentifier databaseIdentifier, OOperationsSet operationsSet, int iterationsNumber,\n      int threadsNumber, int txNumber, String outputResultFile) throws Exception {\n    this.operationsSet = operationsSet;\n    this.iterationsNumber = iterationsNumber;\n    this.threadsNumber = threadsNumber;\n    this.databaseIdentifier = databaseIdentifier;\n    this.txNumber = txNumber;\n    this.outputResultFile = outputResultFile;\n    stressTestResults = new OStressTestResults(operationsSet, databaseIdentifier.getMode(), threadsNumber, iterationsNumber);\n    consoleProgressWriter = new OConsoleWriter(operationsSet, threadsNumber, iterationsNumber);\n  }","commit_id":"e93f4539091295ba397ac8e7bb254bb7e64ae292","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  private int execute() throws Exception {\n\n    long startTime;\n    long totalTime = 0;\n    int returnCode = 0;\n\n    // we don't want logs from DB\n    OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n    // creates the temporary DB where to execute the test\n    ODatabaseUtils.createDatabase(databaseIdentifier);\n    consoleProgressWriter.printMessage(String.format(\"Created database [%s].\", databaseIdentifier.getUrl()));\n\n    // opens the newly created db and creates an index on the class we're going to use\n    ODatabase database = ODatabaseUtils.openDatabase(databaseIdentifier);\n    if (database == null) {\n      throw new Exception(\"Couldn't open database \" + databaseIdentifier.getName() + \".\");\n    }\n    try {\n      final OSchema schema = database.getMetadata().getSchema();\n      final OClass oClass = schema.createClass(OConstants.CLASS_NAME);\n      oClass.createProperty(\"name\", OType.STRING);\n      OIndexManager indexManager = database.getMetadata().getIndexManager();\n      indexManager.createIndex(OConstants.INDEX_NAME, OClass.INDEX_TYPE.UNIQUE.toString(),\n          new OPropertyIndexDefinition(OConstants.CLASS_NAME, \"name\", OType.STRING), oClass.getClusterIds(), null, null);\n    } finally {\n      database.close();\n    }\n\n    // starts the test\n    try {\n\n      // iterates n times\n      for (int i = 0; i < iterationsNumber; i++) {\n\n        // creates the operations executors\n        List<Callable<OOperationsExecutorResults>> operationsExecutors = new ArrayList<Callable<OOperationsExecutorResults>>();\n        for (int j = 0; j < threadsNumber; j++) {\n          operationsExecutors.add(new OOperationsExecutor(databaseIdentifier, operationsSet, txNumber, consoleProgressWriter));\n        }\n\n        // starts parallel execution (blocking call)\n        startTime = System.currentTimeMillis();\n        List<Future<OOperationsExecutorResults>> threadsResults = Executors.newFixedThreadPool(threadsNumber)\n            .invokeAll(operationsExecutors);\n        totalTime += System.currentTimeMillis() - startTime;\n\n        // add the output of every executor\n        for (Future<OOperationsExecutorResults> threadResults : threadsResults) {\n          stressTestResults.addThreadResults(threadResults.get());\n        }\n      }\n      // stops total benchmarking\n      stressTestResults.addTotalExecutionTime(totalTime);\n\n      // prints out total output\n      System.out.println(\"\\r                                                                                             \");\n      System.out.println(stressTestResults.toString());\n\n    } catch (Exception ex) {\n      System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n      returnCode = 1;\n      // ex.printStackTrace();\n    } finally {\n      // we don't need to drop the in-memory DB\n      if (databaseIdentifier.getMode() != OMode.MEMORY) {\n        ODatabaseUtils.dropDatabase(databaseIdentifier);\n        consoleProgressWriter.printMessage(String.format(\"Dropped database [%s].\", databaseIdentifier.getUrl()));\n      }\n    }\n\n    return returnCode;\n  }","id":101143,"modified_method":"@SuppressWarnings(\"unchecked\")\n  private int execute() throws Exception {\n\n    long startTime;\n    long totalTime = 0;\n    int returnCode = 0;\n\n    // we don't want logs from DB\n    OLogManager.instance().setConsoleLevel(\"SEVERE\");\n\n    // creates the temporary DB where to execute the test\n    ODatabaseUtils.createDatabase(databaseIdentifier);\n    consoleProgressWriter.printMessage(String.format(\"Created database [%s].\", databaseIdentifier.getUrl()));\n\n    // opens the newly created db and creates an index on the class we're going to use\n    ODatabase database = ODatabaseUtils.openDatabase(databaseIdentifier);\n    if (database == null) {\n      throw new Exception(\"Couldn't open database \" + databaseIdentifier.getName() + \".\");\n    }\n    try {\n      final OSchema schema = database.getMetadata().getSchema();\n      final OClass oClass = schema.createClass(OConstants.CLASS_NAME);\n      oClass.createProperty(\"name\", OType.STRING);\n      OIndexManager indexManager = database.getMetadata().getIndexManager();\n      indexManager.createIndex(OConstants.INDEX_NAME, OClass.INDEX_TYPE.UNIQUE.toString(),\n          new OPropertyIndexDefinition(OConstants.CLASS_NAME, \"name\", OType.STRING), oClass.getClusterIds(), null, null);\n    } finally {\n      database.close();\n    }\n\n    // starts the test\n    try {\n\n      // iterates n times\n      for (int i = 0; i < iterationsNumber; i++) {\n\n        // creates the operations executors\n        List<Callable<OOperationsExecutorResults>> operationsExecutors = new ArrayList<Callable<OOperationsExecutorResults>>();\n        for (int j = 0; j < threadsNumber; j++) {\n          operationsExecutors.add(new OOperationsExecutor(databaseIdentifier, operationsSet, txNumber, consoleProgressWriter));\n        }\n\n        // starts parallel execution (blocking call)\n        startTime = System.currentTimeMillis();\n        List<Future<OOperationsExecutorResults>> threadsResults = Executors.newFixedThreadPool(threadsNumber)\n            .invokeAll(operationsExecutors);\n        totalTime += System.currentTimeMillis() - startTime;\n\n        // add the output of every executor\n        for (Future<OOperationsExecutorResults> threadResults : threadsResults) {\n          stressTestResults.addThreadResults(threadResults.get());\n        }\n      }\n      // stops total benchmarking\n      stressTestResults.addTotalExecutionTime(totalTime);\n\n      // prints out total output\n      System.out.println(\"\\r                                                                                             \");\n      System.out.println(stressTestResults.toString());\n\n      // if specified, writes output to file\n      if (outputResultFile != null) {\n        OIOUtils.writeFile(new File(outputResultFile), OJsonResultsFormatter.format(stressTestResults));\n      }\n    } catch (Exception ex) {\n      System.err.println(\"\\nAn error has occurred while running the stress test: \" + ex.getMessage());\n      returnCode = 1;\n    } finally {\n      // we don't need to drop the in-memory DB\n      if (databaseIdentifier.getMode() != OMode.MEMORY) {\n        ODatabaseUtils.dropDatabase(databaseIdentifier);\n        consoleProgressWriter.printMessage(String.format(\"Dropped database [%s].\", databaseIdentifier.getUrl()));\n      }\n    }\n\n    return returnCode;\n  }","commit_id":"e93f4539091295ba397ac8e7bb254bb7e64ae292","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * builds a StressTester object using the command line arguments\n   *\n   * @param args\n   * @return\n   * @throws Exception\n   */\n  public static OStressTester getStressTester(String[] args) throws Exception {\n\n    Map<String, String> options = checkOptions(readOptions(args));\n    String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n    OMode mode = OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n    String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n    int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n    int operationsPerTransaction = getNumber(options.get(OConstants.OPTION_TRANSACTIONS), \"transactions\");\n    int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n    OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS), threadsNumber, iterationsNumber);\n    String remoteIp = options.get(OConstants.OPTION_REMOTE_IP);\n    int remotePort = 2424;\n\n    if (operationsPerTransaction > operationsSet.getNumberOfCreates()) {\n      throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_TX_GREATER_THAN_CREATES, operationsPerTransaction, operationsSet.getNumberOfCreates()));\n    }\n\n    if (options.get(OConstants.OPTION_REMOTE_PORT) != null) {\n      remotePort = getNumber(options.get(OConstants.OPTION_REMOTE_PORT), \"remotePort\");\n      if (remotePort > 65535) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_REMOTE_PORT_NUMBER, remotePort));\n      }\n    }\n\n    if (mode == OMode.DISTRIBUTED) {\n      throw new OInitException(String.format(\"OMode [%s] not yet supported.\", mode));\n    }\n\n    if (mode == OMode.REMOTE && remoteIp == null) {\n      throw new OInitException(OErrorMessages.COMMAND_LINE_PARSER_MISSING_REMOTE_IP);\n    }\n\n    if (rootPassword == null && mode == OMode.REMOTE) {\n      Console console = System.console();\n      if (console != null) {\n        rootPassword = String\n            .valueOf(console.readPassword(String.format(OConstants.CONSOLE_REMOTE_PASSWORD_PROMPT, remoteIp, remotePort)));\n      } else {\n        throw new Exception(OErrorMessages.ERROR_OPENING_CONSOLE);\n      }\n    }\n\n    ODatabaseIdentifier databaseIdentifier = new ODatabaseIdentifier(mode, dbName, rootPassword, remoteIp, remotePort);\n    return new OStressTester(databaseIdentifier, operationsSet, iterationsNumber, threadsNumber, operationsPerTransaction);\n  }","id":101144,"modified_method":"/**\n   * builds a StressTester object using the command line arguments\n   *\n   * @param args\n   * @return\n   * @throws Exception\n   */\n  public static OStressTester getStressTester(String[] args) throws Exception {\n\n    Map<String, String> options = checkOptions(readOptions(args));\n    String dbName = OConstants.TEMP_DATABASE_NAME + new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n    OMode mode = OMode.valueOf(options.get(OConstants.OPTION_MODE).toUpperCase());\n    String rootPassword = options.get(OConstants.OPTION_ROOT_PASSWORD);\n    String resultOutputFile = options.get(OConstants.OPTION_OUTPUT_FILE);\n    int iterationsNumber = getNumber(options.get(OConstants.OPTION_ITERATIONS), \"iterations\");\n    int operationsPerTransaction = getNumber(options.get(OConstants.OPTION_TRANSACTIONS), \"transactions\");\n    int threadsNumber = getNumber(options.get(OConstants.OPTION_THREADS), \"threads\");\n    OOperationsSet operationsSet = new OOperationsSet(options.get(OConstants.OPTION_OPERATIONS), threadsNumber, iterationsNumber);\n    String remoteIp = options.get(OConstants.OPTION_REMOTE_IP);\n    int remotePort = 2424;\n\n    if (resultOutputFile != null) {\n      File outputFile = new File(resultOutputFile);\n      if (outputFile.exists()) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_EXISTING_OUTPUT_FILE, resultOutputFile));\n      }\n      if (!outputFile.getParentFile().exists()) {\n        throw new OInitException(\n            String.format(OErrorMessages.COMMAND_LINE_PARSER_NOT_EXISTING_OUTPUT_DIRECTORY, outputFile.getParentFile().getAbsoluteFile()));\n      }\n      if (!outputFile.getParentFile().canWrite()) {\n        throw new OInitException(\n            String.format(OErrorMessages.COMMAND_LINE_PARSER_NO_WRITE_PERMISSION_OUTPUT_FILE, outputFile.getParentFile().getAbsoluteFile()));\n      }\n    }\n\n    if (operationsPerTransaction > operationsSet.getNumberOfCreates()) {\n      throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_TX_GREATER_THAN_CREATES, operationsPerTransaction,\n          operationsSet.getNumberOfCreates()));\n    }\n\n    if (options.get(OConstants.OPTION_REMOTE_PORT) != null) {\n      remotePort = getNumber(options.get(OConstants.OPTION_REMOTE_PORT), \"remotePort\");\n      if (remotePort > 65535) {\n        throw new OInitException(String.format(OErrorMessages.COMMAND_LINE_PARSER_INVALID_REMOTE_PORT_NUMBER, remotePort));\n      }\n    }\n\n    if (mode == OMode.DISTRIBUTED) {\n      throw new OInitException(String.format(\"OMode [%s] not yet supported.\", mode));\n    }\n\n    if (mode == OMode.REMOTE && remoteIp == null) {\n      throw new OInitException(OErrorMessages.COMMAND_LINE_PARSER_MISSING_REMOTE_IP);\n    }\n\n    if (rootPassword == null && mode == OMode.REMOTE) {\n      Console console = System.console();\n      if (console != null) {\n        rootPassword = String\n            .valueOf(console.readPassword(String.format(OConstants.CONSOLE_REMOTE_PASSWORD_PROMPT, remoteIp, remotePort)));\n      } else {\n        throw new Exception(OErrorMessages.ERROR_OPENING_CONSOLE);\n      }\n    }\n\n    ODatabaseIdentifier databaseIdentifier = new ODatabaseIdentifier(mode, dbName, rootPassword, remoteIp, remotePort);\n    return new OStressTester(databaseIdentifier, operationsSet, iterationsNumber, threadsNumber, operationsPerTransaction,\n        resultOutputFile);\n  }","commit_id":"e93f4539091295ba397ac8e7bb254bb7e64ae292","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void appendToResponse(WOResponse response, WOContext context) {\n        boolean wasInForm = context.isInForm();\n        \n        context.setInForm(true);\n        \n        boolean disable = _disabled != null && _disabled.booleanValueInComponent(context.component());\n        boolean shouldAppendFormTags = !disable && !wasInForm;\n        \n        if (shouldAppendFormTags) {\n            _appendOpenTagToResponse(response, context);\n            appendChildrenToResponse(response, context);\n            _appendCloseTagToResponse(response, context);\n            if(_fragmentIdentifier != null) {\n                Object value = _fragmentIdentifier.valueInComponent(context.component());\n                if(value != null) {\n                    String formName = \"document.forms.length-1\";\n                    formName = (_formName != null ? \"'\" +_formName.valueInComponent(context.component()) + \"'\" : formName);\n                    response.appendContentString(\"<script language=\\\"javascript\\\">document.forms[\"+formName+\"].action+=\\\"#\"+value.toString()+\"\\\";<\/script>\");\n                }\n            }\n            if(context instanceof ERXMutableUserInfoHolderInterface) {\n                NSMutableDictionary ui = ((ERXMutableUserInfoHolderInterface)context).mutableUserInfo();\n                \n                ui.removeObjectForKey(\"formName\");\n                ui.removeObjectForKey(\"enctype\");\n            }\n        } else {\n            if(!disable) {\n                log.warn(\"This FORM is embedded inside another FORM. Omitting Tags: \" + this.toString());\n            }\n            appendChildrenToResponse(response, context);\n        }\n\n        context.setInForm(wasInForm);\n    }","id":101145,"modified_method":"public void appendToResponse(WOResponse response, WOContext context) {\n        boolean wasInForm = context.isInForm();\n        \n        context.setInForm(true);\n        \n        boolean disable = _disabled != null && _disabled.booleanValueInComponent(context.component());\n        boolean shouldAppendFormTags = !disable && !wasInForm;\n        \n        if (shouldAppendFormTags) {\n            _appendOpenTagToResponse(response, context);\n            appendChildrenToResponse(response, context);\n            _appendCloseTagToResponse(response, context);\n            if(context instanceof ERXMutableUserInfoHolderInterface) {\n                NSMutableDictionary ui = ((ERXMutableUserInfoHolderInterface)context).mutableUserInfo();\n                \n                ui.removeObjectForKey(\"formName\");\n                ui.removeObjectForKey(\"enctype\");\n            }\n        } else {\n            if(!disable) {\n                log.warn(\"This FORM is embedded inside another FORM. Omitting Tags: \" + this.toString());\n            }\n            appendChildrenToResponse(response, context);\n        }\n\n        context.setInForm(wasInForm);\n    }","commit_id":"d4bedb75e9d9407ac7eb2d0add3fffa8824be0ee","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendAttributesToResponse(WOResponse response, WOContext context) {\n        if(context instanceof ERXMutableUserInfoHolderInterface) {\n            NSMutableDictionary ui = ((ERXMutableUserInfoHolderInterface)context).mutableUserInfo();\n            if(_formName != null) {\n                String formName = (String)_formName.valueInComponent(context.component());\n                if(formName != null) {\n                    ui.setObjectForKey(formName, \"formName\");\n                    response._appendTagAttributeAndValue(\"name\", formName, false);\n                }\n            }\n            if(_enctype != null) {\n                String enctype = (String)_enctype.valueInComponent(context.component());\n                if(enctype != null) {\n                    ui.setObjectForKey(enctype.toLowerCase(), \"enctype\");\n                    response._appendTagAttributeAndValue(\"enctype\", enctype, false);\n                }\n            }\n        }\n        boolean secure = _secure != null && _secure.booleanValueInComponent(context.component());\n        if (secure) {\n            //FIXME: (ak) we assume that relative URL creation is on by default, so we may restore the wrong type \n            WOResponse newResponse = new WOResponse();\n            context._generateCompleteURLs();\n            super.appendAttributesToResponse(newResponse, context);\n            context._generateRelativeURLs();\n            \n            String action = newResponse.contentString();\n            if(action.indexOf(\"action=\\\"http://\") >= 0) {\n                action = action.replaceFirst(\"action=\\\"http://\", \"action=\\\"https://\");\n            }\n            response.appendContentString(action);\n        } else {\n            super.appendAttributesToResponse(response, context);\n        }\n    }","id":101146,"modified_method":"public void appendAttributesToResponse(WOResponse response, WOContext context) {\n        if(context instanceof ERXMutableUserInfoHolderInterface) {\n            NSMutableDictionary ui = ((ERXMutableUserInfoHolderInterface)context).mutableUserInfo();\n            if(_formName != null) {\n                String formName = (String)_formName.valueInComponent(context.component());\n                if(formName != null) {\n                    ui.setObjectForKey(formName, \"formName\");\n                    response._appendTagAttributeAndValue(\"name\", formName, false);\n                }\n            }\n            if(_enctype != null) {\n                String enctype = (String)_enctype.valueInComponent(context.component());\n                if(enctype != null) {\n                    ui.setObjectForKey(enctype.toLowerCase(), \"enctype\");\n                    response._appendTagAttributeAndValue(\"enctype\", enctype, false);\n                }\n            }\n        }\n        boolean secure = _secure != null && _secure.booleanValueInComponent(context.component());\n        Object fragmentIdentifier = (_fragmentIdentifier != null ? _fragmentIdentifier.valueInComponent(context.component()) : null);\n        if (secure || fragmentIdentifier != null) {\n            //FIXME: (ak) we assume that relative URL creation is on by default, so we may restore the wrong type \n            WOResponse newResponse = new WOResponse();\n            if(secure) {\n                context._generateCompleteURLs();\n                super.appendAttributesToResponse(newResponse, context);\n                context._generateRelativeURLs();\n            } else {\n                super.appendAttributesToResponse(newResponse, context);\n            }\n            String attributes = newResponse.contentString();\n            if(secure && attributes.indexOf(\"action=\\\"http://\") >= 0) {\n                attributes = attributes.replaceFirst(\"action=\\\"http://\", \"action=\\\"https://\");\n            }\n            if(fragmentIdentifier != null) {\n                attributes = attributes.replaceFirst(\"action=\\\"([^\\\"]*)\\\"\", \"action=\\\"$1#\" + fragmentIdentifier + \"\\\"\");\n            }\n            \n            response.appendContentString(attributes);\n        } else {\n            super.appendAttributesToResponse(response, context);\n        }\n    }","commit_id":"d4bedb75e9d9407ac7eb2d0add3fffa8824be0ee","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendAttributesToResponse(WOResponse response, WOContext context) {\n        if(context != null && context instanceof ERXMutableUserInfoHolderInterface) {\n            NSMutableDictionary ui = ((ERXMutableUserInfoHolderInterface)context).mutableUserInfo();\n            if(_formName != null) {\n                String formName = (String)_formName.valueInComponent(context.component());\n                if(formName != null) {\n                    ui.setObjectForKey(formName, \"formName\");\n                    response._appendTagAttributeAndValue(\"name\", formName, false);\n                }\n            }\n            if(_enctype != null) {\n                String enctype = (String)_enctype.valueInComponent(context.component());\n                if(enctype != null) {\n                    ui.setObjectForKey(enctype.toLowerCase(), \"enctype\");\n                    response._appendTagAttributeAndValue(\"enctype\", enctype, false);\n                }\n            }\n        }\n        super.appendAttributesToResponse(response, context);\n    }","id":101147,"modified_method":"public void appendAttributesToResponse(WOResponse response, WOContext context) {\n        if(context != null && context instanceof ERXMutableUserInfoHolderInterface) {\n            NSMutableDictionary ui = ((ERXMutableUserInfoHolderInterface)context).mutableUserInfo();\n            if(_formName != null) {\n                String formName = (String)_formName.valueInComponent(context.component());\n                if(formName != null) {\n                    ui.setObjectForKey(formName, \"formName\");\n                    response._appendTagAttributeAndValue(\"name\", formName, false);\n                }\n            }\n            if(_enctype != null) {\n                String enctype = (String)_enctype.valueInComponent(context.component());\n                if(enctype != null) {\n                    ui.setObjectForKey(enctype.toLowerCase(), \"enctype\");\n                    response._appendTagAttributeAndValue(\"enctype\", enctype, false);\n                }\n            }\n        }\n        boolean secure = _secure != null && _secure.booleanValueInComponent(context.component());\n        if (secure) {\n            //FIXME: (ak) we assume that relative URL creation is on by default, so we may restore the wrong type \n            WOResponse newResponse = new WOResponse();\n            context._generateCompleteURLs();\n            super.appendAttributesToResponse(newResponse, context);\n            context._generateRelativeURLs();\n            \n            String action = newResponse.contentString();\n            if(action.indexOf(\"action=\\\"http://\") >= 0) {\n                action = action.replaceFirst(\"action=\\\"http://\", \"action=\\\"https://\");\n            }\n            response.appendContentString(action);\n        } else {\n            super.appendAttributesToResponse(response, context);\n        }\n    }","commit_id":"2a75b4800abcb56033da1b04c82664b0406a9b89","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXWOForm(String name, NSDictionary associations,\n                     WOElement template) {\n        super(name, associations, template);\n        _formName = (WOAssociation) _associations.removeObjectForKey(\"name\");\n        _enctype = (WOAssociation) _associations.removeObjectForKey(\"enctype\");\n        _fragmentIdentifier = (WOAssociation) _associations.removeObjectForKey(\"fragmentIdentifier\");\n    }","id":101148,"modified_method":"public ERXWOForm(String name, NSDictionary associations,\n                     WOElement template) {\n        super(name, associations, template);\n        _formName = (WOAssociation) _associations.removeObjectForKey(\"name\");\n        _enctype = (WOAssociation) _associations.removeObjectForKey(\"enctype\");\n        _fragmentIdentifier = (WOAssociation) _associations.removeObjectForKey(\"fragmentIdentifier\");\n        _secure = (WOAssociation) _associations.removeObjectForKey(\"secure\");\n    }","commit_id":"2a75b4800abcb56033da1b04c82664b0406a9b89","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public void appendAttributesToResponse(WOResponse woresponse, WOContext wocontext) {\n    \tsuper.appendAttributesToResponse(woresponse, wocontext);\n    \tif(defaultNoFollow && _action != null) {\n    \t\tworesponse.appendContentString(\" rel=\\\"nofollow\\\"\");\n    \t}\n    }","id":101149,"modified_method":"@Override\n    public void appendAttributesToResponse(final WOResponse woresponse, WOContext wocontext) {\n    \tif(!ERXApplication.isWO54() && _href != null && _href.valueInComponent(wocontext.component()) != null) {\n    \t\t// AK: for whatever reason, WO double-quotes the '&' when you use the HREF binding, \n    \t\t// so you end up with x=1&amp;amp;y=2 instead of x=1&amp;y=2\n    \t\t// setting escape to false fixes this (one could argue the escape is needed in the first place)\n    \t\t// This is a pretty inefficient method, but at least it's correct\n    \t\tWOResponse response = new WOResponse() {\n    \t\t\tpublic void appendContentHTMLAttributeValue(String s) {\n    \t\t\t\tsuper.appendContentString(s);\n    \t\t\t}\n    \t\t};\n\t\t\tsuper.appendAttributesToResponse(response, wocontext);\n\t\t\tworesponse.appendContentString(response.contentString());\n     \t} else {\n        \tsuper.appendAttributesToResponse(woresponse, wocontext);\n     \t}\n    \tif(defaultNoFollow && _action != null) {\n    \t\tworesponse.appendContentString(\" rel=\\\"nofollow\\\"\");\n    \t}\n    }","commit_id":"65376775e37c59430e58c80b0988b2490000c0ba","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** Drops down or closes the child.\n\t *\n\t * @since 3.0.1\n\t * @see #open\n\t * @see #close\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (open) open();\n\t\telse close();\n\t}","id":101150,"modified_method":"/** Drops down or closes the child.\n\t *\n\t * @since 3.0.1\n\t * @see #open\n\t * @see #close\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\tif (open) open();\n\t\t\telse close();\n\t\t}\n\t}","commit_id":"dbecd637a50c2e637e1534531c9705f4b167de75","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link Textbox#service},\n\t * it also handles onOpen and onSelect.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tEvents.postEvent(OpenEvent.getOpenEvent(request));\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":101151,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link Textbox#service},\n\t * it also handles onOpen and onSelect.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\t\t\t_open = evt.isOpen();\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"dbecd637a50c2e637e1534531c9705f4b167de75","url":"https://github.com/zkoss/zk"},{"original_method":"/** Drops down or closes the list of combo items ({@link Comboitem}.\n\t *\n\t * @since 3.0.1\n\t * @see #open\n\t * @see #close\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (open) open();\n\t\telse close();\n\t}","id":101152,"modified_method":"/** Drops down or closes the list of combo items ({@link Comboitem}.\n\t *\n\t * @since 3.0.1\n\t * @see #open\n\t * @see #close\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\tif (open) open();\n\t\t\telse close();\n\t\t}\n\t}","commit_id":"dbecd637a50c2e637e1534531c9705f4b167de75","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link Textbox#service},\n\t * it also handles onOpen and onSelect.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tEvents.postEvent(OpenEvent.getOpenEvent(request));\n\t\t}else if (cmd.equals(Events.ON_SELECT)) {\n\t\t\tSelectEvent evt = SelectEvent.getSelectEvent(request);\n\t\t\tSet selItems = evt.getSelectedItems();\n\t\t\t_selItem = selItems != null && !selItems.isEmpty()?\n\t\t\t\t(Comboitem)selItems.iterator().next(): null;\n\t\t\t_lastCkVal = getValue(); //onChange is sent before onSelect\n\t\t\t\n\t\t\tsyncSelectionToModel();\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":101153,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link Textbox#service},\n\t * it also handles onOpen and onSelect.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\t\t\t_open = evt.isOpen();\n\t\t\tEvents.postEvent(evt);\n\t\t} else if (cmd.equals(Events.ON_SELECT)) {\n\t\t\tSelectEvent evt = SelectEvent.getSelectEvent(request);\n\t\t\tSet selItems = evt.getSelectedItems();\n\t\t\t_selItem = selItems != null && !selItems.isEmpty()?\n\t\t\t\t(Comboitem)selItems.iterator().next(): null;\n\t\t\t_lastCkVal = getValue(); //onChange is sent before onSelect\n\t\t\t\n\t\t\tsyncSelectionToModel();\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"dbecd637a50c2e637e1534531c9705f4b167de75","url":"https://github.com/zkoss/zk"},{"original_method":"public void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\r\n\t\tfinal String cmd = request.getCommand();\r\n\t\tif (cmd.equals(Events.ON_CLICK)) {\r\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\r\n\t\t} else if (cmd.equals(Events.ON_OPEN)) {\r\n\t\t\tEvents.postEvent(OpenEvent.getOpenEvent(request));\r\n\t\t} else\r\n\t\t\tsuper.service(request, everError);\r\n\t}","id":101154,"modified_method":"public void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\r\n\t\tfinal String cmd = request.getCommand();\r\n\t\tif (cmd.equals(Events.ON_CLICK)) {\r\n\t\t\tEvents.postEvent(MouseEvent.getMouseEvent(request));\r\n\t\t} else if (cmd.equals(Events.ON_OPEN)) {\r\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\r\n\t\t\t_open = evt.isOpen();\r\n\t\t\tEvents.postEvent(evt);\r\n\t\t} else\r\n\t\t\tsuper.service(request, everError);\r\n\t}","commit_id":"fa05c107d6fad662de92508b2ae254f98f723d97","url":"https://github.com/zkoss/zk"},{"original_method":"/** Drops down or closes the child.\r\n\t * @see #open\r\n\t * @see #close\r\n\t */\r\n\tpublic void setOpen(boolean open) {\r\n\t\tif (open) open();\r\n\t\telse close();\r\n\t}","id":101155,"modified_method":"/** Drops down or closes the child, \r\n\t * only works while visible.\r\n\t * @see #open\r\n\t * @see #close\r\n\t */\r\n\tpublic void setOpen(boolean open) {\r\n\t\tif (open != _open) {\r\n\t\t\t_open = open;\r\n\t\t\tif (isVisible()) {\r\n\t\t\t\tif (open) open();\r\n\t\t\t\telse close();\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"fa05c107d6fad662de92508b2ae254f98f723d97","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onOpen.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN))\n\t\t\tEvents.postEvent(OpenEvent.getOpenEvent(request));\n\t\telse\n\t\t\tsuper.service(request, everError);\n\t}","id":101156,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onOpen.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\t\t\tsuper.setVisible(evt.isOpen()); // Bug B50-3178065\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"6ef0d1a13645d6173ad8780f61d9badefba1b1d8","url":"https://github.com/zkoss/zk"},{"original_method":"private Object[] processPutRow(AbstractNode node) throws KettleException\r\n\t{\r\n\t\t// Create new row...\r\n\t\tObject[] outputRowData = buildEmptyRow();\r\n\t\t\r\n\t\t // Create new row\tor clone\r\n\t\tif(meta.isInFields()) {\r\n\t\t\t System.arraycopy(data.readrow, 0, outputRowData, 0, data.nrReadRow);\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdata.nodenr++; \r\n\r\n\t\t\t// Read fields...\r\n\t\t\tfor (int i=0;i<data.nrInputFields;i++)\r\n\t\t\t{\t\r\n\t\t\t\t// Get field\r\n\t\t\t\tGetXMLDataField xmlDataField = meta.getInputFields()[i];\r\n\t\t\t\t// Get the Path to look for\r\n\t\t\t\tString XPathValue = xmlDataField.getXPath();\r\n\r\n\t\t\t\tif(meta.isuseToken())\r\n\t\t\t\t{\r\n\t\t\t\t\t// See if user use Token inside path field\r\n\t\t\t\t\t// The syntax is : @_Fieldname-\r\n\t\t\t\t\t// PDI will search for Fieldname value and replace it\r\n\t\t\t\t\t// Fieldname must be defined before the current node\r\n\t\t\t\t\tXPathValue=substituteToken(XPathValue, outputRowData);\r\n\t\t\t\t\tif (isDetailed()) \tlogDetailed(XPathValue);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Get node value\r\n\t\t\t\tString nodevalue =null;\r\n\t\t\t\t\r\n\t\t\t\t// Handle namespaces\r\n\t\t\t\tif(meta.isNamespaceAware())\r\n\t\t\t\t{\r\n\t\t\t\t\tXPath xpathField = node.createXPath(addNSPrefix(XPathValue, data.PathValue));\r\n\t\t\t\t\txpathField.setNamespaceURIs(data.NAMESPACE);\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=xpathField.valueOf(node);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnodevalue=xpathField.selectSingleNode(node).asXML();\r\n\t\t\t\t}else\r\n\t\t\t\t{\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=node.valueOf(XPathValue);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnodevalue=node.selectSingleNode(XPathValue).asXML();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Do trimming\r\n\t\t\t\tswitch (xmlDataField.getTrimType())\r\n\t\t\t\t{\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_LEFT:\r\n\t\t\t\t\t\tnodevalue = Const.ltrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_RIGHT:\r\n\t\t\t\t\t\tnodevalue = Const.rtrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_BOTH:\r\n\t\t\t\t\t\tnodevalue = Const.trim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\r\n\t\t\t\t// Do conversions\r\n\t\t\t\t//\r\n\t\t\t\tValueMetaInterface targetValueMeta = data.outputRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\tValueMetaInterface sourceValueMeta = data.convertRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\toutputRowData[data.totalpreviousfields+i] = targetValueMeta.convertData(sourceValueMeta, nodevalue);\r\n\r\n\t\t\t\t// Do we need to repeat this field if it is null?\r\n\t\t\t\tif (meta.getInputFields()[i].isRepeated())\r\n\t\t\t\t{\r\n\t\t\t\t\tif (data.previousRow!=null && Const.isEmpty(nodevalue))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toutputRowData[data.totalpreviousfields+i] = data.previousRow[data.totalpreviousfields+i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}// End of loop over fields...\t\r\n\t\t\t\r\n\t\t\tint rowIndex = data.totalpreviousfields+ data.nrInputFields;\r\n\t\t\t\r\n\t\t\t// See if we need to add the filename to the row...\r\n\t\t\tif ( meta.includeFilename() && !Const.isEmpty(meta.getFilenameField()) ) {\r\n\t\t\t\toutputRowData[rowIndex++] = data.filename;\r\n\t\t\t}\r\n\t\t\t // See if we need to add the row number to the row...  \r\n\t        if (meta.includeRowNumber() && !Const.isEmpty(meta.getRowNumberField()))\r\n\t        {\r\n\t            outputRowData[rowIndex++] = new Long(data.rownr);\r\n\t        }\r\n\t        // Possibly add short filename...\r\n\t\t\tif (meta.getShortFileNameField()!=null && meta.getShortFileNameField().length()>0)\r\n\t\t\t{\t\t\t\t\r\n\t\t\t\toutputRowData[rowIndex++] = data.shortFilename;\r\n\t\t\t}\r\n\t\t\t// Add Extension\r\n\t\t\tif (meta.getExtensionField()!=null && meta.getExtensionField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.extension;\r\n\t\t\t}\r\n\t\t\t// add path\r\n\t\t\tif (meta.getPathField()!=null && meta.getPathField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.path;\r\n\t\t\t}\r\n\t\t\t// Add Size\r\n\t\t\tif (meta.getSizeField()!=null && meta.getSizeField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Long(data.size);\r\n\t\t\t}\r\n\t\t\t// add Hidden\r\n\t\t\tif (meta.isHiddenField()!=null && meta.isHiddenField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Boolean(data.path);\r\n\t\t\t}\r\n\t\t\t// Add modification date\r\n\t\t\tif (meta.getLastModificationDateField()!=null && meta.getLastModificationDateField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.lastModificationDateTime;\r\n\t\t\t}\r\n\t\t\t// Add Uri\r\n\t\t\tif (meta.getUriField()!=null && meta.getUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.uriName;\r\n\t\t\t}\r\n\t\t\t// Add RootUri\r\n\t\t\tif (meta.getRootUriField()!=null && meta.getRootUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.rootUriName;\r\n\t\t\t}\r\n\r\n\t\t\tRowMetaInterface irow = getInputRowMeta();\r\n\t\t\t\r\n\t\t\tif (irow == null) {\r\n\t\t\t  data.previousRow = outputRowData;\r\n\t\t\t} else {\r\n\t\t\t  // clone to previously allocated array to make sure next step doesn't\r\n\t\t\t  // change it in between...\r\n\t\t\t  for (int i=0; i<outputRowData.length; i++) {\r\n\t\t\t    // Clone without re-allocating array\r\n\t\t\t    this.prevRow[i] = outputRowData[i]; // Direct copy\r\n\t\t\t  }\r\n        data.previousRow = irow.cloneRow(outputRowData, this.prevRow); // Pick up everything else that needs a real deep clone \r\n\t\t\t}\r\n\t    \r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\t if (getStepMeta().isDoingErrorHandling())\r\n\t\t\t {\r\n\t\t\t\t //Simply add this row to the error row\r\n\t\t\t\t putError(data.outputRowMeta, outputRowData, 1, e.toString(), null, \"GetXMLData001\");\r\n\t\t\t\t data.errorInRowButContinue = true;\t\t\t\t \r\n\t\t\t\t return null;\r\n\t\t\t } else {\r\n\t\t\t\tlogError(e.toString());\r\n\t\t\t\tthrow new KettleException(e.toString());\r\n\t\t\t }\r\n\t\t} \r\n\t\treturn outputRowData;\r\n\t}","id":101157,"modified_method":"private Object[] processPutRow(AbstractNode node) throws KettleException\r\n\t{\r\n\t\t// Create new row...\r\n\t\tObject[] outputRowData = buildEmptyRow();\r\n\t\t\r\n\t\t // Create new row\tor clone\r\n\t\tif(meta.isInFields()) {\r\n\t\t\t System.arraycopy(data.readrow, 0, outputRowData, 0, data.nrReadRow);\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdata.nodenr++; \r\n\r\n\t\t\t// Read fields...\r\n\t\t\tfor (int i=0;i<data.nrInputFields;i++)\r\n\t\t\t{\t\r\n\t\t\t\t// Get field\r\n\t\t\t\tGetXMLDataField xmlDataField = meta.getInputFields()[i];\r\n\t\t\t\t// Get the Path to look for\r\n\t\t\t\tString XPathValue = xmlDataField.getXPath();\r\n\r\n\t\t\t\tif(meta.isuseToken())\r\n\t\t\t\t{\r\n\t\t\t\t\t// See if user use Token inside path field\r\n\t\t\t\t\t// The syntax is : @_Fieldname-\r\n\t\t\t\t\t// PDI will search for Fieldname value and replace it\r\n\t\t\t\t\t// Fieldname must be defined before the current node\r\n\t\t\t\t\tXPathValue=substituteToken(XPathValue, outputRowData);\r\n\t\t\t\t\tif (isDetailed()) \tlogDetailed(XPathValue);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Get node value\r\n\t\t\t\tString nodevalue =null;\r\n\t\t\t\t\r\n\t\t\t\t// Handle namespaces\r\n\t\t\t\tif(meta.isNamespaceAware())\r\n\t\t\t\t{\r\n\t\t\t\t\tXPath xpathField = node.createXPath(addNSPrefix(XPathValue, data.PathValue));\r\n\t\t\t\t\txpathField.setNamespaceURIs(data.NAMESPACE);\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=xpathField.valueOf(node);\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// nodevalue=xpathField.selectSingleNode(node).asXML();\r\n            Node n = xpathField.selectSingleNode(node);\r\n            if (n != null)\r\n              nodevalue = n.asXML();\r\n\t\t\t\t\telse\r\n              nodevalue = \"\";\r\n          }\r\n\t\t\t\t}else\r\n\t\t\t\t{\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=node.valueOf(XPathValue);\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// nodevalue=node.selectSingleNode(XPathValue).asXML();\r\n            Node n = node.selectSingleNode(XPathValue);\r\n            if (n != null)\r\n              nodevalue = n.asXML();\r\n\t\t\t\t\telse\r\n              nodevalue = \"\";\r\n          }\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Do trimming\r\n\t\t\t\tswitch (xmlDataField.getTrimType())\r\n\t\t\t\t{\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_LEFT:\r\n\t\t\t\t\t\tnodevalue = Const.ltrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_RIGHT:\r\n\t\t\t\t\t\tnodevalue = Const.rtrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_BOTH:\r\n\t\t\t\t\t\tnodevalue = Const.trim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\r\n\t\t\t\t// Do conversions\r\n\t\t\t\t//\r\n\t\t\t\tValueMetaInterface targetValueMeta = data.outputRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\tValueMetaInterface sourceValueMeta = data.convertRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\toutputRowData[data.totalpreviousfields+i] = targetValueMeta.convertData(sourceValueMeta, nodevalue);\r\n\r\n\t\t\t\t// Do we need to repeat this field if it is null?\r\n\t\t\t\tif (meta.getInputFields()[i].isRepeated())\r\n\t\t\t\t{\r\n\t\t\t\t\tif (data.previousRow!=null && Const.isEmpty(nodevalue))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toutputRowData[data.totalpreviousfields+i] = data.previousRow[data.totalpreviousfields+i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}// End of loop over fields...\t\r\n\t\t\t\r\n\t\t\tint rowIndex = data.totalpreviousfields+ data.nrInputFields;\r\n\t\t\t\r\n\t\t\t// See if we need to add the filename to the row...\r\n\t\t\tif ( meta.includeFilename() && !Const.isEmpty(meta.getFilenameField()) ) {\r\n\t\t\t\toutputRowData[rowIndex++] = data.filename;\r\n\t\t\t}\r\n\t\t\t // See if we need to add the row number to the row...  \r\n\t        if (meta.includeRowNumber() && !Const.isEmpty(meta.getRowNumberField()))\r\n\t        {\r\n\t            outputRowData[rowIndex++] = new Long(data.rownr);\r\n\t        }\r\n\t        // Possibly add short filename...\r\n\t\t\tif (meta.getShortFileNameField()!=null && meta.getShortFileNameField().length()>0)\r\n\t\t\t{\t\t\t\t\r\n\t\t\t\toutputRowData[rowIndex++] = data.shortFilename;\r\n\t\t\t}\r\n\t\t\t// Add Extension\r\n\t\t\tif (meta.getExtensionField()!=null && meta.getExtensionField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.extension;\r\n\t\t\t}\r\n\t\t\t// add path\r\n\t\t\tif (meta.getPathField()!=null && meta.getPathField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.path;\r\n\t\t\t}\r\n\t\t\t// Add Size\r\n\t\t\tif (meta.getSizeField()!=null && meta.getSizeField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Long(data.size);\r\n\t\t\t}\r\n\t\t\t// add Hidden\r\n\t\t\tif (meta.isHiddenField()!=null && meta.isHiddenField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Boolean(data.path);\r\n\t\t\t}\r\n\t\t\t// Add modification date\r\n\t\t\tif (meta.getLastModificationDateField()!=null && meta.getLastModificationDateField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.lastModificationDateTime;\r\n\t\t\t}\r\n\t\t\t// Add Uri\r\n\t\t\tif (meta.getUriField()!=null && meta.getUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.uriName;\r\n\t\t\t}\r\n\t\t\t// Add RootUri\r\n\t\t\tif (meta.getRootUriField()!=null && meta.getRootUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.rootUriName;\r\n\t\t\t}\r\n\r\n\t\t\tRowMetaInterface irow = getInputRowMeta();\r\n\t\t\t\r\n\t\t\tif (irow == null) {\r\n\t\t\t  data.previousRow = outputRowData;\r\n\t\t\t} else {\r\n\t\t\t  // clone to previously allocated array to make sure next step doesn't\r\n\t\t\t  // change it in between...\r\n\t\t\t  for (int i=0; i<outputRowData.length; i++) {\r\n\t\t\t    // Clone without re-allocating array\r\n\t\t\t    this.prevRow[i] = outputRowData[i]; // Direct copy\r\n\t\t\t  }\r\n        data.previousRow = irow.cloneRow(outputRowData, this.prevRow); // Pick up everything else that needs a real deep clone \r\n\t\t\t}\r\n\t    \r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\t if (getStepMeta().isDoingErrorHandling())\r\n\t\t\t {\r\n\t\t\t\t //Simply add this row to the error row\r\n\t\t\t\t putError(data.outputRowMeta, outputRowData, 1, e.toString(), null, \"GetXMLData001\");\r\n\t\t\t\t data.errorInRowButContinue = true;\t\t\t\t \r\n\t\t\t\t return null;\r\n\t\t\t } else {\r\n\t\t\t\tlogError(e.toString());\r\n\t\t\t\tthrow new KettleException(e.toString());\r\n\t\t\t }\r\n\t\t} \r\n\t\treturn outputRowData;\r\n\t}","commit_id":"145fd3ae3b6a31d61714901d4f72f07f26eeb838","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private Object[] processPutRow(AbstractNode node) throws KettleException\r\n\t{\r\n\t\t// Create new row...\r\n\t\tObject[] outputRowData = buildEmptyRow();\r\n\t\t\r\n\t\t // Create new row\tor clone\r\n\t\tif(meta.isInFields()) {\r\n\t\t\t System.arraycopy(data.readrow, 0, outputRowData, 0, data.nrReadRow);\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdata.nodenr++; \r\n\r\n\t\t\t// Read fields...\r\n\t\t\tfor (int i=0;i<data.nrInputFields;i++)\r\n\t\t\t{\t\r\n\t\t\t\t// Get field\r\n\t\t\t\tGetXMLDataField xmlDataField = meta.getInputFields()[i];\r\n\t\t\t\t// Get the Path to look for\r\n\t\t\t\tString XPathValue = xmlDataField.getXPath();\r\n\r\n\t\t\t\tif(meta.isuseToken())\r\n\t\t\t\t{\r\n\t\t\t\t\t// See if user use Token inside path field\r\n\t\t\t\t\t// The syntax is : @_Fieldname-\r\n\t\t\t\t\t// PDI will search for Fieldname value and replace it\r\n\t\t\t\t\t// Fieldname must be defined before the current node\r\n\t\t\t\t\tXPathValue=substituteToken(XPathValue, outputRowData);\r\n\t\t\t\t\tif (isDetailed()) \tlogDetailed(XPathValue);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Get node value\r\n\t\t\t\tString nodevalue =null;\r\n\t\t\t\t\r\n\t\t\t\t// Handle namespaces\r\n\t\t\t\tif(meta.isNamespaceAware())\r\n\t\t\t\t{\r\n\t\t\t\t\tXPath xpathField = node.createXPath(addNSPrefix(XPathValue, data.PathValue));\r\n\t\t\t\t\txpathField.setNamespaceURIs(data.NAMESPACE);\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=xpathField.valueOf(node);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnodevalue=xpathField.selectSingleNode(node).asXML();\r\n\t\t\t\t}else\r\n\t\t\t\t{\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=node.valueOf(XPathValue);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnodevalue=node.selectSingleNode(XPathValue).asXML();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Do trimming\r\n\t\t\t\tswitch (xmlDataField.getTrimType())\r\n\t\t\t\t{\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_LEFT:\r\n\t\t\t\t\t\tnodevalue = Const.ltrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_RIGHT:\r\n\t\t\t\t\t\tnodevalue = Const.rtrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_BOTH:\r\n\t\t\t\t\t\tnodevalue = Const.trim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\r\n\t\t\t\t// Do conversions\r\n\t\t\t\t//\r\n\t\t\t\tValueMetaInterface targetValueMeta = data.outputRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\tValueMetaInterface sourceValueMeta = data.convertRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\toutputRowData[data.totalpreviousfields+i] = targetValueMeta.convertData(sourceValueMeta, nodevalue);\r\n\r\n\t\t\t\t// Do we need to repeat this field if it is null?\r\n\t\t\t\tif (meta.getInputFields()[i].isRepeated())\r\n\t\t\t\t{\r\n\t\t\t\t\tif (data.previousRow!=null && Const.isEmpty(nodevalue))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toutputRowData[data.totalpreviousfields+i] = data.previousRow[data.totalpreviousfields+i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}// End of loop over fields...\t\r\n\t\t\t\r\n\t\t\tint rowIndex = data.totalpreviousfields+ data.nrInputFields;\r\n\t\t\t\r\n\t\t\t// See if we need to add the filename to the row...\r\n\t\t\tif ( meta.includeFilename() && !Const.isEmpty(meta.getFilenameField()) ) {\r\n\t\t\t\toutputRowData[rowIndex++] = data.filename;\r\n\t\t\t}\r\n\t\t\t // See if we need to add the row number to the row...  \r\n\t        if (meta.includeRowNumber() && !Const.isEmpty(meta.getRowNumberField()))\r\n\t        {\r\n\t            outputRowData[rowIndex++] = new Long(data.rownr);\r\n\t        }\r\n\t        // Possibly add short filename...\r\n\t\t\tif (meta.getShortFileNameField()!=null && meta.getShortFileNameField().length()>0)\r\n\t\t\t{\t\t\t\t\r\n\t\t\t\toutputRowData[rowIndex++] = data.shortFilename;\r\n\t\t\t}\r\n\t\t\t// Add Extension\r\n\t\t\tif (meta.getExtensionField()!=null && meta.getExtensionField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.extension;\r\n\t\t\t}\r\n\t\t\t// add path\r\n\t\t\tif (meta.getPathField()!=null && meta.getPathField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.path;\r\n\t\t\t}\r\n\t\t\t// Add Size\r\n\t\t\tif (meta.getSizeField()!=null && meta.getSizeField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Long(data.size);\r\n\t\t\t}\r\n\t\t\t// add Hidden\r\n\t\t\tif (meta.isHiddenField()!=null && meta.isHiddenField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Boolean(data.path);\r\n\t\t\t}\r\n\t\t\t// Add modification date\r\n\t\t\tif (meta.getLastModificationDateField()!=null && meta.getLastModificationDateField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.lastModificationDateTime;\r\n\t\t\t}\r\n\t\t\t// Add Uri\r\n\t\t\tif (meta.getUriField()!=null && meta.getUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.uriName;\r\n\t\t\t}\r\n\t\t\t// Add RootUri\r\n\t\t\tif (meta.getRootUriField()!=null && meta.getRootUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.rootUriName;\r\n\t\t\t}\r\n\r\n\t\t\tRowMetaInterface irow = getInputRowMeta();\r\n\t\t\t\r\n\t\t\tif (irow == null) {\r\n\t\t\t  data.previousRow = outputRowData;\r\n\t\t\t} else {\r\n\t\t\t  // clone to previously allocated array to make sure next step doesn't\r\n\t\t\t  // change it in between...\r\n\t\t\t  for (int i=0; i<outputRowData.length; i++) {\r\n\t\t\t    // Clone without re-allocating array\r\n\t\t\t    this.prevRow[i] = outputRowData[i]; // Direct copy\r\n\t\t\t  }\r\n        data.previousRow = irow.cloneRow(outputRowData, this.prevRow); // Pick up everything else that needs a real deep clone \r\n\t\t\t}\r\n\t    \r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\t if (getStepMeta().isDoingErrorHandling())\r\n\t\t\t {\r\n\t\t\t\t //Simply add this row to the error row\r\n\t\t\t\t putError(data.outputRowMeta, outputRowData, 1, e.toString(), null, \"GetXMLData001\");\r\n\t\t\t\t data.errorInRowButContinue = true;\t\t\t\t \r\n\t\t\t\t return null;\r\n\t\t\t } else {\r\n\t\t\t\tlogError(e.toString());\r\n\t\t\t\tthrow new KettleException(e.toString());\r\n\t\t\t }\r\n\t\t} \r\n\t\treturn outputRowData;\r\n\t}","id":101158,"modified_method":"private Object[] processPutRow(AbstractNode node) throws KettleException\r\n\t{\r\n\t\t// Create new row...\r\n\t\tObject[] outputRowData = buildEmptyRow();\r\n\t\t\r\n\t\t // Create new row\tor clone\r\n\t\tif(meta.isInFields()) {\r\n\t\t\t System.arraycopy(data.readrow, 0, outputRowData, 0, data.nrReadRow);\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\tdata.nodenr++; \r\n\r\n\t\t\t// Read fields...\r\n\t\t\tfor (int i=0;i<data.nrInputFields;i++)\r\n\t\t\t{\t\r\n\t\t\t\t// Get field\r\n\t\t\t\tGetXMLDataField xmlDataField = meta.getInputFields()[i];\r\n\t\t\t\t// Get the Path to look for\r\n\t\t\t\tString XPathValue = xmlDataField.getXPath();\r\n\r\n\t\t\t\tif(meta.isuseToken())\r\n\t\t\t\t{\r\n\t\t\t\t\t// See if user use Token inside path field\r\n\t\t\t\t\t// The syntax is : @_Fieldname-\r\n\t\t\t\t\t// PDI will search for Fieldname value and replace it\r\n\t\t\t\t\t// Fieldname must be defined before the current node\r\n\t\t\t\t\tXPathValue=substituteToken(XPathValue, outputRowData);\r\n\t\t\t\t\tif (isDetailed()) \tlogDetailed(XPathValue);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Get node value\r\n\t\t\t\tString nodevalue =null;\r\n\t\t\t\t\r\n\t\t\t\t// Handle namespaces\r\n\t\t\t\tif(meta.isNamespaceAware())\r\n\t\t\t\t{\r\n\t\t\t\t\tXPath xpathField = node.createXPath(addNSPrefix(XPathValue, data.PathValue));\r\n\t\t\t\t\txpathField.setNamespaceURIs(data.NAMESPACE);\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=xpathField.valueOf(node);\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// nodevalue=xpathField.selectSingleNode(node).asXML();\r\n            Node n = xpathField.selectSingleNode(node);\r\n            if (n != null)\r\n              nodevalue = n.asXML();\r\n\t\t\t\t\telse\r\n              nodevalue = \"\";\r\n          }\r\n\t\t\t\t}else\r\n\t\t\t\t{\r\n\t\t\t\t\tif(xmlDataField.getResultType()== GetXMLDataField.RESULT_TYPE_VALUE_OF)\r\n\t\t\t\t\t\tnodevalue=node.valueOf(XPathValue);\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// nodevalue=node.selectSingleNode(XPathValue).asXML();\r\n            Node n = node.selectSingleNode(XPathValue);\r\n            if (n != null)\r\n              nodevalue = n.asXML();\r\n\t\t\t\t\telse\r\n              nodevalue = \"\";\r\n          }\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Do trimming\r\n\t\t\t\tswitch (xmlDataField.getTrimType())\r\n\t\t\t\t{\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_LEFT:\r\n\t\t\t\t\t\tnodevalue = Const.ltrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_RIGHT:\r\n\t\t\t\t\t\tnodevalue = Const.rtrim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GetXMLDataField.TYPE_TRIM_BOTH:\r\n\t\t\t\t\t\tnodevalue = Const.trim(nodevalue);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\r\n\t\t\t\t// Do conversions\r\n\t\t\t\t//\r\n\t\t\t\tValueMetaInterface targetValueMeta = data.outputRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\tValueMetaInterface sourceValueMeta = data.convertRowMeta.getValueMeta(data.totalpreviousfields+i);\r\n\t\t\t\toutputRowData[data.totalpreviousfields+i] = targetValueMeta.convertData(sourceValueMeta, nodevalue);\r\n\r\n\t\t\t\t// Do we need to repeat this field if it is null?\r\n\t\t\t\tif (meta.getInputFields()[i].isRepeated())\r\n\t\t\t\t{\r\n\t\t\t\t\tif (data.previousRow!=null && Const.isEmpty(nodevalue))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toutputRowData[data.totalpreviousfields+i] = data.previousRow[data.totalpreviousfields+i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}// End of loop over fields...\t\r\n\t\t\t\r\n\t\t\tint rowIndex = data.totalpreviousfields+ data.nrInputFields;\r\n\t\t\t\r\n\t\t\t// See if we need to add the filename to the row...\r\n\t\t\tif ( meta.includeFilename() && !Const.isEmpty(meta.getFilenameField()) ) {\r\n\t\t\t\toutputRowData[rowIndex++] = data.filename;\r\n\t\t\t}\r\n\t\t\t // See if we need to add the row number to the row...  \r\n\t        if (meta.includeRowNumber() && !Const.isEmpty(meta.getRowNumberField()))\r\n\t        {\r\n\t            outputRowData[rowIndex++] = new Long(data.rownr);\r\n\t        }\r\n\t        // Possibly add short filename...\r\n\t\t\tif (meta.getShortFileNameField()!=null && meta.getShortFileNameField().length()>0)\r\n\t\t\t{\t\t\t\t\r\n\t\t\t\toutputRowData[rowIndex++] = data.shortFilename;\r\n\t\t\t}\r\n\t\t\t// Add Extension\r\n\t\t\tif (meta.getExtensionField()!=null && meta.getExtensionField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.extension;\r\n\t\t\t}\r\n\t\t\t// add path\r\n\t\t\tif (meta.getPathField()!=null && meta.getPathField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.path;\r\n\t\t\t}\r\n\t\t\t// Add Size\r\n\t\t\tif (meta.getSizeField()!=null && meta.getSizeField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Long(data.size);\r\n\t\t\t}\r\n\t\t\t// add Hidden\r\n\t\t\tif (meta.isHiddenField()!=null && meta.isHiddenField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = new Boolean(data.path);\r\n\t\t\t}\r\n\t\t\t// Add modification date\r\n\t\t\tif (meta.getLastModificationDateField()!=null && meta.getLastModificationDateField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.lastModificationDateTime;\r\n\t\t\t}\r\n\t\t\t// Add Uri\r\n\t\t\tif (meta.getUriField()!=null && meta.getUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.uriName;\r\n\t\t\t}\r\n\t\t\t// Add RootUri\r\n\t\t\tif (meta.getRootUriField()!=null && meta.getRootUriField().length()>0)\r\n\t\t\t{\r\n\t\t\t\toutputRowData[rowIndex++] = data.rootUriName;\r\n\t\t\t}\r\n\r\n\t\t\tRowMetaInterface irow = getInputRowMeta();\r\n\t\t\t\r\n\t\t\tif (irow == null) {\r\n\t\t\t  data.previousRow = outputRowData;\r\n\t\t\t} else {\r\n\t\t\t  // clone to previously allocated array to make sure next step doesn't\r\n\t\t\t  // change it in between...\r\n\t\t\t  for (int i=0; i<outputRowData.length; i++) {\r\n\t\t\t    // Clone without re-allocating array\r\n\t\t\t    this.prevRow[i] = outputRowData[i]; // Direct copy\r\n\t\t\t  }\r\n        data.previousRow = irow.cloneRow(outputRowData, this.prevRow); // Pick up everything else that needs a real deep clone \r\n\t\t\t}\r\n\t    \r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\t if (getStepMeta().isDoingErrorHandling())\r\n\t\t\t {\r\n\t\t\t\t //Simply add this row to the error row\r\n\t\t\t\t putError(data.outputRowMeta, outputRowData, 1, e.toString(), null, \"GetXMLData001\");\r\n\t\t\t\t data.errorInRowButContinue = true;\t\t\t\t \r\n\t\t\t\t return null;\r\n\t\t\t } else {\r\n\t\t\t\tlogError(e.toString());\r\n\t\t\t\tthrow new KettleException(e.toString());\r\n\t\t\t }\r\n\t\t} \r\n\t\treturn outputRowData;\r\n\t}","commit_id":"acbc2c44078aa5346b9536bfc01980b86a23cd4d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Nullable\n  protected static Editor navigate(Project project, int offset, @Nullable VirtualFile vfile) {\n    if (vfile == null) {\n      return null;\n    }\n    new OpenFileDescriptor(project, vfile, offset).navigate(true); // properly contributes to editing history\n    FileEditor fileEditor = FileEditorManager.getInstance(project).getSelectedEditor(vfile);\n    if (fileEditor instanceof TextEditor) {\n      final Editor editor = ((TextEditor)fileEditor).getEditor();\n      editor.getCaretModel().moveToOffset(offset);\n      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      return editor;\n    }\n    return null;\n  }","id":101159,"modified_method":"@Nullable\n  protected static Editor navigate(@NotNull final Project project, @NotNull final VirtualFile file, final int offset) {\n    final OpenFileDescriptor descriptor = new OpenFileDescriptor(project, file, offset);\n    descriptor.setScrollType(ScrollType.MAKE_VISIBLE);\n    descriptor.navigate(true);\n\n    final FileEditor fileEditor = FileEditorManager.getInstance(project).getSelectedEditor(file);\n    return fileEditor instanceof TextEditor ? ((TextEditor)fileEditor).getEditor() : null;\n  }","commit_id":"2d6a9cd08ed64fab6af07d49dc9fc955ced56e7d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    PsiElement anchor = findAnchor(psiElement);\n    if (anchor == null) {\n      return;\n    }\n\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    template.addTextSegment(\"class \");\n    template.addVariable(DartPresentableUtil.getExpression(myClassName), false);\n    template.addTextSegment(\"{\\n\");\n    template.addEndVariable();\n    template.addTextSegment(\"\\n}\\n\");\n\n    final Editor openedEditor = navigate(project, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","id":101160,"modified_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    PsiElement anchor = findAnchor(psiElement);\n    if (anchor == null) {\n      return;\n    }\n\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    template.addTextSegment(\"class \");\n    template.addVariable(DartPresentableUtil.getExpression(myClassName), false);\n    template.addTextSegment(\"{\\n\");\n    template.addEndVariable();\n    template.addTextSegment(\"\\n}\\n\");\n\n    VirtualFile file = anchor.getContainingFile().getVirtualFile();\n    final Editor openedEditor = file == null ? null : navigate(project, file, anchor.getTextOffset());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","commit_id":"2d6a9cd08ed64fab6af07d49dc9fc955ced56e7d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    if (!buildTemplate(template, psiElement)) {\n      return;\n    }\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    final Editor openedEditor = navigate(project, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","id":101161,"modified_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    if (!buildTemplate(template, psiElement)) {\n      return;\n    }\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    VirtualFile file = anchor.getContainingFile().getVirtualFile();\n    final Editor openedEditor = file == null ? null : navigate(project, file, anchor.getTextOffset());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","commit_id":"2d6a9cd08ed64fab6af07d49dc9fc955ced56e7d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    buildTemplate(template, psiElement);\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    final Editor openedEditor = navigate(project, anchor.getTextOffset(), anchor.getContainingFile().getVirtualFile());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","id":101162,"modified_method":"@Override\n  protected void applyFix(Project project, @NotNull PsiElement psiElement, Editor editor) {\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    buildTemplate(template, psiElement);\n\n    PsiElement anchor = findAnchor(psiElement);\n\n    if (anchor == null) {\n      CommonRefactoringUtil.showErrorHint(\n        project,\n        editor,\n        DartBundle.message(\"dart.create.function.intention.family\"),\n        DartBundle.message(\"dart.cannot.find.place.to.create\"),\n        null\n      );\n      return;\n    }\n\n    VirtualFile file = anchor.getContainingFile().getVirtualFile();\n    final Editor openedEditor = file == null ? null : navigate(project, file, anchor.getTextOffset());\n    if (openedEditor != null) {\n      templateManager.startTemplate(openedEditor, template);\n    }\n  }","commit_id":"2d6a9cd08ed64fab6af07d49dc9fc955ced56e7d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {\n    final SourceFileEdit fileEdit = myChange.getEdits().get(0);\n    final String filePath = FileUtil.toSystemIndependentName(fileEdit.getFile());\n    final SourceEdit sourceEdit = fileEdit.getEdits().get(0);\n\n    final VirtualFile virtualFile;\n\n    // Create the file if it does not exist.\n    if (fileEdit.getFileStamp() == -1) {\n      try {\n        final String directoryPath = PathUtil.getParentPath(filePath);\n        if (directoryPath.isEmpty()) throw new IOException(\"empty folder path\");\n\n        final VirtualFile directory = VfsUtil.createDirectoryIfMissing(directoryPath);\n        if (directory == null) throw new IOException(\"failed to create folder \" + FileUtil.toSystemDependentName(directoryPath));\n\n        virtualFile = directory.createChildData(this, PathUtil.getFileName(filePath));\n      }\n      catch (IOException e) {\n        final String message = DartBundle.message(\"failed.to.create.file.0.1\", FileUtil.toSystemDependentName(filePath), e.getMessage());\n        CommonRefactoringUtil.showErrorHint(project, editor, message, CommonBundle.getErrorTitle(), null);\n        return;\n      }\n    }\n    else {\n      virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);\n    }\n\n    if (virtualFile == null) return;\n\n    if (!FileModificationService.getInstance().prepareVirtualFilesForWrite(project, Collections.singletonList(virtualFile))) return;\n\n    final Document document = FileDocumentManager.getInstance().getDocument(virtualFile);\n    if (document == null) return;\n\n    // Templates can only grow source, so we trim first if necessary\n    if (sourceEdit.getLength() > 0) {\n      final Runnable runnable = new Runnable() {\n        public void run() {\n          document.deleteString(sourceEdit.getOffset(), sourceEdit.getOffset() + sourceEdit.getLength());\n        }\n      };\n\n      if (CommandProcessor.getInstance().getCurrentCommand() == null) {\n        CommandProcessor.getInstance().runUndoTransparentAction(runnable);\n      }\n      else {\n        runnable.run();\n      }\n    }\n\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    final Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    addContents(template, sourceEdit);\n\n    final Editor targetEditor = BaseCreateFix.navigate(project, sourceEdit.getOffset(), virtualFile);\n    if (targetEditor != null) {\n      templateManager.startTemplate(targetEditor, template);\n    }\n  }","id":101163,"modified_method":"@Override\n  public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file) throws IncorrectOperationException {\n    final SourceFileEdit fileEdit = myChange.getEdits().get(0);\n    final String filePath = FileUtil.toSystemIndependentName(fileEdit.getFile());\n    final SourceEdit sourceEdit = fileEdit.getEdits().get(0);\n\n    final VirtualFile virtualFile;\n\n    // Create the file if it does not exist.\n    if (fileEdit.getFileStamp() == -1) {\n      try {\n        final String directoryPath = PathUtil.getParentPath(filePath);\n        if (directoryPath.isEmpty()) throw new IOException(\"empty folder path\");\n\n        final VirtualFile directory = VfsUtil.createDirectoryIfMissing(directoryPath);\n        if (directory == null) throw new IOException(\"failed to create folder \" + FileUtil.toSystemDependentName(directoryPath));\n\n        virtualFile = directory.createChildData(this, PathUtil.getFileName(filePath));\n      }\n      catch (IOException e) {\n        final String message = DartBundle.message(\"failed.to.create.file.0.1\", FileUtil.toSystemDependentName(filePath), e.getMessage());\n        CommonRefactoringUtil.showErrorHint(project, editor, message, CommonBundle.getErrorTitle(), null);\n        return;\n      }\n    }\n    else {\n      virtualFile = LocalFileSystem.getInstance().findFileByPath(filePath);\n    }\n\n    if (virtualFile == null) return;\n\n    if (!FileModificationService.getInstance().prepareVirtualFilesForWrite(project, Collections.singletonList(virtualFile))) return;\n\n    final Document document = FileDocumentManager.getInstance().getDocument(virtualFile);\n    if (document == null) return;\n\n    // Templates can only grow source, so we trim first if necessary\n    if (sourceEdit.getLength() > 0) {\n      final Runnable runnable = new Runnable() {\n        public void run() {\n          document.deleteString(sourceEdit.getOffset(), sourceEdit.getOffset() + sourceEdit.getLength());\n        }\n      };\n\n      if (CommandProcessor.getInstance().getCurrentCommand() == null) {\n        CommandProcessor.getInstance().runUndoTransparentAction(runnable);\n      }\n      else {\n        runnable.run();\n      }\n    }\n\n    final TemplateManager templateManager = TemplateManager.getInstance(project);\n    final Template template = templateManager.createTemplate(\"\", \"\");\n    template.setToReformat(true);\n\n    addContents(template, sourceEdit);\n\n    final Editor targetEditor = BaseCreateFix.navigate(project, virtualFile, sourceEdit.getOffset());\n    if (targetEditor != null) {\n      templateManager.startTemplate(targetEditor, template);\n    }\n  }","commit_id":"2d6a9cd08ed64fab6af07d49dc9fc955ced56e7d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassConstructorsScope(_context.getEnclosingNode(), operationContext.getScope());\n  }","id":101164,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassConstructorsScope(((_context.getReferenceNode() == null) ?\n      _context.getEnclosingNode() :\n      _context.getReferenceNode()\n    ), operationContext.getScope());\n  }","commit_id":"46ecd3cd11cb1d159fa934615e7922f2a1d24558","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassifiersScope(_context.getEnclosingNode(), IClassifiersSearchScope.CLASSIFFIER, operationContext.getScope());\n  }","id":101165,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassifiersScope(((_context.getReferenceNode() == null) ?\n      _context.getEnclosingNode() :\n      _context.getReferenceNode()\n    ), IClassifiersSearchScope.CLASSIFFIER, operationContext.getScope());\n  }","commit_id":"46ecd3cd11cb1d159fa934615e7922f2a1d24558","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<SNode> getClassifierMembers() {\n    List<SNode> members = this.getAllClassifierMembers();\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode memberNode : members) {\n      SNode member = SNodeOperations.cast(memberNode, \"jetbrains.mps.baseLanguage.structure.ClassifierMember\");\n      if (VisibilityUtil.isVisible(this.myContextNode, member)) {\n        ListSequence.fromList(result).addElement(member);\n      }\n    }\n    return result;\n  }","id":101166,"modified_method":"private List<SNode> getClassifierMembers() {\n    List<SNode> members = this.getAllClassifierMembers();\n    List<SNode> result = new ArrayList<SNode>();\n    for (SNode memberNode : members) {\n      SNode member = SNodeOperations.cast(memberNode, \"jetbrains.mps.baseLanguage.structure.ClassifierMember\");\n      if (myContextNode == null || VisibilityUtil.isVisible(myContextNode, member)) {\n        ListSequence.fromList(result).addElement(member);\n      }\n    }\n    return result;\n  }","commit_id":"46ecd3cd11cb1d159fa934615e7922f2a1d24558","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassifiersScope(_context.getEnclosingNode(), IClassifiersSearchScope.ANYTHING, operationContext.getScope()) {\n      protected List<INodeAdapter> getNodesFormClassifiersList(List<Classifier> classifiers, int constraint, Condition<INodeAdapter> condition) {\n        List<INodeAdapter> result = new ArrayList<INodeAdapter>();\n        for (Classifier classifier : classifiers) {\n          if (classifier instanceof NamedTupleDeclaration) {\n            result.add(classifier);\n          }\n        }\n        return result;\n      }\n    };\n  }","id":101167,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassifiersScope(((_context.getReferenceNode() == null) ?\n      _context.getEnclosingNode() :\n      _context.getReferenceNode()\n    ), IClassifiersSearchScope.ANYTHING, operationContext.getScope()) {\n      protected List<INodeAdapter> getNodesFormClassifiersList(List<Classifier> classifiers, int constraint, Condition<INodeAdapter> condition) {\n        List<INodeAdapter> result = new ArrayList<INodeAdapter>();\n        for (Classifier classifier : classifiers) {\n          if (classifier instanceof NamedTupleDeclaration) {\n            result.add(classifier);\n          }\n        }\n        return result;\n      }\n    };\n  }","commit_id":"46ecd3cd11cb1d159fa934615e7922f2a1d24558","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassifiersScope(_context.getEnclosingNode(), IClassifiersSearchScope.CLASSIFFIER, operationContext.getScope()) {\n      @NotNull\n      @Override\n      public List<Classifier> getClassifiers() {\n        Set<SNode> enclosingClassifierAncestors = SetSequence.fromSet(new HashSet<SNode>());\n        SetSequence.fromSet(enclosingClassifierAncestors).addSequence(ListSequence.fromList(SNodeOperations.getAncestors(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.Classifier\", false)));\n\n        List<Classifier> result = new ArrayList();\n        for (Classifier classifier : ListSequence.fromList(super.getClassifiers())) {\n          if (classifier.getNonStatic()) {\n            continue;\n          }\n          if (classifier instanceof AnonymousClass) {\n            continue;\n          }\n          List<SNode> ancestors = classifier.getNode().getAncestors(true);\n          // Filtering out Classifiers located in third-party containers (not Classifiers) \n          // and having no common Classifier container with enclosing node. \n          // Useful for Classifiers contained in EditorTestCases \n          // (\"result\" should not be able to access classifiers from \"nodeToEdit\")... \n          if (ListSequence.fromList(ancestors).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return !(SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n            }\n          }).isNotEmpty() && ListSequence.fromList(ancestors).intersect(SetSequence.fromSet(enclosingClassifierAncestors)).isEmpty()) {\n            continue;\n          }\n          result.add(classifier);\n        }\n        return result;\n      }\n    };\n  }","id":101168,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new VisibleClassifiersScope(((_context.getReferenceNode() == null) ?\n      _context.getEnclosingNode() :\n      _context.getReferenceNode()\n    ), IClassifiersSearchScope.CLASSIFFIER, operationContext.getScope()) {\n      @NotNull\n      @Override\n      public List<Classifier> getClassifiers() {\n        Set<SNode> enclosingClassifierAncestors = SetSequence.fromSet(new HashSet<SNode>());\n        SetSequence.fromSet(enclosingClassifierAncestors).addSequence(ListSequence.fromList(SNodeOperations.getAncestors(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.Classifier\", false)));\n\n        List<Classifier> result = new ArrayList();\n        for (Classifier classifier : ListSequence.fromList(super.getClassifiers())) {\n          if (classifier.getNonStatic()) {\n            continue;\n          }\n          if (classifier instanceof AnonymousClass) {\n            continue;\n          }\n          List<SNode> ancestors = classifier.getNode().getAncestors(true);\n          // Filtering out Classifiers located in third-party containers (not Classifiers) \n          // and having no common Classifier container with enclosing node. \n          // Useful for Classifiers contained in EditorTestCases \n          // (\"result\" should not be able to access classifiers from \"nodeToEdit\")... \n          if (ListSequence.fromList(ancestors).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return !(SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n            }\n          }).isNotEmpty() && ListSequence.fromList(ancestors).intersect(SetSequence.fromSet(enclosingClassifierAncestors)).isEmpty()) {\n            continue;\n          }\n          result.add(classifier);\n        }\n        return result;\n      }\n    };\n  }","commit_id":"46ecd3cd11cb1d159fa934615e7922f2a1d24558","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean isVisible(@NotNull SNode context, @NotNull SNode name) {\n    // only check visibility of the name, accessibility of qualifier and if the name is member is not checked here \n    if (SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n      return isClassifierAccessible(context, SNodeOperations.cast(name, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(name, \"visibility\", true), \"jetbrains.mps.baseLanguage.structure.PublicVisibility\") || SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration\")) {\n      return true;\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(name, \"visibility\", true), \"jetbrains.mps.baseLanguage.structure.PrivateVisibility\")) {\n      return topClassifier(context) == topClassifier(name);\n    }\n    // package or protected access \n    if (packageName(context).equals(packageName(name))) {\n      return true;\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(name, \"visibility\", true), \"jetbrains.mps.baseLanguage.structure.ProtectedVisibility\")) {\n      //  checkspecial cases of protected access \n      SNode classifier = SNodeOperations.getAncestor(name, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      for (SNode cls : ListSequence.fromList(SNodeOperations.getAncestors(context, \"jetbrains.mps.baseLanguage.structure.Classifier\", true))) {\n        if (BaseLanguageUtil.isAssignable(((Classifier) SNodeOperations.getAdapter(cls)), ((Classifier) SNodeOperations.getAdapter(classifier)))) {\n          if (SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\") && SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\") || SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\") && SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\")) {\n            // check ExpressionName or PrimaryExpression is subclass of cls, works only with right context \n            //  will not work in the case: otherClass.method(protectedMethod()) with enclosed node as context \n            SNode qualifierType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(context), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true));\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(qualifierType, new VisibilityUtil.QuotationClass_v8uv56_a1a0d0a0a0c0g0a().createNode(cls))) {\n              return true;\n            }\n          } else if (SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\")) {\n            // check it is superclass constructor invocation or anonymous class instance creation \n            return SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation\") || SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\") || SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.AnonymousClassCreator\");\n          } else {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }","id":101169,"modified_method":"public static boolean isVisible(@NotNull SNode context, @NotNull SNode name) {\n    // only check visibility of the name, accessibility of qualifier and if the name is member is not checked here \n    if (SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n      return isClassifierAccessible(context, SNodeOperations.cast(name, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(name, \"visibility\", true), \"jetbrains.mps.baseLanguage.structure.PublicVisibility\") || SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration\")) {\n      return true;\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(name, \"visibility\", true), \"jetbrains.mps.baseLanguage.structure.PrivateVisibility\")) {\n      return topClassifier(context) == topClassifier(name);\n    }\n    // package or protected access \n    if (packageName(context).equals(packageName(name))) {\n      return true;\n    }\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(name, \"visibility\", true), \"jetbrains.mps.baseLanguage.structure.ProtectedVisibility\")) {\n      //  check special cases of protected access \n      SNode classifier = SNodeOperations.getAncestor(name, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      for (SNode cls : ListSequence.fromList(SNodeOperations.getAncestors(context, \"jetbrains.mps.baseLanguage.structure.Classifier\", true))) {\n        if (BaseLanguageUtil.isAssignable(((Classifier) SNodeOperations.getAdapter(cls)), ((Classifier) SNodeOperations.getAdapter(classifier)))) {\n          if (SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\") && SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\") || SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\") && SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\")) {\n            // check ExpressionName or PrimaryExpression is subclass of cls, works only with right context \n            //  will not work in the case: otherClass.method(protectedMethod()) with enclosed node as context \n            SNode qualifier = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(context), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(qualifier), new VisibilityUtil.QuotationClass_v8uv56_a1a0d0a0a0c0g0a().createNode(cls))) {\n              return true;\n            }\n          } else if (SNodeOperations.isInstanceOf(name, \"jetbrains.mps.baseLanguage.structure.ConstructorDeclaration\")) {\n            // check it is superclass constructor invocation or anonymous class instance creation \n            return SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.SuperConstructorInvocation\") || SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\") || SNodeOperations.isInstanceOf(context, \"jetbrains.mps.baseLanguage.structure.AnonymousClassCreator\");\n          } else {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"46ecd3cd11cb1d159fa934615e7922f2a1d24558","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isInScope(SNode node) {\n    // speed up IVisible nodes with context \n    if (myContextNode == null || !(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"))) {\n      return super.isInScope(node);\n    }\n    // check only NON_FINAL constraint, other constraints should be enforced by the reference type \n    if ((getConstraint() & NON_FINAL) != 0 && SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\") && SPropertyOperations.getBoolean(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"isFinal\")) {\n      return false;\n    }\n    return VisibilityUtil.isVisible(myContextNode, SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"));\n  }","id":101170,"modified_method":"public boolean isInScope(SNode node) {\n    // speed up IVisible nodes with context \n    if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"))) {\n      return super.isInScope(node);\n    }\n    // check only NON_FINAL constraint, other constraints should be enforced by the reference type \n    if ((getConstraint() & NON_FINAL) != 0 && SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\") && SPropertyOperations.getBoolean(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"isFinal\")) {\n      return false;\n    }\n    return VisibilityUtil.isVisible(myContextNode, SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"));\n  }","commit_id":"46ecd3cd11cb1d159fa934615e7922f2a1d24558","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isInScope(SNode node) {\n    if (myContextNode == null || !(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"))) {\n      return super.isInScope(node);\n    }\n    return VisibilityUtil.isVisible(myContextNode, SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"));\n  }","id":101171,"modified_method":"public boolean isInScope(SNode node) {\n    if (myContextNode == null || !(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassifierMember\"))) {\n      if (log.isErrorEnabled()) {\n        log.error(\"isInScope(\" + node + \") - context is null or not ClassifierMember\");\n      }\n      return super.isInScope(node);\n    }\n    return myClassifierScope.getClassifierNodes().contains(SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false)) && VisibilityUtil.isVisible(myContextNode, SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassifierMember\"));\n  }","commit_id":"5dc185168d321cf5e891018f16b1b1f915533ed3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ClassifierVisibleMembersScope(@Nullable SNode classifierType, @Nullable SNode contextNode, int constraint) {\n    this.myClassifierType = classifierType;\n    this.myContextNode = contextNode;\n    this.myClassifierScope = new ClassifierAndSuperClassifiersScope((classifierType != null ?\n      ((Classifier) SNodeOperations.getAdapter(SLinkOperations.getTarget(classifierType, \"classifier\", false))) :\n      null\n    ), constraint);\n  }","id":101172,"modified_method":"public ClassifierVisibleMembersScope(@Nullable SNode classifierType, @Nullable SNode contextNode, int constraint) {\n    this.myClassifierType = classifierType;\n    this.myContextNode = contextNode;\n    this.myClassifierScope = new ClassifierAndSuperClassifiersScope(((Classifier) SNodeOperations.getAdapter(SLinkOperations.getTarget(classifierType, \"classifier\", false))), constraint);\n  }","commit_id":"5dc185168d321cf5e891018f16b1b1f915533ed3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"))) {\n      return new SimpleSearchScope(new ArrayList());\n    }\n    SNode instance = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n    SNode classifierType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(instance), HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.structure.ClassifierType\"), false);\n    return new InstanceMethodCall_InstanceMethodScope(((ClassifierType) SNodeOperations.getAdapter(classifierType)), _context.getEnclosingNode());\n  }","id":101173,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"))) {\n      return new SimpleSearchScope(new ArrayList());\n    }\n    SNode instance = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n    SNode classifierType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(instance), HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.structure.ClassifierType\"), false);\n    return new InstanceMethodCall_InstanceMethodScope(((ClassifierType) SNodeOperations.getAdapter(classifierType)), ((_context.getReferenceNode() == null) ?\n      _context.getEnclosingNode() :\n      _context.getReferenceNode()\n    ));\n  }","commit_id":"5dc185168d321cf5e891018f16b1b1f915533ed3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isInScope(SNode node) {\n    // speed up IVisible nodes with context \n    if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"))) {\n      return super.isInScope(node);\n    }\n    // check only NON_FINAL constraint, other constraints should be enforced by the reference type \n    if ((getConstraint() & NON_FINAL) != 0 && SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\") && SPropertyOperations.getBoolean(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"isFinal\")) {\n      return false;\n    }\n    return VisibilityUtil.isVisible(myContextNode, SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"));\n  }","id":101174,"modified_method":"public boolean isInScope(SNode node) {\n    // speed up IVisible nodes with context \n    if (!(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"))) {\n      if (log.isErrorEnabled()) {\n        log.error(\"isInScope(\" + node + \") - not instance of IVisible\");\n      }\n      return super.isInScope(node);\n    }\n    // check only NON_FINAL constraint, other constraints should be enforced by the reference type \n    if ((getConstraint() & NON_FINAL) != 0 && SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\") && SPropertyOperations.getBoolean(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"isFinal\")) {\n      return false;\n    }\n    return VisibilityUtil.isVisible(myContextNode, SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.IVisible\"));\n  }","commit_id":"5dc185168d321cf5e891018f16b1b1f915533ed3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void refactorRenameNode(final IOperationContext context, final SNode node, String newName) {\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        SModelRepository.getInstance().saveAll();\n      }\n    });\n\n    final IRefactoring refactoring = (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\") ?\n      (IRefactoring) new RenameConcept() :\n      (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\") ?\n        (IRefactoring) new RenameProperty() :\n        (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\") ?\n          (IRefactoring) new RenameLink() :\n          null\n        )\n      )\n    );\n    if (refactoring == null) {\n      return;\n    }\n\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring);\n    refactoringContext.setCurrentOperationContext(context);\n    refactoringContext.setSelectedNode(node);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoringContext.setSelectedModel(SNodeOperations.getModel(node).getModelDescriptor());\n      }\n    });\n    refactoringContext.setSelectedModule(context.getModule());\n    refactoringContext.setSelectedProject(context.getProject());\n\n    // set new name parameter for refactoring to skip initial dialog \n    refactoringContext.setParameter(\"myNewName\", newName);\n\n    new Thread() {\n      public void run() {\n        new RefactoringProcessor().execute(refactoring, refactoringContext);\n      }\n    }.start();\n  }","id":101175,"modified_method":"public static void refactorRenameNode(final IOperationContext context, final SNode node, String newName) {\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        SModelRepository.getInstance().saveAll();\n      }\n    });\n\n    final IRefactoring refactoring = (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\") ?\n      new RenameConcept() :\n      (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.PropertyDeclaration\") ?\n        new RenameProperty() :\n        (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.structure.structure.LinkDeclaration\") ?\n          new RenameLink() :\n          null\n        )\n      )\n    );\n    if (refactoring == null) {\n      return;\n    }\n\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring);\n    refactoringContext.setCurrentOperationContext(context);\n    refactoringContext.setSelectedNode(node);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoringContext.setSelectedModel(SNodeOperations.getModel(node).getModelDescriptor());\n      }\n    });\n    refactoringContext.setSelectedModule(context.getModule());\n    refactoringContext.setSelectedProject(context.getProject());\n\n    // set new name parameter for refactoring to skip initial dialog \n    refactoringContext.setParameter(\"myNewName\", newName);\n\n    new Thread() {\n      public void run() {\n        new RefactoringProcessor().execute(refactoring, refactoringContext);\n      }\n    }.start();\n  }","commit_id":"79314eaa93a5b359f7c398262396343e063db906","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new AbstractSearchScope() {\n      @NotNull\n      public List<SNode> getNodes(Condition<SNode> p0) {\n        List<SNode> result = new ArrayList<SNode>();\n        SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n        for (SNode extension : ListSequence.fromList(SModelOperations.getNodesIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.baseLanguage.extensionMethods.structure.TypeExtension\"))) {\n          if (TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(operand), Type_Behavior.call_getLooseType_5744862332972792015(SLinkOperations.getTarget(extension, \"type\", true)))) {\n            for (SNode method : ListSequence.fromList(SLinkOperations.getTargets(extension, \"methods\", true))) {\n              if (VisibilityUtil.isVisible(_context.getEnclosingNode(), method)) {\n                ListSequence.fromList(result).addElement(method);\n              }\n            }\n          }\n        }\n        for (SNode container : ListSequence.fromList(SModelOperations.getNodesIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.baseLanguage.extensionMethods.structure.SimpleExtensionMethodsContainer\"))) {\n          for (SNode method : ListSequence.fromList(SLinkOperations.getTargets(container, \"methods\", true))) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(operand), Type_Behavior.call_getLooseType_5744862332972792015(SLinkOperations.getTarget(method, \"extendedType\", true)))) {\n              if (VisibilityUtil.isVisible(_context.getEnclosingNode(), method)) {\n                ListSequence.fromList(result).addElement(method);\n              }\n            }\n          }\n        }\n        return ListSequence.fromListWithValues(new ArrayList<SNode>(), result);\n      }\n\n      @Override\n      public boolean isInScope(SNode node) {\n        SNode extMethod = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.extensionMethods.structure.ExtensionMethodDeclaration\");\n        SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n        return TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(operand), Type_Behavior.call_getLooseType_5744862332972792015(ExtensionMethodDeclaration_Behavior.call_getThisType_8022092943109893938(extMethod))) && VisibilityUtil.isVisible(_context.getEnclosingNode(), extMethod);\n      }\n    };\n\n\n\n  }","id":101176,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return new AbstractSearchScope() {\n      @NotNull\n      public List<SNode> getNodes(Condition<SNode> p0) {\n        List<SNode> result = new ArrayList<SNode>();\n        SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n        for (SNode extension : ListSequence.fromList(SModelOperations.getNodesIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.baseLanguage.extensionMethods.structure.TypeExtension\"))) {\n          if (TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(operand), Type_Behavior.call_getLooseType_5744862332972792015(SLinkOperations.getTarget(extension, \"type\", true)))) {\n            for (SNode method : ListSequence.fromList(SLinkOperations.getTargets(extension, \"methods\", true))) {\n              if (VisibilityUtil.isVisible(_context.getEnclosingNode(), method)) {\n                ListSequence.fromList(result).addElement(method);\n              }\n            }\n          }\n        }\n        for (SNode container : ListSequence.fromList(SModelOperations.getNodesIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.baseLanguage.extensionMethods.structure.SimpleExtensionMethodsContainer\"))) {\n          for (SNode method : ListSequence.fromList(SLinkOperations.getTargets(container, \"methods\", true))) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(operand), Type_Behavior.call_getLooseType_5744862332972792015(SLinkOperations.getTarget(method, \"extendedType\", true)))) {\n              if (VisibilityUtil.isVisible(_context.getEnclosingNode(), method)) {\n                ListSequence.fromList(result).addElement(method);\n              }\n            }\n          }\n        }\n        return ListSequence.fromListWithValues(new ArrayList<SNode>(), result);\n      }\n\n      @Override\n      public boolean isInScope(SNode node) {\n        SNode extMethod = SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.extensionMethods.structure.ExtensionMethodDeclaration\");\n        SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true);\n        return TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(operand), Type_Behavior.call_getLooseType_5744862332972792015(ExtensionMethodDeclaration_Behavior.call_getThisType_8022092943109893938(extMethod))) && VisibilityUtil.isVisible(_context.getReferenceNode(), extMethod);\n      }\n    };\n\n\n\n  }","commit_id":"79314eaa93a5b359f7c398262396343e063db906","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"))) {\n      return null;\n    }\n    SNode opClassifier = DotExpression_Behavior.call_getClassifier_1213877410697(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"));\n    if (opClassifier == null) {\n      return null;\n    }\n    List<SNode> resultProperties = new ArrayList<SNode>();\n    List<SNode> classifiers = ((List<SNode>) new ClassifierAndSuperClassifiersScope(((Classifier) SNodeOperations.getAdapter(opClassifier))).getClassifierNodes());\n    for (SNode classifier : ListSequence.fromList(classifiers)) {\n      if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n        SNode classConcept = SNodeOperations.cast(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n        List<SNode> properties = SLinkOperations.getTargets(classConcept, \"property\", true);\n        for (SNode property : ListSequence.fromList(properties)) {\n          if (VisibilityUtil.isVisible(_context.getEnclosingNode(), property)) {\n            ListSequence.fromList(resultProperties).addElement(property);\n          }\n        }\n      }\n    }\n    return resultProperties;\n  }","id":101177,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    if (!(SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"))) {\n      return null;\n    }\n    SNode opClassifier = DotExpression_Behavior.call_getClassifier_1213877410697(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.DotExpression\"));\n    if (opClassifier == null) {\n      return null;\n    }\n    List<SNode> resultProperties = new ArrayList<SNode>();\n    List<SNode> classifiers = new ClassifierAndSuperClassifiersScope(((Classifier) SNodeOperations.getAdapter(opClassifier))).getClassifierNodes();\n    for (SNode classifier : ListSequence.fromList(classifiers)) {\n      if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n        for (SNode property : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"property\", true))) {\n          if (VisibilityUtil.isVisible(((_context.getReferenceNode() == null) ?\n            _context.getEnclosingNode() :\n            _context.getReferenceNode()\n          ), property)) {\n            ListSequence.fromList(resultProperties).addElement(property);\n          }\n        }\n      }\n    }\n    return resultProperties;\n  }","commit_id":"79314eaa93a5b359f7c398262396343e063db906","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected List<String> getTestSpecs() {\n      List<String> specs = new ArrayList<String>();\n      List<AbstractTestProxy> failedTests = getFailedTests(myProject);\n      for (AbstractTestProxy failedTest : failedTests) {\n        if (failedTest.isLeaf()) {\n          final Location location = failedTest.getLocation(myProject);\n          if (location != null) {\n            final PsiElement element = location.getPsiElement();\n\n            if (getConfiguration() instanceof DjangoTestsRunConfiguration) {\n              String appName = DjangoTestUtil.getAppNameForLocation(location.getModule(), location.getPsiElement());\n              String target = DjangoTestUtil.buildTargetFromLocation(appName, element);\n              if (target != null)\n                specs.add(target);\n            }\n            else {\n              PyClass pyClass = PsiTreeUtil.getParentOfType(element, PyClass.class, false);\n              PyFunction pyFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class, false);\n              String path = location.getVirtualFile().getCanonicalPath();\n              if (pyClass != null)\n                path += \"::\" + pyClass.getName();\n              if (pyFunction != null)\n                path += \"::\" + pyFunction.getName();\n\n              if (!specs.contains(path))\n                specs.add(path);\n            }\n          }\n        }\n      }\n      return specs;\n    }","id":101178,"modified_method":"@Override\n    protected List<String> getTestSpecs() {\n      List<String> specs = new ArrayList<String>();\n      List<AbstractTestProxy> failedTests = getFailedTests(myProject);\n      for (AbstractTestProxy failedTest : failedTests) {\n        if (failedTest.isLeaf()) {\n          final Location location = failedTest.getLocation(myProject);\n          if (location == null) continue;\n\n          final PsiElement element = location.getPsiElement();\n          if (getConfiguration() instanceof DjangoTestsRunConfiguration) {\n            String appName = DjangoTestUtil.getAppNameForLocation(location.getModule(), location.getPsiElement());\n            String target = DjangoTestUtil.buildTargetFromLocation(appName, element);\n            if (target != null)\n              specs.add(target);\n          }\n          else {\n            PyClass pyClass = PsiTreeUtil.getParentOfType(element, PyClass.class, false);\n            PyFunction pyFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class, false);\n            final VirtualFile virtualFile = location.getVirtualFile();\n            if (virtualFile != null) {\n              String path = virtualFile.getCanonicalPath();\n              if (pyClass != null)\n                path += \"::\" + pyClass.getName();\n              if (pyFunction != null)\n                path += \"::\" + pyFunction.getName();\n\n              if (!specs.contains(path))\n                specs.add(path);\n            }\n          }\n        }\n      }\n      return specs;\n    }","commit_id":"ad9f507bdbed94151f1fae1d0c9e068bd67ea290","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    @Override\n    public RunProfileState getState(@NotNull Executor executor, @NotNull ExecutionEnvironment env) throws ExecutionException {\n      final AbstractPythonRunConfiguration configuration = ((AbstractPythonRunConfiguration)getPeer());\n      final PythonCommandLineState state = new FailedPythonTestCommandLineStateBase(configuration, env,\n                                                            (PythonTestCommandLineStateBase)configuration.getState(executor, env));\n      return state;\n    }","id":101179,"modified_method":"@Nullable\n    @Override\n    public RunProfileState getState(@NotNull Executor executor, @NotNull ExecutionEnvironment env) throws ExecutionException {\n      final AbstractPythonRunConfiguration configuration = ((AbstractPythonRunConfiguration)getPeer());\n      return new FailedPythonTestCommandLineStateBase(configuration, env,\n                                                            (PythonTestCommandLineStateBase)configuration.getState(executor, env));\n    }","commit_id":"ad9f507bdbed94151f1fae1d0c9e068bd67ea290","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public MyRunProfile getRunProfile() {\n    final AbstractPythonRunConfiguration configuration = (AbstractPythonRunConfiguration)getModel().getProperties().getConfiguration();\n    return new MyTestRunProfile(configuration);\n  }","id":101180,"modified_method":"@Override\n  @Nullable\n  public MyRunProfile getRunProfile() {\n    final TestFrameworkRunningModel model = getModel();\n    if (model == null) return null;\n    final AbstractPythonRunConfiguration configuration = (AbstractPythonRunConfiguration)model.getProperties().getConfiguration();\n    return new MyTestRunProfile(configuration);\n  }","commit_id":"ad9f507bdbed94151f1fae1d0c9e068bd67ea290","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static SAbstractConcept getConcept(SNode node) {\n    SConcept concept = node.getConcept();\n    boolean cd = concept.equals(SNodeUtil.concept_ConceptDeclaration);\n    boolean icd = concept.equals(SNodeUtil.concept_InterfaceConceptDeclaration);\n    if (cd || icd) {\n      String name = NameUtil.getModelLongName(node.getModel()) + \".\" + getNormalizedName(node);\n      if (cd) {\n        return MetaAdapterFactory.getConcept(MetaIdByDeclaration.getConceptId(node), name);\n      } else {\n        return MetaAdapterFactory.getInterfaceConcept(MetaIdByDeclaration.getConceptId(node), name);\n      }\n    }\n    return null;\n  }","id":101181,"modified_method":"public static SAbstractConcept getConcept(SNode node) {\n    SConcept concept = node.getConcept();\n    boolean cd = concept.equals(SNodeUtil.concept_ConceptDeclaration);\n    boolean icd = concept.equals(SNodeUtil.concept_InterfaceConceptDeclaration);\n    if (!cd && !icd) return null;\n    SModel model = node.getModel();\n    if (model == null) return null;\n    if (!(model.getModule() instanceof Language)) return null;\n\n    String name = NameUtil.getModelLongName(model) + \".\" + getNormalizedName(node);\n    if (cd) {\n      return MetaAdapterFactory.getConcept(MetaIdByDeclaration.getConceptId(node), name);\n    } else {\n      return MetaAdapterFactory.getInterfaceConcept(MetaIdByDeclaration.getConceptId(node), name);\n    }\n  }","commit_id":"3c97036baa63632bb0330ccf15dcdcfc2eb2104b","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Set<SNode> getAbstractChildren(final SNode node, Set<SNode> visited) throws CircularHierarchyException {\n    Set<SNode> result;\n    if (myIsParentHierarchy) {\n      result = getParents(node, visited);\n    } else {\n      result = getDescendants(node, visited);\n    }\n    if (myOnlyInOneModel) {\n      result = CollectionUtil.filter(result, new Condition<SNode>() {\n        public boolean met(SNode n) {\n          if (n == null) {\n            return false;\n          }\n          return SNodeOperations.getModel(n) == SNodeOperations.getModel(node);\n        }\n      });\n    }\n    if (!(myShowGeneratorModels)) {\n      result = CollectionUtil.filter(result, new Condition<SNode>() {\n        public boolean met(SNode n) {\n          if (n == null) {\n            return false;\n          }\n          return !(SModelStereotype.isGeneratorModel(SNodeOperations.getModel(n)));\n        }\n      });\n    }\n    return result;\n  }","id":101182,"modified_method":"protected Set<SNode> getAbstractChildren(final SNode node, Set<SNode> visited) throws CircularHierarchyException {\n    Set<SNode> result;\n    if (myIsParentHierarchy) {\n      result = getParents(node, visited);\n    } else {\n      result = getDescendants(node, visited);\n    }\n    if (myOnlyInOneModel) {\n      result = CollectionUtil.filter(result, new Condition<SNode>() {\n        public boolean met(SNode n) {\n          if (n == null) {\n            return false;\n          }\n          return SNodeOperations.getModel(n) == SNodeOperations.getModel(node);\n        }\n      });\n    }\n    if (!(myShowGeneratorModels)) {\n      result = CollectionUtil.filter(result, new Condition<SNode>() {\n        public boolean met(SNode n) {\n          if (n == null) {\n            return false;\n          }\n          return !(isInGeneratorModel(n));\n        }\n      });\n    }\n    return result;\n  }","commit_id":"4b7781dd3df875b0dab38296f0daec5c180bb1b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected SNode getAbstractParent(SNode node) {\n    if (myIsParentHierarchy) {\n      return null;\n    }\n    SNode result = getParent(node);\n    if (result == null) {\n      return null;\n    }\n    if (!(myShowGeneratorModels)) {\n      while (SModelStereotype.isGeneratorModel(SNodeOperations.getModel(result))) {\n        result = getParent(result);\n        if (result == null) {\n          return null;\n        }\n      }\n    }\n    if (myOnlyInOneModel && (SNodeOperations.getModel(result) != SNodeOperations.getModel(node))) {\n      return null;\n    }\n    return result;\n  }","id":101183,"modified_method":"protected SNode getAbstractParent(SNode node) {\n    if (myIsParentHierarchy) {\n      return null;\n    }\n    SNode result = getParent(node);\n    if (result == null) {\n      return null;\n    }\n    if (!(myShowGeneratorModels)) {\n      while (isInGeneratorModel(result)) {\n        result = getParent(result);\n        if (result == null) {\n          return null;\n        }\n      }\n    }\n    if (myOnlyInOneModel && (SNodeOperations.getModel(result) != SNodeOperations.getModel(node))) {\n      return null;\n    }\n    return result;\n  }","commit_id":"4b7781dd3df875b0dab38296f0daec5c180bb1b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doUpdatePresentation() {\n    @DisposableCommand SNode node = myNode;\n    if (node == null) {\n      return;\n    }\n    setIcon(IconManager.getIconFor(node));\n    setAdditionalText(calculateAdditionalText());\n    setAutoExpandable(false);\n  }","id":101184,"modified_method":"protected void doUpdatePresentation() {\n    @DisposableCommand SNode node = myNode;\n    if (node == null) {\n      return;\n    }\n    setIcon(IconManager.getIconFor(node));\n    String addText = calculateAdditionalText();\n    if (addText != null) {\n      setAdditionalText(addText);\n    }\n    setAutoExpandable(false);\n  }","commit_id":"4b7781dd3df875b0dab38296f0daec5c180bb1b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected String calculateAdditionalText() {\n    if (getNode() == null) {\n      return \"null\";\n    }\n    return SNodeOperations.getModel(getNode()).getSModelFqName().toString();\n  }","id":101185,"modified_method":"protected String calculateAdditionalText() {\n    if (getNode() == null) {\n      return null;\n    }\n\n    SModel model = SNodeOperations.getModel(getNode());\n    if (model == null) {\n      return null;\n    }\n\n    return model.getSModelFqName().toString();\n  }","commit_id":"4b7781dd3df875b0dab38296f0daec5c180bb1b8","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public TraceablePositionInfo getTargetCodePosition() {\n    DebugInfo debugInfo = TraceInfoCache.getInstance().get(myNodePointer.getModel());\n    if (debugInfo == null) {\n      return null;\n    }\n    return debugInfo.getPositionForNode(myNodePointer.getNodeId().toString());\n  }","id":101186,"modified_method":"@Nullable\n  public TraceablePositionInfo getTargetCodePosition() {\n    SModelDescriptor model = myNodePointer.getModel();\n    if (model == null) return null;\n    DebugInfo debugInfo = TraceInfoCache.getInstance().get(model);\n    if (debugInfo == null) {\n      return null;\n    }\n    return debugInfo.getPositionForNode(myNodePointer.getNodeId().toString());\n  }","commit_id":"c9c93008618a5fbd74f2a4e7c5c27a82ca631f2e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void selectNode(final SNode node) {\n    LOG.checkEDT();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        getTree().runWithoutExpansion(new Runnable() {\n          public void run() {\n            MPSTreeNodeEx sNodeNode = findMostSuitableSNodeTreeNode(node);\n            getTree().selectNode(sNodeNode);\n          }\n        });\n      }\n    });\n  }","id":101187,"modified_method":"public void selectNode(@NotNull final SNode node) {\n    LOG.checkEDT();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        getTree().runWithoutExpansion(new Runnable() {\n          public void run() {\n            MPSTreeNodeEx sNodeNode = findMostSuitableSNodeTreeNode(node);\n\n            if (sNodeNode == null) {\n              LOG.warning(\"Couldn't select node \\\"\" + node.getName() + \"\\\" : tree node not found.\");\n              return;\n            }\n\n            getTree().selectNode(sNodeNode);\n          }\n        });\n      }\n    });\n  }","commit_id":"2bf9b7ce88d628a06c94a789b41a0c74d60e555f","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected MPSTreeNodeEx findMostSuitableSNodeTreeNode(SNode node) {\n    SModelTreeNode modelNode = findMostSuitableModelTreeNode(node.getModel().getModelDescriptor());\n    if (modelNode == null) return null;\n\n    return findSNodeTreeNodeInParent(node, modelNode);\n  }","id":101188,"modified_method":"protected MPSTreeNodeEx findMostSuitableSNodeTreeNode(@NotNull SNode node) {\n    SModel model = node.getModel();\n    if (model == null) return null;\n    SModelTreeNode modelNode = findMostSuitableModelTreeNode(model.getModelDescriptor());\n    if (modelNode == null) return null;\n\n    return findSNodeTreeNodeInParent(node, modelNode);\n  }","commit_id":"2bf9b7ce88d628a06c94a789b41a0c74d60e555f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SelectInTarget createSelectInTarget() {\n    return new SelectInTarget() {\n      private SNode myNode;\n\n      public boolean canSelect(SelectInContext context) {\n        VirtualFile virtualFile = context.getVirtualFile();\n        if (!(virtualFile instanceof MPSNodeVirtualFile)) return false;\n\n        MPSNodeVirtualFile file = (MPSNodeVirtualFile) virtualFile;\n        FileEditor[] editors = FileEditorManager.getInstance(myProject).getEditors(file);\n        if (editors.length != 0) {\n          FileEditor editor = editors[0];\n          if (!(editor instanceof MPSFileNodeEditor)) return false;\n          EditorComponent editorComponent = ((MPSFileNodeEditor) editor).getNodeEditor().getCurrentEditorComponent();\n          if (editorComponent == null) return false;\n          myNode = editorComponent.getEditedNode();\n        } else {\n          myNode = file.getNode();\n        }\n        return true;\n      }\n\n      public void selectIn(final SelectInContext context, boolean requestFocus) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            selectNode(myNode);\n          }\n        });\n        activate(requestFocus);\n      }\n\n      public String getToolWindowId() {\n        return ID;\n      }\n\n      public String getMinorViewId() {\n        return null;\n      }\n\n      public float getWeight() {\n        return 0;\n      }\n\n      public String toString() {\n        return \"Logical View\";\n      }\n    };\n  }","id":101189,"modified_method":"public SelectInTarget createSelectInTarget() {\n    return new SelectInTarget() {\n      private SNode myNode;\n\n      public boolean canSelect(SelectInContext context) {\n        VirtualFile virtualFile = context.getVirtualFile();\n        if (!(virtualFile instanceof MPSNodeVirtualFile)) return false;\n\n        MPSNodeVirtualFile file = (MPSNodeVirtualFile) virtualFile;\n        FileEditor[] editors = FileEditorManager.getInstance(myProject).getEditors(file);\n        if (editors.length != 0) {\n          FileEditor editor = editors[0];\n          if (!(editor instanceof MPSFileNodeEditor)) return false;\n          EditorComponent editorComponent = ((MPSFileNodeEditor) editor).getNodeEditor().getCurrentEditorComponent();\n          if (editorComponent == null) return false;\n          myNode = editorComponent.getEditedNode();\n        } else {\n          myNode = file.getNode();\n        }\n        return true;\n      }\n\n      public void selectIn(final SelectInContext context, boolean requestFocus) {\n        if (myNode == null) return;\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            selectNode(myNode);\n          }\n        });\n        activate(requestFocus);\n      }\n\n      public String getToolWindowId() {\n        return ID;\n      }\n\n      public String getMinorViewId() {\n        return null;\n      }\n\n      public float getWeight() {\n        return 0;\n      }\n\n      public String toString() {\n        return \"Logical View\";\n      }\n    };\n  }","commit_id":"2bf9b7ce88d628a06c94a789b41a0c74d60e555f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void commitToOriginal() {\n    VirtualFile origVirtualFile = PsiUtilCore.getVirtualFile(myNewFile.getContext());\n    myCommittingToOriginal = true;\n    try {\n      if (origVirtualFile == null || !ReadonlyStatusHandler.getInstance(myProject).ensureFilesWritable(origVirtualFile).hasReadonlyFiles()) {\n        PostprocessReformattingAspect.getInstance(myProject).disablePostprocessFormattingInside(new Runnable() {\n          @Override\n          public void run() {\n            if (myAltFullRange != null) {\n              altCommitToOriginal();\n              return;\n            }\n            commitToOriginalInner();\n          }\n        });\n      }\n    }\n    finally {\n      myCommittingToOriginal = false;\n    }\n  }","id":101190,"modified_method":"private void commitToOriginal(final DocumentEvent e) {\n    VirtualFile origVirtualFile = PsiUtilCore.getVirtualFile(myNewFile.getContext());\n    myCommittingToOriginal = true;\n    try {\n      if (origVirtualFile == null || !ReadonlyStatusHandler.getInstance(myProject).ensureFilesWritable(origVirtualFile).hasReadonlyFiles()) {\n        PostprocessReformattingAspect.getInstance(myProject).disablePostprocessFormattingInside(new Runnable() {\n          @Override\n          public void run() {\n            if (myAltFullRange != null) {\n              altCommitToOriginal(e);\n              return;\n            }\n            commitToOriginalInner();\n          }\n        });\n      }\n    }\n    finally {\n      myCommittingToOriginal = false;\n    }\n  }","commit_id":"1ff91f6ca139ae8f98d53f5f2a0c251381e50692","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void altCommitToOriginal() {\n    final PsiFile origPsiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myOrigDocument);\n    String newText = myNewDocument.getText();\n    // prepare guarded blocks\n    LinkedHashMap<String, String> replacementMap = new LinkedHashMap<String, String>();\n    int count = 0;\n    for (RangeMarker o : ContainerUtil.reverse(((DocumentEx)myNewDocument).getGuardedBlocks())) {\n      String replacement = o.getUserData(REPLACEMENT_KEY);\n      String tempText = \"REPLACE\"+(count++)+Long.toHexString(StringHash.calc(replacement));\n      newText = newText.substring(0, o.getStartOffset()) + tempText + newText.substring(o.getEndOffset());\n      replacementMap.put(tempText, replacement);\n    }\n    // run preformat processors\n    myEditor.getCaretModel().moveToOffset(myAltFullRange.getStartOffset());\n    for (CopyPastePreProcessor preProcessor : Extensions.getExtensions(CopyPastePreProcessor.EP_NAME)) {\n      newText = preProcessor.preprocessOnPaste(myProject, origPsiFile, myEditor, newText, null);\n    }\n    myOrigDocument.replaceString(myAltFullRange.getStartOffset(), myAltFullRange.getEndOffset(), newText);\n    // replace temp strings for guarded blocks\n    for (String tempText : replacementMap.keySet()) {\n      int idx = CharArrayUtil.indexOf(myOrigDocument.getCharsSequence(), tempText, myAltFullRange.getStartOffset(), myAltFullRange.getEndOffset());\n      myOrigDocument.replaceString(idx, idx + tempText.length(), replacementMap.get(tempText));\n    }\n    // JAVA: fix occasional char literal concatenation\n    fixDocumentQuotes(myOrigDocument, myAltFullRange.getStartOffset() - 1);\n    fixDocumentQuotes(myOrigDocument, myAltFullRange.getEndOffset());\n\n    // reformat\n    PsiDocumentManager.getInstance(myProject).commitDocument(myOrigDocument);\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          CodeStyleManager.getInstance(myProject).reformatRange(\n            origPsiFile, myAltFullRange.getStartOffset(), myAltFullRange.getEndOffset(), true);\n        }\n        catch (IncorrectOperationException e) {\n          //LOG.error(e);\n        }\n      }\n    };\n    DocumentUtil.executeInBulk(myOrigDocument, true, task);\n    myEditor.getCaretModel().moveToOffset(myAltFullRange.getStartOffset());\n    myEditor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n  }","id":101191,"modified_method":"private void altCommitToOriginal(@NotNull DocumentEvent e) {\n    final PsiFile origPsiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myOrigDocument);\n    String newText = myNewDocument.getText();\n    // prepare guarded blocks\n    LinkedHashMap<String, String> replacementMap = new LinkedHashMap<String, String>();\n    int count = 0;\n    for (RangeMarker o : ContainerUtil.reverse(((DocumentEx)myNewDocument).getGuardedBlocks())) {\n      String replacement = o.getUserData(REPLACEMENT_KEY);\n      String tempText = \"REPLACE\"+(count++)+Long.toHexString(StringHash.calc(replacement));\n      newText = newText.substring(0, o.getStartOffset()) + tempText + newText.substring(o.getEndOffset());\n      replacementMap.put(tempText, replacement);\n    }\n    // run preformat processors\n    final int hostStartOffset = myAltFullRange.getStartOffset();\n    myEditor.getCaretModel().moveToOffset(hostStartOffset);\n    for (CopyPastePreProcessor preProcessor : Extensions.getExtensions(CopyPastePreProcessor.EP_NAME)) {\n      newText = preProcessor.preprocessOnPaste(myProject, origPsiFile, myEditor, newText, null);\n    }\n    myOrigDocument.replaceString(hostStartOffset, myAltFullRange.getEndOffset(), newText);\n    // replace temp strings for guarded blocks\n    for (String tempText : replacementMap.keySet()) {\n      int idx = CharArrayUtil.indexOf(myOrigDocument.getCharsSequence(), tempText, hostStartOffset, myAltFullRange.getEndOffset());\n      myOrigDocument.replaceString(idx, idx + tempText.length(), replacementMap.get(tempText));\n    }\n    // JAVA: fix occasional char literal concatenation\n    fixDocumentQuotes(myOrigDocument, hostStartOffset - 1);\n    fixDocumentQuotes(myOrigDocument, myAltFullRange.getEndOffset());\n\n    // reformat\n    PsiDocumentManager.getInstance(myProject).commitDocument(myOrigDocument);\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          CodeStyleManager.getInstance(myProject).reformatRange(\n            origPsiFile, hostStartOffset, myAltFullRange.getEndOffset(), true);\n        }\n        catch (IncorrectOperationException e) {\n          //LOG.error(e);\n        }\n      }\n    };\n    DocumentUtil.executeInBulk(myOrigDocument, true, task);\n\n    PsiElement newInjected = InjectedLanguageManager.getInstance(myProject).findInjectedElementAt(origPsiFile, hostStartOffset);\n    DocumentWindow documentWindow = newInjected == null ? null : InjectedLanguageUtil.getDocumentWindow(newInjected);\n    if (documentWindow != null) {\n      myEditor.getCaretModel().moveToOffset(documentWindow.injectedToHost(e.getOffset()));\n      myEditor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n    }\n  }","commit_id":"1ff91f6ca139ae8f98d53f5f2a0c251381e50692","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void documentChanged(DocumentEvent e) {\n    UndoManager undoManager = UndoManager.getInstance(myProject);\n    boolean undoOrRedo = undoManager.isUndoInProgress() || undoManager.isRedoInProgress();\n    if (undoOrRedo) {\n      // allow undo/redo up until 'creation stamp' back in time\n      // and check it after action is completed\n      if (e.getDocument() == myOrigDocument) {\n        //noinspection SSBasedInspection\n        SwingUtilities.invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            if (myOrigCreationStamp > myOrigDocument.getModificationStamp()) {\n              closeEditor();\n            }\n          }\n        });\n      }\n    }\n    else if (e.getDocument() == myNewDocument) {\n      commitToOriginal();\n      if (!isValid()) closeEditor();\n    }\n    else if (e.getDocument() == myOrigDocument) {\n      if (myCommittingToOriginal || myAltFullRange != null && myAltFullRange.isValid()) return;\n      closeEditor();\n    }\n  }","id":101192,"modified_method":"@Override\n  public void documentChanged(DocumentEvent e) {\n    UndoManager undoManager = UndoManager.getInstance(myProject);\n    boolean undoOrRedo = undoManager.isUndoInProgress() || undoManager.isRedoInProgress();\n    if (undoOrRedo) {\n      // allow undo/redo up until 'creation stamp' back in time\n      // and check it after action is completed\n      if (e.getDocument() == myOrigDocument) {\n        //noinspection SSBasedInspection\n        SwingUtilities.invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            if (myOrigCreationStamp > myOrigDocument.getModificationStamp()) {\n              closeEditor();\n            }\n          }\n        });\n      }\n    }\n    else if (e.getDocument() == myNewDocument) {\n      commitToOriginal(e);\n      if (!isValid()) closeEditor();\n    }\n    else if (e.getDocument() == myOrigDocument) {\n      if (myCommittingToOriginal || myAltFullRange != null && myAltFullRange.isValid()) return;\n      closeEditor();\n    }\n  }","commit_id":"1ff91f6ca139ae8f98d53f5f2a0c251381e50692","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * add code to implement GroovyObject\n     * @param node\n     */\n    public void visitClass(final ClassNode node) {\n        this.classNode = node;\n\n        if ((classNode.getModifiers() & Opcodes.ACC_INTERFACE) >0) {\n            //interfaces have no constructors, but this code expects one,\n            //so create a dummy and don't add it to the class node\n            ConstructorNode dummy = new ConstructorNode(0,null);\n            addInitialization(node, dummy);\n            node.visitContents(this);\n            return;\n        }\n\n        ClassNode[] classNodes = classNode.getInterfaces();\n        List interfaces = new ArrayList();\n        for (int i = 0; i < classNodes.length; i++) {\n            ClassNode classNode = classNodes[i];\n            interfaces.add(classNode.getName());\n        }\n        Set interfaceSet = new HashSet(interfaces);\n        if (interfaceSet.size() != interfaces.size()) {\n            throw new RuntimeParserException(\"Duplicate interfaces in implements list: \" + interfaces, classNode);\n        }\n\n        addDefaultParameterMethods(node);\n        addDefaultParameterConstructors(node);\n\n        String _myClassFieldName = \"$myClass\";\n        while (node.getDeclaredField(_myClassFieldName) != null)\n          _myClassFieldName = _myClassFieldName + \"$\";\n        final String myClassFieldName = _myClassFieldName;\n\n        final String classInternalName = BytecodeHelper.getClassInternalName(node);\n\n//        FieldNode myClassField = node.addField(myClassFieldName, ACC_PRIVATE|ACC_STATIC, ClassHelper.CLASS_Type, new ClassExpression(node));\n//        myClassField.setSynthetic(true);\n\n        String _staticClassInfoFieldName = \"$staticClassInfo\";\n        while (node.getDeclaredField(_staticClassInfoFieldName) != null)\n          _staticClassInfoFieldName = _staticClassInfoFieldName + \"$\";\n        final String staticMetaClassFieldName = _staticClassInfoFieldName;\n\n        FieldNode staticMetaClassField = node.addField(staticMetaClassFieldName, ACC_PRIVATE|ACC_STATIC, ClassHelper.make(ClassInfo.class,false), null);\n        staticMetaClassField.setSynthetic(true);\n\n        List getStaticMetaClassCode = new LinkedList();\n        getStaticMetaClassCode.add( new BytecodeInstruction(){\n            public void visit(MethodVisitor mv) {\n                mv.visitFieldInsn(GETSTATIC, classInternalName, staticMetaClassFieldName, \"Lorg/codehaus/groovy/reflection/ClassInfo;\");\n                mv.visitVarInsn(ASTORE, 1);\n                mv.visitVarInsn(ALOAD, 1);\n                Label l0 = new Label();\n                mv.visitJumpInsn(IFNONNULL, l0);\n\n                mv.visitVarInsn(ALOAD, 0);\n                mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Object\", \"getClass\", \"()Ljava/lang/Class;\");\n                mv.visitMethodInsn(INVOKESTATIC, \"org/codehaus/groovy/reflection/ClassInfo\", \"getClassInfo\", \"(Ljava/lang/Class;)Lorg/codehaus/groovy/reflection/ClassInfo;\");\n                mv.visitInsn(DUP);\n                mv.visitVarInsn(ASTORE, 1);\n                mv.visitFieldInsn(PUTSTATIC, classInternalName, staticMetaClassFieldName, \"Lorg/codehaus/groovy/reflection/ClassInfo;\");\n\n                mv.visitLabel(l0);\n\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn(INVOKEVIRTUAL, \"org/codehaus/groovy/reflection/ClassInfo\", \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                mv.visitInsn(ARETURN);\n\n            }\n        });\n        node.addSyntheticMethod(\n            \"$getStaticMetaClass\",\n            ACC_PROTECTED,\n            ClassHelper.make(MetaClass.class),\n            Parameter.EMPTY_ARRAY,\n            ClassNode.EMPTY_ARRAY,\n            new BytecodeSequence(getStaticMetaClassCode)\n        );\n\n        boolean knownSpecialCase =\n                node.isDerivedFrom(ClassHelper.GSTRING_TYPE)\n                        || node.isDerivedFrom(ClassHelper.make(GroovyObjectSupport.class))\n                        || node.implementsInterface(ClassHelper.METACLASS_TYPE);\n\n        if (!knownSpecialCase) {\n\n            if (!node.isDerivedFromGroovyObject()) node.addInterface(ClassHelper.make(GroovyObject.class));\n            FieldNode metaClassField = getMetaClassField(node);\n\n            if (!node.hasMethod(\"getMetaClass\", Parameter.EMPTY_ARRAY)) {\n                metaClassField = setMetaClassFieldIfNotExists(node, metaClassField);\n                List getMetaClassCode = new LinkedList();\n                getMetaClassCode.add(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        Label nullLabel = new Label();\n\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitFieldInsn(GETFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        mv.visitInsn(DUP);\n                        mv.visitJumpInsn(IFNULL, nullLabel);\n                        mv.visitInsn(ARETURN);\n\n                        mv.visitLabel(nullLabel);\n                        mv.visitInsn(POP);\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitInsn(DUP);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"$getStaticMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitFieldInsn(PUTFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitFieldInsn(GETFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        mv.visitInsn(ARETURN);\n                    }\n                });\n                node.addSyntheticMethod(\n                        \"getMetaClass\",\n                        ACC_PUBLIC | ACC_SYNTHETIC,\n                        ClassHelper.METACLASS_TYPE,\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(getMetaClassCode)\n                );\n            }\n\n            Parameter[] parameters = new Parameter[] { new Parameter(ClassHelper.METACLASS_TYPE, \"mc\") };\n            if (!node.hasMethod(\"setMetaClass\", parameters)) {\n                metaClassField=setMetaClassFieldIfNotExists(node,metaClassField);\n                Statement setMetaClassCode;                \n                if (Modifier.isFinal(metaClassField.getModifiers())) {\n                    ConstantExpression text = new ConstantExpression(\"cannot set read-only meta class\");\n                    ConstructorCallExpression cce = new ConstructorCallExpression(ClassHelper.make(IllegalArgumentException.class), text);\n                    setMetaClassCode = new ExpressionStatement(cce);\n                } else {\n                    List list = new ArrayList();\n                    list.add (new BytecodeInstruction() {\n                        public void visit(MethodVisitor mv) {\n                            mv.visitVarInsn(ALOAD, 0);\n                            mv.visitVarInsn(ALOAD, 1);\n                            mv.visitFieldInsn(PUTFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        }\n                    });\n                    setMetaClassCode = new BytecodeSequence(list);\n                }\n                \n                node.addSyntheticMethod(\n                        \"setMetaClass\",\n                        ACC_PUBLIC,\n                        ClassHelper.VOID_TYPE,\n                        SET_METACLASS_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        setMetaClassCode\n                );\n            }\n\n            if (!node.hasMethod(\"invokeMethod\",INVOKE_METHOD_PARAMS)) {\n                VariableExpression vMethods = new VariableExpression(\"method\");\n                VariableExpression vArguments = new VariableExpression(\"arguments\");\n                VariableScope blockScope = new VariableScope();\n                blockScope.putReferencedLocalVariable(vMethods);\n                blockScope.putReferencedLocalVariable(vArguments);\n                List instructions = new ArrayList();\n                instructions.add(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        Label nullLabel = new Label();\n\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitVarInsn(ALOAD, 1);\n                        mv.visitVarInsn(ALOAD, 2);\n                        mv.visitMethodInsn(INVOKEINTERFACE, \"groovy/lang/MetaClass\", \"invokeMethod\", \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\");\n                        mv.visitInsn(ARETURN);\n                    }\n                });\n                node.addSyntheticMethod(\n                        \"invokeMethod\",\n                        ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE, INVOKE_METHOD_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(instructions)\n                );\n            }\n\n            if (!node.hasMethod(\"getProperty\", GET_PROPERTY_PARAMS)) {\n                List instructions = new ArrayList();\n                instructions.add(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitVarInsn(ALOAD, 1);\n                        mv.visitMethodInsn(INVOKEINTERFACE, \"groovy/lang/MetaClass\", \"getProperty\", \"(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;\");\n                        mv.visitInsn(ARETURN);\n                    }\n                });\n                node.addSyntheticMethod(\n                        \"getProperty\",\n                        ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        GET_PROPERTY_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(instructions)\n                );\n            }\n\n            if (!node.hasMethod(\"setProperty\", SET_PROPERTY_PARAMS)) {\n                List instructions = new ArrayList();\n                instructions.add(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitVarInsn(ALOAD, 1);\n                        mv.visitVarInsn(ALOAD, 2);\n                        mv.visitMethodInsn(INVOKEINTERFACE, \"groovy/lang/MetaClass\", \"setProperty\", \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V\");\n                        mv.visitInsn(RETURN);                    }\n                });\n                node.addSyntheticMethod(\n                        \"setProperty\",\n                        ACC_PUBLIC,\n                        ClassHelper.VOID_TYPE,\n                        SET_PROPERTY_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(instructions)\n                );\n            }\n\n        }\n\n        if (node.getDeclaredConstructors().isEmpty()) {\n            ConstructorNode constructor = new ConstructorNode(ACC_PUBLIC, null);\n            constructor.setSynthetic(true);\n            node.addConstructor(constructor);\n        }\n\n        if (!(node instanceof InnerClassNode)) {// add a static timestamp field to the class\n            addTimeStamp(node);\n        }\n\n        addInitialization(node);\n        checkReturnInObjectInitializer(node.getObjectInitializerStatements());\n        node.getObjectInitializerStatements().clear();\n        addCovariantMethods(node);\n        node.visitContents(this);\n    }","id":101193,"modified_method":"/**\n     * add code to implement GroovyObject\n     * @param node\n     */\n    public void visitClass(final ClassNode node) {\n        this.classNode = node;\n\n        if ((classNode.getModifiers() & Opcodes.ACC_INTERFACE) >0) {\n            //interfaces have no constructors, but this code expects one,\n            //so create a dummy and don't add it to the class node\n            ConstructorNode dummy = new ConstructorNode(0,null);\n            addInitialization(node, dummy);\n            node.visitContents(this);\n            return;\n        }\n\n        ClassNode[] classNodes = classNode.getInterfaces();\n        List interfaces = new ArrayList();\n        for (int i = 0; i < classNodes.length; i++) {\n            ClassNode classNode = classNodes[i];\n            interfaces.add(classNode.getName());\n        }\n        Set interfaceSet = new HashSet(interfaces);\n        if (interfaceSet.size() != interfaces.size()) {\n            throw new RuntimeParserException(\"Duplicate interfaces in implements list: \" + interfaces, classNode);\n        }\n\n        addDefaultParameterMethods(node);\n        addDefaultParameterConstructors(node);\n\n        final String classInternalName = BytecodeHelper.getClassInternalName(node);\n\n        String _staticClassInfoFieldName = \"$staticClassInfo\";\n        while (node.getDeclaredField(_staticClassInfoFieldName) != null)\n          _staticClassInfoFieldName = _staticClassInfoFieldName + \"$\";\n        final String staticMetaClassFieldName = _staticClassInfoFieldName;\n\n        FieldNode staticMetaClassField = node.addField(staticMetaClassFieldName, ACC_PRIVATE|ACC_STATIC, ClassHelper.make(ClassInfo.class,false), null);\n        staticMetaClassField.setSynthetic(true);\n\n        node.addSyntheticMethod(\n            \"$getStaticMetaClass\",\n            ACC_PROTECTED,\n            ClassHelper.make(MetaClass.class),\n            Parameter.EMPTY_ARRAY,\n            ClassNode.EMPTY_ARRAY,\n            new BytecodeSequence(new BytecodeInstruction(){\n            public void visit(MethodVisitor mv) {\n                mv.visitFieldInsn(GETSTATIC, classInternalName, staticMetaClassFieldName, \"Lorg/codehaus/groovy/reflection/ClassInfo;\");\n                mv.visitVarInsn(ASTORE, 1);\n                mv.visitVarInsn(ALOAD, 1);\n                Label l0 = new Label();\n                mv.visitJumpInsn(IFNONNULL, l0);\n\n                mv.visitVarInsn(ALOAD, 0);\n                mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Object\", \"getClass\", \"()Ljava/lang/Class;\");\n                mv.visitMethodInsn(INVOKESTATIC, \"org/codehaus/groovy/reflection/ClassInfo\", \"getClassInfo\", \"(Ljava/lang/Class;)Lorg/codehaus/groovy/reflection/ClassInfo;\");\n                mv.visitInsn(DUP);\n                mv.visitVarInsn(ASTORE, 1);\n                mv.visitFieldInsn(PUTSTATIC, classInternalName, staticMetaClassFieldName, \"Lorg/codehaus/groovy/reflection/ClassInfo;\");\n\n                mv.visitLabel(l0);\n\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn(INVOKEVIRTUAL, \"org/codehaus/groovy/reflection/ClassInfo\", \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                mv.visitInsn(ARETURN);\n\n            }\n        })\n        );\n\n        boolean knownSpecialCase =\n                node.isDerivedFrom(ClassHelper.GSTRING_TYPE)\n                        || node.isDerivedFrom(ClassHelper.make(GroovyObjectSupport.class))\n                        || node.implementsInterface(ClassHelper.METACLASS_TYPE);\n\n        if (!knownSpecialCase) {\n\n            if (!node.isDerivedFromGroovyObject()) node.addInterface(ClassHelper.make(GroovyObject.class));\n            FieldNode metaClassField = getMetaClassField(node);\n\n            if (!node.hasMethod(\"getMetaClass\", Parameter.EMPTY_ARRAY)) {\n                metaClassField = setMetaClassFieldIfNotExists(node, metaClassField);\n                node.addSyntheticMethod(\n                        \"getMetaClass\",\n                        ACC_PUBLIC | ACC_SYNTHETIC,\n                        ClassHelper.METACLASS_TYPE,\n                        Parameter.EMPTY_ARRAY,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        Label nullLabel = new Label();\n\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitFieldInsn(GETFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        mv.visitInsn(DUP);\n                        mv.visitJumpInsn(IFNULL, nullLabel);\n                        mv.visitInsn(ARETURN);\n\n                        mv.visitLabel(nullLabel);\n                        mv.visitInsn(POP);\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitInsn(DUP);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"$getStaticMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitFieldInsn(PUTFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitFieldInsn(GETFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        mv.visitInsn(ARETURN);\n                    }\n                })\n                );\n            }\n\n            Parameter[] parameters = new Parameter[] { new Parameter(ClassHelper.METACLASS_TYPE, \"mc\") };\n            if (!node.hasMethod(\"setMetaClass\", parameters)) {\n                metaClassField=setMetaClassFieldIfNotExists(node,metaClassField);\n                Statement setMetaClassCode;                \n                if (Modifier.isFinal(metaClassField.getModifiers())) {\n                    ConstantExpression text = new ConstantExpression(\"cannot set read-only meta class\");\n                    ConstructorCallExpression cce = new ConstructorCallExpression(ClassHelper.make(IllegalArgumentException.class), text);\n                    setMetaClassCode = new ExpressionStatement(cce);\n                } else {\n                    List list = new ArrayList();\n                    list.add (new BytecodeInstruction() {\n                        public void visit(MethodVisitor mv) {\n                            mv.visitVarInsn(ALOAD, 0);\n                            mv.visitVarInsn(ALOAD, 1);\n                            mv.visitFieldInsn(PUTFIELD, classInternalName, \"metaClass\", \"Lgroovy/lang/MetaClass;\");\n                        }\n                    });\n                    setMetaClassCode = new BytecodeSequence(list);\n                }\n                \n                node.addSyntheticMethod(\n                        \"setMetaClass\",\n                        ACC_PUBLIC,\n                        ClassHelper.VOID_TYPE,\n                        SET_METACLASS_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        setMetaClassCode\n                );\n            }\n\n            if (!node.hasMethod(\"invokeMethod\",INVOKE_METHOD_PARAMS)) {\n                VariableExpression vMethods = new VariableExpression(\"method\");\n                VariableExpression vArguments = new VariableExpression(\"arguments\");\n                VariableScope blockScope = new VariableScope();\n                blockScope.putReferencedLocalVariable(vMethods);\n                blockScope.putReferencedLocalVariable(vArguments);\n                node.addSyntheticMethod(\n                        \"invokeMethod\",\n                        ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE, INVOKE_METHOD_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitVarInsn(ALOAD, 1);\n                        mv.visitVarInsn(ALOAD, 2);\n                        mv.visitMethodInsn(INVOKEINTERFACE, \"groovy/lang/MetaClass\", \"invokeMethod\", \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\");\n                        mv.visitInsn(ARETURN);\n                    }\n                })\n                );\n            }\n\n            if (!node.hasMethod(\"getProperty\", GET_PROPERTY_PARAMS)) {\n                node.addSyntheticMethod(\n                        \"getProperty\",\n                        ACC_PUBLIC,\n                        ClassHelper.OBJECT_TYPE,\n                        GET_PROPERTY_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitVarInsn(ALOAD, 1);\n                        mv.visitMethodInsn(INVOKEINTERFACE, \"groovy/lang/MetaClass\", \"getProperty\", \"(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;\");\n                        mv.visitInsn(ARETURN);\n                    }\n                })\n                );\n            }\n\n            if (!node.hasMethod(\"setProperty\", SET_PROPERTY_PARAMS)) {\n                node.addSyntheticMethod(\n                        \"setProperty\",\n                        ACC_PUBLIC,\n                        ClassHelper.VOID_TYPE,\n                        SET_PROPERTY_PARAMS,\n                        ClassNode.EMPTY_ARRAY,\n                        new BytecodeSequence(new BytecodeInstruction() {\n                    public void visit(MethodVisitor mv) {\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, \"getMetaClass\", \"()Lgroovy/lang/MetaClass;\");\n                        mv.visitVarInsn(ALOAD, 0);\n                        mv.visitVarInsn(ALOAD, 1);\n                        mv.visitVarInsn(ALOAD, 2);\n                        mv.visitMethodInsn(INVOKEINTERFACE, \"groovy/lang/MetaClass\", \"setProperty\", \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V\");\n                        mv.visitInsn(RETURN);                    }\n                })\n                );\n            }\n\n        }\n\n        if (node.getDeclaredConstructors().isEmpty()) {\n            ConstructorNode constructor = new ConstructorNode(ACC_PUBLIC, null);\n            constructor.setSynthetic(true);\n            node.addConstructor(constructor);\n        }\n\n        if (!(node instanceof InnerClassNode)) {// add a static timestamp field to the class\n            addTimeStamp(node);\n        }\n\n        addInitialization(node);\n        checkReturnInObjectInitializer(node.getObjectInitializerStatements());\n        node.getObjectInitializerStatements().clear();\n        addCovariantMethods(node);\n        node.visitContents(this);\n    }","commit_id":"27dfb7f0f8c9bc0d174834c003c7d5d413a9d3cf","url":"https://github.com/apache/groovy"},{"original_method":"protected void addTimeStamp(ClassNode node) {\n        FieldNode timeTagField = new FieldNode(\n                Verifier.__TIMESTAMP,\n                Modifier.PUBLIC | Modifier.STATIC,\n                ClassHelper.Long_TYPE,\n                //\"\",\n                node,\n                new ConstantExpression(new Long(System.currentTimeMillis())));\n        // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode(\"public static final long __timeStamp = \" + System.currentTimeMillis() + \"L\");\n        timeTagField.setSynthetic(true);\n        node.addField(timeTagField);\n\n        timeTagField = new FieldNode(\n                Verifier.__TIMESTAMP__ + String.valueOf(System.currentTimeMillis()),\n                Modifier.PUBLIC | Modifier.STATIC,\n                ClassHelper.Long_TYPE,\n                //\"\",\n                node,\n                new ConstantExpression(new Long(0)));\n        // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode(\"public static final long __timeStamp = \" + System.currentTimeMillis() + \"L\");\n        timeTagField.setSynthetic(true);\n        node.addField(timeTagField);\n    }","id":101194,"modified_method":"protected void addTimeStamp(ClassNode node) {\n        FieldNode timeTagField = new FieldNode(\n                Verifier.__TIMESTAMP,\n                Modifier.PUBLIC | Modifier.STATIC,\n                ClassHelper.Long_TYPE,\n                //\"\",\n                node,\n                new ConstantExpression(System.currentTimeMillis()));\n        // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode(\"public static final long __timeStamp = \" + System.currentTimeMillis() + \"L\");\n        timeTagField.setSynthetic(true);\n        node.addField(timeTagField);\n\n        timeTagField = new FieldNode(\n                Verifier.__TIMESTAMP__ + String.valueOf(System.currentTimeMillis()),\n                Modifier.PUBLIC | Modifier.STATIC,\n                ClassHelper.Long_TYPE,\n                //\"\",\n                node,\n                new ConstantExpression((long) 0));\n        // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode(\"public static final long __timeStamp = \" + System.currentTimeMillis() + \"L\");\n        timeTagField.setSynthetic(true);\n        node.addField(timeTagField);\n    }","commit_id":"27dfb7f0f8c9bc0d174834c003c7d5d413a9d3cf","url":"https://github.com/apache/groovy"},{"original_method":"@Override\r\n\tpublic MaterialAttribute copy () {\r\n\t\treturn new ColorAttribute(color, name);\r\n\t}","id":101195,"modified_method":"@Override\r\n\tpublic MaterialAttribute copy () {\r\n\t\treturn new ColorAttribute(color, name, colorType);\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void bind (ShaderProgram program) {\r\n\t\tprogram.setUniformf(name, color.r, color.g, color.b, color.a);\r\n\t}","id":101196,"modified_method":"@Override\r\n\tpublic void bind (ShaderProgram program) {\r\n\t\tprogram.setUniformf(colorNames[type], color.r, color.g, color.b);\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"public ColorAttribute (Color color, String name) {\r\n\t\tsuper(name);\r\n\t\tthis.color = new Color(color);\r\n\t}","id":101197,"modified_method":"public ColorAttribute (Color color, String name, ColorType colorType) {\r\n\t\tsuper(name);\r\n\t\tthis.color.set(color);\r\n\t\tthis.colorType = colorType;\r\n\t\tthis.type = colorType.ordinal();\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void bind () {\r\n\t\tif (Gdx.gl10 == null) throw new RuntimeException(\"Can't call ColorAttribute.bind() in a GL20 context\");\r\n\t\tGdx.gl10.glColor4f(color.r, color.g, color.b, color.a);\r\n\t}","id":101198,"modified_method":"@Override\r\n\tpublic void bind () {\r\n\t\tif (Gdx.gl10 == null) throw new RuntimeException(\"Can't call ColorAttribute.bind() in a GL20 context\");\r\n\r\n\t\t// todo how about emissive or specular?\r\n\t\tif (colorType == ColorType.DIFFUSE) Gdx.gl10.glColor4f(color.r, color.g, color.b, 1f);\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void create () {\r\n\r\n\t\tmodelMatrix2.translate(0, 2, -8);\r\n\t\t//lightShader = ShaderLoader.createShader(\"vertexpath\", \"vertexpath\");\r\n\t\tlightShader = ShaderLoader.createShader(\"light\", \"light\");\r\n\t\t\r\n\t\tlightManager = new LightManager(LIGHTS_NUM);\r\n\t\tfor (int i = 0; i < 4; i++) {\r\n\t\t\tPointLight l = new PointLight();\r\n\t\t\tl.position.set(MathUtils.random(16) - 8, MathUtils.random(6) - 2, -MathUtils.random(16) + 2);\r\n\t\t\tl.color.r = MathUtils.random();\r\n\t\t\tl.color.b = MathUtils.random();\r\n\t\t\tl.color.g = MathUtils.random();\r\n\t\t\tl.intensity = LIGHT_INTESITY;\r\n\t\t\tlightManager.addLigth(l);\r\n\t\t}\r\n\t\tlightManager.dirLight = new DirectionalLight();\r\n\t\tlightManager.dirLight.color.set(0.038f,0.04f,0.09f,0);\r\n\t\tlightManager.dirLight.direction.set(-.1f,-1,0.03f).nor();\r\n\t\t\r\n\t\tlightManager.ambientLight.set(0.02f,0.02f,0.02f,0f);\r\n\t\t\r\n\t\tcam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 64f;\r\n\t\tcam.position.set(0, 0.5f, -2f);\r\n\t\tcam.update();\r\n\r\n\t\tcamController = new PerspectiveCamController(cam);\r\n\t\tGdx.input.setInputProcessor(camController);\r\n\r\n\t\ttexture = new Texture(Gdx.files.internal(\"data/multipleuvs_1.png\"), null, true);\r\n\t\ttexture.setFilter(TextureFilter.MipMapLinearNearest, TextureFilter.Linear);\r\n\r\n\t\ttexture2 = new Texture(Gdx.files.internal(\"data/wall.png\"), null, true);\r\n\t\ttexture2.setFilter(TextureFilter.MipMapLinearNearest, TextureFilter.Linear);\r\n\r\n\r\n\t\ttry {\r\n\t\t\tInputStream in = Gdx.files.internal(\"data/models/sphere.obj\").read();\r\n\t\t\tmesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\t\t\tin = Gdx.files.internal(\"data/models/basicscene.obj\").read();\r\n\t\t\tmesh2 = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\tmesh2.scale(1.25f, 1.25f, 1.25f);\r\n\r\n\t\tmesh.getVertexAttribute(Usage.Position).alias = \"a_position\";\r\n\t\tmesh.getVertexAttribute(Usage.Normal).alias = \"a_normal\";\r\n\t\t// mesh.getVertexAttribute(Usage.TextureCoordinates).alias =\r\n\t\t// \"a_texCoord0\";\r\n\r\n\t\tmesh2.getVertexAttribute(Usage.Position).alias = \"a_position\";\r\n\t\tmesh2.getVertexAttribute(Usage.Normal).alias = \"a_normal\";\r\n\t\t// mesh2.getVertexAttribute(Usage.TextureCoordinates).alias =\r\n\t\t// \"a_texCoord0\";\r\n\r\n\t}","id":101199,"modified_method":"public void create () {\r\n\r\n\t\t// lightShader = ShaderLoader.createShader(\"vertexpath\", \"vertexpath\");\r\n\r\n\t\tlightManager = new LightManager(LIGHTS_NUM, LightQuality.VERTEX);\r\n\t\tshader = ShaderFactory.createShader(null, lightManager);\r\n\t\tfor (int i = 0; i < 4; i++) {\r\n\t\t\tPointLight l = new PointLight();\r\n\t\t\tl.position.set(MathUtils.random(32) - 16, MathUtils.random(8) - 2, -MathUtils.random(32) + 16);\r\n\t\t\tl.color.r = MathUtils.random();\r\n\t\t\tl.color.b = MathUtils.random();\r\n\t\t\tl.color.g = MathUtils.random();\r\n\t\t\tl.intensity = LIGHT_INTESITY;\r\n\t\t\tlightManager.addLigth(l);\r\n\t\t}\r\n\t\tlightManager.dirLight = new DirectionalLight();\r\n\t\tlightManager.dirLight.color.set(1f, 0.1f, 0.09f, 0);\r\n\t\tlightManager.dirLight.direction.set(-.1f, -1, 0.03f).nor();\r\n\r\n\t\tlightManager.ambientLight.set(0.02f, 0.02f, 0.02f, 0f);\r\n\r\n\t\tcam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 64f;\r\n\t\tcam.position.set(0, 0.5f, -2f);\r\n\t\tcam.update();\r\n\r\n\t\tcamController = new PerspectiveCamController(cam);\r\n\t\tGdx.input.setInputProcessor(camController);\r\n\r\n\t\ttexture = new Texture(Gdx.files.internal(\"data/multipleuvs_1.png\"), null, true);\r\n\t\ttexture.setFilter(TextureFilter.MipMapLinearNearest, TextureFilter.Linear);\r\n\r\n\t\tmodel = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/models/sphere.obj\"));\r\n\t\tmodel2 = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/models/basicscene.obj\"));\r\n\r\n\t\tinstance = new StillModelNode();\r\n\t\tinstance.getTransform().translate(0, 3, -4);\r\n\t\tinstance2 = new StillModelNode();\r\n\r\n\t\tBoundingBox box = new BoundingBox();\r\n\t\tmodel.getBoundingBox(box);\r\n\t\tinstance.radius = box.getDimensions().len() / 2;\r\n\r\n\t\tmodel2.getBoundingBox(box);\r\n\t\tinstance2.radius = box.getDimensions().len() / 2;\r\n\r\n\t\tprotoRenderer = new PrototypeRendererGL20();\r\n\t\tprotoRenderer.setLightManager(lightManager);\r\n\r\n\t\tprotoRenderer.setShader(shader);\r\n\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void render () {\r\n\r\n\t\tlogger.log();\t\t\r\n\r\n\t\tfinal float delta = Gdx.graphics.getDeltaTime();\r\n\t\tcamController.update(delta);\r\n\t\t\r\n\t\ttimer+=delta;\r\n\t\tfor (int i = 0; i < lightManager.pointLights.size; i++) {\r\n\t\t\tVector3 v = lightManager.pointLights.get(i).position;\r\n\t\t\tv.x += MathUtils.sin(timer)*0.01f;\r\n\t\t\tv.z += MathUtils.cos(timer)*0.01f;\r\n\t\t}\r\n\r\n\t\tGdx.gl.glEnable(GL10.GL_CULL_FACE);\r\n\t\tGdx.gl.glCullFace(GL10.GL_BACK);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\t\tGdx.gl.glDepthMask(true);\r\n\r\n\t\tGdx.gl.glClearColor(0, 0, 0, 0);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\r\n\t\t\r\n\t\ttexture.bind(0);\r\n\r\n\t\tlightShader.begin();\r\n\t\t\r\n\t\tlightManager.applyGlobalLights(lightShader);\r\n\t\t\r\n\t\tlightShader.setUniformMatrix(\"u_modelMatrix\", modelMatrix2, false);\r\n\r\n\t\tlightShader.setUniformf(\"camPos\", cam.position.x, cam.position.y, cam.position.z);\r\n\t\tlightShader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\t\tlightShader.setUniformi(\"u_texture0\", 0);\r\n\t\tlightManager.calculateLights(0, 2, -8);\r\n\t\tlightManager.applyLights(lightShader);\r\n\r\n\t\tmesh.render(lightShader, GL10.GL_TRIANGLES);\r\n\r\n\t\ttexture2.bind(0);\r\n\t\tlightShader.setUniformMatrix(\"u_normalMatrix\", normalMatrix, false);\r\n\t\tlightShader.setUniformMatrix(\"u_modelMatrix\", modelMatrix, false);\r\n\t\tlightManager.calculateLights(0, 0, 0);\r\n\t\tlightManager.applyLights(lightShader);\r\n\t\tmesh2.render(lightShader, GL10.GL_TRIANGLES);\r\n\r\n\t\tlightShader.end();\r\n\r\n\t}","id":101200,"modified_method":"public void render () {\r\n\r\n\t\tlogger.log();\r\n\r\n\t\tfinal float delta = Gdx.graphics.getDeltaTime();\r\n\t\tcamController.update(delta);\r\n\r\n\t\ttimer += delta;\r\n\t\tfor (int i = 0; i < lightManager.pointLights.size; i++) {\r\n\t\t\tVector3 v = lightManager.pointLights.get(i).position;\r\n\t\t\tv.x += MathUtils.sin(timer) * 0.01f;\r\n\t\t\tv.z += MathUtils.cos(timer) * 0.01f;\r\n\t\t}\r\n\r\n\t\tGdx.gl.glEnable(GL10.GL_CULL_FACE);\r\n\t\tGdx.gl.glCullFace(GL10.GL_BACK);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\t\tGdx.gl.glDepthMask(true);\r\n\r\n\t\tGdx.gl.glClearColor(0, 0, 0, 0);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\r\n\t\ttexture.bind(0);\r\n\r\n\t\tshader.begin();\r\n\r\n\t\tshader.setUniformf(\"camPos\", cam.position.x, cam.position.y, cam.position.z);\r\n\t\tshader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\r\n\t\tshader.end();\r\n\r\n\t\tprotoRenderer.begin();\r\n\r\n\t\tprotoRenderer.draw(model, instance);\r\n\t\tprotoRenderer.draw(model2, instance2);\r\n\t\tprotoRenderer.end();\r\n\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void dispose () {\r\n\t\tmesh.dispose();\r\n\t\tmesh2.dispose();\r\n\t\ttexture.dispose();\r\n\t\ttexture2.dispose();\r\n\t\tlightShader.dispose();\r\n\r\n\t}","id":101201,"modified_method":"public void dispose () {\r\n\t\tmodel.dispose();\r\n\t\tmodel2.dispose();\r\n\t\ttexture.dispose();\r\n\t\tshader.dispose();\r\n\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"public LightManager(int maxLightsPerModel) {\r\n\t\tthis.maxLightsPerModel = maxLightsPerModel;\r\n\r\n\t\tcolors = new float[3 * maxLightsPerModel];\r\n\t\tpositions = new float[3 * maxLightsPerModel];\r\n\t\tintensities = new float[maxLightsPerModel];\r\n\t}","id":101202,"modified_method":"public LightManager (int maxLightsPerModel, LightQuality lightQuality) {\r\n\t\tquality = lightQuality;\r\n\t\tthis.maxLightsPerModel = maxLightsPerModel;\r\n\r\n\t\tcolors = new float[3 * maxLightsPerModel];\r\n\t\tpositions = new float[3 * maxLightsPerModel];\r\n\t\tintensities = new float[maxLightsPerModel];\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"public LightManager() {\r\n\t\tthis(4);\r\n\t}","id":101203,"modified_method":"public LightManager () {\r\n\t\tthis(4, LightQuality.VERTEX);\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void create() {\r\n\t\tlong start = System.nanoTime();\r\n\t\tmodel = ModelLoaderRegistry\r\n\t\t\t\t.loadStillModel(Gdx.files.internal(fileName));\r\n\t\tGdx.app.log(\"StillModelViewer\", \"loading took: \"\r\n\t\t\t\t+ (System.nanoTime() - start) / 1000000000.0f);\r\n\r\n\t\tif (textureFileNames.length != 0) {\r\n\t\t\ttextures = new Texture[textureFileNames.length];\r\n\t\t\tfor (int i = 0; i < textureFileNames.length; i++) {\r\n\t\t\t\ttextures[i] = new Texture(\r\n\t\t\t\t\t\tGdx.files.internal(textureFileNames[i]), i > 0 ? false\r\n\t\t\t\t\t\t\t\t: true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmodel.getBoundingBox(bounds);\r\n\t\tfloat len = bounds.getDimensions().len();\r\n\t\tSystem.out.println(\"bounds: \" + bounds);\r\n\r\n\t\tcam = new PerspectiveCamera(60, Gdx.graphics.getWidth(),\r\n\t\t\t\tGdx.graphics.getHeight());\r\n\t\tcam.position.set(bounds.getCenter().cpy()\r\n\t\t\t\t.add(len / 2, len / 2, len / 2));\r\n\t\tcam.lookAt(bounds.getCenter().x, bounds.getCenter().y,\r\n\t\t\t\tbounds.getCenter().z);\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 512;\r\n\r\n\t\trenderer = new ImmediateModeRenderer20(false, true, 16);\r\n\t\tbatch = new SpriteBatch();\r\n\t\tfont = new BitmapFont();\r\n\r\n\t\tshader = ShaderLoader.createShader(\"light\", \"light\");\r\n\r\n\t\tlightManager = new LightManager(4);\r\n\t\tlightManager.ambientLight.set(0.1f, 0.1f, 0.1f, 0);\r\n\t\tlightManager.dirLight = new DirectionalLight();\r\n\t\tlightManager.dirLight.color.set(0.048f, 0.04f, 0.09f, 0);\r\n\t\tlightManager.dirLight.direction.set(-.1f, -1, 0.03f).nor();\r\n\r\n\t\tfor (int i = 0; i < 8; i++) {\r\n\t\t\tPointLight l = new PointLight();\r\n\t\t\tl.position.set(MathUtils.random(6) - 3, MathUtils.random(9) - 3,\r\n\t\t\t\t\t-MathUtils.random(6) + 3);\r\n\t\t\tl.color.r = MathUtils.random();\r\n\t\t\tl.color.b = MathUtils.random();\r\n\t\t\tl.color.g = MathUtils.random();\r\n\t\t\tl.intensity = 64;\r\n\t\t\tlightManager.addLigth(l);\r\n\t\t}\r\n\t\tlightManager.ambientLight.set(1, 0, 0, 0);\r\n\r\n\t\tprotoRenderer = new PrototypeRendererGL20();\r\n\t\tprotoRenderer.setShader(shader);\r\n\t\tprotoRenderer.setLightManager(lightManager);\r\n\r\n\t\tinstance = new StillModelNode();\r\n\t\tinstance.getTransform().translate(-len / 3, 4, 2);\r\n\t\tinstance2 = new StillModelNode();\r\n\t\tinstance2.getTransform().translate(len / 4, -2, 2);\r\n\r\n\t\tinstance.radius = bounds.getDimensions().len() / 2;\r\n\t\tinstance2.radius = instance.radius;\r\n\r\n\t\tfor (StillSubMesh mesh : model.subMeshes) {\r\n\t\t\tSystem.out.println(mesh.material.name);\r\n\t\t}\r\n\t}","id":101204,"modified_method":"@Override\r\n\tpublic void create () {\r\n\t\tlong start = System.nanoTime();\r\n\t\tmodel = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(fileName));\r\n\t\tGdx.app.log(\"StillModelViewer\", \"loading took: \" + (System.nanoTime() - start) / 1000000000.0f);\r\n\r\n\t\tif (textureFileNames.length != 0) {\r\n\t\t\ttextures = new Texture[textureFileNames.length];\r\n\t\t\tfor (int i = 0; i < textureFileNames.length; i++) {\r\n\t\t\t\ttextures[i] = new Texture(Gdx.files.internal(textureFileNames[i]), i > 0 ? false : true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmodel.getBoundingBox(bounds);\r\n\t\tfloat len = bounds.getDimensions().len();\r\n\t\tSystem.out.println(\"bounds: \" + bounds);\r\n\r\n\t\tcam = new PerspectiveCamera(60, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\tcam.position.set(bounds.getCenter().cpy().add(len / 2, len / 2, len / 2));\r\n\t\tcam.lookAt(bounds.getCenter().x, bounds.getCenter().y, bounds.getCenter().z);\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 512;\r\n\r\n\t\tbatch = new SpriteBatch();\r\n\t\tfont = new BitmapFont();\r\n\r\n\t\t//shader1 = ShaderLoader.createShader(\"light\", \"light\");\r\n\t\t//shader2 = ShaderLoader.createShader(\"vertexpath\", \"vertexpath\");\r\n\r\n\t\tlightManager = new LightManager(4, LightQuality.VERTEX);\r\n\t\tlightManager.ambientLight.set(0.1f, 0.1f, 0.1f, 0);\r\n\t\tlightManager.dirLight = new DirectionalLight();\r\n\t\tlightManager.dirLight.color.set(1.0f, 0.1f, 0.09f, 0);\r\n\t\tlightManager.dirLight.direction.set(-.1f, -1, 0.03f).nor();\r\n\r\n\t\tfor (int i = 0; i < 14; i++) {\r\n\t\t\tPointLight l = new PointLight();\r\n\t\t\tl.position.set(-MathUtils.random(6) + 3, MathUtils.random(3), -MathUtils.random(6) + 3);\r\n\t\t\tl.color.r = MathUtils.random();\r\n\t\t\tl.color.b = MathUtils.random();\r\n\t\t\tl.color.g = MathUtils.random();\r\n\t\t\tl.intensity = 2;\r\n\t\t\tlightManager.addLigth(l);\r\n\t\t}\r\n\t\tlightManager.ambientLight.set(1, 0, 0, 0);\r\n\r\n\t\tprotoRenderer = new PrototypeRendererGL20();\r\n\t\tprotoRenderer.setLightManager(lightManager);\r\n\r\n\t\tinstance = new StillModelNode();\r\n\t\tinstance.getTransform().translate(-len / 2, -2, 2);\r\n\t\tinstance2 = new StillModelNode();\r\n\t\tinstance2.getTransform().translate(len / 2, -2, -7);\r\n\r\n\t\tinstance.radius = bounds.getDimensions().len() / 2;\r\n\t\tinstance2.radius = instance.radius;\r\n\r\n\t\tMaterialAttribute c1 = new ColorAttribute(new Color(0.52f, 0.51f, 0.51f, 1.0f), \"color\", ColorType.SPECULAR);\r\n\t\tMaterialAttribute c2 = new ColorAttribute(new Color(0.95f, 0.95f, 0.95f, 1.0f), \"color\", ColorType.DIFFUSE);\r\n\t\tMaterialAttribute c3 = new ColorAttribute(new Color(0.01f, 0.05f, 0.05f, 1.0f), \"color\", ColorType.EMISSIVE);\r\n\t\tMaterial material = new Material(\"color\", c1, c2, c3);\r\n\t\tmodel.setMaterial(material);\r\n\t\t\t\r\n\t\tshader2 = ShaderFactory.createShader(material, lightManager);\r\n\t\t\r\n\t\t//lightManager.quality=LightQuality.FRAGMENT;\r\n\t\t//\t\tshader1 = ShaderFactory.createShader(material, lightManager);\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void render() {\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\t\tGdx.gl.glEnable(GL10.GL_CULL_FACE);\r\n\r\n\t\tinstance.getTransform().rotate(0, 1, -0.1f,\r\n\t\t\t\t35 * Gdx.graphics.getDeltaTime());\r\n\t\tinstance2.getTransform().rotate(0, 1, 0.1f,\r\n\t\t\t\t-15 * Gdx.graphics.getDeltaTime());\r\n\r\n\t\tcam.update();\r\n\r\n\t\tshader.begin();\r\n\t\tshader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\r\n\t\tshader.setUniformi(\"u_texture0\", 0);\r\n\t\tshader.end();\r\n\r\n\t\ttextures[0].bind(0);\r\n\r\n\t\t// shader.setUniformi(\"u_texture1\", 1);\r\n\t\t// textures[1].bind(1);\r\n\r\n\t\tprotoRenderer.begin();\r\n\t\tprotoRenderer.draw(model, instance);\r\n\t\tprotoRenderer.draw(model, instance2);\r\n\t\tprotoRenderer.end();\r\n\r\n\t\tbatch.begin();\r\n\t\tfont.draw(batch, \"fps: \" + Gdx.graphics.getFramesPerSecond(), 20, 30);\r\n\t\tbatch.end();\r\n\r\n\t\tfps.log();\r\n\t}","id":101205,"modified_method":"@Override\r\n\tpublic void render () {\r\n\t\tShaderProgram shader = shader2;\r\n//\t\tif (Gdx.input.isTouched()) {\r\n//\t\t\tshader = shader1;\r\n//\t\t}\r\n\t\tprotoRenderer.setShader(shader);\r\n\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\t\tGdx.gl.glEnable(GL10.GL_CULL_FACE);\r\n\r\n\t\tinstance.getTransform().rotate(0, 1, -0.1f, 35 * Gdx.graphics.getDeltaTime());\r\n\t\tinstance2.getTransform().rotate(0, 1, 0.1f, -15 * Gdx.graphics.getDeltaTime());\r\n\r\n\t\tcam.update();\r\n\r\n\t\tshader.begin();\r\n\t\tshader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\t\tshader.setUniformf(\"camPos\", cam.position.x, cam.position.y, cam.position.z);\r\n\t\tshader.setUniformi(\"u_texture0\", 0);\r\n\t\tshader.end();\r\n\r\n\t\ttextures[0].bind(0);\r\n\r\n\t\t// shader.setUniformi(\"u_texture1\", 1);\r\n\t\t// textures[1].bind(1);\r\n\r\n\t\tprotoRenderer.begin();\r\n\t\tprotoRenderer.draw(model, instance);\r\n\t\tprotoRenderer.draw(model, instance2);\r\n\t\tprotoRenderer.end();\r\n\r\n\t\tbatch.begin();\r\n\t\tfont.draw(batch, \"fps: \" + Gdx.graphics.getFramesPerSecond(), 20, 30);\r\n\t\tbatch.end();\r\n\r\n\t\tfps.log();\r\n\t}","commit_id":"e0df4caa1dbdf38dc8227049ce106f9e6d1a7116","url":"https://github.com/libgdx/libgdx"},{"original_method":"public RendererGL10 () {\r\n\t\ttry {\r\n\t\t\tspriteBatch = new SpriteBatch();\r\n\r\n\t\t\tInputStream in = Gdx.files.internal(\"data/ship.obj\").read();\r\n\t\t\tshipMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tin = Gdx.files.internal(\"data/invader.obj\").read();\r\n\t\t\tinvaderMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tin = Gdx.files.internal(\"data/block.obj\").read();\r\n\t\t\tblockMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tin = Gdx.files.internal(\"data/shot.obj\").read();\r\n\t\t\tshotMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tshipTexture = new Texture(Gdx.files.internal(\"data/ship.png\"), Format.RGB565, true);\r\n\t\t\tshipTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tinvaderTexture = new Texture(Gdx.files.internal(\"data/invader.png\"), Format.RGB565, true);\r\n\t\t\tinvaderTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tbackgroundTexture = new Texture(Gdx.files.internal(\"data/planet.jpg\"), Format.RGB565, true);\r\n\t\t\tbackgroundTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\texplosionTexture = new Texture(Gdx.files.internal(\"data/explode.png\"), Format.RGBA4444, true);\r\n\t\t\texplosionTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\r\n\t\t\texplosionMesh = new Mesh(true, 4 * 16, 0, new VertexAttribute(Usage.Position, 3, \"a_position\"), new VertexAttribute(\r\n\t\t\t\tUsage.TextureCoordinates, 2, \"a_texCoord\"));\r\n\r\n\t\t\tfloat[] vertices = new float[4 * 16 * (3 + 2)];\r\n\t\t\tint idx = 0;\r\n\t\t\tfor (int row = 0; row < 4; row++) {\r\n\t\t\t\tfor (int column = 0; column < 4; column++) {\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0 + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\texplosionMesh.setVertices(vertices);\r\n\t\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font10.fnt\"), Gdx.files.internal(\"data/font10.png\"), false);\r\n\r\n\t\t\tcamera = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\t} catch (Exception ex) {\r\n\t\t\tex.printStackTrace();\r\n\t\t}\r\n\t}","id":101206,"modified_method":"public RendererGL10 () {\r\n\t\ttry {\r\n\t\t\tspriteBatch = new SpriteBatch();\r\n\r\n\t\t\tshipMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/ship.obj\"));\r\n\t\t\tinvaderMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/invader.obj\"));\r\n\t\t\tblockMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/block.obj\"));\r\n\t\t\tshotMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/shot.obj\"));\r\n\r\n\t\t\tshipTexture = new Texture(Gdx.files.internal(\"data/ship.png\"), Format.RGB565, true);\r\n\t\t\tshipTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tinvaderTexture = new Texture(Gdx.files.internal(\"data/invader.png\"), Format.RGB565, true);\r\n\t\t\tinvaderTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tbackgroundTexture = new Texture(Gdx.files.internal(\"data/planet.jpg\"), Format.RGB565, true);\r\n\t\t\tbackgroundTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\texplosionTexture = new Texture(Gdx.files.internal(\"data/explode.png\"), Format.RGBA4444, true);\r\n\t\t\texplosionTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\r\n\t\t\texplosionMesh = new Mesh(true, 4 * 16, 0, new VertexAttribute(Usage.Position, 3, \"a_position\"), new VertexAttribute(\r\n\t\t\t\tUsage.TextureCoordinates, 2, \"a_texCoord\"));\r\n\r\n\t\t\tfloat[] vertices = new float[4 * 16 * (3 + 2)];\r\n\t\t\tint idx = 0;\r\n\t\t\tfor (int row = 0; row < 4; row++) {\r\n\t\t\t\tfor (int column = 0; column < 4; column++) {\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0 + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\texplosionMesh.setVertices(vertices);\r\n\t\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font10.fnt\"), Gdx.files.internal(\"data/font10.png\"), false);\r\n\r\n\t\t\tcamera = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\t} catch (Exception ex) {\r\n\t\t\tex.printStackTrace();\r\n\t\t}\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderShip (GL10 gl, Ship ship) {\r\n\t\tif (ship.isExploding) return;\r\n\r\n\t\tshipTexture.bind();\r\n\t\tgl.glPushMatrix();\r\n\t\tgl.glTranslatef(ship.position.x, ship.position.y, ship.position.z);\r\n\t\tgl.glRotatef(45 * (-Gdx.input.getAccelerometerY() / 5), 0, 0, 1);\r\n\t\tgl.glRotatef(180, 0, 1, 0);\r\n\t\tshipMesh.render(GL10.GL_TRIANGLES);\r\n\t\tgl.glPopMatrix();\r\n\t}","id":101207,"modified_method":"private void renderShip (GL10 gl, Ship ship) {\r\n\t\tif (ship.isExploding) return;\r\n\r\n\t\tshipTexture.bind();\r\n\t\tgl.glPushMatrix();\r\n\t\tgl.glTranslatef(ship.position.x, ship.position.y, ship.position.z);\r\n\t\tgl.glRotatef(45 * (-Gdx.input.getAccelerometerY() / 5), 0, 0, 1);\r\n\t\tgl.glRotatef(180, 0, 1, 0);\r\n\t\tshipMesh.render();\r\n\t\tgl.glPopMatrix();\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderShots (GL10 gl, ArrayList<Shot> shots) {\r\n\t\tgl.glColor4f(1, 1, 0, 1);\r\n\t\tfor (int i = 0; i < shots.size(); i++) {\r\n\t\t\tShot shot = shots.get(i);\r\n\t\t\tgl.glPushMatrix();\r\n\t\t\tgl.glTranslatef(shot.position.x, shot.position.y, shot.position.z);\r\n\t\t\tshotMesh.render(GL10.GL_TRIANGLES);\r\n\t\t\tgl.glPopMatrix();\r\n\t\t}\r\n\t\tgl.glColor4f(1, 1, 1, 1);\r\n\t}","id":101208,"modified_method":"private void renderShots (GL10 gl, ArrayList<Shot> shots) {\r\n\t\tgl.glColor4f(1, 1, 0, 1);\r\n\t\tfor (int i = 0; i < shots.size(); i++) {\r\n\t\t\tShot shot = shots.get(i);\r\n\t\t\tgl.glPushMatrix();\r\n\t\t\tgl.glTranslatef(shot.position.x, shot.position.y, shot.position.z);\r\n\t\t\tshotMesh.render();\r\n\t\t\tgl.glPopMatrix();\r\n\t\t}\r\n\t\tgl.glColor4f(1, 1, 1, 1);\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderBlocks (GL10 gl, ArrayList<Block> blocks) {\r\n\t\tgl.glEnable(GL10.GL_BLEND);\r\n\t\tgl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\r\n\t\tgl.glColor4f(0.2f, 0.2f, 1, 0.7f);\r\n\t\tfor (int i = 0; i < blocks.size(); i++) {\r\n\t\t\tBlock block = blocks.get(i);\r\n\t\t\tgl.glPushMatrix();\r\n\t\t\tgl.glTranslatef(block.position.x, block.position.y, block.position.z);\r\n\t\t\tblockMesh.render(GL10.GL_TRIANGLES);\r\n\t\t\tgl.glPopMatrix();\r\n\t\t}\r\n\t\tgl.glColor4f(1, 1, 1, 1);\r\n\t\tgl.glDisable(GL10.GL_BLEND);\r\n\t}","id":101209,"modified_method":"private void renderBlocks (GL10 gl, ArrayList<Block> blocks) {\r\n\t\tgl.glEnable(GL10.GL_BLEND);\r\n\t\tgl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\r\n\t\tgl.glColor4f(0.2f, 0.2f, 1, 0.7f);\r\n\t\tfor (int i = 0; i < blocks.size(); i++) {\r\n\t\t\tBlock block = blocks.get(i);\r\n\t\t\tgl.glPushMatrix();\r\n\t\t\tgl.glTranslatef(block.position.x, block.position.y, block.position.z);\r\n\t\t\tblockMesh.render();\r\n\t\t\tgl.glPopMatrix();\r\n\t\t}\r\n\t\tgl.glColor4f(1, 1, 1, 1);\r\n\t\tgl.glDisable(GL10.GL_BLEND);\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderInvaders (GL10 gl, ArrayList<Invader> invaders) {\r\n\t\tinvaderTexture.bind();\r\n\t\tfor (int i = 0; i < invaders.size(); i++) {\r\n\t\t\tInvader invader = invaders.get(i);\r\n\t\t\tgl.glPushMatrix();\r\n\t\t\tgl.glTranslatef(invader.position.x, invader.position.y, invader.position.z);\r\n\t\t\tgl.glRotatef(invaderAngle, 0, 1, 0);\r\n\t\t\tinvaderMesh.render(GL10.GL_TRIANGLES);\r\n\t\t\tgl.glPopMatrix();\r\n\t\t}\r\n\t}","id":101210,"modified_method":"private void renderInvaders (GL10 gl, ArrayList<Invader> invaders) {\r\n\t\tinvaderTexture.bind();\r\n\t\tfor (int i = 0; i < invaders.size(); i++) {\r\n\t\t\tInvader invader = invaders.get(i);\r\n\t\t\tgl.glPushMatrix();\r\n\t\t\tgl.glTranslatef(invader.position.x, invader.position.y, invader.position.z);\r\n\t\t\tgl.glRotatef(invaderAngle, 0, 1, 0);\r\n\t\t\tinvaderMesh.render();\r\n\t\t\tgl.glPopMatrix();\r\n\t\t}\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderInvaders (ArrayList<Invader> invaders) {\r\n\t\tlightTexShader.begin();\r\n\t\tnormal.idt();\r\n\t\tnormal.rotate(0, 1, 0, invaderAngle);\r\n\t\tnormal3.set(normal.toNormalMatrix());\r\n\t\tlightTexShader.setUniformMatrix(\"u_normal\", normal3);\r\n\t\tinvaderTexture.bind();\r\n\t\tfor (int i = 0; i < invaders.size(); i++) {\r\n\t\t\tInvader invader = invaders.get(i);\r\n\t\t\ttransform.set(camera.combined);\r\n\t\t\ttransform.translate(invader.position.x, invader.position.y, invader.position.z);\r\n\t\t\ttransform.rotate(0, 1, 0, invaderAngle);\r\n\t\t\tlightTexShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\t\tinvaderMesh.render(lightTexShader, GL10.GL_TRIANGLES);\r\n\t\t}\r\n\t\tlightTexShader.end();\r\n\t}","id":101211,"modified_method":"private void renderInvaders (ArrayList<Invader> invaders) {\r\n\t\tlightTexShader.begin();\r\n\t\tnormal.idt();\r\n\t\tnormal.rotate(0, 1, 0, invaderAngle);\r\n\t\tnormal3.set(normal.toNormalMatrix());\r\n\t\tlightTexShader.setUniformMatrix(\"u_normal\", normal3);\r\n\t\tinvaderTexture.bind();\r\n\t\tfor (int i = 0; i < invaders.size(); i++) {\r\n\t\t\tInvader invader = invaders.get(i);\r\n\t\t\ttransform.set(camera.combined);\r\n\t\t\ttransform.translate(invader.position.x, invader.position.y, invader.position.z);\r\n\t\t\ttransform.rotate(0, 1, 0, invaderAngle);\r\n\t\t\tlightTexShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\t\tinvaderMesh.render(lightTexShader);\r\n\t\t}\r\n\t\tlightTexShader.end();\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderBlocks (ArrayList<Block> blocks) {\r\n\t\tGdx.gl.glEnable(GL10.GL_BLEND);\r\n\t\tGdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\r\n\t\tcolorShader.begin();\r\n\t\tcolorShader.setUniformf(\"u_color\", 0, 0, 1, 0.5f);\r\n\t\tfor (int i = 0; i < blocks.size(); i++) {\r\n\t\t\tBlock block = blocks.get(i);\r\n\t\t\ttransform.set(camera.combined);\r\n\t\t\ttransform.translate(block.position.x, block.position.y, block.position.z);\r\n\t\t\tcolorShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\t\tblockMesh.render(colorShader, GL10.GL_TRIANGLES);\r\n\t\t}\r\n\t\tcolorShader.end();\r\n\t\tGdx.gl.glDisable(GL10.GL_BLEND);\r\n\t}","id":101212,"modified_method":"private void renderBlocks (ArrayList<Block> blocks) {\r\n\t\tGdx.gl.glEnable(GL10.GL_BLEND);\r\n\t\tGdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\r\n\t\tcolorShader.begin();\r\n\t\tcolorShader.setUniformf(\"u_color\", 0, 0, 1, 0.5f);\r\n\t\tfor (int i = 0; i < blocks.size(); i++) {\r\n\t\t\tBlock block = blocks.get(i);\r\n\t\t\ttransform.set(camera.combined);\r\n\t\t\ttransform.translate(block.position.x, block.position.y, block.position.z);\r\n\t\t\tcolorShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\t\tblockMesh.render(colorShader);\r\n\t\t}\r\n\t\tcolorShader.end();\r\n\t\tGdx.gl.glDisable(GL10.GL_BLEND);\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderShots (ArrayList<Shot> shots) {\r\n\t\tcolorShader.begin();\r\n\t\tcolorShader.setUniformf(\"u_color\", 1, 1, 0, 1f);\r\n\t\tfor (int i = 0; i < shots.size(); i++) {\r\n\t\t\tShot shot = shots.get(i);\r\n\t\t\ttransform.set(camera.combined);\r\n\t\t\ttransform.translate(shot.position.x, shot.position.y, shot.position.z);\r\n\t\t\tcolorShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\t\tshotMesh.render(colorShader, GL10.GL_TRIANGLES);\r\n\t\t}\r\n\t\tcolorShader.end();\r\n\t}","id":101213,"modified_method":"private void renderShots (ArrayList<Shot> shots) {\r\n\t\tcolorShader.begin();\r\n\t\tcolorShader.setUniformf(\"u_color\", 1, 1, 0, 1f);\r\n\t\tfor (int i = 0; i < shots.size(); i++) {\r\n\t\t\tShot shot = shots.get(i);\r\n\t\t\ttransform.set(camera.combined);\r\n\t\t\ttransform.translate(shot.position.x, shot.position.y, shot.position.z);\r\n\t\t\tcolorShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\t\tshotMesh.render(colorShader);\r\n\t\t}\r\n\t\tcolorShader.end();\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"public RendererGL20 () {\r\n\t\ttry {\r\n\t\t\tspriteBatch = new SpriteBatch();\r\n\r\n\t\t\ttexShader = new ShaderProgram(Gdx.files.internal(\"data/shaders/tex-vs.glsl\"),\r\n\t\t\t\tGdx.files.internal(\"data/shaders/tex-fs.glsl\"));\r\n\t\t\tcolorShader = new ShaderProgram(Gdx.files.internal(\"data/shaders/color-vs.glsl\"),\r\n\t\t\t\tGdx.files.internal(\"data/shaders/color-fs.glsl\"));\r\n\t\t\tlightTexShader = new ShaderProgram(Gdx.files.internal(\"data/shaders/light-tex-vs.glsl\"),\r\n\t\t\t\tGdx.files.internal(\"data/shaders/light-tex-fs.glsl\"));\r\n\r\n\t\t\tif (!texShader.isCompiled()) throw new GdxRuntimeException(\"Couldn't compile tex shader\");\r\n\t\t\tif (!colorShader.isCompiled()) throw new GdxRuntimeException(\"Couldn't compile color shader\");\r\n\t\t\tif (!lightTexShader.isCompiled()) throw new GdxRuntimeException(\"Couldn't compile light/tex shader\");\r\n\r\n\t\t\tInputStream in = Gdx.files.internal(\"data/ship.obj\").read();\r\n\t\t\tshipMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tin = Gdx.files.internal(\"data/invader.obj\").read();\r\n\t\t\tinvaderMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tin = Gdx.files.internal(\"data/block.obj\").read();\r\n\t\t\tblockMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tin = Gdx.files.internal(\"data/shot.obj\").read();\r\n\t\t\tshotMesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t\tshipTexture = new Texture(Gdx.files.internal(\"data/ship.png\"), Format.RGB565, true);\r\n\t\t\tshipTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tinvaderTexture = new Texture(Gdx.files.internal(\"data/invader.png\"), Format.RGB565, true);\r\n\t\t\tinvaderTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tbackgroundTexture = new Texture(Gdx.files.internal(\"data/planet.jpg\"), Format.RGB565, true);\r\n\t\t\tbackgroundTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\texplosionTexture = new Texture(Gdx.files.internal(\"data/explode.png\"), Format.RGBA4444, true);\r\n\t\t\texplosionTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\r\n\t\t\texplosionMesh = new Mesh(true, 4 * 16, 0, new VertexAttribute(Usage.Position, 3, \"a_position\"), new VertexAttribute(\r\n\t\t\t\tUsage.TextureCoordinates, 2, \"a_texCoord0\"));\r\n\r\n\t\t\tfloat[] vertices = new float[4 * 16 * (3 + 2)];\r\n\t\t\tint idx = 0;\r\n\t\t\tfor (int row = 0; row < 4; row++) {\r\n\t\t\t\tfor (int column = 0; column < 4; column++) {\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0 + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\texplosionMesh.setVertices(vertices);\r\n\t\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font10.fnt\"), Gdx.files.internal(\"data/font10.png\"), false);\r\n\r\n\t\t\tcamera = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\t} catch (Exception ex) {\r\n\t\t\tex.printStackTrace();\r\n\t\t}\r\n\t}","id":101214,"modified_method":"public RendererGL20 () {\r\n\t\ttry {\r\n\t\t\tspriteBatch = new SpriteBatch();\r\n\r\n\t\t\ttexShader = new ShaderProgram(Gdx.files.internal(\"data/shaders/tex-vs.glsl\"),\r\n\t\t\t\tGdx.files.internal(\"data/shaders/tex-fs.glsl\"));\r\n\t\t\tcolorShader = new ShaderProgram(Gdx.files.internal(\"data/shaders/color-vs.glsl\"),\r\n\t\t\t\tGdx.files.internal(\"data/shaders/color-fs.glsl\"));\r\n\t\t\tlightTexShader = new ShaderProgram(Gdx.files.internal(\"data/shaders/light-tex-vs.glsl\"),\r\n\t\t\t\tGdx.files.internal(\"data/shaders/light-tex-fs.glsl\"));\r\n\r\n\t\t\tif (!texShader.isCompiled()) throw new GdxRuntimeException(\"Couldn't compile tex shader\");\r\n\t\t\tif (!colorShader.isCompiled()) throw new GdxRuntimeException(\"Couldn't compile color shader\");\r\n\t\t\tif (!lightTexShader.isCompiled()) throw new GdxRuntimeException(\"Couldn't compile light/tex shader\");\r\n\r\n\t\t\tshipMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/ship.obj\"));\r\n\t\t\tinvaderMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/invader.obj\"));\r\n\t\t\tblockMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/block.obj\"));\r\n\t\t\tshotMesh = ModelLoaderRegistry.loadStillModel(Gdx.files.internal(\"data/shot.obj\"));\r\n\r\n\t\t\tshipTexture = new Texture(Gdx.files.internal(\"data/ship.png\"), Format.RGB565, true);\r\n\t\t\tshipTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tinvaderTexture = new Texture(Gdx.files.internal(\"data/invader.png\"), Format.RGB565, true);\r\n\t\t\tinvaderTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\tbackgroundTexture = new Texture(Gdx.files.internal(\"data/planet.jpg\"), Format.RGB565, true);\r\n\t\t\tbackgroundTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\t\t\texplosionTexture = new Texture(Gdx.files.internal(\"data/explode.png\"), Format.RGBA4444, true);\r\n\t\t\texplosionTexture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);\r\n\r\n\t\t\texplosionMesh = new Mesh(true, 4 * 16, 0, new VertexAttribute(Usage.Position, 3, \"a_position\"), new VertexAttribute(\r\n\t\t\t\tUsage.TextureCoordinates, 2, \"a_texCoord0\"));\r\n\r\n\t\t\tfloat[] vertices = new float[4 * 16 * (3 + 2)];\r\n\t\t\tint idx = 0;\r\n\t\t\tfor (int row = 0; row < 4; row++) {\r\n\t\t\t\tfor (int column = 0; column < 4; column++) {\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0 + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0 + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\r\n\t\t\t\t\tvertices[idx++] = 1;\r\n\t\t\t\t\tvertices[idx++] = -1;\r\n\t\t\t\t\tvertices[idx++] = 0;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + column * 0.25f;\r\n\t\t\t\t\tvertices[idx++] = 0.25f + row * 0.25f;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\texplosionMesh.setVertices(vertices);\r\n\t\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font10.fnt\"), Gdx.files.internal(\"data/font10.png\"), false);\r\n\r\n\t\t\tcamera = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\t} catch (Exception ex) {\r\n\t\t\tex.printStackTrace();\r\n\t\t}\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void renderShip (Ship ship) {\r\n\t\tif (ship.isExploding) return;\r\n\r\n\t\tshipTexture.bind();\r\n\t\tlightTexShader.begin();\r\n\t\tlightTexShader.setUniformi(\"u_diffuse\", 0);\r\n\t\ttransform.set(camera.combined);\r\n\t\ttransform.translate(ship.position.x, ship.position.y, ship.position.z);\r\n\t\ttransform.rotate(0, 0, 1, 45 * (-Gdx.input.getAccelerometerY() / 5));\r\n\t\ttransform.rotate(0, 1, 0, 180);\r\n\t\tlightTexShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\tnormal.idt();\r\n\t\tnormal.rotate(0, 1, 0, 180);\r\n\t\tnormal3.set(normal.toNormalMatrix());\r\n\t\tlightTexShader.setUniformMatrix(\"u_normal\", normal3);\r\n\t\tshipMesh.render(lightTexShader, GL10.GL_TRIANGLES);\r\n\t\tlightTexShader.end();\r\n\t}","id":101215,"modified_method":"private void renderShip (Ship ship) {\r\n\t\tif (ship.isExploding) return;\r\n\r\n\t\tshipTexture.bind();\r\n\t\tlightTexShader.begin();\r\n\t\tlightTexShader.setUniformi(\"u_diffuse\", 0);\r\n\t\ttransform.set(camera.combined);\r\n\t\ttransform.translate(ship.position.x, ship.position.y, ship.position.z);\r\n\t\ttransform.rotate(0, 0, 1, 45 * (-Gdx.input.getAccelerometerY() / 5));\r\n\t\ttransform.rotate(0, 1, 0, 180);\r\n\t\tlightTexShader.setUniformMatrix(\"u_projView\", transform);\r\n\t\tnormal.idt();\r\n\t\tnormal.rotate(0, 1, 0, 180);\r\n\t\tnormal3.set(normal.toNormalMatrix());\r\n\t\tlightTexShader.setUniformMatrix(\"u_normal\", normal3);\r\n\t\tshipMesh.render(lightTexShader);\r\n\t\tlightTexShader.end();\r\n\t}","commit_id":"b25c00a553c7381c728695933fa9127a9e0a4b61","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Test\n  public void testMe() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"package tutorial {\");\n    _builder.newLine();\n    _builder.append(\"import java.util.Date\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"/**\");\n    _builder.newLine();\n    _builder.append(\" \\t \");\n    _builder.append(\"* A simple entity to describe a Person\");\n    _builder.newLine();\n    _builder.append(\" \\t \");\n    _builder.append(\"*/\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"entity Person {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"firstName: String\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"lastName: String\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"birthday: Date\");\n    _builder.newLine();\n    _builder.append(\"  \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    StringConcatenation _builder_1 = new StringConcatenation();\n    _builder_1.append(\"package tutorial;\");\n    _builder_1.newLine();\n    _builder_1.newLine();\n    _builder_1.append(\"import java.util.Date;\");\n    _builder_1.newLine();\n    _builder_1.newLine();\n    _builder_1.append(\"/**\");\n    _builder_1.newLine();\n    _builder_1.append(\" \");\n    _builder_1.append(\"* A simple entity to describe a Person\");\n    _builder_1.newLine();\n    _builder_1.append(\" \");\n    _builder_1.append(\"*/\");\n    _builder_1.newLine();\n    _builder_1.append(\"public class Person {\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private String firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public String getFirstName() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setFirstName(final String firstName) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.firstName = firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private String lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public String getLastName() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setLastName(final String lastName) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.lastName = lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private Date birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public Date getBirthday() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setBirthday(final Date birthday) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.birthday = birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    this._compilationTestHelper.assertCompilesTo(_builder, _builder_1);\n  }","id":101216,"modified_method":"@Test\n  public void testMe() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"package tutorial\");\n      _builder.newLine();\n      _builder.newLine();\n      _builder.append(\"import java.util.Date\");\n      _builder.newLine();\n      _builder.newLine();\n      _builder.append(\"/**\");\n      _builder.newLine();\n      _builder.append(\" \");\n      _builder.append(\"* A simple entity to describe a Person\");\n      _builder.newLine();\n      _builder.append(\" \");\n      _builder.append(\"*/\");\n      _builder.newLine();\n      _builder.append(\"entity Person {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"firstName: String\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"lastName: String\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"birthday: Date\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      StringConcatenation _builder_1 = new StringConcatenation();\n      _builder_1.append(\"package tutorial;\");\n      _builder_1.newLine();\n      _builder_1.newLine();\n      _builder_1.append(\"import java.util.Date;\");\n      _builder_1.newLine();\n      _builder_1.newLine();\n      _builder_1.append(\"/**\");\n      _builder_1.newLine();\n      _builder_1.append(\" \");\n      _builder_1.append(\"* A simple entity to describe a Person\");\n      _builder_1.newLine();\n      _builder_1.append(\" \");\n      _builder_1.append(\"*/\");\n      _builder_1.newLine();\n      _builder_1.append(\"public class Person {\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"private String firstName;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"public String getFirstName() {\");\n      _builder_1.newLine();\n      _builder_1.append(\"    \");\n      _builder_1.append(\"return this.firstName;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"}\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"public void setFirstName(final String firstName) {\");\n      _builder_1.newLine();\n      _builder_1.append(\"    \");\n      _builder_1.append(\"this.firstName = firstName;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"}\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"private String lastName;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"public String getLastName() {\");\n      _builder_1.newLine();\n      _builder_1.append(\"    \");\n      _builder_1.append(\"return this.lastName;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"}\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"public void setLastName(final String lastName) {\");\n      _builder_1.newLine();\n      _builder_1.append(\"    \");\n      _builder_1.append(\"this.lastName = lastName;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"}\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"private Date birthday;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"public Date getBirthday() {\");\n      _builder_1.newLine();\n      _builder_1.append(\"    \");\n      _builder_1.append(\"return this.birthday;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"}\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"public void setBirthday(final Date birthday) {\");\n      _builder_1.newLine();\n      _builder_1.append(\"    \");\n      _builder_1.append(\"this.birthday = birthday;\");\n      _builder_1.newLine();\n      _builder_1.append(\"  \");\n      _builder_1.append(\"}\");\n      _builder_1.newLine();\n      _builder_1.append(\"}\");\n      _builder_1.newLine();\n      this._compilationTestHelper.assertCompilesTo(_builder, _builder_1);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"71a54aa2e5e797122a211d2f227e9cfc96c2241f","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testMe() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"package tutorial {\");\n    _builder.newLine();\n    _builder.append(\"import java.util.Date\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"/**\");\n    _builder.newLine();\n    _builder.append(\" \\t \");\n    _builder.append(\"* A simple entity to describe a Person\");\n    _builder.newLine();\n    _builder.append(\" \\t \");\n    _builder.append(\"*/\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"entity Person {\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"firstName: String\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"lastName: String\");\n    _builder.newLine();\n    _builder.append(\"\\t\\t\");\n    _builder.append(\"birthday: Date\");\n    _builder.newLine();\n    _builder.append(\"  \");\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    StringConcatenation _builder_1 = new StringConcatenation();\n    _builder_1.append(\"package tutorial;\");\n    _builder_1.newLine();\n    _builder_1.newLine();\n    _builder_1.append(\"import java.util.Date;\");\n    _builder_1.newLine();\n    _builder_1.newLine();\n    _builder_1.append(\"/**\");\n    _builder_1.newLine();\n    _builder_1.append(\" \");\n    _builder_1.append(\"* A simple entity to describe a Person\");\n    _builder_1.newLine();\n    _builder_1.append(\" \");\n    _builder_1.append(\"*/\");\n    _builder_1.newLine();\n    _builder_1.append(\"public class Person {\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private String firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public String getFirstName() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setFirstName(final String firstName) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.firstName = firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private String lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public String getLastName() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setLastName(final String lastName) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.lastName = lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private Date birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public Date getBirthday() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setBirthday(final Date birthday) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.birthday = birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    this._compilationTestHelper.assertCompilesTo(_builder, _builder_1);\n  }","id":101217,"modified_method":"@Test\n  public void testMe() {\n    StringConcatenation _builder = new StringConcatenation();\n    _builder.append(\"package tutorial\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"import java.util.Date\");\n    _builder.newLine();\n    _builder.newLine();\n    _builder.append(\"/**\");\n    _builder.newLine();\n    _builder.append(\" \");\n    _builder.append(\"* A simple entity to describe a Person\");\n    _builder.newLine();\n    _builder.append(\" \");\n    _builder.append(\"*/\");\n    _builder.newLine();\n    _builder.append(\"entity Person {\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"firstName: String\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"lastName: String\");\n    _builder.newLine();\n    _builder.append(\"\\t\");\n    _builder.append(\"birthday: Date\");\n    _builder.newLine();\n    _builder.append(\"}\");\n    _builder.newLine();\n    _builder.newLine();\n    StringConcatenation _builder_1 = new StringConcatenation();\n    _builder_1.append(\"package tutorial;\");\n    _builder_1.newLine();\n    _builder_1.newLine();\n    _builder_1.append(\"import java.util.Date;\");\n    _builder_1.newLine();\n    _builder_1.newLine();\n    _builder_1.append(\"/**\");\n    _builder_1.newLine();\n    _builder_1.append(\" \");\n    _builder_1.append(\"* A simple entity to describe a Person\");\n    _builder_1.newLine();\n    _builder_1.append(\" \");\n    _builder_1.append(\"*/\");\n    _builder_1.newLine();\n    _builder_1.append(\"public class Person {\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private String firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public String getFirstName() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setFirstName(final String firstName) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.firstName = firstName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private String lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public String getLastName() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setLastName(final String lastName) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.lastName = lastName;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"private Date birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public Date getBirthday() {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"return this.birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"public void setBirthday(final Date birthday) {\");\n    _builder_1.newLine();\n    _builder_1.append(\"    \");\n    _builder_1.append(\"this.birthday = birthday;\");\n    _builder_1.newLine();\n    _builder_1.append(\"  \");\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    _builder_1.append(\"}\");\n    _builder_1.newLine();\n    this._compilationTestHelper.assertCompilesTo(_builder, _builder_1);\n  }","commit_id":"065def8dd8cbe88d2dc181176416d3f06ab24f07","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void serializeXWikiContext(XWikiContext context, Map<String, Serializable> remoteData)\n    {\n        remoteData.put(CONTEXT_WIKI, context.getDatabase());\n        remoteData.put(CONTEXT_USER, context.getUser());\n    }","id":101218,"modified_method":"/**\n     * @param context the XWiki context to serialize\n     * @return the serialized version of the context\n     */\n    protected Serializable serializeXWikiContext(XWikiContext context)\n    {\n        HashMap<String, Serializable> remoteDataMap = new HashMap<String, Serializable>();\n\n        remoteDataMap.put(CONTEXT_WIKI, context.getDatabase());\n        remoteDataMap.put(CONTEXT_USER, context.getUser());\n\n        return remoteDataMap;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected XWikiDocument unserializeDocument(Map<String, Serializable> remoteData)\n    {\n        DocumentName docName = (DocumentName) remoteData.get(DOC_NAME);\n\n        XWikiDocument doc;\n        if (remoteData.get(DOC_VERSION) == null) {\n            doc = new XWikiDocument(docName.getWiki(), docName.getSpace(), docName.getPage());\n        } else {\n            doc = new LazyXWikiDocument();\n            doc.setDatabase(docName.getWiki());\n            doc.setSpace(docName.getSpace());\n            doc.setName(docName.getPage());\n            doc.setLanguage((String) remoteData.get(DOC_LANGUAGE));\n            doc.setVersion((String) remoteData.get(DOC_VERSION));\n        }\n\n        XWikiDocument origDoc;\n        if (remoteData.get(ORIGDOC_VERSION) == null) {\n            origDoc = new XWikiDocument(docName.getWiki(), docName.getSpace(), docName.getPage());\n        } else {\n            origDoc = new LazyXWikiDocument();\n            origDoc.setDatabase(docName.getWiki());\n            origDoc.setSpace(docName.getSpace());\n            origDoc.setName(docName.getPage());\n            origDoc.setLanguage((String) remoteData.get(ORIGDOC_LANGUAGE));\n            origDoc.setVersion((String) remoteData.get(ORIGDOC_VERSION));\n        }\n\n        doc.setOriginalDocument(origDoc);\n\n        return doc;\n    }","id":101219,"modified_method":"/**\n     * @param remoteData the serialized version of the document\n     * @return the document\n     */\n    protected XWikiDocument unserializeDocument(Serializable remoteData)\n    {\n        Map<String, Serializable> remoteDataMap = (Map<String, Serializable>) remoteData;\n\n        DocumentName docName = (DocumentName) remoteDataMap.get(DOC_NAME);\n\n        XWikiDocument doc;\n        if (remoteDataMap.get(DOC_VERSION) == null) {\n            doc = new XWikiDocument(docName.getWiki(), docName.getSpace(), docName.getPage());\n        } else {\n            doc = new LazyXWikiDocument();\n            doc.setDatabase(docName.getWiki());\n            doc.setSpace(docName.getSpace());\n            doc.setName(docName.getPage());\n            doc.setLanguage((String) remoteDataMap.get(DOC_LANGUAGE));\n            doc.setVersion((String) remoteDataMap.get(DOC_VERSION));\n        }\n\n        XWikiDocument origDoc;\n        if (remoteDataMap.get(ORIGDOC_VERSION) == null) {\n            origDoc = new XWikiDocument(docName.getWiki(), docName.getSpace(), docName.getPage());\n        } else {\n            origDoc = new LazyXWikiDocument();\n            origDoc.setDatabase(docName.getWiki());\n            origDoc.setSpace(docName.getSpace());\n            origDoc.setName(docName.getPage());\n            origDoc.setLanguage((String) remoteDataMap.get(ORIGDOC_LANGUAGE));\n            origDoc.setVersion((String) remoteDataMap.get(ORIGDOC_VERSION));\n        }\n\n        doc.setOriginalDocument(origDoc);\n\n        return doc;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected XWikiContext unserializeXWikiContext(Map<String, Serializable> remoteData)\n    {\n        XWikiContext context = (XWikiContext) this.execution.getContext().getProperty(\"xwikicontext\");\n        context.setDatabase((String) remoteData.get(CONTEXT_WIKI));\n        context.setUser((String) remoteData.get(CONTEXT_USER));\n\n        return context;\n    }","id":101220,"modified_method":"/**\n     * @param remoteData the serialized version of the context\n     * @return the XWiki context\n     */\n    protected XWikiContext unserializeXWikiContext(Serializable remoteData)\n    {\n        Map<String, Serializable> remoteDataMap = (Map<String, Serializable>) remoteData;\n\n        XWikiContext context = (XWikiContext) this.execution.getContext().getProperty(\"xwikicontext\");\n        context.setDatabase((String) remoteDataMap.get(CONTEXT_WIKI));\n        context.setUser((String) remoteDataMap.get(CONTEXT_USER));\n\n        return context;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void serializeXWikiDocument(XWikiDocument document, Map<String, Serializable> remoteData)\n    {\n        remoteData.put(DOC_NAME, new DocumentName(document.getWikiName(), document.getSpaceName(),\n            document.getPageName()));\n\n        if (!document.isNew()) {\n            remoteData.put(DOC_VERSION, document.getVersion());\n            remoteData.put(DOC_LANGUAGE, document.getLanguage());\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        if (!originalDocument.isNew()) {\n            remoteData.put(ORIGDOC_VERSION, originalDocument.getVersion());\n            remoteData.put(ORIGDOC_LANGUAGE, originalDocument.getLanguage());\n        }\n    }","id":101221,"modified_method":"/**\n     * @param document the document to serialize\n     * @return the serialized version of the document\n     */\n    protected Serializable serializeXWikiDocument(XWikiDocument document)\n    {\n        HashMap<String, Serializable> remoteDataMap = new HashMap<String, Serializable>();\n\n        remoteDataMap.put(DOC_NAME, new DocumentName(document.getWikiName(), document.getSpaceName(),\n            document.getPageName()));\n\n        if (!document.isNew()) {\n            remoteDataMap.put(DOC_VERSION, document.getVersion());\n            remoteDataMap.put(DOC_LANGUAGE, document.getLanguage());\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        if (!originalDocument.isNew()) {\n            remoteDataMap.put(ORIGDOC_VERSION, originalDocument.getVersion());\n            remoteDataMap.put(ORIGDOC_LANGUAGE, originalDocument.getLanguage());\n        }\n\n        return remoteDataMap;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (remoteEvent.getEvent() instanceof ActionExecutionEvent) {\n            Map<String, Serializable> remoteData = (Map<String, Serializable>) remoteEvent.getData();\n\n            // set some context information\n            XWikiContext context = unserializeXWikiContext(remoteData);\n\n            // restore document\n            XWikiDocument document = unserializeDocument(remoteData);\n\n            // fill the local event\n            localEvent.setEvent((Event) remoteEvent.getEvent());\n            localEvent.setSource(document);\n            localEvent.setData(context);\n\n            return true;\n        }\n\n        return false;\n    }","id":101222,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (remoteEvent.getEvent() instanceof ActionExecutionEvent) {\n            // fill the local event\n            localEvent.setEvent((Event) remoteEvent.getEvent());\n            localEvent.setSource(unserializeDocument(remoteEvent.getSource()));\n            localEvent.setData(unserializeXWikiContext(remoteEvent.getData()));\n\n            return true;\n        }\n\n        return false;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.LocalEventConverter#toRemote(org.xwiki.observation.remote.LocalEventData,\n     *      org.xwiki.observation.remote.RemoteEventData)\n     */\n    public boolean toRemote(LocalEventData localEvent, RemoteEventData remoteEvent)\n    {\n        if (localEvent.getEvent() instanceof ActionExecutionEvent) {\n            ActionExecutionEvent event = (ActionExecutionEvent) localEvent.getEvent();\n\n            if (this.actions.contains(event.getActionName())) {\n                HashMap<String, Serializable> remoteData = new HashMap<String, Serializable>();\n\n                // serialize document\n                serializeXWikiDocument((XWikiDocument) localEvent.getSource(), remoteData);\n\n                // save some context informations\n                serializeXWikiContext((XWikiContext) localEvent.getData(), remoteData);\n\n                // fill the remote event\n                remoteEvent.setEvent((Serializable) localEvent.getEvent());\n                remoteEvent.setData(remoteData);\n\n                return true;\n            }\n        }\n\n        return false;\n    }","id":101223,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.LocalEventConverter#toRemote(org.xwiki.observation.remote.LocalEventData,\n     *      org.xwiki.observation.remote.RemoteEventData)\n     */\n    public boolean toRemote(LocalEventData localEvent, RemoteEventData remoteEvent)\n    {\n        if (localEvent.getEvent() instanceof ActionExecutionEvent) {\n            ActionExecutionEvent event = (ActionExecutionEvent) localEvent.getEvent();\n\n            if (this.actions.contains(event.getActionName())) {\n                // fill the remote event\n                remoteEvent.setEvent((Serializable) localEvent.getEvent());\n                remoteEvent.setSource(serializeXWikiDocument((XWikiDocument) localEvent.getSource()));\n                remoteEvent.setData(serializeXWikiContext((XWikiContext) localEvent.getData()));\n\n                return true;\n            }\n        }\n\n        return false;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.LocalEventConverter#toRemote(org.xwiki.observation.remote.LocalEventData,\n     *      org.xwiki.observation.remote.RemoteEventData)\n     */\n    public boolean toRemote(LocalEventData localEvent, RemoteEventData remoteEvent)\n    {\n        if (this.events.contains(localEvent.getEvent())) {\n            HashMap<String, Serializable> remoteData = new HashMap<String, Serializable>();\n\n            // serialize document\n            serializeXWikiDocument((XWikiDocument) localEvent.getSource(), remoteData);\n\n            // save some context informations\n            serializeXWikiContext((XWikiContext) localEvent.getData(), remoteData);\n\n            // fill the remote event\n            remoteEvent.setEvent((Serializable) localEvent.getEvent());\n            remoteEvent.setData(remoteData);\n\n            return true;\n        }\n\n        return false;\n    }","id":101224,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.LocalEventConverter#toRemote(org.xwiki.observation.remote.LocalEventData,\n     *      org.xwiki.observation.remote.RemoteEventData)\n     */\n    public boolean toRemote(LocalEventData localEvent, RemoteEventData remoteEvent)\n    {\n        if (this.events.contains(localEvent.getEvent())) {\n            // fill the remote event\n            remoteEvent.setEvent((Serializable) localEvent.getEvent());\n            remoteEvent.setSource(serializeXWikiDocument((XWikiDocument) localEvent.getSource()));\n            remoteEvent.setData(serializeXWikiContext((XWikiContext) localEvent.getData()));\n\n            return true;\n        }\n\n        return false;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (this.events.contains(remoteEvent.getEvent())) {\n            Map<String, Serializable> remoteData = (Map<String, Serializable>) remoteEvent.getData();\n\n            // set some context information\n            XWikiContext context = unserializeXWikiContext(remoteData);\n\n            // restore document\n            XWikiDocument document = unserializeDocument(remoteData);\n\n            // fill the local event\n            localEvent.setEvent((Event) remoteEvent.getEvent());\n            localEvent.setSource(document);\n            localEvent.setData(context);\n\n            return true;\n        }\n\n        return false;\n    }","id":101225,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (this.events.contains(remoteEvent.getEvent())) {\n            // fill the local event\n            localEvent.setEvent((Event) remoteEvent.getEvent());\n            localEvent.setSource(unserializeDocument(remoteEvent.getSource()));\n            localEvent.setData(unserializeXWikiContext(remoteEvent.getData()));\n\n            return true;\n        }\n\n        return false;\n    }","commit_id":"df8166321ab35da9c335819d457b819d8d53b80a","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\t//SimpleDateFormat prt = new SimpleDateFormat(\"dd.MM.yyyy HH:mm\");\n\t\t\t//pref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t//\t\tprt.format(sunriseSunset.getSunset())));\n\t\t\t//new approach for previous 3 lines from Issue 1313\n\t\t\t  DateFormat format = SimpleDateFormat.getDateTimeInstance();\n\t\t\t  String sunrise = format.format(sunriseSunset.getSunrise());\n\t\t\t  String sunset = format.format(sunriseSunset.getSunset());\n\t\t\t  pref.setSummary(activity.getString(R.string.day_night_info_description, sunrise, sunset));\n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t}","id":101226,"modified_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\tSimpleDateFormat prt = new SimpleDateFormat(\"dd.MM.yyyy HH:mm\");\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t\t\tprt.format(sunriseSunset.getSunset())));\n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t}","commit_id":"0f532c1f1f7c5d924e89aad4b4da6605c2ece812","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\t//SimpleDateFormat prt = new SimpleDateFormat(\"dd.MM.yyyy HH:mm\");\n\t\t\t//pref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t//\t\tprt.format(sunriseSunset.getSunset())));\n\t\t\t//new approach for previous 3 lines from Issue 1313\n\t\t\t  DateFormat format = SimpleDateFormat.getDateTimeInstance();\n\t\t\t  String sunrise = format.format(sunriseSunset.getSunrise());\n\t\t\t  String sunset = format.format(sunriseSunset.getSunset());\n\t\t\t  pref.setSummary(activity.getString(R.string.day_night_info_description, sunrise, sunset)); \n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t}","id":101227,"modified_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\tSimpleDateFormat prt = new SimpleDateFormat(\"yyyy-MM-dd  HH:mm\");\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t\t\tprt.format(sunriseSunset.getSunset())));\n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\t\t\n\t}","commit_id":"f2c16a179448bfa053a982ba8bbcd19dbc0de2ad","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\tSimpleDateFormat prt = new SimpleDateFormat(\"dd.MM.yyyy HH:mm\");\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t\t\tprt.format(sunriseSunset.getSunset())));\n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t}","id":101228,"modified_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\t//SimpleDateFormat prt = new SimpleDateFormat(\"dd.MM.yyyy HH:mm\");\n\t\t\t//pref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t//\t\tprt.format(sunriseSunset.getSunset())));\n\t\t\t//new approach for previous 3 lines from Issue 1313\n\t\t\t  DateFormat format = SimpleDateFormat.getDateTimeInstance();\n\t\t\t  String sunrise = format.format(sunriseSunset.getSunrise());\n\t\t\t  String sunset = format.format(sunriseSunset.getSunset());\n\t\t\t  pref.setSummary(activity.getString(R.string.day_night_info_description, sunrise, sunset)); \n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t}","commit_id":"b5cebe9a6bf2976a1d95d86aeb507324b94cf735","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tSunriseSunset\n*******************************************************************************\n*\n*\tConstructor for SunriseSunset class.\n* \n*----------------------------------------------------------------------------*/\n\tpublic SunriseSunset( \n\t\t\t\t  double dfLatIn,\t\t\t\t// latitude \n\t\t\t\t  double dfLonIn,\t\t\t\t// longitude \n\t\t\t\t  Date\t dateInputIn,\t\t\t// date\n\t\t\t\t  TimeZone tzIn\t\t\t        // time zone\n\t\t\t\t  )\n\t{\n\t\t// Calculate internal representation of timezone offset as fraction of hours from GMT\n\t\t// Our calculations consider offsets to the West as positive, so we must invert\n\t\t// the signal of the values provided by the standard library\n\t\tdouble dfTimeZoneIn = 1.0 * tzIn.getOffset(dateInputIn.getTime()) / 3600000;\n\n\t\t// Copy values supplied as agruments to local variables.\n\t\tdfLat \t\t= dfLatIn;\n\t\tdfLon \t\t= dfLonIn;\n\t\tdateInput \t= dateInputIn;\n\t\tdfTimeZone \t= dfTimeZoneIn;\n\t\torigTimeZone= dfTimeZoneIn;\n\n\t\t// Call the method to do the calculations.\n\t\tdoCalculations();\n\n\t}","id":101229,"modified_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tSunriseSunset\n*******************************************************************************\n*\n*\tConstructor for SunriseSunset class.\n* \n*----------------------------------------------------------------------------*/\n\tpublic SunriseSunset( \n\t\t\t\t  double dfLatIn,\t\t\t\t// latitude \n\t\t\t\t  double dfLonIn,\t\t\t\t// longitude \n\t\t\t\t  Date\t dateInputIn,\t\t\t// date\n\t\t\t\t  TimeZone tzIn\t\t\t        // time zone\n\t\t\t\t  )\n\t{\n\t\t// Calculate internal representation of timezone offset as fraction of hours from GMT\n\t\t// Our calculations consider offsets to the West as positive, so we must invert\n\t\t// the signal of the values provided by the standard library\n\t\tdouble dfTimeZoneIn = 1.0 * tzIn.getOffset(dateInputIn.getTime()) / 3600000;\n\n\t\t// Copy values supplied as agruments to local variables.\n\t\tdfLat \t\t= dfLatIn;\n\t\tdfLon \t\t= dfLonIn;\n\t\tdateInput \t= dateInputIn;\n\t\tdfTimeZone \t= dfTimeZoneIn;\n\n\t\t// Call the method to do the calculations.\n\t\tdoCalculations();\n\n\t}","commit_id":"b5cebe9a6bf2976a1d95d86aeb507324b94cf735","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tdoCalculations\n*******************************************************************************\n*\n*\tMethod for performing the calculations done in SUNUP.BAS.\n* \n*----------------------------------------------------------------------------*/\n\tprivate void doCalculations()\n\t{\n\t\ttry\n\t\t{\n\t\t\t// Break out day, month, and year from date provided.\n\t\t\t// (This is necesary for the math algorithms.)\n\n\t\t\tdfmtYear  = new SimpleDateFormat( \"yyyy\" );\n\t\t\tdfmtYear.setLenient( false );\n\t\t\tdfmtYear.setTimeZone( tz );\n\n\t\t\tdfmtMonth = new SimpleDateFormat( \"M\" );\n\t\t\tdfmtMonth.setLenient( false );\n\t\t\tdfmtMonth.setTimeZone( tz );\n\n\t\t\tdfmtDay   = new SimpleDateFormat( \"d\" );\n\t\t\tdfmtDay.setLenient( false );\n\t\t\tdfmtDay.setTimeZone( tz );\n\t\t\t\n\t\t\tiYear  = Integer.parseInt(  dfmtYear.format( dateInput ) );\n\t\t\tiMonth = Integer.parseInt( dfmtMonth.format( dateInput ) );\n\t\t\tiDay   = Integer.parseInt(   dfmtDay.format( dateInput ) );\n\t\t\t\t\t\n\t\t\t// Convert time zone hours to decimal days (SUNUP.BAS line 50)\n\t\t\tdfTimeZone = dfTimeZone / 24.0;\n\n\t\t\t// NOTE: (7 Feb 2001) Here is a non-standard part of SUNUP.BAS:\n\t\t\t// It (and this algorithm) assumes that the time zone is \n\t\t\t// positive west, instead of the standard negative west.\n\t\t\t// Classes calling SunriseSunset will be assuming that \n\t\t\t// times zones are specified in negative west, so here the \n\t\t\t// sign is changed so that the SUNUP algorithm works:\n\t\t\tdfTimeZone = -dfTimeZone;\n\n\t\t\t// Convert longitude to fraction (SUNUP.BAS line 50)\n\t\t\tdfLon = dfLon / 360.0;\n\n\t\t\t// Convert calendar date to Julian date:\n\t\t\t// Check to see if it's later than 1583: Gregorian calendar\n\t\t\t// When declared, bGregorian is initialized to false.\n\t\t\t// ** Consider making a separate class of this function. **\n\t\t\tif( iYear >= 1583 ) bGregorian = true;\n\t\t\t// SUNUP.BAS 1210\n\t\t\tdfJ = -Math.floor( 7.0\t\t// SUNUP used INT, not floor\n\t\t\t\t\t\t\t * ( Math.floor( \n\t\t\t\t\t\t\t\t\t\t    ( iMonth + 9.0 )\n\t\t\t\t\t\t\t\t\t\t    / 12.0\n\t\t\t\t\t\t\t\t\t\t   ) + iYear\n\t\t\t\t\t\t\t    ) / 4.0\n\t\t\t\t\t\t\t )\n\t\t\t\t// add SUNUP.BAS 1240 and 1250 for G = 0\n\t\t\t\t+ Math.floor( iMonth * 275.0 / 9.0 )\n\t\t\t\t+ iDay\n\t\t\t\t+ 1721027.0\n\t\t\t\t+ iYear * 367.0;\n\t\t\t\t\n\t\t\tif ( bGregorian )\n\t\t\t{\n\t\t\t\t// SUNUP.BAS 1230\n\t\t\t\tif ( ( iMonth - 9.0 ) < 0.0 ) iSign = -1;\n\t\t\t\telse iSign = 1;\n\t\t\t\tdfA = Math.abs( iMonth - 9.0 );\n\t\t\t\t// SUNUP.BAS 1240 and 1250\n\t\t\t\tdfJ3 = -Math.floor(\n\t\t\t\t\t\t\t\t  (\n\t\t\t\t\t\t Math.floor(\n\t\t\t\t\t \t  Math.floor( iYear \n\t\t\t\t\t\t\t\t\t + (double)iSign \n\t\t\t\t\t\t\t\t\t   * Math.floor( dfA / 7.0 )\n\t\t\t\t\t\t\t\t    )\n\t\t\t\t\t\t\t\t    / 100.0\n\t\t\t\t\t\t\t\t   ) + 1.0\n\t\t\t\t\t\t\t\t  ) * 0.75\n\t\t\t\t\t\t\t\t );\n\t\t\t\t// correct dfJ as in SUNUP.BAS 1240 and 1250 for G = 1\n\t\t\t\tdfJ = dfJ + dfJ3 + 2.0;\n\t\t\t}\n\t\t\t// SUNUP.BAS 1290\n\t\t\tiJulian = (int)dfJ - 1;\n\t\t\t\n\t\t\t// SUNUP.BAS 60 and 70 (see also line 1290)\n\t\t\tdfT = (double)iJulian - 2451545.0 + 0.5;\n\t\t\tdfTT = dfT / 36525.0 + 1.0;\t\t\t\t// centuries since 1900\n\t\n\t\t\t// Calculate local sidereal time at 0h in zone time\n\t\t\t// SUNUP.BAS 410 through 460\n\t\t\tdfT0 = ( dfT * 8640184.813 / 36525.0\n\t\t\t\t\t+ 24110.5\n\t\t\t\t\t+ dfTimeZone * 86636.6\n\t\t\t\t\t+ dfLon * 86400.0\n\t\t\t\t  )\n\t\t\t\t  / 86400.0;\n\t\t\tdfT0 = dfT0 - Math.floor( dfT0 );\t// NOTE: SUNUP.BAS uses INT()\n\t\t\tdfT0 = dfT0 * 2.0 * Math.PI;\n\t\t\t// SUNUP.BAS 90\n\t\t\tdfT = dfT + dfTimeZone;\n\n\t\t\t// SUNUP.BAS 110: Get Sun's position\n\t\t\tfor( iCount=0; iCount<=1; iCount++ )\t// Loop thru only twice\n\t\t\t{\n\t\t\t\t// Calculate Sun's right ascension and declination\n\t\t\t\t//   at the start and end of each day.\n\t\t\t\t// SUNUP.BAS 910 - 1160: Fundamental arguments\n\t\t\t\t//   from van Flandern and Pulkkinen, 1979\n\t\t\t\t\n\t\t\t\t// declare local temporary doubles for calculations\n\t\t\t\tdouble\tdfGG;\t\t\t\t\t\t// SUNUP.BAS G\n\t\t\t\tdouble\tdfLL;\t\t\t\t\t\t// SUNUP.BAS L\n\t\t\t\tdouble\tdfSS;\t\t\t\t\t\t// SUNUP.BAS S\n\t\t\t\tdouble\tdfUU;\t\t\t\t\t\t// SUNUP.BAS U\n\t\t\t\tdouble\tdfVV;\t\t\t\t\t\t// SUNUP.BAS V\n\t\t\t\tdouble\tdfWW;\t\t\t\t\t\t// SUNUP.BAS W\n\t\n\t\t\t\tdfLL = 0.779072 + 0.00273790931 * dfT;\n\t\t\t\tdfLL = dfLL - Math.floor( dfLL );\n\t\t\t\tdfLL = dfLL * 2.0 * Math.PI;\n\t\n\t\t\t\tdfGG = 0.993126 + 0.0027377785 * dfT;\n\t\t\t\tdfGG = dfGG - Math.floor( dfGG );\n\t\t\t\tdfGG = dfGG * 2.0 * Math.PI;\n\t\n\t\t\t\tdfVV =   0.39785 * Math.sin( dfLL )\n\t\t\t\t\t\t- 0.01000 * Math.sin( dfLL - dfGG )\n\t\t\t\t\t\t+ 0.00333 * Math.sin( dfLL + dfGG )\n\t\t\t\t\t\t- 0.00021 * Math.sin( dfLL ) * dfTT;\n\t\t\t\t\t\t\n\t\t\t\tdfUU = 1\n\t\t\t\t\t    - 0.03349 * Math.cos( dfGG )\n\t\t\t\t\t\t- 0.00014 * Math.cos( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.00008 * Math.cos( dfLL );\n\t\t\n\t\t\t\tdfWW = - 0.00010\n\t\t\t\t\t\t- 0.04129 * Math.sin( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.03211 * Math.sin( dfGG )\n\t\t\t\t\t\t- 0.00104 * Math.sin( 2.0 * dfLL - dfGG )\n\t\t\t\t\t\t- 0.00035 * Math.sin( 2.0 * dfLL + dfGG )\n\t\t\t\t\t\t- 0.00008 * Math.sin( dfGG ) * dfTT;\n\t\t\t\t\t\t\n\t\t\t\t// Compute Sun's RA and Dec; SUNUP.BAS 1120 - 1140\n\t\t\t\tdfSS = dfWW / Math.sqrt( dfUU - dfVV * dfVV );\n\t\t\t\tdfA5 = dfLL \n\t\t\t\t\t   + Math.atan( dfSS / Math.sqrt( 1.0 - dfSS * dfSS ));\n\t\t\t\t\t\n\t\t\t\tdfSS = dfVV / Math.sqrt( dfUU );\n\t\t\t\tdfD5 = Math.atan( dfSS / Math.sqrt( 1 - dfSS * dfSS ));\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t// Set values and increment t\n\t\t\t\tif ( iCount == 0 )\t\t// SUNUP.BAS 125\n\t\t\t\t{\n\t\t\t\t\tdfAA1 = dfA5;\n\t\t\t\t\tdfDD1 = dfD5;\n\t\t\t\t}\n\t\t\t\telse\t\t\t\t\t// SUNUP.BAS 145\n\t\t\t\t{\n\t\t\t\t\tdfAA2 = dfA5;\n\t\t\t\t\tdfDD2 = dfD5;\n\t\t\t\t}\n\t\t\t\tdfT = dfT + 1.0;\t\t// SUNUP.BAS 130\n\t\t\t}\t// end of Get Sun's Position for loop\n\t\t\t\t\n\t\t\tif ( dfAA2 < dfAA1 ) dfAA2 = dfAA2 + 2.0 * Math.PI;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// SUNUP.BAS 150\n\t\n\t\t\tdfZenith = Math.PI * 90.833 / 180.0;\t\t\t// SUNUP.BAS 160\n\t\t\tdfSinLat = Math.sin( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\t\tdfCosLat = Math.cos( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\t\t\t\n\t\t\tdfA0 = dfAA1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfD0 = dfDD1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfDA = dfAA2 - dfAA1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\t\tdfDD = dfDD2 - dfDD1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\t\t\t\n\t\t\tdfK1 = 15.0 * 1.0027379 * Math.PI / 180.0;\t\t// SUNUP.BAS 330\n\t\n\t\t\t// Initialize sunrise and sunset times, and other variables\n\t\t\t// hr and min are set to impossible times to make errors obvious\n\t\t\tdfHourRise = 99.0;\n\t\t\tdfMinRise  = 99.0;\n\t\t\tdfHourSet  = 99.0;\n\t\t\tdfMinSet   = 99.0;\n\t\t\tdfV0 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\t\tdfV2 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\t\t\t\n\t\t\t// Test each hour to see if the Sun crosses the horizon\n\t\t\t//   and which way it is heading.\n\t\t\tfor( iCount=0; iCount<24; iCount++ )\t\t\t// SUNUP.BAS 210\n\t\t\t{\n\t\t\t\tdouble\ttempA;\t\t\t\t\t\t\t\t// SUNUP.BAS A\n\t\t\t\tdouble\ttempB;\t\t\t\t\t\t\t\t// SUNUP.BAS B\n\t\t\t\tdouble\ttempD;\t\t\t\t\t\t\t\t// SUNUP.BAS D\n\t\t\t\tdouble\ttempE;\t\t\t\t\t\t\t\t// SUNUP.BAS E\n\t\t\t\t\t\n\t\t\t\tdfC0 = (double)iCount;\n\t\t\t\tdfP = ( dfC0 + 1.0 ) / 24.0;\t\t\t\t// SUNUP.BAS 220\n\t\t\t\tdfA2 = dfAA1 + dfP * dfDA;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfD2 = dfDD1 + dfP * dfDD;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfL0 = dfT0 + dfC0 * dfK1;\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfL2 = dfL0 + dfK1;\t\t\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfH0 = dfL0 - dfA0;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\tdfH2 = dfL2 - dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\t// hour angle at half hour\n\t\t\t\tdfH1 = ( dfH2 + dfH0 ) / 2.0;\t\t\t\t// SUNUP.BAS 520\n\t\t\t\t// declination at half hour\n\t\t\t\tdfD1 = ( dfD2 + dfD0 ) / 2.0;\t\t\t\t// SUNUP.BAS 530\n\t\t\t\t\t\n\t\t\t\t// Set value of dfV0 only if this is the first hour, \n\t\t\t\t// otherwise, it will get set to the last dfV2 (SUNUP.BAS 250)\n\t\t\t\tif ( iCount == 0 )\t\t\t\t\t\t\t// SUNUP.BAS 550\n\t\t\t\t{\t\n\t\t\t\t\tdfV0 = dfSinLat * Math.sin( dfD0 )\n\t\t\t\t\t\t + dfCosLat * Math.cos( dfD0 ) * Math.cos( dfH0 )\n\t\t\t\t\t\t - Math.cos( dfZenith );\t\t\t// SUNUP.BAS 560\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdfV0 = dfV2;\t// That is, dfV2 from the previous hour.\n\t\t\t\t\n\t\t\t\tdfV2 = dfSinLat * Math.sin( dfD2 )\n\t\t\t\t\t\t + dfCosLat * Math.cos( dfD2 ) * Math.cos( dfH2 )\n\t\t\t\t\t\t - Math.cos( dfZenith );\t\t\t// SUNUP.BAS 570\n\t\t\t\t\t\n\t\t\t\t// if dfV0 and dfV2 have the same sign, then proceed to next hr\n\t\t\t\tif ( \n\t\t\t\t\t ( dfV0 >= 0.0 && dfV2 >= 0.0 )\t\t// both are positive\n\t\t\t\t\t ||\t\t\t\t\t\t\t\t// or\n\t\t\t\t\t ( dfV0 < 0.0 && dfV2 < 0.0 ) \t\t// both are negative\n\t\t\t\t   )\n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdfV1 = dfSinLat * Math.sin( dfD1 )\n\t\t\t\t\t + dfCosLat * Math.cos( dfD1 ) * Math.cos( dfH1 )\n\t\t\t\t\t - Math.cos( dfZenith );\t\t\t\t// SUNUP.BAS 590\n\t\n\t\t\t\ttempA = 2.0 * dfV2 - 4.0 * dfV1 + 2.0 * dfV0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// SUNUP.BAS 600\n\t\t\t\ttempB = 4.0 * dfV1 - 3.0 * dfV0 - dfV2;\t\t// SUNUP.BAS 600\n\t\t\t\ttempD = tempB * tempB - 4.0 * tempA * dfV0;\t// SUNUP.BAS 610\n\t\t\t\t\t\n\t\t\t\tif ( tempD < 0.0 ) \n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\ttempD = Math.sqrt( tempD );\t\t\t\t\t// SUNUP.BAS 620\n\t\n\t\t\t\t// Determine occurence of sunrise or sunset.\n\t\t\t\t\t\n\t\t\t\t// Flags to identify occurrence during this day are \n\t\t\t\t// bSunriseToday and bSunsetToday, and are initialized false.\n\t\t\t\t// These are set true only if sunrise or sunset occurs \n\t\t\t\t// at any point in the hourly loop. Never set to false.\n\t\n\t\t\t\t// Flags to identify occurrence during this hour:\n\t\t\t\tbSunrise = false;\t\t\t\t// reset before test\n\t\t\t\tbSunset  = false;\t\t\t\t// reset before test\n\t\t\t\t\t\n\t\t\t\tif ( dfV0 < 0.0 && dfV2 > 0.0 )\t// sunrise occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunrise = true;\t\t\t// SUNUP.BAS 640\n\t\t\t\t\tbSunriseToday = true;\t\t// sunrise occurred today\n\t\t\t\t}\n\t\n\t\t\t\tif ( dfV0 > 0.0 && dfV2 < 0.0 )\t// sunset occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunset = true;\t\t\t\t// SUNUP.BAS 660\n\t\t\t\t\tbSunsetToday = true;\t\t// sunset occurred today\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\ttempE = ( tempD - tempB ) / ( 2.0 * tempA );\n\t\t\t\tif ( tempE > 1.0 || tempE < 0.0 )\t// SUNUP.BAS 670, 680\n\t\t\t\t\ttempE = ( -tempD - tempB ) / ( 2.0 * tempA );\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t// Set values of hour and minute of sunset or sunrise\n\t\t\t\t// only if sunrise/set occurred this hour.\n\t\t\t\tif ( bSunrise )\n\t\t\t\t{\n\t\t\t\t\tdfHourRise = Math.floor( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinRise  = Math.floor( \n\t\t\t\t\t\t\t\t\t\t\t ( dfC0 + tempE + 1.0/120.0 \n\t\t\t\t\t\t\t\t\t\t\t    - dfHourRise \n\t\t\t\t\t\t\t\t\t\t\t )\n\t\t\t\t\t\t\t\t\t\t\t * 60.0\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tif ( bSunset )\n\t\t\t\t{\n\t\t\t\t\tdfHourSet  = Math.floor( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinSet   = Math.floor( \n\t\t\t\t\t\t\t\t\t\t\t ( dfC0 + tempE + 1.0/120.0\n\t\t\t\t\t\t\t\t\t\t\t    - dfHourSet \n\t\t\t\t\t\t\t\t\t\t\t ) \n\t\t\t\t\t\t\t\t\t\t\t * 60.0\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// Change settings of variables for next loop\n\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\t\n\t\t\t}\t// end of loop testing each hour for an event\t\n\t\t\t\t\n\t\t\t// After having checked all hours, set flags if no rise or set\n\t\t\t// bSunUpAllDay and bSundownAllDay are initialized as false\n\t\t\tif ( !bSunriseToday && !bSunsetToday )\n\t\t\t{\n\t\t\t\tif ( dfV2 < 0.0 )\n\t\t\t\t\tbSunDownAllDay = true;\n\t\t\t\telse\n\t\t\t\t\tbSunUpAllDay = true;\n\t\t\t}\n\t\n\t\t\t// Load dateSunrise with data\n\t\t\tdfmtDateTime = new SimpleDateFormat( \"d M yyyy HH:mm z\" );\n\n\t\t\t// Timezone signal is reversed in SunriseSunset class\n\t\t\tString tz_signal = origTimeZone <= 0?\"-\":\"+\";\n\t\t\tdouble abs_tz = Math.abs(origTimeZone);\n\t\t\tNumberFormat formatter = new DecimalFormat(\"00\");\n\n\t\t\tString tz_offset_hours = formatter.format((int)abs_tz);\n\t\t\tString tz_offset_minutes = formatter.format((int)(60 * (abs_tz - (int)abs_tz)));\n\n\t\t\tif( bSunriseToday )\n\t\t\t{\n\t\t\t\tdateSunrise = dfmtDateTime.parse( iDay \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iMonth \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iYear \n\t\t\t\t\t\t\t\t\t\t+ \" \" + (int)dfHourRise\n\t\t\t\t\t\t\t\t\t\t+ \":\" + (int)dfMinRise \n\t\t\t\t\t\t\t\t\t\t+ \" GMT\"\n\t\t\t\t\t\t\t\t\t    + tz_signal + tz_offset_hours\n\t\t\t\t\t\t\t\t\t\t+\":\" + tz_offset_minutes );\n\t\t\t}\n\t\t\n\t\t\t// Load dateSunset with data\n\t\t\tif( bSunsetToday )\n\t\t\t{\n\t\t\t\tdateSunset = dfmtDateTime.parse( iDay \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iMonth \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iYear \n\t\t\t\t\t\t\t\t\t\t+ \" \" + (int)dfHourSet\n\t\t\t\t\t\t\t\t\t\t+ \":\" + (int)dfMinSet \n\t\t\t\t\t\t\t\t\t\t+ \" GMT\"\n\t\t\t\t\t\t\t\t\t    + tz_signal + tz_offset_hours\n\t\t\t\t\t\t\t\t\t\t+\":\" + tz_offset_minutes );\n\t\t\t}\n\t\t} // end of try\n\n\t\t// Catch errors\n\t\tcatch( ParseException e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t} // end of catch\n\n\t}","id":101230,"modified_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tdoCalculations\n*******************************************************************************\n*\n*\tMethod for performing the calculations done in SUNUP.BAS.\n* \n*----------------------------------------------------------------------------*/\n\tprivate void doCalculations()\n\t{\n\t\t\t// Break out day, month, and year from date provided using local time zone.\n\t\t\t// (This is necessary for the math algorithms.)\n\t\t\tCalendar cin = Calendar.getInstance();\n\t\t\tcin.setTime(dateInput);\n\t\n\t\t\tiYear  = cin.get(Calendar.YEAR); \n\t\t\tiMonth = cin.get(Calendar.MONTH) + 1; \n\t\t\tiDay   = cin.get(Calendar.DAY_OF_MONTH); \n\t\n\t\t\t// Convert time zone hours to decimal days (SUNUP.BAS line 50)\n\t\t\tdfTimeZone = dfTimeZone / 24.0;\n\t\n\t\t\t// NOTE: (7 Feb 2001) Here is a non-standard part of SUNUP.BAS:\n\t\t\t// It (and this algorithm) assumes that the time zone is \n\t\t\t// positive west, instead of the standard negative west.\n\t\t\t// Classes calling SunriseSunset will be assuming that \n\t\t\t// times zones are specified in negative west, so here the \n\t\t\t// sign is changed so that the SUNUP algorithm works:\n\t\t\tdfTimeZone = -dfTimeZone;\n\t\n\t\t\t// Convert longitude to fraction (SUNUP.BAS line 50)\n\t\t\tdfLon = dfLon / 360.0;\n\t\n\t\t\t// Convert calendar date to Julian date:\n\t\t\t// Check to see if it's later than 1583: Gregorian calendar\n\t\t\t// When declared, bGregorian is initialized to false.\n\t\t\t// ** Consider making a separate class of this function. **\n\t\t\tif( iYear >= 1583 ) bGregorian = true;\n\t\t\t// SUNUP.BAS 1210\n\t\t\tdfJ = -Math.floor( 7.0\t\t// SUNUP used INT, not floor\n\t\t\t\t\t* ( Math.floor( \n\t\t\t\t\t\t\t( iMonth + 9.0 )\n\t\t\t\t\t\t\t/ 12.0\n\t\t\t\t\t\t\t) + iYear\n\t\t\t\t\t\t\t) / 4.0\n\t\t\t\t\t)\n\t\t\t\t\t// add SUNUP.BAS 1240 and 1250 for G = 0\n\t\t\t\t\t+ Math.floor( iMonth * 275.0 / 9.0 )\n\t\t\t\t\t+ iDay\n\t\t\t\t\t+ 1721027.0\n\t\t\t\t\t+ iYear * 367.0;\n\t\n\t\t\tif ( bGregorian )\n\t\t\t{\n\t\t\t\t// SUNUP.BAS 1230\n\t\t\t\tif ( ( iMonth - 9.0 ) < 0.0 ) iSign = -1;\n\t\t\t\telse iSign = 1;\n\t\t\t\tdfA = Math.abs( iMonth - 9.0 );\n\t\t\t\t// SUNUP.BAS 1240 and 1250\n\t\t\t\tdfJ3 = -Math.floor(\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tMath.floor(\n\t\t\t\t\t\t\t\t\t\tMath.floor( iYear \n\t\t\t\t\t\t\t\t\t\t\t\t+ (double)iSign \n\t\t\t\t\t\t\t\t\t\t\t\t* Math.floor( dfA / 7.0 )\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t/ 100.0\n\t\t\t\t\t\t\t\t\t\t) + 1.0\n\t\t\t\t\t\t\t\t) * 0.75\n\t\t\t\t\t\t);\n\t\t\t\t// correct dfJ as in SUNUP.BAS 1240 and 1250 for G = 1\n\t\t\t\tdfJ = dfJ + dfJ3 + 2.0;\n\t\t\t}\n\t\t\t// SUNUP.BAS 1290\n\t\t\tiJulian = (int)dfJ - 1;\n\t\n\t\t\t// SUNUP.BAS 60 and 70 (see also line 1290)\n\t\t\tdfT = (double)iJulian - 2451545.0 + 0.5;\n\t\t\tdfTT = dfT / 36525.0 + 1.0;\t\t\t\t// centuries since 1900\n\t\n\t\t\t// Calculate local sidereal time at 0h in zone time\n\t\t\t// SUNUP.BAS 410 through 460\n\t\t\tdfT0 = ( dfT * 8640184.813 / 36525.0\n\t\t\t\t\t+ 24110.5\n\t\t\t\t\t+ dfTimeZone * 86636.6\n\t\t\t\t\t+ dfLon * 86400.0\n\t\t\t\t\t)\n\t\t\t\t\t/ 86400.0;\n\t\t\tdfT0 = dfT0 - Math.floor( dfT0 );\t// NOTE: SUNUP.BAS uses INT()\n\t\t\tdfT0 = dfT0 * 2.0 * Math.PI;\n\t\t\t// SUNUP.BAS 90\n\t\t\tdfT = dfT + dfTimeZone;\n\t\n\t\t\t// SUNUP.BAS 110: Get Sun's position\n\t\t\tfor( iCount=0; iCount<=1; iCount++ )\t// Loop thru only twice\n\t\t\t{\n\t\t\t\t// Calculate Sun's right ascension and declination\n\t\t\t\t//   at the start and end of each day.\n\t\t\t\t// SUNUP.BAS 910 - 1160: Fundamental arguments\n\t\t\t\t//   from van Flandern and Pulkkinen, 1979\n\t\n\t\t\t\t// declare local temporary doubles for calculations\n\t\t\t\tdouble\tdfGG;\t\t\t\t\t\t// SUNUP.BAS G\n\t\t\t\tdouble\tdfLL;\t\t\t\t\t\t// SUNUP.BAS L\n\t\t\t\tdouble\tdfSS;\t\t\t\t\t\t// SUNUP.BAS S\n\t\t\t\tdouble\tdfUU;\t\t\t\t\t\t// SUNUP.BAS U\n\t\t\t\tdouble\tdfVV;\t\t\t\t\t\t// SUNUP.BAS V\n\t\t\t\tdouble\tdfWW;\t\t\t\t\t\t// SUNUP.BAS W\n\t\n\t\t\t\tdfLL = 0.779072 + 0.00273790931 * dfT;\n\t\t\t\tdfLL = dfLL - Math.floor( dfLL );\n\t\t\t\tdfLL = dfLL * 2.0 * Math.PI;\n\t\n\t\t\t\tdfGG = 0.993126 + 0.0027377785 * dfT;\n\t\t\t\tdfGG = dfGG - Math.floor( dfGG );\n\t\t\t\tdfGG = dfGG * 2.0 * Math.PI;\n\t\n\t\t\t\tdfVV =   0.39785 * Math.sin( dfLL )\n\t\t\t\t\t\t- 0.01000 * Math.sin( dfLL - dfGG )\n\t\t\t\t\t\t+ 0.00333 * Math.sin( dfLL + dfGG )\n\t\t\t\t\t\t- 0.00021 * Math.sin( dfLL ) * dfTT;\n\t\n\t\t\t\tdfUU = 1\n\t\t\t\t\t\t- 0.03349 * Math.cos( dfGG )\n\t\t\t\t\t\t- 0.00014 * Math.cos( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.00008 * Math.cos( dfLL );\n\t\n\t\t\t\tdfWW = - 0.00010\n\t\t\t\t\t\t- 0.04129 * Math.sin( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.03211 * Math.sin( dfGG )\n\t\t\t\t\t\t- 0.00104 * Math.sin( 2.0 * dfLL - dfGG )\n\t\t\t\t\t\t- 0.00035 * Math.sin( 2.0 * dfLL + dfGG )\n\t\t\t\t\t\t- 0.00008 * Math.sin( dfGG ) * dfTT;\n\t\n\t\t\t\t// Compute Sun's RA and Dec; SUNUP.BAS 1120 - 1140\n\t\t\t\tdfSS = dfWW / Math.sqrt( dfUU - dfVV * dfVV );\n\t\t\t\tdfA5 = dfLL \n\t\t\t\t\t\t+ Math.atan( dfSS / Math.sqrt( 1.0 - dfSS * dfSS ));\n\t\n\t\t\t\tdfSS = dfVV / Math.sqrt( dfUU );\n\t\t\t\tdfD5 = Math.atan( dfSS / Math.sqrt( 1 - dfSS * dfSS ));\t\t\t\t\t\n\t\n\t\t\t\t// Set values and increment t\n\t\t\t\tif ( iCount == 0 )\t\t// SUNUP.BAS 125\n\t\t\t\t{\n\t\t\t\t\tdfAA1 = dfA5;\n\t\t\t\t\tdfDD1 = dfD5;\n\t\t\t\t}\n\t\t\t\telse\t\t\t\t\t// SUNUP.BAS 145\n\t\t\t\t{\n\t\t\t\t\tdfAA2 = dfA5;\n\t\t\t\t\tdfDD2 = dfD5;\n\t\t\t\t}\n\t\t\t\tdfT = dfT + 1.0;\t\t// SUNUP.BAS 130\n\t\t\t}\t// end of Get Sun's Position for loop\n\t\n\t\t\tif ( dfAA2 < dfAA1 ) dfAA2 = dfAA2 + 2.0 * Math.PI;\n\t\t\t// SUNUP.BAS 150\n\t\n\t\t\tdfZenith = Math.PI * 90.833 / 180.0;\t\t\t// SUNUP.BAS 160\n\t\t\tdfSinLat = Math.sin( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\t\tdfCosLat = Math.cos( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\n\t\t\tdfA0 = dfAA1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfD0 = dfDD1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfDA = dfAA2 - dfAA1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\t\tdfDD = dfDD2 - dfDD1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\n\t\t\tdfK1 = 15.0 * 1.0027379 * Math.PI / 180.0;\t\t// SUNUP.BAS 330\n\t\n\t\t\t// Initialize sunrise and sunset times, and other variables\n\t\t\t// hr and min are set to impossible times to make errors obvious\n\t\t\tdfHourRise = 99;\n\t\t\tdfMinRise  = 99;\n\t\t\tdfHourSet  = 99;\n\t\t\tdfMinSet   = 99;\n\t\t\tdfV0 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\t\tdfV2 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\n\t\t\t// Test each hour to see if the Sun crosses the horizon\n\t\t\t//   and which way it is heading.\n\t\t\tfor( iCount=0; iCount<24; iCount++ )\t\t\t// SUNUP.BAS 210\n\t\t\t{\n\t\t\t\tdouble\ttempA;\t\t\t\t\t\t\t\t// SUNUP.BAS A\n\t\t\t\tdouble\ttempB;\t\t\t\t\t\t\t\t// SUNUP.BAS B\n\t\t\t\tdouble\ttempD;\t\t\t\t\t\t\t\t// SUNUP.BAS D\n\t\t\t\tdouble\ttempE;\t\t\t\t\t\t\t\t// SUNUP.BAS E\n\t\n\t\t\t\tdfC0 = (double)iCount;\n\t\t\t\tdfP = ( dfC0 + 1.0 ) / 24.0;\t\t\t\t// SUNUP.BAS 220\n\t\t\t\tdfA2 = dfAA1 + dfP * dfDA;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfD2 = dfDD1 + dfP * dfDD;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfL0 = dfT0 + dfC0 * dfK1;\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfL2 = dfL0 + dfK1;\t\t\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfH0 = dfL0 - dfA0;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\tdfH2 = dfL2 - dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\t// hour angle at half hour\n\t\t\t\tdfH1 = ( dfH2 + dfH0 ) / 2.0;\t\t\t\t// SUNUP.BAS 520\n\t\t\t\t// declination at half hour\n\t\t\t\tdfD1 = ( dfD2 + dfD0 ) / 2.0;\t\t\t\t// SUNUP.BAS 530\n\t\n\t\t\t\t// Set value of dfV0 only if this is the first hour, \n\t\t\t\t// otherwise, it will get set to the last dfV2 (SUNUP.BAS 250)\n\t\t\t\tif ( iCount == 0 )\t\t\t\t\t\t\t// SUNUP.BAS 550\n\t\t\t\t{\t\n\t\t\t\t\tdfV0 = dfSinLat * Math.sin( dfD0 )\n\t\t\t\t\t\t\t+ dfCosLat * Math.cos( dfD0 ) * Math.cos( dfH0 )\n\t\t\t\t\t\t\t- Math.cos( dfZenith );\t\t\t// SUNUP.BAS 560\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdfV0 = dfV2;\t// That is, dfV2 from the previous hour.\n\t\n\t\t\t\tdfV2 = dfSinLat * Math.sin( dfD2 )\n\t\t\t\t\t\t+ dfCosLat * Math.cos( dfD2 ) * Math.cos( dfH2 )\n\t\t\t\t\t\t- Math.cos( dfZenith );\t\t\t// SUNUP.BAS 570\n\t\n\t\t\t\t// if dfV0 and dfV2 have the same sign, then proceed to next hr\n\t\t\t\tif ( \n\t\t\t\t\t\t( dfV0 >= 0.0 && dfV2 >= 0.0 )\t\t// both are positive\n\t\t\t\t\t\t||\t\t\t\t\t\t\t\t// or\n\t\t\t\t\t\t( dfV0 < 0.0 && dfV2 < 0.0 ) \t\t// both are negative\n\t\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\n\t\t\t\tdfV1 = dfSinLat * Math.sin( dfD1 )\n\t\t\t\t\t\t+ dfCosLat * Math.cos( dfD1 ) * Math.cos( dfH1 )\n\t\t\t\t\t\t- Math.cos( dfZenith );\t\t\t\t// SUNUP.BAS 590\n\t\n\t\t\t\ttempA = 2.0 * dfV2 - 4.0 * dfV1 + 2.0 * dfV0;\n\t\t\t\t// SUNUP.BAS 600\n\t\t\t\ttempB = 4.0 * dfV1 - 3.0 * dfV0 - dfV2;\t\t// SUNUP.BAS 600\n\t\t\t\ttempD = tempB * tempB - 4.0 * tempA * dfV0;\t// SUNUP.BAS 610\n\t\n\t\t\t\tif ( tempD < 0.0 ) \n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\n\t\t\t\ttempD = Math.sqrt( tempD );\t\t\t\t\t// SUNUP.BAS 620\n\t\n\t\t\t\t// Determine occurence of sunrise or sunset.\n\t\n\t\t\t\t// Flags to identify occurrence during this day are \n\t\t\t\t// bSunriseToday and bSunsetToday, and are initialized false.\n\t\t\t\t// These are set true only if sunrise or sunset occurs \n\t\t\t\t// at any point in the hourly loop. Never set to false.\n\t\n\t\t\t\t// Flags to identify occurrence during this hour:\n\t\t\t\tbSunrise = false;\t\t\t\t// reset before test\n\t\t\t\tbSunset  = false;\t\t\t\t// reset before test\n\t\n\t\t\t\tif ( dfV0 < 0.0 && dfV2 > 0.0 )\t// sunrise occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunrise = true;\t\t\t// SUNUP.BAS 640\n\t\t\t\t\tbSunriseToday = true;\t\t// sunrise occurred today\n\t\t\t\t}\n\t\n\t\t\t\tif ( dfV0 > 0.0 && dfV2 < 0.0 )\t// sunset occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunset = true;\t\t\t\t// SUNUP.BAS 660\n\t\t\t\t\tbSunsetToday = true;\t\t// sunset occurred today\n\t\t\t\t}\n\t\n\t\t\t\ttempE = ( tempD - tempB ) / ( 2.0 * tempA );\n\t\t\t\tif ( tempE > 1.0 || tempE < 0.0 )\t// SUNUP.BAS 670, 680\n\t\t\t\t\ttempE = ( -tempD - tempB ) / ( 2.0 * tempA );\t\t\t\t\t\n\t\n\t\t\t\t// Set values of hour and minute of sunset or sunrise\n\t\t\t\t// only if sunrise/set occurred this hour.\n\t\t\t\tif ( bSunrise )\n\t\t\t\t{\n\t\t\t\t\tdfHourRise = (int)( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinRise  = (int) ( \n\t\t\t\t\t\t\t( dfC0 + tempE + 1.0/120.0 \n\t\t\t\t\t\t\t\t\t- dfHourRise \n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t* 60.0\n\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tif ( bSunset )\n\t\t\t\t{\n\t\t\t\t\tdfHourSet  = (int) ( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinSet   = (int)( \n\t\t\t\t\t\t\t( dfC0 + tempE + 1.0/120.0\n\t\t\t\t\t\t\t\t\t- dfHourSet \n\t\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\t\t* 60.0\n\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// Change settings of variables for next loop\n\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\n\t\t\t}\t// end of loop testing each hour for an event\t\n\t\n\t\t\t// After having checked all hours, set flags if no rise or set\n\t\t\t// bSunUpAllDay and bSundownAllDay are initialized as false\n\t\t\tif ( !bSunriseToday && !bSunsetToday )\n\t\t\t{\n\t\t\t\tif ( dfV2 < 0.0 )\n\t\t\t\t\tbSunDownAllDay = true;\n\t\t\t\telse\n\t\t\t\t\tbSunUpAllDay = true;\n\t\t\t}\n\t\n\t\t\t// Load dateSunrise with data\n\t\n\t\t\tif( bSunriseToday )\n\t\t\t{\n\t\t\t\tCalendar c = Calendar.getInstance();\n\t\t\t\tc.set(Calendar.YEAR, iYear);\n\t\t\t\tc.set(Calendar.MONTH, iMonth-1);\n\t\t\t\tc.set(Calendar.DAY_OF_MONTH, iDay);\n\t\t\t\tc.set(Calendar.HOUR_OF_DAY, dfHourRise);\n\t\t\t\tc.set(Calendar.MINUTE, dfMinRise);\n\t\t\t\tdateSunrise = c.getTime();\n\t\t\t}\n\t\n\t\t\t// Load dateSunset with data\n\t\t\tif( bSunsetToday )\n\t\t\t{\n\t\t\t\tCalendar c = Calendar.getInstance();\n\t\t\t\tc.set(Calendar.YEAR, iYear);\n\t\t\t\tc.set(Calendar.MONTH, iMonth-1);\n\t\t\t\tc.set(Calendar.DAY_OF_MONTH, iDay);\n\t\t\t\tc.set(Calendar.HOUR_OF_DAY, dfHourSet);\n\t\t\t\tc.set(Calendar.MINUTE, dfMinSet);\n\t\t\t\tdateSunset = c.getTime();\n\t\t\t}\n\t}","commit_id":"b5cebe9a6bf2976a1d95d86aeb507324b94cf735","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\tSimpleDateFormat prt = new SimpleDateFormat(\"dd.MM.yyyy HH:mm\");\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t\t\tprt.format(sunriseSunset.getSunset())));\n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t}","id":101231,"modified_method":"@Override\n\tpublic void settingsActivityCreate(final SettingsActivity activity, PreferenceScreen screen) {\n\t\tPreferenceScreen general = (PreferenceScreen) screen.findPreference(SettingsActivity.SCREEN_ID_GENERAL_SETTINGS);\n\t\t\n\t\tPreferenceCategory cat = new PreferenceCategory(app);\n\t\tcat.setTitle(R.string.debugging_and_development);\n\t\tgeneral.addPreference(cat);\n\t\t\n\t\tCheckBoxPreference dbg = activity.createCheckBoxPreference(settings.DEBUG_RENDERING_INFO, \n\t\t\t\tR.string.trace_rendering, R.string.trace_rendering_descr);\n\t\tcat.addPreference(dbg);\n\t\t\n\t\tPreference pref = new Preference(app);\n\t\tpref.setTitle(R.string.test_voice_prompts);\n\t\tpref.setSummary(R.string.play_commands_of_currently_selected_voice);\n\t\tpref.setKey(\"test_voice_commands\");\n\t\tpref.setOnPreferenceClickListener(new OnPreferenceClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onPreferenceClick(Preference preference) {\n\t\t\t\tactivity.startActivity(new Intent(activity, TestVoiceActivity.class));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tcat.addPreference(pref);\n\t\t\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.global_app_allocated_memory);\n\t\t\n\t\tlong javaAvailMem = (Runtime.getRuntime().totalMemory() -  Runtime.getRuntime().freeMemory())/ (1024*1024l);\n\t\tlong javaTotal = Runtime.getRuntime().totalMemory() / (1024*1024l);\n\t\tlong dalvikSize = android.os.Debug.getNativeHeapAllocatedSize() / (1024*1024l);\n\t\tpref.setSummary(activity.getString(R.string.global_app_allocated_memory_descr, javaAvailMem, javaTotal, dalvikSize));\n\t\tcat.addPreference(pref);\n\t\t\n//\t\tActivityManager activityManager = (ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);\n//\t\tActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();\n//\t\tactivityManager.getMemoryInfo(memoryInfo);\n//\t\tlong totalSize = memoryInfo.availMem / (1024*1024l);\n\t\tMemoryInfo mem = new Debug.MemoryInfo();\n\t\tDebug.getMemoryInfo(mem);\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.native_app_allocated_memory);\n\t\tpref.setSummary(activity.getString(R.string.native_app_allocated_memory_descr \n\t\t\t\t, mem.nativePrivateDirty / 1024, mem.dalvikPrivateDirty / 1024 , mem.otherPrivateDirty / 1024\n\t\t\t\t, mem.nativePss / 1024, mem.dalvikPss / 1024 , mem.otherPss / 1024));\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t\tSunriseSunset sunriseSunset = app.getDaynightHelper().getSunriseSunset();\n\t\tpref = new Preference(app);\n\t\tpref.setTitle(R.string.day_night_info);\n\t\tif (sunriseSunset != null) {\n\t\t\t//SimpleDateFormat prt = new SimpleDateFormat(\"dd.MM.yyyy HH:mm\");\n\t\t\t//pref.setSummary(activity.getString(R.string.day_night_info_description, prt.format(sunriseSunset.getSunrise()),\n\t\t\t//\t\tprt.format(sunriseSunset.getSunset())));\n\t\t\t//new approach for previous 3 lines from Issue 1313\n\t\t\t  DateFormat format = SimpleDateFormat.getDateTimeInstance();\n\t\t\t  String sunrise = format.format(sunriseSunset.getSunrise());\n\t\t\t  String sunset = format.format(sunriseSunset.getSunset());\n\t\t\t  pref.setSummary(activity.getString(R.string.day_night_info_description, sunrise, sunset));\n\t\t} else {\n\t\t\tpref.setSummary(activity.getString(R.string.day_night_info_description, \"null\",\n\t\t\t\t\t\"null\"));\n\t\t}\n\t\tcat.addPreference(pref);\n\t\t\n\t\t\n\t}","commit_id":"199e879c9be4b0c84850859d0cc7bebcb4d390d3","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tdoCalculations\n*******************************************************************************\n*\n*\tMethod for performing the calculations done in SUNUP.BAS.\n* \n*----------------------------------------------------------------------------*/\n\tprivate void doCalculations()\n\t{\n\t\ttry\n\t\t{\n\t\t\t// Break out day, month, and year from date provided.\n\t\t\t// (This is necesary for the math algorithms.)\n\n\t\t\tdfmtYear  = new SimpleDateFormat( \"yyyy\" );\n\t\t\tdfmtYear.setLenient( false );\n\t\t\tdfmtYear.setTimeZone( tz );\n\n\t\t\tdfmtMonth = new SimpleDateFormat( \"M\" );\n\t\t\tdfmtMonth.setLenient( false );\n\t\t\tdfmtMonth.setTimeZone( tz );\n\n\t\t\tdfmtDay   = new SimpleDateFormat( \"d\" );\n\t\t\tdfmtDay.setLenient( false );\n\t\t\tdfmtDay.setTimeZone( tz );\n\t\t\t\n\t\t\tiYear  = Integer.parseInt(  dfmtYear.format( dateInput ) );\n\t\t\tiMonth = Integer.parseInt( dfmtMonth.format( dateInput ) );\n\t\t\tiDay   = Integer.parseInt(   dfmtDay.format( dateInput ) );\n\t\t\t\t\t\n\t\t\t// Convert time zone hours to decimal days (SUNUP.BAS line 50)\n\t\t\tdfTimeZone = dfTimeZone / 24.0;\n\n\t\t\t// NOTE: (7 Feb 2001) Here is a non-standard part of SUNUP.BAS:\n\t\t\t// It (and this algorithm) assumes that the time zone is \n\t\t\t// positive west, instead of the standard negative west.\n\t\t\t// Classes calling SunriseSunset will be assuming that \n\t\t\t// times zones are specified in negative west, so here the \n\t\t\t// sign is changed so that the SUNUP algorithm works:\n\t\t\tdfTimeZone = -dfTimeZone;\n\n\t\t\t// Convert longitude to fraction (SUNUP.BAS line 50)\n\t\t\tdfLon = dfLon / 360.0;\n\n\t\t\t// Convert calendar date to Julian date:\n\t\t\t// Check to see if it's later than 1583: Gregorian calendar\n\t\t\t// When declared, bGregorian is initialized to false.\n\t\t\t// ** Consider making a separate class of this function. **\n\t\t\tif( iYear >= 1583 ) bGregorian = true;\n\t\t\t// SUNUP.BAS 1210\n\t\t\tdfJ = -Math.floor( 7.0\t\t// SUNUP used INT, not floor\n\t\t\t\t\t\t\t * ( Math.floor( \n\t\t\t\t\t\t\t\t\t\t    ( iMonth + 9.0 )\n\t\t\t\t\t\t\t\t\t\t    / 12.0\n\t\t\t\t\t\t\t\t\t\t   ) + iYear\n\t\t\t\t\t\t\t    ) / 4.0\n\t\t\t\t\t\t\t )\n\t\t\t\t// add SUNUP.BAS 1240 and 1250 for G = 0\n\t\t\t\t+ Math.floor( iMonth * 275.0 / 9.0 )\n\t\t\t\t+ iDay\n\t\t\t\t+ 1721027.0\n\t\t\t\t+ iYear * 367.0;\n\t\t\t\t\n\t\t\tif ( bGregorian )\n\t\t\t{\n\t\t\t\t// SUNUP.BAS 1230\n\t\t\t\tif ( ( iMonth - 9.0 ) < 0.0 ) iSign = -1;\n\t\t\t\telse iSign = 1;\n\t\t\t\tdfA = Math.abs( iMonth - 9.0 );\n\t\t\t\t// SUNUP.BAS 1240 and 1250\n\t\t\t\tdfJ3 = -Math.floor(\n\t\t\t\t\t\t\t\t  (\n\t\t\t\t\t\t Math.floor(\n\t\t\t\t\t \t  Math.floor( iYear \n\t\t\t\t\t\t\t\t\t + (double)iSign \n\t\t\t\t\t\t\t\t\t   * Math.floor( dfA / 7.0 )\n\t\t\t\t\t\t\t\t    )\n\t\t\t\t\t\t\t\t    / 100.0\n\t\t\t\t\t\t\t\t   ) + 1.0\n\t\t\t\t\t\t\t\t  ) * 0.75\n\t\t\t\t\t\t\t\t );\n\t\t\t\t// correct dfJ as in SUNUP.BAS 1240 and 1250 for G = 1\n\t\t\t\tdfJ = dfJ + dfJ3 + 2.0;\n\t\t\t}\n\t\t\t// SUNUP.BAS 1290\n\t\t\tiJulian = (int)dfJ - 1;\n\t\t\t\n\t\t\t// SUNUP.BAS 60 and 70 (see also line 1290)\n\t\t\tdfT = (double)iJulian - 2451545.0 + 0.5;\n\t\t\tdfTT = dfT / 36525.0 + 1.0;\t\t\t\t// centuries since 1900\n\t\n\t\t\t// Calculate local sidereal time at 0h in zone time\n\t\t\t// SUNUP.BAS 410 through 460\n\t\t\tdfT0 = ( dfT * 8640184.813 / 36525.0\n\t\t\t\t\t+ 24110.5\n\t\t\t\t\t+ dfTimeZone * 86636.6\n\t\t\t\t\t+ dfLon * 86400.0\n\t\t\t\t  )\n\t\t\t\t  / 86400.0;\n\t\t\tdfT0 = dfT0 - Math.floor( dfT0 );\t// NOTE: SUNUP.BAS uses INT()\n\t\t\tdfT0 = dfT0 * 2.0 * Math.PI;\n\t\t\t// SUNUP.BAS 90\n\t\t\tdfT = dfT + dfTimeZone;\n\n\t\t\t// SUNUP.BAS 110: Get Sun's position\n\t\t\tfor( iCount=0; iCount<=1; iCount++ )\t// Loop thru only twice\n\t\t\t{\n\t\t\t\t// Calculate Sun's right ascension and declination\n\t\t\t\t//   at the start and end of each day.\n\t\t\t\t// SUNUP.BAS 910 - 1160: Fundamental arguments\n\t\t\t\t//   from van Flandern and Pulkkinen, 1979\n\t\t\t\t\n\t\t\t\t// declare local temporary doubles for calculations\n\t\t\t\tdouble\tdfGG;\t\t\t\t\t\t// SUNUP.BAS G\n\t\t\t\tdouble\tdfLL;\t\t\t\t\t\t// SUNUP.BAS L\n\t\t\t\tdouble\tdfSS;\t\t\t\t\t\t// SUNUP.BAS S\n\t\t\t\tdouble\tdfUU;\t\t\t\t\t\t// SUNUP.BAS U\n\t\t\t\tdouble\tdfVV;\t\t\t\t\t\t// SUNUP.BAS V\n\t\t\t\tdouble\tdfWW;\t\t\t\t\t\t// SUNUP.BAS W\n\t\n\t\t\t\tdfLL = 0.779072 + 0.00273790931 * dfT;\n\t\t\t\tdfLL = dfLL - Math.floor( dfLL );\n\t\t\t\tdfLL = dfLL * 2.0 * Math.PI;\n\t\n\t\t\t\tdfGG = 0.993126 + 0.0027377785 * dfT;\n\t\t\t\tdfGG = dfGG - Math.floor( dfGG );\n\t\t\t\tdfGG = dfGG * 2.0 * Math.PI;\n\t\n\t\t\t\tdfVV =   0.39785 * Math.sin( dfLL )\n\t\t\t\t\t\t- 0.01000 * Math.sin( dfLL - dfGG )\n\t\t\t\t\t\t+ 0.00333 * Math.sin( dfLL + dfGG )\n\t\t\t\t\t\t- 0.00021 * Math.sin( dfLL ) * dfTT;\n\t\t\t\t\t\t\n\t\t\t\tdfUU = 1\n\t\t\t\t\t    - 0.03349 * Math.cos( dfGG )\n\t\t\t\t\t\t- 0.00014 * Math.cos( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.00008 * Math.cos( dfLL );\n\t\t\n\t\t\t\tdfWW = - 0.00010\n\t\t\t\t\t\t- 0.04129 * Math.sin( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.03211 * Math.sin( dfGG )\n\t\t\t\t\t\t- 0.00104 * Math.sin( 2.0 * dfLL - dfGG )\n\t\t\t\t\t\t- 0.00035 * Math.sin( 2.0 * dfLL + dfGG )\n\t\t\t\t\t\t- 0.00008 * Math.sin( dfGG ) * dfTT;\n\t\t\t\t\t\t\n\t\t\t\t// Compute Sun's RA and Dec; SUNUP.BAS 1120 - 1140\n\t\t\t\tdfSS = dfWW / Math.sqrt( dfUU - dfVV * dfVV );\n\t\t\t\tdfA5 = dfLL \n\t\t\t\t\t   + Math.atan( dfSS / Math.sqrt( 1.0 - dfSS * dfSS ));\n\t\t\t\t\t\n\t\t\t\tdfSS = dfVV / Math.sqrt( dfUU );\n\t\t\t\tdfD5 = Math.atan( dfSS / Math.sqrt( 1 - dfSS * dfSS ));\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t// Set values and increment t\n\t\t\t\tif ( iCount == 0 )\t\t// SUNUP.BAS 125\n\t\t\t\t{\n\t\t\t\t\tdfAA1 = dfA5;\n\t\t\t\t\tdfDD1 = dfD5;\n\t\t\t\t}\n\t\t\t\telse\t\t\t\t\t// SUNUP.BAS 145\n\t\t\t\t{\n\t\t\t\t\tdfAA2 = dfA5;\n\t\t\t\t\tdfDD2 = dfD5;\n\t\t\t\t}\n\t\t\t\tdfT = dfT + 1.0;\t\t// SUNUP.BAS 130\n\t\t\t}\t// end of Get Sun's Position for loop\n\t\t\t\t\n\t\t\tif ( dfAA2 < dfAA1 ) dfAA2 = dfAA2 + 2.0 * Math.PI;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// SUNUP.BAS 150\n\t\n\t\t\tdfZenith = Math.PI * 90.833 / 180.0;\t\t\t// SUNUP.BAS 160\n\t\t\tdfSinLat = Math.sin( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\t\tdfCosLat = Math.cos( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\t\t\t\n\t\t\tdfA0 = dfAA1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfD0 = dfDD1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfDA = dfAA2 - dfAA1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\t\tdfDD = dfDD2 - dfDD1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\t\t\t\n\t\t\tdfK1 = 15.0 * 1.0027379 * Math.PI / 180.0;\t\t// SUNUP.BAS 330\n\t\n\t\t\t// Initialize sunrise and sunset times, and other variables\n\t\t\t// hr and min are set to impossible times to make errors obvious\n\t\t\tdfHourRise = 99.0;\n\t\t\tdfMinRise  = 99.0;\n\t\t\tdfHourSet  = 99.0;\n\t\t\tdfMinSet   = 99.0;\n\t\t\tdfV0 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\t\tdfV2 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\t\t\t\n\t\t\t// Test each hour to see if the Sun crosses the horizon\n\t\t\t//   and which way it is heading.\n\t\t\tfor( iCount=0; iCount<24; iCount++ )\t\t\t// SUNUP.BAS 210\n\t\t\t{\n\t\t\t\tdouble\ttempA;\t\t\t\t\t\t\t\t// SUNUP.BAS A\n\t\t\t\tdouble\ttempB;\t\t\t\t\t\t\t\t// SUNUP.BAS B\n\t\t\t\tdouble\ttempD;\t\t\t\t\t\t\t\t// SUNUP.BAS D\n\t\t\t\tdouble\ttempE;\t\t\t\t\t\t\t\t// SUNUP.BAS E\n\t\t\t\t\t\n\t\t\t\tdfC0 = (double)iCount;\n\t\t\t\tdfP = ( dfC0 + 1.0 ) / 24.0;\t\t\t\t// SUNUP.BAS 220\n\t\t\t\tdfA2 = dfAA1 + dfP * dfDA;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfD2 = dfDD1 + dfP * dfDD;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfL0 = dfT0 + dfC0 * dfK1;\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfL2 = dfL0 + dfK1;\t\t\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfH0 = dfL0 - dfA0;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\tdfH2 = dfL2 - dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\t// hour angle at half hour\n\t\t\t\tdfH1 = ( dfH2 + dfH0 ) / 2.0;\t\t\t\t// SUNUP.BAS 520\n\t\t\t\t// declination at half hour\n\t\t\t\tdfD1 = ( dfD2 + dfD0 ) / 2.0;\t\t\t\t// SUNUP.BAS 530\n\t\t\t\t\t\n\t\t\t\t// Set value of dfV0 only if this is the first hour, \n\t\t\t\t// otherwise, it will get set to the last dfV2 (SUNUP.BAS 250)\n\t\t\t\tif ( iCount == 0 )\t\t\t\t\t\t\t// SUNUP.BAS 550\n\t\t\t\t{\t\n\t\t\t\t\tdfV0 = dfSinLat * Math.sin( dfD0 )\n\t\t\t\t\t\t + dfCosLat * Math.cos( dfD0 ) * Math.cos( dfH0 )\n\t\t\t\t\t\t - Math.cos( dfZenith );\t\t\t// SUNUP.BAS 560\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdfV0 = dfV2;\t// That is, dfV2 from the previous hour.\n\t\t\t\t\n\t\t\t\tdfV2 = dfSinLat * Math.sin( dfD2 )\n\t\t\t\t\t\t + dfCosLat * Math.cos( dfD2 ) * Math.cos( dfH2 )\n\t\t\t\t\t\t - Math.cos( dfZenith );\t\t\t// SUNUP.BAS 570\n\t\t\t\t\t\n\t\t\t\t// if dfV0 and dfV2 have the same sign, then proceed to next hr\n\t\t\t\tif ( \n\t\t\t\t\t ( dfV0 >= 0.0 && dfV2 >= 0.0 )\t\t// both are positive\n\t\t\t\t\t ||\t\t\t\t\t\t\t\t// or\n\t\t\t\t\t ( dfV0 < 0.0 && dfV2 < 0.0 ) \t\t// both are negative\n\t\t\t\t   )\n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdfV1 = dfSinLat * Math.sin( dfD1 )\n\t\t\t\t\t + dfCosLat * Math.cos( dfD1 ) * Math.cos( dfH1 )\n\t\t\t\t\t - Math.cos( dfZenith );\t\t\t\t// SUNUP.BAS 590\n\t\n\t\t\t\ttempA = 2.0 * dfV2 - 4.0 * dfV1 + 2.0 * dfV0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// SUNUP.BAS 600\n\t\t\t\ttempB = 4.0 * dfV1 - 3.0 * dfV0 - dfV2;\t\t// SUNUP.BAS 600\n\t\t\t\ttempD = tempB * tempB - 4.0 * tempA * dfV0;\t// SUNUP.BAS 610\n\t\t\t\t\t\n\t\t\t\tif ( tempD < 0.0 ) \n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\ttempD = Math.sqrt( tempD );\t\t\t\t\t// SUNUP.BAS 620\n\t\n\t\t\t\t// Determine occurence of sunrise or sunset.\n\t\t\t\t\t\n\t\t\t\t// Flags to identify occurrence during this day are \n\t\t\t\t// bSunriseToday and bSunsetToday, and are initialized false.\n\t\t\t\t// These are set true only if sunrise or sunset occurs \n\t\t\t\t// at any point in the hourly loop. Never set to false.\n\t\n\t\t\t\t// Flags to identify occurrence during this hour:\n\t\t\t\tbSunrise = false;\t\t\t\t// reset before test\n\t\t\t\tbSunset  = false;\t\t\t\t// reset before test\n\t\t\t\t\t\n\t\t\t\tif ( dfV0 < 0.0 && dfV2 > 0.0 )\t// sunrise occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunrise = true;\t\t\t// SUNUP.BAS 640\n\t\t\t\t\tbSunriseToday = true;\t\t// sunrise occurred today\n\t\t\t\t}\n\t\n\t\t\t\tif ( dfV0 > 0.0 && dfV2 < 0.0 )\t// sunset occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunset = true;\t\t\t\t// SUNUP.BAS 660\n\t\t\t\t\tbSunsetToday = true;\t\t// sunset occurred today\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\ttempE = ( tempD - tempB ) / ( 2.0 * tempA );\n\t\t\t\tif ( tempE > 1.0 || tempE < 0.0 )\t// SUNUP.BAS 670, 680\n\t\t\t\t\ttempE = ( -tempD - tempB ) / ( 2.0 * tempA );\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t// Set values of hour and minute of sunset or sunrise\n\t\t\t\t// only if sunrise/set occurred this hour.\n\t\t\t\tif ( bSunrise )\n\t\t\t\t{\n\t\t\t\t\tdfHourRise = Math.floor( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinRise  = Math.floor( \n\t\t\t\t\t\t\t\t\t\t\t ( dfC0 + tempE + 1.0/120.0 \n\t\t\t\t\t\t\t\t\t\t\t    - dfHourRise \n\t\t\t\t\t\t\t\t\t\t\t )\n\t\t\t\t\t\t\t\t\t\t\t * 60.0\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tif ( bSunset )\n\t\t\t\t{\n\t\t\t\t\tdfHourSet  = Math.floor( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinSet   = Math.floor( \n\t\t\t\t\t\t\t\t\t\t\t ( dfC0 + tempE + 1.0/120.0\n\t\t\t\t\t\t\t\t\t\t\t    - dfHourSet \n\t\t\t\t\t\t\t\t\t\t\t ) \n\t\t\t\t\t\t\t\t\t\t\t * 60.0\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// Change settings of variables for next loop\n\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\t\n\t\t\t}\t// end of loop testing each hour for an event\t\n\t\t\t\t\n\t\t\t// After having checked all hours, set flags if no rise or set\n\t\t\t// bSunUpAllDay and bSundownAllDay are initialized as false\n\t\t\tif ( !bSunriseToday && !bSunsetToday )\n\t\t\t{\n\t\t\t\tif ( dfV2 < 0.0 )\n\t\t\t\t\tbSunDownAllDay = true;\n\t\t\t\telse\n\t\t\t\t\tbSunUpAllDay = true;\n\t\t\t}\n\t\n\t\t\t// Load dateSunrise with data\n\t\t\tdfmtDateTime = new SimpleDateFormat( \"d M yyyy HH:mm z\" );\n\n\t\t\t// Timezone signal is reversed in SunriseSunset class\n\t\t\tString tz_signal = origTimeZone <= 0?\"-\":\"+\";\n\t\t\tdouble abs_tz = Math.abs(origTimeZone);\n\t\t\tNumberFormat formatter = new DecimalFormat(\"00\");\n\n\t\t\tString tz_offset_hours = formatter.format((int)abs_tz);\n\t\t\tString tz_offset_minutes = formatter.format((int)(60 * (abs_tz - (int)abs_tz)));\n\n\t\t\tif( bSunriseToday )\n\t\t\t{\n\t\t\t\tdateSunrise = dfmtDateTime.parse( iDay \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iMonth \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iYear \n\t\t\t\t\t\t\t\t\t\t+ \" \" + (int)dfHourRise\n\t\t\t\t\t\t\t\t\t\t+ \":\" + (int)dfMinRise \n\t\t\t\t\t\t\t\t\t\t+ \" GMT\"\n\t\t\t\t\t\t\t\t\t    + tz_signal + tz_offset_hours\n\t\t\t\t\t\t\t\t\t\t+\":\" + tz_offset_minutes );\n\t\t\t}\n\t\t\n\t\t\t// Load dateSunset with data\n\t\t\tif( bSunsetToday )\n\t\t\t{\n\t\t\t\tdateSunset = dfmtDateTime.parse( iDay \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iMonth \n\t\t\t\t\t\t\t\t\t\t+ \" \" + iYear \n\t\t\t\t\t\t\t\t\t\t+ \" \" + (int)dfHourSet\n\t\t\t\t\t\t\t\t\t\t+ \":\" + (int)dfMinSet \n\t\t\t\t\t\t\t\t\t\t+ \" GMT\"\n\t\t\t\t\t\t\t\t\t    + tz_signal + tz_offset_hours\n\t\t\t\t\t\t\t\t\t\t+\":\" + tz_offset_minutes );\n\t\t\t}\n\t\t} // end of try\n\n\t\t// Catch errors\n\t\tcatch( ParseException e )\n\t\t{\n\t\t\te.printStackTrace();\n\t\t} // end of catch\n\n\t}","id":101232,"modified_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tdoCalculations\n*******************************************************************************\n*\n*\tMethod for performing the calculations done in SUNUP.BAS.\n* \n*----------------------------------------------------------------------------*/\n\tprivate void doCalculations()\n\t{\n\t\t\t// Break out day, month, and year from date provided using local time zone.\n\t\t\t// (This is necessary for the math algorithms.)\n\t\t\tCalendar cin = Calendar.getInstance();\n\t\t\tcin.setTime(dateInput);\n\t\n\t\t\tiYear  = cin.get(Calendar.YEAR); \n\t\t\tiMonth = cin.get(Calendar.MONTH) + 1; \n\t\t\tiDay   = cin.get(Calendar.DAY_OF_MONTH); \n\t\n\t\t\t// Convert time zone hours to decimal days (SUNUP.BAS line 50)\n\t\t\tdfTimeZone = dfTimeZone / 24.0;\n\t\n\t\t\t// NOTE: (7 Feb 2001) Here is a non-standard part of SUNUP.BAS:\n\t\t\t// It (and this algorithm) assumes that the time zone is \n\t\t\t// positive west, instead of the standard negative west.\n\t\t\t// Classes calling SunriseSunset will be assuming that \n\t\t\t// times zones are specified in negative west, so here the \n\t\t\t// sign is changed so that the SUNUP algorithm works:\n\t\t\tdfTimeZone = -dfTimeZone;\n\t\n\t\t\t// Convert longitude to fraction (SUNUP.BAS line 50)\n\t\t\tdfLon = dfLon / 360.0;\n\t\n\t\t\t// Convert calendar date to Julian date:\n\t\t\t// Check to see if it's later than 1583: Gregorian calendar\n\t\t\t// When declared, bGregorian is initialized to false.\n\t\t\t// ** Consider making a separate class of this function. **\n\t\t\tif( iYear >= 1583 ) bGregorian = true;\n\t\t\t// SUNUP.BAS 1210\n\t\t\tdfJ = -Math.floor( 7.0\t\t// SUNUP used INT, not floor\n\t\t\t\t\t* ( Math.floor( \n\t\t\t\t\t\t\t( iMonth + 9.0 )\n\t\t\t\t\t\t\t/ 12.0\n\t\t\t\t\t\t\t) + iYear\n\t\t\t\t\t\t\t) / 4.0\n\t\t\t\t\t)\n\t\t\t\t\t// add SUNUP.BAS 1240 and 1250 for G = 0\n\t\t\t\t\t+ Math.floor( iMonth * 275.0 / 9.0 )\n\t\t\t\t\t+ iDay\n\t\t\t\t\t+ 1721027.0\n\t\t\t\t\t+ iYear * 367.0;\n\t\n\t\t\tif ( bGregorian )\n\t\t\t{\n\t\t\t\t// SUNUP.BAS 1230\n\t\t\t\tif ( ( iMonth - 9.0 ) < 0.0 ) iSign = -1;\n\t\t\t\telse iSign = 1;\n\t\t\t\tdfA = Math.abs( iMonth - 9.0 );\n\t\t\t\t// SUNUP.BAS 1240 and 1250\n\t\t\t\tdfJ3 = -Math.floor(\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tMath.floor(\n\t\t\t\t\t\t\t\t\t\tMath.floor( iYear \n\t\t\t\t\t\t\t\t\t\t\t\t+ (double)iSign \n\t\t\t\t\t\t\t\t\t\t\t\t* Math.floor( dfA / 7.0 )\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t/ 100.0\n\t\t\t\t\t\t\t\t\t\t) + 1.0\n\t\t\t\t\t\t\t\t) * 0.75\n\t\t\t\t\t\t);\n\t\t\t\t// correct dfJ as in SUNUP.BAS 1240 and 1250 for G = 1\n\t\t\t\tdfJ = dfJ + dfJ3 + 2.0;\n\t\t\t}\n\t\t\t// SUNUP.BAS 1290\n\t\t\tiJulian = (int)dfJ - 1;\n\t\n\t\t\t// SUNUP.BAS 60 and 70 (see also line 1290)\n\t\t\tdfT = (double)iJulian - 2451545.0 + 0.5;\n\t\t\tdfTT = dfT / 36525.0 + 1.0;\t\t\t\t// centuries since 1900\n\t\n\t\t\t// Calculate local sidereal time at 0h in zone time\n\t\t\t// SUNUP.BAS 410 through 460\n\t\t\tdfT0 = ( dfT * 8640184.813 / 36525.0\n\t\t\t\t\t+ 24110.5\n\t\t\t\t\t+ dfTimeZone * 86636.6\n\t\t\t\t\t+ dfLon * 86400.0\n\t\t\t\t\t)\n\t\t\t\t\t/ 86400.0;\n\t\t\tdfT0 = dfT0 - Math.floor( dfT0 );\t// NOTE: SUNUP.BAS uses INT()\n\t\t\tdfT0 = dfT0 * 2.0 * Math.PI;\n\t\t\t// SUNUP.BAS 90\n\t\t\tdfT = dfT + dfTimeZone;\n\t\n\t\t\t// SUNUP.BAS 110: Get Sun's position\n\t\t\tfor( iCount=0; iCount<=1; iCount++ )\t// Loop thru only twice\n\t\t\t{\n\t\t\t\t// Calculate Sun's right ascension and declination\n\t\t\t\t//   at the start and end of each day.\n\t\t\t\t// SUNUP.BAS 910 - 1160: Fundamental arguments\n\t\t\t\t//   from van Flandern and Pulkkinen, 1979\n\t\n\t\t\t\t// declare local temporary doubles for calculations\n\t\t\t\tdouble\tdfGG;\t\t\t\t\t\t// SUNUP.BAS G\n\t\t\t\tdouble\tdfLL;\t\t\t\t\t\t// SUNUP.BAS L\n\t\t\t\tdouble\tdfSS;\t\t\t\t\t\t// SUNUP.BAS S\n\t\t\t\tdouble\tdfUU;\t\t\t\t\t\t// SUNUP.BAS U\n\t\t\t\tdouble\tdfVV;\t\t\t\t\t\t// SUNUP.BAS V\n\t\t\t\tdouble\tdfWW;\t\t\t\t\t\t// SUNUP.BAS W\n\t\n\t\t\t\tdfLL = 0.779072 + 0.00273790931 * dfT;\n\t\t\t\tdfLL = dfLL - Math.floor( dfLL );\n\t\t\t\tdfLL = dfLL * 2.0 * Math.PI;\n\t\n\t\t\t\tdfGG = 0.993126 + 0.0027377785 * dfT;\n\t\t\t\tdfGG = dfGG - Math.floor( dfGG );\n\t\t\t\tdfGG = dfGG * 2.0 * Math.PI;\n\t\n\t\t\t\tdfVV =   0.39785 * Math.sin( dfLL )\n\t\t\t\t\t\t- 0.01000 * Math.sin( dfLL - dfGG )\n\t\t\t\t\t\t+ 0.00333 * Math.sin( dfLL + dfGG )\n\t\t\t\t\t\t- 0.00021 * Math.sin( dfLL ) * dfTT;\n\t\n\t\t\t\tdfUU = 1\n\t\t\t\t\t\t- 0.03349 * Math.cos( dfGG )\n\t\t\t\t\t\t- 0.00014 * Math.cos( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.00008 * Math.cos( dfLL );\n\t\n\t\t\t\tdfWW = - 0.00010\n\t\t\t\t\t\t- 0.04129 * Math.sin( dfLL * 2.0 )\n\t\t\t\t\t\t+ 0.03211 * Math.sin( dfGG )\n\t\t\t\t\t\t- 0.00104 * Math.sin( 2.0 * dfLL - dfGG )\n\t\t\t\t\t\t- 0.00035 * Math.sin( 2.0 * dfLL + dfGG )\n\t\t\t\t\t\t- 0.00008 * Math.sin( dfGG ) * dfTT;\n\t\n\t\t\t\t// Compute Sun's RA and Dec; SUNUP.BAS 1120 - 1140\n\t\t\t\tdfSS = dfWW / Math.sqrt( dfUU - dfVV * dfVV );\n\t\t\t\tdfA5 = dfLL \n\t\t\t\t\t\t+ Math.atan( dfSS / Math.sqrt( 1.0 - dfSS * dfSS ));\n\t\n\t\t\t\tdfSS = dfVV / Math.sqrt( dfUU );\n\t\t\t\tdfD5 = Math.atan( dfSS / Math.sqrt( 1 - dfSS * dfSS ));\t\t\t\t\t\n\t\n\t\t\t\t// Set values and increment t\n\t\t\t\tif ( iCount == 0 )\t\t// SUNUP.BAS 125\n\t\t\t\t{\n\t\t\t\t\tdfAA1 = dfA5;\n\t\t\t\t\tdfDD1 = dfD5;\n\t\t\t\t}\n\t\t\t\telse\t\t\t\t\t// SUNUP.BAS 145\n\t\t\t\t{\n\t\t\t\t\tdfAA2 = dfA5;\n\t\t\t\t\tdfDD2 = dfD5;\n\t\t\t\t}\n\t\t\t\tdfT = dfT + 1.0;\t\t// SUNUP.BAS 130\n\t\t\t}\t// end of Get Sun's Position for loop\n\t\n\t\t\tif ( dfAA2 < dfAA1 ) dfAA2 = dfAA2 + 2.0 * Math.PI;\n\t\t\t// SUNUP.BAS 150\n\t\n\t\t\tdfZenith = Math.PI * 90.833 / 180.0;\t\t\t// SUNUP.BAS 160\n\t\t\tdfSinLat = Math.sin( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\t\tdfCosLat = Math.cos( dfLat * Math.PI / 180.0 );\t// SUNUP.BAS 170\n\t\n\t\t\tdfA0 = dfAA1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfD0 = dfDD1;\t\t\t\t\t\t\t\t\t// SUNUP.BAS 190\n\t\t\tdfDA = dfAA2 - dfAA1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\t\tdfDD = dfDD2 - dfDD1;\t\t\t\t\t\t\t// SUNUP.BAS 200\n\t\n\t\t\tdfK1 = 15.0 * 1.0027379 * Math.PI / 180.0;\t\t// SUNUP.BAS 330\n\t\n\t\t\t// Initialize sunrise and sunset times, and other variables\n\t\t\t// hr and min are set to impossible times to make errors obvious\n\t\t\tdfHourRise = 99;\n\t\t\tdfMinRise  = 99;\n\t\t\tdfHourSet  = 99;\n\t\t\tdfMinSet   = 99;\n\t\t\tdfV0 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\t\tdfV2 = 0.0;\t\t// initialization implied by absence in SUNUP.BAS\n\t\n\t\t\t// Test each hour to see if the Sun crosses the horizon\n\t\t\t//   and which way it is heading.\n\t\t\tfor( iCount=0; iCount<24; iCount++ )\t\t\t// SUNUP.BAS 210\n\t\t\t{\n\t\t\t\tdouble\ttempA;\t\t\t\t\t\t\t\t// SUNUP.BAS A\n\t\t\t\tdouble\ttempB;\t\t\t\t\t\t\t\t// SUNUP.BAS B\n\t\t\t\tdouble\ttempD;\t\t\t\t\t\t\t\t// SUNUP.BAS D\n\t\t\t\tdouble\ttempE;\t\t\t\t\t\t\t\t// SUNUP.BAS E\n\t\n\t\t\t\tdfC0 = (double)iCount;\n\t\t\t\tdfP = ( dfC0 + 1.0 ) / 24.0;\t\t\t\t// SUNUP.BAS 220\n\t\t\t\tdfA2 = dfAA1 + dfP * dfDA;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfD2 = dfDD1 + dfP * dfDD;\t\t\t\t\t// SUNUP.BAS 230\n\t\t\t\tdfL0 = dfT0 + dfC0 * dfK1;\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfL2 = dfL0 + dfK1;\t\t\t\t\t\t\t// SUNUP.BAS 500\n\t\t\t\tdfH0 = dfL0 - dfA0;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\tdfH2 = dfL2 - dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 510\n\t\t\t\t// hour angle at half hour\n\t\t\t\tdfH1 = ( dfH2 + dfH0 ) / 2.0;\t\t\t\t// SUNUP.BAS 520\n\t\t\t\t// declination at half hour\n\t\t\t\tdfD1 = ( dfD2 + dfD0 ) / 2.0;\t\t\t\t// SUNUP.BAS 530\n\t\n\t\t\t\t// Set value of dfV0 only if this is the first hour, \n\t\t\t\t// otherwise, it will get set to the last dfV2 (SUNUP.BAS 250)\n\t\t\t\tif ( iCount == 0 )\t\t\t\t\t\t\t// SUNUP.BAS 550\n\t\t\t\t{\t\n\t\t\t\t\tdfV0 = dfSinLat * Math.sin( dfD0 )\n\t\t\t\t\t\t\t+ dfCosLat * Math.cos( dfD0 ) * Math.cos( dfH0 )\n\t\t\t\t\t\t\t- Math.cos( dfZenith );\t\t\t// SUNUP.BAS 560\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdfV0 = dfV2;\t// That is, dfV2 from the previous hour.\n\t\n\t\t\t\tdfV2 = dfSinLat * Math.sin( dfD2 )\n\t\t\t\t\t\t+ dfCosLat * Math.cos( dfD2 ) * Math.cos( dfH2 )\n\t\t\t\t\t\t- Math.cos( dfZenith );\t\t\t// SUNUP.BAS 570\n\t\n\t\t\t\t// if dfV0 and dfV2 have the same sign, then proceed to next hr\n\t\t\t\tif ( \n\t\t\t\t\t\t( dfV0 >= 0.0 && dfV2 >= 0.0 )\t\t// both are positive\n\t\t\t\t\t\t||\t\t\t\t\t\t\t\t// or\n\t\t\t\t\t\t( dfV0 < 0.0 && dfV2 < 0.0 ) \t\t// both are negative\n\t\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\n\t\t\t\tdfV1 = dfSinLat * Math.sin( dfD1 )\n\t\t\t\t\t\t+ dfCosLat * Math.cos( dfD1 ) * Math.cos( dfH1 )\n\t\t\t\t\t\t- Math.cos( dfZenith );\t\t\t\t// SUNUP.BAS 590\n\t\n\t\t\t\ttempA = 2.0 * dfV2 - 4.0 * dfV1 + 2.0 * dfV0;\n\t\t\t\t// SUNUP.BAS 600\n\t\t\t\ttempB = 4.0 * dfV1 - 3.0 * dfV0 - dfV2;\t\t// SUNUP.BAS 600\n\t\t\t\ttempD = tempB * tempB - 4.0 * tempA * dfV0;\t// SUNUP.BAS 610\n\t\n\t\t\t\tif ( tempD < 0.0 ) \n\t\t\t\t{\n\t\t\t\t\t// Break iteration and proceed to test next hour\n\t\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// SUNUP.BAS 610\n\t\t\t\t}\n\t\n\t\t\t\ttempD = Math.sqrt( tempD );\t\t\t\t\t// SUNUP.BAS 620\n\t\n\t\t\t\t// Determine occurence of sunrise or sunset.\n\t\n\t\t\t\t// Flags to identify occurrence during this day are \n\t\t\t\t// bSunriseToday and bSunsetToday, and are initialized false.\n\t\t\t\t// These are set true only if sunrise or sunset occurs \n\t\t\t\t// at any point in the hourly loop. Never set to false.\n\t\n\t\t\t\t// Flags to identify occurrence during this hour:\n\t\t\t\tbSunrise = false;\t\t\t\t// reset before test\n\t\t\t\tbSunset  = false;\t\t\t\t// reset before test\n\t\n\t\t\t\tif ( dfV0 < 0.0 && dfV2 > 0.0 )\t// sunrise occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunrise = true;\t\t\t// SUNUP.BAS 640\n\t\t\t\t\tbSunriseToday = true;\t\t// sunrise occurred today\n\t\t\t\t}\n\t\n\t\t\t\tif ( dfV0 > 0.0 && dfV2 < 0.0 )\t// sunset occurs this hour\n\t\t\t\t{\n\t\t\t\t\tbSunset = true;\t\t\t\t// SUNUP.BAS 660\n\t\t\t\t\tbSunsetToday = true;\t\t// sunset occurred today\n\t\t\t\t}\n\t\n\t\t\t\ttempE = ( tempD - tempB ) / ( 2.0 * tempA );\n\t\t\t\tif ( tempE > 1.0 || tempE < 0.0 )\t// SUNUP.BAS 670, 680\n\t\t\t\t\ttempE = ( -tempD - tempB ) / ( 2.0 * tempA );\t\t\t\t\t\n\t\n\t\t\t\t// Set values of hour and minute of sunset or sunrise\n\t\t\t\t// only if sunrise/set occurred this hour.\n\t\t\t\tif ( bSunrise )\n\t\t\t\t{\n\t\t\t\t\tdfHourRise = (int)( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinRise  = (int) ( \n\t\t\t\t\t\t\t( dfC0 + tempE + 1.0/120.0 \n\t\t\t\t\t\t\t\t\t- dfHourRise \n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t* 60.0\n\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tif ( bSunset )\n\t\t\t\t{\n\t\t\t\t\tdfHourSet  = (int) ( dfC0 + tempE + 1.0/120.0 );\n\t\t\t\t\tdfMinSet   = (int)( \n\t\t\t\t\t\t\t( dfC0 + tempE + 1.0/120.0\n\t\t\t\t\t\t\t\t\t- dfHourSet \n\t\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\t\t* 60.0\n\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// Change settings of variables for next loop\n\t\t\t\tdfA0 = dfA2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\t\t\tdfD0 = dfD2;\t\t\t\t\t\t\t\t// SUNUP.BAS 250\n\t\n\t\t\t}\t// end of loop testing each hour for an event\t\n\t\n\t\t\t// After having checked all hours, set flags if no rise or set\n\t\t\t// bSunUpAllDay and bSundownAllDay are initialized as false\n\t\t\tif ( !bSunriseToday && !bSunsetToday )\n\t\t\t{\n\t\t\t\tif ( dfV2 < 0.0 )\n\t\t\t\t\tbSunDownAllDay = true;\n\t\t\t\telse\n\t\t\t\t\tbSunUpAllDay = true;\n\t\t\t}\n\t\n\t\t\t// Load dateSunrise with data\n\t\n\t\t\tif( bSunriseToday )\n\t\t\t{\n\t\t\t\tCalendar c = Calendar.getInstance();\n\t\t\t\tc.set(Calendar.YEAR, iYear);\n\t\t\t\tc.set(Calendar.MONTH, iMonth-1);\n\t\t\t\tc.set(Calendar.DAY_OF_MONTH, iDay);\n\t\t\t\tc.set(Calendar.HOUR_OF_DAY, dfHourRise);\n\t\t\t\tc.set(Calendar.MINUTE, dfMinRise);\n\t\t\t\tdateSunrise = c.getTime();\n\t\t\t}\n\t\n\t\t\t// Load dateSunset with data\n\t\t\tif( bSunsetToday )\n\t\t\t{\n\t\t\t\tCalendar c = Calendar.getInstance();\n\t\t\t\tc.set(Calendar.YEAR, iYear);\n\t\t\t\tc.set(Calendar.MONTH, iMonth-1);\n\t\t\t\tc.set(Calendar.DAY_OF_MONTH, iDay);\n\t\t\t\tc.set(Calendar.HOUR_OF_DAY, dfHourSet);\n\t\t\t\tc.set(Calendar.MINUTE, dfMinSet);\n\t\t\t\tdateSunset = c.getTime();\n\t\t\t}\n\t}","commit_id":"199e879c9be4b0c84850859d0cc7bebcb4d390d3","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tSunriseSunset\n*******************************************************************************\n*\n*\tConstructor for SunriseSunset class.\n* \n*----------------------------------------------------------------------------*/\n\tpublic SunriseSunset( \n\t\t\t\t  double dfLatIn,\t\t\t\t// latitude \n\t\t\t\t  double dfLonIn,\t\t\t\t// longitude \n\t\t\t\t  Date\t dateInputIn,\t\t\t// date\n\t\t\t\t  TimeZone tzIn\t\t\t        // time zone\n\t\t\t\t  )\n\t{\n\t\t// Calculate internal representation of timezone offset as fraction of hours from GMT\n\t\t// Our calculations consider offsets to the West as positive, so we must invert\n\t\t// the signal of the values provided by the standard library\n\t\tdouble dfTimeZoneIn = 1.0 * tzIn.getOffset(dateInputIn.getTime()) / 3600000;\n\n\t\t// Copy values supplied as agruments to local variables.\n\t\tdfLat \t\t= dfLatIn;\n\t\tdfLon \t\t= dfLonIn;\n\t\tdateInput \t= dateInputIn;\n\t\tdfTimeZone \t= dfTimeZoneIn;\n\t\torigTimeZone= dfTimeZoneIn;\n\n\t\t// Call the method to do the calculations.\n\t\tdoCalculations();\n\n\t}","id":101233,"modified_method":"/******************************************************************************\n*\tmethod:\t\t\t\t\tSunriseSunset\n*******************************************************************************\n*\n*\tConstructor for SunriseSunset class.\n* \n*----------------------------------------------------------------------------*/\n\tpublic SunriseSunset( \n\t\t\t\t  double dfLatIn,\t\t\t\t// latitude \n\t\t\t\t  double dfLonIn,\t\t\t\t// longitude \n\t\t\t\t  Date\t dateInputIn,\t\t\t// date\n\t\t\t\t  TimeZone tzIn\t\t\t        // time zone\n\t\t\t\t  )\n\t{\n\t\t// Calculate internal representation of timezone offset as fraction of hours from GMT\n\t\t// Our calculations consider offsets to the West as positive, so we must invert\n\t\t// the signal of the values provided by the standard library\n\t\tdouble dfTimeZoneIn = 1.0 * tzIn.getOffset(dateInputIn.getTime()) / 3600000;\n\n\t\t// Copy values supplied as agruments to local variables.\n\t\tdfLat \t\t= dfLatIn;\n\t\tdfLon \t\t= dfLonIn;\n\t\tdateInput \t= dateInputIn;\n\t\tdfTimeZone \t= dfTimeZoneIn;\n\n\t\t// Call the method to do the calculations.\n\t\tdoCalculations();\n\n\t}","commit_id":"199e879c9be4b0c84850859d0cc7bebcb4d390d3","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            int cardsHand = controller.getHand().size();\r\n            if (cardsHand > 0) {\r\n                Cards cards = controller.getHand().copy();\r\n                for (UUID cardId: cards) {\r\n                    Card card = game.getCard(cardId);\r\n                    if (card != null) {\r\n                        controller.removeFromHand(card, game);\r\n                        card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                    }\r\n                }\r\n                controller.shuffleLibrary(game);\r\n                controller.drawCards(cardsHand, game);\r\n            }\r\n            return true;            \r\n        }\r\n\r\n        return false;\r\n    }","id":101234,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            int cardsHand = controller.getHand().size();\r\n            if (cardsHand > 0) {\r\n                for (Card card: controller.getHand().getCards(game)) {\r\n                    if (card != null) {\r\n                        controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.HAND, true, false);\r\n                    }\r\n                }\r\n                controller.shuffleLibrary(game);\r\n                controller.drawCards(cardsHand, game);\r\n            }\r\n            return true;            \r\n        }\r\n\r\n        return false;\r\n    }","commit_id":"aa8c72cb0c2451625ab22776eba90aea7517dc50","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            for (UUID playerId : controller.getInRange()) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    int cardsHand = player.getHand().size();\r\n                    if (cardsHand > 0){\r\n                        for (Card card: player.getHand().getCards(game)) {\r\n                            player.removeFromHand(card, game);\r\n                            card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                        }\r\n                        game.informPlayers(player.getLogName() + \" shuffles the cards from his or her hand into his or her library\");\r\n                        player.shuffleLibrary(game);\r\n                        player.drawCards(cardsHand, game);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":101235,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Map<UUID, Integer> permanentsCount = new HashMap<>();\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    permanentsCount.put(playerId, player.getHand().size());\r\n                    player.moveCards(player.getHand(), Zone.HAND, Zone.LIBRARY, source, game);\r\n                    player.shuffleLibrary(game);\r\n                }\r\n            }\r\n            for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null && permanentsCount.containsKey(playerId)) {\r\n                    player.drawCards(permanentsCount.get(playerId), game);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"752335f4ab4b64eab595b6313529a18e36c0c628","url":"https://github.com/magefree/mage"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101236,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupAdminRoleByUsers() throws Exception {\n\t\tGroup site = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupOwnerUser(site);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(site);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\tsite.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), site.getGroupId(), role.getRoleId()));\n\t}","id":101237,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupAdminRoleByUsers() throws Exception {\n\t\tGroup site = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupOwnerUser(site);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(site);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\tsite.getGroupId(), role.getRoleId(), _subjectUser, _objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), site.getGroupId(), role.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingGroupOwnerRoleByRoles() throws Exception {\n\t\tGroup group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101238,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingGroupOwnerRoleByRoles() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(_group);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\t_group.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101239,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingGroupAdminRoleByRoles() throws Exception {\n\t\tGroup group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101240,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingGroupAdminRoleByRoles() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(_group);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\t_group.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(\n\t\t\torganization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101241,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(_organization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101242,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(\n\t\t\torganization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101243,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_organization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101244,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101245,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101246,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(\n\t\t\torganization.getGroup());\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101247,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(_organization.getGroup());\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupOwnerRoleByUsers() throws Exception {\n\t\tGroup group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(group);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), group.getGroupId(), role.getRoleId()));\n\t}","id":101248,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupOwnerRoleByUsers() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupOwnerUser(_group);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\t_group.getGroupId(), role.getRoleId(), _subjectUser, _objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _group.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(\n\t\t\torganization.getGroup());\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101249,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_organization.getGroup());\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101250,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(\n\t\t\torganization.getGroup());\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101251,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_organization.getGroup());\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101252,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(\n\t\t\torganization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101253,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_organization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101254,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(\n\t\t\torganization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101255,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingSiteAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(_organization.getGroup());\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101256,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationAdminRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupAdminRoleByRoles() throws Exception {\n\t\tGroup group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(group);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), group.getGroupId(), role.getRoleId()));\n\t}","id":101257,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupAdminRoleByRoles() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupOwnerUser(_group);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\t_group.getGroupId(), role.getRoleId(), _subjectUser, _objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _group.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101258,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101259,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationAdminUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\t\tobjectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101260,"modified_method":"@Test\n\tpublic void testOrganizationAdminRemovingOrganizationAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(),\n\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationAdminUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101261,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationOwnerRoleByRoles()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByRole(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(\n\t\t\torganization.getGroup());\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101262,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingSiteAdminRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization(true);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(_organization.getGroup());\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101263,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tGroup group = _organization.getGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupOwnerRoleByRoles() throws Exception {\n\t\tGroup group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupOwnerUser(group);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(group);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), group.getGroupId(), role.getRoleId()));\n\t}","id":101264,"modified_method":"@Test\n\tpublic void testGroupOwnerRemovingGroupOwnerRoleByRoles() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupOwnerUser(_group);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\tdeleteUserGroupRolesByRole(\n\t\t\t_group.getGroupId(), role.getRoleId(), _subjectUser, _objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _group.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingGroupOwnerRoleByUsers() throws Exception {\n\t\tGroup group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addGroupOwnerUser(group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101265,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingGroupOwnerRoleByUsers() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(_group);\n\t\t_objectUser = UserTestUtil.addGroupOwnerUser(_group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\t_group.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGroupAdminRemovingGroupAdminRoleByUsers() throws Exception {\n\t\tGroup group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\tUser subjectUser = UserTestUtil.addGroupAdminUser(group);\n\t\tUser objectUser = UserTestUtil.addGroupAdminUser(group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\tgroup.getGroupId(), role.getRoleId(), subjectUser, objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tobjectUser.getUserId(), group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","id":101266,"modified_method":"@Test\n\tpublic void testGroupAdminRemovingGroupAdminRoleByUsers() throws Exception {\n\t\t_group = GroupTestUtil.addGroup();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t_subjectUser = UserTestUtil.addGroupAdminUser(_group);\n\t\t_objectUser = UserTestUtil.addGroupAdminUser(_group);\n\n\t\ttry {\n\t\t\tdeleteUserGroupRolesByUser(\n\t\t\t\t_group.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t\t_objectUser);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (PrincipalException pe) {\n\t\t\tAssert.assertTrue(\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t_objectUser.getUserId(), _group.getGroupId(),\n\t\t\t\t\trole.getRoleId()));\n\t\t}\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\tOrganization organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\tUser subjectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\t\tUser objectUser = UserTestUtil.addOrganizationOwnerUser(organization);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\torganization.getGroupId(), role.getRoleId(), subjectUser,\n\t\t\tobjectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\tobjectUser.getUserId(), organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","id":101267,"modified_method":"@Test\n\tpublic void testOrganizationOwnerRemovingOrganizationOwnerRoleByUsers()\n\t\tthrows Exception {\n\n\t\t_organization = OrganizationTestUtil.addOrganization();\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tTestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER);\n\n\t\t_subjectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\t\t_objectUser = UserTestUtil.addOrganizationOwnerUser(_organization);\n\n\t\tdeleteUserGroupRolesByUser(\n\t\t\t_organization.getGroupId(), role.getRoleId(), _subjectUser,\n\t\t\t_objectUser);\n\n\t\tAssert.assertFalse(\n\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t_objectUser.getUserId(), _organization.getGroupId(),\n\t\t\t\trole.getRoleId()));\n\t}","commit_id":"b173debbf5196394518467a19db108d6e383c5a6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Tests that writing a null buffer throws the correct exception.\n   *\n   * @throws IOException when the write fails\n   */\n  @Test\n  public void writeNullBufferTest() throws IOException {\n    mThrown.expect(IllegalArgumentException.class);\n    mThrown.expectMessage(PreconditionMessage.ERR_WRITE_BUFFER_NULL);\n    mTestStream.write(null);\n  }","id":101268,"modified_method":"/**\n   * Tests that writing a null buffer throws the correct exception.\n   *\n   * @throws IOException when the write fails\n   */\n  @Test\n  public void writeNullBufferTest() throws IOException {\n    try {\n      mTestStream.write(null);\n      fail();\n    } catch (IllegalArgumentException e) {\n      Assert.assertEquals(PreconditionMessage.ERR_WRITE_BUFFER_NULL, e.getMessage());\n    }\n  }","commit_id":"7ad7ed994ef246775d183a9bbc51cbb2450f85f7","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void missingLocationPolicyTest() throws IOException {\n    mThrown.expect(NullPointerException.class);\n    mThrown.expectMessage(PreconditionMessage.FILE_WRITE_LOCATION_POLICY_UNSPECIFIED);\n\n    OutStreamOptions options =\n        new OutStreamOptions.Builder(ClientContext.getConf()).setBlockSizeBytes(BLOCK_LENGTH)\n            .setUnderStorageType(UnderStorageType.NO_PERSIST).setLocationPolicy(null).build();\n    mTestStream = createTestStream(FILE_ID, options);\n  }","id":101269,"modified_method":"@Test\n  public void missingLocationPolicyTest() throws IOException {\n    OutStreamOptions options =\n        new OutStreamOptions.Builder(ClientContext.getConf()).setBlockSizeBytes(BLOCK_LENGTH)\n            .setUnderStorageType(UnderStorageType.NO_PERSIST).setLocationPolicy(null).build();\n    try {\n      mTestStream = createTestStream(FILE_ID, options);\n      fail();\n    } catch (NullPointerException e) {\n      Assert.assertEquals(PreconditionMessage.FILE_WRITE_LOCATION_POLICY_UNSPECIFIED,\n          e.getMessage());\n    }\n  }","commit_id":"7ad7ed994ef246775d183a9bbc51cbb2450f85f7","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests that the correct exception is thrown when a buffer is written with invalid offset/length.\n   *\n   * @throws IOException when the write fails\n   */\n  @Test\n  public void writeBadBufferOffsetTest() throws IOException {\n    mThrown.expect(IllegalArgumentException.class);\n    mThrown.expectMessage(String.format(PreconditionMessage.ERR_BUFFER_STATE, 10, 5, 6));\n    mTestStream.write(new byte[10], 5, 6);\n  }","id":101270,"modified_method":"/**\n   * Tests that the correct exception is thrown when a buffer is written with invalid offset/length.\n   *\n   * @throws IOException when the write fails\n   */\n  @Test\n  public void writeBadBufferOffsetTest() throws IOException {\n    try {\n      mTestStream.write(new byte[10], 5, 6);\n      fail();\n    } catch (IllegalArgumentException e) {\n      Assert.assertEquals(String.format(PreconditionMessage.ERR_BUFFER_STATE, 10, 5, 6),\n          e.getMessage());\n    }\n  }","commit_id":"7ad7ed994ef246775d183a9bbc51cbb2450f85f7","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests that if an exception is thrown by the underlying out stream, and the user is using\n   * {@link UnderStorageType#NO_PERSIST} for their under storage type, the correct exception\n   * message will be thrown.\n   *\n   * @throws  IOException when the write fails\n   */\n  @Test\n  public void cacheWriteExceptionNonSyncPersistTest() throws IOException {\n    OutStreamOptions options = new OutStreamOptions.Builder(ClientContext.getConf())\n        .setBlockSizeBytes(BLOCK_LENGTH).setUnderStorageType(UnderStorageType.NO_PERSIST).build();\n    mTestStream = createTestStream(FILE_ID, options);\n\n    BufferedBlockOutStream stream = Mockito.mock(BufferedBlockOutStream.class);\n    Whitebox.setInternalState(mTestStream, \"mCurrentBlockOutStream\", stream);\n    Mockito.when(stream.remaining()).thenReturn(BLOCK_LENGTH);\n    Mockito.doThrow(new IOException(\"test error\")).when(stream).write((byte) 7);\n    mThrown.expect(IOException.class);\n    mThrown.expectMessage(ExceptionMessage.FAILED_CACHE.getMessage(\"test error\"));\n    mTestStream.write(7);\n  }","id":101271,"modified_method":"/**\n   * Tests that if an exception is thrown by the underlying out stream, and the user is using\n   * {@link UnderStorageType#NO_PERSIST} for their under storage type, the correct exception\n   * message will be thrown.\n   *\n   * @throws  IOException when the write fails\n   */\n  @Test\n  public void cacheWriteExceptionNonSyncPersistTest() throws IOException {\n    OutStreamOptions options = new OutStreamOptions.Builder(ClientContext.getConf())\n        .setBlockSizeBytes(BLOCK_LENGTH).setUnderStorageType(UnderStorageType.NO_PERSIST).build();\n    mTestStream = createTestStream(FILE_ID, options);\n\n    BufferedBlockOutStream stream = Mockito.mock(BufferedBlockOutStream.class);\n    Whitebox.setInternalState(mTestStream, \"mCurrentBlockOutStream\", stream);\n    Mockito.when(stream.remaining()).thenReturn(BLOCK_LENGTH);\n    Mockito.doThrow(new IOException(\"test error\")).when(stream).write((byte) 7);\n    try {\n      mTestStream.write(7);\n      fail();\n    } catch (IOException e) {\n      Assert.assertEquals(ExceptionMessage.FAILED_CACHE.getMessage(\"test error\"), e.getMessage());\n    }\n  }","commit_id":"7ad7ed994ef246775d183a9bbc51cbb2450f85f7","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests that writing a null buffer with offset/length information throws the correct exception.\n   *\n   * @throws IOException when the write fails\n   */\n  @Test\n  public void writeNullBufferOffsetTest() throws IOException {\n    mThrown.expect(IllegalArgumentException.class);\n    mThrown.expectMessage(PreconditionMessage.ERR_WRITE_BUFFER_NULL);\n    mTestStream.write(null, 0, 0);\n  }","id":101272,"modified_method":"/**\n   * Tests that writing a null buffer with offset/length information throws the correct exception.\n   *\n   * @throws IOException when the write fails\n   */\n  @Test\n  public void writeNullBufferOffsetTest() throws IOException {\n    try {\n      mTestStream.write(null, 0, 0);\n      fail();\n    } catch (IllegalArgumentException e) {\n      Assert.assertEquals(PreconditionMessage.ERR_WRITE_BUFFER_NULL, e.getMessage());\n    }\n  }","commit_id":"7ad7ed994ef246775d183a9bbc51cbb2450f85f7","url":"https://github.com/amplab/tachyon"},{"original_method":"private void setParameters(Functional decl, MethodMirror methodMirror) {\n        ParameterList parameters = new ParameterList();\n        decl.addParameterList(parameters);\n        for(VariableMirror paramMirror : methodMirror.getParameters()){\n            ValueParameter parameter = new ValueParameter();\n            parameter.setContainer((Scope) decl);\n            parameter.setUnit(((Element)decl).getUnit());\n            if(decl instanceof Class){\n                ((Class)decl).getMembers().add(parameter);\n            }\n            String paramName = getAnnotationStringValue(paramMirror, CEYLON_NAME_ANNOTATION);\n            // use whatever param name we find as default\n            if(paramName == null)\n                paramName = paramMirror.getName();\n            parameter.setName(paramName);\n            parameter.setType(obtainType(paramMirror.getType(), paramMirror, (Scope) decl));\n            if(paramMirror.getAnnotation(CEYLON_SEQUENCED_ANNOTATION) != null)\n                parameter.setSequenced(true);\n            if(paramMirror.getAnnotation(CEYLON_DEFAULTED_ANNOTATION) != null)\n                parameter.setDefaulted(true);\n            markUnboxed(parameter, paramMirror.getType());\n            parameter.setDeclaration((Declaration) decl);\n            parameters.getParameters().add(parameter);\n        }\n    }","id":101273,"modified_method":"private void setParameters(Functional decl, MethodMirror methodMirror, boolean isCeylon) {\n        ParameterList parameters = new ParameterList();\n        decl.addParameterList(parameters);\n        for(VariableMirror paramMirror : methodMirror.getParameters()){\n            ValueParameter parameter = new ValueParameter();\n            parameter.setContainer((Scope) decl);\n            parameter.setUnit(((Element)decl).getUnit());\n            if(decl instanceof Class){\n                ((Class)decl).getMembers().add(parameter);\n            }\n            String paramName = getAnnotationStringValue(paramMirror, CEYLON_NAME_ANNOTATION);\n            // use whatever param name we find as default\n            if(paramName == null)\n                paramName = paramMirror.getName();\n            parameter.setName(paramName);\n            TypeMirror typeMirror = paramMirror.getType();\n            ProducedType type = obtainType(typeMirror, paramMirror, (Scope) decl);\n            if(!isCeylon && !typeMirror.isPrimitive()){\n                // Java parameters are all optional unless primitives\n                type = typeFactory.getOptionalType(type);\n            }\n            parameter.setType(type );\n            if(paramMirror.getAnnotation(CEYLON_SEQUENCED_ANNOTATION) != null)\n                parameter.setSequenced(true);\n            if(paramMirror.getAnnotation(CEYLON_DEFAULTED_ANNOTATION) != null)\n                parameter.setDefaulted(true);\n            markUnboxed(parameter, paramMirror.getType());\n            parameter.setDeclaration((Declaration) decl);\n            parameters.getParameters().add(parameter);\n        }\n    }","commit_id":"914b4afd957774f5217aded34976dc6d8c3386dd","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void complete(LazyMethod method) {\n        MethodMirror meth = null;\n        String lookupName = Util.quoteIfJavaKeyword(method.getName());\n        for(MethodMirror m : method.classMirror.getDirectMethods()){\n            // We skip members marked with @Ignore\n            if(m.getAnnotation(CEYLON_IGNORE_ANNOTATION) != null)\n                continue;\n            \n            if(m.getName().equals(lookupName)){\n                meth = m;\n                break;\n            }\n        }\n        if(meth == null || meth.getReturnType() == null)\n            throw new RuntimeException(\"Failed to find toplevel method \"+method.getName());\n        \n        // type params first\n        setTypeParameters(method, meth);\n\n        // now its parameters\n        setParameters(method, meth);\n        method.setType(obtainType(meth.getReturnType(), meth, method));\n        markUnboxed(method, meth.getReturnType());\n     }","id":101274,"modified_method":"@Override\n    public void complete(LazyMethod method) {\n        MethodMirror meth = null;\n        String lookupName = Util.quoteIfJavaKeyword(method.getName());\n        for(MethodMirror m : method.classMirror.getDirectMethods()){\n            // We skip members marked with @Ignore\n            if(m.getAnnotation(CEYLON_IGNORE_ANNOTATION) != null)\n                continue;\n            \n            if(m.getName().equals(lookupName)){\n                meth = m;\n                break;\n            }\n        }\n        if(meth == null || meth.getReturnType() == null)\n            throw new RuntimeException(\"Failed to find toplevel method \"+method.getName());\n        \n        // type params first\n        setTypeParameters(method, meth);\n\n        // now its parameters\n        setParameters(method, meth, true /* toplevel methods are always Ceylon */);\n        method.setType(obtainType(meth.getReturnType(), meth, method));\n        markUnboxed(method, meth.getReturnType());\n     }","commit_id":"914b4afd957774f5217aded34976dc6d8c3386dd","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void complete(ClassOrInterface klass, ClassMirror classMirror) {\n        HashSet<String> variables = new HashSet<String>();\n        String qualifiedName = classMirror.getQualifiedName();\n        boolean isJava = qualifiedName.startsWith(\"java.\");\n        boolean isCeylon = (classMirror.getAnnotation(CEYLON_CEYLON_ANNOTATION) != null);\n        \n        // Java classes with multiple constructors get turned into multiple Ceylon classes\n        // Here we get the specific constructor that was assigned to us (if any)\n        MethodMirror constructor = null;\n        if (klass instanceof LazyClass) {\n            constructor = ((LazyClass)klass).getConstructor();\n        }\n            \n        // Turn a list of possibly overloaded methods into a map\n        // of lists that contain methods with the same name\n        Map<String, List<MethodMirror>> methods = new LinkedHashMap<String, List<MethodMirror>>();\n        for(MethodMirror methodMirror : classMirror.getDirectMethods()){\n            // We skip members marked with @Ignore\n            if(methodMirror.getAnnotation(CEYLON_IGNORE_ANNOTATION) != null)\n                continue;\n            if(methodMirror.isStaticInit())\n                continue;\n            // FIXME Should we allow static methods or not?\n            if(isCeylon && methodMirror.isStatic())\n                continue;\n            // FIXME: temporary, because some private classes from the jdk are\n            // referenced in private methods but not available\n            if(isJava && !methodMirror.isPublic())\n                continue;\n            String methodName = methodMirror.getName();\n            List<MethodMirror> homonyms = methods.get(methodName);\n            if (homonyms == null) {\n                homonyms = new LinkedList<MethodMirror>();\n                methods.put(methodName, homonyms);\n            }\n            homonyms.add(methodMirror);\n        }\n        \n        // Add the methods\n        for(List<MethodMirror> methodMirrors : methods.values()){\n            boolean isOverloaded = methodMirrors.size() > 1;\n            for (MethodMirror methodMirror : methodMirrors) {\n                String methodName = methodMirror.getName();\n                if(methodMirror == constructor) {\n                    ((Class)klass).setOverloaded(isOverloaded);\n                    if(!(klass instanceof LazyClass) || !((LazyClass)klass).isTopLevelObjectType())\n                        setParameters((Class)klass, methodMirror);\n                } else if(methodMirror.isConstructor()) {\n                    // skip other constructors\n                } else if(isGetter(methodMirror)) {\n                    // simple attribute\n                    addValue(klass, methodMirror, getJavaAttributeName(methodName));\n                } else if(isSetter(methodMirror)) {\n                    // We skip setters for now and handle them later\n                    variables.add(getJavaAttributeName(methodName));\n                } else if(isHashAttribute(methodMirror)) {\n                    // ERASURE\n                    // Un-erasing 'hash' attribute from 'hashCode' method\n                    addValue(klass, methodMirror, \"hash\");\n                } else if(isStringAttribute(methodMirror)) {\n                    // ERASURE\n                    // Un-erasing 'string' attribute from 'toString' method\n                    addValue(klass, methodMirror, \"string\");\n                } else {\n                    // normal method\n                    Method method = new Method();\n    \n                    method.setContainer(klass);\n                    method.setName(methodName);\n                    method.setUnit(klass.getUnit());\n                    method.setOverloaded(isOverloaded);\n                    setMethodOrValueFlags(klass, methodMirror, method);\n    \n                    // type params first\n                    setTypeParameters(method, methodMirror);\n    \n                    // now its parameters\n                    if(isEqualsMethod(methodMirror))\n                        setEqualsParameters(method, methodMirror);\n                    else\n                        setParameters(method, methodMirror);\n                    \n                    // and its return type\n                    ProducedType type = getMethodReturnType(methodMirrors, method);\n                    method.setType(type);\n                    \n                    markUnboxed(method, methodMirror.getReturnType());\n                    klass.getMembers().add(method);\n                }\n            }\n        }\n\n        for(FieldMirror fieldMirror : classMirror.getDirectFields()){\n            // We skip members marked with @Ignore\n            if(fieldMirror.getAnnotation(CEYLON_IGNORE_ANNOTATION) != null)\n                continue;\n            // FIXME: Skip static fields for now\n            if(fieldMirror.isStatic())\n                continue;\n            String name = fieldMirror.getName();\n            // skip the field if \"we've already got one\"\n            if(klass.getDirectMember(name) != null)\n                continue;\n            addValue(klass, fieldMirror);\n        }\n        \n        // Now mark all Values for which Setters exist as variable\n        for(String var : variables){\n            Declaration decl = klass.getMember(var);\n            if (decl != null && decl instanceof Value) {\n                ((Value)decl).setVariable(true);\n            } else {\n                logWarning(\"Has conflicting attribute and method name '\" + var + \"': \"+qualifiedName);\n            }\n        }\n        \n        setExtendedType(klass, classMirror);\n        setSatisfiedTypes(klass, classMirror);\n        setCaseTypes(klass, classMirror);\n        fillRefinedDeclarations(klass);\n    }","id":101275,"modified_method":"private void complete(ClassOrInterface klass, ClassMirror classMirror) {\n        HashSet<String> variables = new HashSet<String>();\n        String qualifiedName = classMirror.getQualifiedName();\n        boolean isJava = qualifiedName.startsWith(\"java.\");\n        boolean isCeylon = (classMirror.getAnnotation(CEYLON_CEYLON_ANNOTATION) != null);\n        \n        // Java classes with multiple constructors get turned into multiple Ceylon classes\n        // Here we get the specific constructor that was assigned to us (if any)\n        MethodMirror constructor = null;\n        if (klass instanceof LazyClass) {\n            constructor = ((LazyClass)klass).getConstructor();\n        }\n            \n        // Turn a list of possibly overloaded methods into a map\n        // of lists that contain methods with the same name\n        Map<String, List<MethodMirror>> methods = new LinkedHashMap<String, List<MethodMirror>>();\n        for(MethodMirror methodMirror : classMirror.getDirectMethods()){\n            // We skip members marked with @Ignore\n            if(methodMirror.getAnnotation(CEYLON_IGNORE_ANNOTATION) != null)\n                continue;\n            if(methodMirror.isStaticInit())\n                continue;\n            // FIXME Should we allow static methods or not?\n            if(isCeylon && methodMirror.isStatic())\n                continue;\n            // FIXME: temporary, because some private classes from the jdk are\n            // referenced in private methods but not available\n            if(isJava && !methodMirror.isPublic())\n                continue;\n            String methodName = methodMirror.getName();\n            List<MethodMirror> homonyms = methods.get(methodName);\n            if (homonyms == null) {\n                homonyms = new LinkedList<MethodMirror>();\n                methods.put(methodName, homonyms);\n            }\n            homonyms.add(methodMirror);\n        }\n        \n        // Add the methods\n        for(List<MethodMirror> methodMirrors : methods.values()){\n            boolean isOverloaded = methodMirrors.size() > 1;\n            for (MethodMirror methodMirror : methodMirrors) {\n                String methodName = methodMirror.getName();\n                if(methodMirror == constructor) {\n                    ((Class)klass).setOverloaded(isOverloaded);\n                    if(!(klass instanceof LazyClass) || !((LazyClass)klass).isTopLevelObjectType())\n                        setParameters((Class)klass, methodMirror, isCeylon);\n                } else if(methodMirror.isConstructor()) {\n                    // skip other constructors\n                } else if(isGetter(methodMirror)) {\n                    // simple attribute\n                    addValue(klass, methodMirror, getJavaAttributeName(methodName));\n                } else if(isSetter(methodMirror)) {\n                    // We skip setters for now and handle them later\n                    variables.add(getJavaAttributeName(methodName));\n                } else if(isHashAttribute(methodMirror)) {\n                    // ERASURE\n                    // Un-erasing 'hash' attribute from 'hashCode' method\n                    addValue(klass, methodMirror, \"hash\");\n                } else if(isStringAttribute(methodMirror)) {\n                    // ERASURE\n                    // Un-erasing 'string' attribute from 'toString' method\n                    addValue(klass, methodMirror, \"string\");\n                } else {\n                    // normal method\n                    Method method = new Method();\n    \n                    method.setContainer(klass);\n                    method.setName(methodName);\n                    method.setUnit(klass.getUnit());\n                    method.setOverloaded(isOverloaded);\n                    setMethodOrValueFlags(klass, methodMirror, method);\n    \n                    // type params first\n                    setTypeParameters(method, methodMirror);\n    \n                    // now its parameters\n                    if(isEqualsMethod(methodMirror))\n                        setEqualsParameters(method, methodMirror);\n                    else\n                        setParameters(method, methodMirror, isCeylon);\n                    \n                    // and its return type\n                    ProducedType type = getMethodReturnType(methodMirrors, method);\n                    method.setType(type);\n                    \n                    markUnboxed(method, methodMirror.getReturnType());\n                    klass.getMembers().add(method);\n                }\n            }\n        }\n\n        for(FieldMirror fieldMirror : classMirror.getDirectFields()){\n            // We skip members marked with @Ignore\n            if(fieldMirror.getAnnotation(CEYLON_IGNORE_ANNOTATION) != null)\n                continue;\n            // FIXME: Skip static fields for now\n            if(fieldMirror.isStatic())\n                continue;\n            String name = fieldMirror.getName();\n            // skip the field if \"we've already got one\"\n            if(klass.getDirectMember(name) != null)\n                continue;\n            addValue(klass, fieldMirror);\n        }\n        \n        // Now mark all Values for which Setters exist as variable\n        for(String var : variables){\n            Declaration decl = klass.getMember(var);\n            if (decl != null && decl instanceof Value) {\n                ((Value)decl).setVariable(true);\n            } else {\n                logWarning(\"Has conflicting attribute and method name '\" + var + \"': \"+qualifiedName);\n            }\n        }\n        \n        setExtendedType(klass, classMirror);\n        setSatisfiedTypes(klass, classMirror);\n        setCaseTypes(klass, classMirror);\n        fillRefinedDeclarations(klass);\n    }","commit_id":"914b4afd957774f5217aded34976dc6d8c3386dd","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private Method addMethod(ClassOrInterface klass, MethodMirror methodMirror, boolean isCeylon, boolean isOverloaded) {\n        JavaMethod method = new JavaMethod();\n        \n        method.setContainer(klass);\n        method.setRealName(methodMirror.getName());\n        method.setName(Util.strip(methodMirror.getName()));\n        method.setUnit(klass.getUnit());\n        method.setOverloaded(isOverloaded);\n        setMethodOrValueFlags(klass, methodMirror, method);\n\n        // type params first\n        setTypeParameters(method, methodMirror);\n\n        // now its parameters\n        if(isEqualsMethod(methodMirror))\n            setEqualsParameters(method, methodMirror);\n        else\n            setParameters(method, methodMirror, isCeylon, klass);\n        \n        // and its return type\n        try{\n            ProducedType type = obtainType(methodMirror.getReturnType(), methodMirror, method);\n            method.setUncheckedNullType(!isCeylon);\n            method.setType(type);\n            method.setDeclaredVoid(methodMirror.isDeclaredVoid());\n        }catch(TypeParserException x){\n            logError(\"Invalid type signature for method return type of \"+klass.getQualifiedNameString()+\".\"+methodMirror.getName()+\": \"+x.getMessage());\n            throw x;\n        }\n        \n        markUnboxed(method, methodMirror.getReturnType());\n        setAnnotations(method, methodMirror);\n        \n        klass.getMembers().add(method);\n        \n        return method;\n    }","id":101276,"modified_method":"private Method addMethod(ClassOrInterface klass, MethodMirror methodMirror, boolean isCeylon, boolean isOverloaded) {\n        JavaMethod method = new JavaMethod();\n        \n        method.setContainer(klass);\n        method.setRealName(methodMirror.getName());\n        method.setName(Util.strip(methodMirror.getName()));\n        method.setUnit(klass.getUnit());\n        method.setOverloaded(isOverloaded);\n        setMethodOrValueFlags(klass, methodMirror, method);\n\n        // type params first\n        setTypeParameters(method, methodMirror);\n\n        // now its parameters\n        if(isEqualsMethod(methodMirror))\n            setEqualsParameters(method, methodMirror);\n        else\n            setParameters(method, methodMirror, isCeylon, klass);\n        \n        // and its return type\n        try{\n            ProducedType type = obtainType(methodMirror.getReturnType(), methodMirror, method);\n            method.setType(type);\n            method.setUncheckedNullType(!isCeylon && !methodMirror.getReturnType().isPrimitive());\n            method.setDeclaredVoid(methodMirror.isDeclaredVoid());\n        }catch(TypeParserException x){\n            logError(\"Invalid type signature for method return type of \"+klass.getQualifiedNameString()+\".\"+methodMirror.getName()+\": \"+x.getMessage());\n            throw x;\n        }\n        \n        markUnboxed(method, methodMirror.getReturnType());\n        setAnnotations(method, methodMirror);\n        \n        klass.getMembers().add(method);\n        \n        return method;\n    }","commit_id":"869d102c9d028ff476c67eb0642772f249c86666","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void addValue(ClassOrInterface klass, FieldMirror fieldMirror, boolean isCeylon) {\n        // make sure it's a FieldValue so we can figure it out in the backend\n        Value value = new FieldValue();\n        value.setContainer(klass);\n        value.setName(fieldMirror.getName());\n        value.setUnit(klass.getUnit());\n        value.setShared(fieldMirror.isPublic() || fieldMirror.isProtected());\n        value.setProtectedVisibility(fieldMirror.isProtected());\n        value.setStaticallyImportable(fieldMirror.isStatic());\n        // field can't be abstract or interface, so not formal\n        // can we override fields? good question. Not really, but from an external point of view?\n        // FIXME: figure this out: (default)\n        // FIXME: for the same reason, can it be an overriding field? (actual)\n        value.setVariable(!fieldMirror.isFinal());\n        try{\n            value.setType(obtainType(fieldMirror.getType(), fieldMirror, klass));\n            value.setUncheckedNullType(!isCeylon);\n        }catch(TypeParserException x){\n            logError(\"Invalid type signature for field \"+klass.getQualifiedNameString()+\".\"+value.getName()+\": \"+x.getMessage());\n            throw x;\n        }\n        markUnboxed(value, fieldMirror.getType());\n        klass.getMembers().add(value);\n    }","id":101277,"modified_method":"private void addValue(ClassOrInterface klass, FieldMirror fieldMirror, boolean isCeylon) {\n        // make sure it's a FieldValue so we can figure it out in the backend\n        Value value = new FieldValue();\n        value.setContainer(klass);\n        value.setName(fieldMirror.getName());\n        value.setUnit(klass.getUnit());\n        value.setShared(fieldMirror.isPublic() || fieldMirror.isProtected());\n        value.setProtectedVisibility(fieldMirror.isProtected());\n        value.setStaticallyImportable(fieldMirror.isStatic());\n        // field can't be abstract or interface, so not formal\n        // can we override fields? good question. Not really, but from an external point of view?\n        // FIXME: figure this out: (default)\n        // FIXME: for the same reason, can it be an overriding field? (actual)\n        value.setVariable(!fieldMirror.isFinal());\n        try{\n            ProducedType type = obtainType(fieldMirror.getType(), fieldMirror, klass);\n            value.setType(type);\n            value.setUncheckedNullType(!isCeylon && !fieldMirror.getType().isPrimitive());\n        }catch(TypeParserException x){\n            logError(\"Invalid type signature for field \"+klass.getQualifiedNameString()+\".\"+value.getName()+\": \"+x.getMessage());\n            throw x;\n        }\n        markUnboxed(value, fieldMirror.getType());\n        klass.getMembers().add(value);\n    }","commit_id":"869d102c9d028ff476c67eb0642772f249c86666","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void addValue(ClassOrInterface klass, MethodMirror methodMirror, String methodName, boolean isCeylon) {\n        JavaBeanValue value = new JavaBeanValue();\n        value.setGetterName(methodMirror.getName());\n        value.setContainer(klass);\n        value.setName(methodName);\n        value.setUnit(klass.getUnit());\n        setMethodOrValueFlags(klass, methodMirror, value);\n        try{\n            value.setType(obtainType(methodMirror.getReturnType(), methodMirror, klass));\n            value.setUncheckedNullType(!isCeylon);\n        }catch(TypeParserException x){\n            logError(\"Invalid type signature for getter type of \"+klass.getQualifiedNameString()+\".\"+methodName+\": \"+x.getMessage());\n            throw x;\n        }\n        markUnboxed(value, methodMirror.getReturnType());\n        setAnnotations(value, methodMirror);\n        klass.getMembers().add(value);\n    }","id":101278,"modified_method":"private void addValue(ClassOrInterface klass, MethodMirror methodMirror, String methodName, boolean isCeylon) {\n        JavaBeanValue value = new JavaBeanValue();\n        value.setGetterName(methodMirror.getName());\n        value.setContainer(klass);\n        value.setName(methodName);\n        value.setUnit(klass.getUnit());\n        setMethodOrValueFlags(klass, methodMirror, value);\n        try{\n            ProducedType type = obtainType(methodMirror.getReturnType(), methodMirror, klass);\n            value.setType(type);\n            value.setUncheckedNullType(!isCeylon && !methodMirror.getReturnType().isPrimitive());\n        }catch(TypeParserException x){\n            logError(\"Invalid type signature for getter type of \"+klass.getQualifiedNameString()+\".\"+methodName+\": \"+x.getMessage());\n            throw x;\n        }\n        markUnboxed(value, methodMirror.getReturnType());\n        setAnnotations(value, methodMirror);\n        klass.getMembers().add(value);\n    }","commit_id":"869d102c9d028ff476c67eb0642772f249c86666","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * create an instance *\n     */\n    public DirectAdminObjectActivatorService(String jndiName, String className, String resourceAdapter,\n                                             String raId, String[] properties,Module module, ContextNames.BindInfo bindInfo) {\n        this.jndiName = jndiName;\n        this.className = className;\n        this.resourceAdapter = resourceAdapter;\n        this.raId = raId;\n        this.properties = properties;\n        this.module = module;\n        this.bindInfo = bindInfo;\n    }","id":101279,"modified_method":"/**\n     * create an instance *\n     */\n    public DirectAdminObjectActivatorService(String jndiName, String className, String resourceAdapter,\n                                             String raId, Map<String, String> properties, Module module, ContextNames.BindInfo bindInfo) {\n        this.jndiName = jndiName;\n        this.className = className;\n        this.resourceAdapter = resourceAdapter;\n        this.raId = raId;\n        this.properties = properties;\n        this.module = module;\n        this.bindInfo = bindInfo;\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        ROOT_LOGGER.debugf(\"started DirectConnectionFactoryActivatorService %s\", context.getController().getName());\n        String aoClass = null;\n\n\n        try {\n\n            Connector cmd = mdr.getValue().getResourceAdapter(raId);\n            if (cmd.getVersion() == Connector.Version.V_10) {\n                throw ConnectorLogger.ROOT_LOGGER.adminObjectForJCA10(resourceAdapter, jndiName);\n            } else {\n                ResourceAdapter ra1516 = (ResourceAdapter) cmd.getResourceadapter();\n                if (ra1516.getAdminObjects() != null) {\n                    for (AdminObject ao : ra1516.getAdminObjects()) {\n                        if (ao.getAdminobjectClass().getValue().equals(className))\n                            aoClass = ao.getAdminobjectClass().getValue();\n                    }\n                }\n            }\n\n            if (aoClass == null || !aoClass.equals(className)) {\n                throw ConnectorLogger.ROOT_LOGGER.invalidAdminObject(aoClass, resourceAdapter, jndiName);\n            }\n\n            Map<String, String> raConfigProperties = new HashMap<String, String>();\n            Map<String, String> aoConfigProperties = new HashMap<String, String>();\n\n            if (properties != null) {\n                for (String prop : properties) {\n                    String key = prop.substring(0, prop.indexOf(\"=\"));\n                    String value = prop.substring(prop.indexOf(\"=\") + 1);\n\n                    if (key.startsWith(\"ra.\")) {\n                        raConfigProperties.put(key.substring(3), value);\n                    } else if (key.startsWith(\"ao.\")) {\n                        aoConfigProperties.put(key.substring(3), value);\n                    } else {\n                        aoConfigProperties.put(key, value);\n                    }\n                }\n            }\n\n            org.jboss.jca.common.api.metadata.resourceadapter.AdminObject ao = new AdminObjectImpl(aoConfigProperties, aoClass, jndiName, poolName(aoClass, className), Boolean.TRUE, Boolean.TRUE);\n\n            Activation activation = new ActivationImpl(null, null, TransactionSupportEnum.LocalTransaction, Collections.<ConnectionDefinition>emptyList(), Collections.singletonList(ao),\n                    null, Collections.<String>emptyList(), null, null);\n\n            String serviceName = jndiName;\n            serviceName = serviceName.replace(':', '_');\n            serviceName = serviceName.replace('/', '_');\n\n            ResourceAdapterActivatorService activator = new ResourceAdapterActivatorService(cmd, activation, module.getClassLoader(), serviceName);\n            activator.setCreateBinderService(false);\n            activator.setBindInfo(bindInfo);\n            ServiceTarget serviceTarget = context.getChildTarget();\n\n            ServiceBuilder adminObjectServiceBuilder = serviceTarget\n                    .addService(ConnectorServices.RESOURCE_ADAPTER_ACTIVATOR_SERVICE.append(serviceName), activator)\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, AS7MetadataRepository.class,\n                            activator.getMdrInjector())\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class,\n                            activator.getRaRepositoryInjector())\n                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                            activator.getManagementRepositoryInjector())\n                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                            ResourceAdapterDeploymentRegistry.class, activator.getRegistryInjector())\n                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                            activator.getTxIntegrationInjector())\n                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE,\n                            JcaSubsystemConfiguration.class, activator.getConfigInjector())\n                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                            activator.getSubjectFactoryInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class,\n                            activator.getCcmInjector()).addDependency(NamingService.SERVICE_NAME)\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER)\n                    .addDependency(ConnectorServices.BOOTSTRAP_CONTEXT_SERVICE.append(\"default\"));\n\n\n            adminObjectServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n    }","id":101280,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        ROOT_LOGGER.debugf(\"started DirectConnectionFactoryActivatorService %s\", context.getController().getName());\n        String aoClass = null;\n\n\n        try {\n\n            Connector cmd = mdr.getValue().getResourceAdapter(raId);\n            if (cmd.getVersion() == Connector.Version.V_10) {\n                throw ConnectorLogger.ROOT_LOGGER.adminObjectForJCA10(resourceAdapter, jndiName);\n            } else {\n                ResourceAdapter ra1516 = (ResourceAdapter) cmd.getResourceadapter();\n                if (ra1516.getAdminObjects() != null) {\n                    for (AdminObject ao : ra1516.getAdminObjects()) {\n                        if (ao.getAdminobjectClass().getValue().equals(className))\n                            aoClass = ao.getAdminobjectClass().getValue();\n                    }\n                }\n            }\n\n            if (aoClass == null || !aoClass.equals(className)) {\n                throw ConnectorLogger.ROOT_LOGGER.invalidAdminObject(aoClass, resourceAdapter, jndiName);\n            }\n\n            Map<String, String> raConfigProperties = new HashMap<String, String>();\n            Map<String, String> aoConfigProperties = new HashMap<String, String>();\n\n            if (properties != null) {\n                for (Map.Entry<String,String> prop : properties.entrySet()) {\n                    String key = prop.getKey();\n                    String value = prop.getValue();\n                    if (key.startsWith(\"ra.\")) {\n                        raConfigProperties.put(key.substring(3), value);\n                    } else if (key.startsWith(\"ao.\")) {\n                        aoConfigProperties.put(key.substring(3), value);\n                    } else {\n                        aoConfigProperties.put(key, value);\n                    }\n                }\n            }\n\n            org.jboss.jca.common.api.metadata.resourceadapter.AdminObject ao = new AdminObjectImpl(aoConfigProperties, aoClass, jndiName, poolName(aoClass, className), Boolean.TRUE, Boolean.TRUE);\n\n            Activation activation = new ActivationImpl(null, null, TransactionSupportEnum.LocalTransaction, Collections.<ConnectionDefinition>emptyList(), Collections.singletonList(ao),\n                    null, Collections.<String>emptyList(), null, null);\n\n            String serviceName = jndiName;\n            serviceName = serviceName.replace(':', '_');\n            serviceName = serviceName.replace('/', '_');\n\n            ResourceAdapterActivatorService activator = new ResourceAdapterActivatorService(cmd, activation, module.getClassLoader(), serviceName);\n            activator.setCreateBinderService(false);\n            activator.setBindInfo(bindInfo);\n            ServiceTarget serviceTarget = context.getChildTarget();\n\n            ServiceBuilder adminObjectServiceBuilder = serviceTarget\n                    .addService(ConnectorServices.RESOURCE_ADAPTER_ACTIVATOR_SERVICE.append(serviceName), activator)\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, AS7MetadataRepository.class,\n                            activator.getMdrInjector())\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class,\n                            activator.getRaRepositoryInjector())\n                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                            activator.getManagementRepositoryInjector())\n                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                            ResourceAdapterDeploymentRegistry.class, activator.getRegistryInjector())\n                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                            activator.getTxIntegrationInjector())\n                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE,\n                            JcaSubsystemConfiguration.class, activator.getConfigInjector())\n                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                            activator.getSubjectFactoryInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class,\n                            activator.getCcmInjector()).addDependency(NamingService.SERVICE_NAME)\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER)\n                    .addDependency(ConnectorServices.BOOTSTRAP_CONTEXT_SERVICE.append(\"default\"));\n\n\n            adminObjectServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        ROOT_LOGGER.debugf(\"started DirectConnectionFactoryActivatorService %s\", context.getController().getName());\n        String cfInterface = null;\n\n\n        try {\n\n            Connector cmd = mdr.getValue().getResourceAdapter(raId);\n\n            ResourceAdapter ra = cmd.getResourceadapter();\n            if (ra.getOutboundResourceadapter() != null) {\n                for (ConnectionDefinition cd : ra.getOutboundResourceadapter().getConnectionDefinitions()) {\n                    if (cd.getConnectionFactoryInterface().getValue().equals(interfaceName))\n                        cfInterface = cd.getConnectionFactoryInterface().getValue();\n                }\n            }\n\n\n            if (cfInterface == null || !cfInterface.equals(interfaceName)) {\n                throw ConnectorLogger.ROOT_LOGGER.invalidConnectionFactory(cfInterface, resourceAdapter, jndiName);\n            }\n\n            Map<String, String> raConfigProperties = new HashMap<String, String>();\n            Map<String, String> mcfConfigProperties = new HashMap<String, String>();\n            String securitySetting = null;\n            String securitySettingDomain = null;\n\n            if (properties != null) {\n                for (String prop : properties) {\n                    if (prop.startsWith(\"ironjacamar.security\")) {\n                        securitySetting = prop.substring(prop.indexOf(\"=\") + 1);\n                    } else if (prop.startsWith(\"ironjacamar.security.domain\")) {\n                        securitySettingDomain = prop.substring(prop.indexOf(\"=\") + 1);\n                    } else {\n                        String key = prop.substring(0, prop.indexOf(\"=\"));\n                        String value = prop.substring(prop.indexOf(\"=\") + 1);\n\n                        if (key.startsWith(\"ra.\")) {\n                            raConfigProperties.put(key.substring(3), value);\n                        } else if (key.startsWith(\"mcf.\")) {\n                            mcfConfigProperties.put(key.substring(4), value);\n                        } else {\n                            mcfConfigProperties.put(key, value);\n                        }\n                    }\n                }\n            }\n\n            String mcfClass = null;\n\n            if (ra.getOutboundResourceadapter() != null) {\n                for (ConnectionDefinition cd :\n                        ra.getOutboundResourceadapter().getConnectionDefinitions()) {\n                    if (cd.getConnectionFactoryInterface().getValue().equals(cfInterface))\n                        mcfClass = cd.getManagedConnectionFactoryClass().getValue();\n                }\n            }\n\n\n            Security security = null;\n            if (securitySetting != null) {\n                if (\"\".equals(securitySetting)) {\n                    security = new SecurityImpl(null, null, false);\n                } else if (\"application\".equals(securitySetting)) {\n                    security = new SecurityImpl(null, null, true);\n                } else if (\"domain\".equals(securitySetting) && securitySettingDomain != null) {\n                    security = new SecurityImpl(securitySettingDomain, null, false);\n                } else if (\"domain-and-application\".equals(securitySetting) && securitySettingDomain != null) {\n                    security = new SecurityImpl(null, securitySettingDomain, false);\n                }\n            }\n\n            if (security == null) {\n                SUBSYSTEM_RA_LOGGER.noSecurityDefined(jndiName);\n            }\n\n\n            Pool pool = null;\n            Boolean isXA = Boolean.FALSE;\n            if (transactionSupport == TransactionSupport.TransactionSupportLevel.XATransaction) {\n                pool = new XaPoolImpl(minPoolSize < 0 ? Defaults.MIN_POOL_SIZE : minPoolSize, Defaults.INITIAL_POOL_SIZE, maxPoolSize < 0 ? Defaults.MAX_POOL_SIZE : maxPoolSize,\n                        Defaults.PREFILL, Defaults.USE_STRICT_MIN, Defaults.FLUSH_STRATEGY,\n                        null, Defaults.IS_SAME_RM_OVERRIDE, Defaults.INTERLEAVING, Defaults.PAD_XID, Defaults.WRAP_XA_RESOURCE, Defaults.NO_TX_SEPARATE_POOL);\n                isXA = Boolean.TRUE;\n            } else {\n                pool = new PoolImpl(minPoolSize < 0 ? Defaults.MIN_POOL_SIZE : minPoolSize, Defaults.INITIAL_POOL_SIZE, maxPoolSize < 0 ? Defaults.MAX_POOL_SIZE : maxPoolSize,\n                        Defaults.PREFILL, Defaults.USE_STRICT_MIN, Defaults.FLUSH_STRATEGY, null);\n            }\n\n            TransactionSupportEnum transactionSupportValue = TransactionSupportEnum.NoTransaction;\n            if (transactionSupport == TransactionSupport.TransactionSupportLevel.XATransaction) {\n                transactionSupportValue = TransactionSupportEnum.XATransaction;\n            } else if (transactionSupport == TransactionSupport.TransactionSupportLevel.LocalTransaction) {\n                transactionSupportValue = TransactionSupportEnum.LocalTransaction;\n            }\n\n            org.jboss.jca.common.api.metadata.resourceadapter.ConnectionDefinition cd = new org.jboss.jca.common.metadata.resourceadapter.ConnectionDefinitionImpl(mcfConfigProperties, mcfClass, jndiName, poolName(cfInterface),\n                    Boolean.TRUE, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE, Defaults.CONNECTABLE, Defaults.TRACKING,\n                    pool, null, null, security, null, isXA);\n\n            Activation activation = new ActivationImpl(null, null, transactionSupportValue, Collections.singletonList(cd), Collections.<AdminObject>emptyList(), raConfigProperties, Collections.<String>emptyList(), null, null);\n\n            String serviceName = jndiName;\n            serviceName = serviceName.replace(':', '_');\n            serviceName = serviceName.replace('/', '_');\n\n            ResourceAdapterActivatorService activator = new ResourceAdapterActivatorService(cmd, activation, module.getClassLoader(), serviceName);\n            activator.setCreateBinderService(false);\n            activator.setBindInfo(bindInfo);\n            ServiceTarget serviceTarget = context.getChildTarget();\n            ServiceName activatorServiceName = ConnectorServices.RESOURCE_ADAPTER_ACTIVATOR_SERVICE.append(serviceName);\n            ServiceBuilder connectionFactoryServiceBuilder = serviceTarget\n                    .addService(activatorServiceName, activator)\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, AS7MetadataRepository.class,\n                            activator.getMdrInjector())\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class,\n                            activator.getRaRepositoryInjector())\n                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                            activator.getManagementRepositoryInjector())\n                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                            ResourceAdapterDeploymentRegistry.class, activator.getRegistryInjector())\n                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE,\n                            JcaSubsystemConfiguration.class, activator.getConfigInjector())\n                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                            activator.getSubjectFactoryInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class,\n                            activator.getCcmInjector())\n                    .addDependency(NamingService.SERVICE_NAME)\n                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                            activator.getTxIntegrationInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER)\n                    .addDependency(ConnectorServices.BOOTSTRAP_CONTEXT_SERVICE.append(\"default\"));\n\n\n            connectionFactoryServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n    }","id":101281,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        ROOT_LOGGER.debugf(\"started DirectConnectionFactoryActivatorService %s\", context.getController().getName());\n        String cfInterface = null;\n\n\n        try {\n\n            Connector cmd = mdr.getValue().getResourceAdapter(raId);\n\n            ResourceAdapter ra = cmd.getResourceadapter();\n            if (ra.getOutboundResourceadapter() != null) {\n                for (ConnectionDefinition cd : ra.getOutboundResourceadapter().getConnectionDefinitions()) {\n                    if (cd.getConnectionFactoryInterface().getValue().equals(interfaceName))\n                        cfInterface = cd.getConnectionFactoryInterface().getValue();\n                }\n            }\n\n\n            if (cfInterface == null || !cfInterface.equals(interfaceName)) {\n                throw ConnectorLogger.ROOT_LOGGER.invalidConnectionFactory(cfInterface, resourceAdapter, jndiName);\n            }\n\n            Map<String, String> raConfigProperties = new HashMap<String, String>();\n            Map<String, String> mcfConfigProperties = new HashMap<String, String>();\n            String securitySetting = null;\n            String securitySettingDomain = null;\n\n            if (properties != null) {\n                for (Map.Entry<String,String> prop : properties.entrySet()) {\n                    String key = prop.getKey();\n                    String value = prop.getValue();\n                    if (key.startsWith(\"ironjacamar.security\")) {\n                        securitySetting = value;\n                    } else if (key.startsWith(\"ironjacamar.security.domain\")) {\n                        securitySettingDomain = value;\n                    } else {\n                        if (key.startsWith(\"ra.\")) {\n                            raConfigProperties.put(key.substring(3), value);\n                        } else if (key.startsWith(\"mcf.\")) {\n                            mcfConfigProperties.put(key.substring(4), value);\n                        } else {\n                            mcfConfigProperties.put(key, value);\n                        }\n                    }\n                }\n            }\n\n            String mcfClass = null;\n\n            if (ra.getOutboundResourceadapter() != null) {\n                for (ConnectionDefinition cd :\n                        ra.getOutboundResourceadapter().getConnectionDefinitions()) {\n                    if (cd.getConnectionFactoryInterface().getValue().equals(cfInterface))\n                        mcfClass = cd.getManagedConnectionFactoryClass().getValue();\n                }\n            }\n\n\n            Security security = null;\n            if (securitySetting != null) {\n                if (\"\".equals(securitySetting)) {\n                    security = new SecurityImpl(null, null, false);\n                } else if (\"application\".equals(securitySetting)) {\n                    security = new SecurityImpl(null, null, true);\n                } else if (\"domain\".equals(securitySetting) && securitySettingDomain != null) {\n                    security = new SecurityImpl(securitySettingDomain, null, false);\n                } else if (\"domain-and-application\".equals(securitySetting) && securitySettingDomain != null) {\n                    security = new SecurityImpl(null, securitySettingDomain, false);\n                }\n            }\n\n            if (security == null) {\n                SUBSYSTEM_RA_LOGGER.noSecurityDefined(jndiName);\n            }\n\n\n            Pool pool = null;\n            Boolean isXA = Boolean.FALSE;\n            if (transactionSupport == TransactionSupport.TransactionSupportLevel.XATransaction) {\n                pool = new XaPoolImpl(minPoolSize < 0 ? Defaults.MIN_POOL_SIZE : minPoolSize, Defaults.INITIAL_POOL_SIZE, maxPoolSize < 0 ? Defaults.MAX_POOL_SIZE : maxPoolSize,\n                        Defaults.PREFILL, Defaults.USE_STRICT_MIN, Defaults.FLUSH_STRATEGY,\n                        null, Defaults.IS_SAME_RM_OVERRIDE, Defaults.INTERLEAVING, Defaults.PAD_XID, Defaults.WRAP_XA_RESOURCE, Defaults.NO_TX_SEPARATE_POOL);\n                isXA = Boolean.TRUE;\n            } else {\n                pool = new PoolImpl(minPoolSize < 0 ? Defaults.MIN_POOL_SIZE : minPoolSize, Defaults.INITIAL_POOL_SIZE, maxPoolSize < 0 ? Defaults.MAX_POOL_SIZE : maxPoolSize,\n                        Defaults.PREFILL, Defaults.USE_STRICT_MIN, Defaults.FLUSH_STRATEGY, null);\n            }\n\n            TransactionSupportEnum transactionSupportValue = TransactionSupportEnum.NoTransaction;\n            if (transactionSupport == TransactionSupport.TransactionSupportLevel.XATransaction) {\n                transactionSupportValue = TransactionSupportEnum.XATransaction;\n            } else if (transactionSupport == TransactionSupport.TransactionSupportLevel.LocalTransaction) {\n                transactionSupportValue = TransactionSupportEnum.LocalTransaction;\n            }\n\n            org.jboss.jca.common.api.metadata.resourceadapter.ConnectionDefinition cd = new org.jboss.jca.common.metadata.resourceadapter.ConnectionDefinitionImpl(mcfConfigProperties, mcfClass, jndiName, poolName(cfInterface),\n                    Boolean.TRUE, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE, Boolean.TRUE, Defaults.CONNECTABLE, Defaults.TRACKING,\n                    pool, null, null, security, null, isXA);\n\n            Activation activation = new ActivationImpl(null, null, transactionSupportValue, Collections.singletonList(cd), Collections.<AdminObject>emptyList(), raConfigProperties, Collections.<String>emptyList(), null, null);\n\n            String serviceName = jndiName;\n            serviceName = serviceName.replace(':', '_');\n            serviceName = serviceName.replace('/', '_');\n\n            ResourceAdapterActivatorService activator = new ResourceAdapterActivatorService(cmd, activation, module.getClassLoader(), serviceName);\n            activator.setCreateBinderService(false);\n            activator.setBindInfo(bindInfo);\n            ServiceTarget serviceTarget = context.getChildTarget();\n            ServiceName activatorServiceName = ConnectorServices.RESOURCE_ADAPTER_ACTIVATOR_SERVICE.append(serviceName);\n            ServiceBuilder connectionFactoryServiceBuilder = serviceTarget\n                    .addService(activatorServiceName, activator)\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, AS7MetadataRepository.class,\n                            activator.getMdrInjector())\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class,\n                            activator.getRaRepositoryInjector())\n                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class,\n                            activator.getManagementRepositoryInjector())\n                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                            ResourceAdapterDeploymentRegistry.class, activator.getRegistryInjector())\n                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE,\n                            JcaSubsystemConfiguration.class, activator.getConfigInjector())\n                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                            activator.getSubjectFactoryInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class,\n                            activator.getCcmInjector())\n                    .addDependency(NamingService.SERVICE_NAME)\n                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                            activator.getTxIntegrationInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER)\n                    .addDependency(ConnectorServices.BOOTSTRAP_CONTEXT_SERVICE.append(\"default\"));\n\n\n            connectionFactoryServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * create an instance *\n     */\n    public DirectConnectionFactoryActivatorService(String jndiName, String interfaceName, String resourceAdapter,\n                                                   String raId, int maxPoolSize, int minPoolSize,\n                                                   String[] properties, TransactionSupport.TransactionSupportLevel transactionSupport,\n                                                   Module module, ContextNames.BindInfo bindInfo) {\n        this.jndiName = jndiName;\n        this.interfaceName = interfaceName;\n        this.resourceAdapter = resourceAdapter;\n        this.raId = raId;\n        this.maxPoolSize = maxPoolSize;\n        this.minPoolSize = minPoolSize;\n        this.properties = properties;\n        if (transactionSupport == null)\n            transactionSupport = TransactionSupport.TransactionSupportLevel.NoTransaction;\n        this.transactionSupport = transactionSupport;\n        this.module = module;\n        this.bindInfo = bindInfo;\n    }","id":101282,"modified_method":"/**\n     * create an instance *\n     */\n    public DirectConnectionFactoryActivatorService(String jndiName, String interfaceName, String resourceAdapter,\n                                                   String raId, int maxPoolSize, int minPoolSize,\n                                                   Map<String, String> properties, TransactionSupport.TransactionSupportLevel transactionSupport,\n                                                   Module module, ContextNames.BindInfo bindInfo) {\n        this.jndiName = jndiName;\n        this.interfaceName = interfaceName;\n        this.resourceAdapter = resourceAdapter;\n        this.raId = raId;\n        this.maxPoolSize = maxPoolSize;\n        this.minPoolSize = minPoolSize;\n        this.properties = properties;\n        if (transactionSupport == null)\n            transactionSupport = TransactionSupport.TransactionSupportLevel.NoTransaction;\n        this.transactionSupport = transactionSupport;\n        this.module = module;\n        this.bindInfo = bindInfo;\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void activateProcessors(final DeploymentProcessorTarget updateContext) {\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_DSXML_DEPLOYMENT, new DsXmlDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_DATA_SOURCE_DEFINITION_ANNOTATION, new DataSourceDefinitionAnnotationParser());\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_DATASOURCE_REF, new DataSourceDefinitionDeploymentDescriptorParser());\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.FIRST_MODULE_USE, Phase.FIRST_MODULE_USE_DSXML_DEPLOYMENT, new DsXmlDeploymentInstallProcessor());\n    }","id":101283,"modified_method":"public void activateProcessors(final DeploymentProcessorTarget updateContext) {\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_DSXML_DEPLOYMENT, new DsXmlDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RESOURCE_DEF_ANNOTATION_DATA_SOURCE, new DataSourceDefinitionAnnotationProcessor());\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RESOURCE_DEF_XML_DATA_SOURCE, new DataSourceDefinitionDescriptorProcessor());\n        updateContext.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.FIRST_MODULE_USE, Phase.FIRST_MODULE_USE_DSXML_DEPLOYMENT, new DsXmlDeploymentInstallProcessor());\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(MailExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_MAIL_SESSION_DEFINITION_ANNOTATION, new MailSessionDefinitionAnnotationParser());\n                processorTarget.addDeploymentProcessor(MailExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_MAIL, new MailDependenciesProcessor());\n                processorTarget.addDeploymentProcessor(MailExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_MAIL_SESSION_REF, new MailSessionDeploymentDescriptorParser());\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","id":101284,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(MailExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RESOURCE_DEF_ANNOTATION_MAIL_SESSION, new MailSessionDefinitionAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(MailExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_MAIL, new MailDependenciesProcessor());\n                processorTarget.addDeploymentProcessor(MailExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RESOURCE_DEF_XML_MAIL_SESSION, new MailSessionDefinitionDescriptorProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                // keep the statements ordered by phase + priority\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_JMS_CONNECTION_FACTORY_RESOURCE_INJECTION, new DefaultJMSConnectionFactoryResourceReferenceProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_ANNOTATIONS, new MessagingJMSDefinitionAnnotationParser());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_MESSAGING_XML_RESOURCES, new MessagingXmlParsingDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_JMS, new MessagingDependencyProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_JMS_CDI_EXTENSIONS, new CDIDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_JMS_DEFINITION_DEPLOYMENT, new MessagingJMSDefinitionDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEFAULT_BINDINGS_JMS_CONNECTION_FACTORY, new DefaultJMSConnectionFactoryBindingProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_MESSAGING_XML_RESOURCES, new MessagingXmlInstallDeploymentUnitProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","id":101285,"modified_method":"@Override\n    protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                // keep the statements ordered by phase + priority\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_JMS_CONNECTION_FACTORY_RESOURCE_INJECTION, new DefaultJMSConnectionFactoryResourceReferenceProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RESOURCE_DEF_ANNOTATION_JMS_DESTINATION, new JMSDestinationDefinitionAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RESOURCE_DEF_ANNOTATION_JMS_CONNECTION_FACTORY, new JMSConnectionFactoryDefinitionAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_MESSAGING_XML_RESOURCES, new MessagingXmlParsingDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_JMS, new MessagingDependencyProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_JMS_CDI_EXTENSIONS, new CDIDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RESOURCE_DEF_XML_JMS_CONNECTION_FACTORY, new JMSConnectionFactoryDefinitionDescriptorProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RESOURCE_DEF_XML_JMS_DESTINATION, new JMSDestinationDefinitionDescriptorProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEFAULT_BINDINGS_JMS_CONNECTION_FACTORY, new DefaultJMSConnectionFactoryBindingProcessor());\n                processorTarget.addDeploymentProcessor(MessagingExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_MESSAGING_XML_RESOURCES, new MessagingXmlInstallDeploymentUnitProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //SecurityClient client = null;\n        try {\n            InitialContext ctx = new InitialContext();\n\n            //client = SecurityClientFactory.getSecurityClient();\n            //client.setSimple(\"user1\", \"password1\");\n            //client.login();\n\n            Object appAdmin = ctx.lookup(\"java:app/rardeployment/AppAdmin\");\n            if (appAdmin == null)\n               throw new ServletException(\"Failed to access AppAdmin\");\n\n            Object compAdmin = ctx.lookup(\"java:comp/rardeployment/CompAdmin\");\n            if (compAdmin == null)\n               throw new ServletException(\"Failed to access CompAdmin\");\n\n            Object moduleAdmin = ctx.lookup(\"java:module/rardeployment/ModuleAdmin\");\n            if (moduleAdmin == null)\n               throw new ServletException(\"Failed to access ModuleAdmin\");\n\n            Object globalAdmin = ctx.lookup(\"java:global/rardeployment/GlobalAdmin\");\n            if (globalAdmin == null)\n               throw new ServletException(\"Failed to access GlobalAdmin\");\n\n            Object appCF = ctx.lookup(\"java:app/rardeployment/AppCF\");\n            if (appCF == null)\n               throw new ServletException(\"Failed to access AppCF\");\n\n            Object compCF = ctx.lookup(\"java:comp/rardeployment/CompCF\");\n            if (compCF == null)\n               throw new ServletException(\"Failed to access CompCF\");\n\n            Object moduleCF = ctx.lookup(\"java:module/rardeployment/ModuleCF\");\n            if (moduleCF == null)\n               throw new ServletException(\"Failed to access ModuleCF\");\n\n            Object globalCF = ctx.lookup(\"java:global/rardeployment/GlobalCF\");\n            if (globalCF == null)\n               throw new ServletException(\"Failed to access GlobalCF\");\n\n        } catch (ServletException se) {\n            log.error(se);\n            throw se;\n        } catch (Exception e) {\n            log.error(e);\n            throw new ServletException(\"Failed to access resource adapter\", e);\n        } finally {\n            //client.logout();\n        }\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        out.print(\"RARServlet OK\");\n        out.close();\n    }","id":101286,"modified_method":"protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //SecurityClient client = null;\n        try {\n            InitialContext ctx = new InitialContext();\n\n            //client = SecurityClientFactory.getSecurityClient();\n            //client.setSimple(\"user1\", \"password1\");\n            //client.login();\n\n            Object appAdmin = ctx.lookup(\"java:app/rardeployment/AppAdmin\");\n            if (appAdmin == null)\n               throw new ServletException(\"Failed to access AppAdmin\");\n\n            Object compAdmin = ctx.lookup(\"java:comp/rardeployment/CompAdmin\");\n            if (compAdmin == null)\n               throw new ServletException(\"Failed to access CompAdmin\");\n\n            Object moduleAdmin = ctx.lookup(\"java:module/rardeployment/ModuleAdmin\");\n            if (moduleAdmin == null)\n               throw new ServletException(\"Failed to access ModuleAdmin\");\n\n            Object globalAdmin = ctx.lookup(\"java:global/rardeployment/GlobalAdmin\");\n            if (globalAdmin == null)\n               throw new ServletException(\"Failed to access GlobalAdmin\");\n\n            Object appCF = ctx.lookup(\"java:app/rardeployment/AppCF\");\n            if (appCF == null)\n               throw new ServletException(\"Failed to access AppCF\");\n\n            Object compCF = ctx.lookup(\"java:comp/rardeployment/CompCF\");\n            if (compCF == null)\n               throw new ServletException(\"Failed to access CompCF\");\n\n            Object moduleCF = ctx.lookup(\"java:module/rardeployment/ModuleCF\");\n            if (moduleCF == null)\n               throw new ServletException(\"Failed to access ModuleCF\");\n\n            Object globalCF = ctx.lookup(\"java:global/rardeployment/GlobalCF\");\n            if (globalCF == null)\n               throw new ServletException(\"Failed to access GlobalCF\");\n\n            if (xmlAO == null)\n                throw new ServletException(\"Failed to retrieve AO defined in xml descriptor\");\n\n            if (xmlCF == null)\n                throw new ServletException(\"Failed to retrieve CF defined in xml descriptor\");\n\n        } catch (ServletException se) {\n            log.error(se);\n            throw se;\n        } catch (Exception e) {\n            log.error(e);\n            throw new ServletException(\"Failed to access resource adapter\", e);\n        } finally {\n            //client.logout();\n        }\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        out.print(\"RARServlet OK\");\n        out.close();\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void activateProcessors(final DeploymentProcessorTarget updateContext) {\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_RAR, new RaStructureProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_JDBC_DRIVER, new StructureDriverProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RA_DEPLOYMENT, new RaDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_IRON_JACAMAR_DEPLOYMENT,\n                new IronJacamarDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_RAR_CONFIG, new RarDependencyProcessor(appclient));\n                if (!appclient)\n                    updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RAR_SERVICES_DEPS, new RaXmlDependencyProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RA_NATIVE, new RaNativeProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RA_DEPLOYMENT, new ParsedRaDeploymentProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RA_XML_DEPLOYMENT, new RaXmlDeploymentProcessor(\n                mdrService.getValue()));\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_CONNECTION_FACTORY_DEFINITION_ANNOTATION,\n                                             new ConnectionFactoryDefinitionAnnotationParser());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_ADMIN_OBJECT_DEFINITION_ANNOTATION,\n                                             new AdministeredObjectDefinitionAnnotationParser());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_JDBC_DRIVER, new DriverProcessor());\n    }","id":101287,"modified_method":"public void activateProcessors(final DeploymentProcessorTarget updateContext) {\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_RAR, new RaStructureProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_JDBC_DRIVER, new StructureDriverProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RA_DEPLOYMENT, new RaDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_IRON_JACAMAR_DEPLOYMENT,\n                new IronJacamarDeploymentParsingProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RESOURCE_DEF_ANNOTATION_CONNECTION_FACTORY,\n                new ConnectionFactoryDefinitionAnnotationProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_RESOURCE_DEF_ANNOTATION_ADMINISTERED_OBJECT,\n                new AdministeredObjectDefinitionAnnotationProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_RAR_CONFIG, new RarDependencyProcessor(appclient));\n                if (!appclient)\n                    updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RAR_SERVICES_DEPS, new RaXmlDependencyProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RESOURCE_DEF_XML_CONNECTION_FACTORY,\n                new ConnectionFactoryDefinitionDescriptorProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_RESOURCE_DEF_XML_ADMINISTERED_OBJECT,\n                new AdministeredObjectDefinitionDescriptorProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RA_NATIVE, new RaNativeProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RA_DEPLOYMENT, new ParsedRaDeploymentProcessor());\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RA_XML_DEPLOYMENT, new RaXmlDeploymentProcessor(\n                mdrService.getValue()));\n        updateContext.addDeploymentProcessor(ResourceAdaptersExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_JDBC_DRIVER, new DriverProcessor());\n    }","commit_id":"3a3c044e344b542dbdce5f4e6f7e5978e6944714","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * @see org.jboss.webservices.integration.deployers.deployment.DeploymentModelBuilder#newDeploymentModel(DeploymentUnit)\n     *\n     * @param unit deployment unit\n     */\n    public final void newDeploymentModel(final DeploymentUnit unit) {\n        final ArchiveDeployment dep;\n        if (unit.hasAttachment(DEPLOYMENT_KEY)) {\n            dep = (ArchiveDeployment) unit.getAttachment(DEPLOYMENT_KEY);\n        } else {\n            try {\n                dep = this.newDeployment(unit);\n            } catch (DeploymentUnitProcessingException e) {\n                throw new RuntimeException(e);\n            }\n            dep.addAttachment(DeploymentUnit.class, unit);\n            unit.putAttachment(DEPLOYMENT_KEY, dep);\n            // propagate\n            final JBossWebMetaData webMD = getJBossWebMetaData(unit);\n            dep.addAttachment(JBossWebMetaData.class, webMD);\n            // propagate\n            final WebservicesMetaData webservicesMD = getOptionalAttachment(unit, WEBSERVICES_METADATA_KEY);\n            dep.addAttachment(WebservicesMetaData.class, webservicesMD);\n            // propagate\n            final JBossWebservicesMetaData jbossWebservicesMD = getOptionalAttachment(unit, JBOSS_WEBSERVICES_METADATA_KEY);\n            dep.addAttachment(JBossWebservicesMetaData.class, jbossWebservicesMD);\n            // propagate\n            final JAXWSDeployment jaxwsDeployment = getOptionalAttachment(unit, JAXWS_ENDPOINTS_KEY);\n            dep.addAttachment(JAXWSDeployment.class, jaxwsDeployment);\n        }\n\n        this.build(dep, unit);\n    }","id":101288,"modified_method":"/**\n     * @see org.jboss.webservices.integration.deployers.deployment.DeploymentModelBuilder#newDeploymentModel(DeploymentUnit)\n     *\n     * @param unit deployment unit\n     */\n    public final void newDeploymentModel(final DeploymentUnit unit) {\n        final ArchiveDeployment dep;\n        if (unit.hasAttachment(DEPLOYMENT_KEY)) {\n            dep = (ArchiveDeployment) unit.getAttachment(DEPLOYMENT_KEY);\n        } else {\n            try {\n                dep = this.newDeployment(unit);\n            } catch (DeploymentUnitProcessingException e) {\n                throw new RuntimeException(e);\n            }\n            dep.addAttachment(DeploymentUnit.class, unit);\n            unit.putAttachment(DEPLOYMENT_KEY, dep);\n            // propagate\n            final JBossWebMetaData webMD = getJBossWebMetaData(unit);\n            dep.addAttachment(JBossWebMetaData.class, webMD);\n            // propagate\n            final WebservicesMetaData webservicesMD = getOptionalAttachment(unit, WEBSERVICES_METADATA_KEY);\n            dep.addAttachment(WebservicesMetaData.class, webservicesMD);\n            // propagate\n            final JBossWebservicesMetaData jbossWebservicesMD = getOptionalAttachment(unit, JBOSS_WEBSERVICES_METADATA_KEY);\n            dep.addAttachment(JBossWebservicesMetaData.class, jbossWebservicesMD);\n            // propagate\n            final JAXWSDeployment jaxwsDeployment = getOptionalAttachment(unit, JAXWS_ENDPOINTS_KEY);\n            dep.addAttachment(JAXWSDeployment.class, jaxwsDeployment);\n            // propagate\n            final JAXRPCDeployment jaxrpcDeployment = getOptionalAttachment(unit, JAXRPC_ENDPOINTS_KEY);\n            dep.addAttachment(JAXRPCDeployment.class, jaxrpcDeployment);\n            // propagate\n            final EjbJarMetaData ejbJarMD = getOptionalAttachment(unit, EjbDeploymentAttachmentKeys.EJB_JAR_METADATA);\n            dep.addAttachment(EjbJarMetaData.class, ejbJarMD);\n        }\n\n        this.build(dep, unit);\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Build container independent meta data.\n     *\n     * @param dep webservice deployment\n     */\n    @Override\n    public void start(final Deployment dep) {\n        if (WSHelper.isJseDeployment(dep)) {\n            if (WSHelper.hasAttachment(dep, JBossWebMetaData.class)) {\n                this.log.debug(\"Creating JBoss agnostic JSE meta data for deployment: \" + dep.getSimpleName());\n                final JSEArchiveMetaData jseMetaData = this.metaDataBuilderJSE.create(dep);\n                dep.addAttachment(JSEArchiveMetaData.class, jseMetaData);\n            }\n        }\n        if (WSHelper.isJaxwsEjbDeployment(dep)) {\n            this.log.debug(\"Creating JBoss agnostic EJB3 meta data for deployment: \" + dep.getSimpleName());\n            final EJBArchiveMetaData ejbMetaData = this.metaDataBuilderEJB3.create(dep);\n            dep.addAttachment(EJBArchiveMetaData.class, ejbMetaData);\n        }\n//      else if (WSHelper.isJaxrpcEjbDeployment(dep))\n//      {\n//         this.log.debug(\"Creating JBoss agnostic EJB21 meta data for deployment: \" + dep.getSimpleName());\n//         final EJBArchiveMetaData ejbMetaData = this.metaDataBuilderEJB21.create(dep);\n//         dep.addAttachment(EJBArchiveMetaData.class, ejbMetaData);\n//      }\n   }","id":101289,"modified_method":"/**\n     * Build container independent meta data.\n     *\n     * @param dep webservice deployment\n     */\n    @Override\n    public void start(final Deployment dep) {\n        if (WSHelper.isJseDeployment(dep)) {\n            if (WSHelper.hasAttachment(dep, JBossWebMetaData.class)) {\n                this.log.debug(\"Creating JBoss agnostic JSE meta data for deployment: \" + dep.getSimpleName());\n                final JSEArchiveMetaData jseMetaData = this.metaDataBuilderJSE.create(dep);\n                dep.addAttachment(JSEArchiveMetaData.class, jseMetaData);\n            }\n        }\n        if (WSHelper.isJaxwsEjbDeployment(dep)) {\n            this.log.debug(\"Creating JBoss agnostic EJB3 meta data for deployment: \" + dep.getSimpleName());\n            final EJBArchiveMetaData ejbMetaData = this.metaDataBuilderEJB3.create(dep);\n            dep.addAttachment(EJBArchiveMetaData.class, ejbMetaData);\n        }\n        else if (WSHelper.isJaxrpcEjbDeployment(dep)) {\n            this.log.debug(\"Creating JBoss agnostic EJB21 meta data for deployment: \" + dep.getSimpleName());\n            final EJBArchiveMetaData ejbMetaData = this.metaDataBuilderEJB21.create(dep);\n            dep.addAttachment(EJBArchiveMetaData.class, ejbMetaData);\n        }\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates new JAXRPC EJB21 deployment and registers it with deployment unit.\n     *\n     * @param dep webservice deployment\n     * @param unit deployment unit\n     */\n    @Override\n    protected void build(final Deployment dep, final DeploymentUnit unit) {\n//        final JBossMetaData jbmd = this.getAndPropagateAttachment(JBossMetaData.class, unit, dep);\n//        final WebservicesMetaData wsMetaData = this.getAndPropagateAttachment(WebservicesMetaData.class, unit, dep);\n//        this.getAndPropagateAttachment(WebServiceDeployment.class, unit, dep);\n//\n//        this.log.debug(\"Creating JAXRPC EJB21 endpoints meta data model\");\n//        for (final WebserviceDescriptionMetaData webserviceDescriptionMD : wsMetaData.getWebserviceDescriptions()) {\n//            for (final PortComponentMetaData portComponentMD : webserviceDescriptionMD.getPortComponents()) {\n//                final String ejbName = portComponentMD.getEjbLink();\n//                this.log.debug(\"EJB21 name: \" + ejbName);\n//                final JBossEnterpriseBeanMetaData beanMetaData = jbmd.getEnterpriseBean(ejbName);\n//                final String ejbClass = beanMetaData.getEjbClass();\n//                this.log.debug(\"EJB21 class: \" + ejbClass);\n//\n//                this.newHttpEndpoint(ejbClass, ejbName, dep);\n//            }\n//        }\n    }","id":101290,"modified_method":"/**\n     * Creates new JAXRPC EJB21 deployment and registers it with deployment unit.\n     *\n     * @param dep webservice deployment\n     * @param unit deployment unit\n     */\n    @Override\n    protected void build(final Deployment dep, final DeploymentUnit unit) {\n        log.debug(\"Creating JAXRPC EJB21 endpoints meta data model\");\n        for (final EJBEndpoint ejbEndpoint : getJaxrpcEjbs(unit)) {\n            final String ejbName = ejbEndpoint.getName();\n            log.debug(\"EJB3 name: \" + ejbName);\n            final String ejbClass = ejbEndpoint.getClassName();\n            log.debug(\"EJB3 class: \" + ejbClass);\n            final Endpoint ep = newHttpEndpoint(ejbClass, ejbName, dep);\n            ep.setProperty(EJB_COMPONENT_VIEW_NAME, ejbEndpoint.getComponentViewName());\n        }\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n    * Returns WebServiceContext associated with this invocation.\n    *\n    * @param invocation current invocation\n    * @return web service context or null if not available\n    */\n   private WebServiceContext getWebServiceContext(final Invocation invocation) {\n      final InvocationContext invocationContext = invocation.getInvocationContext();\n      return invocationContext.getAttachment(WebServiceContext.class);\n   }","id":101291,"modified_method":"private static WebServiceContext getWebServiceContext(final Invocation invocation) {\n      final InvocationContext invocationContext = invocation.getInvocationContext();\n      return invocationContext.getAttachment(WebServiceContext.class);\n   }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n    * Injects webservice context on target bean.\n    *\n    *  @param invocation current invocation\n    */\n   @Override\n   public void onBeforeInvocation(final Invocation invocation) {\n      final WebServiceContext wsContext = getWebServiceContext(invocation);\n      ThreadLocalAwareWebServiceContext.getInstance().setMessageContext(wsContext);\n   }","id":101292,"modified_method":"@Override\n   public void onBeforeInvocation(final Invocation invocation) {\n      final WebServiceContext wsContext = getWebServiceContext(invocation);\n      ThreadLocalAwareWebServiceContext.getInstance().setMessageContext(wsContext);\n   }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n    * Cleanups injected webservice context on target bean.\n    *\n    * @param invocation current invocation\n    */\n   @Override\n   public void onAfterInvocation(final Invocation invocation) {\n      ThreadLocalAwareWebServiceContext.getInstance().setMessageContext(null);\n   }","id":101293,"modified_method":"@Override\n   public void onAfterInvocation(final Invocation invocation) {\n      ThreadLocalAwareWebServiceContext.getInstance().setMessageContext(null);\n   }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Returns invocation handler associated with invocation type.\n     *\n     * @param type invocation type\n     * @return invocation handler\n     */\n    public InvocationHandler newInvocationHandler(final InvocationType type) {\n        InvocationHandler handler = null;\n\n        switch (type) {\n            case JAXRPC_JSE:\n                handler = new InvocationHandlerJAXRPC();\n                break;\n// TODO !!\n//            case JAXRPC_EJB21:\n//                handler = new InvocationHandlerEJB21();\n//                break;\n//            case JAXRPC_MDB21:\n//                handler = new InvocationHandlerMDB21();\n//                break;\n            case JAXWS_JSE:\n                handler = new InvocationHandlerJAXWS();\n                break;\n            case JAXWS_EJB3:\n                handler = new InvocationHandlerEJB3();\n                break;\n//            case JAXWS_MDB3:\n//                handler = new InvocationHandlerMDB3();\n//                break;\n            default:\n                throw new IllegalArgumentException(\"Unable to resolve spi.invocation.InvocationHandler for type \" + type);\n        }\n\n        return handler;\n    }","id":101294,"modified_method":"/**\n     * Returns invocation handler associated with invocation type.\n     *\n     * @param type invocation type\n     * @return invocation handler\n     */\n    public InvocationHandler newInvocationHandler(final InvocationType type) {\n        InvocationHandler handler = null;\n\n        switch (type) {\n            case JAXWS_JSE:\n                handler = new InvocationHandlerJAXWS();\n                break;\n            case JAXWS_EJB3:\n                handler = new InvocationHandlerEJB3();\n                break;\n            case JAXRPC_JSE:\n                handler = new InvocationHandlerJAXRPC();\n                break;\n            case JAXRPC_EJB21:\n                handler = new InvocationHandlerEJB21();\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unable to resolve spi.invocation.InvocationHandler for type \" + type);\n        }\n\n        return handler;\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * @see AbstractMetaDataBuilderEJB#buildEnterpriseBeansMetaData(Deployment,\n     *      EJBArchiveMetaData)\n     *\n     * @param dep\n     *            webservice deployment\n     * @param ejbArchiveMD\n     *            EJB archive meta data\n     */\n    @Override\n    protected void buildEnterpriseBeansMetaData(final Deployment dep, final EJBArchiveMetaData ejbArchiveMD) {\n        if (!WSHelper.isJaxwsJseDeployment(dep)) { // [AS7-1605] support\n            final JBossWebMetaData jbossWebMD = WSHelper.getOptionalAttachment(dep, JBossWebMetaData.class);\n            final String contextRoot = getContextRoot(dep, jbossWebMD);\n            if (contextRoot != null) {\n                final JSEArchiveMetaData jseArchiveMD = new JSEArchiveMetaData();\n                jseArchiveMD.setContextRoot(contextRoot);\n                dep.addAttachment(JSEArchiveMetaData.class, jseArchiveMD);\n            }\n        }\n\n        final JAXWSDeployment ejb3Deployment = WSHelper.getRequiredAttachment(dep, JAXWSDeployment.class);\n        final List<EJBMetaData> wsEjbsMD = new LinkedList<EJBMetaData>();\n        final JBossWebservicesMetaData jbossWebservicesMD = WSHelper.getOptionalAttachment(dep, JBossWebservicesMetaData.class);\n\n        for (final EJBEndpoint jbossEjbMD : ejb3Deployment.getEjbEndpoints()) {\n            this.buildEnterpriseBeanMetaData(wsEjbsMD, jbossEjbMD, jbossWebservicesMD);\n        }\n\n        ejbArchiveMD.setEnterpriseBeans(wsEjbsMD);\n    }","id":101295,"modified_method":"@Override\n    protected void buildEnterpriseBeansMetaData(final Deployment dep, final EJBArchiveMetaData ejbArchiveMD) {\n        if (!WSHelper.isJaxwsJseDeployment(dep)) { // [AS7-1605] support\n            final JBossWebMetaData jbossWebMD = WSHelper.getOptionalAttachment(dep, JBossWebMetaData.class);\n            final String contextRoot = getContextRoot(dep, jbossWebMD);\n            if (contextRoot != null) {\n                final JSEArchiveMetaData jseArchiveMD = new JSEArchiveMetaData();\n                jseArchiveMD.setContextRoot(contextRoot);\n                dep.addAttachment(JSEArchiveMetaData.class, jseArchiveMD);\n            }\n        }\n\n        final JAXWSDeployment jaxwsDeployment = WSHelper.getRequiredAttachment(dep, JAXWSDeployment.class);\n        final List<EJBMetaData> wsEjbsMD = new LinkedList<EJBMetaData>();\n        final JBossWebservicesMetaData jbossWebservicesMD = WSHelper.getOptionalAttachment(dep, JBossWebservicesMetaData.class);\n\n        for (final EJBEndpoint jbossEjbMD : jaxwsDeployment.getEjbEndpoints()) {\n            this.buildEnterpriseBeanMetaData(wsEjbsMD, jbossEjbMD, jbossWebservicesMD);\n        }\n\n        ejbArchiveMD.setEnterpriseBeans(wsEjbsMD);\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Constructor.\n     */\n    MetaDataBuilderEJB3() {\n        super();\n    }","id":101296,"modified_method":"MetaDataBuilderEJB3() {\n        super();\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void activate(final DeploymentProcessorTarget processorTarget, final boolean appclient) {\n        // Add a EEResourceReferenceProcessor which handles @Resource references of type WebServiceContext.\n        // Note that we do it here instead of a DUP because the @Resource reference processor for WebServiceContext *isn't*\n        // per DU\n        EEResourceReferenceProcessorRegistry.registerResourceReferenceProcessor(new WebServiceContextResourceProcessor());\n        processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_WS_REF_DESCRIPTOR, new WSRefDDProcessor());\n        processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_WS_REF_ANNOTATION, new WSRefAnnotationProcessor());\n        if (!appclient) {\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEBSERVICES_XML, new WebservicesDescriptorDeploymentProcessor());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEBSERVICES_XML, new JBossWebservicesDescriptorDeploymentProcessor());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXWS_HANDLER_CHAIN_ANNOTATION, new WSHandlerChainAnnotationProcessor());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WS_JMS_INTEGRATION, new WSIntegrationProcessorJAXWS_JMS());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXWS_ENDPOINT_CREATE_COMPONENT_DESCRIPTIONS, new WSIntegrationProcessorJAXWS_POJO());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXWS_HANDLER_CREATE_COMPONENT_DESCRIPTIONS, new WSIntegrationProcessorJAXWS_HANDLER());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WS_EJB_INTEGRATION, new WSIntegrationProcessorJAXWS_EJB());\n            processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WS, new WSDependenciesProcessor());\n            //processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_JAXRPC, new WSJAXRPCDependenciesDeploymentProcessor());\n            processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WS_UNIVERSAL_META_DATA_MODEL, new WSModelDeploymentProcessor());\n            addDeploymentProcessors(processorTarget, Phase.INSTALL, Phase.INSTALL_WS_DEPLOYMENT_ASPECTS);\n        }\n    }","id":101297,"modified_method":"static void activate(final DeploymentProcessorTarget processorTarget, final boolean appclient) {\n        // Add a EEResourceReferenceProcessor which handles @Resource references of type WebServiceContext.\n        // Note that we do it here instead of a DUP because the @Resource reference processor for WebServiceContext *isn't*\n        // per DU\n        EEResourceReferenceProcessorRegistry.registerResourceReferenceProcessor(new WebServiceContextResourceProcessor());\n        processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_WS_REF_DESCRIPTOR, new WSRefDDProcessor());\n        processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_WS_REF_ANNOTATION, new WSRefAnnotationProcessor());\n        if (!appclient) {\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEBSERVICES_XML, new WebservicesDescriptorDeploymentProcessor());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEBSERVICES_XML, new JBossWebservicesDescriptorDeploymentProcessor());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXWS_EJB_INTEGRATION, new WSIntegrationProcessorJAXWS_EJB());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXRPC_EJB_INTEGRATION, new WSIntegrationProcessorJAXRPC_EJB());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXWS_HANDLER_CHAIN_ANNOTATION, new WSHandlerChainAnnotationProcessor());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WS_JMS_INTEGRATION, new WSIntegrationProcessorJAXWS_JMS());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXWS_ENDPOINT_CREATE_COMPONENT_DESCRIPTIONS, new WSIntegrationProcessorJAXWS_POJO());\n            processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JAXWS_HANDLER_CREATE_COMPONENT_DESCRIPTIONS, new WSIntegrationProcessorJAXWS_HANDLER());\n            processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WS, new WSDependenciesProcessor());\n            //processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_JAXRPC, new WSJAXRPCDependenciesDeploymentProcessor());\n            processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WS_UNIVERSAL_META_DATA_MODEL, new WSModelDeploymentProcessor());\n            addDeploymentProcessors(processorTarget, Phase.INSTALL, Phase.INSTALL_WS_DEPLOYMENT_ASPECTS);\n        }\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static boolean isJaxrpcEjbDeployment(final DeploymentUnit unit) {\n        // TODO: implement\n        return false;\n    }","id":101298,"modified_method":"private static boolean isJaxrpcEjbDeployment(final DeploymentUnit unit) {\n        final boolean hasWebservicesMD = unit.hasAttachment(WEBSERVICES_METADATA_KEY);\n        final boolean hasEjbJarMD = unit.hasAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_METADATA);\n        return hasWebservicesMD && hasEjbJarMD;\n    }","commit_id":"af46ef66d371805a2708e35d08f50a3393626286","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext context, ModelNode operation, ResultHandler resultHandler) {\n\n        if(context instanceof NewBootOperationContext) {\n            final NewBootOperationContext bootContext = (NewBootOperationContext) context;\n            logger.info(\"Activating EE subsystem\");\n            bootContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_DEPLOYMENT, new EarStructureProcessor());\n        }\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":101299,"modified_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext context, ModelNode operation, ResultHandler resultHandler) {\n\n        if(context instanceof NewBootOperationContext) {\n            final NewBootOperationContext bootContext = (NewBootOperationContext) context;\n            logger.info(\"Activating EE subsystem\");\n            bootContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_DEPLOYMENT_INIT, new EarInitializationProcessor());\n            bootContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_APP_XML_PARSE, new ApplicationXmlParsingProcessor());\n            bootContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR, new EarStructureProcessor());\n            bootContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_MODULE_CONTEXT, new ModuleContextProcessor());\n            bootContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_APP_CONTEXT, new ApplicationContextProcessor());\n        }\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"1eceb20af6857a2fd16202bc58070d4c0e1db7e1","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext updateContext, ModelNode operation, ResultHandler resultHandler) {\n        final ModelNode config = operation.get(REQUEST_PROPERTIES, CommonAttributes.CONTAINER_CONFIG);\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        if(updateContext instanceof NewBootOperationContext) {\n            final NewBootOperationContext ctx = (NewBootOperationContext) updateContext;\n\n            final String defaultHost = operation.get(REQUEST_PROPERTIES).has(CommonAttributes.DEFAULT_HOST) ?\n                    operation.get(REQUEST_PROPERTIES).get(CommonAttributes.DEFAULT_HOST).asString() : DEFAULT_HOST;\n\n            final NewSharedWebMetaDataBuilder sharedWebBuilder = new NewSharedWebMetaDataBuilder(config.clone());\n            final NewSharedTldsMetaDataBuilder sharedTldsBuilder = new NewSharedTldsMetaDataBuilder(config.clone());\n\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR_DEPLOYMENT_INIT, new WarDeploymentInitializingProcessor());\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR_DEPLOYMENT, new WarStructureDeploymentProcessor(sharedWebBuilder.create(), sharedTldsBuilder.create()));\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT, new WebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT_FRAGMENT, new WebFragmentParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEB_DEPLOYMENT, new JBossWebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TLD_DEPLOYMENT, new TldParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WAR_MODULE, new WarClassloadingDependencyProcessor());\n            ctx.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_ANNOTATION_WAR, new WarAnnotationDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_SERVLET_INIT_DEPLOYMENT, new ServletContainerInitializerDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_METADATA, new WarMetaDataProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_DEPLOYMENT, new WarDeploymentProcessor(defaultHost));\n        }\n\n        updateContext.getSubModel().get(CommonAttributes.CONTAINER_CONFIG).set(config);\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":101300,"modified_method":"/** {@inheritDoc} */\n    public Cancellable execute(NewOperationContext updateContext, ModelNode operation, ResultHandler resultHandler) {\n        final ModelNode config = operation.get(REQUEST_PROPERTIES, CommonAttributes.CONTAINER_CONFIG);\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        if(updateContext instanceof NewBootOperationContext) {\n            final NewBootOperationContext ctx = (NewBootOperationContext) updateContext;\n\n            final String defaultHost = operation.get(REQUEST_PROPERTIES).has(CommonAttributes.DEFAULT_HOST) ?\n                    operation.get(REQUEST_PROPERTIES).get(CommonAttributes.DEFAULT_HOST).asString() : DEFAULT_HOST;\n\n            final NewSharedWebMetaDataBuilder sharedWebBuilder = new NewSharedWebMetaDataBuilder(config.clone());\n            final NewSharedTldsMetaDataBuilder sharedTldsBuilder = new NewSharedTldsMetaDataBuilder(config.clone());\n\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR_DEPLOYMENT_INIT, new WarDeploymentInitializingProcessor());\n            ctx.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR, new WarStructureDeploymentProcessor(sharedWebBuilder.create(), sharedTldsBuilder.create()));\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT, new WebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT_FRAGMENT, new WebFragmentParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEB_DEPLOYMENT, new JBossWebParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TLD_DEPLOYMENT, new TldParsingDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WAR_MODULE, new WarClassloadingDependencyProcessor());\n            ctx.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_ANNOTATION_WAR, new WarAnnotationDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_SERVLET_INIT_DEPLOYMENT, new ServletContainerInitializerDeploymentProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_METADATA, new WarMetaDataProcessor());\n            ctx.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_DEPLOYMENT, new WarDeploymentProcessor(defaultHost));\n        }\n\n        updateContext.getSubModel().get(CommonAttributes.CONTAINER_CONFIG).set(config);\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"1eceb20af6857a2fd16202bc58070d4c0e1db7e1","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static WebResource.Builder clientRequestAsAdmin(String path) {\n        return Client\n                .create()\n                .resource(PropertiesHolder.getProperty(Constants.zanataInstance\n                        .value()) + path)\n                .header(\"X-Auth-User\", \"admin\")\n                .header(\"X-Auth-Token\",\n                        PropertiesHolder.getProperty(Constants.zanataApiKey\n                                .value()))\n                .header(\"Content-Type\", \"application/xml\")\n                .header(\"Accept\", \"application/xml\");\n    }","id":101301,"modified_method":"private static Invocation.Builder clientRequestAsAdmin(String path) {\n        return new ResteasyClientBuilder()\n                .build()\n                .target(PropertiesHolder.getProperty(Constants.zanataInstance\n                        .value()) + path)\n                .request(MediaType.APPLICATION_XML_TYPE)\n                .header(\"X-Auth-User\", \"admin\")\n                .header(\"X-Auth-Token\",\n                        PropertiesHolder.getProperty(Constants.zanataApiKey\n                                .value()));\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static List<Integer> getStatusCodes(List<Future<Integer>> futures) {\n        return Lists.transform(futures,\n                new Function<Future<Integer>, Integer>() {\n\n                    @Override\n                    public Integer apply(Future<Integer> input) {\n                        return getResult(input);\n                    }\n                });\n    }","id":101302,"modified_method":"private static List<Integer> getStatusCodes(List<Future<Integer>> futures) {\n        return futures.stream().map(ConcurrentAccessTest::getResult)\n                .collect(Collectors.toList());\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeClass\n    // Need to ensure that the correct concurrent slots are available\n    public static void beforeClass() throws Exception {\n        String path = \"rest/configurations/c/max.concurrent.req.per.apikey\";\n        WebResource.Builder configRequest = clientRequestAsAdmin(path);\n        configRequest.entity(\"6\", MediaType.APPLICATION_JSON_TYPE);\n        configRequest.put();\n    }","id":101303,"modified_method":"@BeforeClass\n    // Need to ensure that the correct concurrent slots are available\n    public static void beforeClass() throws Exception {\n        String path = \"rest/configurations/c/max.concurrent.req.per.apikey\";\n        Invocation.Builder configRequest = clientRequestAsAdmin(path);\n        configRequest.put(Entity.json(\"6\"));\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static Integer getResult(Future<Integer> input) {\n        try {\n            return input.get();\n        } catch (InterruptedException e) {\n            throw Throwables.propagate(e);\n        } catch (ExecutionException e) {\n            throw Throwables.propagate(e);\n        }\n    }","id":101304,"modified_method":"private static Integer getResult(Future<Integer> input) {\n        try {\n            return input.get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw Throwables.propagate(e);\n        }\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static WebResource.Builder clientRequestAsAdmin(String path) {\n        return Client\n                .create()\n                .resource(PropertiesHolder.getProperty(Constants.zanataInstance\n                        .value()) + path)\n                .header(\"X-Auth-User\", \"admin\")\n                .header(\"X-Auth-Token\",\n                        PropertiesHolder.getProperty(Constants.zanataApiKey\n                                .value()))\n                .header(\"Content-Type\", \"application/xml\")\n                .header(\"Accept\", \"application/xml\");\n    }","id":101305,"modified_method":"private static Invocation.Builder clientRequestAsAdmin(String path) {\n        return new ResteasyClientBuilder().build()\n                .target(PropertiesHolder.getProperty(Constants.zanataInstance\n                        .value()) + path)\n                .request(MediaType.APPLICATION_XML_TYPE)\n                .header(\"X-Auth-User\", \"admin\")\n                .header(\"X-Auth-Token\",\n                        PropertiesHolder.getProperty(Constants.zanataApiKey\n                                .value()))\n                .header(\"Content-Type\", \"application/xml\");\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Ignore(\"RHBZ1218458\")\n    public void canLimitConcurrentRestRequestsPerAPIKey() throws Exception {\n        // translator creates the project/version\n        final String projectSlug = \"project\";\n        final String iterationSlug = \"version\";\n        new ZanataRestCaller(TRANSLATOR, TRANSLATOR_API)\n                .createProjectAndVersion(projectSlug, iterationSlug, \"gettext\");\n\n        WebResource.Builder clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n        clientRequest.entity(\"2\", MediaType.APPLICATION_JSON_TYPE);\n\n        clientRequest.put();\n\n        // prepare to fire multiple REST requests\n        final AtomicInteger atomicInteger = new AtomicInteger(1);\n\n        // requests from translator user\n        final int translatorThreads = 3;\n        Callable<Integer> translatorTask = new Callable<Integer>() {\n\n            @Override\n            public Integer call() {\n                return invokeRestService(new ZanataRestCaller(TRANSLATOR,\n                        TRANSLATOR_API), projectSlug, iterationSlug,\n                        atomicInteger);\n            }\n        };\n        List<Callable<Integer>> translatorTasks =\n                Collections.nCopies(translatorThreads, translatorTask);\n\n        // requests from admin user\n        int adminThreads = 2;\n        Callable<Integer> adminTask = new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                return invokeRestService(new ZanataRestCaller(), projectSlug,\n                        iterationSlug, atomicInteger);\n            }\n        };\n\n        List<Callable<Integer>> adminTasks =\n                Collections.nCopies(adminThreads, adminTask);\n\n        ExecutorService executorService =\n                Executors.newFixedThreadPool(translatorThreads + adminThreads);\n\n        List<Callable<Integer>> tasks =\n                ImmutableList.<Callable<Integer>> builder()\n                        .addAll(translatorTasks).addAll(adminTasks).build();\n\n        List<Future<Integer>> futures = executorService.invokeAll(tasks);\n\n        List<Integer> result = getResultStatusCodes(futures);\n\n        // 1 request from translator should get 429 and fail\n        log.info(\"result: {}\", result);\n        assertThat(result).contains(201, 201, 201, 201, 429);\n    }","id":101306,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Ignore(\"RHBZ1218458\")\n    public void canLimitConcurrentRestRequestsPerAPIKey() throws Exception {\n        // translator creates the project/version\n        final String projectSlug = \"project\";\n        final String iterationSlug = \"version\";\n        new ZanataRestCaller(TRANSLATOR, TRANSLATOR_API)\n                .createProjectAndVersion(projectSlug, iterationSlug, \"gettext\");\n\n        Invocation.Builder clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n\n        clientRequest.put(Entity.json(\"2\"));\n\n        // prepare to fire multiple REST requests\n        final AtomicInteger atomicInteger = new AtomicInteger(1);\n\n        // requests from translator user\n        final int translatorThreads = 3;\n        Callable<Integer> translatorTask = new Callable<Integer>() {\n\n            @Override\n            public Integer call() {\n                return invokeRestService(new ZanataRestCaller(TRANSLATOR,\n                        TRANSLATOR_API), projectSlug, iterationSlug,\n                        atomicInteger);\n            }\n        };\n        List<Callable<Integer>> translatorTasks =\n                Collections.nCopies(translatorThreads, translatorTask);\n\n        // requests from admin user\n        int adminThreads = 2;\n        Callable<Integer> adminTask = new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                return invokeRestService(new ZanataRestCaller(), projectSlug,\n                        iterationSlug, atomicInteger);\n            }\n        };\n\n        List<Callable<Integer>> adminTasks =\n                Collections.nCopies(adminThreads, adminTask);\n\n        ExecutorService executorService =\n                Executors.newFixedThreadPool(translatorThreads + adminThreads);\n\n        List<Callable<Integer>> tasks =\n                ImmutableList.<Callable<Integer>> builder()\n                        .addAll(translatorTasks).addAll(adminTasks).build();\n\n        List<Future<Integer>> futures = executorService.invokeAll(tasks);\n\n        List<Integer> result = getResultStatusCodes(futures);\n\n        // 1 request from translator should get 429 and fail\n        log.info(\"result: {}\", result);\n        assertThat(result).contains(201, 201, 201, 201, 429);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canCallServerConfigurationRestService() throws Exception {\n        WebResource.Builder clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n        clientRequest.entity(\"1\", MediaType.APPLICATION_JSON_TYPE);\n        // can put\n        clientRequest.put();\n\n        // can get single configuration\n        String rateLimitConfig =\n                clientRequestAsAdmin(\n                        \"rest/configurations/\" + maxConcurrentPathParam).get(\n                        String.class);\n\n        assertThat(rateLimitConfig)\n                .contains(\"max.concurrent.req.per.apikey\");\n        assertThat(rateLimitConfig).contains(\"<value>1<\/value>\");\n\n        // can get all configurations\n        String configurations =\n                clientRequestAsAdmin(\"rest/configurations/\").get(String.class);\n        log.info(\"result {}\", configurations);\n\n        assertThat(configurations).isNotNull();\n    }","id":101307,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canCallServerConfigurationRestService() throws Exception {\n        Invocation.Builder clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n        // can put\n        clientRequest.put(Entity.json(\"1\"));\n\n        // can get single configuration\n        String rateLimitConfig =\n                clientRequestAsAdmin(\n                        \"rest/configurations/\" + maxConcurrentPathParam).get(\n                        String.class);\n\n        assertThat(rateLimitConfig)\n                .contains(\"max.concurrent.req.per.apikey\");\n        assertThat(rateLimitConfig).contains(\"<value>1<\/value>\");\n\n        // can get all configurations\n        String configurations =\n                clientRequestAsAdmin(\"rest/configurations/\").get(String.class);\n        log.info(\"result {}\", configurations);\n\n        assertThat(configurations).isNotNull();\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canOnlyDealWithKnownConfiguration() throws Exception {\n        WebResource.Builder clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\");\n\n        try {\n            clientRequest.put();\n        } catch (UniformInterfaceException e) {\n            assertThat(e.getResponse().getStatus()).isEqualTo(400);\n        }\n\n        ClientResponse getResponse =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\").get(\n                        ClientResponse.class);\n        assertThat(getResponse.getStatus()).isEqualTo(404);\n    }","id":101308,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canOnlyDealWithKnownConfiguration() throws Exception {\n        Invocation.Builder clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\");\n\n            Response response = clientRequest.put(Entity.json(\"\"));\n            assertThat(response.getStatus()).isEqualTo(400);\n\n        Response getResponse =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\").get();\n        assertThat(getResponse.getStatus()).isEqualTo(404);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static Integer invokeRestService(ZanataRestCaller restCaller,\n            String projectSlug, String iterationSlug,\n            AtomicInteger atomicInteger) {\n        try {\n            int counter = atomicInteger.getAndIncrement();\n            return restCaller.postSourceDocResource(projectSlug, iterationSlug,\n                    ZanataRestCaller.buildSourceResource(\"doc\" + counter,\n                            ZanataRestCaller.buildTextFlow(\"res\" + counter,\n                                    \"content\" + counter)), false);\n        } catch (UniformInterfaceException e) {\n            log.info(\"rest call failed: {}\", e.getMessage());\n            return e.getResponse().getStatus();\n        }\n    }","id":101309,"modified_method":"private static Integer invokeRestService(ZanataRestCaller restCaller,\n            String projectSlug, String iterationSlug,\n            AtomicInteger atomicInteger) {\n        int counter = atomicInteger.getAndIncrement();\n        return restCaller.postSourceDocResource(projectSlug, iterationSlug,\n                ZanataRestCaller.buildSourceResource(\"doc\" + counter,\n                        ZanataRestCaller.buildTextFlow(\"res\" + counter,\n                                \"content\" + counter)), false);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static WebResource.Builder clientRequestAsTranslator(String path) {\n        return Client.create().resource(\n                PropertiesHolder.getProperty(Constants.zanataInstance\n                        .value()) + path)\n                .header(\"X-Auth-User\", TRANSLATOR)\n                .header(\"X-Auth-Token\", TRANSLATOR_API)\n                .header(\"Content-Type\", \"application/xml\")\n                .header(\"Accept\", \"application/xml\");\n    }","id":101310,"modified_method":"private static Invocation.Builder clientRequestAsTranslator(String path) {\n        return new ResteasyClientBuilder().build().target(\n                PropertiesHolder.getProperty(Constants.zanataInstance\n                        .value()) + path)\n                .request(MediaType.APPLICATION_XML_TYPE)\n                .header(\"X-Auth-User\", TRANSLATOR)\n                .header(\"X-Auth-Token\", TRANSLATOR_API);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void serverConfigurationRestServiceOnlyAvailableToAdmin()\n            throws Exception {\n        // all request should be rejected\n        ClientResponse response =\n                clientRequestAsTranslator(\"rest/configurations/\").get(\n                        ClientResponse.class);\n        assertThat(response.getStatus()).isEqualTo(403);\n\n        ClientResponse response1 =\n                clientRequestAsTranslator(\n                        \"rest/configurations/c/email.admin.addr\").get(\n                        ClientResponse.class);\n        assertThat(response1.getStatus()).isEqualTo(403);\n\n        WebResource.Builder request =\n                clientRequestAsTranslator(\n                \"rest/configurations/c/email.admin.addr\");\n        request.entity(\"admin@email.com\", MediaType.APPLICATION_JSON_TYPE);\n        try {\n            request.put();\n        } catch (UniformInterfaceException e) {\n            assertThat(e.getResponse().getStatus()).isEqualTo(403);\n        }\n    }","id":101311,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void serverConfigurationRestServiceOnlyAvailableToAdmin()\n            throws Exception {\n        // all request should be rejected\n        Response response =\n                clientRequestAsTranslator(\"rest/configurations/\").get();\n        assertThat(response.getStatus()).isEqualTo(403);\n\n        Response response1 =\n                clientRequestAsTranslator(\n                        \"rest/configurations/c/email.admin.addr\").get();\n        assertThat(response1.getStatus()).isEqualTo(403);\n\n        Invocation.Builder request =\n                clientRequestAsTranslator(\n                \"rest/configurations/c/email.admin.addr\");\n        Response response2 = request.put(Entity.json(\"admin@email.com\"));\n        assertThat(response2.getStatus()).isEqualTo(403);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = 5000)\n    public void unmappedExceptionWillAlsoReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        WebResource.Builder configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.entity(\"1\", MediaType.APPLICATION_JSON_TYPE);\n        configRequest.put();\n\n        // When: multiple requests that will result in an unmapped exception\n        WebResource.Builder clientRequest =\n                clientRequestAsAdmin(\n                \"rest/test/data/sample/dummy?exception=java.lang.RuntimeException\");\n        clientRequest.get(ClientResponse.class);\n        clientRequest.get(ClientResponse.class);\n        clientRequest.get(ClientResponse.class);\n        clientRequest.get(ClientResponse.class);\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1).isEqualTo(1);\n    }","id":101312,"modified_method":"@Test(timeout = 5000)\n    public void unmappedExceptionWillAlsoReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        Invocation.Builder configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.put(Entity.json(\"1\"));\n\n        // When: multiple requests that will result in an unmapped exception\n        Invocation.Builder clientRequest =\n                clientRequestAsAdmin(\n                \"rest/test/data/sample/dummy?exception=java.lang.RuntimeException\");\n        clientRequest.get();\n        clientRequest.get();\n        clientRequest.get();\n        clientRequest.get();\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1).isEqualTo(1);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = 5000)\n    public void exceptionWillReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        WebResource.Builder configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.entity(\"1\", MediaType.APPLICATION_JSON_TYPE);\n        configRequest.put();\n\n        // When: multiple requests that will result in a mapped exception\n        WebResource.Builder clientRequest =\n                clientRequestAsAdmin(\n                \"rest/test/data/sample/dummy?exception=org.zanata.rest.NoSuchEntityException\");\n        clientRequest.get(ClientResponse.class);\n        clientRequest.get(ClientResponse.class);\n        clientRequest.get(ClientResponse.class);\n        clientRequest.get(ClientResponse.class);\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1).isEqualTo(1);\n    }","id":101313,"modified_method":"@Test(timeout = 5000)\n    public void exceptionWillReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        Invocation.Builder configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.put(Entity.json(\"1\"));\n\n        // When: multiple requests that will result in a mapped exception\n        Invocation.Builder clientRequest =\n                clientRequestAsAdmin(\n                \"rest/test/data/sample/dummy?exception=org.zanata.rest.NoSuchEntityException\");\n        clientRequest.get();\n        clientRequest.get();\n        clientRequest.get();\n        clientRequest.get();\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1).isEqualTo(1);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static WebResource.Builder createRequest(String path) {\n        WebResource.Builder resource =\n                Client.create()\n                        .resource(\n                                PropertiesHolder\n                                        .getProperty(Constants.zanataInstance\n                                                .value())\n                                        + \"rest/test/data/sample\" + path)\n                        // having null username will bypass\n                        // ZanataRestSecurityInterceptor\n                        // clientRequest.header(\"X-Auth-User\", null);\n                        .header(\"X-Auth-Token\",\n                                PropertiesHolder\n                                        .getProperty(Constants.zanataApiKey\n                                                .value()))\n                        .header(\"Content-Type\", \"application/xml\");\n        return resource;\n    }","id":101314,"modified_method":"private static Invocation.Builder createRequest(String path) {\n        Invocation.Builder resource =\n                new ResteasyClientBuilder().build()\n                        .target(\n                                PropertiesHolder\n                                        .getProperty(Constants.zanataInstance\n                                                .value())\n                                        + \"rest/test/data/sample\" + path)\n                        .request(MediaType.APPLICATION_XML_TYPE)\n                        // having null username will bypass\n                        // ZanataRestSecurityInterceptor\n                        // clientRequest.header(\"X-Auth-User\", null);\n                        .header(\"X-Auth-Token\",\n                                PropertiesHolder\n                                        .getProperty(Constants.zanataApiKey\n                                                .value()));\n        return resource;\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void makeSampleProject() throws Exception {\n        createRequest(\"/project\").put();\n    }","id":101315,"modified_method":"public static void makeSampleProject() throws Exception {\n        createRequest(\"/project\").put(EMPTY_ENTITY);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void addLanguage(String localeId, @Nullable String pluralForms) throws Exception {\n        String path = \"/languages/l/\" + localeId + (pluralForms != null ? \"?pluralForms=\" + pluralForms : \"\");\n        createRequest(path).put();\n    }","id":101316,"modified_method":"public static void addLanguage(String localeId, @Nullable String pluralForms) throws Exception {\n        String path = \"/languages/l/\" + localeId + (pluralForms != null ? \"?pluralForms=\" + pluralForms : \"\");\n        createRequest(path).put(EMPTY_ENTITY);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * @param username\n     *            username to join language team\n     * @param localesCSV\n     *            locale ids separated by comma\n     */\n    public static void userJoinsLanguageTeam(String username,\n            String localesCSV) throws Exception {\n        Client.create()\n                .resource(\n                        PropertiesHolder.getProperty(Constants.zanataInstance\n                                .value()) + \"rest/test/data/sample/accounts/u/\"\n                                + username + \"/languages\")\n                .queryParam(\"locales\", localesCSV)\n                .header(\"X-Auth-Token\",\n                        PropertiesHolder.getProperty(Constants.zanataApiKey\n                                .value()))\n                .header(\"Content-Type\", \"application/xml\").put();\n    }","id":101317,"modified_method":"/**\n     * @param username\n     *            username to join language team\n     * @param localesCSV\n     *            locale ids separated by comma\n     */\n    public static void userJoinsLanguageTeam(String username,\n            String localesCSV) throws Exception {\n        new ResteasyClientBuilder().build()\n                .target(\n                        PropertiesHolder.getProperty(Constants.zanataInstance\n                                .value()) + \"rest/test/data/sample/accounts/u/\"\n                                + username + \"/languages\")\n                .queryParam(\"locales\", localesCSV)\n                .request(MediaType.APPLICATION_XML_TYPE)\n                .header(\"X-Auth-Token\",\n                        PropertiesHolder.getProperty(Constants.zanataApiKey\n                                .value()))\n                .put(EMPTY_ENTITY);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void makeSampleUsers() throws Exception {\n        createRequest(\"/users\").put();\n    }","id":101318,"modified_method":"public static void makeSampleUsers() throws Exception {\n        createRequest(\"/users\").put(\n                EMPTY_ENTITY);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void makeSampleLanguages() throws Exception {\n        createRequest(\"/languages\").put();\n    }","id":101319,"modified_method":"public static void makeSampleLanguages() throws Exception {\n        createRequest(\"/languages\").put(EMPTY_ENTITY);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private WebResource.Builder createRequest(URI uri) {\n        WebResource.Builder resource =\n                Client.create()\n                        .resource(uri)\n                        // having null username will bypass\n                        // ZanataRestSecurityInterceptor\n                        // clientRequest.header(\"X-Auth-User\", null);\n                        .header(\"X-Auth-Token\", apiKey)\n                        .header(\"Content-Type\", \"application/xml\");\n        return resource;\n    }","id":101320,"modified_method":"private Invocation.Builder createRequest(URI uri) {\n\n        Invocation.Builder builder = new ResteasyClientBuilder().build()\n                .target(uri)\n                .request()\n                // having null username will bypass\n                // ZanataRestSecurityInterceptor\n                // clientRequest.header(\"X-Auth-User\", null);\n                .header(\"X-Auth-Token\", apiKey);\n        return builder;\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void putSourceDocResource(String projectSlug, String iterationSlug,\n            String idNoSlash, Resource resource, boolean copytrans) {\n        restClientFactory.getSourceDocResourceClient(projectSlug,\n                iterationSlug).putResource(idNoSlash, resource,\n                Collections.<String>emptySet(), copytrans);\n    }","id":101321,"modified_method":"public void putSourceDocResource(String projectSlug, String iterationSlug,\n            String idNoSlash, Resource resource, boolean copytrans) {\n        restClientFactory.getSourceDocResourceClient(projectSlug,\n                iterationSlug).putResource(idNoSlash, resource,\n                Collections.emptySet(), copytrans);\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void postTest(String path, String testClass, String methodName) {\n        UriBuilder uri = UriBuilder.fromUri(baseUrl + path);\n        uri.queryParam(\"testClass\", testClass);\n        uri.queryParam(\"method\", methodName);\n        WebResource.Builder request = createRequest(uri.build());\n        request.post();\n    }","id":101322,"modified_method":"private void postTest(String path, String testClass, String methodName) {\n        UriBuilder uri = UriBuilder.fromUri(baseUrl + path);\n        uri.queryParam(\"testClass\", testClass);\n        uri.queryParam(\"method\", methodName);\n        Invocation.Builder request = createRequest(uri.build());\n        request.post(Entity.text(\"\"));\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"private ProcessStatus waitUntilFinished(\n            final AsyncProcessClient asyncProcessClient,\n            ProcessStatus processStatus) {\n        final String processId = processStatus.getUrl();\n        Awaitility.await()\n                .pollInterval(Duration.ONE_SECOND)\n                .until(() -> {\n                    return DONE_STATUS.contains(\n                            asyncProcessClient.getProcessStatus(processId)\n                                    .getStatusCode());\n                });\n\n        if (processStatus.getStatusCode().equals(\n                ProcessStatus.ProcessStatusCode.Failed)) {\n            throw new RuntimeException(processStatus.getStatusCode().toString());\n        }\n        return processStatus;\n    }","id":101323,"modified_method":"private ProcessStatus waitUntilFinished(\n            final AsyncProcessClient asyncProcessClient,\n            ProcessStatus processStatus) {\n        final String processId = processStatus.getUrl();\n        Awaitility.await()\n                .pollInterval(Duration.ONE_SECOND)\n                .until(() -> DONE_STATUS.contains(\n                        asyncProcessClient.getProcessStatus(processId)\n                                .getStatusCode()));\n\n        if (processStatus.getStatusCode().equals(\n                ProcessStatus.ProcessStatusCode.Failed)) {\n            throw new RuntimeException(processStatus.getStatusCode().toString());\n        }\n        return processStatus;\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void asyncPushSource(String projectSlug, String iterationSlug,\n            Resource sourceResource, boolean copyTrans) {\n        AsyncProcessClient asyncProcessClient =\n                restClientFactory.getAsyncProcessClient();\n        ProcessStatus processStatus =\n                asyncProcessClient.startSourceDocCreationOrUpdate(\n                        sourceResource.getName(), projectSlug, iterationSlug,\n                        sourceResource,\n                        Sets.<String> newHashSet(), false);\n        processStatus = waitUntilFinished(asyncProcessClient, processStatus);\n        log.info(\"finished async source push ({}-{}): {}\", projectSlug,\n                iterationSlug, processStatus.getStatusCode());\n        if (copyTrans) {\n            runCopyTrans(projectSlug, iterationSlug, sourceResource.getName());\n        }\n    }","id":101324,"modified_method":"public void asyncPushSource(String projectSlug, String iterationSlug,\n            Resource sourceResource, boolean copyTrans) {\n        AsyncProcessClient asyncProcessClient =\n                restClientFactory.getAsyncProcessClient();\n        ProcessStatus processStatus =\n                asyncProcessClient.startSourceDocCreationOrUpdate(\n                        sourceResource.getName(), projectSlug, iterationSlug,\n                        sourceResource,\n                        Sets.newHashSet(), false);\n        processStatus = waitUntilFinished(asyncProcessClient, processStatus);\n        log.info(\"finished async source push ({}-{}): {}\", projectSlug,\n                iterationSlug, processStatus.getStatusCode());\n        if (copyTrans) {\n            runCopyTrans(projectSlug, iterationSlug, sourceResource.getName());\n        }\n    }","commit_id":"674b1e923cf5ad9803a99ce0e4b566aed3421a47","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n\tpublic void testImportResourcesWAR() throws Exception {\n\t\t_importedGroup = GroupLocalServiceUtil.fetchGroup(\n\t\t\tTestPropsValues.getCompanyId(), \"ResourcesImporterTest\");\n\n\t\t// Verify the deployment\n\n\t\tAssert.assertNotNull(_importedGroup);\n\n\t\tlong privateLayoutsCount = LayoutLocalServiceUtil.getLayoutsCount(\n\t\t\t_importedGroup, true);\n\n\t\tAssert.assertEquals(0, privateLayoutsCount);\n\n\t\tlong publicLayoutsCount = LayoutLocalServiceUtil.getLayoutsCount(\n\t\t\t_importedGroup, false);\n\n\t\tAssert.assertEquals(4, publicLayoutsCount);\n\n\t\tlong journalArticlesCount =\n\t\t\tJournalArticleLocalServiceUtil.getArticlesCount(\n\t\t\t\t_importedGroup.getGroupId());\n\n\t\tAssert.assertEquals(2, journalArticlesCount);\n\n\t\tlong fileEntriesCount = DLFileEntryLocalServiceUtil.getFileEntriesCount(\n\t\t\t_importedGroup.getGroupId(),\n\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID);\n\n\t\tAssert.assertEquals(2, fileEntriesCount);\n\n\t\tLayout homeLayout = LayoutLocalServiceUtil.getFriendlyURLLayout(\n\t\t\t_importedGroup.getGroupId(), false, \"/home\");\n\n\t\tAssert.assertTrue(homeLayout.isTypePortlet());\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)homeLayout.getLayoutType();\n\n\t\tList<Portlet> portlets = layoutTypePortlet.getAllPortlets();\n\n\t\tAssert.assertEquals(2, portlets.size());\n\t}","id":101325,"modified_method":"@Test\n\tpublic void testResourcesImport() throws Exception {\n\t\t_importedGroup = GroupLocalServiceUtil.fetchGroup(\n\t\t\tTestPropsValues.getCompanyId(), \"ResourcesImporterTest\");\n\n\t\tAssert.assertNotNull(_importedGroup);\n\n\t\t_layoutPrototypes = getLayoutPrototypes();\n\n\t\tAssert.assertEquals(2, _layoutPrototypes.size());\n\n\t\tvalidateLayouts(_importedGroup);\n\n\t\tvalidateJournal(_importedGroup);\n\n\t\tvalidateDocumentLibrary(_importedGroup);\n\t}","commit_id":"7e2d53a503af683db4a06a7a9bc09157c9cf47b3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static WebArchive buildTestWebArchive() {\n\t\tWebArchive webArchive = ShrinkWrap.create(WebArchive.class);\n\n\t\t// Generic files\n\n\t\taddWebInfResource(webArchive, \"liferay-plugin-package.properties\");\n\n\t\t// Site map\n\n\t\taddWebInfResource(\n\t\t\twebArchive, \"classes/resources-importer/sitemap.json\");\n\n\t\t// Document Library specific files\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents/image1.jpg\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents/image2.jpg\");\n\n\t\t// Journal specific files\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/BASIC_WEB_CONTENT/\" +\n\t\t\t\t\"article1.html\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/BASIC_WEB_CONTENT/\" +\n\t\t\t\t\"article2.html\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/\" +\n\t\t\t\t\"BASIC_WEB_CONTENT.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/\" +\n\t\t\t\t\"BASIC_WEB_CONTENT/BASIC_WEB_CONTENT.ftl\");\n\n\t\treturn webArchive;\n\t}","id":101326,"modified_method":"protected static WebArchive buildTestWebArchive() {\n\t\tWebArchive webArchive = ShrinkWrap.create(WebArchive.class);\n\n\t\t// Generic resources\n\n\t\taddWebInfResource(webArchive, \"liferay-plugin-package.properties\");\n\t\taddWebInfResource(webArchive, \"classes/resources-importer/assets.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive, \"classes/resources-importer/sitemap.json\");\n\n\t\t// Document Library specific resources\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents/\" +\n\t\t\t\t\"company_logo.png\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents/\" +\n\t\t\t\t\"Parent Folder/child_document.txt\");\n\n\t\t// Journal specific resources\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/BASIC_WEB_CONTENT/\" +\n\t\t\t\t\"Basic Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/\" +\n\t\t\t\t\"BASIC_WEB_CONTENT.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/\" +\n\t\t\t\t\"BASIC_WEB_CONTENT/BASIC_WEB_CONTENT.ftl\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/Child Template/\" +\n\t\t\t\t\"Child Template Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/Parent Structure/\" +\n\t\t\t\t\"Child Structure.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/Child Structure/\" +\n\t\t\t\t\"Child Template.ftl\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/Parent Template/\" +\n\t\t\t\t\"Parent Template Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/\" +\n\t\t\t\t\"Parent Structure.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/Parent Structure/\" +\n\t\t\t\t\"Parent Template.ftl\");\n\n\t\t// Page Templates\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/templates/page/page_1.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/templates/page/page_2.json\");\n\n\t\treturn webArchive;\n\t}","commit_id":"7e2d53a503af683db4a06a7a9bc09157c9cf47b3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static WebArchive buildTestWebArchive() {\n\t\tWebArchive webArchive = ShrinkWrap.create(WebArchive.class);\n\n\t\t// General\n\n\t\taddWebInfResource(webArchive, \"liferay-plugin-package.properties\");\n\t\taddWebInfResource(webArchive, \"classes/resources-importer/assets.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive, \"classes/resources-importer/sitemap.json\");\n\n\t\t// Document library\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents/\" +\n\t\t\t\t\"company_logo.png\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents/\" +\n\t\t\t\t\"Parent Folder/child_document.txt\");\n\n\t\t// Journal\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/BASIC_WEB_CONTENT/\" +\n\t\t\t\t\"Basic Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/\" +\n\t\t\t\t\"BASIC_WEB_CONTENT.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/\" +\n\t\t\t\t\"BASIC_WEB_CONTENT/BASIC_WEB_CONTENT.ftl\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/Child Template/\" +\n\t\t\t\t\"Child Template Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/Parent Structure/\" +\n\t\t\t\t\"Child Structure.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/Child Structure/\" +\n\t\t\t\t\"Child Template.ftl\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/Parent Template/\" +\n\t\t\t\t\"Parent Template Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/\" +\n\t\t\t\t\"Parent Structure.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/Parent Structure/\" +\n\t\t\t\t\"Parent Template.ftl\");\n\n\t\t// Page templates\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/templates/page/page_1.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/templates/page/page_2.json\");\n\n\t\treturn webArchive;\n\t}","id":101327,"modified_method":"protected static WebArchive buildTestWebArchive() {\n\t\tWebArchive webArchive = ShrinkWrap.create(WebArchive.class);\n\n\t\t// General\n\n\t\taddWebInfResource(webArchive, \"liferay-plugin-package.properties\");\n\t\taddWebInfResource(webArchive, \"classes/resources-importer/assets.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive, \"classes/resources-importer/sitemap.json\");\n\n\t\t// Document library\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents\" +\n\t\t\t\t\"/company_logo.png\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/document_library/documents\" +\n\t\t\t\t\"/Parent Folder/child_document.txt\");\n\n\t\t// Journal\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/BASIC_WEB_CONTENT\" +\n\t\t\t\t\"/Basic Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures\" +\n\t\t\t\t\"/BASIC_WEB_CONTENT.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/BASIC_WEB_CONTENT\" +\n\t\t\t\t\"/BASIC_WEB_CONTENT.ftl\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/Child Template\" +\n\t\t\t\t\"/Child Template Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/Parent Structure\" +\n\t\t\t\t\"/Child Structure.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/Child Structure\" +\n\t\t\t\t\"/Child Template.ftl\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/articles/Parent Template\" +\n\t\t\t\t\"/Parent Template Article.xml\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/structures/Parent \" +\n\t\t\t\t\"Structure.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/journal/templates/Parent Structure\" +\n\t\t\t\t\"/Parent Template.ftl\");\n\n\t\t// Page templates\n\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/templates/page/page_1.json\");\n\t\taddWebInfResource(\n\t\t\twebArchive,\n\t\t\t\"classes/resources-importer/templates/page/page_2.json\");\n\n\t\treturn webArchive;\n\t}","commit_id":"a910fbee16157bdc07c11745d7ee889f2c5381c7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Iterable sourceNodesQuery_1170347787985(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List list = _QueriesUtil.getList_ContextOwner_ifMethod_ParmsUsedInClosure(_context.getNode(), ((TemplateQueryContext)_context).getGenerator());\n    return (List<SNode>)list;\n  }","id":101328,"modified_method":"public static Iterable sourceNodesQuery_1170347787985(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List<SNode> list = _QueriesUtil.getList_ContextOwner_ifMethod_ParmsUsedInClosure(_context.getNode(), ((TemplateQueryContext)_context).getGenerator());\n    return (List<SNode>)list;\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_1170347696338(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List list = _QueriesUtil.getList_ContextOwner_ifMethod_ParmsUsedInClosure(_context.getNode(), ((TemplateQueryContext)_context).getGenerator());\n    return (List<SNode>)list;\n  }","id":101329,"modified_method":"public static Iterable sourceNodesQuery_1170347696338(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List<SNode> list = _QueriesUtil.getList_ContextOwner_ifMethod_ParmsUsedInClosure(_context.getNode(), ((TemplateQueryContext)_context).getGenerator());\n    return (List<SNode>)list;\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_1170347169279(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List list = _QueriesUtil.getList_ContextOwner_VariablesUsedInClosure(_context.getNode(), ((TemplateQueryContext)_context).getGenerator());\n    return (List<SNode>)list;\n  }","id":101330,"modified_method":"public static Iterable sourceNodesQuery_1170347169279(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    List<SNode> list = _QueriesUtil.getList_ContextOwner_VariablesUsedInClosure(_context.getNode(), ((TemplateQueryContext)_context).getGenerator());\n    return (List<SNode>)list;\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> parameterTypes(SNode method, SNode instanceType, SNode classifier) {\n    List<SNode> result = ListSequence.fromList(new LinkedList<SNode>());\n    boolean containsVars = false;\n    for(SNode parameter : SLinkOperations.getTargets(method, \"parameter\", true)) {\n      if (ListSequence.fromList(SNodeOperations.getDescendants(parameter, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)).isNotEmpty()) {\n        containsVars = true;\n      }\n      ListSequence.fromList(result).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter, \"type\", true)));\n    }\n    if (!(containsVars)) {\n      return result;\n    }\n    Set<SNode> frontier = new HashSet<SNode>();\n    frontier.add(instanceType);\n    SNode concreteMethodClassifierType = ResolveUtil.getConcreteSuperClassifierType(frontier, classifier);\n    if (concreteMethodClassifierType == null) {\n      return result;\n    }\n    List<SNode> typeParameters = ListSequence.fromList(SLinkOperations.getTargets(concreteMethodClassifierType, \"parameter\", true)).toListSequence();\n    for(SNode paramType : new ArrayList<SNode>(result)) {\n      for(SNode typeVar : SNodeOperations.getDescendants(paramType, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)) {\n        SNode replacement = SNodeOperations.copyNode(ListSequence.fromList(typeParameters).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false))));\n        if ((SNodeOperations.getParent(typeVar) == null)) {\n          ListSequence.fromList(result).insertElement(result.indexOf(typeVar), replacement);\n          ListSequence.fromList(result).removeElement(typeVar);\n        } else\n        {\n          SNodeOperations.replaceWithAnother(typeVar, replacement);\n        }\n      }\n    }\n    return result;\n  }","id":101331,"modified_method":"public static List<SNode> parameterTypes(SNode method, SNode instanceType, SNode classifier) {\n    List<SNode> result = ListSequence.fromList(new LinkedList<SNode>());\n    boolean containsVars = false;\n    for(SNode parameter : SLinkOperations.getTargets(method, \"parameter\", true)) {\n      if (ListSequence.fromList(SNodeOperations.getDescendants(parameter, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)).isNotEmpty()) {\n        containsVars = true;\n      }\n      ListSequence.fromList(result).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter, \"type\", true)));\n    }\n    if (!(containsVars)) {\n      return result;\n    }\n    Set<SNode> frontier = new HashSet<SNode>();\n    frontier.add(instanceType);\n    SNode concreteMethodClassifierType = ResolveUtil.getConcreteSuperClassifierType(frontier, classifier);\n    if (concreteMethodClassifierType == null) {\n      return result;\n    }\n    List<SNode> typeParameters = ListSequence.fromList(SLinkOperations.getTargets(concreteMethodClassifierType, \"parameter\", true)).toListSequence();\n    for(SNode paramType : new ArrayList<SNode>(result)) {\n      for(SNode typeVar : SNodeOperations.getDescendants(paramType, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)) {\n        SNode replacement = SNodeOperations.copyNode(ListSequence.fromList(typeParameters).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false))));\n        if ((SNodeOperations.getParent(typeVar) == null)) {\n          ListSequence.fromList(result).insertElement(ListSequence.fromList(result).indexOf(typeVar), replacement);\n          ListSequence.fromList(result).removeElement(typeVar);\n        } else\n        {\n          SNodeOperations.replaceWithAnother(typeVar, replacement);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@InferenceMethod()\n  public static void inference_equateParametersAndReturnType(final TypeCheckingContext typeCheckingContext, final SNode mc, SNode returnType, Map<SNode, List<SNode>> mmap) {\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      Iterator<SNode> formalIterator = ((List<SNode>)parameterDeclarations).iterator();\n      Iterator<SNode> actualIterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n      SNode formalParam = null;\n      SNode actualParam = null;\n      while (true) {\n        if (!(actualIterator.hasNext())) {\n          break;\n        }\n        if (!(formalIterator.hasNext())) {\n          break;\n        }\n        formalParam = formalIterator.next();\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalParam, \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n          break;\n        }\n        actualParam = actualIterator.next();\n        SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(formalParam, \"type\", true), mmap);\n        {\n          SNode _nodeToCheck_1029348928467 = actualParam;\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n          intentionProvider.putArgument(\"methodCall\", mc);\n          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n          typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actualParam, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530380\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530376\", false, 2, intentionProvider);\n        }\n      }\n      do {\n        SNode matchedNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n        {\n          boolean matches_3 = false;\n          {\n            SNode matchingNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n            if (matchingNode_3 != null) {\n              matches_3 = SModelUtil_new.isAssignableConcept(matchingNode_3.getConceptFqName(), \"jetbrains.mps.baseLanguage.structure.VariableArityType\");\n            }\n          }\n          if (matches_3) {\n            {\n              SNode componentType = SLinkOperations.getTarget(matchedNode_3, \"componentType\", true);\n              final SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, componentType, mmap);\n              if (SLinkOperations.getCount(mc, \"actualArgument\") == ListSequence.fromList(parameterDeclarations).count()) {\n                // the actual parameter may appear to be an array instead of vararg\n                final SNode actual = actualIterator.next();\n                {\n                  final SNode actualType = typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347108709\", true);\n                  typeCheckingContext.whenConcrete(actualType, new Runnable() {\n\n                    public void run() {\n                      if (SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n                        {\n                          SNode _nodeToCheck_1029348928467 = actual;\n                          BaseIntentionProvider intentionProvider = null;\n                          intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                          intentionProvider.putArgument(\"methodCall\", mc);\n                          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                          typeCheckingContext.createLessThanInequation(SLinkOperations.getTarget(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"componentType\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347279318\", false, 2, intentionProvider);\n                        }\n                      } else\n                      {\n                        SNode _nodeToCheck_1029348928467 = actual;\n                        BaseIntentionProvider intentionProvider = null;\n                        intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                        intentionProvider.putArgument(\"methodCall\", mc);\n                        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                        typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(actualType), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347200873\", false, 2, intentionProvider);\n                      }\n                    }\n\n                  }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347102532\", false, false);\n                }\n              } else\n              {\n                // in this case the actual parameter is definitely a vararg\n                while (actualIterator.hasNext()) {\n                  SNode actual = actualIterator.next();\n                  {\n                    SNode _nodeToCheck_1029348928467 = actual;\n                    BaseIntentionProvider intentionProvider = null;\n                    intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                    intentionProvider.putArgument(\"methodCall\", mc);\n                    intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                    typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702426\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702422\", false, 2, intentionProvider);\n                  }\n                }\n              }\n            }\n            break;\n          }\n        }\n      } while(false);\n    } else\n    {\n      {\n        SNode arg;\n        SNode param;\n        Iterator<SNode> arg_iterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n        Iterator<SNode> param_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true).iterator();\n        while (true) {\n          if (!(arg_iterator.hasNext())) {\n            break;\n          }\n          if (!(param_iterator.hasNext())) {\n            break;\n          }\n          arg = arg_iterator.next();\n          param = param_iterator.next();\n          {\n            SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(param, \"type\", true), mmap);\n            {\n              SNode _nodeToCheck_1029348928467 = arg;\n              BaseIntentionProvider intentionProvider = null;\n              intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n              intentionProvider.putArgument(\"methodCall\", mc);\n              intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n              typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(arg, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371331\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371327\", false, 2, intentionProvider);\n            }\n          }\n        }\n      }\n    }\n    if (returnType != null) {\n      SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, returnType, mmap);\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(mc, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371361\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371359\", intentionProvider);\n      }\n    }\n  }","id":101332,"modified_method":"@InferenceMethod()\n  public static void inference_equateParametersAndReturnType(final TypeCheckingContext typeCheckingContext, final SNode mc, SNode returnType, Map<SNode, List<SNode>> mmap) {\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      Iterator<SNode> formalIterator = ((List<SNode>)parameterDeclarations).iterator();\n      Iterator<SNode> actualIterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n      SNode formalParam = null;\n      SNode actualParam = null;\n      while (true) {\n        if (!(actualIterator.hasNext())) {\n          break;\n        }\n        if (!(formalIterator.hasNext())) {\n          break;\n        }\n        formalParam = formalIterator.next();\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalParam, \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n          break;\n        }\n        actualParam = actualIterator.next();\n        SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(formalParam, \"type\", true), mmap);\n        {\n          SNode _nodeToCheck_1029348928467 = actualParam;\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n          intentionProvider.putArgument(\"methodCall\", mc);\n          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n          typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actualParam, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530380\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530376\", false, 2, intentionProvider);\n        }\n      }\n      do {\n        SNode matchedNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n        {\n          boolean matches_3 = false;\n          {\n            SNode matchingNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n            if (matchingNode_3 != null) {\n              matches_3 = SModelUtil_new.isAssignableConcept(matchingNode_3.getConceptFqName(), \"jetbrains.mps.baseLanguage.structure.VariableArityType\");\n            }\n          }\n          if (matches_3) {\n            {\n              SNode componentType = SLinkOperations.getTarget(matchedNode_3, \"componentType\", true);\n              final SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, componentType, mmap);\n              if (SLinkOperations.getCount(mc, \"actualArgument\") == ListSequence.fromList(parameterDeclarations).count()) {\n                // the actual parameter may appear to be an array instead of vararg\n                final SNode actual = actualIterator.next();\n                {\n                  final SNode actualType = typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347108709\", true);\n                  typeCheckingContext.whenConcrete(actualType, new Runnable() {\n\n                    public void run() {\n                      if (SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n                        {\n                          SNode _nodeToCheck_1029348928467 = actual;\n                          BaseIntentionProvider intentionProvider = null;\n                          intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                          intentionProvider.putArgument(\"methodCall\", mc);\n                          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                          typeCheckingContext.createLessThanInequation(SLinkOperations.getTarget(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"componentType\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347279318\", false, 2, intentionProvider);\n                        }\n                      } else\n                      {\n                        SNode _nodeToCheck_1029348928467 = actual;\n                        BaseIntentionProvider intentionProvider = null;\n                        intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                        intentionProvider.putArgument(\"methodCall\", mc);\n                        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                        typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(actualType), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347200873\", false, 2, intentionProvider);\n                      }\n                    }\n\n                  }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347102532\", false, false);\n                }\n              } else\n              {\n                // in this case the actual parameter is definitely a vararg\n                while (actualIterator.hasNext()) {\n                  SNode actual = actualIterator.next();\n                  {\n                    SNode _nodeToCheck_1029348928467 = actual;\n                    BaseIntentionProvider intentionProvider = null;\n                    intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                    intentionProvider.putArgument(\"methodCall\", mc);\n                    intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                    typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702426\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702422\", false, 2, intentionProvider);\n                  }\n                }\n              }\n            }\n            break;\n          }\n        }\n      } while(false);\n    } else\n    {\n      {\n        SNode arg;\n        SNode param;\n        Iterator<SNode> arg_iterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n        Iterator<SNode> param_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true).iterator();\n        while (true) {\n          if (!(arg_iterator.hasNext())) {\n            break;\n          }\n          if (!(param_iterator.hasNext())) {\n            break;\n          }\n          arg = arg_iterator.next();\n          param = param_iterator.next();\n          {\n            SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(param, \"type\", true), mmap);\n            {\n              SNode _nodeToCheck_1029348928467 = arg;\n              BaseIntentionProvider intentionProvider = null;\n              intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n              intentionProvider.putArgument(\"methodCall\", mc);\n              intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n              typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(arg, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371331\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371327\", false, 2, intentionProvider);\n            }\n          }\n        }\n      }\n    }\n    if (returnType != null) {\n      SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, returnType, mmap);\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(mc, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371361\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371359\", intentionProvider);\n      }\n    }\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@CheckingMethod()\n  /* package */static void check(final TypeCheckingContext typeCheckingContext, Set<SNode> throwables, SNode mainNode) {\n    for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_29().createNode(typeCheckingContext)) || TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_28().createNode(typeCheckingContext))) {\n        throwables.remove(livingThrowable);\n      }\n    }\n    if (throwables.isEmpty()) {\n      return;\n    }\n    List<SNode> statementLists = SNodeOperations.getAncestors(mainNode, \"jetbrains.mps.baseLanguage.structure.StatementList\", false);\n    for(SNode statementList : statementLists) {\n      SNode parent = SNodeOperations.getParent(statementList);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryCatchStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryCatchStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode baseMethodDeclaration = parent;\n        for(SNode throwableType : SLinkOperations.getTargets(baseMethodDeclaration, \"throwsItem\", true)) {\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n        if (!(throwables.isEmpty())) {\n          String errorString = \"uncaught exceptions:\";\n          for(SNode exc : throwables) {\n            errorString = errorString + \" \" + exc;\n          }\n          {\n            BaseIntentionProvider intentionProvider = null;\n            intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).AddExceptionToMethodSignature_QuickFix\", false);\n            intentionProvider.putArgument(\"throwableType\", throwables.iterator().next());\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            typeCheckingContext.reportTypeError(mainNode, errorString, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1210182111558\", intentionProvider, errorTarget);\n          }\n        }\n        return;\n      }\n    }\n  }","id":101333,"modified_method":"@CheckingMethod()\n  /* package */static void check(final TypeCheckingContext typeCheckingContext, Set<SNode> throwables, SNode mainNode) {\n    for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_29().createNode(typeCheckingContext)) || TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_28().createNode(typeCheckingContext))) {\n        throwables.remove(livingThrowable);\n      }\n    }\n    if (throwables.isEmpty()) {\n      return;\n    }\n    List<SNode> statementLists = SNodeOperations.getAncestors(mainNode, \"jetbrains.mps.baseLanguage.structure.StatementList\", false);\n    for(SNode statementList : statementLists) {\n      SNode parent = SNodeOperations.getParent(statementList);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryCatchStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryCatchStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode baseMethodDeclaration = parent;\n        for(SNode throwableType : SLinkOperations.getTargets(baseMethodDeclaration, \"throwsItem\", true)) {\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n        if (!(throwables.isEmpty())) {\n          String errorString = \"uncaught exceptions:\";\n          for(SNode exc : throwables) {\n            errorString = errorString + \" \" + exc;\n          }\n          {\n            BaseIntentionProvider intentionProvider = null;\n            intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).AddExceptionToMethodSignature_QuickFix\", false);\n            intentionProvider.putArgument(\"throwableType\", throwables.iterator().next());\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            typeCheckingContext.reportTypeError(mainNode, errorString, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1210182111558\", intentionProvider, errorTarget);\n          }\n        }\n        return;\n      }\n    }\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode antiquotation, final TypeCheckingContext typeCheckingContext) {\n    SNode contentsType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(antiquotation, \"expression\", true));\n    if (SNodeOperations.isInstanceOf(contentsType, \"jetbrains.mps.lang.smodel.structure.SNodeType\")) {\n      if (SConceptOperations.isSubConceptOf(SLinkOperations.getTarget(contentsType, \"concept\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ReplaceClassAntiquotationWithClassifierType_QuickFix\");\n          intentionProvider.putArgument(\"antiquotation\", antiquotation);\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          typeCheckingContext.reportWarning(SLinkOperations.getTarget(antiquotation, \"expression\", true), \"Substitution of a classifier here is probably an error\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228301999219\", intentionProvider, errorTarget);\n        }\n      }\n    }\n  }","id":101334,"modified_method":"public void applyRule(final SNode antiquotation, final TypeCheckingContext typeCheckingContext) {\n    SNode contentsType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(antiquotation, \"expression\", true));\n    if (SNodeOperations.isInstanceOf(contentsType, \"jetbrains.mps.lang.smodel.structure.SNodeType\")) {\n      if (SConceptOperations.isSubConceptOf(SLinkOperations.getTarget(contentsType, \"concept\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ReplaceClassAntiquotationWithClassifierType_QuickFix\");\n          intentionProvider.putArgument(\"antiquotation\", antiquotation);\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          typeCheckingContext.reportWarning(SLinkOperations.getTarget(antiquotation, \"expression\", true), \"Substitution of a classifier here is probably an error\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228301999219\", intentionProvider, errorTarget);\n        }\n      }\n    }\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode iMethodCall, final TypeCheckingContext typeCheckingContext) {\n    SNode baseMethodDeclaration = SLinkOperations.getTarget(iMethodCall, \"baseMethodDeclaration\", false);\n    boolean b = true;\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(baseMethodDeclaration, \"parameter\", true);\n    List<SNode> actualArguments = SLinkOperations.getTargets(iMethodCall, \"actualArgument\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      b = ListSequence.fromList(parameterDeclarations).count() - 1 <= ListSequence.fromList(actualArguments).count();\n    } else\n    {\n      b = ListSequence.fromList(parameterDeclarations).count() == ListSequence.fromList(actualArguments).count();\n    }\n    if (!(b)) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n        intentionProvider.putArgument(\"methodCall\", iMethodCall);\n        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(baseMethodDeclaration, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(iMethodCall, \"wrong number of parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219948518456\", intentionProvider, errorTarget);\n      }\n    }\n    if (SLinkOperations.getCount(baseMethodDeclaration, \"typeVariableDeclaration\") > 0) {\n      for(SNode actual : actualArguments) {\n        typeCheckingContext.addDependencyForCurrent(actual);\n      }\n    }\n  }","id":101335,"modified_method":"public void applyRule(final SNode iMethodCall, final TypeCheckingContext typeCheckingContext) {\n    SNode baseMethodDeclaration = SLinkOperations.getTarget(iMethodCall, \"baseMethodDeclaration\", false);\n    boolean b = true;\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(baseMethodDeclaration, \"parameter\", true);\n    List<SNode> actualArguments = SLinkOperations.getTargets(iMethodCall, \"actualArgument\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      b = ListSequence.fromList(parameterDeclarations).count() - 1 <= ListSequence.fromList(actualArguments).count();\n    } else\n    {\n      b = ListSequence.fromList(parameterDeclarations).count() == ListSequence.fromList(actualArguments).count();\n    }\n    if (!(b)) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n        intentionProvider.putArgument(\"methodCall\", iMethodCall);\n        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(baseMethodDeclaration, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(iMethodCall, \"wrong number of parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219948518456\", intentionProvider, errorTarget);\n      }\n    }\n    if (SLinkOperations.getCount(baseMethodDeclaration, \"typeVariableDeclaration\") > 0) {\n      for(SNode actual : actualArguments) {\n        typeCheckingContext.addDependencyForCurrent(actual);\n      }\n    }\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext) {\n    {\n      final SNode t = subtype;\n      typeCheckingContext.whenConcrete(t, new Runnable() {\n\n        public void run() {\n          {\n            _Patterns.Pattern_9 pattern_0 = new _Patterns.Pattern_9(SLinkOperations.getTarget(supertype, \"classifier\", false));\n            SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(typeCheckingContext.getEquationManager().getRepresentator(t), pattern_0, typeCheckingContext);\n            if (coercedNode_0 != null) {\n              {\n                SNode typeParam;\n                SNode myParam;\n                Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_0, \"parameter\", true).iterator();\n                Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n                while (true) {\n                  if (!(typeParam_iterator.hasNext())) {\n                    break;\n                  }\n                  if (!(myParam_iterator.hasNext())) {\n                    break;\n                  }\n                  typeParam = typeParam_iterator.next();\n                  myParam = myParam_iterator.next();\n                  {\n                    final SNode finalTypeParam = typeParam;\n                    {\n                      SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                      BaseIntentionProvider intentionProvider = null;\n                      typeCheckingContext.createLessThanInequation(finalTypeParam, myParam, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220535076789\", false, 0, intentionProvider);\n                    }\n                    {\n                      final SNode concreteParam = myParam;\n                      typeCheckingContext.whenConcrete(concreteParam, new Runnable() {\n\n                        public void run() {\n                          if (!(SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                            {\n                              SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                              BaseIntentionProvider intentionProvider = null;\n                              typeCheckingContext.createEquation(finalTypeParam, typeCheckingContext.getEquationManager().getRepresentator(concreteParam), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357903\", intentionProvider);\n                            }\n                          }\n                        }\n\n                      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357880\", false, false);\n                    }\n                  }\n                }\n              }\n            } else\n            {\n              SNode nodeWithError = equationInfo.getNodeWithError();\n              SNode methodCall = null;\n              if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = nodeWithError;\n              } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = SNodeOperations.getParent(nodeWithError);\n              }\n              if (methodCall != null) {\n                SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  intentionProvider = new BaseIntentionProvider(\"r:e93cfbed-d604-4676-9018-14ad60bf9faa(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                  intentionProvider.putArgument(\"methodCall\", methodCall);\n                  intentionProvider.putArgument(\"classifier\", classifier);\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1227259028675\", intentionProvider, errorTarget);\n                }\n              } else\n              {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357915\", intentionProvider, errorTarget);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357849\", false, true);\n    }\n  }","id":101336,"modified_method":"public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext) {\n    {\n      final SNode t = subtype;\n      typeCheckingContext.whenConcrete(t, new Runnable() {\n\n        public void run() {\n          {\n            _Patterns.Pattern_9 pattern_0 = new _Patterns.Pattern_9(SLinkOperations.getTarget(supertype, \"classifier\", false));\n            SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(typeCheckingContext.getEquationManager().getRepresentator(t), pattern_0, typeCheckingContext);\n            if (coercedNode_0 != null) {\n              {\n                SNode typeParam;\n                SNode myParam;\n                Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_0, \"parameter\", true).iterator();\n                Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n                while (true) {\n                  if (!(typeParam_iterator.hasNext())) {\n                    break;\n                  }\n                  if (!(myParam_iterator.hasNext())) {\n                    break;\n                  }\n                  typeParam = typeParam_iterator.next();\n                  myParam = myParam_iterator.next();\n                  {\n                    final SNode finalTypeParam = typeParam;\n                    {\n                      SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                      BaseIntentionProvider intentionProvider = null;\n                      typeCheckingContext.createLessThanInequation(finalTypeParam, myParam, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220535076789\", false, 0, intentionProvider);\n                    }\n                    {\n                      final SNode concreteParam = myParam;\n                      typeCheckingContext.whenConcrete(concreteParam, new Runnable() {\n\n                        public void run() {\n                          if (!(SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                            {\n                              SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                              BaseIntentionProvider intentionProvider = null;\n                              typeCheckingContext.createEquation(finalTypeParam, typeCheckingContext.getEquationManager().getRepresentator(concreteParam), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357903\", intentionProvider);\n                            }\n                          }\n                        }\n\n                      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357880\", false, false);\n                    }\n                  }\n                }\n              }\n            } else\n            {\n              SNode nodeWithError = equationInfo.getNodeWithError();\n              SNode methodCall = null;\n              if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = nodeWithError;\n              } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = SNodeOperations.getParent(nodeWithError);\n              }\n              if (methodCall != null) {\n                SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  intentionProvider = new BaseIntentionProvider(\"r:56bcfd97-ecc2-45ba-ba2e-97c475668b5a(jetbrains.mps.baseLanguage.typesystem@17_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                  intentionProvider.putArgument(\"methodCall\", methodCall);\n                  intentionProvider.putArgument(\"classifier\", classifier);\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1227259028675\", intentionProvider, errorTarget);\n                }\n              } else\n              {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357915\", intentionProvider, errorTarget);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357849\", false, true);\n    }\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode clt) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = new ArrayList<SNode>();\n    List<SNode> supertypes = new ArrayList<SNode>();\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = classifier;\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        ListSequence.fromList(supertypes).addElement(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      supertypes.addAll(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = classifier;\n      supertypes.addAll(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true));\n    }\n    if (ListSequence.fromList(supertypes).isEmpty()) {\n      ListSequence.fromList(result).addElement(new _Quotations.QuotationClass_4().createNode());\n    }\n    for(SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.copyNode(supertype);\n      for(SNode typeParam : new ArrayList<SNode>(SLinkOperations.getTargets(supertypeCopy, \"parameter\", true))) {\n        if (SNodeOperations.isInstanceOf(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\")) {\n          SNode tvr = typeParam;\n          int i = ListSequence.fromList(SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(tvr, \"typeVariableDeclaration\", false));\n          if (i < 0 || i >= SLinkOperations.getCount(clt, \"parameter\")) {\n            ((SNode)supertypeCopy).removeChild(typeParam);\n            continue;\n          }\n          SNode newNode = SNodeOperations.copyNode(ListSequence.fromList(((List<SNode>)SLinkOperations.getTargets(clt, \"parameter\", true))).getElement(i));\n          supertypeCopy.replaceChild(typeParam, newNode);\n        }\n      }\n      ListSequence.fromList(result).addElement(supertypeCopy);\n    }\n    ListSequence.fromList(supertypes).addElement(clt);\n    for(SNode supertype : supertypes) {\n      SNode erasure = SNodeOperations.copyNode(supertype);\n      if (SLinkOperations.getCount(erasure, \"parameter\") > 0) {\n        for(SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        ListSequence.fromList(result).addElement(erasure);\n      }\n    }\n    return result;\n  }","id":101337,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode clt) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = new ArrayList<SNode>();\n    List<SNode> supertypes = new ArrayList<SNode>();\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = classifier;\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        ListSequence.fromList(supertypes).addElement(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true)));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = classifier;\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true)));\n    }\n    if (ListSequence.fromList(supertypes).isEmpty()) {\n      ListSequence.fromList(result).addElement(new _Quotations.QuotationClass_4().createNode());\n    }\n    for(SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.copyNode(supertype);\n      for(SNode typeParam : new ArrayList<SNode>(SLinkOperations.getTargets(supertypeCopy, \"parameter\", true))) {\n        if (SNodeOperations.isInstanceOf(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\")) {\n          SNode tvr = typeParam;\n          int i = ListSequence.fromList(SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(tvr, \"typeVariableDeclaration\", false));\n          if (i < 0 || i >= SLinkOperations.getCount(clt, \"parameter\")) {\n            ((SNode)supertypeCopy).removeChild(typeParam);\n            continue;\n          }\n          SNode newNode = SNodeOperations.copyNode(ListSequence.fromList(((List<SNode>)SLinkOperations.getTargets(clt, \"parameter\", true))).getElement(i));\n          supertypeCopy.replaceChild(typeParam, newNode);\n        }\n      }\n      ListSequence.fromList(result).addElement(supertypeCopy);\n    }\n    ListSequence.fromList(supertypes).addElement(clt);\n    for(SNode supertype : supertypes) {\n      SNode erasure = SNodeOperations.copyNode(supertype);\n      if (SLinkOperations.getCount(erasure, \"parameter\") > 0) {\n        for(SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        ListSequence.fromList(result).addElement(erasure);\n      }\n    }\n    return result;\n  }","commit_id":"2e2610b69b0c21992874d64fac221127888d1afc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(SNode node) {\n    if (SNodeOperations.isInstanceOf(((SNode)this.getField(\"methodCall\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassCreator\") && SNodeOperations.isInstanceOf(((SNode)this.getField(\"classifier\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode constructorCall = ((SNode)this.getField(\"methodCall\")[0]);\n      SNode classConcept = ((SNode)this.getField(\"classifier\")[0]);\n      List<SNode> list = SLinkOperations.getTargets(classConcept, \"constructor\", true);\n      for(SNode constructorDeclaration : list) {\n        if (SLinkOperations.getCount(constructorDeclaration, \"parameter\") == SLinkOperations.getCount(constructorCall, \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(SLinkOperations.getTarget(constructorCall, \"baseMethodDeclaration\", false), TypeChecker.getInstance().getTypeOf(constructorCall), ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameter;\n            SNode argument;\n            Iterator<SNode> parameter_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(constructorCall, \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameter_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameter = parameter_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), SLinkOperations.getTarget(parameter, \"type\", true)))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(constructorCall, \"baseMethodDeclaration\", constructorDeclaration, false);\n            return;\n          }\n        }\n      }\n    } else\n    {\n      SNode instanceType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.getParent(((SNode)this.getField(\"methodCall\")[0])), \"operand\", true));\n      ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope((Classifier)((Classifier)SNodeOperations.getAdapter(SLinkOperations.getTarget(instanceType, \"classifier\", false))));\n      List list = scope.getMethodsByName(SPropertyOperations.getString(SLinkOperations.getTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", false), \"name\"));\n      for(Object object : list) {\n        INodeAdapter adapter = (INodeAdapter)object;\n        SNode baseMethodDeclaration = ((SNode)adapter.getNode());\n        if (SLinkOperations.getCount(baseMethodDeclaration, \"parameter\") == SLinkOperations.getCount(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(baseMethodDeclaration, instanceType, ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameterType;\n            SNode argument;\n            Iterator<SNode> parameterType_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameterType_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameterType = parameterType_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", baseMethodDeclaration, false);\n            return;\n          }\n        }\n      }\n    }\n  }","id":101338,"modified_method":"public void execute(SNode node) {\n    if (SNodeOperations.isInstanceOf(((SNode)this.getField(\"methodCall\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassCreator\") && SNodeOperations.isInstanceOf(((SNode)this.getField(\"classifier\")[0]), \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode constructorCall = ((SNode)this.getField(\"methodCall\")[0]);\n      SNode classConcept = ((SNode)this.getField(\"classifier\")[0]);\n      List<SNode> list = SLinkOperations.getTargets(classConcept, \"constructor\", true);\n      for(SNode constructorDeclaration : list) {\n        if (SLinkOperations.getCount(constructorDeclaration, \"parameter\") == SLinkOperations.getCount(constructorCall, \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(SLinkOperations.getTarget(constructorCall, \"baseMethodDeclaration\", false), TypeChecker.getInstance().getTypeOf(constructorCall), ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameter;\n            SNode argument;\n            Iterator<SNode> parameter_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(constructorCall, \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameter_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameter = parameter_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), SLinkOperations.getTarget(parameter, \"type\", true)))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(constructorCall, \"baseMethodDeclaration\", constructorDeclaration, false);\n            return;\n          }\n        }\n      }\n    } else\n    {\n      SNode instanceType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.getParent(((SNode)this.getField(\"methodCall\")[0])), \"operand\", true));\n      ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope((Classifier)((Classifier)SNodeOperations.getAdapter(SLinkOperations.getTarget(instanceType, \"classifier\", false))));\n      List<BaseMethodDeclaration> list = scope.getMethodsByName(SPropertyOperations.getString(SLinkOperations.getTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", false), \"name\"));\n      for(BaseMethodDeclaration object : list) {\n        INodeAdapter adapter = (INodeAdapter)object;\n        SNode baseMethodDeclaration = ((SNode)adapter.getNode());\n        if (SLinkOperations.getCount(baseMethodDeclaration, \"parameter\") == SLinkOperations.getCount(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\")) {\n          boolean good = true;\n          List<SNode> parameterTypes = ResolveUtil.parameterTypes(baseMethodDeclaration, instanceType, ((SNode)this.getField(\"classifier\")[0]));\n          {\n            SNode parameterType;\n            SNode argument;\n            Iterator<SNode> parameterType_iterator = parameterTypes.iterator();\n            Iterator<SNode> argument_iterator = SLinkOperations.getTargets(((SNode)this.getField(\"methodCall\")[0]), \"actualArgument\", true).iterator();\n            while (true) {\n              if (!(parameterType_iterator.hasNext())) {\n                break;\n              }\n              if (!(argument_iterator.hasNext())) {\n                break;\n              }\n              parameterType = parameterType_iterator.next();\n              argument = argument_iterator.next();\n              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {\n                good = false;\n                break;\n              }\n            }\n          }\n          if (good) {\n            SLinkOperations.setTarget(((SNode)this.getField(\"methodCall\")[0]), \"baseMethodDeclaration\", baseMethodDeclaration, false);\n            return;\n          }\n        }\n      }\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean virtual_isSupersetOf_1220438914705(SNode thisNode, SNode t) {\n    if (SNodeOperations.isInstanceOf(t, \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n      do {\n        SNode matchedNode_0 = thisNode;\n        {\n          boolean matches_0 = false;\n          _Patterns.Pattern_0 matchingPattern = new _Patterns.Pattern_0();\n          matches_0 = matchingPattern.match(matchedNode_0);\n          if (matches_0) {\n            return true;\n          }\n        }\n        return false;\n      } while(false);\n    }\n    {\n      _Patterns.Pattern_1 pattern_0 = new _Patterns.Pattern_1(SLinkOperations.getTarget(thisNode, \"classifier\", false));\n      SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_0);\n      if (coercedNode_0 != null) {\n        {\n          SNode typeParam;\n          SNode myParam;\n          Iterator<SNode> typeParam_iterator = pattern_0.PatternVar0.iterator();\n          Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(thisNode, \"parameter\", true).iterator();\n          while (true) {\n            if (!(typeParam_iterator.hasNext())) {\n              break;\n            }\n            if (!(myParam_iterator.hasNext())) {\n              break;\n            }\n            typeParam = typeParam_iterator.next();\n            myParam = myParam_iterator.next();\n            if (SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\")) {\n              if (!(Type_Behavior.call_isSupersetOf_1220438914705(myParam, typeParam))) {\n                return false;\n              }\n            } else\n            {\n              if (!(MatchingUtil.matchNodes(myParam, typeParam))) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      } else\n      {\n      }\n    }\n    return Type_Behavior.callSuper_isSupersetOf_1220438914705(thisNode, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", t);\n  }","id":101339,"modified_method":"public static boolean virtual_isSupersetOf_1220438914705(SNode thisNode, SNode t) {\n    if (SNodeOperations.isInstanceOf(t, \"jetbrains.mps.baseLanguage.structure.WildCardType\")) {\n      do {\n        SNode matchedNode_0 = thisNode;\n        {\n          boolean matches_0 = false;\n          _Patterns.Pattern_0 matchingPattern = new _Patterns.Pattern_0();\n          matches_0 = matchingPattern.match(matchedNode_0);\n          if (matches_0) {\n            return true;\n          }\n        }\n        return false;\n      } while(false);\n    }\n    {\n      _Patterns.Pattern_1 pattern_0 = new _Patterns.Pattern_1();\n      SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_0);\n      if (coercedNode_0 != null) {\n        {\n          SNode typeParam;\n          SNode myParam;\n          Iterator<SNode> typeParam_iterator = pattern_0.PatternVar0.iterator();\n          Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(thisNode, \"parameter\", true).iterator();\n          while (true) {\n            if (!(typeParam_iterator.hasNext())) {\n              break;\n            }\n            if (!(myParam_iterator.hasNext())) {\n              break;\n            }\n            typeParam = typeParam_iterator.next();\n            myParam = myParam_iterator.next();\n            if (SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(myParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\")) {\n              if (!(Type_Behavior.call_isSupersetOf_1220438914705(myParam, typeParam))) {\n                return false;\n              }\n            } else\n            {\n              if (!(MatchingUtil.matchNodes(myParam, typeParam))) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      } else\n      {\n      }\n    }\n    return Type_Behavior.callSuper_isSupersetOf_1220438914705(thisNode, \"jetbrains.mps.baseLanguage.structure.ClassifierType\", t);\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode method = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", true, false);\n      SNode declClassifier = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      if ((declClassifier != null)) {\n        ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(declClassifier)), IClassifiersSearchScope.INSTANCE_METHOD);\n        List<BaseMethodDeclaration> list = scope.getOverriddenMethods(((InstanceMethodDeclaration)SNodeOperations.getAdapter(method)));\n        if (list.size() > 0) {\n          SNode overriden = ((SNode)list.get(0).getNode());\n          editorContext.getOperationContext().getComponent(MPSEditorOpener.class).openNode(overriden);\n        }\n      }\n    }","id":101340,"modified_method":"private void execute_internal(final KeyEvent keyEvent, final EditorContext editorContext, final SNode node, final List<SNode> selectedNodes) {\n      SNode method = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration\", true, false);\n      SNode declClassifier = SNodeOperations.getAncestor(method, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n      if ((declClassifier != null)) {\n        ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(declClassifier)), IClassifiersSearchScope.INSTANCE_METHOD);\n        List<BaseMethodDeclaration> list = scope.getOverriddenMethods(((InstanceMethodDeclaration)SNodeOperations.getAdapter(method)));\n        if (ListSequence.fromList(list).count() > 0) {\n          SNode overriden = ((SNode)ListSequence.fromList(list).getElement(0).getNode());\n          editorContext.getOperationContext().getComponent(MPSEditorOpener.class).openNode(overriden);\n        }\n      }\n    }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MigrationToCollections_MigrationScript(IOperationContext operationContext) {\n    super(\"Migration from List to collections\");\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"ListMigration\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"ListMigration\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~List\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~ArrayList\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~LinkedList\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null);\n        SLinkOperations.setTarget(result, \"elementType\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, result);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Size \";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Size \";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_15().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetSizeOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Get\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Get\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_16().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode access = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListElementAccessExpression\", null);\n        SLinkOperations.setTarget(access, \"list\", SLinkOperations.getTarget(SNodeOperations.getParent(node), \"operand\", true), true);\n        SLinkOperations.setTarget(access, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(SNodeOperations.getParent(node), access);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Clear\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Clear\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_17().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ClearAllElementsOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add first\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add first\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_18().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode opration = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddElementOperation\", null);\n        SLinkOperations.setTarget(opration, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, opration);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add element\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add element\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_19().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.InsertElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).last()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"isEmpty\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"isEmpty\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        LinkedList l2;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_20().createNode(), \"operation\", true), \"baseMethodDeclaration\", false) || SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_21().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.IsEmptyOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"set\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"set\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_22().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.SetElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(0)), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(1)), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"remove\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"remove\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_23().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveAtElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeObject\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeObject\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_24().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"indexOf\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"indexOf\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_25().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetIndexOfOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addAll\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addAll\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_26().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddAllElementsOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_27().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddFirstElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addLast\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addLast\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_28().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddLastElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_29().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveFirstElementOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n  }","id":101341,"modified_method":"public MigrationToCollections_MigrationScript(IOperationContext operationContext) {\n    super(\"Migration from List to collections\");\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"ListMigration\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"ListMigration\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~List\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~ArrayList\") || SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~LinkedList\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListType\", null);\n        if (ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).count() > 0) {\n          SLinkOperations.setTarget(result, \"elementType\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"parameter\", true)).first()), true);\n        } else\n        {\n          SNode type = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\", null);\n          SLinkOperations.setTarget(type, \"classifier\", SNodeOperations.getNode(\"f:java_stub#java.lang(java.lang@java_stub)\", \"~Object\"), false);\n          SLinkOperations.setTarget(result, \"elementType\", type, true);\n        }\n        SNodeOperations.replaceWithAnother(node, result);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"ArrayList\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"ArrayList\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassCreator\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).count() == 0 && SNodeOperations.getParent(SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false)) == SNodeOperations.getNode(\"f:java_stub#java.util(java.util@java_stub)\", \"~ArrayList\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListCreatorWithInit\", null);\n        SLinkOperations.setTarget(result, \"elementType\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"typeParameter\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, result);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Size \";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Size \";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_15().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetSizeOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Get\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Get\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_16().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode access = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ListElementAccessExpression\", null);\n        SLinkOperations.setTarget(access, \"list\", SLinkOperations.getTarget(SNodeOperations.getParent(node), \"operand\", true), true);\n        SLinkOperations.setTarget(access, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(SNodeOperations.getParent(node), access);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Clear\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Clear\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_17().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.ClearAllElementsOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add first\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add first\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        ArrayList arrayList;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_18().createNode(), \"operation\", true), \"baseMethodDeclaration\", false) || SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_19().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode opration = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddElementOperation\", null);\n        SLinkOperations.setTarget(opration, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, opration);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"Add element\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Add element\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_20().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.InsertElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).last()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"isEmpty\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"isEmpty\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        LinkedList l2;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_21().createNode(), \"operation\", true), \"baseMethodDeclaration\", false) || SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_22().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.IsEmptyOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"set\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"set\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_23().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.SetElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"index\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(0)), true);\n        SLinkOperations.setTarget(operation, \"element\", SNodeOperations.copyNode(ListSequence.fromList(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).toListSequence()).getElement(1)), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeObject\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeObject\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_24().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"indexOf\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"indexOf\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_25().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.GetIndexOfOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addAll\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addAll\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        List l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_26().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddAllElementsOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_27().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddFirstElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"addLast\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"addLast\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_28().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNode operation = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.AddLastElementOperation\", null);\n        SLinkOperations.setTarget(operation, \"argument\", SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(node, \"actualArgument\", true)).first()), true);\n        SNodeOperations.replaceWithAnother(node, operation);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n\n      public String getName() {\n        return \"removeFirst\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"removeFirst\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        LinkedList l;\n        return SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SLinkOperations.getTarget(SLinkOperations.getTarget(new _Quotations.QuotationClass_29().createNode(), \"operation\", true), \"baseMethodDeclaration\", false);\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SNodeOperations.replaceWithAnother(node, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.collections.structure.RemoveFirstElementOperation\", null));\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n\n    });\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode arrayType) {\n    // see JLS 3.0\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(arrayType, \"componentType\", true), \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n      return CollectionUtil.list(new _Quotations.QuotationClass_82().createNode(), new _Quotations.QuotationClass_83().createNode(), new _Quotations.QuotationClass_84().createNode());\n    }\n    return new ArrayList<SNode>();\n  }","id":101342,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode arrayType) {\n    // see JLS 3.0\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(arrayType, \"componentType\", true), \"jetbrains.mps.baseLanguage.structure.PrimitiveType\")) {\n      return CollectionUtil.list(new _Quotations.QuotationClass_82().createNode(), new _Quotations.QuotationClass_83().createNode(), new _Quotations.QuotationClass_84().createNode());\n    }\n    return ListSequence.<SNode>fromArray();\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> parameterTypes(SNode method, SNode instanceType, SNode classifier) {\n    List<SNode> result = new LinkedList<SNode>();\n    boolean containsVars = false;\n    for(SNode parameter : SLinkOperations.getTargets(method, \"parameter\", true)) {\n      if (ListSequence.fromList(SNodeOperations.getDescendants(parameter, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)).isNotEmpty()) {\n        containsVars = true;\n      }\n      result.add(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter, \"type\", true)));\n    }\n    if (!(containsVars)) {\n      return result;\n    }\n    Set<SNode> frontier = new HashSet<SNode>();\n    frontier.add(instanceType);\n    SNode concreteMethodClassifierType = ResolveUtil.getConcreteSuperClassifierType(frontier, classifier);\n    if (concreteMethodClassifierType == null) {\n      return result;\n    }\n    List<SNode> typeParameters = ListSequence.fromList(SLinkOperations.getTargets(concreteMethodClassifierType, \"parameter\", true)).toListSequence();\n    for(SNode paramType : new ArrayList<SNode>(result)) {\n      for(SNode typeVar : SNodeOperations.getDescendants(paramType, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)) {\n        SNode replacement = SNodeOperations.copyNode(ListSequence.fromList(typeParameters).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false))));\n        if ((SNodeOperations.getParent(typeVar) == null)) {\n          result.add(result.indexOf(typeVar), replacement);\n          result.remove(typeVar);\n        } else\n        {\n          SNodeOperations.replaceWithAnother(typeVar, replacement);\n        }\n      }\n    }\n    return result;\n  }","id":101343,"modified_method":"public static List<SNode> parameterTypes(SNode method, SNode instanceType, SNode classifier) {\n    List<SNode> result = new LinkedList<SNode>();\n    boolean containsVars = false;\n    for(SNode parameter : SLinkOperations.getTargets(method, \"parameter\", true)) {\n      if (ListSequence.fromList(SNodeOperations.getDescendants(parameter, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)).isNotEmpty()) {\n        containsVars = true;\n      }\n      ListSequence.fromList(result).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter, \"type\", true)));\n    }\n    if (!(containsVars)) {\n      return result;\n    }\n    Set<SNode> frontier = new HashSet<SNode>();\n    frontier.add(instanceType);\n    SNode concreteMethodClassifierType = ResolveUtil.getConcreteSuperClassifierType(frontier, classifier);\n    if (concreteMethodClassifierType == null) {\n      return result;\n    }\n    List<SNode> typeParameters = ListSequence.fromList(SLinkOperations.getTargets(concreteMethodClassifierType, \"parameter\", true)).toListSequence();\n    for(SNode paramType : new ArrayList<SNode>(result)) {\n      for(SNode typeVar : SNodeOperations.getDescendants(paramType, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true)) {\n        SNode replacement = SNodeOperations.copyNode(ListSequence.fromList(typeParameters).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false))));\n        if ((SNodeOperations.getParent(typeVar) == null)) {\n          ListSequence.fromList(result).insertElement(ListSequence.fromList(result).indexOf(typeVar), replacement);\n          ListSequence.fromList(result).removeElement(typeVar);\n        } else\n        {\n          SNodeOperations.replaceWithAnother(typeVar, replacement);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@CheckingMethod()\n  /* package */static void check(final TypeCheckingContext typeCheckingContext, Set<SNode> throwables, SNode mainNode) {\n    for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_29().createNode(typeCheckingContext)) || TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_28().createNode(typeCheckingContext))) {\n        throwables.remove(livingThrowable);\n      }\n    }\n    if (throwables.isEmpty()) {\n      return;\n    }\n    List<SNode> statementLists = SNodeOperations.getAncestors(mainNode, \"jetbrains.mps.baseLanguage.structure.StatementList\", false);\n    for(SNode statementList : statementLists) {\n      SNode parent = SNodeOperations.getParent(statementList);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryCatchStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryCatchStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode baseMethodDeclaration = parent;\n        for(SNode throwableType : SLinkOperations.getTargets(baseMethodDeclaration, \"throwsItem\", true)) {\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n        if (!(throwables.isEmpty())) {\n          String errorString = \"uncaught exceptions:\";\n          for(SNode exc : throwables) {\n            errorString = errorString + \" \" + exc;\n          }\n          {\n            BaseIntentionProvider intentionProvider = null;\n            intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).AddExceptionToMethodSignature_QuickFix\", false);\n            intentionProvider.putArgument(\"throwableType\", throwables.iterator().next());\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            typeCheckingContext.reportTypeError(mainNode, errorString, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1210182111558\", intentionProvider, errorTarget);\n          }\n        }\n        return;\n      }\n    }\n  }","id":101344,"modified_method":"@CheckingMethod()\n  /* package */static void check(final TypeCheckingContext typeCheckingContext, Set<SNode> throwables, SNode mainNode) {\n    for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n      if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_29().createNode(typeCheckingContext)) || TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, new _Quotations.QuotationClass_28().createNode(typeCheckingContext))) {\n        throwables.remove(livingThrowable);\n      }\n    }\n    if (throwables.isEmpty()) {\n      return;\n    }\n    List<SNode> statementLists = SNodeOperations.getAncestors(mainNode, \"jetbrains.mps.baseLanguage.structure.StatementList\", false);\n    for(SNode statementList : statementLists) {\n      SNode parent = SNodeOperations.getParent(statementList);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode tryCatchStatement = parent;\n        for(SNode catchClause : SLinkOperations.getTargets(tryCatchStatement, \"catchClause\", true)) {\n          SNode throwableType = SLinkOperations.getTarget(SLinkOperations.getTarget(catchClause, \"throwable\", true), \"type\", true);\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n      }\n      if (throwables.isEmpty()) {\n        return;\n      }\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\") && SLinkOperations.getTarget(parent, \"body\", true) == statementList) {\n        SNode baseMethodDeclaration = parent;\n        for(SNode throwableType : SLinkOperations.getTargets(baseMethodDeclaration, \"throwsItem\", true)) {\n          for(SNode livingThrowable : new HashSet<SNode>(throwables)) {\n            if (TypeChecker.getInstance().getSubtypingManager().isSubtype(livingThrowable, throwableType)) {\n              throwables.remove(livingThrowable);\n            }\n          }\n        }\n        if (!(throwables.isEmpty())) {\n          String errorString = \"uncaught exceptions:\";\n          for(SNode exc : throwables) {\n            errorString = errorString + \" \" + exc;\n          }\n          {\n            BaseIntentionProvider intentionProvider = null;\n            intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).AddExceptionToMethodSignature_QuickFix\", false);\n            intentionProvider.putArgument(\"throwableType\", throwables.iterator().next());\n            IErrorTarget errorTarget = new NodeErrorTarget();\n            typeCheckingContext.reportTypeError(mainNode, errorString, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1210182111558\", intentionProvider, errorTarget);\n          }\n        }\n        return;\n      }\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@InferenceMethod()\n  public static void inference_matchConcreteTypesWithTypeVariables(final TypeCheckingContext typeCheckingContext, SNode genericClassifier, SNode instanceType, Map<SNode, List<SNode>> mmap) {\n    if ((genericClassifier != null) && mmap != null && !(mmap.isEmpty())) {\n      List<SNode> params = new ArrayList<SNode>();\n      for(SNode tvd : SLinkOperations.getTargets(genericClassifier, \"typeVariableDeclaration\", true)) {\n        List<SNode> nodes = mmap.get(tvd);\n        final SNode p_typevar_1228174472023 = typeCheckingContext.createNewRuntimeTypesVariable();\n        if (nodes != null) {\n          SNode tvar = ListSequence.fromList(nodes).getElement(0);\n          if (TRACE_METHOD_TYPES) {\n            System.out.println(\"-2- \" + BaseConcept_Behavior.call_getPresentation_1213877396640(tvar) + \" :==: \" + BaseConcept_Behavior.call_getPresentation_1213877396640(ListSequence.fromList(nodes).getElement(0)));\n          }\n          {\n            SNode _nodeToCheck_1029348928467 = null;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createEquation(tvar, typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174300650\", intentionProvider);\n          }\n        }\n        ListSequence.fromList(params).addElement(typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023));\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(instanceType, new _Quotations.QuotationClass_27().createNode(params, genericClassifier, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174029908\", false, 0, intentionProvider);\n      }\n    }\n  }","id":101345,"modified_method":"@InferenceMethod()\n  public static void inference_matchConcreteTypesWithTypeVariables(final TypeCheckingContext typeCheckingContext, SNode genericClassifier, SNode instanceType, Map<SNode, List<SNode>> mmap) {\n    if ((genericClassifier != null) && mmap != null && !(mmap.isEmpty())) {\n      List<SNode> params = ListSequence.<SNode>fromArray();\n      for(SNode tvd : SLinkOperations.getTargets(genericClassifier, \"typeVariableDeclaration\", true)) {\n        List<SNode> nodes = mmap.get(tvd);\n        final SNode p_typevar_1228174472023 = typeCheckingContext.createNewRuntimeTypesVariable();\n        if (nodes != null) {\n          SNode tvar = ListSequence.fromList(nodes).getElement(0);\n          if (TRACE_METHOD_TYPES) {\n            System.out.println(\"-2- \" + BaseConcept_Behavior.call_getPresentation_1213877396640(tvar) + \" :==: \" + BaseConcept_Behavior.call_getPresentation_1213877396640(ListSequence.fromList(nodes).getElement(0)));\n          }\n          {\n            SNode _nodeToCheck_1029348928467 = null;\n            BaseIntentionProvider intentionProvider = null;\n            typeCheckingContext.createEquation(tvar, typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174300650\", intentionProvider);\n          }\n        }\n        ListSequence.fromList(params).addElement(typeCheckingContext.getEquationManager().getRepresentator(p_typevar_1228174472023));\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createLessThanInequation(instanceType, new _Quotations.QuotationClass_27().createNode(params, genericClassifier, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228174029908\", false, 0, intentionProvider);\n      }\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@InferenceMethod()\n  public static void inference_equateParametersAndReturnType(final TypeCheckingContext typeCheckingContext, final SNode mc, SNode returnType, Map<SNode, List<SNode>> mmap) {\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      Iterator<SNode> formalIterator = ((List<SNode>)parameterDeclarations).iterator();\n      Iterator<SNode> actualIterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n      SNode formalParam = null;\n      SNode actualParam = null;\n      while (true) {\n        if (!(actualIterator.hasNext())) {\n          break;\n        }\n        if (!(formalIterator.hasNext())) {\n          break;\n        }\n        formalParam = formalIterator.next();\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalParam, \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n          break;\n        }\n        actualParam = actualIterator.next();\n        SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(formalParam, \"type\", true), mmap);\n        {\n          SNode _nodeToCheck_1029348928467 = actualParam;\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n          intentionProvider.putArgument(\"methodCall\", mc);\n          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n          typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actualParam, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530380\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530376\", false, 2, intentionProvider);\n        }\n      }\n      do {\n        SNode matchedNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n        {\n          boolean matches_3 = false;\n          {\n            SNode matchingNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n            if (matchingNode_3 != null) {\n              matches_3 = SModelUtil_new.isAssignableConcept(matchingNode_3.getConceptFqName(), \"jetbrains.mps.baseLanguage.structure.VariableArityType\");\n            }\n          }\n          if (matches_3) {\n            {\n              SNode componentType = SLinkOperations.getTarget(matchedNode_3, \"componentType\", true);\n              final SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, componentType, mmap);\n              if (SLinkOperations.getCount(mc, \"actualArgument\") == ListSequence.fromList(parameterDeclarations).count()) {\n                // the actual parameter may appear to be an array instead of vararg\n                final SNode actual = actualIterator.next();\n                {\n                  final SNode actualType = typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347108709\", true);\n                  typeCheckingContext.whenConcrete(actualType, new Runnable() {\n\n                    public void run() {\n                      if (SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n                        {\n                          SNode _nodeToCheck_1029348928467 = actual;\n                          BaseIntentionProvider intentionProvider = null;\n                          intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                          intentionProvider.putArgument(\"methodCall\", mc);\n                          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                          typeCheckingContext.createLessThanInequation(SLinkOperations.getTarget(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"componentType\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347279318\", false, 2, intentionProvider);\n                        }\n                      } else\n                      {\n                        SNode _nodeToCheck_1029348928467 = actual;\n                        BaseIntentionProvider intentionProvider = null;\n                        intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                        intentionProvider.putArgument(\"methodCall\", mc);\n                        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                        typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(actualType), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347200873\", false, 2, intentionProvider);\n                      }\n                    }\n\n                  }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347102532\", false, false);\n                }\n              } else\n              {\n                // in this case the actual parameter is definitely a vararg\n                while (actualIterator.hasNext()) {\n                  SNode actual = actualIterator.next();\n                  {\n                    SNode _nodeToCheck_1029348928467 = actual;\n                    BaseIntentionProvider intentionProvider = null;\n                    intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                    intentionProvider.putArgument(\"methodCall\", mc);\n                    intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                    typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702426\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702422\", false, 2, intentionProvider);\n                  }\n                }\n              }\n            }\n            break;\n          }\n        }\n      } while(false);\n    } else\n    {\n      {\n        SNode arg;\n        SNode param;\n        Iterator<SNode> arg_iterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n        Iterator<SNode> param_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true).iterator();\n        while (true) {\n          if (!(arg_iterator.hasNext())) {\n            break;\n          }\n          if (!(param_iterator.hasNext())) {\n            break;\n          }\n          arg = arg_iterator.next();\n          param = param_iterator.next();\n          {\n            SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(param, \"type\", true), mmap);\n            {\n              SNode _nodeToCheck_1029348928467 = arg;\n              BaseIntentionProvider intentionProvider = null;\n              intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n              intentionProvider.putArgument(\"methodCall\", mc);\n              intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n              typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(arg, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371331\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371327\", false, 2, intentionProvider);\n            }\n          }\n        }\n      }\n    }\n    if (returnType != null) {\n      SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, returnType, mmap);\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(mc, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371361\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371359\", intentionProvider);\n      }\n    }\n  }","id":101346,"modified_method":"@InferenceMethod()\n  public static void inference_equateParametersAndReturnType(final TypeCheckingContext typeCheckingContext, final SNode mc, SNode returnType, Map<SNode, List<SNode>> mmap) {\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      Iterator<SNode> formalIterator = ((List<SNode>)parameterDeclarations).iterator();\n      Iterator<SNode> actualIterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n      SNode formalParam = null;\n      SNode actualParam = null;\n      while (true) {\n        if (!(actualIterator.hasNext())) {\n          break;\n        }\n        if (!(formalIterator.hasNext())) {\n          break;\n        }\n        formalParam = formalIterator.next();\n        if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(formalParam, \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n          break;\n        }\n        actualParam = actualIterator.next();\n        SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(formalParam, \"type\", true), mmap);\n        {\n          SNode _nodeToCheck_1029348928467 = actualParam;\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n          intentionProvider.putArgument(\"methodCall\", mc);\n          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n          typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actualParam, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530380\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947530376\", false, 2, intentionProvider);\n        }\n      }\n      do {\n        SNode matchedNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n        {\n          boolean matches_3 = false;\n          {\n            SNode matchingNode_3 = SLinkOperations.getTarget(formalParam, \"type\", true);\n            if (matchingNode_3 != null) {\n              matches_3 = SModelUtil_new.isAssignableConcept(matchingNode_3.getConceptFqName(), \"jetbrains.mps.baseLanguage.structure.VariableArityType\");\n            }\n          }\n          if (matches_3) {\n            {\n              SNode componentType = SLinkOperations.getTarget(matchedNode_3, \"componentType\", true);\n              final SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, componentType, mmap);\n              if (SLinkOperations.getCount(mc, \"actualArgument\") == ListSequence.fromList(parameterDeclarations).count()) {\n                // the actual parameter may appear to be an array instead of vararg\n                final SNode actual = actualIterator.next();\n                {\n                  final SNode actualType = typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347108709\", true);\n                  typeCheckingContext.whenConcrete(actualType, new Runnable() {\n\n                    public void run() {\n                      if (SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"jetbrains.mps.baseLanguage.structure.ArrayType\")) {\n                        {\n                          SNode _nodeToCheck_1029348928467 = actual;\n                          BaseIntentionProvider intentionProvider = null;\n                          intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                          intentionProvider.putArgument(\"methodCall\", mc);\n                          intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                          typeCheckingContext.createLessThanInequation(SLinkOperations.getTarget(typeCheckingContext.getEquationManager().getRepresentator(actualType), \"componentType\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347279318\", false, 2, intentionProvider);\n                        }\n                      } else\n                      {\n                        SNode _nodeToCheck_1029348928467 = actual;\n                        BaseIntentionProvider intentionProvider = null;\n                        intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                        intentionProvider.putArgument(\"methodCall\", mc);\n                        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                        typeCheckingContext.createLessThanInequation(typeCheckingContext.getEquationManager().getRepresentator(actualType), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347200873\", false, 2, intentionProvider);\n                      }\n                    }\n\n                  }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220347102532\", false, false);\n                }\n              } else\n              {\n                // in this case the actual parameter is definitely a vararg\n                while (actualIterator.hasNext()) {\n                  SNode actual = actualIterator.next();\n                  {\n                    SNode _nodeToCheck_1029348928467 = actual;\n                    BaseIntentionProvider intentionProvider = null;\n                    intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                    intentionProvider.putArgument(\"methodCall\", mc);\n                    intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n                    typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(actual, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702426\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219947702422\", false, 2, intentionProvider);\n                  }\n                }\n              }\n            }\n            break;\n          }\n        }\n      } while(false);\n    } else\n    {\n      {\n        SNode arg;\n        SNode param;\n        Iterator<SNode> arg_iterator = SLinkOperations.getTargets(mc, \"actualArgument\", true).iterator();\n        Iterator<SNode> param_iterator = SLinkOperations.getTargets(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"parameter\", true).iterator();\n        while (true) {\n          if (!(arg_iterator.hasNext())) {\n            break;\n          }\n          if (!(param_iterator.hasNext())) {\n            break;\n          }\n          arg = arg_iterator.next();\n          param = param_iterator.next();\n          {\n            SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, SLinkOperations.getTarget(param, \"type\", true), mmap);\n            {\n              SNode _nodeToCheck_1029348928467 = arg;\n              BaseIntentionProvider intentionProvider = null;\n              intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n              intentionProvider.putArgument(\"methodCall\", mc);\n              intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(SLinkOperations.getTarget(mc, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n              typeCheckingContext.createLessThanInequation(typeCheckingContext.typeOf(arg, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371331\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371327\", false, 2, intentionProvider);\n            }\n          }\n        }\n      }\n    }\n    if (returnType != null) {\n      SNode matchedType = inference_matchTypeWithTypeVariables(typeCheckingContext, returnType, mmap);\n      {\n        SNode _nodeToCheck_1029348928467 = null;\n        BaseIntentionProvider intentionProvider = null;\n        typeCheckingContext.createEquation(typeCheckingContext.typeOf(mc, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371361\", true), matchedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1203441371359\", intentionProvider);\n      }\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      SLinkOperations.getTargets(node, \"auxBounds\", true).clear();\n      SLinkOperations.setTarget(node, \"bound\", null, true);\n    }","id":101347,"modified_method":"public void execute_internal(EditorContext editorContext, SNode node) {\n      ListSequence.fromList(SLinkOperations.getTargets(node, \"auxBounds\", true)).clear();\n      SLinkOperations.setTarget(node, \"bound\", null, true);\n    }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode antiquotation, final TypeCheckingContext typeCheckingContext) {\n    SNode contentsType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(antiquotation, \"expression\", true));\n    if (SNodeOperations.isInstanceOf(contentsType, \"jetbrains.mps.lang.smodel.structure.SNodeType\")) {\n      if (SConceptOperations.isSubConceptOf(SLinkOperations.getTarget(contentsType, \"concept\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ReplaceClassAntiquotationWithClassifierType_QuickFix\");\n          intentionProvider.putArgument(\"antiquotation\", antiquotation);\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          typeCheckingContext.reportWarning(SLinkOperations.getTarget(antiquotation, \"expression\", true), \"Substitution of a classifier here is probably an error\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228301999219\", intentionProvider, errorTarget);\n        }\n      }\n    }\n  }","id":101348,"modified_method":"public void applyRule(final SNode antiquotation, final TypeCheckingContext typeCheckingContext) {\n    SNode contentsType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(antiquotation, \"expression\", true));\n    if (SNodeOperations.isInstanceOf(contentsType, \"jetbrains.mps.lang.smodel.structure.SNodeType\")) {\n      if (SConceptOperations.isSubConceptOf(SLinkOperations.getTarget(contentsType, \"concept\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ReplaceClassAntiquotationWithClassifierType_QuickFix\");\n          intentionProvider.putArgument(\"antiquotation\", antiquotation);\n          IErrorTarget errorTarget = new NodeErrorTarget();\n          typeCheckingContext.reportWarning(SLinkOperations.getTarget(antiquotation, \"expression\", true), \"Substitution of a classifier here is probably an error\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1228301999219\", intentionProvider, errorTarget);\n        }\n      }\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode iMethodCall, final TypeCheckingContext typeCheckingContext) {\n    SNode baseMethodDeclaration = SLinkOperations.getTarget(iMethodCall, \"baseMethodDeclaration\", false);\n    boolean b = true;\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(baseMethodDeclaration, \"parameter\", true);\n    List<SNode> actualArguments = SLinkOperations.getTargets(iMethodCall, \"actualArgument\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      b = ListSequence.fromList(parameterDeclarations).count() - 1 <= ListSequence.fromList(actualArguments).count();\n    } else\n    {\n      b = ListSequence.fromList(parameterDeclarations).count() == ListSequence.fromList(actualArguments).count();\n    }\n    if (!(b)) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n        intentionProvider.putArgument(\"methodCall\", iMethodCall);\n        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(baseMethodDeclaration, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(iMethodCall, \"wrong number of parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219948518456\", intentionProvider, errorTarget);\n      }\n    }\n    if (SLinkOperations.getCount(baseMethodDeclaration, \"typeVariableDeclaration\") > 0) {\n      for(SNode actual : actualArguments) {\n        typeCheckingContext.addDependencyForCurrent(actual);\n      }\n    }\n  }","id":101349,"modified_method":"public void applyRule(final SNode iMethodCall, final TypeCheckingContext typeCheckingContext) {\n    SNode baseMethodDeclaration = SLinkOperations.getTarget(iMethodCall, \"baseMethodDeclaration\", false);\n    boolean b = true;\n    List<SNode> parameterDeclarations = SLinkOperations.getTargets(baseMethodDeclaration, \"parameter\", true);\n    List<SNode> actualArguments = SLinkOperations.getTargets(iMethodCall, \"actualArgument\", true);\n    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(ListSequence.fromList(parameterDeclarations).last(), \"type\", true), \"jetbrains.mps.baseLanguage.structure.VariableArityType\")) {\n      b = ListSequence.fromList(parameterDeclarations).count() - 1 <= ListSequence.fromList(actualArguments).count();\n    } else\n    {\n      b = ListSequence.fromList(parameterDeclarations).count() == ListSequence.fromList(actualArguments).count();\n    }\n    if (!(b)) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n        intentionProvider.putArgument(\"methodCall\", iMethodCall);\n        intentionProvider.putArgument(\"classifier\", SNodeOperations.getAncestor(baseMethodDeclaration, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false));\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(iMethodCall, \"wrong number of parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1219948518456\", intentionProvider, errorTarget);\n      }\n    }\n    if (SLinkOperations.getCount(baseMethodDeclaration, \"typeVariableDeclaration\") > 0) {\n      for(SNode actual : actualArguments) {\n        typeCheckingContext.addDependencyForCurrent(actual);\n      }\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext) {\n    {\n      final SNode t = subtype;\n      typeCheckingContext.whenConcrete(t, new Runnable() {\n\n        public void run() {\n          {\n            _Patterns.Pattern_9 pattern_0 = new _Patterns.Pattern_9(SLinkOperations.getTarget(supertype, \"classifier\", false));\n            SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(typeCheckingContext.getEquationManager().getRepresentator(t), pattern_0, typeCheckingContext);\n            if (coercedNode_0 != null) {\n              {\n                SNode typeParam;\n                SNode myParam;\n                Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_0, \"parameter\", true).iterator();\n                Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n                while (true) {\n                  if (!(typeParam_iterator.hasNext())) {\n                    break;\n                  }\n                  if (!(myParam_iterator.hasNext())) {\n                    break;\n                  }\n                  typeParam = typeParam_iterator.next();\n                  myParam = myParam_iterator.next();\n                  {\n                    final SNode finalTypeParam = typeParam;\n                    {\n                      SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                      BaseIntentionProvider intentionProvider = null;\n                      typeCheckingContext.createLessThanInequation(finalTypeParam, myParam, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220535076789\", false, 0, intentionProvider);\n                    }\n                    {\n                      final SNode concreteParam = myParam;\n                      typeCheckingContext.whenConcrete(concreteParam, new Runnable() {\n\n                        public void run() {\n                          if (!(SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                            {\n                              SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                              BaseIntentionProvider intentionProvider = null;\n                              typeCheckingContext.createEquation(finalTypeParam, typeCheckingContext.getEquationManager().getRepresentator(concreteParam), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357903\", intentionProvider);\n                            }\n                          }\n                        }\n\n                      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357880\", false, false);\n                    }\n                  }\n                }\n              }\n            } else\n            {\n              SNode nodeWithError = equationInfo.getNodeWithError();\n              SNode methodCall = null;\n              if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = nodeWithError;\n              } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = SNodeOperations.getParent(nodeWithError);\n              }\n              if (methodCall != null) {\n                SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  intentionProvider = new BaseIntentionProvider(\"r:8b97b114-9ad5-4768-9af5-bcb4e6ab8b57(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                  intentionProvider.putArgument(\"methodCall\", methodCall);\n                  intentionProvider.putArgument(\"classifier\", classifier);\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1227259028675\", intentionProvider, errorTarget);\n                }\n              } else\n              {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357915\", intentionProvider, errorTarget);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357849\", false, true);\n    }\n  }","id":101350,"modified_method":"public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext) {\n    {\n      final SNode t = subtype;\n      typeCheckingContext.whenConcrete(t, new Runnable() {\n\n        public void run() {\n          {\n            _Patterns.Pattern_9 pattern_0 = new _Patterns.Pattern_9();\n            SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(typeCheckingContext.getEquationManager().getRepresentator(t), pattern_0, typeCheckingContext);\n            if (coercedNode_0 != null) {\n              {\n                SNode typeParam;\n                SNode myParam;\n                Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_0, \"parameter\", true).iterator();\n                Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n                while (true) {\n                  if (!(typeParam_iterator.hasNext())) {\n                    break;\n                  }\n                  if (!(myParam_iterator.hasNext())) {\n                    break;\n                  }\n                  typeParam = typeParam_iterator.next();\n                  myParam = myParam_iterator.next();\n                  {\n                    final SNode finalTypeParam = typeParam;\n                    {\n                      SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                      BaseIntentionProvider intentionProvider = null;\n                      typeCheckingContext.createLessThanInequation(finalTypeParam, myParam, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220535076789\", false, 0, intentionProvider);\n                    }\n                    {\n                      final SNode concreteParam = myParam;\n                      typeCheckingContext.whenConcrete(concreteParam, new Runnable() {\n\n                        public void run() {\n                          if (!(SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(typeCheckingContext.getEquationManager().getRepresentator(concreteParam), \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                            {\n                              SNode _nodeToCheck_1029348928467 = equationInfo.getNodeWithError();\n                              BaseIntentionProvider intentionProvider = null;\n                              typeCheckingContext.createEquation(finalTypeParam, typeCheckingContext.getEquationManager().getRepresentator(concreteParam), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357903\", intentionProvider);\n                            }\n                          }\n                        }\n\n                      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357880\", false, false);\n                    }\n                  }\n                }\n              }\n            } else\n            {\n              SNode nodeWithError = equationInfo.getNodeWithError();\n              SNode methodCall = null;\n              if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = nodeWithError;\n              } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n                methodCall = SNodeOperations.getParent(nodeWithError);\n              }\n              if (methodCall != null) {\n                SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  intentionProvider = new BaseIntentionProvider(\"r:9095eee1-b8e6-4029-bacd-db6690a4d836(jetbrains.mps.baseLanguage.typesystem@3_0).ChooseAppropriateMethodDeclaration_QuickFix\", true);\n                  intentionProvider.putArgument(\"methodCall\", methodCall);\n                  intentionProvider.putArgument(\"classifier\", classifier);\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1227259028675\", intentionProvider, errorTarget);\n                }\n              } else\n              {\n                {\n                  BaseIntentionProvider intentionProvider = null;\n                  IErrorTarget errorTarget = new NodeErrorTarget();\n                  typeCheckingContext.reportTypeError(nodeWithError, BaseConcept_Behavior.call_getPresentation_1213877396640(subtype) + \" is not a subtype of \" + BaseConcept_Behavior.call_getPresentation_1213877396640(supertype), \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357915\", intentionProvider, errorTarget);\n                }\n              }\n            }\n          }\n        }\n\n      }, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1220523357849\", false, true);\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean checkInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo) {\n    boolean result_14532009 = true;\n    {\n      final SNode t = subtype;\n      {\n        _Patterns.Pattern_9 pattern_1 = new _Patterns.Pattern_9(SLinkOperations.getTarget(supertype, \"classifier\", false));\n        SNode coercedNode_1 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_1);\n        if (coercedNode_1 != null) {\n          {\n            SNode typeParam;\n            SNode myParam;\n            Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_1, \"parameter\", true).iterator();\n            Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n            while (true) {\n              if (!(typeParam_iterator.hasNext())) {\n                break;\n              }\n              if (!(myParam_iterator.hasNext())) {\n                break;\n              }\n              typeParam = typeParam_iterator.next();\n              myParam = myParam_iterator.next();\n              {\n                final SNode finalTypeParam = typeParam;\n                result_14532009 = result_14532009 && TypeChecker.getInstance().getSubtypingManager().isSubtype(finalTypeParam, myParam, true);\n                {\n                  final SNode concreteParam = myParam;\n                  if (!(SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                    result_14532009 = result_14532009 && MatchingUtil.matchNodes(finalTypeParam, concreteParam);\n                  }\n                }\n              }\n            }\n          }\n        } else\n        {\n          SNode nodeWithError = equationInfo.getNodeWithError();\n          SNode methodCall = null;\n          if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = nodeWithError;\n          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = SNodeOperations.getParent(nodeWithError);\n          }\n          if (methodCall != null) {\n            SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n            result_14532009 = false;\n          } else\n          {\n            result_14532009 = false;\n          }\n        }\n      }\n    }\n    return result_14532009;\n  }","id":101351,"modified_method":"public boolean checkInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo) {\n    boolean result_14532009 = true;\n    {\n      final SNode t = subtype;\n      {\n        _Patterns.Pattern_9 pattern_1 = new _Patterns.Pattern_9();\n        SNode coercedNode_1 = TypeChecker.getInstance().getRuntimeSupport().coerce_(t, pattern_1);\n        if (coercedNode_1 != null) {\n          {\n            SNode typeParam;\n            SNode myParam;\n            Iterator<SNode> typeParam_iterator = SLinkOperations.getTargets(coercedNode_1, \"parameter\", true).iterator();\n            Iterator<SNode> myParam_iterator = SLinkOperations.getTargets(supertype, \"parameter\", true).iterator();\n            while (true) {\n              if (!(typeParam_iterator.hasNext())) {\n                break;\n              }\n              if (!(myParam_iterator.hasNext())) {\n                break;\n              }\n              typeParam = typeParam_iterator.next();\n              myParam = myParam_iterator.next();\n              {\n                final SNode finalTypeParam = typeParam;\n                result_14532009 = result_14532009 && TypeChecker.getInstance().getSubtypingManager().isSubtype(finalTypeParam, myParam, true);\n                {\n                  final SNode concreteParam = myParam;\n                  if (!(SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(concreteParam, \"jetbrains.mps.baseLanguage.structure.UpperBoundType\"))) {\n                    result_14532009 = result_14532009 && MatchingUtil.matchNodes(finalTypeParam, concreteParam);\n                  }\n                }\n              }\n            }\n          }\n        } else\n        {\n          SNode nodeWithError = equationInfo.getNodeWithError();\n          SNode methodCall = null;\n          if (SNodeOperations.isInstanceOf(nodeWithError, \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = nodeWithError;\n          } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(nodeWithError), \"jetbrains.mps.baseLanguage.structure.IMethodCall\")) {\n            methodCall = SNodeOperations.getParent(nodeWithError);\n          }\n          if (methodCall != null) {\n            SNode classifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false);\n            result_14532009 = false;\n          } else\n          {\n            result_14532009 = false;\n          }\n        }\n      }\n    }\n    return result_14532009;\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode clt) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = new ArrayList<SNode>();\n    List<SNode> supertypes = new ArrayList<SNode>();\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = classifier;\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        supertypes.add(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      supertypes.addAll(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = classifier;\n      supertypes.addAll(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true));\n    }\n    if (supertypes.isEmpty()) {\n      result.add(new _Quotations.QuotationClass_4().createNode());\n    }\n    for(SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.copyNode(supertype);\n      for(SNode typeParam : new ArrayList<SNode>(SLinkOperations.getTargets(supertypeCopy, \"parameter\", true))) {\n        if (SNodeOperations.isInstanceOf(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\")) {\n          SNode tvr = typeParam;\n          int i = ((List)SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(tvr, \"typeVariableDeclaration\", false));\n          if (i < 0 || i >= SLinkOperations.getCount(clt, \"parameter\")) {\n            ((SNode)supertypeCopy).removeChild(typeParam);\n            continue;\n          }\n          SNode newNode = SNodeOperations.copyNode(((SNode)((List)SLinkOperations.getTargets(clt, \"parameter\", true)).get(i)));\n          supertypeCopy.replaceChild(typeParam, newNode);\n        }\n      }\n      result.add(supertypeCopy);\n    }\n    supertypes.add(clt);\n    for(SNode supertype : supertypes) {\n      SNode erasure = SNodeOperations.copyNode(supertype);\n      if (SLinkOperations.getCount(erasure, \"parameter\") > 0) {\n        for(SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        result.add(erasure);\n      }\n    }\n    return result;\n  }","id":101352,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode clt) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = ListSequence.<SNode>fromArray();\n    List<SNode> supertypes = ListSequence.<SNode>fromArray();\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = classifier;\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        ListSequence.fromList(supertypes).addElement(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true)));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = classifier;\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true)));\n    }\n    if (ListSequence.fromList(supertypes).isEmpty()) {\n      ListSequence.fromList(result).addElement(new _Quotations.QuotationClass_4().createNode());\n    }\n    for(SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.copyNode(supertype);\n      for(SNode typeParam : new ArrayList<SNode>(SLinkOperations.getTargets(supertypeCopy, \"parameter\", true))) {\n        if (SNodeOperations.isInstanceOf(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\")) {\n          SNode tvr = typeParam;\n          int i = ListSequence.fromList(SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(tvr, \"typeVariableDeclaration\", false));\n          if (i < 0 || i >= SLinkOperations.getCount(clt, \"parameter\")) {\n            ((SNode)supertypeCopy).removeChild(typeParam);\n            continue;\n          }\n          SNode newNode = SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(clt, \"parameter\", true)).getElement(i));\n          supertypeCopy.replaceChild(typeParam, newNode);\n        }\n      }\n      ListSequence.fromList(result).addElement(supertypeCopy);\n    }\n    ListSequence.fromList(supertypes).addElement(clt);\n    for(SNode supertype : supertypes) {\n      SNode erasure = SNodeOperations.copyNode(supertype);\n      if (SLinkOperations.getCount(erasure, \"parameter\") > 0) {\n        for(SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        ListSequence.fromList(result).addElement(erasure);\n      }\n    }\n    return result;\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode thisExpr, final TypeCheckingContext typeCheckingContext) {\n    SNode classifier;\n    if ((SLinkOperations.getTarget(thisExpr, \"classConcept\", false) != null)) {\n      classifier = SLinkOperations.getTarget(thisExpr, \"classConcept\", false);\n    } else\n    {\n      SNode contextNode = thisExpr;\n      SNode parent = SNodeOperations.getParent(thisExpr);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        for(SNode param : SLinkOperations.getTargets(parent, \"parameter\", true)) {\n          if (ListSequence.fromList(SNodeOperations.getDescendants(param, null, true)).contains(thisExpr)) {\n            contextNode = parent;\n            break;\n          }\n        }\n      }\n      classifier = SNodeOperations.getAncestor(contextNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    }\n    List<SNode> typeVarRefs = new ArrayList<SNode>();\n    for(SNode typeVariableDeclaration : SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)) {\n      ListSequence.fromList(typeVarRefs).addElement(new _Quotations.QuotationClass_14().createNode(typeVariableDeclaration, typeCheckingContext));\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = thisExpr;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(thisExpr, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810739\", true), new _Quotations.QuotationClass_15().createNode(typeVarRefs, classifier, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810737\", intentionProvider);\n    }\n  }","id":101353,"modified_method":"public void applyRule(final SNode thisExpr, final TypeCheckingContext typeCheckingContext) {\n    SNode classifier;\n    if ((SLinkOperations.getTarget(thisExpr, \"classConcept\", false) != null)) {\n      classifier = SLinkOperations.getTarget(thisExpr, \"classConcept\", false);\n    } else\n    {\n      SNode contextNode = thisExpr;\n      SNode parent = SNodeOperations.getParent(thisExpr);\n      if (SNodeOperations.isInstanceOf(parent, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        for(SNode param : SLinkOperations.getTargets(parent, \"parameter\", true)) {\n          if (ListSequence.fromList(SNodeOperations.getDescendants(param, null, true)).contains(thisExpr)) {\n            contextNode = parent;\n            break;\n          }\n        }\n      }\n      classifier = SNodeOperations.getAncestor(contextNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    }\n    List<SNode> typeVarRefs = new ArrayList<SNode>();\n    for(SNode typeVariableDeclaration : SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)) {\n      ListSequence.fromList(typeVarRefs).addElement(new _Quotations.QuotationClass_14().createNode(typeVariableDeclaration, typeCheckingContext));\n    }\n    {\n      SNode _nodeToCheck_1029348928467 = thisExpr;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(thisExpr, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810739\", true), new _Quotations.QuotationClass_15().createNode(typeVarRefs, typeCheckingContext), _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1215004810737\", intentionProvider);\n    }\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode creator, final TypeCheckingContext typeCheckingContext) {\n    if (SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    if (!(SLinkOperations.getCount(creator, \"typeParameter\") == 0 || SLinkOperations.getCount(creator, \"typeParameter\") == SLinkOperations.getCount(SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"typeVariableDeclaration\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(creator, \"wrong number of type parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1216200944338\", intentionProvider, errorTarget);\n      }\n    }\n    for(SNode parameter : SLinkOperations.getTargets(creator, \"typeParameter\", true)) {\n      if (!(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(parameter, SLinkOperations.getTarget(new _Quotations.QuotationClass_87().createNode(typeCheckingContext), \"descriptor\", false), false)))) {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(parameter, \"primitive type not allowed\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606006\", intentionProvider, errorTarget);\n      }\n    }\n    // ---\n    SNode constructedType = new _Quotations.QuotationClass_88().createNode(SLinkOperations.getTargets(creator, \"typeParameter\", true), methodClassifier, typeCheckingContext);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(creator, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606043\", true), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606039\", intentionProvider);\n    }\n    final SNode instanceType_typevar_1212781606045 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606046\", intentionProvider);\n    }\n    // --- following piece of cake is identical for any method call ---\n    Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n    RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(typeCheckingContext, creator, null, mmap);\n    RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(typeCheckingContext, methodClassifier, typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), mmap);\n    RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(typeCheckingContext, mmap);\n  }","id":101354,"modified_method":"public void applyRule(final SNode creator, final TypeCheckingContext typeCheckingContext) {\n    if (SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false) == null) {\n      return;\n    }\n    final SNode methodClassifier = SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    if (!(SLinkOperations.getCount(creator, \"typeParameter\") == 0 || SLinkOperations.getCount(creator, \"typeParameter\") == SLinkOperations.getCount(SNodeOperations.getAncestor(SLinkOperations.getTarget(creator, \"baseMethodDeclaration\", false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"typeVariableDeclaration\"))) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(creator, \"wrong number of type parameters\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1216200944338\", intentionProvider, errorTarget);\n      }\n    }\n    for(SNode parameter : SLinkOperations.getTargets(creator, \"typeParameter\", true)) {\n      if (!(!(TypeChecker.getInstance().getSubtypingManager().isSubtype(parameter, SLinkOperations.getTarget(new _Quotations.QuotationClass_87().createNode(typeCheckingContext), \"descriptor\", false), false)))) {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        typeCheckingContext.reportTypeError(parameter, \"primitive type not allowed\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606006\", intentionProvider, errorTarget);\n      }\n    }\n    // ---\n    SNode constructedType = new _Quotations.QuotationClass_88().createNode(SLinkOperations.getTargets(creator, \"typeParameter\", true), typeCheckingContext);\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.typeOf(creator, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606043\", true), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606039\", intentionProvider);\n    }\n    final SNode instanceType_typevar_1212781606045 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = creator;\n      BaseIntentionProvider intentionProvider = null;\n      typeCheckingContext.createEquation(typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), constructedType, _nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"1212781606046\", intentionProvider);\n    }\n    // --- following piece of cake is identical for any method call ---\n    Map<SNode, List<SNode>> mmap = new HashMap<SNode, List<SNode>>();\n    RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(typeCheckingContext, creator, null, mmap);\n    RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(typeCheckingContext, methodClassifier, typeCheckingContext.getEquationManager().getRepresentator(instanceType_typevar_1212781606045), mmap);\n    RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(typeCheckingContext, mmap);\n  }","commit_id":"259c5dde0a81d25b928b83dcf83db811de5d9ac7","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void initBindAddress() throws IOException {\n\t\tString autodetectAddress = PropsValues.CLUSTER_LINK_AUTODETECT_ADDRESS;\n\n\t\tif (Validator.isNull(autodetectAddress)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString host = autodetectAddress;\n\t\tint port = 80;\n\n\t\tint index = autodetectAddress.indexOf(StringPool.COLON);\n\n\t\tif (index != -1) {\n\t\t\thost = autodetectAddress.substring(0, index);\n\t\t\tport = GetterUtil.getInteger(\n\t\t\t\tautodetectAddress.substring(index + 1), port);\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Autodetecting JGroups outgoing IP address and interface for \" +\n\t\t\t\t\thost + \":\" + port);\n\t\t}\n\n\t\tSocketUtil.BindInfo bindInfo = SocketUtil.getBindInfo(host, port);\n\n\t\tInetAddress inetAddress = bindInfo.getInetAddress();\n\t\tNetworkInterface networkInterface = bindInfo.getNetworkInterface();\n\n\t\tSystem.setProperty(\"jgroups.bind_addr\", inetAddress.getHostAddress());\n\t\tSystem.setProperty(\n\t\t\t\"jgroups.bind_interface\", networkInterface.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Setting JGroups outgoing IP address to \" +\n\t\t\t\t\tinetAddress.getHostAddress() + \" and interface to \" +\n\t\t\t\t\t\tnetworkInterface.getName());\n\t\t}\n\t}","id":101355,"modified_method":"protected void initBindAddress() throws IOException {\n\t\tString autodetectAddress = PropsValues.CLUSTER_LINK_AUTODETECT_ADDRESS;\n\n\t\tif (Validator.isNull(autodetectAddress)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString host = autodetectAddress;\n\t\tint port = 80;\n\n\t\tint index = autodetectAddress.indexOf(StringPool.COLON);\n\n\t\tif (index != -1) {\n\t\t\thost = autodetectAddress.substring(0, index);\n\t\t\tport = GetterUtil.getInteger(\n\t\t\t\tautodetectAddress.substring(index + 1), port);\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Autodetecting JGroups outgoing IP address and interface for \" +\n\t\t\t\t\thost + \":\" + port);\n\t\t}\n\n\t\tSocketUtil.BindInfo bindInfo = SocketUtil.getBindInfo(host, port);\n\n\t\tbindInetAddress = bindInfo.getInetAddress();\n\t\tNetworkInterface networkInterface = bindInfo.getNetworkInterface();\n\n\t\tSystem.setProperty(\"jgroups.bind_addr\",\n\t\t\tbindInetAddress.getHostAddress());\n\t\tSystem.setProperty(\n\t\t\t\"jgroups.bind_interface\", networkInterface.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Setting JGroups outgoing IP address to \" +\n\t\t\t\t\tbindInetAddress.getHostAddress() + \" and interface to \" +\n\t\t\t\t\t\tnetworkInterface.getName());\n\t\t}\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void removeClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\n\t\t_clusterEventListeners.remove(clusterEventListener);\n\t}","id":101356,"modified_method":"public void removeClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\t\tif (!isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_clusterEventListeners.remove(clusterEventListener);\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setClusterEventListener(\n\t\tList<ClusterEventListener> clusterEventListeners) {\n\n\t\tfor (ClusterEventListener clusterEventListener :\n\t\t\t\tclusterEventListeners) {\n\n\t\t\taddClusterEventListener(clusterEventListener);\n\t\t}\n\t}","id":101357,"modified_method":"public void setClusterEventListener(\n\t\tList<ClusterEventListener> clusterEventListeners) {\n\n\t\tif (!isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_clusterEventListeners.addAllAbsent(clusterEventListeners);\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ClusterNode getLocalClusterNode() throws SystemException {\n\t\tif (!isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tClusterNode clusterNode = getClusterNode(getLocalControlAddress());\n\n\t\tif (clusterNode == null) {\n\t\t\t_localClusterNodeId = PortalUUIDUtil.generate();\n\n\t\t\tclusterNode = new ClusterNode(_localClusterNodeId);\n\n\t\t\tString autodetectAddress =\n\t\t\t\tPropsValues.CLUSTER_LINK_AUTODETECT_ADDRESS;\n\n\t\t\tclusterNode.setPort(PortalUtil.getPortalPort());\n\n\t\t\ttry {\n\t\t\t\tInetAddress inetAddress = getHostInetAddress(autodetectAddress);\n\n\t\t\t\tclusterNode.setInetAddress(inetAddress);\n\n\t\t\t\tclusterNode.setHostName(inetAddress.getHostName());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"Unable to determine local network address\", e);\n\t\t\t}\n\t\t}\n\n\t\treturn clusterNode;\n\t}","id":101358,"modified_method":"public ClusterNode getLocalClusterNode() throws SystemException {\n\t\tif (!isEnabled()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tClusterNode clusterNode = _addressMap.get(getLocalControlAddress());\n\n\t\tif (clusterNode == null) {\n\t\t\t_localClusterNodeId = PortalUUIDUtil.generate();\n\n\t\t\tclusterNode = new ClusterNode(_localClusterNodeId);\n\n\t\t\tclusterNode.setPort(PortalUtil.getPortalPort());\n\n\t\t\ttry {\n\t\t\t\tInetAddress inetAddress = bindInetAddress;\n\n\t\t\t\tif (inetAddress == null) {\n\t\t\t\t\tinetAddress = InetAddressUtil.getLocalInetAddress();\n\t\t\t\t}\n\n\t\t\t\tclusterNode.setInetAddress(inetAddress);\n\n\t\t\t\tclusterNode.setHostName(inetAddress.getHostName());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"Unable to determine local network address\", e);\n\t\t\t}\n\t\t}\n\n\t\treturn clusterNode;\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<ClusterNode> getClusterNodes() {\n\t\tif (!isEnabled()) {\n\t\t\treturn Collections.EMPTY_LIST;\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tCollection<ClusterNode> clusterNodes = _addressMap.values();\n\n\t\t\treturn new ArrayList<ClusterNode>(clusterNodes);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\t}","id":101359,"modified_method":"public List<ClusterNode> getClusterNodes() {\n\t\tif (!isEnabled()) {\n\t\t\treturn Collections.EMPTY_LIST;\n\t\t}\n\t\treturn new ArrayList<ClusterNode>(_addressMap.values());\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isClusterNodeAlive(String clusterNodeId) {\n\t\tif (!isEnabled()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (getAddress(clusterNodeId) != null);\n\t}","id":101360,"modified_method":"public boolean isClusterNodeAlive(String clusterNodeId) {\n\t\tif (!isEnabled()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn _clusterNodeIdMap.containsKey(clusterNodeId);\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<ClusterEventListener> getClusterEventListeners() {\n\t\treturn Collections.unmodifiableList(_clusterEventListeners);\n\t}","id":101361,"modified_method":"public List<ClusterEventListener> getClusterEventListeners() {\n\t\tif (!isEnabled()) {\n\t\t\treturn Collections.EMPTY_LIST;\n\t\t}\n\t\treturn Collections.unmodifiableList(_clusterEventListeners);\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setShortcutLocalMethod(boolean shortcutLocalMethod) {\n\t\t_shortcutLocalMethod = shortcutLocalMethod;\n\t}","id":101362,"modified_method":"public void setShortcutLocalMethod(boolean shortcutLocalMethod) {\n\t\tif (!isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_shortcutLocalMethod = shortcutLocalMethod;\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\n\t\tif (!isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!_clusterEventListeners.contains(clusterEventListener)) {\n\t\t\t_clusterEventListeners.add(clusterEventListener);\n\t\t}\n\n\t\treturn;\n\t}","id":101363,"modified_method":"public void addClusterEventListener(\n\t\tClusterEventListener clusterEventListener) {\n\t\tif (!isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_clusterEventListeners.addIfAbsent(clusterEventListener);\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void memberRemoved(List<Address> departAddresses) {\n\t\tList<ClusterNode> departingClusterNodes = new ArrayList<ClusterNode>();\n\n\t\tfor (Address departAddress : departAddresses) {\n\t\t\tClusterNode clusterNode = getClusterNode(departAddress);\n\n\t\t\tif (clusterNode == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdepartingClusterNodes.add(clusterNode);\n\n\t\t\t_writeLock.lock();\n\n\t\t\ttry {\n\t\t\t\tif (_clusterNodeIdMap.containsValue(departAddress)) {\n\t\t\t\t\tString clusterNodeId = clusterNode.getClusterNodeId();\n\n\t\t\t\t\t_clusterNodeIdMap.remove(clusterNodeId);\n\n\t\t\t\t\t_addressMap.remove(departAddress);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\"Unable to remove address \" + departAddress +\n\t\t\t\t\t\t\t\" from cluster node \" + clusterNode);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t_writeLock.unlock();\n\t\t\t}\n\t\t}\n\n\t\tif (departingClusterNodes.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClusterEvent clusterEvent = ClusterEvent.depart(departingClusterNodes);\n\n\t\tfireClusterEvent(clusterEvent);\n\t}","id":101364,"modified_method":"protected void memberRemoved(List<Address> departAddresses) {\n\t\tList<ClusterNode> departingClusterNodes = new ArrayList<ClusterNode>();\n\n\t\tfor (Address departAddress : departAddresses) {\n\t\t\tClusterNode departingClusterNode = _addressMap.remove(\n\t\t\t\tdepartAddress);\n\t\t\tif (departingClusterNode != null) {\n\t\t\t\tdepartingClusterNodes.add(departingClusterNode);\n\n\t\t\t\t_clusterNodeIdMap.remove(\n\t\t\t\t\tdepartingClusterNode.getClusterNodeId());\n\t\t\t}\n\t\t}\n\n\t\tif (departingClusterNodes.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClusterEvent clusterEvent = ClusterEvent.depart(departingClusterNodes);\n\n\t\tfireClusterEvent(clusterEvent);\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void memberJoined(Address joinAddress, ClusterNode clusterNode) {\n\t\t_writeLock.lock();\n\n\t\ttry {\n\t\t\tboolean hasClusterNode = _clusterNodeIdMap.containsValue(\n\t\t\t\tjoinAddress);\n\n\t\t\tboolean hasAddress = _addressMap.containsKey(joinAddress);\n\n\t\t\tif (hasClusterNode && hasAddress) {\n\t\t\t\t_addressMap.remove(joinAddress);\n\n\t\t\t\t_addressMap.put(joinAddress, clusterNode);\n\t\t\t}\n\t\t\telse if (!hasClusterNode && !hasAddress) {\n\t\t\t\t_addressMap.put(joinAddress, clusterNode);\n\n\t\t\t\tString clusterNodeId = clusterNode.getClusterNodeId();\n\n\t\t\t\t_clusterNodeIdMap.put(clusterNodeId, joinAddress);\n\n\t\t\t\tif (getLocalControlAddress().equals(joinAddress)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tClusterEvent clusterEvent = ClusterEvent.join(clusterNode);\n\n\t\t\t\tfireClusterEvent(clusterEvent);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Unable to join address \" + joinAddress +\n\t\t\t\t\t\t\" to cluster node \" + clusterNode);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_writeLock.unlock();\n\t\t}\n\t}","id":101365,"modified_method":"protected void memberJoined(Address joinAddress, ClusterNode clusterNode) {\n\t\t_addressMap.put(joinAddress, clusterNode);\n\t\tAddress previousAddress = _clusterNodeIdMap.put(\n\t\t\tclusterNode.getClusterNodeId(), joinAddress);\n\t\tif ((previousAddress == null) &&\n\t\t\t!getLocalControlAddress().equals(joinAddress)) {\n\t\t\tClusterEvent clusterEvent = ClusterEvent.join(clusterNode);\n\t\t\tfireClusterEvent(clusterEvent);\n\t\t}\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<Address> prepareAddresses(ClusterRequest clusterRequest) {\n\t\tboolean isMulticast = clusterRequest.isMulticast();\n\n\t\tList<Address> addresses = null;\n\n\t\tif (isMulticast) {\n\t\t\taddresses = getControlAddresses();\n\t\t}\n\t\telse {\n\t\t\tCollection<String> clusterNodeIds =\n\t\t\t\tclusterRequest.getTargetClusterNodeIds();\n\n\t\t\taddresses = new ArrayList<Address>(clusterNodeIds.size());\n\n\t\t\tfor (String clusterNodeId : clusterNodeIds) {\n\t\t\t\tAddress address = getAddress(clusterNodeId);\n\n\t\t\t\taddresses.add(address);\n\t\t\t}\n\t\t}\n\n\t\tAddress localControlAddress = getLocalControlAddress();\n\n\t\tif (clusterRequest.isSkipLocal() || _shortcutLocalMethod) {\n\t\t\taddresses.remove(localControlAddress);\n\t\t}\n\n\t\treturn addresses;\n\t}","id":101366,"modified_method":"protected List<Address> prepareAddresses(ClusterRequest clusterRequest) {\n\t\tboolean isMulticast = clusterRequest.isMulticast();\n\n\t\tList<Address> addresses = null;\n\n\t\tif (isMulticast) {\n\t\t\taddresses = getAddresses(_controlChannel);\n\t\t}\n\t\telse {\n\t\t\tCollection<String> clusterNodeIds =\n\t\t\t\tclusterRequest.getTargetClusterNodeIds();\n\n\t\t\taddresses = new ArrayList<Address>(clusterNodeIds.size());\n\n\t\t\tfor (String clusterNodeId : clusterNodeIds) {\n\t\t\t\tAddress address = _clusterNodeIdMap.get(clusterNodeId);\n\n\t\t\t\taddresses.add(address);\n\t\t\t}\n\t\t}\n\n\t\tAddress localControlAddress = getLocalControlAddress();\n\n\t\tif (clusterRequest.isSkipLocal() || _shortcutLocalMethod) {\n\t\t\taddresses.remove(localControlAddress);\n\t\t}\n\n\t\treturn addresses;\n\t}","commit_id":"375121ce4e3eede21cc84d5e92fda0bd263edf9b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static <T> T[] extract( Class<T[]> type, T obj1, T obj2,\n            Object[] more, boolean odd )\n    {\n        if ( more.length % 2 != 0 )\n        {\n            throw new IllegalArgumentException();\n        }\n        Object[] target = Arrays.copyOf( EMPTY_ARRAY, ( more.length / 2 ) + 2,\n                type );\n        try\n        {\n            target[0] = obj1;\n            target[1] = obj2;\n            for ( int i = 2; i < target.length; i++ )\n            {\n                target[i] = more[( i - 2 ) * 2 + ( odd ? 1 : 0 )];\n            }\n        }\n        catch ( ArrayStoreException cast )\n        {\n            throw new IllegalArgumentException( cast );\n        }\n        return type.cast( target );\n    }","id":101367,"modified_method":"private static <T> T[] extract( Class<T[]> type, T obj1, T obj2,\n            Object[] more, boolean odd )\n    {\n        if ( more.length % 2 != 0 )\n        {\n            throw new IllegalArgumentException();\n        }\n        Object[] target = (Object[]) Array.newInstance( type,\n                ( more.length / 2 ) + 2 );\n        try\n        {\n            target[0] = obj1;\n            target[1] = obj2;\n            for ( int i = 2; i < target.length; i++ )\n            {\n                target[i] = more[( i - 2 ) * 2 + ( odd ? 1 : 0 )];\n            }\n        }\n        catch ( ArrayStoreException cast )\n        {\n            throw new IllegalArgumentException( cast );\n        }\n        return type.cast( target );\n    }","commit_id":"f6167fada5967e5c985b5518672d045cdd456978","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testBreadthFirst() throws Exception\n    {\n        Traverser traverser = new TraversalDescriptionImpl().breadthFirst().traverse(\n                referenceNode() );\n        Deque<Set<String>> levels = new LinkedList<Set<String>>();\n        levels.push( new HashSet<String>( Arrays.asList( \"5\", \"6\", \"7\", \"8\",\n                \"9\", \"A\", \"B\", \"C\", \"D\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"2\", \"3\", \"4\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"1\" ) ) );\n        Set<String> current = levels.pop();\n        for ( Position position : traverser )\n        {\n            String nodeName = (String) position.node().getProperty( \"name\" );\n            if ( current.isEmpty() )\n            {\n                current = levels.pop();\n            }\n            assertTrue( \"Should not contain node (\" + nodeName\n                        + \") at level \" + ( 3 - levels.size() ),\n                    current.remove( nodeName ) );\n        }\n\n        assertTrue( \"Should have no more levels\", levels.isEmpty() );\n        assertTrue( \"Should be empty\", current.isEmpty() );\n    }","id":101368,"modified_method":"@Test\n    public void testBreadthFirst() throws Exception\n    {\n        Traverser traverser = new TraversalDescriptionImpl().breadthFirst().traverse(\n                referenceNode() );\n        Stack<Set<String>> levels = new Stack<Set<String>>();\n        levels.push( new HashSet<String>( Arrays.asList( \"5\", \"6\", \"7\", \"8\",\n                \"9\", \"A\", \"B\", \"C\", \"D\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"2\", \"3\", \"4\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"1\" ) ) );\n        Set<String> current = levels.pop();\n        for ( Position position : traverser )\n        {\n            String nodeName = (String) position.node().getProperty( \"name\" );\n            if ( current.isEmpty() )\n            {\n                current = levels.pop();\n            }\n            assertTrue( \"Should not contain node (\" + nodeName\n                        + \") at level \" + ( 3 - levels.size() ),\n                    current.remove( nodeName ) );\n        }\n\n        assertTrue( \"Should have no more levels\", levels.isEmpty() );\n        assertTrue( \"Should be empty\", current.isEmpty() );\n    }","commit_id":"f6167fada5967e5c985b5518672d045cdd456978","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static <T> T[] extract( Class<T[]> type, T obj1, T obj2,\n            Object[] more, boolean odd )\n    {\n        if ( more.length % 2 != 0 )\n        {\n            throw new IllegalArgumentException();\n        }\n        Object[] target = Arrays.copyOf( EMPTY_ARRAY, ( more.length / 2 ) + 2,\n                type );\n        try\n        {\n            target[0] = obj1;\n            target[1] = obj2;\n            for ( int i = 2; i < target.length; i++ )\n            {\n                target[i] = more[( i - 2 ) * 2 + ( odd ? 1 : 0 )];\n            }\n        }\n        catch ( ArrayStoreException cast )\n        {\n            throw new IllegalArgumentException( cast );\n        }\n        return type.cast( target );\n    }","id":101369,"modified_method":"private static <T> T[] extract( Class<T[]> type, T obj1, T obj2,\n            Object[] more, boolean odd )\n    {\n        if ( more.length % 2 != 0 )\n        {\n            throw new IllegalArgumentException();\n        }\n        Object[] target = (Object[]) Array.newInstance( type,\n                ( more.length / 2 ) + 2 );\n        try\n        {\n            target[0] = obj1;\n            target[1] = obj2;\n            for ( int i = 2; i < target.length; i++ )\n            {\n                target[i] = more[( i - 2 ) * 2 + ( odd ? 1 : 0 )];\n            }\n        }\n        catch ( ArrayStoreException cast )\n        {\n            throw new IllegalArgumentException( cast );\n        }\n        return type.cast( target );\n    }","commit_id":"7569647fe120f74fa40a8ec5dc38f0ae4fdd4801","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testBreadthFirst() throws Exception\n    {\n        Traverser traverser = new TraversalDescriptionImpl().breadthFirst().traverse(\n                referenceNode() );\n        Deque<Set<String>> levels = new LinkedList<Set<String>>();\n        levels.push( new HashSet<String>( Arrays.asList( \"5\", \"6\", \"7\", \"8\",\n                \"9\", \"A\", \"B\", \"C\", \"D\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"2\", \"3\", \"4\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"1\" ) ) );\n        Set<String> current = levels.pop();\n        for ( Position position : traverser )\n        {\n            String nodeName = (String) position.node().getProperty( \"name\" );\n            if ( current.isEmpty() )\n            {\n                current = levels.pop();\n            }\n            assertTrue( \"Should not contain node (\" + nodeName\n                        + \") at level \" + ( 3 - levels.size() ),\n                    current.remove( nodeName ) );\n        }\n\n        assertTrue( \"Should have no more levels\", levels.isEmpty() );\n        assertTrue( \"Should be empty\", current.isEmpty() );\n    }","id":101370,"modified_method":"@Test\n    public void testBreadthFirst() throws Exception\n    {\n        Traverser traverser = new TraversalDescriptionImpl().breadthFirst().traverse(\n                referenceNode() );\n        Stack<Set<String>> levels = new Stack<Set<String>>();\n        levels.push( new HashSet<String>( Arrays.asList( \"5\", \"6\", \"7\", \"8\",\n                \"9\", \"A\", \"B\", \"C\", \"D\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"2\", \"3\", \"4\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"1\" ) ) );\n        Set<String> current = levels.pop();\n        for ( Position position : traverser )\n        {\n            String nodeName = (String) position.node().getProperty( \"name\" );\n            if ( current.isEmpty() )\n            {\n                current = levels.pop();\n            }\n            assertTrue( \"Should not contain node (\" + nodeName\n                        + \") at level \" + ( 3 - levels.size() ),\n                    current.remove( nodeName ) );\n        }\n\n        assertTrue( \"Should have no more levels\", levels.isEmpty() );\n        assertTrue( \"Should be empty\", current.isEmpty() );\n    }","commit_id":"7569647fe120f74fa40a8ec5dc38f0ae4fdd4801","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static <T> T[] extract( Class<T[]> type, T obj1, T obj2,\n            Object[] more, boolean odd )\n    {\n        if ( more.length % 2 != 0 )\n        {\n            throw new IllegalArgumentException();\n        }\n        Object[] target = Arrays.copyOf( EMPTY_ARRAY, ( more.length / 2 ) + 2,\n                type );\n        try\n        {\n            target[0] = obj1;\n            target[1] = obj2;\n            for ( int i = 2; i < target.length; i++ )\n            {\n                target[i] = more[( i - 2 ) * 2 + ( odd ? 1 : 0 )];\n            }\n        }\n        catch ( ArrayStoreException cast )\n        {\n            throw new IllegalArgumentException( cast );\n        }\n        return type.cast( target );\n    }","id":101371,"modified_method":"private static <T> T[] extract( Class<T[]> type, T obj1, T obj2,\n            Object[] more, boolean odd )\n    {\n        if ( more.length % 2 != 0 )\n        {\n            throw new IllegalArgumentException();\n        }\n        Object[] target = (Object[]) Array.newInstance( type,\n                ( more.length / 2 ) + 2 );\n        try\n        {\n            target[0] = obj1;\n            target[1] = obj2;\n            for ( int i = 2; i < target.length; i++ )\n            {\n                target[i] = more[( i - 2 ) * 2 + ( odd ? 1 : 0 )];\n            }\n        }\n        catch ( ArrayStoreException cast )\n        {\n            throw new IllegalArgumentException( cast );\n        }\n        return type.cast( target );\n    }","commit_id":"63cd48863f81110148d27938021e93df43143e05","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testBreadthFirst() throws Exception\n    {\n        Traverser traverser = new TraversalDescriptionImpl().breadthFirst().traverse(\n                referenceNode() );\n        Deque<Set<String>> levels = new LinkedList<Set<String>>();\n        levels.push( new HashSet<String>( Arrays.asList( \"5\", \"6\", \"7\", \"8\",\n                \"9\", \"A\", \"B\", \"C\", \"D\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"2\", \"3\", \"4\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"1\" ) ) );\n        Set<String> current = levels.pop();\n        for ( Position position : traverser )\n        {\n            String nodeName = (String) position.node().getProperty( \"name\" );\n            if ( current.isEmpty() )\n            {\n                current = levels.pop();\n            }\n            assertTrue( \"Should not contain node (\" + nodeName\n                        + \") at level \" + ( 3 - levels.size() ),\n                    current.remove( nodeName ) );\n        }\n\n        assertTrue( \"Should have no more levels\", levels.isEmpty() );\n        assertTrue( \"Should be empty\", current.isEmpty() );\n    }","id":101372,"modified_method":"@Test\n    public void testBreadthFirst() throws Exception\n    {\n        Traverser traverser = new TraversalDescriptionImpl().breadthFirst().traverse(\n                referenceNode() );\n        Stack<Set<String>> levels = new Stack<Set<String>>();\n        levels.push( new HashSet<String>( Arrays.asList( \"5\", \"6\", \"7\", \"8\",\n                \"9\", \"A\", \"B\", \"C\", \"D\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"2\", \"3\", \"4\" ) ) );\n        levels.push( new HashSet<String>( Arrays.asList( \"1\" ) ) );\n        Set<String> current = levels.pop();\n        for ( Position position : traverser )\n        {\n            String nodeName = (String) position.node().getProperty( \"name\" );\n            if ( current.isEmpty() )\n            {\n                current = levels.pop();\n            }\n            assertTrue( \"Should not contain node (\" + nodeName\n                        + \") at level \" + ( 3 - levels.size() ),\n                    current.remove( nodeName ) );\n        }\n\n        assertTrue( \"Should have no more levels\", levels.isEmpty() );\n        assertTrue( \"Should be empty\", current.isEmpty() );\n    }","commit_id":"63cd48863f81110148d27938021e93df43143e05","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected String upload(HttpServletRequest request, StringManager smClient) {\n        String message = \"\";\n\n        try {\n            while (true) {\n                Part warPart = request.getPart(\"deployWar\");\n                if (warPart == null) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadNoFile\");\n                    break;\n                }\n                String filename = warPart.getSubmittedFileName();\n                if (!filename.toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadNotWar\", filename);\n                    break;\n                }\n                // Get the filename if uploaded name includes a path\n                if (filename.lastIndexOf('\\\\') >= 0) {\n                    filename =\n                        filename.substring(filename.lastIndexOf('\\\\') + 1);\n                }\n                if (filename.lastIndexOf('/') >= 0) {\n                    filename =\n                        filename.substring(filename.lastIndexOf('/') + 1);\n                }\n\n                // Identify the appBase of the owning Host of this Context\n                // (if any)\n                File file = new File(host.getAppBaseFile(), filename);\n                if (file.exists()) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadWarExists\",\n                            filename);\n                    break;\n                }\n\n                ContextName cn = new ContextName(filename, true);\n                String name = cn.getName();\n\n                if ((host.findChild(name) != null) && !isDeployed(name)) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadInServerXml\",\n                            filename);\n                    break;\n                }\n\n                if (!isServiced(name)) {\n                    addServiced(name);\n                    try {\n                        warPart.write(file.getAbsolutePath());\n                        // Perform new deployment\n                        check(name);\n                    } finally {\n                        removeServiced(name);\n                    }\n                }\n                break;\n            }\n        } catch(Exception e) {\n            message = smClient.getString\n                (\"htmlManagerServlet.deployUploadFail\", e.getMessage());\n            log(message, e);\n        }\n        return message;\n    }","id":101373,"modified_method":"protected String upload(HttpServletRequest request, StringManager smClient) {\n        String message = \"\";\n\n        try {\n            while (true) {\n                Part warPart = request.getPart(\"deployWar\");\n                if (warPart == null) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadNoFile\");\n                    break;\n                }\n                String filename = warPart.getSubmittedFileName();\n                if (!filename.toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadNotWar\", filename);\n                    break;\n                }\n                // Get the filename if uploaded name includes a path\n                if (filename.lastIndexOf('\\\\') >= 0) {\n                    filename =\n                        filename.substring(filename.lastIndexOf('\\\\') + 1);\n                }\n                if (filename.lastIndexOf('/') >= 0) {\n                    filename =\n                        filename.substring(filename.lastIndexOf('/') + 1);\n                }\n\n                // Identify the appBase of the owning Host of this Context\n                // (if any)\n                File file = new File(host.getAppBaseFile(), filename);\n                if (file.exists()) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadWarExists\",\n                            filename);\n                    break;\n                }\n\n                ContextName cn = new ContextName(filename, true);\n                String name = cn.getName();\n\n                if ((host.findChild(name) != null) && !isDeployed(name)) {\n                    message = smClient.getString(\n                            \"htmlManagerServlet.deployUploadInServerXml\",\n                            filename);\n                    break;\n                }\n\n                if (isServiced(name)) {\n                    message = smClient.getString(\"managerServlet.inService\", name);\n                } else {\n                    addServiced(name);\n                    try {\n                        warPart.write(file.getAbsolutePath());\n                        // Perform new deployment\n                        check(name);\n                    } finally {\n                        removeServiced(name);\n                    }\n                }\n                break;\n            }\n        } catch(Exception e) {\n            message = smClient.getString\n                (\"htmlManagerServlet.deployUploadFail\", e.getMessage());\n            log(message, e);\n        }\n        return message;\n    }","commit_id":"b7508405d9f7205973adb1881d96c88fe2e5c3b4","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Undeploy the web application at the specified context path.\n     *\n     * @param writer Writer to render to\n     * @param cn Name of the application to be removed\n     */\n    protected void undeploy(PrintWriter writer, ContextName cn,\n            StringManager smClient) {\n\n        if (debug >= 1)\n            log(\"undeploy: Undeploying web application at '\" + cn + \"'\");\n\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n\n        String name = cn.getName();\n        String baseName = cn.getBaseName();\n        String displayPath = cn.getDisplayName();\n\n        try {\n\n            // Validate the Context of the specified application\n            Context context = (Context) host.findChild(name);\n            if (context == null) {\n                writer.println(smClient.getString(\"managerServlet.noContext\",\n                        RequestUtil.filter(displayPath)));\n                return;\n            }\n\n            if (!isDeployed(name)) {\n                writer.println(smClient.getString(\"managerServlet.notDeployed\",\n                        RequestUtil.filter(displayPath)));\n                return;\n            }\n\n            if (!isServiced(name)) {\n                addServiced(name);\n                try {\n                    // Try to stop the context first to be nicer\n                    context.stop();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                }\n                try {\n                    File war = new File(host.getAppBaseFile(), baseName + \".war\");\n                    File dir = new File(host.getAppBaseFile(), baseName);\n                    File xml = new File(configBase, baseName + \".xml\");\n                    if (war.exists() && !war.delete()) {\n                        writer.println(smClient.getString(\n                                \"managerServlet.deleteFail\", war));\n                        return;\n                    } else if (dir.exists() && !undeployDir(dir)) {\n                        writer.println(smClient.getString(\n                                \"managerServlet.deleteFail\", dir));\n                        return;\n                    } else if (xml.exists() && !xml.delete()) {\n                        writer.println(smClient.getString(\n                                \"managerServlet.deleteFail\", xml));\n                        return;\n                    }\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n            writer.println(smClient.getString(\"managerServlet.undeployed\",\n                    displayPath));\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log(\"ManagerServlet.undeploy[\" + displayPath + \"]\", t);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    t.toString()));\n        }\n\n    }","id":101374,"modified_method":"/**\n     * Undeploy the web application at the specified context path.\n     *\n     * @param writer Writer to render to\n     * @param cn Name of the application to be removed\n     */\n    protected void undeploy(PrintWriter writer, ContextName cn,\n            StringManager smClient) {\n\n        if (debug >= 1)\n            log(\"undeploy: Undeploying web application at '\" + cn + \"'\");\n\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n\n        String name = cn.getName();\n        String baseName = cn.getBaseName();\n        String displayPath = cn.getDisplayName();\n\n        try {\n\n            // Validate the Context of the specified application\n            Context context = (Context) host.findChild(name);\n            if (context == null) {\n                writer.println(smClient.getString(\"managerServlet.noContext\",\n                        RequestUtil.filter(displayPath)));\n                return;\n            }\n\n            if (!isDeployed(name)) {\n                writer.println(smClient.getString(\"managerServlet.notDeployed\",\n                        RequestUtil.filter(displayPath)));\n                return;\n            }\n\n            if (isServiced(name)) {\n                writer.println(smClient.getString(\"managerServlet.inService\", displayPath));\n            } else {\n                addServiced(name);\n                try {\n                    // Try to stop the context first to be nicer\n                    context.stop();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                }\n                try {\n                    File war = new File(host.getAppBaseFile(), baseName + \".war\");\n                    File dir = new File(host.getAppBaseFile(), baseName);\n                    File xml = new File(configBase, baseName + \".xml\");\n                    if (war.exists() && !war.delete()) {\n                        writer.println(smClient.getString(\n                                \"managerServlet.deleteFail\", war));\n                        return;\n                    } else if (dir.exists() && !undeployDir(dir)) {\n                        writer.println(smClient.getString(\n                                \"managerServlet.deleteFail\", dir));\n                        return;\n                    } else if (xml.exists() && !xml.delete()) {\n                        writer.println(smClient.getString(\n                                \"managerServlet.deleteFail\", xml));\n                        return;\n                    }\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n            writer.println(smClient.getString(\"managerServlet.undeployed\",\n                    displayPath));\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log(\"ManagerServlet.undeploy[\" + displayPath + \"]\", t);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    t.toString()));\n        }\n\n    }","commit_id":"b7508405d9f7205973adb1881d96c88fe2e5c3b4","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Deploy a web application archive (included in the current request)\n     * at the specified context path.\n     *\n     * @param writer   Writer to render results to\n     * @param cn       Name of the application to be installed\n     * @param tag      Tag to be associated with the webapp\n     * @param update   Flag that indicates that any existing app should be\n     *                   replaced\n     * @param request  Servlet request we are processing\n     * @param smClient i18n messages using the locale of the client\n     */\n    protected synchronized void deploy\n        (PrintWriter writer, ContextName cn,\n         String tag, boolean update, HttpServletRequest request,\n         StringManager smClient) {\n\n        if (debug >= 1) {\n            log(\"deploy: Deploying web application '\" + cn + \"'\");\n        }\n\n        // Validate the requested context path\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n        String name = cn.getName();\n        String baseName = cn.getBaseName();\n        String displayPath = cn.getDisplayName();\n\n        // If app exists deployment can only proceed if update is true\n        // Note existing WAR will be deleted and then replaced\n        Context context = (Context) host.findChild(name);\n        if (context != null && !update) {\n            writer.println(smClient.getString(\"managerServlet.alreadyContext\",\n                    displayPath));\n            return;\n        }\n\n        File deployedWar = new File(host.getAppBaseFile(), baseName + \".war\");\n\n        // Determine full path for uploaded WAR\n        File uploadedWar;\n        if (tag == null) {\n            if (update) {\n                // Append \".tmp\" to the file name so it won't get deployed if auto\n                // deployment is enabled. It also means the old war won't get\n                // deleted if the upload fails\n                uploadedWar = new File(deployedWar.getAbsolutePath() + \".tmp\");\n                if (uploadedWar.exists() && !uploadedWar.delete()) {\n                    writer.println(smClient.getString(\"managerServlet.deleteFail\",\n                            uploadedWar));\n                }\n            } else {\n                uploadedWar = deployedWar;\n            }\n        } else {\n            File uploadPath = new File(versioned, tag);\n            if (!uploadPath.mkdirs() && !uploadPath.isDirectory()) {\n                writer.println(smClient.getString(\"managerServlet.mkdirFail\",\n                        uploadPath));\n                return;\n            }\n            uploadedWar = new File(uploadPath, baseName + \".war\");\n        }\n        if (debug >= 2) {\n            log(\"Uploading WAR file to \" + uploadedWar);\n        }\n\n        try {\n            if (!isServiced(name)) {\n                addServiced(name);\n                try {\n                    // Upload WAR\n                    uploadWar(writer, request, uploadedWar, smClient);\n                    if (update && tag == null) {\n                        if (deployedWar.exists() && !deployedWar.delete()) {\n                            writer.println(smClient.getString(\"managerServlet.deleteFail\",\n                                    deployedWar));\n                            return;\n                        }\n                        // Rename uploaded WAR file\n                        uploadedWar.renameTo(deployedWar);\n                    }\n                    if (tag != null) {\n                        // Copy WAR to the host's appBase\n                        copy(uploadedWar, deployedWar);\n                    }\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n        } catch (Exception e) {\n            log(\"managerServlet.check[\" + displayPath + \"]\", e);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    e.toString()));\n            return;\n        }\n\n        context = (Context) host.findChild(name);\n        if (context != null && context.getConfigured()) {\n            writer.println(smClient.getString(\n                    \"managerServlet.deployed\", displayPath));\n        } else {\n            // Something failed\n            writer.println(smClient.getString(\n                    \"managerServlet.deployFailed\", displayPath));\n        }\n    }","id":101375,"modified_method":"/**\n     * Deploy a web application archive (included in the current request)\n     * at the specified context path.\n     *\n     * @param writer   Writer to render results to\n     * @param cn       Name of the application to be installed\n     * @param tag      Tag to be associated with the webapp\n     * @param update   Flag that indicates that any existing app should be\n     *                   replaced\n     * @param request  Servlet request we are processing\n     * @param smClient i18n messages using the locale of the client\n     */\n    protected synchronized void deploy\n        (PrintWriter writer, ContextName cn,\n         String tag, boolean update, HttpServletRequest request,\n         StringManager smClient) {\n\n        if (debug >= 1) {\n            log(\"deploy: Deploying web application '\" + cn + \"'\");\n        }\n\n        // Validate the requested context path\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n        String name = cn.getName();\n        String baseName = cn.getBaseName();\n        String displayPath = cn.getDisplayName();\n\n        // If app exists deployment can only proceed if update is true\n        // Note existing WAR will be deleted and then replaced\n        Context context = (Context) host.findChild(name);\n        if (context != null && !update) {\n            writer.println(smClient.getString(\"managerServlet.alreadyContext\",\n                    displayPath));\n            return;\n        }\n\n        File deployedWar = new File(host.getAppBaseFile(), baseName + \".war\");\n\n        // Determine full path for uploaded WAR\n        File uploadedWar;\n        if (tag == null) {\n            if (update) {\n                // Append \".tmp\" to the file name so it won't get deployed if auto\n                // deployment is enabled. It also means the old war won't get\n                // deleted if the upload fails\n                uploadedWar = new File(deployedWar.getAbsolutePath() + \".tmp\");\n                if (uploadedWar.exists() && !uploadedWar.delete()) {\n                    writer.println(smClient.getString(\"managerServlet.deleteFail\",\n                            uploadedWar));\n                }\n            } else {\n                uploadedWar = deployedWar;\n            }\n        } else {\n            File uploadPath = new File(versioned, tag);\n            if (!uploadPath.mkdirs() && !uploadPath.isDirectory()) {\n                writer.println(smClient.getString(\"managerServlet.mkdirFail\",\n                        uploadPath));\n                return;\n            }\n            uploadedWar = new File(uploadPath, baseName + \".war\");\n        }\n        if (debug >= 2) {\n            log(\"Uploading WAR file to \" + uploadedWar);\n        }\n\n        try {\n            if (isServiced(name)) {\n                writer.println(smClient.getString(\"managerServlet.inService\", displayPath));\n            } else {\n                addServiced(name);\n                try {\n                    // Upload WAR\n                    uploadWar(writer, request, uploadedWar, smClient);\n                    if (update && tag == null) {\n                        if (deployedWar.exists() && !deployedWar.delete()) {\n                            writer.println(smClient.getString(\"managerServlet.deleteFail\",\n                                    deployedWar));\n                            return;\n                        }\n                        // Rename uploaded WAR file\n                        uploadedWar.renameTo(deployedWar);\n                    }\n                    if (tag != null) {\n                        // Copy WAR to the host's appBase\n                        copy(uploadedWar, deployedWar);\n                    }\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n        } catch (Exception e) {\n            log(\"managerServlet.check[\" + displayPath + \"]\", e);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    e.toString()));\n            return;\n        }\n\n        context = (Context) host.findChild(name);\n        if (context != null && context.getConfigured()) {\n            writer.println(smClient.getString(\n                    \"managerServlet.deployed\", displayPath));\n        } else {\n            // Something failed\n            writer.println(smClient.getString(\n                    \"managerServlet.deployFailed\", displayPath));\n        }\n    }","commit_id":"b7508405d9f7205973adb1881d96c88fe2e5c3b4","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Install an application for the specified path from the specified\n     * web application archive.\n     *\n     * @param writer    Writer to render results to\n     * @param config    URL of the context configuration file to be installed\n     * @param cn        Name of the application to be installed\n     * @param war       URL of the web application archive to be installed\n     * @param update    true to override any existing webapp on the path\n     * @param smClient  i18n messages using the locale of the client\n     */\n    protected void deploy(PrintWriter writer, String config, ContextName cn,\n            String war, boolean update, StringManager smClient) {\n\n        if (config != null && config.length() == 0) {\n            config = null;\n        }\n        if (war != null && war.length() == 0) {\n            war = null;\n        }\n\n        if (debug >= 1) {\n            if (config != null && config.length() > 0) {\n                if (war != null) {\n                    log(\"install: Installing context configuration at '\" +\n                            config + \"' from '\" + war + \"'\");\n                } else {\n                    log(\"install: Installing context configuration at '\" +\n                            config + \"'\");\n                }\n            } else {\n                if (cn != null) {\n                    log(\"install: Installing web application '\" + cn +\n                            \"' from '\" + war + \"'\");\n                } else {\n                    log(\"install: Installing web application from '\" + war + \"'\");\n                }\n            }\n        }\n\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n        @SuppressWarnings(\"null\") // checked in call above\n        String name = cn.getName();\n        String baseName = cn.getBaseName();\n        String displayPath = cn.getDisplayName();\n\n        // If app exists deployment can only proceed if update is true\n        // Note existing files will be deleted and then replaced\n        Context context = (Context) host.findChild(name);\n        if (context != null && !update) {\n            writer.println(smClient.getString(\"managerServlet.alreadyContext\",\n                    displayPath));\n            return;\n        }\n\n        if (config != null && (config.startsWith(\"file:\"))) {\n            config = config.substring(\"file:\".length());\n        }\n        if (war != null && (war.startsWith(\"file:\"))) {\n            war = war.substring(\"file:\".length());\n        }\n\n        try {\n            if (!isServiced(name)) {\n                addServiced(name);\n                try {\n                    if (config != null) {\n                        if (!configBase.mkdirs() && !configBase.isDirectory()) {\n                            writer.println(smClient.getString(\n                                    \"managerServlet.mkdirFail\",configBase));\n                            return;\n                        }\n                        File localConfig = new File(configBase, baseName + \".xml\");\n                        if (localConfig.isFile() && !localConfig.delete()) {\n                            writer.println(smClient.getString(\n                                    \"managerServlet.deleteFail\", localConfig));\n                            return;\n                        }\n                        copy(new File(config), localConfig);\n                    }\n                    if (war != null) {\n                        File localWar;\n                        if (war.endsWith(\".war\")) {\n                            localWar = new File(host.getAppBaseFile(), baseName + \".war\");\n                        } else {\n                            localWar = new File(host.getAppBaseFile(), baseName);\n                        }\n                        if (localWar.exists() && !ExpandWar.delete(localWar)) {\n                            writer.println(smClient.getString(\n                                    \"managerServlet.deleteFail\", localWar));\n                            return;\n                        }\n                        copy(new File(war), localWar);\n                    }\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n            context = (Context) host.findChild(name);\n            if (context != null && context.getConfigured() &&\n                    context.getState().isAvailable()) {\n                writer.println(smClient.getString(\n                        \"managerServlet.deployed\", displayPath));\n            } else if (context!=null && !context.getState().isAvailable()) {\n                writer.println(smClient.getString(\n                        \"managerServlet.deployedButNotStarted\", displayPath));\n            } else {\n                // Something failed\n                writer.println(smClient.getString(\n                        \"managerServlet.deployFailed\", displayPath));\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log(\"ManagerServlet.install[\" + displayPath + \"]\", t);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    t.toString()));\n        }\n\n    }","id":101376,"modified_method":"/**\n     * Install an application for the specified path from the specified\n     * web application archive.\n     *\n     * @param writer    Writer to render results to\n     * @param config    URL of the context configuration file to be installed\n     * @param cn        Name of the application to be installed\n     * @param war       URL of the web application archive to be installed\n     * @param update    true to override any existing webapp on the path\n     * @param smClient  i18n messages using the locale of the client\n     */\n    protected void deploy(PrintWriter writer, String config, ContextName cn,\n            String war, boolean update, StringManager smClient) {\n\n        if (config != null && config.length() == 0) {\n            config = null;\n        }\n        if (war != null && war.length() == 0) {\n            war = null;\n        }\n\n        if (debug >= 1) {\n            if (config != null && config.length() > 0) {\n                if (war != null) {\n                    log(\"install: Installing context configuration at '\" +\n                            config + \"' from '\" + war + \"'\");\n                } else {\n                    log(\"install: Installing context configuration at '\" +\n                            config + \"'\");\n                }\n            } else {\n                if (cn != null) {\n                    log(\"install: Installing web application '\" + cn +\n                            \"' from '\" + war + \"'\");\n                } else {\n                    log(\"install: Installing web application from '\" + war + \"'\");\n                }\n            }\n        }\n\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n        @SuppressWarnings(\"null\") // checked in call above\n        String name = cn.getName();\n        String baseName = cn.getBaseName();\n        String displayPath = cn.getDisplayName();\n\n        // If app exists deployment can only proceed if update is true\n        // Note existing files will be deleted and then replaced\n        Context context = (Context) host.findChild(name);\n        if (context != null && !update) {\n            writer.println(smClient.getString(\"managerServlet.alreadyContext\",\n                    displayPath));\n            return;\n        }\n\n        if (config != null && (config.startsWith(\"file:\"))) {\n            config = config.substring(\"file:\".length());\n        }\n        if (war != null && (war.startsWith(\"file:\"))) {\n            war = war.substring(\"file:\".length());\n        }\n\n        try {\n            if (isServiced(name)) {\n                writer.println(smClient.getString(\"managerServlet.inService\", displayPath));\n            } else {\n                addServiced(name);\n                try {\n                    if (config != null) {\n                        if (!configBase.mkdirs() && !configBase.isDirectory()) {\n                            writer.println(smClient.getString(\n                                    \"managerServlet.mkdirFail\",configBase));\n                            return;\n                        }\n                        File localConfig = new File(configBase, baseName + \".xml\");\n                        if (localConfig.isFile() && !localConfig.delete()) {\n                            writer.println(smClient.getString(\n                                    \"managerServlet.deleteFail\", localConfig));\n                            return;\n                        }\n                        copy(new File(config), localConfig);\n                    }\n                    if (war != null) {\n                        File localWar;\n                        if (war.endsWith(\".war\")) {\n                            localWar = new File(host.getAppBaseFile(), baseName + \".war\");\n                        } else {\n                            localWar = new File(host.getAppBaseFile(), baseName);\n                        }\n                        if (localWar.exists() && !ExpandWar.delete(localWar)) {\n                            writer.println(smClient.getString(\n                                    \"managerServlet.deleteFail\", localWar));\n                            return;\n                        }\n                        copy(new File(war), localWar);\n                    }\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n            context = (Context) host.findChild(name);\n            if (context != null && context.getConfigured() &&\n                    context.getState().isAvailable()) {\n                writer.println(smClient.getString(\n                        \"managerServlet.deployed\", displayPath));\n            } else if (context!=null && !context.getState().isAvailable()) {\n                writer.println(smClient.getString(\n                        \"managerServlet.deployedButNotStarted\", displayPath));\n            } else {\n                // Something failed\n                writer.println(smClient.getString(\n                        \"managerServlet.deployFailed\", displayPath));\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log(\"ManagerServlet.install[\" + displayPath + \"]\", t);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    t.toString()));\n        }\n\n    }","commit_id":"b7508405d9f7205973adb1881d96c88fe2e5c3b4","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Install an application for the specified path from the specified\n     * web application archive.\n     *\n     * @param writer    Writer to render results to\n     * @param tag       Revision tag to deploy from\n     * @param cn        Name of the application to be installed\n     * @param smClient  i18n messages using the locale of the client\n     */\n    protected void deploy(PrintWriter writer, ContextName cn, String tag,\n            StringManager smClient) {\n\n        // NOTE: It is assumed that update is always true in this method.\n\n        // Validate the requested context path\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n\n        String baseName = cn.getBaseName();\n        String name = cn.getName();\n        String displayPath = cn.getDisplayName();\n\n        // Find the local WAR file\n        File localWar = new File(new File(versioned, tag), baseName + \".war\");\n\n        File deployedWar = new File(host.getAppBaseFile(), baseName + \".war\");\n\n        // Copy WAR to appBase\n        try {\n            if (!isServiced(name)) {\n                addServiced(name);\n                try {\n                    if (!deployedWar.delete()) {\n                        writer.println(smClient.getString(\"managerServlet.deleteFail\",\n                                deployedWar));\n                        return;\n                    }\n                    copy(localWar, deployedWar);\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n        } catch (Exception e) {\n            log(\"managerServlet.check[\" + displayPath + \"]\", e);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    e.toString()));\n            return;\n        }\n\n        context = (Context) host.findChild(name);\n        if (context != null && context.getConfigured()) {\n            writer.println(smClient.getString(\"managerServlet.deployed\",\n                    displayPath));\n        } else {\n            // Something failed\n            writer.println(smClient.getString(\"managerServlet.deployFailed\",\n                    displayPath));\n        }\n\n    }","id":101377,"modified_method":"/**\n     * Install an application for the specified path from the specified\n     * web application archive.\n     *\n     * @param writer    Writer to render results to\n     * @param tag       Revision tag to deploy from\n     * @param cn        Name of the application to be installed\n     * @param smClient  i18n messages using the locale of the client\n     */\n    protected void deploy(PrintWriter writer, ContextName cn, String tag,\n            StringManager smClient) {\n\n        // NOTE: It is assumed that update is always true in this method.\n\n        // Validate the requested context path\n        if (!validateContextName(cn, writer, smClient)) {\n            return;\n        }\n\n        String baseName = cn.getBaseName();\n        String name = cn.getName();\n        String displayPath = cn.getDisplayName();\n\n        // Find the local WAR file\n        File localWar = new File(new File(versioned, tag), baseName + \".war\");\n\n        File deployedWar = new File(host.getAppBaseFile(), baseName + \".war\");\n\n        // Copy WAR to appBase\n        try {\n            if (isServiced(name)) {\n                writer.println(smClient.getString(\"managerServlet.inService\", displayPath));\n            } else {\n                addServiced(name);\n                try {\n                    if (!deployedWar.delete()) {\n                        writer.println(smClient.getString(\"managerServlet.deleteFail\",\n                                deployedWar));\n                        return;\n                    }\n                    copy(localWar, deployedWar);\n                    // Perform new deployment\n                    check(name);\n                } finally {\n                    removeServiced(name);\n                }\n            }\n        } catch (Exception e) {\n            log(\"managerServlet.check[\" + displayPath + \"]\", e);\n            writer.println(smClient.getString(\"managerServlet.exception\",\n                    e.toString()));\n            return;\n        }\n\n        context = (Context) host.findChild(name);\n        if (context != null && context.getConfigured()) {\n            writer.println(smClient.getString(\"managerServlet.deployed\",\n                    displayPath));\n        } else {\n            // Something failed\n            writer.println(smClient.getString(\"managerServlet.deployFailed\",\n                    displayPath));\n        }\n\n    }","commit_id":"b7508405d9f7205973adb1881d96c88fe2e5c3b4","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n\t\tpublic GetTransUnitsStatesResult execute(GetTransUnitsStates action, ExecutionContext context)\n\t\t\t\tthrows ActionException {\n\n\t\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\t\n\t\t\tlog.info(\"Fetching Transunits for {0}\", action.getDocumentId());\n\t\t\t\n\t\t\tQuery query = session.createQuery(\n\t\t\t\t\"from HTextFlowTarget tft where tft.textFlow.document.id = :id \" +\n\t\t        \" and tft.locale = :locale \"+ \n\t\t\t\t\" and tft.state = :state\"+\n\t\t\t\t\" order by tft.textFlow.id\")\n\t\t\t\t.setParameter(\"id\", action.getDocumentId().getValue())\n\t\t\t    .setParameter(\"locale\", action.getWorkspaceId().getLocaleId())\n\t\t\t    .setParameter(\"state\", action.getState());\n\t\t\t\n\t\t\tlog.info(\"Transunits for State {0}\", action.getState());\n\t\t\n\t\t\tList<HTextFlowTarget> textFlowTargets = query.list();\n\t\t    \n\t\t\tArrayList<TransUnitId> units = new ArrayList<TransUnitId>();\n\t\t\tif(action.isReverse()) {\n\t\t\t\tint count = 0;\n\t\t\t\tCollections.reverse(textFlowTargets);\n\t\t\t\t\n\t\t\t\tfor(HTextFlowTarget textFlowTarget : textFlowTargets) {\n\t\t\t\t\tif(textFlowTarget.getTextFlow().getId() < action.getOffset() && count < action.getCount()) {\n\t\t\t\t\t\tTransUnitId tuId = new TransUnitId(textFlowTarget.getTextFlow().getId());\n\t\t\t\t\t\tunits.add(tuId);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t} else if (count >= action.getCount()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint count = 0;\n\t\t\t\tfor(HTextFlowTarget textFlowTarget : textFlowTargets) {\n\t\t\t\t\tif(textFlowTarget.getTextFlow().getId() > action.getOffset() && count < action.getCount()) {\n\t\t\t\t\t\tTransUnitId tuId = new TransUnitId(textFlowTarget.getTextFlow().getId());\n\t\t\t\t\t\tunits.add(tuId);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t} else if (count >= action.getCount()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new GetTransUnitsStatesResult(action.getDocumentId(), units);\n\t\t}","id":101378,"modified_method":"@Override\n\t\tpublic GetTransUnitsStatesResult execute(GetTransUnitsStates action, ExecutionContext context)\n\t\t\t\tthrows ActionException {\n\n\t\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\tList<Long> results = new ArrayList<Long>(); \n\t\t\t\t\t\t\n\t\t\tif(action.getState().equals(ContentState.NeedReview)) {\n\t\t\t\tList<HTextFlowTarget> textFlowTargets = new ArrayList<HTextFlowTarget>();\n\t\t\t\tif(action.isReverse()) {\n\t\t\t\t\ttextFlowTargets = session.createQuery(\"from HTextFlowTarget tft where tft.textFlow.document.id = :id \" +\n\t\t\t\t\t\t\" and tft.state = :state \" +\n\t\t\t\t\t\t\" and tft.textFlow.pos < :offset \"+\n\t\t\t\t\t\t\" and tft.locale = :locale \"+\n\t\t\t\t\t\t\" order by tft.textFlow.pos desc\")\t\t\t\t\t\t\n\t\t\t\t\t\t.setParameter(\"state\", action.getState())\n\t\t\t\t\t\t.setParameter(\"offset\", action.getOffset())\n\t\t\t\t\t\t.setParameter(\"locale\", action.getWorkspaceId().getLocaleId())\n\t\t\t\t\t\t.setParameter(\"id\", action.getDocumentId().getValue())\n\t\t\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t\t\t.list();\n\t\t\t\t} else {\n\t\t\t\t\ttextFlowTargets = session.createQuery(\"from HTextFlowTarget tft where tft.textFlow.document.id = :id \" +\n\t\t\t\t\t\t\t\" and tft.state = :state \" +\n\t\t\t\t\t\t\t\" and tft.textFlow.pos > :offset \"+\n\t\t\t\t\t\t\t\" and tft.locale = :locale \"+\n\t\t\t\t\t\t\t\" order by tft.textFlow.pos\")\t\t\t\t\t\t\n\t\t\t\t\t\t.setParameter(\"state\", action.getState())\n\t\t\t\t\t\t.setParameter(\"offset\", action.getOffset())\n\t\t\t\t\t\t.setParameter(\"locale\", action.getWorkspaceId().getLocaleId())\n\t\t\t\t\t\t.setParameter(\"id\", action.getDocumentId().getValue())\n\t\t\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t\t\t.list();\n\t\t\t\t}\n\t\t\t\tfor (HTextFlowTarget target : textFlowTargets) {\n\t\t\t\t\tresults.add(new Long(target.getTextFlow().getPos()));\n\t\t\t\t}\n\t\t\t} else if(action.getState().equals(ContentState.New)) {\n\t\t\t\tList<HTextFlow> textFlows = new ArrayList<HTextFlow>();\n\t\t\t\tif(action.isReverse()) {\n\t\t\t\t\ttextFlows = session.createQuery(\n\t\t\t\t\t\t\t\"from HTextFlow tf where tf.document.id = :id \" +\n\t\t\t\t\t\t\t\" and tf.pos < :offset \"+\n\t\t\t\t\t\t\t\" order by tf.pos desc\")\n\t\t\t\t\t\t\t.setParameter(\"offset\", action.getOffset())\n\t\t\t\t\t\t\t.setParameter(\"id\", action.getDocumentId().getValue())\n\t\t\t\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t\t\t\t.list();\n\t\t\t\t} else {\n\t\t\t\t\ttextFlows = session.createQuery(\n\t\t\t\t\t\t\t\t\t\"from HTextFlow tf where tf.document.id = :id \" +\n\t\t\t\t\t\t\t\t\t\" and tf.pos > :offset \"+\n\t\t\t\t\t\t\t\t\t\" order by tf.pos\")\n\t\t\t\t\t\t\t\t\t.setParameter(\"offset\", action.getOffset())\n\t\t\t\t\t\t\t\t\t.setParameter(\"id\", action.getDocumentId().getValue())\n\t\t\t\t\t\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t\t\t\t\t\t.list();\n\t\t\t\t}\n\t\t\t\tfor(HTextFlow textFlow : textFlows) {\n\t\t\t\t\tif(textFlow.getTargets().get(action.getWorkspaceId().getLocaleId())==null){\n\t\t\t\t\t\tresults.add(new Long(textFlow.getPos()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn new GetTransUnitsStatesResult(action.getDocumentId(), results);\n\t\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic GetTransUnitsResult execute(GetTransUnits action, ExecutionContext context)\n\t\t\tthrows ActionException {\n\n\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\n\t\tlog.info(\"Fetching Transunits for {0}\", action.getDocumentId());\n\t\t\n\t\tQuery query = session.createQuery(\n\t\t\t\"from HTextFlow tf where tf.document.id = :id order by tf.id\")\n\t\t\t.setParameter(\"id\", action.getDocumentId().getValue());\n\t\t\n\t\tint size = query.list().size();\n\t\t\n\t\tList<HTextFlow> textFlows = query \n\t\t\t\t.setFirstResult(action.getOffset())\n\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t.list();\n\t\t\n\t\t\n\t\t\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(HTextFlow textFlow : textFlows) {\n\t\t\t\n\t\t\tTransUnitId tuId = new TransUnitId(textFlow.getId());\n\t\t\tProjectContainerId projectContainerId = new ProjectContainerId(textFlow.getDocument().getProject().getId());\n\t\t\tTranslationWorkspace workspace = translationWorkspaceManager.getOrRegisterWorkspace(\n\t\t\t\t\taction.getWorkspaceId() );\n\n\t\t\t//EditState editstate = workspace.getTransUnitStatus(tuId);\n\t\t\tTransUnit tu = new TransUnit(tuId, action.getWorkspaceId().getLocaleId(), textFlow.getContent(), toString(textFlow.getComment()), \"\", ContentState.New);\n\t\t\tHTextFlowTarget target = textFlow.getTargets().get(action.getWorkspaceId().getLocaleId());\n\t\t\tif(target != null) {\n\t\t\t\ttu.setTarget(target.getContent());\n\t\t\t\ttu.setStatus( target.getState() );\n\t\t\t}\n\t\t\tunits.add(tu);\n\t\t}\n\n\t\treturn new GetTransUnitsResult(action.getDocumentId(), units, size );\n\t}","id":101379,"modified_method":"@Override\n\tpublic GetTransUnitsResult execute(GetTransUnits action, ExecutionContext context)\n\t\t\tthrows ActionException {\n\n\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\n\t\tlog.info(\"Fetching Transunits for {0}\", action.getDocumentId());\n\t\t\n\t\tQuery query = session.createQuery(\n\t\t\t\"from HTextFlow tf where tf.document.id = :id order by tf.pos\")\n\t\t\t.setParameter(\"id\", action.getDocumentId().getValue());\n\t\t\n\t\tint size = query.list().size();\n\t\t\n\t\tList<HTextFlow> textFlows = query \n\t\t\t\t.setFirstResult(action.getOffset())\n\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t.list();\n\t\t\n\t\t\n\t\t\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(HTextFlow textFlow : textFlows) {\n\t\t\t\n\t\t\tTransUnitId tuId = new TransUnitId(textFlow.getId());\n\t\t\tProjectContainerId projectContainerId = new ProjectContainerId(textFlow.getDocument().getProject().getId());\n\t\t\tTranslationWorkspace workspace = translationWorkspaceManager.getOrRegisterWorkspace(\n\t\t\t\t\taction.getWorkspaceId() );\n\n\t\t\t//EditState editstate = workspace.getTransUnitStatus(tuId);\n\t\t\tTransUnit tu = new TransUnit(tuId, action.getWorkspaceId().getLocaleId(), textFlow.getContent(), toString(textFlow.getComment()), \"\", ContentState.New);\n\t\t\tHTextFlowTarget target = textFlow.getTargets().get(action.getWorkspaceId().getLocaleId());\n\t\t\tif(target != null) {\n\t\t\t\ttu.setTarget(target.getContent());\n\t\t\t\ttu.setStatus( target.getState() );\n\t\t\t}\n\t\t\tunits.add(tu);\n\t\t}\n\n\t\treturn new GetTransUnitsResult(action.getDocumentId(), units, size );\n\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ArrayList<TransUnitId> getUnits() {\n\t\treturn units;\n\t}","id":101380,"modified_method":"public List<Long> getUnits() {\n\t\treturn units;\n\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"public GetTransUnitsStatesResult(DocumentId documentId, ArrayList<TransUnitId> units) {\n\t\tthis.documentId = documentId;\n\t\tthis.units = units;\n\t}","id":101381,"modified_method":"public GetTransUnitsStatesResult(DocumentId documentId, List<Long> units) {\n\t\tthis.documentId = documentId;\n\t\tthis.units = units;\n\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void cachePrevFuzzy(final ContentState desiredState, final StatesCacheCallback callBack) {\n\t\tisReqComplete = false;\n\t\tdispatcher.execute(new GetTransUnitsStates(documentId, curRowIndex+1, 3, true, desiredState), new AsyncCallback<GetTransUnitsStatesResult>() {\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GetTransUnitsStatesResult result) {\n\t\t\t\tisReqComplete = true;\n\t\t\t\tif(!result.getUnits().isEmpty()) {\n\t\t\t\t\tif(desiredState.equals(ContentState.NeedReview))\n\t\t\t\t\t\ttransIdPrevFuzzyCache = result.getUnits();\n\t\t\t\t\tif(desiredState.equals(ContentState.New))\n\t\t\t\t\t\ttransIdPrevNewCache = result.getUnits();\n\t\t\t\t\t\n\t\t\t\t\tcallBack.prevFuzzy(desiredState);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t}\n\t\t});\n\t}","id":101382,"modified_method":"private void cachePrevFuzzy(final ContentState desiredState, final StatesCacheCallback callBack) {\n\t\tisReqComplete = false;\n\t\tdispatcher.execute(new GetTransUnitsStates(documentId, curRowIndex, 3, true, desiredState), new AsyncCallback<GetTransUnitsStatesResult>() {\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GetTransUnitsStatesResult result) {\n\t\t\t\tisReqComplete = true;\n\t\t\t\tif(!result.getUnits().isEmpty()) {\n\t\t\t\t\tif(desiredState.equals(ContentState.NeedReview))\n\t\t\t\t\t\ttransIdPrevFuzzyCache = result.getUnits();\n\t\t\t\t\tif(desiredState.equals(ContentState.New))\n\t\t\t\t\t\ttransIdPrevNewCache = result.getUnits();\n\t\t\t\t\tcallBack.prevFuzzy(desiredState);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t}\n\t\t});\n\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void gotoPrevState(ContentState desiredState) { \n\t\tif(desiredState.equals(ContentState.NeedReview)) {\n\t\t//Clean the cache for Next Fuzzy to avoid issues about cache is obsolete\n\t\ttransIdNextFuzzyCache.clear();\n\t\t//If the catch of fuzzy row is empty and request is complete, generate one\n\t\tif(transIdPrevFuzzyCache.isEmpty()) {\n\t\t\t if (isReqComplete)\n\t\t\t\t cachePrevFuzzy(desiredState, cacheCallback);\n\t\t} else {\n\t\t\tint size = transIdPrevFuzzyCache.size(); \n\t\t\tint offset = (int)transIdPrevFuzzyCache.get(size-1).getId()-1;\n\t\t\t\tif(curRowIndex > offset) {\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tint fuzzyRowIndex = (int)transIdPrevFuzzyCache.get(i).getId()-1;\n\t\t\t\t\t\tif (curRowIndex > fuzzyRowIndex) {\n\t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tcancelEdit();\n\t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n\t\t\t\t\t\t\t\tif(pageNum != curPage)\n\t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n\t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}  else {\n\t\t\t\t\ttransIdPrevFuzzyCache.clear();\n\t\t\t\t\tcachePrevFuzzy(desiredState, cacheCallback);\n\t\t\t\t}\n\t\t}\n\t\t} else if(desiredState.equals(ContentState.New)) {\n\t\t\t //Clean the cache for Next New to avoid issues about cache is obsolete\n\t\t\ttransIdNextNewCache.clear();\n\t\t\t//If the catch of fuzzy row is empty and request is complete, generate one\n\t\t\t\tif(transIdPrevNewCache.isEmpty()) {\n\t\t\t\t\t if (isReqComplete)\n\t\t\t\t\t\t cachePrevFuzzy(desiredState, cacheCallback);\n\t\t\t\t} else {\n\t\t\t\t\tint size = transIdPrevNewCache.size(); \n\t\t\t\t\tint offset = (int)transIdPrevNewCache.get(size-1).getId()-1;\n\t\t\t\t\tif(curRowIndex > offset) {\n\t\t\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\t\t\tint fuzzyRowIndex = (int)transIdPrevNewCache.get(i).getId()-1;\n\t\t\t\t\t\t\t\tif (curRowIndex > fuzzyRowIndex) {\n\t\t\t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\t\t\tcancelEdit();\n\t\t\t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n\t\t\t\t\t\t\t\t\t\tif(pageNum != curPage)\n\t\t\t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n\t\t\t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}  else {\n\t\t\t\t\t\t\ttransIdPrevNewCache.clear();\n\t\t\t\t\t\t\tcachePrevFuzzy(desiredState, cacheCallback);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t}","id":101383,"modified_method":"private void gotoPrevState(ContentState desiredState) { \n\t\tif(desiredState.equals(ContentState.NeedReview)) {\n\t\t//Clean the cache for Next Fuzzy to avoid issues about cache is obsolete\n\t\ttransIdNextFuzzyCache.clear();\n\t\t//If the catch of fuzzy row is empty and request is complete, generate one\n\t\tif(transIdPrevFuzzyCache.isEmpty()) {\n\t\t\t if (isReqComplete)\n\t\t\t\t cachePrevFuzzy(desiredState, cacheCallback);\n\t\t} else {\n\t\t\tint size = transIdPrevFuzzyCache.size(); \n\t\t\tint offset = transIdPrevFuzzyCache.get(size-1).intValue();\n\t\t\t\tif(curRowIndex > offset) {\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tint fuzzyRowIndex = transIdPrevFuzzyCache.get(i).intValue();\n\t\t\t\t\t\tif (curRowIndex > fuzzyRowIndex) {\n\t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tcancelEdit();\n\t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n\t\t\t\t\t\t\t\tif(pageNum != curPage)\n\t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n\t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}  else {\n\t\t\t\t\ttransIdPrevFuzzyCache.clear();\n\t\t\t\t\tcachePrevFuzzy(desiredState, cacheCallback);\n\t\t\t\t}\n\t\t}\n\t\t} else if(desiredState.equals(ContentState.New)) {\n\t\t\t //Clean the cache for Next New to avoid issues about cache is obsolete\n\t\t\ttransIdNextNewCache.clear();\n\t\t\t//If the catch of fuzzy row is empty and request is complete, generate one\n\t\t\t\tif(transIdPrevNewCache.isEmpty()) {\n\t\t\t\t\t if (isReqComplete)\n\t\t\t\t\t\t cachePrevFuzzy(desiredState, cacheCallback);\n\t\t\t\t} else {\n\t\t\t\t\tint size = transIdPrevNewCache.size(); \n\t\t\t\t\tint offset = transIdPrevNewCache.get(size-1).intValue();\n\t\t\t\t\tLog.info(\"Size: \"+size);\n\t\t\t\t\tLog.info(\"Offset: \"+offset);\n\t\t\t\t\tLog.info(\"Current \"+ curRowIndex);\n\t\t\t\t\tif(curRowIndex > offset) {\n\t\t\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\t\t\tint fuzzyRowIndex = transIdPrevNewCache.get(i).intValue();\n\t\t\t\t\t\t\t\tif (curRowIndex > fuzzyRowIndex) {\n\t\t\t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\t\t\tcancelEdit();\n\t\t\t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n\t\t\t\t\t\t\t\t\t\tif(pageNum != curPage)\n\t\t\t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n\t\t\t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}  else {\n\t\t\t\t\t\t\ttransIdPrevNewCache.clear();\n\t\t\t\t\t\t\tcachePrevFuzzy(desiredState, cacheCallback);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void cacheNextFuzzy(final ContentState desiredState, final StatesCacheCallback callBack) {\n\t\tisReqComplete = false;\n\t\tdispatcher.execute(new GetTransUnitsStates(documentId, curRowIndex+1, 3, false, desiredState), new AsyncCallback<GetTransUnitsStatesResult>() {\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GetTransUnitsStatesResult result) {\n\t\t\t\tLog.info(\"DesiredState: \"+desiredState);\n\t\t\t\tLog.info(\"Size:\"+result.getUnits().size());\n\t\t\t\tisReqComplete = true;\t\n\t\t\t\tif(!result.getUnits().isEmpty()) {\n\t\t\t\t\tif(desiredState.equals(ContentState.NeedReview))\n\t\t\t\t\t\ttransIdNextFuzzyCache = result.getUnits();\n\t\t\t\t\tif(desiredState.equals(ContentState.New)) {\n\t\t\t\t\t\n\t\t\t\t\t\ttransIdNextNewCache = result.getUnits();\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tcallBack.nextFuzzy(desiredState);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t}\n\t\t});\n\t}","id":101384,"modified_method":"private void cacheNextFuzzy(final ContentState desiredState, final StatesCacheCallback callBack) {\n\t\tisReqComplete = false;\n\t\tdispatcher.execute(new GetTransUnitsStates(documentId, curRowIndex, 3, false, desiredState), new AsyncCallback<GetTransUnitsStatesResult>() {\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GetTransUnitsStatesResult result) {\n\t\t\t\tLog.info(\"DesiredState: \"+desiredState);\n\t\t\t\tLog.info(\"Size:\"+result.getUnits().size());\n\t\t\t\tisReqComplete = true;\t\n\t\t\t\tif(!result.getUnits().isEmpty()) {\n\t\t\t\t\tif(desiredState.equals(ContentState.NeedReview))\n\t\t\t\t\t\ttransIdNextFuzzyCache = result.getUnits();\n\t\t\t\t\tif(desiredState.equals(ContentState.New))\n\t\t\t\t\t\ttransIdNextNewCache = result.getUnits();\n\t\t\t\t\tcallBack.nextFuzzy(desiredState);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t}\n\t\t});\n\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void gotoNextState(ContentState desiredState) {\n\t\tLog.info(\"State: \"+desiredState);\n        if(desiredState.equals(ContentState.NeedReview)) {\n        \ttransIdPrevFuzzyCache.clear();\n\t\t//If the catch of fuzzy row is empty, generate one\n\t\tif(transIdNextFuzzyCache.isEmpty()) {\n\t\t\tif(isReqComplete) \n\t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n\t\t} else {\n\t\t\tint size = transIdNextFuzzyCache.size(); \n\t\t\tint offset = (int)transIdNextFuzzyCache.get(size-1).getId()-1;\n\t\t\tif(curRowIndex < offset) {\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tint fuzzyRowIndex = (int)transIdNextFuzzyCache.get(i).getId()-1;\n\t\t\t\t\t\tif (curRowIndex < fuzzyRowIndex) {\n\t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tLog.info(\"Page for Next \"+pageNum);\n\t\t\t\t\t\t\t\tLog.info(\"Next Row Index \"+rowNum);\n\t\t\t\t\t\t\t\tcancelEdit();\n\t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n\t\t\t\t\t\t\t\tif(pageNum != curPage)\n\t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n\t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttransIdNextFuzzyCache.clear();\n\t\t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n\t\t\t\t}\n\t\t}\n        } else if (desiredState.equals(ContentState.New)) {\n         \ttransIdPrevNewCache.clear();\n    \t\t//If the catch of fuzzy row is empty, generate one\n    \t\tif(transIdNextNewCache.isEmpty()) {\n    \t\t\tif(isReqComplete) \n    \t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n    \t\t} else {\n    \t\t\tint size = transIdNextNewCache.size(); \n    \t\t\tint offset = (int)transIdNextNewCache.get(size-1).getId()-1;\n    \t\t\tif(curRowIndex < offset) {\n    \t\t\t\tfor (int i = 0; i < size; i++) {\n    \t\t\t\t\t\tint fuzzyRowIndex = (int)transIdNextNewCache.get(i).getId()-1;\n    \t\t\t\t\t\tif (curRowIndex < fuzzyRowIndex) {\n    \t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n    \t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n    \t\t\t\t\t\t\t\tLog.info(\"Page for Next \"+pageNum);\n    \t\t\t\t\t\t\t\tLog.info(\"Next Row Index \"+rowNum);\n    \t\t\t\t\t\t\t\tcancelEdit();\n    \t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n    \t\t\t\t\t\t\t\tif(pageNum != curPage)\n    \t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n    \t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t} else {\n    \t\t\t\t\ttransIdNextNewCache.clear();\n    \t\t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n    \t\t\t\t}\n    \t\t}\n        \t\n        \t\n        }\n\t}","id":101385,"modified_method":"private void gotoNextState(ContentState desiredState) {\n\t\tLog.info(\"State: \"+desiredState);\n        if(desiredState.equals(ContentState.NeedReview)) {\n        \ttransIdPrevFuzzyCache.clear();\n\t\t//If the catch of fuzzy row is empty, generate one\n\t\tif(transIdNextFuzzyCache.isEmpty()) {\n\t\t\tif(isReqComplete) \n\t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n\t\t} else {\n\t\t\tint size = transIdNextFuzzyCache.size(); \n\t\t\tint offset = transIdNextFuzzyCache.get(size-1).intValue();\n\t\t\tif(curRowIndex < offset) {\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tint fuzzyRowIndex = transIdNextFuzzyCache.get(i).intValue();\n\t\t\t\t\t\tif (curRowIndex < fuzzyRowIndex) {\n\t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n\t\t\t\t\t\t\t\tLog.info(\"Page for Next \"+pageNum);\n\t\t\t\t\t\t\t\tLog.info(\"Next Row Index \"+rowNum);\n\t\t\t\t\t\t\t\tcancelEdit();\n\t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n\t\t\t\t\t\t\t\tif(pageNum != curPage)\n\t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n\t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttransIdNextFuzzyCache.clear();\n\t\t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n\t\t\t\t}\n\t\t}\n        } else if (desiredState.equals(ContentState.New)) {\n         \ttransIdPrevNewCache.clear();\n    \t\t//If the catch of fuzzy row is empty, generate one\n    \t\tif(transIdNextNewCache.isEmpty()) {\n    \t\t\tif(isReqComplete) \n    \t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n    \t\t} else {\n    \t\t\tint size = transIdNextNewCache.size(); \n    \t\t\tint offset = transIdNextNewCache.get(size-1).intValue();\n    \t\t\tif(curRowIndex < offset) {\n    \t\t\t\tfor (int i = 0; i < size; i++) {\n    \t\t\t\t\t\tint fuzzyRowIndex = transIdNextNewCache.get(i).intValue();\n    \t\t\t\t\t\tif (curRowIndex < fuzzyRowIndex) {\n    \t\t\t\t\t\t\t\tint pageNum = fuzzyRowIndex/(MAX_PAGE_ROW+1);\n    \t\t\t\t\t\t\t\tint rowNum = fuzzyRowIndex%(MAX_PAGE_ROW+1);\n    \t\t\t\t\t\t\t\tLog.info(\"Page for Next \"+pageNum);\n    \t\t\t\t\t\t\t\tLog.info(\"Next Row Index \"+rowNum);\n    \t\t\t\t\t\t\t\tcancelEdit();\n    \t\t\t\t\t\t\t\tselectedTransUnit = display.getTransUnitValue(rowNum);\n    \t\t\t\t\t\t\t\tif(pageNum != curPage)\n    \t\t\t\t\t\t\t\t\tdisplay.gotoPage(pageNum, false);\n    \t\t\t\t\t\t\t\tdisplay.gotoRow(rowNum); \n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t} else {\n    \t\t\t\t\ttransIdNextNewCache.clear();\n    \t\t\t\t\tcacheNextFuzzy(desiredState, cacheCallback);\n    \t\t\t\t}\n    \t\t}\n        \t\n        \t\n        }\n\t}","commit_id":"90adc21ef0acaeb9bf8277bd941555e8aff86868","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void processBatchOfRows(ArrayList<BatchUpdate> list, byte[] tableName)\n        throws IOException {\n      // See HBASE-748 for pseudo code of this method\n      if (list.isEmpty()) {\n        return;\n      }\n      boolean retryOnlyOne = false;\n      Collections.sort(list);\n      List<BatchUpdate> tempUpdates = new ArrayList<BatchUpdate>();\n      byte [] currentRegion = getRegionLocation(tableName, list.get(0).getRow(),\n        false).getRegionInfo().getRegionName();\n      byte [] region = currentRegion;\n      boolean isLastRow = false;\n      int tries = 0;\n      for (int i = 0; i < list.size() && tries < numRetries; i++) {\n        BatchUpdate batchUpdate = list.get(i);\n        tempUpdates.add(batchUpdate);\n        isLastRow = (i + 1) == list.size();\n        if (!isLastRow) {\n          region = getRegionLocation(tableName, list.get(i + 1).getRow(), false)\n              .getRegionInfo().getRegionName();\n        }\n        if (!Bytes.equals(currentRegion, region) || isLastRow || retryOnlyOne) {\n          final BatchUpdate[] updates = tempUpdates.toArray(new BatchUpdate[0]);\n          int index = getRegionServerForWithoutRetries(new ServerCallable<Integer>(\n              this, tableName, batchUpdate.getRow()) {\n            public Integer call() throws IOException {\n              int i = server.batchUpdates(location.getRegionInfo()\n                  .getRegionName(), updates);\n              return i;\n            }\n          });\n          if (index != -1) {\n            if (tries == numRetries - 1) {\n              throw new RetriesExhaustedException(\"Some server\",\n                  currentRegion, batchUpdate.getRow(), \n                  tries, new ArrayList<Throwable>());\n            }\n            long sleepTime = getPauseTime(tries);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Reloading region \" + Bytes.toString(currentRegion) +\n                \" location because regionserver didn't accept updates; \" +\n                \"tries=\" + tries +\n                \" of max=\" + this.numRetries + \", waiting=\" + sleepTime + \"ms\");\n            }\n            try {\n              Thread.sleep(sleepTime);\n              tries++;\n            } catch (InterruptedException e) {\n              // continue\n            }\n            i = i - updates.length + index;\n            retryOnlyOne = true;\n            region = getRegionLocation(tableName, list.get(i + 1).getRow(),\n                true).getRegionInfo().getRegionName();\n          }\n          else {\n            retryOnlyOne = false;\n          }\n          currentRegion = region;\n          tempUpdates.clear();\n        }\n      }\n    }","id":101386,"modified_method":"public void processBatchOfRows(ArrayList<BatchUpdate> list, byte[] tableName)\n        throws IOException {\n      if (list.isEmpty()) {\n        return;\n      }\n      boolean retryOnlyOne = false;\n      int tries = 0;\n      Collections.sort(list);\n      List<BatchUpdate> tempUpdates = new ArrayList<BatchUpdate>();\n      HRegionLocation location =\n        getRegionLocationForRowWithRetries(tableName, list.get(0).getRow());\n      byte [] currentRegion = location.getRegionInfo().getRegionName();\n      byte [] region = currentRegion;\n      boolean isLastRow = false;\n      for (int i = 0; i < list.size() && tries < numRetries; i++) {\n        BatchUpdate batchUpdate = list.get(i);\n        tempUpdates.add(batchUpdate);\n        isLastRow = (i + 1) == list.size();\n        if (!isLastRow) {\n          location = getRegionLocationForRowWithRetries(tableName,\n            list.get(i+1).getRow());\n          region = location.getRegionInfo().getRegionName();\n        }\n        if (!Bytes.equals(currentRegion, region) || isLastRow || retryOnlyOne) {\n          final BatchUpdate[] updates = tempUpdates.toArray(new BatchUpdate[0]);\n          int index = getRegionServerWithRetries(new ServerCallable<Integer>(\n              this, tableName, batchUpdate.getRow()) {\n            public Integer call() throws IOException {\n              int i = server.batchUpdates(location.getRegionInfo()\n                  .getRegionName(), updates);\n              return i;\n            }\n          });\n          if (index != -1) {\n            if (tries == numRetries - 1) {\n              throw new RetriesExhaustedException(\"Some server\",\n                  currentRegion, batchUpdate.getRow(), \n                  tries, new ArrayList<Throwable>());\n            }\n            long sleepTime = getPauseTime(tries);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Reloading region \" + Bytes.toString(currentRegion) +\n                \" location because regionserver didn't accept updates; \" +\n                \"tries=\" + tries +\n                \" of max=\" + this.numRetries + \", waiting=\" + sleepTime + \"ms\");\n            }\n            try {\n              Thread.sleep(sleepTime);\n              tries++;\n            } catch (InterruptedException e) {\n              // continue\n            }\n            i = i - updates.length + index;\n            retryOnlyOne = true;\n            location = getRegionLocationForRowWithRetries(tableName, \n              list.get(i + 1).getRow());\n            region = location.getRegionInfo().getRegionName();\n          }\n          else {\n            retryOnlyOne = false;\n          }\n          currentRegion = region;\n          tempUpdates.clear();\n        }\n      }\n    }","commit_id":"700b2a782d4d88bfa0f5c0ad78a8feba2c485cb2","url":"https://github.com/apache/hbase"},{"original_method":"@NotNull\n    public static PropertyDescriptor getPropertyDescriptorForObjectDeclaration(@NotNull BindingContext context,\n            @NotNull JetObjectDeclarationName name) {\n        PropertyDescriptor propertyDescriptor = context.get(BindingContext.OBJECT_DECLARATION, name);\n        assert propertyDescriptor != null : message(name);\n        return propertyDescriptor;\n    }","id":101387,"modified_method":"@NotNull\n    public static PropertyDescriptor getPropertyDescriptorForObjectDeclaration(@NotNull BindingContext context,\n            @NotNull JetObjectDeclarationName name) {\n        return BindingContextUtils.getNotNull(context, BindingContext.OBJECT_DECLARATION, name);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static JetType getTypeByReference(@NotNull BindingContext context,\n            @NotNull JetTypeReference typeReference) {\n        JetType result = context.get(BindingContext.TYPE, typeReference);\n        assert result != null : message(typeReference, \"TypeReference should reference a type\");\n        return result;\n    }","id":101388,"modified_method":"@NotNull\n    public static JetType getTypeByReference(@NotNull BindingContext context,\n            @NotNull JetTypeReference typeReference) {\n        return BindingContextUtils.getNotNull(context, BindingContext.TYPE, typeReference);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getNextFunction(@NotNull BindingContext context,\n            @NotNull JetExpression rangeExpression) {\n        ResolvedCall<FunctionDescriptor> resolvedCall = context.get(BindingContext.LOOP_RANGE_NEXT_RESOLVED_CALL, rangeExpression);\n        assert resolvedCall != null : ErrorReportingUtils\n                .message(rangeExpression, \"Range expression must have a descriptor for next function\");\n        return resolvedCall;\n    }","id":101389,"modified_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getNextFunction(@NotNull BindingContext context,\n            @NotNull JetExpression rangeExpression) {\n        return BindingContextUtils.getNotNull(context, BindingContext.LOOP_RANGE_NEXT_RESOLVED_CALL, rangeExpression);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getIteratorFunction(@NotNull BindingContext context,\n            @NotNull JetExpression rangeExpression) {\n        ResolvedCall<FunctionDescriptor> resolvedCall = context.get(BindingContext.LOOP_RANGE_ITERATOR_RESOLVED_CALL, rangeExpression);\n        assert resolvedCall != null :\n                message(rangeExpression, \"Range expression must have a descriptor for iterator function\");\n        return resolvedCall;\n    }","id":101390,"modified_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getIteratorFunction(@NotNull BindingContext context,\n            @NotNull JetExpression rangeExpression) {\n        return BindingContextUtils.getNotNull(context, BindingContext.LOOP_RANGE_ITERATOR_RESOLVED_CALL, rangeExpression);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean isStatement(@NotNull BindingContext context, @NotNull JetExpression expression) {\n        Boolean isStatement = context.get(BindingContext.STATEMENT, expression);\n        assert isStatement != null : message(expression, \"Invalid behaviour of get(BindingContext.STATEMENT) at\");\n        return isStatement;\n    }","id":101391,"modified_method":"public static boolean isStatement(@NotNull BindingContext context, @NotNull JetExpression expression) {\n        return BindingContextUtils.getNotNull(context, BindingContext.STATEMENT, expression);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getResolvedCallForArrayAccess(@NotNull BindingContext context,\n            @NotNull JetArrayAccessExpression arrayAccessExpression,\n            boolean isGet) {\n        ResolvedCall<FunctionDescriptor> resolvedCall = context.get(isGet\n                                                                    ? INDEXED_LVALUE_GET\n                                                                    : INDEXED_LVALUE_SET, arrayAccessExpression);\n        assert resolvedCall != null : message(arrayAccessExpression);\n        return resolvedCall;\n    }","id":101392,"modified_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getResolvedCallForArrayAccess(@NotNull BindingContext context,\n            @NotNull JetArrayAccessExpression arrayAccessExpression,\n            boolean isGet) {\n        return BindingContextUtils.getNotNull(context, isGet ? INDEXED_LVALUE_GET : INDEXED_LVALUE_SET, arrayAccessExpression);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean isVariableReassignment(@NotNull BindingContext context, @NotNull JetExpression expression) {\n        Boolean result = context.get(BindingContext.VARIABLE_REASSIGNMENT, expression);\n        assert result != null : message(expression);\n        return result;\n    }","id":101393,"modified_method":"public static boolean isVariableReassignment(@NotNull BindingContext context, @NotNull JetExpression expression) {\n        return BindingContextUtils.getNotNull(context, BindingContext.VARIABLE_REASSIGNMENT, expression);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getHasNextCallable(@NotNull BindingContext context,\n            @NotNull JetExpression rangeExpression) {\n        ResolvedCall<FunctionDescriptor> resolvedCall = context.get(BindingContext.LOOP_RANGE_HAS_NEXT_RESOLVED_CALL, rangeExpression);\n        assert resolvedCall != null\n                : message(rangeExpression, \"Range expression must have a descriptor for hasNext function or property\");\n        return resolvedCall;\n    }","id":101394,"modified_method":"@NotNull\n    public static ResolvedCall<FunctionDescriptor> getHasNextCallable(@NotNull BindingContext context,\n            @NotNull JetExpression rangeExpression) {\n        return BindingContextUtils.getNotNull(context, BindingContext.LOOP_RANGE_HAS_NEXT_RESOLVED_CALL, rangeExpression);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static JetType getTypeForExpression(@NotNull BindingContext context,\n            @NotNull JetExpression expression) {\n        JetType type = context.get(BindingContext.EXPRESSION_TYPE, expression);\n        assert type != null : message(expression);\n        return type;\n    }","id":101395,"modified_method":"@NotNull\n    public static JetType getTypeForExpression(@NotNull BindingContext context,\n            @NotNull JetExpression expression) {\n        return BindingContextUtils.getNotNull(context, BindingContext.EXPRESSION_TYPE, expression);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static DeclarationDescriptor getDescriptorForElement(@NotNull BindingContext context,\n            @NotNull PsiElement element) {\n        DeclarationDescriptor descriptor = context.get(BindingContext.DECLARATION_TO_DESCRIPTOR, element);\n\n        assert descriptor != null : message(element, element + \" doesn't have a descriptor\");\n        return descriptor;\n    }","id":101396,"modified_method":"@NotNull\n    public static DeclarationDescriptor getDescriptorForElement(@NotNull BindingContext context,\n            @NotNull PsiElement element) {\n        return BindingContextUtils.getNotNull(context, BindingContext.DECLARATION_TO_DESCRIPTOR, element);\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static DeclarationDescriptor getDescriptorForReferenceExpression(@NotNull BindingContext context,\n            @NotNull JetReferenceExpression reference) {\n        DeclarationDescriptor referencedDescriptor = getNullableDescriptorForReferenceExpression(context, reference);\n        if (BindingContextUtils.isExpressionWithValidReference(reference, context)) {\n            assert referencedDescriptor != null\n                    : message(reference, \"Reference expression must reference a descriptor for reference \" + reference.getText());\n            return referencedDescriptor;\n        }\n        return null;\n    }","id":101397,"modified_method":"@Nullable\n    public static DeclarationDescriptor getDescriptorForReferenceExpression(@NotNull BindingContext context,\n            @NotNull JetReferenceExpression reference) {\n        if (BindingContextUtils.isExpressionWithValidReference(reference, context)) {\n            return BindingContextUtils.getNotNull(context, BindingContext.REFERENCE_TARGET, reference);\n        }\n        return null;\n    }","commit_id":"84542872b8fd84fe2d27a64145eb8e86bacdc1e9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public IndentInfo setIndentEmptyLines(boolean indentEmptyLines) {\n    myIndentEmptyLines = indentEmptyLines;\n    return this;\n  }","id":101398,"modified_method":"@NotNull\n  IndentInfo setIndentEmptyLines(boolean indentEmptyLines) {\n    myIndentEmptyLines = indentEmptyLines;\n    return this;\n  }","commit_id":"834dfce3fede85202c099eef5b068819368569d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void generateLineWhitespace(@NotNull StringBuffer buffer,\n                                      @NotNull CommonCodeStyleSettings.IndentOptions options,\n                                      int indentSpaces,\n                                      int alignmentSpaces,\n                                      boolean tabsAllowed) {\n     if (options.USE_TAB_CHARACTER && tabsAllowed) {\n      if (options.SMART_TABS) {\n        int tabCount = indentSpaces / options.TAB_SIZE;\n        int leftSpaces = indentSpaces - tabCount * options.TAB_SIZE;\n        if (tabCount > 0) {\n          StringUtil.repeatSymbol(buffer, '\\t', tabCount);\n        }\n        if (leftSpaces + alignmentSpaces > 0) {\n          StringUtil.repeatSymbol(buffer, ' ', leftSpaces + alignmentSpaces);\n        }\n      }\n      else {\n        int size = indentSpaces + alignmentSpaces;\n        while (size > 0) {\n          if (size >= options.TAB_SIZE) {\n            buffer.append('\\t');\n            size -= options.TAB_SIZE;\n          }\n          else {\n            buffer.append(' ');\n            size--;\n          }\n        }\n      }\n    }\n    else {\n      int spaces = indentSpaces + alignmentSpaces;\n      if (spaces > 0) {\n        StringUtil.repeatSymbol(buffer, ' ', spaces);\n      }\n    }\n  }","id":101399,"modified_method":"private static void generateLineWhitespace(@NotNull StringBuffer buffer,\n                                             @NotNull CommonCodeStyleSettings.IndentOptions options,\n                                             int indentSpaces,\n                                             int alignmentSpaces,\n                                             boolean tabsAllowed) {\n    if (options.USE_TAB_CHARACTER && tabsAllowed) {\n      if (options.SMART_TABS) {\n        int tabCount = indentSpaces / options.TAB_SIZE;\n        int leftSpaces = indentSpaces - tabCount * options.TAB_SIZE;\n        StringUtil.repeatSymbol(buffer, '\\t', tabCount);\n        StringUtil.repeatSymbol(buffer, ' ', leftSpaces + alignmentSpaces);\n      }\n      else {\n        int size = indentSpaces + alignmentSpaces;\n        int tabs = size / options.TAB_SIZE;\n        int spaces = size % options.TAB_SIZE;\n        StringUtil.repeatSymbol(buffer, '\\t', tabs);\n        StringUtil.repeatSymbol(buffer, ' ', spaces);\n      }\n    }\n    else {\n       int spaces = indentSpaces + alignmentSpaces;\n       StringUtil.repeatSymbol(buffer, ' ', spaces);\n    }\n  }","commit_id":"834dfce3fede85202c099eef5b068819368569d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @param resourceSpec The simplest, raw string reference handed to us from the operating system as a name for the object\n     * @param resourceName A name for the new node that will contain the resource\n     */\n    // TODO: handle case of a dropped reference to a local HTML file, where we want to use\n    // the file name as the generated node name, and yet ALSO want to set the resourceTitle\n    // via an HTML scan of the file (if one can be found).\n    private LWNode createNewNode(String resourceSpec, String resourceName, java.awt.Point p)\n    {\n        MapResource resource = new MapResource(resourceSpec);\n\n        if (resourceName == null) {\n            resource.setTitleFromContent();\n            if (resource.getTitle() != null)\n                resourceName = resource.getTitle();\n            else\n                resourceName = createResourceTitle(resourceSpec);\n        } else if (resourceSpec.endsWith(\".html\") || resourceSpec.endsWith(\".htm\")) {\n            // attempt to scan a local file\n            resource.setTitleFromContent();\n        }\n\n        LWNode node = NodeTool.createNode(resourceName);\n        node.setResource(resource);\n        if (p != null) {\n            node.setCenterAt(dropToMapLocation(p));\n            viewer.getMap().addNode(node);            //set selection to node?\n        } // else: special case: no node location, so we're creating a child node -- don't add to map\n        return node;\n    }","id":101400,"modified_method":"/**\n     * @param resourceSpec The simplest, raw string reference handed to us from the operating system as a name for the object\n     * @param resourceName A name for the new node that will contain the resource\n     */\n    // TODO: handle case of a dropped reference to a local HTML file, where we want to use\n    // the file name as the generated node name, and yet ALSO want to set the resourceTitle\n    // via an HTML scan of the file (if one can be found).\n    private LWNode createNewNode(String resourceSpec, String resourceName, java.awt.Point p)\n    {\n        MapResource resource = new MapResource(resourceSpec);\n\n        if (resourceName == null) {\n            resource.setTitleFromContent();\n            if (resource.getTitle() != null)\n                resourceName = resource.getTitle();\n            else\n                resourceName = createResourceTitle(resourceSpec);\n        } else if (resourceSpec.endsWith(\".html\") || resourceSpec.endsWith(\".htm\")) {\n            // attempt to scan a local file\n            resource.setTitleFromContent();\n        }\n\n        LWNode node = NodeTool.createNode(resourceName);\n        node.setResource(resource);\n        if (p != null) {\n            if (CenterNodesOnDrop)\n                node.setCenterAt(dropToMapLocation(p));\n            else\n                node.setLocation(dropToMapLocation(p));\n            viewer.getMap().addNode(node);            //set selection to node?\n        } // else: special case: no node location, so we're creating a child node -- don't add to map\n        return node;\n    }","commit_id":"e484b399a706632e3d1da1aa69323dfbbd83fa1d","url":"https://github.com/VUE/VUE"},{"original_method":"private void createNewTextNode(String text, java.awt.Point p)\n    {\n        LWNode node = NodeTool.createTextNode(text);\n        node.setCenterAt(dropToMapLocation(p));\n        viewer.getMap().addNode(node);\n    }","id":101401,"modified_method":"private void createNewTextNode(String text, java.awt.Point p)\n    {\n        LWNode node = NodeTool.createTextNode(text);\n        if (CenterNodesOnDrop)\n            node.setCenterAt(dropToMapLocation(p));\n        else\n            node.setLocation(dropToMapLocation(p));\n        viewer.getMap().addNode(node);\n    }","commit_id":"e484b399a706632e3d1da1aa69323dfbbd83fa1d","url":"https://github.com/VUE/VUE"},{"original_method":"private LWNode createNewNode(Resource resource, java.awt.Point p)\n    {\n        String title;\n        if (resource.getTitle() != null)\n            title = resource.getTitle();\n        else\n            title = resource.getSpec();\n        LWNode node = NodeTool.createNode(title);\n        node.setResource(resource);\n        if (p != null) {\n            node.setCenterAt(dropToMapLocation(p));\n            viewer.getMap().addNode(node);            //set selection to node?\n        } // else: special case: no node location, so we're creating a child node -- don't add to map\n        return node;\n        \n    }","id":101402,"modified_method":"private LWNode createNewNode(Resource resource, java.awt.Point p)\n    {\n        String title;\n        if (resource.getTitle() != null)\n            title = resource.getTitle();\n        else\n            title = resource.getSpec();\n        LWNode node = NodeTool.createNode(title);\n        node.setResource(resource);\n        if (p != null) {\n            if (CenterNodesOnDrop)\n                node.setCenterAt(dropToMapLocation(p));\n            else\n                node.setLocation(dropToMapLocation(p));\n            viewer.getMap().addNode(node);            //set selection to node?\n        } // else: special case: no node location, so we're creating a child node -- don't add to map\n        return node;\n        \n    }","commit_id":"e484b399a706632e3d1da1aa69323dfbbd83fa1d","url":"https://github.com/VUE/VUE"},{"original_method":"private void createNewNode(java.awt.Image image, java.awt.Point p)\n    {\n        // todo: query the NodeTool for current node shape, etc.\n        LWNode node = NodeTool.createNode();\n        node.setCenterAt(dropToMapLocation(p));\n        node.setImage(image);\n        node.setNotes(image.toString());\n        viewer.getMap().addNode(node);\n        //set selection to node?\n        \n        /*\n        String label = \"[image]\";\n        if (image instanceof BufferedImage) {\n            BufferedImage bi = (BufferedImage) image;\n            label = \"[image \"\n                + bi.getWidth() + \"x\"\n                + bi.getHeight()\n                + \" type \" + bi.getType()\n                + \"]\";\n            //System.out.println(\"BufferedImage: \" + bi.getColorModel());\n            // is null System.out.println(\"BufferedImage props: \" + java.util.Arrays.asList(bi.getPropertyNames()));\n            }*/\n    }","id":101403,"modified_method":"private void createNewNode(java.awt.Image image, java.awt.Point p)\n    {\n        // todo: query the NodeTool for current node shape, etc.\n        LWNode node = NodeTool.createNode();\n        if (CenterNodesOnDrop)\n            node.setCenterAt(dropToMapLocation(p));\n        else\n            node.setLocation(dropToMapLocation(p));\n        node.setImage(image);\n        node.setNotes(image.toString());\n        viewer.getMap().addNode(node);\n        //set selection to node?\n        \n        /*\n        String label = \"[image]\";\n        if (image instanceof BufferedImage) {\n            BufferedImage bi = (BufferedImage) image;\n            label = \"[image \"\n                + bi.getWidth() + \"x\"\n                + bi.getHeight()\n                + \" type \" + bi.getType()\n                + \"]\";\n            //System.out.println(\"BufferedImage: \" + bi.getColorModel());\n            // is null System.out.println(\"BufferedImage props: \" + java.util.Arrays.asList(bi.getPropertyNames()));\n            }*/\n    }","commit_id":"e484b399a706632e3d1da1aa69323dfbbd83fa1d","url":"https://github.com/VUE/VUE"},{"original_method":"public void setPageContext(PageContext pageContext) {\n        super.setPageContext(pageContext);\n\n        // init local fields, since tag might be reused\n        flush = false;\n    }","id":101404,"modified_method":"public void setPageContext(PageContext pageContext) {\n        super.setPageContext(pageContext);\n\n        // init local fields, since tag might be reused\n        flush = false;\n        this.var = null;\n        this.scope = PageContext.PAGE_SCOPE;\n    }","commit_id":"ea7f9769b3d0e8c7fcff3a67ef89128bfbcd252d","url":"https://github.com/apache/sling"},{"original_method":"protected void dispatch(RequestDispatcher dispatcher,\n            ServletRequest request, ServletResponse response)\n            throws IOException, ServletException {\n\n        // optionally flush\n        if (flush && !(pageContext.getOut() instanceof BodyContent)) {\n            // might throw an IOException of course\n            pageContext.getOut().flush();\n        }\n\n        dispatcher.include(request, response);\n    }","id":101405,"modified_method":"protected void dispatch(RequestDispatcher dispatcher,\n            ServletRequest request, ServletResponse response)\n            throws IOException, ServletException {\n\n        // optionally flush\n        if (flush && !(pageContext.getOut() instanceof BodyContent)) {\n            // might throw an IOException of course\n            pageContext.getOut().flush();\n        }\n        if (var == null) {\n        \tdispatcher.include(request, response);\n        } else {\n        \tString encoding = response.getCharacterEncoding();\n        \tBufferedServletOutputStream bsops = new BufferedServletOutputStream(encoding);\n        \ttry{\n\t        \tCaptureResponseWrapper wrapper = new CaptureResponseWrapper((HttpServletResponse) response, bsops);\n\t        \tdispatcher.include(request, wrapper);\n\t        \tif (! wrapper.isBinaryResponse()) {\n\t        \t\twrapper.flushBuffer();\n\t            \tpageContext.setAttribute(var, bsops.getBuffer(), scope);\n\t        \t}\n        \t}finally{\n        \t\tIOUtils.closeQuietly(bsops);\n        \t}\n        }\n    }","commit_id":"ea7f9769b3d0e8c7fcff3a67ef89128bfbcd252d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Send a raw syslog message and expect a given event as a result\n     * \n     * @param testPDU The raw syslog message as it would appear on the wire (just the UDP payload)\n     * @param expectedHost The host from which the event should be resolved as originating\n     * @param expectedUEI The expected UEI of the resulting event\n     * @param expectedLogMsg The expected contents of the logmsg for the resulting event \n     * \n     * @throws UnknownHostException \n     * @throws InterruptedException \n     * @throws ExecutionException \n     */\n    private List<Event> doMessageTest(String testPDU, String expectedHost, String expectedUEI, String expectedLogMsg) throws UnknownHostException, InterruptedException, ExecutionException {\n        startSyslogdGracefully();\n        \n        final EventBuilder expectedEventBldr = new EventBuilder(expectedUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(expectedHost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(expectedLogMsg);\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n        final DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, testPDU);\n        final SyslogdConfig config = SyslogdConfigFactory.getInstance();\n        WaterfallExecutor.waterfall(m_executorServices, new SyslogConnection(pkt, config.getForwardingRegexp(), config.getMatchingGroupHost(), config.getMatchingGroupMessage(), config.getUeiList(), config.getHideMessages(), config.getDiscardUei()));\n\n        ea.verifyAnticipated(5000,0,0,0,0);\n        final Event receivedEvent = ea.getAnticipatedEventsRecieved().get(0);\n        assertEquals(\"Log messages do not match\", expectedLogMsg, receivedEvent.getLogmsg().getContent());\n        \n        return ea.getAnticipatedEventsRecieved();\n    }","id":101406,"modified_method":"/**\n     * Send a raw syslog message and expect a given event as a result\n     * \n     * @param testPDU The raw syslog message as it would appear on the wire (just the UDP payload)\n     * @param expectedHost The host from which the event should be resolved as originating\n     * @param expectedUEI The expected UEI of the resulting event\n     * @param expectedLogMsg The expected contents of the logmsg for the resulting event \n     * \n     * @throws UnknownHostException \n     * @throws InterruptedException \n     * @throws ExecutionException \n     */\n    private List<Event> doMessageTest(String testPDU, String expectedHost, String expectedUEI, String expectedLogMsg) throws UnknownHostException, InterruptedException, ExecutionException {\n        startSyslogdGracefully();\n        \n        final EventBuilder expectedEventBldr = new EventBuilder(expectedUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(expectedHost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(expectedLogMsg);\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(\"127.0.0.1\"));\n        final DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, testPDU);\n        final SyslogdConfig config = SyslogdConfigFactory.getInstance();\n        WaterfallExecutor.waterfall(m_executorServices, new SyslogConnection(pkt, config.getForwardingRegexp(), config.getMatchingGroupHost(), config.getMatchingGroupMessage(), config.getUeiList(), config.getHideMessages(), config.getDiscardUei()));\n\n        ea.verifyAnticipated(5000,0,0,0,0);\n        final Event receivedEvent = ea.getAnticipatedEventsRecieved().get(0);\n        assertEquals(\"Log messages do not match\", expectedLogMsg, receivedEvent.getLogmsg().getContent());\n        \n        return ea.getAnticipatedEventsRecieved();\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging(true, \"TRACE\");\n\n        InputStream stream = null;\n        try {\n            final String config = \"<?xml version=\\\"1.0\\\"?> \\n\" + \n            \t\t\"<syslogd-configuration> \\n\" + \n            \t\t\"    <configuration \\n\" + \n            \t\t\"            syslog-port=\\\"10514\\\" \\n\" + \n            \t\t\"            new-suspect-on-message=\\\"false\\\" \\n\" + \n            \t\t\"            forwarding-regexp=\\\"^((.+?) (.*))\\\\n?$\\\" \\n\" + \n            \t\t\"            matching-group-host=\\\"2\\\" \\n\" + \n            \t\t\"            matching-group-message=\\\"3\\\" \\n\" + \n            \t\t\"            discard-uei=\\\"DISCARD-MATCHING-MESSAGES\\\" \\n\" + \n            \t\t\"            /> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"    <!-- Use the following to convert UEI ad-hoc --> \\n\" + \n            \t\t\"    <ueiList> \\n\" + \n            \t\t\"        <ueiMatch> \\n\" + \n            \t\t\"            <match type=\\\"substr\\\" expression=\\\"CRISCO\\\"/> \\n\" + \n            \t\t\"            <uei>CISCO<\/uei> \\n\" + \n            \t\t\"        <\/ueiMatch> \\n\" + \n            \t\t\"        <ueiMatch> \\n\" + \n            \t\t\"            <match type=\\\"regex\\\" expression=\\\".*su:auth.*authentication failure.*\\\"/> \\n\" + \n            \t\t\"            <uei>uei.opennms.org/syslog/pam/su/suFailure<\/uei> \\n\" + \n            \t\t\"        <\/ueiMatch> \\n\" + \n            \t\t\"        <!-- Use the following to discard a syslog message without ever creating an event for it. \\n\" + \n            \t\t\"             If you change the value of \\\"discard-uei\\\" above, you must change the UEI used here to match. --> \\n\" + \n            \t\t\"        <ueiMatch> \\n\" + \n            \t\t\"            <match type=\\\"substr\\\" expression=\\\"JUNK\\\"/> \\n\" + \n            \t\t\"            <uei>DISCARD-MATCHING-MESSAGES<\/uei> \\n\" + \n            \t\t\"        <\/ueiMatch> \\n\" + \n            \t\t\"    <\/ueiList> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"    <!-- Use the following to remove a syslog message from the event-trail --> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"    <hideMessage> \\n\" + \n            \t\t\"        <hideMatch> \\n\" + \n            \t\t\"            <match type=\\\"substr\\\" expression=\\\"SECRET\\\"/> \\n\" + \n            \t\t\"        <\/hideMatch> \\n\" + \n            \t\t\"        <hideMatch> \\n\" + \n            \t\t\"            <match type=\\\"regex\\\" expression=\\\".*(double|triple)secret.*\\\"/> \\n\" + \n            \t\t\"        <\/hideMatch> \\n\" + \n            \t\t\"    <\/hideMessage> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"<\/syslogd-configuration>\\n\";\n            \n            stream = new ByteArrayInputStream(config.getBytes());\n            SyslogdConfigFactory.setInstance(new SyslogdConfigFactory(stream));\n        } finally {\n            if (stream != null) {\n                IOUtils.closeQuietly(stream);\n            }\n        }\n\n        m_syslogd = new Syslogd();\n        m_syslogd.init();\n    }","id":101407,"modified_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging(true, \"TRACE\");\n\n        InputStream stream = null;\n        try {\n            final String config = \"<?xml version=\\\"1.0\\\"?> \\n\" + \n            \t\t\"<syslogd-configuration> \\n\" + \n            \t\t\"    <configuration \\n\" + \n            \t\t\"            syslog-port=\\\"10514\\\" \\n\" + \n            \t\t\"            listen-address=\\\"127.0.0.1\\\" \\n\" +\n            \t\t\"            new-suspect-on-message=\\\"false\\\" \\n\" + \n            \t\t\"            forwarding-regexp=\\\"^((.+?) (.*))\\\\n?$\\\" \\n\" + \n            \t\t\"            matching-group-host=\\\"2\\\" \\n\" + \n            \t\t\"            matching-group-message=\\\"3\\\" \\n\" + \n            \t\t\"            discard-uei=\\\"DISCARD-MATCHING-MESSAGES\\\" \\n\" + \n            \t\t\"            /> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"    <!-- Use the following to convert UEI ad-hoc --> \\n\" + \n            \t\t\"    <ueiList> \\n\" + \n            \t\t\"        <ueiMatch> \\n\" + \n            \t\t\"            <match type=\\\"substr\\\" expression=\\\"CRISCO\\\"/> \\n\" + \n            \t\t\"            <uei>CISCO<\/uei> \\n\" + \n            \t\t\"        <\/ueiMatch> \\n\" + \n            \t\t\"        <ueiMatch> \\n\" + \n            \t\t\"            <match type=\\\"regex\\\" expression=\\\".*su:auth.*authentication failure.*\\\"/> \\n\" + \n            \t\t\"            <uei>uei.opennms.org/syslog/pam/su/suFailure<\/uei> \\n\" + \n            \t\t\"        <\/ueiMatch> \\n\" + \n            \t\t\"        <!-- Use the following to discard a syslog message without ever creating an event for it. \\n\" + \n            \t\t\"             If you change the value of \\\"discard-uei\\\" above, you must change the UEI used here to match. --> \\n\" + \n            \t\t\"        <ueiMatch> \\n\" + \n            \t\t\"            <match type=\\\"substr\\\" expression=\\\"JUNK\\\"/> \\n\" + \n            \t\t\"            <uei>DISCARD-MATCHING-MESSAGES<\/uei> \\n\" + \n            \t\t\"        <\/ueiMatch> \\n\" + \n            \t\t\"    <\/ueiList> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"    <!-- Use the following to remove a syslog message from the event-trail --> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"    <hideMessage> \\n\" + \n            \t\t\"        <hideMatch> \\n\" + \n            \t\t\"            <match type=\\\"substr\\\" expression=\\\"SECRET\\\"/> \\n\" + \n            \t\t\"        <\/hideMatch> \\n\" + \n            \t\t\"        <hideMatch> \\n\" + \n            \t\t\"            <match type=\\\"regex\\\" expression=\\\".*(double|triple)secret.*\\\"/> \\n\" + \n            \t\t\"        <\/hideMatch> \\n\" + \n            \t\t\"    <\/hideMessage> \\n\" + \n            \t\t\"\\n\" + \n            \t\t\"<\/syslogd-configuration>\\n\";\n            \n            stream = new ByteArrayInputStream(config.getBytes());\n            SyslogdConfigFactory.setInstance(new SyslogdConfigFactory(stream));\n        } finally {\n            if (stream != null) {\n                IOUtils.closeQuietly(stream);\n            }\n        }\n\n        m_syslogd = new Syslogd();\n        m_syslogd.init();\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SyslogClient(String ident, int logopt, int facility) throws UnknownHostException {\n        if (ident == null) {\n            this.ident = Thread.currentThread().getName();\n        } else {\n            this.ident = ident;\n        }\n        this.facility = facility;\n\n        address = InetAddressUtils.getLocalHostAddress();\n        \n        try {\n            socket = new DatagramSocket();\n        } catch (SocketException e) {\n            LOG.warn(\"Unable to create datagram socket.\", e);\n        }\n    }","id":101408,"modified_method":"public SyslogClient(final String ident, final int logopt, final int facility) throws UnknownHostException {\n        this(ident, logopt, facility, InetAddressUtils.getLocalHostAddress());\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void syslog(int priority, String msg) {\n        final DatagramPacket packet = getPacket(priority, msg);\n        try {\n            socket.send(packet);\n        }\n        catch (IOException e) {\n            LOG.warn(\"Exception sending data.\", e);\n        }\n    }","id":101409,"modified_method":"public void syslog(int priority, String msg) {\n        System.err.println(\"Sending message: \" + msg);\n        final DatagramPacket packet = getPacket(priority, msg);\n        try {\n            socket.send(packet);\n        }\n        catch (IOException e) {\n            LOG.warn(\"Exception sending data.\", e);\n        }\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @Transactional\n    public void testDefaultSyslogd() throws Exception {\n        startSyslogdGracefully();\n\n        int eventCount = 100;\n        \n        List<Integer> foos = new ArrayList<Integer>();\n\n        for (int i = 0; i < eventCount; i++) {\n            int eventNum = Double.valueOf(Math.random() * 10000).intValue();\n            foos.add(eventNum);\n        }\n\n        m_eventCounter.setAnticipated(eventCount);\n\n        long start = System.currentTimeMillis();\n        String testPduFormat = \"2010-08-19 localhost foo%d: load test %d on tty1\";\n        SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DEBUG);\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo));\n            WaterfallExecutor.waterfall(m_executorService, new SyslogConnection(pkt, MATCH_PATTERN, HOST_GROUP, MESSAGE_GROUP, UEI_LIST, HIDE_MESSAGE, DISCARD_UEI));\n        }\n\n        long mid = System.currentTimeMillis();\n        m_eventCounter.waitForFinish(120000);\n        long end = System.currentTimeMillis();\n        \n        final long total = (end - start);\n        final double eventsPerSecond = (eventCount * 1000.0 / total);\n        System.err.println(String.format(\"total time: %d, wait time: %d, events per second: %8.4f\", total, (end - mid), eventsPerSecond));\n    }","id":101410,"modified_method":"@Test\n    @Transactional\n    public void testDefaultSyslogd() throws Exception {\n        startSyslogdGracefully();\n\n        int eventCount = 100;\n        \n        List<Integer> foos = new ArrayList<Integer>();\n\n        for (int i = 0; i < eventCount; i++) {\n            int eventNum = Double.valueOf(Math.random() * 10000).intValue();\n            foos.add(eventNum);\n        }\n\n        m_eventCounter.setAnticipated(eventCount);\n\n        long start = System.currentTimeMillis();\n        String testPduFormat = \"2010-08-19 localhost foo%d: load test %d on tty1\";\n        SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DEBUG, addr(\"127.0.0.1\"));\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo));\n            WaterfallExecutor.waterfall(m_executorService, new SyslogConnection(pkt, MATCH_PATTERN, HOST_GROUP, MESSAGE_GROUP, UEI_LIST, HIDE_MESSAGE, DISCARD_UEI));\n        }\n\n        long mid = System.currentTimeMillis();\n        m_eventCounter.waitForFinish(120000);\n        long end = System.currentTimeMillis();\n        \n        final long total = (end - start);\n        final double eventsPerSecond = (eventCount * 1000.0 / total);\n        System.err.println(String.format(\"total time: %d, wait time: %d, events per second: %8.4f\", total, (end - mid), eventsPerSecond));\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Send a raw syslog message and expect a given event as a result\n     * \n     * @param testPDU The raw syslog message as it would appear on the wire (just the UDP payload)\n     * @param expectedHost The host from which the event should be resolved as originating\n     * @param expectedUEI The expected UEI of the resulting event\n     * @param expectedLogMsg The expected contents of the logmsg for the resulting event \n     * \n     * @throws UnknownHostException \n     * @throws InterruptedException \n     * @throws ExecutionException \n     */\n    private List<Event> doMessageTest(String testPDU, String expectedHost, String expectedUEI, String expectedLogMsg) throws UnknownHostException, InterruptedException, ExecutionException {\n        startSyslogdGracefully();\n        \n        final EventBuilder expectedEventBldr = new EventBuilder(expectedUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(expectedHost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(expectedLogMsg);\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n        final DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, testPDU);\n        final SyslogdConfig config = SyslogdConfigFactory.getInstance();\n        WaterfallExecutor.waterfall(m_executorService, new SyslogConnection(pkt, config.getForwardingRegexp(), config.getMatchingGroupHost(), config.getMatchingGroupMessage(), config.getUeiList(), config.getHideMessages(), config.getDiscardUei()));\n\n        ea.verifyAnticipated(5000,0,0,0,0);\n        final Event receivedEvent = ea.getAnticipatedEventsRecieved().get(0);\n        assertEquals(\"Log messages do not match\", expectedLogMsg, receivedEvent.getLogmsg().getContent());\n        \n        return ea.getAnticipatedEventsRecieved();\n    }","id":101411,"modified_method":"/**\n     * Send a raw syslog message and expect a given event as a result\n     * \n     * @param testPDU The raw syslog message as it would appear on the wire (just the UDP payload)\n     * @param expectedHost The host from which the event should be resolved as originating\n     * @param expectedUEI The expected UEI of the resulting event\n     * @param expectedLogMsg The expected contents of the logmsg for the resulting event \n     * \n     * @throws UnknownHostException \n     * @throws InterruptedException \n     * @throws ExecutionException \n     */\n    private List<Event> doMessageTest(String testPDU, String expectedHost, String expectedUEI, String expectedLogMsg) throws UnknownHostException, InterruptedException, ExecutionException {\n        startSyslogdGracefully();\n        \n        final EventBuilder expectedEventBldr = new EventBuilder(expectedUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(expectedHost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(expectedLogMsg);\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        final DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, testPDU);\n        final SyslogdConfig config = SyslogdConfigFactory.getInstance();\n        WaterfallExecutor.waterfall(m_executorService, new SyslogConnection(pkt, config.getForwardingRegexp(), config.getMatchingGroupHost(), config.getMatchingGroupMessage(), config.getUeiList(), config.getHideMessages(), config.getDiscardUei()));\n\n        ea.verifyAnticipated(5000,0,0,0,0);\n        final Event receivedEvent = ea.getAnticipatedEventsRecieved().get(0);\n        assertEquals(\"Log messages do not match\", expectedLogMsg, receivedEvent.getLogmsg().getContent());\n        \n        return ea.getAnticipatedEventsRecieved();\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRegexSeverityMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beer - Not just for dinner anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/severityOnly\";\n        final String testMsg = \"beer - Not just for dinner anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n            s.syslog(SyslogClient.LOG_CRIT, testPDU);\n        } catch (UnknownHostException uhe) {\n            //Failures are for weenies\n        }\n\n        ea.verifyAnticipated(10000, 0, 0, 0, 0);\n    }","id":101412,"modified_method":"@Test\n    public void testRegexSeverityMatch() throws Exception {\n        startSyslogdGracefully();\n\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beer - Not just for dinner anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/severityOnly\";\n        final String testMsg = \"beer - Not just for dinner anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_CRIT, testPDU);\n\n        ea.verifyAnticipated(10000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRegexFacilityMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beer - Not just for lunch anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/facilityOnly\";\n        final String testMsg = \"beer - Not just for lunch anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"service\", \"local0\");\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 10, SyslogClient.LOG_LOCAL0);\n            s.syslog(SyslogClient.LOG_DEBUG, testPDU);\n        } catch (UnknownHostException uhe) {\n            //Failures are for weenies\n        }\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","id":101413,"modified_method":"@Test\n    public void testRegexFacilityMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beer - Not just for lunch anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/facilityOnly\";\n        final String testMsg = \"beer - Not just for lunch anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"service\", \"local0\");\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient s = new SyslogClient(null, 10, SyslogClient.LOG_LOCAL0, addr(localhost));\n        s.syslog(SyslogClient.LOG_DEBUG, testPDU);\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testMyPatternsSyslogNG() {\n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n            s.syslog(SyslogClient.LOG_DEBUG, \"2007-01-01 host.domain.com A SyslogNG style message\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n    }","id":101414,"modified_method":"@Test\n    public void testMyPatternsSyslogNG() throws UnknownHostException {\n        final SyslogClient s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_DEBUG, \"2007-01-01 host.domain.com A SyslogNG style message\");\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRegexFacilitySeverityMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beer - Not just for lunch anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/facilitySeverity\";\n        final String testMsg = \"beer - Not just for lunch anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"service\", \"local1\");\n        expectedEventBldr.addParam(\"severity\", \"Warning\");\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 10, SyslogClient.LOG_LOCAL1);\n            s.syslog(SyslogClient.LOG_WARNING, testPDU);\n        } catch (UnknownHostException uhe) {\n            //Failures are for weenies\n        }\n    \n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","id":101415,"modified_method":"@Test\n    public void testRegexFacilitySeverityMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beer - Not just for lunch anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/facilitySeverity\";\n        final String testMsg = \"beer - Not just for lunch anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"service\", \"local1\");\n        expectedEventBldr.addParam(\"severity\", \"Warning\");\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient s = new SyslogClient(null, 10, SyslogClient.LOG_LOCAL1, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_WARNING, testPDU);\n    \n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging();\n\n        InputStream stream = null;\n        try {\n            stream = ConfigurationTestUtils.getInputStreamForResource(this, \"/etc/syslogd-configuration.xml\");\n            SyslogdConfigFactory.setInstance(new SyslogdConfigFactory(stream));\n        } finally {\n            if (stream != null) {\n                IOUtils.closeQuietly(stream);\n            }\n        }\n\n        m_syslogd = new Syslogd();\n        m_syslogd.init();\n\n        // Verify that the test syslogd-configuration.xml file was loaded\n        boolean foundBeer = false;\n        boolean foundMalt = false;\n        assertEquals(10514, SyslogdConfigFactory.getInstance().getSyslogPort());\n        for (final UeiMatch match : SyslogdConfigFactory.getInstance().getUeiList().getUeiMatch()) {\n            if (match.getProcessMatch() != null) {\n                if (!foundBeer && \"beerd\".equals(match.getProcessMatch().getExpression())) {\n                    foundBeer = true;\n                } else if (!foundMalt && \"maltd\".equals(match.getProcessMatch().getExpression())) {\n                    foundMalt = true;\n                }\n            }\n        }\n        assertTrue(foundBeer);\n        assertTrue(foundMalt);\n    }","id":101416,"modified_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging();\n        MockLogAppender.resetEvents();\n\n        InputStream stream = null;\n        try {\n            stream = ConfigurationTestUtils.getInputStreamForResource(this, \"/etc/syslogd-configuration.xml\");\n            SyslogdConfigFactory.setInstance(new SyslogdConfigFactory(stream));\n        } finally {\n            if (stream != null) {\n                IOUtils.closeQuietly(stream);\n            }\n        }\n\n        m_syslogd = new Syslogd();\n        m_syslogd.init();\n\n        // Verify that the test syslogd-configuration.xml file was loaded\n        boolean foundBeer = false;\n        boolean foundMalt = false;\n        assertEquals(10514, SyslogdConfigFactory.getInstance().getSyslogPort());\n        for (final UeiMatch match : SyslogdConfigFactory.getInstance().getUeiList().getUeiMatch()) {\n            if (match.getProcessMatch() != null) {\n                if (!foundBeer && \"beerd\".equals(match.getProcessMatch().getExpression())) {\n                    foundBeer = true;\n                } else if (!foundMalt && \"maltd\".equals(match.getProcessMatch().getExpression())) {\n                    foundMalt = true;\n                }\n            }\n        }\n        assertTrue(foundBeer);\n        assertTrue(foundMalt);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRegexProcessMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beerd: beer - Not just for breakfast anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/processOnly\";\n        final String testMsg = \"beer - Not just for breakfast anymore\";\n\n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"process\", \"beerd\");\n\n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(\"beerd\", 10, SyslogClient.LOG_DAEMON);\n            s.syslog(SyslogClient.LOG_DEBUG, testPDU);\n        } catch (UnknownHostException uhe) {\n            //Failures are for weenies\n        }\n    \n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","id":101417,"modified_method":"@Test\n    public void testRegexProcessMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 beerd: beer - Not just for breakfast anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/processOnly\";\n        final String testMsg = \"beer - Not just for breakfast anymore\";\n\n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"process\", \"beerd\");\n\n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient s = new SyslogClient(\"beerd\", 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_DEBUG, testPDU);\n    \n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSubstrDiscard() throws Exception {\n        startSyslogdGracefully();\n        final String testPDU = \"2007-01-01 127.0.0.1 A JUNK message\";\n        \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        \n        SyslogClient sc = null;\n        sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n        sc.syslog(SyslogClient.LOG_DEBUG, testPDU);\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","id":101418,"modified_method":"@Test\n    public void testSubstrDiscard() throws Exception {\n        startSyslogdGracefully();\n        final String testPDU = \"2007-01-01 127.0.0.1 A JUNK message\";\n        \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        \n        final SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        sc.syslog(SyslogClient.LOG_DEBUG, testPDU);\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testMessaging() {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 0, SyslogClient.LOG_DAEMON);\n            s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n    }","id":101419,"modified_method":"@Test\n    public void testMessaging() throws UnknownHostException {\n        // More of an integrations test\n        // relies on you reading some of the logging....\n\n        final SyslogClient s = new SyslogClient(null, 0, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_ERR, \"Hello.\");\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRegexDiscard() throws Exception {\n        startSyslogdGracefully();\n        final String testPDU = \"2007-01-01 127.0.0.1 A TrAsH message\";\n        \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        \n        SyslogClient sc = null;\n        sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n        sc.syslog(SyslogClient.LOG_DEBUG, testPDU);\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","id":101420,"modified_method":"@Test\n    public void testRegexDiscard() throws Exception {\n        startSyslogdGracefully();\n        final String testPDU = \"2007-01-01 127.0.0.1 A TrAsH message\";\n        \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        \n        final SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        sc.syslog(SyslogClient.LOG_DEBUG, testPDU);\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRegexFacilitySeverityProcessMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 maltd: beer - Not just for lunch anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/facilitySeverityProcess\";\n        final String testMsg = \"beer - Not just for lunch anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"process\", \"maltd\");\n        expectedEventBldr.addParam(\"service\", \"local1\");\n        expectedEventBldr.addParam(\"severity\", \"Warning\");\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(\"maltd\", 10, SyslogClient.LOG_LOCAL1);\n            s.syslog(SyslogClient.LOG_WARNING, testPDU);\n        } catch (UnknownHostException uhe) {\n            //Failures are for weenies\n        }\n    \n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","id":101421,"modified_method":"@Test\n    public void testRegexFacilitySeverityProcessMatch() throws Exception {\n        startSyslogdGracefully();\n        MockLogAppender.setupLogging(true, \"TRACE\");\n        String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 maltd: beer - Not just for lunch anymore\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/nonMessageMatch/facilitySeverityProcess\";\n        final String testMsg = \"beer - Not just for lunch anymore\";\n    \n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"process\", \"maltd\");\n        expectedEventBldr.addParam(\"service\", \"local1\");\n        expectedEventBldr.addParam(\"severity\", \"Warning\");\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient s = new SyslogClient(\"maltd\", 10, SyslogClient.LOG_LOCAL1, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_WARNING, testPDU);\n    \n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testIPPatternsSyslogNG() {\n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n            s.syslog(SyslogClient.LOG_DEBUG, \"2007-01-01 127.0.0.1 A SyslogNG style message\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n    }","id":101422,"modified_method":"@Test\n    public void testIPPatternsSyslogNG() throws UnknownHostException {\n        final SyslogClient s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_DEBUG, \"2007-01-01 127.0.0.1 A SyslogNG style message\");\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testResolvePatternsSyslogNG() {\n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n            s.syslog(SyslogClient.LOG_DEBUG, \"2007-01-01 www.opennms.org A SyslogNG style message\");\n        } catch (UnknownHostException e) {\n            //Failures are for weenies\n        }\n    }","id":101423,"modified_method":"@Test\n    public void testResolvePatternsSyslogNG() throws UnknownHostException {\n        final SyslogClient s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_DEBUG, \"2007-01-01 www.opennms.org A SyslogNG style message\");\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testRegexUEIWithOnlyUserSpecifiedParameterAssignments() throws InterruptedException {\n        startSyslogdGracefully();\n        \n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 tea: Secretly replaced cmiskell's tea with 666 ferrets\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/regexParameterAssignmentTest/userSpecifiedOnly\";\n        final String testMsg = \"Secretly replaced cmiskell's tea with 666 ferrets\";\n        final String[] testGroups = { \"cmiskell's\", \"666\", \"ferrets\" };\n\n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"whoseBeverage\", testGroups[0]);\n        expectedEventBldr.addParam(\"count\", testGroups[1]);\n        expectedEventBldr.addParam(\"replacementItem\", testGroups[2]);\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        SyslogClient s = null;\n        try {\n            s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON);\n            s.syslog(SyslogClient.LOG_DEBUG, testPDU);\n        } catch (UnknownHostException uhe) {\n            //Failures are for weenies\n        }\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","id":101424,"modified_method":"@Test\n    public void testRegexUEIWithOnlyUserSpecifiedParameterAssignments() throws InterruptedException, UnknownHostException {\n        startSyslogdGracefully();\n        \n        final String localhost = m_localhost;\n        final String testPDU = \"2007-01-01 127.0.0.1 tea: Secretly replaced cmiskell's tea with 666 ferrets\";\n        final String testUEI = \"uei.opennms.org/tests/syslogd/regexParameterAssignmentTest/userSpecifiedOnly\";\n        final String testMsg = \"Secretly replaced cmiskell's tea with 666 ferrets\";\n        final String[] testGroups = { \"cmiskell's\", \"666\", \"ferrets\" };\n\n        final EventBuilder expectedEventBldr = new EventBuilder(testUEI, \"syslogd\");\n        expectedEventBldr.setInterface(addr(localhost));\n        expectedEventBldr.setLogDest(\"logndisplay\");\n        expectedEventBldr.setLogMessage(testMsg);\n        \n        expectedEventBldr.addParam(\"whoseBeverage\", testGroups[0]);\n        expectedEventBldr.addParam(\"count\", testGroups[1]);\n        expectedEventBldr.addParam(\"replacementItem\", testGroups[2]);\n    \n        final EventAnticipator ea = new EventAnticipator();\n        m_eventIpcManager.addEventListener(ea);\n        ea.anticipateEvent(expectedEventBldr.getEvent());\n        \n        final SyslogClient s = new SyslogClient(null, 10, SyslogClient.LOG_DAEMON, addr(m_localhost));\n        s.syslog(SyslogClient.LOG_DEBUG, testPDU);\n\n        ea.verifyAnticipated(5000, 0, 0, 0, 0);\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @Transactional\n    public void testDefaultSyslogd() throws Exception {\n        startSyslogdGracefully();\n\n        final int eventCount = 100;\n        \n        List<Integer> foos = new ArrayList<Integer>();\n\n        for (int i = 0; i < eventCount; i++) {\n            int eventNum = Double.valueOf(Math.random() * 10000).intValue();\n            foos.add(eventNum);\n        }\n\n        m_eventCounter.setAnticipated(eventCount);\n\n        String testPduFormat = \"2010-08-19 localhost foo%d: load test %d on tty1\";\n        SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_USER);\n\n        // Test by directly invoking the SyslogConnection task\n        System.err.println(\"Starting to send packets\");\n        final long start = System.currentTimeMillis();\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo));\n            WaterfallExecutor.waterfall(m_executorService, new SyslogConnection(pkt, MATCH_PATTERN, HOST_GROUP, MESSAGE_GROUP, UEI_LIST, HIDE_MESSAGE, DISCARD_UEI));\n        }\n\n        /*\n        // Test by sending over a java.net socket\n        final DatagramSocket socket = new DatagramSocket();\n        System.err.println(\"Starting to send packets\");\n        final long start = System.currentTimeMillis();\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo));\n            socket.send(pkt);\n        }\n        socket.close();\n        */\n\n        /*\n        // Test by sending over an NIO channel\n        SocketAddress address = new InetSocketAddress(InetAddressUtils.getLocalHostAddress(), SyslogClient.PORT);\n        final DatagramChannel channel = DatagramChannel.open();\n        final ByteBuffer buffer = ByteBuffer.allocate(0xffff);\n        buffer.clear();\n        System.err.println(\"Starting to send packets\");\n        final long start = System.currentTimeMillis();\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            buffer.put(SyslogClient.getPacketPayload(SyslogClient.LOG_USER, null, SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo)));\n            buffer.flip();\n            channel.send(buffer, address);\n            buffer.clear();\n        }\n        channel.close();\n        */\n\n        System.err.println(String.format(\"Sent %d packets in %d milliseconds\", eventCount, System.currentTimeMillis() - start));\n\n        long mid = System.currentTimeMillis();\n        m_eventCounter.waitForFinish(120000);\n        long end = System.currentTimeMillis();\n        \n        final long total = (end - start);\n        final double eventsPerSecond = (eventCount * 1000.0 / total);\n        System.err.println(String.format(\"total time: %d, wait time: %d, events per second: %8.4f\", total, (end - mid), eventsPerSecond));\n    }","id":101425,"modified_method":"@Test\n    @Transactional\n    public void testDefaultSyslogd() throws Exception {\n        startSyslogdGracefully();\n\n        final int eventCount = 100;\n        \n        List<Integer> foos = new ArrayList<Integer>();\n\n        for (int i = 0; i < eventCount; i++) {\n            int eventNum = Double.valueOf(Math.random() * 10000).intValue();\n            foos.add(eventNum);\n        }\n\n        m_eventCounter.setAnticipated(eventCount);\n\n        String testPduFormat = \"2010-08-19 localhost foo%d: load test %d on tty1\";\n        SyslogClient sc = new SyslogClient(null, 10, SyslogClient.LOG_USER, addr(\"127.0.0.1\"));\n\n        // Test by directly invoking the SyslogConnection task\n        System.err.println(\"Starting to send packets\");\n        final long start = System.currentTimeMillis();\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo));\n            WaterfallExecutor.waterfall(m_executorService, new SyslogConnection(pkt, MATCH_PATTERN, HOST_GROUP, MESSAGE_GROUP, UEI_LIST, HIDE_MESSAGE, DISCARD_UEI));\n        }\n\n        /*\n        // Test by sending over a java.net socket\n        final DatagramSocket socket = new DatagramSocket();\n        System.err.println(\"Starting to send packets\");\n        final long start = System.currentTimeMillis();\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            DatagramPacket pkt = sc.getPacket(SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo));\n            socket.send(pkt);\n        }\n        socket.close();\n        */\n\n        /*\n        // Test by sending over an NIO channel\n        SocketAddress address = new InetSocketAddress(InetAddressUtils.getLocalHostAddress(), SyslogClient.PORT);\n        final DatagramChannel channel = DatagramChannel.open();\n        final ByteBuffer buffer = ByteBuffer.allocate(0xffff);\n        buffer.clear();\n        System.err.println(\"Starting to send packets\");\n        final long start = System.currentTimeMillis();\n        for (int i = 0; i < eventCount; i++) {\n            int foo = foos.get(i);\n            buffer.put(SyslogClient.getPacketPayload(SyslogClient.LOG_USER, null, SyslogClient.LOG_DEBUG, String.format(testPduFormat, foo, foo)));\n            buffer.flip();\n            channel.send(buffer, address);\n            buffer.clear();\n        }\n        channel.close();\n        */\n\n        System.err.println(String.format(\"Sent %d packets in %d milliseconds\", eventCount, System.currentTimeMillis() - start));\n\n        long mid = System.currentTimeMillis();\n        m_eventCounter.waitForFinish(120000);\n        long end = System.currentTimeMillis();\n        \n        final long total = (end - start);\n        final double eventsPerSecond = (eventCount * 1000.0 / total);\n        System.err.println(String.format(\"total time: %d, wait time: %d, events per second: %8.4f\", total, (end - mid), eventsPerSecond));\n    }","commit_id":"9ad53bd74e3dd71e28cc6fb3f6c713dc7b3f4f37","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected String format(\n\t\t\tFile file, String fileName, String absolutePath, String content)\n\t\tthrows Exception {\n\n\t\tString newContent = doFormat(file, fileName, absolutePath, content);\n\n\t\tnewContent = StringUtil.replace(\n\t\t\tnewContent, StringPool.RETURN, StringPool.BLANK);\n\n\t\tif (content.equals(newContent)) {\n\t\t\treturn content;\n\t\t}\n\n\t\treturn format(file, fileName, absolutePath, newContent);\n\t}","id":101426,"modified_method":"protected String format(\n\t\t\tFile file, String fileName, String absolutePath, String content)\n\t\tthrows Exception {\n\n\t\t_errorMessagesMap.remove(fileName);\n\n\t\tString newContent = doFormat(file, fileName, absolutePath, content);\n\n\t\tnewContent = StringUtil.replace(\n\t\t\tnewContent, StringPool.RETURN, StringPool.BLANK);\n\n\t\tif (content.equals(newContent)) {\n\t\t\treturn content;\n\t\t}\n\n\t\treturn format(file, fileName, absolutePath, newContent);\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String format(String fileName) throws Exception {\n\t\tFile file = new File(BASEDIR + fileName);\n\n\t\tfileName = StringUtil.replace(\n\t\t\tfileName, StringPool.BACK_SLASH, StringPool.SLASH);\n\n\t\tString absolutePath = getAbsolutePath(file);\n\n\t\tString content = fileUtil.read(file);\n\n\t\tString newContent = format(file, fileName, absolutePath, content);\n\n\t\tif (!content.equals(newContent)) {\n\t\t\tprocessFormattedFile(file, fileName, content, newContent);\n\t\t}\n\n\t\treturn newContent;\n\t}","id":101427,"modified_method":"protected String format(String fileName) throws Exception {\n\t\tFile file = new File(BASEDIR + fileName);\n\n\t\tfileName = StringUtil.replace(\n\t\t\tfileName, StringPool.BACK_SLASH, StringPool.SLASH);\n\n\t\tString absolutePath = getAbsolutePath(file);\n\n\t\tString content = fileUtil.read(file);\n\n\t\tString newContent = format(file, fileName, absolutePath, content);\n\n\t\tprocessFormattedFile(file, fileName, content, newContent);\n\n\t\treturn newContent;\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<String> getErrorMessages() {\n\t\treturn _errorMessages;\n\t}","id":101428,"modified_method":"@Override\n\tpublic List<String> getErrorMessages() {\n\t\tList<String> errorMessages = new ArrayList<String>();\n\n\t\tfor (Map.Entry<String, List<String>> entry :\n\t\t\t\t_errorMessagesMap.entrySet()) {\n\n\t\t\terrorMessages.addAll(entry.getValue());\n\t\t}\n\n\t\treturn errorMessages;\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _init(\n\t\t\tboolean useProperties, boolean printErrors, boolean autoFix,\n\t\t\tString mainReleaseVersion)\n\t\tthrows Exception {\n\n\t\t_errorMessages = new ArrayList<String>();\n\n\t\tsourceFormatterHelper = new SourceFormatterHelper(useProperties);\n\n\t\tsourceFormatterHelper.init();\n\n\t\t_autoFix = autoFix;\n\n\t\tBaseSourceProcessor.mainReleaseVersion = mainReleaseVersion;\n\n\t\tportalSource = _isPortalSource();\n\n\t\t_properties = _getProperties();\n\n\t\t_excludes = _getExcludes();\n\n\t\t_printErrors = printErrors;\n\t}","id":101429,"modified_method":"private void _init(\n\t\t\tboolean useProperties, boolean printErrors, boolean autoFix,\n\t\t\tString mainReleaseVersion)\n\t\tthrows Exception {\n\n\t\t_errorMessagesMap = new HashMap<String, List<String>>();\n\n\t\tsourceFormatterHelper = new SourceFormatterHelper(useProperties);\n\n\t\tsourceFormatterHelper.init();\n\n\t\t_autoFix = autoFix;\n\n\t\tBaseSourceProcessor.mainReleaseVersion = mainReleaseVersion;\n\n\t\tportalSource = _isPortalSource();\n\n\t\t_properties = _getProperties();\n\n\t\t_excludes = _getExcludes();\n\n\t\t_printErrors = printErrors;\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processFormattedFile(\n\t\t\tFile file, String fileName, String content, String newContent)\n\t\tthrows IOException {\n\n\t\tif (_autoFix) {\n\t\t\tfileUtil.write(file, newContent);\n\t\t}\n\t\telse if (_firstSourceMismatchException == null) {\n\t\t\t_firstSourceMismatchException =\n\t\t\t\tnew SourceMismatchException(fileName, content, newContent);\n\t\t}\n\n\t\tif (_printErrors) {\n\t\t\tsourceFormatterHelper.printError(fileName, file);\n\t\t}\n\t}","id":101430,"modified_method":"protected void processFormattedFile(\n\t\t\tFile file, String fileName, String content, String newContent)\n\t\tthrows IOException {\n\n\t\tif (_printErrors) {\n\t\t\tList<String> errorMessages = _errorMessagesMap.get(fileName);\n\n\t\t\tif (errorMessages != null) {\n\t\t\t\tfor (String errorMessage : errorMessages) {\n\t\t\t\t\tsourceFormatterHelper.printError(fileName, errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (content.equals(newContent)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_autoFix) {\n\t\t\tfileUtil.write(file, newContent);\n\t\t}\n\t\telse if (_firstSourceMismatchException == null) {\n\t\t\t_firstSourceMismatchException =\n\t\t\t\tnew SourceMismatchException(fileName, content, newContent);\n\t\t}\n\n\t\tif (_printErrors) {\n\t\t\tsourceFormatterHelper.printError(fileName, file);\n\t\t}\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void processErrorMessage(String fileName, String message) {\n\t\t_errorMessages.add(message);\n\n\t\tif (_printErrors) {\n\t\t\tsourceFormatterHelper.printError(fileName, message);\n\t\t}\n\t}","id":101431,"modified_method":"protected static void processErrorMessage(String fileName, String message) {\n\t\tList<String> errorMessages = _errorMessagesMap.get(fileName);\n\n\t\tif (errorMessages == null) {\n\t\t\terrorMessages = new ArrayList<String>();\n\t\t}\n\n\t\terrorMessages.add(message);\n\n\t\t_errorMessagesMap.put(fileName, errorMessages);\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void format() throws Exception {\n\t\t_unusedVariablesExclusions = getExclusions(\n\t\t\t\"jsp.unused.variables.excludes\");\n\n\t\tString[] excludes = new String[] {\"**\\\\null.jsp\", \"**\\\\tools\\\\**\"};\n\t\tString[] includes = new String[] {\n\t\t\t\"**\\\\*.jsp\", \"**\\\\*.jspf\", \"**\\\\*.vm\"\n\t\t};\n\n\t\tList<String> fileNames = getFileNames(excludes, includes);\n\n\t\tPattern pattern = Pattern.compile(\n\t\t\t\"\\\\s*@\\\\s*include\\\\s*file=['\\\"](.*)['\\\"]\");\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tFile file = new File(BASEDIR + fileName);\n\n\t\t\tfileName = StringUtil.replace(\n\t\t\t\tfileName, StringPool.BACK_SLASH, StringPool.SLASH);\n\n\t\t\tString absolutePath = getAbsolutePath(file);\n\n\t\t\tString content = fileUtil.read(file);\n\n\t\t\tMatcher matcher = pattern.matcher(content);\n\n\t\t\tString newContent = content;\n\n\t\t\twhile (matcher.find()) {\n\t\t\t\tnewContent = StringUtil.replaceFirst(\n\t\t\t\t\tnewContent, matcher.group(),\n\t\t\t\t\t\"@ include file=\\\"\" + matcher.group(1) + \"\\\"\",\n\t\t\t\t\tmatcher.start());\n\t\t\t}\n\n\t\t\tif (!content.equals(newContent)) {\n\t\t\t\tprocessFormattedFile(file, fileName, content, newContent);\n\t\t\t}\n\n\t\t\tif (portalSource &&\n\t\t\t\tmainReleaseVersion.equals(MAIN_RELEASE_LATEST_VERSION) &&\n\t\t\t\tfileName.endsWith(\"/init.jsp\") &&\n\t\t\t\t!absolutePath.contains(\"/modules/\") &&\n\t\t\t\t!fileName.endsWith(\"/common/init.jsp\")) {\n\n\t\t\t\taddImportCounts(content);\n\t\t\t}\n\n\t\t\t_jspContents.put(fileName, newContent);\n\t\t}\n\n\t\tif (portalSource &&\n\t\t\t!mainReleaseVersion.equals(MAIN_RELEASE_VERSION_6_1_0)) {\n\n\t\t\tmoveFrequentlyUsedImportsToCommonInit(4);\n\t\t}\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tformat(fileName);\n\t\t}\n\t}","id":101432,"modified_method":"@Override\n\tprotected void format() throws Exception {\n\t\t_unusedVariablesExclusions = getExclusions(\n\t\t\t\"jsp.unused.variables.excludes\");\n\n\t\tString[] excludes = new String[] {\"**\\\\null.jsp\", \"**\\\\tools\\\\**\"};\n\t\tString[] includes = new String[] {\n\t\t\t\"**\\\\*.jsp\", \"**\\\\*.jspf\", \"**\\\\*.vm\"\n\t\t};\n\n\t\tList<String> fileNames = getFileNames(excludes, includes);\n\n\t\tPattern pattern = Pattern.compile(\n\t\t\t\"\\\\s*@\\\\s*include\\\\s*file=['\\\"](.*)['\\\"]\");\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tFile file = new File(BASEDIR + fileName);\n\n\t\t\tfileName = StringUtil.replace(\n\t\t\t\tfileName, StringPool.BACK_SLASH, StringPool.SLASH);\n\n\t\t\tString absolutePath = getAbsolutePath(file);\n\n\t\t\tString content = fileUtil.read(file);\n\n\t\t\tMatcher matcher = pattern.matcher(content);\n\n\t\t\tString newContent = content;\n\n\t\t\twhile (matcher.find()) {\n\t\t\t\tnewContent = StringUtil.replaceFirst(\n\t\t\t\t\tnewContent, matcher.group(),\n\t\t\t\t\t\"@ include file=\\\"\" + matcher.group(1) + \"\\\"\",\n\t\t\t\t\tmatcher.start());\n\t\t\t}\n\n\t\t\tprocessFormattedFile(file, fileName, content, newContent);\n\n\t\t\tif (portalSource &&\n\t\t\t\tmainReleaseVersion.equals(MAIN_RELEASE_LATEST_VERSION) &&\n\t\t\t\tfileName.endsWith(\"/init.jsp\") &&\n\t\t\t\t!absolutePath.contains(\"/modules/\") &&\n\t\t\t\t!fileName.endsWith(\"/common/init.jsp\")) {\n\n\t\t\t\taddImportCounts(content);\n\t\t\t}\n\n\t\t\t_jspContents.put(fileName, newContent);\n\t\t}\n\n\t\tif (portalSource &&\n\t\t\t!mainReleaseVersion.equals(MAIN_RELEASE_VERSION_6_1_0)) {\n\n\t\t\tmoveFrequentlyUsedImportsToCommonInit(4);\n\t\t}\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tformat(fileName);\n\t\t}\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String formatPortalPortalProperties() throws Exception {\n\t\tif (!portalSource) {\n\t\t\treturn ContentUtil.get(\"portal.properties\");\n\t\t}\n\n\t\tString fileName = \"portal-impl/src/portal.properties\";\n\n\t\tFile file = getFile(fileName, 4);\n\n\t\tString content = fileUtil.read(file);\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tUnsyncBufferedReader unsyncBufferedReader = new UnsyncBufferedReader(\n\t\t\tnew UnsyncStringReader(content));\n\n\t\tString line = null;\n\n\t\twhile ((line = unsyncBufferedReader.readLine()) != null) {\n\t\t\tline = trimLine(line, true);\n\n\t\t\tif (line.startsWith(StringPool.TAB)) {\n\t\t\t\tline = line.replaceFirst(\n\t\t\t\t\tStringPool.TAB, StringPool.FOUR_SPACES);\n\t\t\t}\n\n\t\t\tsb.append(line);\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\n\t\tunsyncBufferedReader.close();\n\n\t\tString newContent = sb.toString();\n\n\t\tif (newContent.endsWith(\"\\n\")) {\n\t\t\tnewContent = newContent.substring(0, newContent.length() - 1);\n\t\t}\n\n\t\tif (!content.equals(newContent)) {\n\t\t\tprocessFormattedFile(file, fileName, content, newContent);\n\t\t}\n\n\t\treturn newContent;\n\t}","id":101433,"modified_method":"protected String formatPortalPortalProperties() throws Exception {\n\t\tif (!portalSource) {\n\t\t\treturn ContentUtil.get(\"portal.properties\");\n\t\t}\n\n\t\tString fileName = \"portal-impl/src/portal.properties\";\n\n\t\tFile file = getFile(fileName, 4);\n\n\t\tString content = fileUtil.read(file);\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tUnsyncBufferedReader unsyncBufferedReader = new UnsyncBufferedReader(\n\t\t\tnew UnsyncStringReader(content));\n\n\t\tString line = null;\n\n\t\twhile ((line = unsyncBufferedReader.readLine()) != null) {\n\t\t\tline = trimLine(line, true);\n\n\t\t\tif (line.startsWith(StringPool.TAB)) {\n\t\t\t\tline = line.replaceFirst(\n\t\t\t\t\tStringPool.TAB, StringPool.FOUR_SPACES);\n\t\t\t}\n\n\t\t\tsb.append(line);\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\n\t\tunsyncBufferedReader.close();\n\n\t\tString newContent = sb.toString();\n\n\t\tif (newContent.endsWith(\"\\n\")) {\n\t\t\tnewContent = newContent.substring(0, newContent.length() - 1);\n\t\t}\n\n\t\tprocessFormattedFile(file, fileName, content, newContent);\n\n\t\treturn newContent;\n\t}","commit_id":"783b9fe950c831ef2bad7f61d8fdf8c93c7698e6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void formatDuplicateLanguageKeys() throws Exception {\n\t\tif (_duplicateLanguageKeyLinesMap.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tSet<String> allDuplicateLines = new HashSet<>();\n\n\t\tfor (Map.Entry<String, Set<String>> entry :\n\t\t\t\t_duplicateLanguageKeyLinesMap.entrySet()) {\n\n\t\t\tSet<String> duplicateLines = entry.getValue();\n\n\t\t\tremoveDuplicateKeys(entry.getKey(), duplicateLines);\n\n\t\t\tallDuplicateLines.addAll(duplicateLines);\n\t\t}\n\n\t\tFile coreLanguagePropertiesFile = new File(\n\t\t\tgetFile(\"portal-impl\", PORTAL_MAX_DIR_LEVEL),\n\t\t\t\"src/content/Language.properties\");\n\n\t\tString coreLanguagePropertiesContent = FileUtil.read(\n\t\t\tcoreLanguagePropertiesFile);\n\n\t\tString newCoreLanguagePropertiesContent = coreLanguagePropertiesContent;\n\n\t\tString[][] categoryPrefixAndNameArray = getCategoryPrefixAndNameArray();\n\n\t\tfor (String line : allDuplicateLines) {\n\t\t\tString categoryName = getCategoryName(\n\t\t\t\tline, categoryPrefixAndNameArray);\n\n\t\t\tint pos = newCoreLanguagePropertiesContent.indexOf(\n\t\t\t\t\"## \" + categoryName);\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tpos = newCoreLanguagePropertiesContent.indexOf(\"\\n\", pos + 1);\n\t\t\t}\n\n\t\t\tif (!newCoreLanguagePropertiesContent.contains(\n\t\t\t\t\t\"\\n\" + line + \"\\n\")) {\n\n\t\t\t\tnewCoreLanguagePropertiesContent = StringUtil.insert(\n\t\t\t\t\tnewCoreLanguagePropertiesContent, line + \"\\n\", pos + 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!coreLanguagePropertiesContent.equals(\n\t\t\t\tnewCoreLanguagePropertiesContent)) {\n\n\t\t\tprocessFormattedFile(\n\t\t\t\tcoreLanguagePropertiesFile,\n\t\t\t\t\"portal-impl/src/content/Language.properties\",\n\t\t\t\tcoreLanguagePropertiesContent,\n\t\t\t\tnewCoreLanguagePropertiesContent);\n\t\t}\n\t}","id":101434,"modified_method":"protected void formatDuplicateLanguageKeys() throws Exception {\n\t\tif (_duplicateLanguageKeyLinesMap.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tSet<String> allDuplicateLines = new HashSet<>();\n\n\t\tfor (Map.Entry<String, Set<String>> entry :\n\t\t\t\t_duplicateLanguageKeyLinesMap.entrySet()) {\n\n\t\t\tSet<String> duplicateLines = entry.getValue();\n\n\t\t\tremoveDuplicateKeys(entry.getKey(), duplicateLines);\n\n\t\t\tallDuplicateLines.addAll(duplicateLines);\n\t\t}\n\n\t\tFile coreLanguagePropertiesFile = new File(\n\t\t\tgetFile(\"portal-impl\", PORTAL_MAX_DIR_LEVEL),\n\t\t\t\"src/content/Language.properties\");\n\n\t\tString coreLanguagePropertiesContent = FileUtil.read(\n\t\t\tcoreLanguagePropertiesFile);\n\n\t\tString newCoreLanguagePropertiesContent = coreLanguagePropertiesContent;\n\n\t\tString[][] categoryPrefixAndNameArray = getCategoryPrefixAndNameArray();\n\n\t\tStringBundler sb = new StringBundler(allDuplicateLines.size() + 4);\n\n\t\tsb.append(\"The following language keys were used in multiple modules \");\n\t\tsb.append(\"and have been consolidated, or they already existed in \");\n\t\tsb.append(\"portal-impl\\\\src\\\\content\\\\Language.properties:\");\n\t\tsb.append(\"\\n\");\n\n\t\tfor (String line : allDuplicateLines) {\n\t\t\tsb.append(line);\n\t\t\tsb.append(\"\\n\");\n\n\t\t\tString categoryName = getCategoryName(\n\t\t\t\tline, categoryPrefixAndNameArray);\n\n\t\t\tint pos = newCoreLanguagePropertiesContent.indexOf(\n\t\t\t\t\"## \" + categoryName);\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tpos = newCoreLanguagePropertiesContent.indexOf(\"\\n\", pos + 1);\n\t\t\t}\n\n\t\t\tif (!newCoreLanguagePropertiesContent.contains(\n\t\t\t\t\t\"\\n\" + line + \"\\n\")) {\n\n\t\t\t\tnewCoreLanguagePropertiesContent = StringUtil.insert(\n\t\t\t\t\tnewCoreLanguagePropertiesContent, line + \"\\n\", pos + 1);\n\t\t\t}\n\t\t}\n\n\t\tprocessErrorMessage(\n\t\t\t\"portal-impl/src/content/Language.properties\", sb.toString());\n\n\t\tprocessFormattedFile(\n\t\t\tcoreLanguagePropertiesFile,\n\t\t\t\"portal-impl/src/content/Language.properties\",\n\t\t\tcoreLanguagePropertiesContent, newCoreLanguagePropertiesContent);\n\t}","commit_id":"ce6002c7265ea63a341622a1267b79b17f53f355","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static int compareEntities(final RefEntity entity1, final RefEntity entity2) {\n    if (entity1 instanceof RefElement && entity2 instanceof RefElement) {\n      return PsiUtilBase.compareElementsByPosition(((RefElement)entity1).getElement(), ((RefElement)entity2).getElement());\n    } else if (entity1 != null && entity2 != null) {\n      return entity1.getName().compareToIgnoreCase(entity2.getName());\n    }\n    return 0;\n  }","id":101435,"modified_method":"private static int compareEntities(final RefEntity entity1, final RefEntity entity2) {\n    if (entity1 != null && entity2 != null) {\n      final int nameComparison = entity1.getName().compareToIgnoreCase(entity2.getName());\n      if (nameComparison != 0) {\n        return nameComparison;\n      }\n    }\n    if (entity1 instanceof RefElement && entity2 instanceof RefElement) {\n      return PsiUtilBase.compareElementsByPosition(((RefElement)entity1).getElement(), ((RefElement)entity2).getElement());\n    }\n    return 0;\n  }","commit_id":"f064ec8d8452fa8e8d4f81037b5af6a5407b74d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"ConstantConditions\"}) //class cast suppression\n  protected static void merge(@Nullable DefaultTreeModel model, InspectionTreeNode child, InspectionTreeNode parent, boolean merge) {\n    if (merge) {\n      for (int i = 0; i < parent.getChildCount(); i++) {\n        InspectionTreeNode current = (InspectionTreeNode)parent.getChildAt(i);\n        if (child.getClass() != current.getClass()) {\n          continue;\n        }\n        if (current instanceof InspectionPackageNode) {\n          if (((InspectionPackageNode)current).getPackageName().compareTo(((InspectionPackageNode)child).getPackageName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n        else if (current instanceof RefElementNode) {\n          if (((RefElementNode)current).getElement().getName().compareTo(((RefElementNode)child).getElement().getName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n        else if (current instanceof InspectionNode) {\n          if (((InspectionNode)current).getToolWrapper().getShortName().compareTo(((InspectionNode)child).getToolWrapper().getShortName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n        else if (current instanceof InspectionModuleNode) {\n          if (((InspectionModuleNode)current).getName().compareTo(((InspectionModuleNode)child).getName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n      }\n    }\n    add(model, child, parent);\n  }","id":101436,"modified_method":"@SuppressWarnings({\"ConstantConditions\"}) //class cast suppression\n  protected static void merge(@Nullable DefaultTreeModel model, InspectionTreeNode child, InspectionTreeNode parent, boolean merge) {\n    if (merge) {\n      for (int i = 0; i < parent.getChildCount(); i++) {\n        InspectionTreeNode current = (InspectionTreeNode)parent.getChildAt(i);\n        if (child.getClass() != current.getClass()) {\n          continue;\n        }\n        if (current instanceof InspectionPackageNode) {\n          if (((InspectionPackageNode)current).getPackageName().compareTo(((InspectionPackageNode)child).getPackageName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n        else if (current instanceof RefElementNode) {\n          if (((RefElementNode)current).getElement().getName().compareTo(((RefElementNode)child).getElement().getName()) == 0 &&\n              ((RefElementNode)current).getElement().getQualifiedName().compareTo(((RefElementNode)child).getElement().getQualifiedName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n        else if (current instanceof InspectionNode) {\n          if (((InspectionNode)current).getToolWrapper().getShortName().compareTo(((InspectionNode)child).getToolWrapper().getShortName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n        else if (current instanceof InspectionModuleNode) {\n          if (((InspectionModuleNode)current).getName().compareTo(((InspectionModuleNode)child).getName()) == 0) {\n            processDepth(model, child, current);\n            return;\n          }\n        }\n      }\n    }\n    add(model, child, parent);\n  }","commit_id":"41fbb4e09f89789b913d6bc58be9939f3ff85fa4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int compareEntities(final RefEntity entity1, final RefEntity entity2) {\n    if (entity1 instanceof RefElement && entity2 instanceof RefElement) {\n      return PsiUtilCore.compareElementsByPosition(((RefElement)entity1).getElement(), ((RefElement)entity2).getElement());\n    }\n    if (entity1 != null && entity2 != null) {\n      return entity1.getName().compareToIgnoreCase(entity2.getName());\n    }\n    if (entity1 != null) return -1;\n    return entity2 != null ? 1 : 0;\n  }","id":101437,"modified_method":"private static int compareEntities(final RefEntity entity1, final RefEntity entity2) {\n    if (entity1 instanceof RefElement && entity2 instanceof RefElement) {\n      final int positionComparing = PsiUtilCore.compareElementsByPosition(((RefElement)entity1).getElement(), ((RefElement)entity2).getElement());\n      if (positionComparing != 0) {\n        return positionComparing;\n      }\n    }\n    if (entity1 != null && entity2 != null) {\n      final int nameComparing = entity1.getName().compareToIgnoreCase(entity2.getName());\n      if (nameComparing != 0) {\n        return nameComparing;\n      }\n      return entity1.getQualifiedName().compareToIgnoreCase(entity2.getQualifiedName());\n    }\n    if (entity1 != null) return -1;\n    return entity2 != null ? 1 : 0;\n  }","commit_id":"41fbb4e09f89789b913d6bc58be9939f3ff85fa4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int compare(Object o1, Object o2) {\n    InspectionTreeNode node1 = (InspectionTreeNode)o1;\n    InspectionTreeNode node2 = (InspectionTreeNode)o2;\n\n    if (node1 instanceof InspectionSeverityGroupNode && node2 instanceof InspectionSeverityGroupNode) {\n      final InspectionSeverityGroupNode groupNode1 = (InspectionSeverityGroupNode)node1;\n      final InspectionSeverityGroupNode groupNode2 = (InspectionSeverityGroupNode)node2;\n      return -SeverityRegistrar.getSeverityRegistrar(groupNode1.getProject()).compare(groupNode1.getSeverityLevel().getSeverity(), groupNode2.getSeverityLevel().getSeverity());\n    }\n    if (node1 instanceof InspectionSeverityGroupNode) return -1;\n    if (node2 instanceof InspectionSeverityGroupNode) return 1;\n\n    if (node1 instanceof InspectionGroupNode && node2 instanceof InspectionGroupNode) {\n      return ((InspectionGroupNode)node1).getGroupTitle().compareToIgnoreCase(((InspectionGroupNode)node2).getGroupTitle());\n    }\n    if (node1 instanceof InspectionGroupNode) return -1;\n    if (node2 instanceof InspectionGroupNode) return 1;\n\n    if (node1 instanceof InspectionNode && node2 instanceof InspectionNode)\n      return InspectionsConfigTreeComparator.getDisplayTextToSort(node1.toString())\n        .compareToIgnoreCase(InspectionsConfigTreeComparator.getDisplayTextToSort(node2.toString()));\n    if (node1 instanceof InspectionNode) return -1;\n    if (node2 instanceof InspectionNode) return 1;\n\n    if (node1 instanceof InspectionModuleNode && node2 instanceof InspectionModuleNode) {\n      return Comparing.compare(node1.toString(), node2.toString());\n    }\n    if (node1 instanceof InspectionModuleNode) return -1;\n    if (node2 instanceof InspectionModuleNode) return 1;\n\n    if (node1 instanceof InspectionPackageNode && node2 instanceof InspectionPackageNode) {\n      return ((InspectionPackageNode)node1).getPackageName().compareToIgnoreCase(((InspectionPackageNode)node2).getPackageName());\n    }\n    if (node1 instanceof InspectionPackageNode) return -1;\n    if (node2 instanceof InspectionPackageNode) return 1;\n\n    if (node1 instanceof OfflineRefElementNode && node2 instanceof OfflineRefElementNode ||\n        node1 instanceof OfflineProblemDescriptorNode && node2 instanceof OfflineProblemDescriptorNode) {\n      final Object userObject1 = node1.getUserObject();\n      final Object userObject2 = node2.getUserObject();\n      if (userObject1 instanceof OfflineProblemDescriptor && userObject2 instanceof OfflineProblemDescriptor) {\n        final OfflineProblemDescriptor descriptor1 = (OfflineProblemDescriptor)userObject1;\n        final OfflineProblemDescriptor descriptor2 = (OfflineProblemDescriptor)userObject2;\n        if (descriptor1.getLine() != descriptor2.getLine()) return descriptor1.getLine() - descriptor2.getLine();\n        return descriptor1.getFQName().compareTo(descriptor2.getFQName());\n      }\n      if (userObject1 instanceof OfflineProblemDescriptor) {\n        return compareLineNumbers(userObject2, (OfflineProblemDescriptor)userObject1);\n      }\n      if (userObject2 instanceof OfflineProblemDescriptor) {\n        return -compareLineNumbers(userObject1, (OfflineProblemDescriptor)userObject2);\n      }\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof RefElementNode){   //sort by filename and inside file by start offset\n      return compareEntities(((RefElementNode)node1).getElement(), ((RefElementNode)node2).getElement());\n    }\n    if (node1 instanceof ProblemDescriptionNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor1 = ((ProblemDescriptionNode)node1).getDescriptor();\n      final CommonProblemDescriptor descriptor2 = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor1 instanceof ProblemDescriptor && descriptor2 instanceof ProblemDescriptor) {\n        //TODO: Do not materialise lazy pointers\n        return ((ProblemDescriptor)descriptor1).getLineNumber() - ((ProblemDescriptor)descriptor2).getLineNumber();\n      }\n      if (descriptor1 != null && descriptor2 != null) {\n        return descriptor1.getDescriptionTemplate().compareToIgnoreCase(descriptor2.getDescriptionTemplate());\n      }\n      if (descriptor1 == null) return descriptor2 == null ? 0 : -1;\n      return 1;\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return compareEntity(((RefElementNode)node1).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return compareEntities(((RefElementNode)node1).getElement(), ((ProblemDescriptionNode)node2).getElement());\n    }\n\n    if (node2 instanceof RefElementNode && node1 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node1).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return -compareEntity(((RefElementNode)node2).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return -compareEntities(((RefElementNode)node2).getElement(), ((ProblemDescriptionNode)node1).getElement());\n    }\n\n    LOG.error(\"node1: \" + node1 + \", node2: \" + node2);\n    return 0;\n  }","id":101438,"modified_method":"@Override\n  public int compare(Object o1, Object o2) {\n    InspectionTreeNode node1 = (InspectionTreeNode)o1;\n    InspectionTreeNode node2 = (InspectionTreeNode)o2;\n\n    if (node1 instanceof InspectionSeverityGroupNode && node2 instanceof InspectionSeverityGroupNode) {\n      final InspectionSeverityGroupNode groupNode1 = (InspectionSeverityGroupNode)node1;\n      final InspectionSeverityGroupNode groupNode2 = (InspectionSeverityGroupNode)node2;\n      return -SeverityRegistrar.getSeverityRegistrar(groupNode1.getProject()).compare(groupNode1.getSeverityLevel().getSeverity(), groupNode2.getSeverityLevel().getSeverity());\n    }\n    if (node1 instanceof InspectionSeverityGroupNode) return -1;\n    if (node2 instanceof InspectionSeverityGroupNode) return 1;\n\n    if (node1 instanceof InspectionGroupNode && node2 instanceof InspectionGroupNode) {\n      return ((InspectionGroupNode)node1).getGroupTitle().compareToIgnoreCase(((InspectionGroupNode)node2).getGroupTitle());\n    }\n    if (node1 instanceof InspectionGroupNode) return -1;\n    if (node2 instanceof InspectionGroupNode) return 1;\n\n    if (node1 instanceof InspectionNode && node2 instanceof InspectionNode)\n      return InspectionsConfigTreeComparator.getDisplayTextToSort(node1.toString())\n        .compareToIgnoreCase(InspectionsConfigTreeComparator.getDisplayTextToSort(node2.toString()));\n    if (node1 instanceof InspectionNode) return -1;\n    if (node2 instanceof InspectionNode) return 1;\n\n    if (node1 instanceof InspectionModuleNode && node2 instanceof InspectionModuleNode) {\n      return Comparing.compare(node1.toString(), node2.toString());\n    }\n    if (node1 instanceof InspectionModuleNode) return -1;\n    if (node2 instanceof InspectionModuleNode) return 1;\n\n    if (node1 instanceof InspectionPackageNode && node2 instanceof InspectionPackageNode) {\n      final int nonQualified = ((InspectionPackageNode)node1).getPackageName().compareToIgnoreCase(((InspectionPackageNode)node2).getPackageName());\n      if (nonQualified != 0) {\n        return nonQualified;\n      }\n      return nonQualified;\n    }\n    if (node1 instanceof InspectionPackageNode) return -1;\n    if (node2 instanceof InspectionPackageNode) return 1;\n\n    if (node1 instanceof OfflineRefElementNode && node2 instanceof OfflineRefElementNode ||\n        node1 instanceof OfflineProblemDescriptorNode && node2 instanceof OfflineProblemDescriptorNode) {\n      final Object userObject1 = node1.getUserObject();\n      final Object userObject2 = node2.getUserObject();\n      if (userObject1 instanceof OfflineProblemDescriptor && userObject2 instanceof OfflineProblemDescriptor) {\n        final OfflineProblemDescriptor descriptor1 = (OfflineProblemDescriptor)userObject1;\n        final OfflineProblemDescriptor descriptor2 = (OfflineProblemDescriptor)userObject2;\n        if (descriptor1.getLine() != descriptor2.getLine()) return descriptor1.getLine() - descriptor2.getLine();\n        return descriptor1.getFQName().compareTo(descriptor2.getFQName());\n      }\n      if (userObject1 instanceof OfflineProblemDescriptor) {\n        return compareLineNumbers(userObject2, (OfflineProblemDescriptor)userObject1);\n      }\n      if (userObject2 instanceof OfflineProblemDescriptor) {\n        return -compareLineNumbers(userObject1, (OfflineProblemDescriptor)userObject2);\n      }\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof RefElementNode){   //sort by filename and inside file by start offset\n      return compareEntities(((RefElementNode)node1).getElement(), ((RefElementNode)node2).getElement());\n    }\n    if (node1 instanceof ProblemDescriptionNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor1 = ((ProblemDescriptionNode)node1).getDescriptor();\n      final CommonProblemDescriptor descriptor2 = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor1 instanceof ProblemDescriptor && descriptor2 instanceof ProblemDescriptor) {\n        //TODO: Do not materialise lazy pointers\n        return ((ProblemDescriptor)descriptor1).getLineNumber() - ((ProblemDescriptor)descriptor2).getLineNumber();\n      }\n      if (descriptor1 != null && descriptor2 != null) {\n        return descriptor1.getDescriptionTemplate().compareToIgnoreCase(descriptor2.getDescriptionTemplate());\n      }\n      if (descriptor1 == null) return descriptor2 == null ? 0 : -1;\n      return 1;\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return compareEntity(((RefElementNode)node1).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return compareEntities(((RefElementNode)node1).getElement(), ((ProblemDescriptionNode)node2).getElement());\n    }\n\n    if (node2 instanceof RefElementNode && node1 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node1).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return -compareEntity(((RefElementNode)node2).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return -compareEntities(((RefElementNode)node2).getElement(), ((ProblemDescriptionNode)node1).getElement());\n    }\n\n    LOG.error(\"node1: \" + node1 + \", node2: \" + node2);\n    return 0;\n  }","commit_id":"41fbb4e09f89789b913d6bc58be9939f3ff85fa4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    final RefEntity element = getElement();\n    if (element == null || !element.isValid()) {\n      return InspectionsBundle.message(\"inspection.reference.invalid\");\n    }\n    return element.getRefManager().getRefinedElement(element).getQualifiedName();\n  }","id":101439,"modified_method":"public String toString() {\n    final RefEntity element = getElement();\n    if (element == null || !element.isValid()) {\n      return InspectionsBundle.message(\"inspection.reference.invalid\");\n    }\n    return element.getRefManager().getRefinedElement(element).getName();\n  }","commit_id":"41fbb4e09f89789b913d6bc58be9939f3ff85fa4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void update(AnActionEvent e) {\n      e.getPresentation().setEnabled(myScope.isValid());\n    }","id":101440,"modified_method":"@Override\n    public void update(AnActionEvent e) {\n      e.getPresentation().setEnabled(!(myProvider instanceof OfflineInspectionRVContentProvider) && myScope.isValid());\n    }","commit_id":"8da38289fcff75582f85d204c2a3e255eeb0893a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int compare(Object o1, Object o2) {\n    InspectionTreeNode node1 = (InspectionTreeNode)o1;\n    InspectionTreeNode node2 = (InspectionTreeNode)o2;\n\n    if (node1 instanceof InspectionSeverityGroupNode && node2 instanceof InspectionSeverityGroupNode) {\n      final InspectionSeverityGroupNode groupNode1 = (InspectionSeverityGroupNode)node1;\n      final InspectionSeverityGroupNode groupNode2 = (InspectionSeverityGroupNode)node2;\n      return -SeverityRegistrar.getSeverityRegistrar(groupNode1.getProject()).compare(groupNode1.getSeverityLevel().getSeverity(), groupNode2.getSeverityLevel().getSeverity());\n    }\n    if (node1 instanceof InspectionSeverityGroupNode) return -1;\n    if (node2 instanceof InspectionSeverityGroupNode) return 1;\n\n    if (node1 instanceof InspectionGroupNode && node2 instanceof InspectionGroupNode) {\n      return ((InspectionGroupNode)node1).getGroupTitle().compareToIgnoreCase(((InspectionGroupNode)node2).getGroupTitle());\n    }\n    if (node1 instanceof InspectionGroupNode) return -1;\n    if (node2 instanceof InspectionGroupNode) return 1;\n\n    if (node1 instanceof InspectionNode && node2 instanceof InspectionNode)\n      return InspectionsConfigTreeComparator.getDisplayTextToSort(node1.toString())\n        .compareToIgnoreCase(InspectionsConfigTreeComparator.getDisplayTextToSort(node2.toString()));\n    if (node1 instanceof InspectionNode) return -1;\n    if (node2 instanceof InspectionNode) return 1;\n\n    if (node1 instanceof InspectionModuleNode && node2 instanceof InspectionModuleNode) {\n      return Comparing.compare(node1.toString(), node2.toString());\n    }\n    if (node1 instanceof InspectionModuleNode) return -1;\n    if (node2 instanceof InspectionModuleNode) return 1;\n\n    if (node1 instanceof InspectionPackageNode && node2 instanceof InspectionPackageNode) {\n      return ((InspectionPackageNode)node1).getPackageName().compareToIgnoreCase(((InspectionPackageNode)node2).getPackageName());\n    }\n    if (node1 instanceof InspectionPackageNode) return -1;\n    if (node2 instanceof InspectionPackageNode) return 1;\n\n    if (node1 instanceof OfflineRefElementNode && node2 instanceof OfflineRefElementNode) {\n      final Object userObject1 = ((OfflineRefElementNode)node1).getOfflineDescriptor();\n      final Object userObject2 = ((OfflineRefElementNode)node2).getOfflineDescriptor();\n      final OfflineProblemDescriptor descriptor1 = (OfflineProblemDescriptor)userObject1;\n      final OfflineProblemDescriptor descriptor2 = (OfflineProblemDescriptor)userObject2;\n      if (descriptor1.getLine() != descriptor2.getLine()) return descriptor1.getLine() - descriptor2.getLine();\n      return descriptor1.getFQName().compareToIgnoreCase(descriptor2.getFQName());\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof RefElementNode){   //sort by filename and inside file by start offset\n      return compareEntities(((RefElementNode)node1).getElement(), ((RefElementNode)node2).getElement());\n    }\n    if (node1 instanceof ProblemDescriptionNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor1 = ((ProblemDescriptionNode)node1).getDescriptor();\n      final CommonProblemDescriptor descriptor2 = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor1 instanceof ProblemDescriptor && descriptor2 instanceof ProblemDescriptor) {\n        //TODO: Do not materialise lazy pointers\n        return ((ProblemDescriptor)descriptor1).getLineNumber() - ((ProblemDescriptor)descriptor2).getLineNumber();\n      }\n      if (descriptor1 != null && descriptor2 != null) {\n        return descriptor1.getDescriptionTemplate().compareToIgnoreCase(descriptor2.getDescriptionTemplate());\n      }\n      if (descriptor1 == null) return descriptor2 == null ? 0 : -1;\n      return 1;\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return compareEntity(((RefElementNode)node1).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return compareEntities(((RefElementNode)node1).getElement(), ((ProblemDescriptionNode)node2).getElement());\n    }\n\n    if (node2 instanceof RefElementNode && node1 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node1).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return -compareEntity(((RefElementNode)node2).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return -compareEntities(((RefElementNode)node2).getElement(), ((ProblemDescriptionNode)node1).getElement());\n    }\n    if (node1 instanceof InspectionRootNode && node2 instanceof InspectionRootNode) {\n      //TODO Dmitry Batkovich: optimization, because only one root node is existed\n      return 0;\n    }\n\n    LOG.error(\"node1: \" + node1 + \", node2: \" + node2);\n    return 0;\n  }","id":101441,"modified_method":"@Override\n  public int compare(Object o1, Object o2) {\n    InspectionTreeNode node1 = (InspectionTreeNode)o1;\n    InspectionTreeNode node2 = (InspectionTreeNode)o2;\n\n    if (node1 instanceof InspectionSeverityGroupNode && node2 instanceof InspectionSeverityGroupNode) {\n      final InspectionSeverityGroupNode groupNode1 = (InspectionSeverityGroupNode)node1;\n      final InspectionSeverityGroupNode groupNode2 = (InspectionSeverityGroupNode)node2;\n      return -SeverityRegistrar.getSeverityRegistrar(groupNode1.getProject()).compare(groupNode1.getSeverityLevel().getSeverity(), groupNode2.getSeverityLevel().getSeverity());\n    }\n    if (node1 instanceof InspectionSeverityGroupNode) return -1;\n    if (node2 instanceof InspectionSeverityGroupNode) return 1;\n\n    if (node1 instanceof InspectionGroupNode && node2 instanceof InspectionGroupNode) {\n      return ((InspectionGroupNode)node1).getGroupTitle().compareToIgnoreCase(((InspectionGroupNode)node2).getGroupTitle());\n    }\n    if (node1 instanceof InspectionGroupNode) return -1;\n    if (node2 instanceof InspectionGroupNode) return 1;\n\n    if (node1 instanceof InspectionNode && node2 instanceof InspectionNode)\n      return InspectionsConfigTreeComparator.getDisplayTextToSort(node1.toString())\n        .compareToIgnoreCase(InspectionsConfigTreeComparator.getDisplayTextToSort(node2.toString()));\n    if (node1 instanceof InspectionNode) return -1;\n    if (node2 instanceof InspectionNode) return 1;\n\n    if (node1 instanceof InspectionModuleNode && node2 instanceof InspectionModuleNode) {\n      return Comparing.compare(node1.toString(), node2.toString());\n    }\n    if (node1 instanceof InspectionModuleNode) return -1;\n    if (node2 instanceof InspectionModuleNode) return 1;\n\n    if (node1 instanceof InspectionPackageNode && node2 instanceof InspectionPackageNode) {\n      return ((InspectionPackageNode)node1).getPackageName().compareToIgnoreCase(((InspectionPackageNode)node2).getPackageName());\n    }\n    if (node1 instanceof InspectionPackageNode) return -1;\n    if (node2 instanceof InspectionPackageNode) return 1;\n\n    if (node1 instanceof OfflineRefElementNode && node2 instanceof OfflineRefElementNode) {\n      final Object userObject1 = ((OfflineRefElementNode)node1).getOfflineDescriptor();\n      final Object userObject2 = ((OfflineRefElementNode)node2).getOfflineDescriptor();\n      final OfflineProblemDescriptor descriptor1 = (OfflineProblemDescriptor)userObject1;\n      final OfflineProblemDescriptor descriptor2 = (OfflineProblemDescriptor)userObject2;\n      final int res = descriptor1.getFQName().compareToIgnoreCase(descriptor2.getFQName());\n      if (res != 0) {\n        return res;\n      }\n      return descriptor1.getLine() - descriptor2.getLine();\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof RefElementNode){   //sort by filename and inside file by start offset\n      return compareEntities(((RefElementNode)node1).getElement(), ((RefElementNode)node2).getElement());\n    }\n    if (node1 instanceof ProblemDescriptionNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor1 = ((ProblemDescriptionNode)node1).getDescriptor();\n      final CommonProblemDescriptor descriptor2 = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor1 instanceof ProblemDescriptor && descriptor2 instanceof ProblemDescriptor) {\n        //TODO: Do not materialise lazy pointers\n        return ((ProblemDescriptor)descriptor1).getLineNumber() - ((ProblemDescriptor)descriptor2).getLineNumber();\n      }\n      if (descriptor1 != null && descriptor2 != null) {\n        return descriptor1.getDescriptionTemplate().compareToIgnoreCase(descriptor2.getDescriptionTemplate());\n      }\n      if (descriptor1 == null) return descriptor2 == null ? 0 : -1;\n      return 1;\n    }\n\n    if (node1 instanceof RefElementNode && node2 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node2).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return compareEntity(((RefElementNode)node1).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return compareEntities(((RefElementNode)node1).getElement(), ((ProblemDescriptionNode)node2).getElement());\n    }\n\n    if (node2 instanceof RefElementNode && node1 instanceof ProblemDescriptionNode) {\n      final CommonProblemDescriptor descriptor = ((ProblemDescriptionNode)node1).getDescriptor();\n      if (descriptor instanceof ProblemDescriptor) {\n        return -compareEntity(((RefElementNode)node2).getElement(), ((ProblemDescriptor)descriptor).getPsiElement());\n      }\n      return -compareEntities(((RefElementNode)node2).getElement(), ((ProblemDescriptionNode)node1).getElement());\n    }\n    if (node1 instanceof InspectionRootNode && node2 instanceof InspectionRootNode) {\n      //TODO Dmitry Batkovich: optimization, because only one root node is existed\n      return 0;\n    }\n\n    LOG.error(\"node1: \" + node1 + \", node2: \" + node2);\n    return 0;\n  }","commit_id":"8da38289fcff75582f85d204c2a3e255eeb0893a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public InspectionNode appendToolNodeContent(@NotNull GlobalInspectionContextImpl context,\n                                              @NotNull final InspectionNode toolNode,\n                                              @NotNull final InspectionTreeNode parentNode,\n                                              final boolean showStructure,\n                                              boolean groupBySeverity, @NotNull final Map<String, Set<RefEntity>> contents,\n                                              @NotNull final Map<RefEntity, CommonProblemDescriptor[]> problems) {\n    InspectionToolWrapper toolWrapper = toolNode.getToolWrapper();\n    final Map<String, Set<OfflineProblemDescriptor>> filteredContent = getFilteredContent(context, toolWrapper);\n    if (filteredContent != null && !filteredContent.values().isEmpty()) {\n      parentNode.add(toolNode);\n      buildTree(context, filteredContent, false, toolWrapper, OfflineProblemDescriptorContainer::new, showStructure,\n                (newChild) -> {\n                  toolNode.add(newChild);\n                  return newChild;\n                });\n    }\n    return toolNode;\n  }","id":101442,"modified_method":"@Override\n  public InspectionNode appendToolNodeContent(@NotNull GlobalInspectionContextImpl context,\n                                              @NotNull final InspectionNode toolNode,\n                                              @NotNull final InspectionTreeNode parentNode,\n                                              final boolean showStructure,\n                                              boolean groupBySeverity, @NotNull final Map<String, Set<RefEntity>> contents,\n                                              @NotNull final Map<RefEntity, CommonProblemDescriptor[]> problems) {\n    InspectionToolWrapper toolWrapper = toolNode.getToolWrapper();\n    final Map<String, Set<OfflineProblemDescriptor>> filteredContent = getFilteredContent(context, toolWrapper);\n    if (filteredContent != null && !filteredContent.values().isEmpty()) {\n      parentNode.insertByOrder(toolNode, false);\n      buildTree(context, filteredContent, false, toolWrapper, OfflineProblemDescriptorContainer::new, showStructure,\n                (newChild) -> {\n                  toolNode.insertByOrder(newChild, false);\n                  return newChild;\n                });\n    }\n    return toolNode;\n  }","commit_id":"8da38289fcff75582f85d204c2a3e255eeb0893a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static FCPServer maybeCreate(Node node, Config config) throws IOException, InvalidConfigValueException {\n\t\tSubConfig fcpConfig = new SubConfig(\"fcp\", config);\n\t\tfcpConfig.register(\"enabled\", true, 2, true, \"Is FCP server enabled ?\", \"Is FCP server enabled ?\", new FCPEnabledCallback(node));\n\t\tfcpConfig.register(\"port\", 9481 /* anagram of 1984, and 1000 up from old number */,\n\t\t\t\t2, true, \"FCP port number\", \"FCP port number\", new FCPPortNumberCallback(node));\n\t\tfcpConfig.register(\"bindTo\", \"127.0.0.1\", 2, true, \"Ip address to bind to\", \"Ip address to bind the FCP server to\", new FCPBindtoCallback(node));\n\t\tPersistentDownloadsEnabledCallback cb1;\n\t\tPersistentDownloadsFileCallback cb2;\n\t\tPersistentDownloadsIntervalCallback cb3;\n\t\tfcpConfig.register(\"persistentDownloadsEnabled\", true, 3, true, \"Enable persistent downloads?\", \"Whether to enable Persistence=forever for FCP requests. Meaning whether to support requests which persist over node restarts; they must be written to disk and this may constitute a security risk for some people.\",\n\t\t\t\tcb1 = new PersistentDownloadsEnabledCallback());\n\t\tboolean persistentDownloadsEnabled = fcpConfig.getBoolean(\"persistentDownloadsEnabled\");\n\t\tfcpConfig.register(\"persistentDownloadsFile\", \"downloads.dat\", 4, true, \"Filename to store persistent downloads in\", \"Filename to store details of persistent downloads to\",\n\t\t\t\tcb2 = new PersistentDownloadsFileCallback());\n\t\tString persistentDownloadsDir = \n\t\t\tfcpConfig.getString(\"persistentDownloadsFile\");\n\t\t\n\t\tfcpConfig.register(\"persistentDownloadsInterval\", (long)(5*60*1000), 5, true, \"Interval between writing persistent downloads to disk\", \"Interval between writing persistent downloads to disk\",\n\t\t\t\tcb3 = new PersistentDownloadsIntervalCallback());\n\t\t\n\t\tlong persistentDownloadsInterval = fcpConfig.getLong(\"persistentDownloadsInterval\");\n\t\t\n\t\tFCPServer fcp;\n\t\tif(fcpConfig.getBoolean(\"enabled\")){\n\t\t\tLogger.normal(node, \"Starting FCP server on \"+fcpConfig.getString(\"bindTo\")+\":\"+fcpConfig.getInt(\"port\")+\".\");\n\t\t\tfcp = new FCPServer(fcpConfig.getString(\"bindTo\"), fcpConfig.getInt(\"port\"), node, persistentDownloadsEnabled, persistentDownloadsDir, persistentDownloadsInterval);\n\t\t\tnode.setFCPServer(fcp);\t\n\t\t\t\n\t\t\tif(fcp != null) {\n\t\t\t\tcb1.server = fcp;\n\t\t\t\tcb2.server = fcp;\n\t\t\t\tcb3.server = fcp;\n\t\t\t}\n\t\t}else{\n\t\t\tLogger.normal(node, \"Not starting FCP server as it's disabled\");\n\t\t\tfcp = null;\n\t\t}\n\t\n\t\tfcpConfig.finishedInitialization();\n\t\treturn fcp;\n\t}","id":101443,"modified_method":"public static FCPServer maybeCreate(Node node, Config config) throws IOException, InvalidConfigValueException {\n\t\tSubConfig fcpConfig = new SubConfig(\"fcp\", config);\n\t\tfcpConfig.register(\"enabled\", true, 2, true, \"Is FCP server enabled ?\", \"Is FCP server enabled ?\", new FCPEnabledCallback(node));\n\t\tfcpConfig.register(\"port\", 9481 /* anagram of 1984, and 1000 up from old number */,\n\t\t\t\t2, true, \"FCP port number\", \"FCP port number\", new FCPPortNumberCallback(node));\n\t\tfcpConfig.register(\"bindTo\", \"127.0.0.1\", 2, true, \"Ip address to bind to\", \"Ip address to bind the FCP server to\", new FCPBindtoCallback(node));\n\t\tPersistentDownloadsEnabledCallback cb1;\n\t\tPersistentDownloadsFileCallback cb2;\n\t\tPersistentDownloadsIntervalCallback cb3;\n\t\tfcpConfig.register(\"persistentDownloadsEnabled\", true, 3, true, \"Enable persistent downloads?\", \"Whether to enable Persistence=forever for FCP requests. Meaning whether to support requests which persist over node restarts; they must be written to disk and this may constitute a security risk for some people.\",\n\t\t\t\tcb1 = new PersistentDownloadsEnabledCallback());\n\t\tboolean persistentDownloadsEnabled = fcpConfig.getBoolean(\"persistentDownloadsEnabled\");\n\t\tfcpConfig.register(\"persistentDownloadsFile\", \"downloads.dat\", 4, true, \"Filename to store persistent downloads in\", \"Filename to store details of persistent downloads to\",\n\t\t\t\tcb2 = new PersistentDownloadsFileCallback());\n\t\tString persistentDownloadsDir = \n\t\t\tfcpConfig.getString(\"persistentDownloadsFile\");\n\t\t\n\t\tfcpConfig.register(\"persistentDownloadsInterval\", (long)(5*60*1000), 5, true, \"Interval between writing persistent downloads to disk\", \"Interval between writing persistent downloads to disk\",\n\t\t\t\tcb3 = new PersistentDownloadsIntervalCallback());\n\t\t\n\t\tlong persistentDownloadsInterval = fcpConfig.getLong(\"persistentDownloadsInterval\");\n\t\t\n\t\tFCPServer fcp;\n\t\t\n\t\tfcp = new FCPServer(fcpConfig.getString(\"bindTo\"), fcpConfig.getInt(\"port\"), node, persistentDownloadsEnabled, persistentDownloadsDir, persistentDownloadsInterval, fcpConfig.getBoolean(\"enabled\"));\n\t\tnode.setFCPServer(fcp);\t\n\t\t\n\t\tif(fcp != null) {\n\t\t\tcb1.server = fcp;\n\t\t\tcb2.server = fcp;\n\t\t\tcb3.server = fcp;\n\t\t}\n\t\t\n\t\n\t\tfcpConfig.finishedInitialization();\n\t\treturn fcp;\n\t}","commit_id":"b6a8f1787df168986eebe0909f752eaab340abbe","url":"https://github.com/freenet/fred"},{"original_method":"public FCPServer(String ipToBindTo, int port, Node node, boolean persistentDownloadsEnabled, String persistentDownloadsDir, long persistenceInterval) throws IOException, InvalidConfigValueException {\n\t\tthis.bindTo = ipToBindTo;\n\t\tthis.persistenceInterval = persistenceInterval;\n\t\tthis.port = port;\n\t\tthis.enabled = true;\n\t\tthis.sock = new ServerSocket(port, 0, InetAddress.getByName(bindTo));\n\t\tthis.node = node;\n\t\tclientsByName = new WeakHashMap();\n\t\t// This one is only used to get the default settings. Individual FCP conns\n\t\t// will make their own.\n\t\tHighLevelSimpleClient client = node.makeClient((short)0);\n\t\tdefaultFetchContext = client.getFetcherContext();\n\t\tdefaultInsertContext = client.getInserterContext();\n\t\tThread t = new Thread(this, \"FCP server\");\n\t\tthis.enablePersistentDownloads = persistentDownloadsEnabled;\n\t\tglobalClient = new FCPClient(\"Global Queue\", this, null, true);\n\t\tsetPersistentDownloadsFile(new File(persistentDownloadsDir));\n\t\tt.setDaemon(true);\n\t\tt.start();\n\t\tif(enablePersistentDownloads) {\n\t\t\tloadPersistentRequests();\n\t\t\tstartPersister();\n\t\t}\n\t}","id":101444,"modified_method":"public FCPServer(String ipToBindTo, int port, Node node, boolean persistentDownloadsEnabled, String persistentDownloadsDir, long persistenceInterval, boolean isEnabled) throws IOException, InvalidConfigValueException {\n\t\tthis.bindTo = ipToBindTo;\n\t\tthis.persistenceInterval = persistenceInterval;\n\t\tthis.port = port;\n\t\tthis.enabled = isEnabled;\n\t\tthis.enablePersistentDownloads = persistentDownloadsEnabled;\n\t\tsetPersistentDownloadsFile(new File(persistentDownloadsDir));\n\t\t\n\t\tif (this.enabled) {\n\t\t\tthis.node = node;\n\t\t\tclientsByName = new WeakHashMap();\n\t\t\t\n\t\t\t\n\t\t\t// This one is only used to get the default settings. Individual FCP conns\n\t\t\t// will make their own.\n\t\t\tHighLevelSimpleClient client = node.makeClient((short)0);\n\t\t\tdefaultFetchContext = client.getFetcherContext();\n\t\t\tdefaultInsertContext = client.getInserterContext();\n\t\t\t\n\t\t\t\n\t\t\tglobalClient = new FCPClient(\"Global Queue\", this, null, true);\n\t\t\t\n\t\t\t\n\t\t\tif(enablePersistentDownloads) {\n\t\t\t\tloadPersistentRequests();\n\t\t\t\tstartPersister();\n\t\t\t}\n\t\t\t\n\t\t\tLogger.normal(this, \"Starting FCP server on \"+bindTo+\":\"+port+\".\");\n\t\t\tServerSocket tempsock = null;\n\t\t\ttry {\n\t\t\t\ttempsock = new ServerSocket(port, 0, InetAddress.getByName(bindTo));\n\t\t\t} catch (BindException be) {\n\t\t\t\tLogger.error(this, \"Couldn't bind to FCP Port \"+port+\". FCP Server not started.\");\n\t\t\t}\n\t\t\t\n\t\t\tthis.sock = tempsock;\n\t\t\t\n\t\t\tif (this.sock != null) {\n\t\t\t\tThread t = new Thread(this, \"FCP server\");\n\t\t\t\tt.setDaemon(true);\n\t\t\t\tt.start();\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.normal(this, \"Not starting FCP server as it's disabled\");\n\t\t\tthis.sock = null;\n\t\t\tthis.node = null;\n\t\t\tthis.clientsByName = null;\n\t\t\tthis.globalClient = null;\n\t\t\tthis.defaultFetchContext = null;\n\t\t}\n\t\t\n\t}","commit_id":"b6a8f1787df168986eebe0909f752eaab340abbe","url":"https://github.com/freenet/fred"},{"original_method":"@Test\n  public void testGetResources() throws Exception {\n    TestStreamProvider streamProvider  = new TestStreamProvider();\n    TestGangliaHostProvider hostProvider = new TestGangliaHostProvider();\n\n    GangliaPropertyProvider propertyProvider = new GangliaHostComponentPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        streamProvider,\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID, new TemporalInfoImpl(10L, 20L, 1L));\n    Request  request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID), temporalInfoMap);\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(\"http://domU-12-31-39-0E-34-E1.compute-1.internal/cgi-bin/rrd.py?c=HDPSlaves&h=domU-12-31-39-0E-34-E1.compute-1.internal&m=jvm.metrics.gcCount&s=10&e=20&r=1\",\n        streamProvider.getLastSpec());\n\n    Assert.assertEquals(3, PropertyHelper.getProperties(resource).size());\n    Assert.assertNotNull(resource.getPropertyValue(PROPERTY_ID));\n\n\n    // tasktracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"TASKTRACKER\");\n\n    // only ask for one property\n    temporalInfoMap = new HashMap<String, TemporalInfo>();\n\n    //http://ec2-174-129-152-147.compute-1.amazonaws.com/cgi-bin/rrd.py?c=HDPSlaves&m=jvm.metrics.gcCount,mapred.shuffleOutput.shuffle_exceptions_caught,mapred.shuffleOutput.shuffle_failed_outputs,mapred.shuffleOutput.shuffle_output_bytes,mapred.shuffleOutput.shuffle_success_outputs&s=10&e=20&r=1&h=ip-10-85-111-149.ec2.internal\n\n    Set<String> properties = new HashSet<String>();\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_exceptions_caught\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_failed_outputs\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_output_bytes\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_success_outputs\"));\n    request = PropertyHelper.getReadRequest(properties, temporalInfoMap);\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(\"http://domU-12-31-39-0E-34-E1.compute-1.internal/cgi-bin/rrd.py?c=HDPSlaves&h=domU-12-31-39-0E-34-E1.compute-1.internal&m=mapred.shuffleOutput.shuffle_output_bytes,mapred.shuffleOutput.shuffle_success_outputs,mapred.shuffleOutput.shuffle_failed_outputs,mapred.shuffleOutput.shuffle_exceptions_caught&e=now&pt=true\",\n        streamProvider.getLastSpec());\n\n    Assert.assertEquals(6, PropertyHelper.getProperties(resource).size());\n    Assert.assertNotNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_exceptions_caught\")));\n    Assert.assertNotNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_failed_outputs\")));\n    Assert.assertNotNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_output_bytes\")));\n    Assert.assertNotNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_success_outputs\")));\n  }","id":101445,"modified_method":"@Test\n  public void testGetResources() throws Exception {\n    TestStreamProvider streamProvider  = new TestStreamProvider();\n    TestGangliaHostProvider hostProvider = new TestGangliaHostProvider();\n\n    GangliaPropertyProvider propertyProvider = new GangliaHostComponentPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        streamProvider,\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID, new TemporalInfoImpl(10L, 20L, 1L));\n    Request  request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID), temporalInfoMap);\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(\"http://domU-12-31-39-0E-34-E1.compute-1.internal/cgi-bin/rrd.py?c=HDPSlaves&h=domU-12-31-39-0E-34-E1.compute-1.internal&m=jvm.metrics.gcCount&s=10&e=20&r=1\",\n        streamProvider.getLastSpec());\n\n    Assert.assertEquals(3, PropertyHelper.getProperties(resource).size());\n    Assert.assertNotNull(resource.getPropertyValue(PROPERTY_ID));\n\n\n    // tasktracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"TASKTRACKER\");\n\n    // only ask for one property\n    temporalInfoMap = new HashMap<String, TemporalInfo>();\n\n    //http://ec2-174-129-152-147.compute-1.amazonaws.com/cgi-bin/rrd.py?c=HDPSlaves&m=jvm.metrics.gcCount,mapred.shuffleOutput.shuffle_exceptions_caught,mapred.shuffleOutput.shuffle_failed_outputs,mapred.shuffleOutput.shuffle_output_bytes,mapred.shuffleOutput.shuffle_success_outputs&s=10&e=20&r=1&h=ip-10-85-111-149.ec2.internal\n\n    Set<String> properties = new HashSet<String>();\n    String shuffle_exceptions_caught = PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_exceptions_caught\");\n    String shuffle_failed_outputs    = PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_failed_outputs\");\n    String shuffle_output_bytes      = PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_output_bytes\");\n    String shuffle_success_outputs   = PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_success_outputs\");\n\n    properties.add(shuffle_exceptions_caught);\n    properties.add(shuffle_failed_outputs);\n    properties.add(shuffle_output_bytes);\n    properties.add(shuffle_success_outputs);\n    request = PropertyHelper.getReadRequest(properties, temporalInfoMap);\n\n    temporalInfoMap.put(shuffle_exceptions_caught, new TemporalInfoImpl(10L, 20L, 1L));\n    temporalInfoMap.put(shuffle_failed_outputs, new TemporalInfoImpl(10L, 20L, 1L));\n    temporalInfoMap.put(shuffle_output_bytes, new TemporalInfoImpl(10L, 20L, 1L));\n    temporalInfoMap.put(shuffle_success_outputs, new TemporalInfoImpl(10L, 20L, 1L));\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(\"http://domU-12-31-39-0E-34-E1.compute-1.internal/cgi-bin/rrd.py?c=HDPSlaves&h=domU-12-31-39-0E-34-E1.compute-1.internal&m=mapred.shuffleOutput.shuffle_output_bytes,mapred.shuffleOutput.shuffle_success_outputs,mapred.shuffleOutput.shuffle_failed_outputs,mapred.shuffleOutput.shuffle_exceptions_caught&s=10&e=20&r=1\",\n        streamProvider.getLastSpec());\n\n    Assert.assertEquals(6, PropertyHelper.getProperties(resource).size());\n    Assert.assertNotNull(resource.getPropertyValue(shuffle_exceptions_caught));\n    Assert.assertNotNull(resource.getPropertyValue(shuffle_failed_outputs));\n    Assert.assertNotNull(resource.getPropertyValue(shuffle_output_bytes));\n    Assert.assertNotNull(resource.getPropertyValue(shuffle_success_outputs));\n  }","commit_id":"a4e7d8bc258f8ef539ee48b3e56901a615018c47","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResources() throws Exception {\n    TestStreamProvider  streamProvider = new TestStreamProvider();\n    TestJMXHostProvider hostProvider = new TestJMXHostProvider();\n\n    JMXPropertyProvider propertyProvider = new JMXPropertyProvider(\n        PropertyHelper.getJMXPropertyIds(Resource.Type.HostComponent),\n        streamProvider,\n        hostProvider, PropertyHelper.getPropertyId(\"HostRoles\", \"cluster_name\"), PropertyHelper.getPropertyId(\"HostRoles\", \"host_name\"), PropertyHelper.getPropertyId(\"HostRoles\", \"component_name\"));\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-0e-34-e1.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"NAMENODE\");\n\n    // request with an empty set should get all supported properties\n    Request request = PropertyHelper.getReadRequest(Collections.<String>emptySet());\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-0e-34-e1.compute-1.internal:50070\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_namenode_jmx.json for values\n    Assert.assertEquals(13670605,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/rpc\", \"ReceivedBytes\")));\n    Assert.assertEquals(28,      resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/dfs/namenode\", \"CreateFileOps\")));\n    Assert.assertEquals(1006632960, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(473433016, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(23634400, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n\n\n    // datanode\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // request with an empty set should get all supported properties\n    request = PropertyHelper.getReadRequest(Collections.<String>emptySet());\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:50075\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_datanode_jmx.json for values\n    Assert.assertEquals(856,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/rpc\", \"ReceivedBytes\")));\n    Assert.assertEquals(954466304, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(9772616, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(21933376, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n\n\n    // jobtracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"JOBTRACKER\");\n\n    // only ask for specific properties\n    Set<String> properties = new HashSet<String>();\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"threadsWaiting\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\"));\n    request = PropertyHelper.getReadRequest(properties);\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:50030\"), streamProvider.getLastSpec());\n\n    // see test/resources/mapreduce_jobtracker_jmx.json for values\n    Assert.assertEquals(7, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(59, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"threadsWaiting\")));\n    Assert.assertEquals(1052770304, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(43580400, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(29602888, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"gcCount\")));\n\n    // tasktracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"TASKTRACKER\");\n\n    // only ask for specific properties\n    properties = new HashSet<String>();\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\"));\n    request = PropertyHelper.getReadRequest(properties);\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:50060\"), streamProvider.getLastSpec());\n\n    Assert.assertEquals(6, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(954466304, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(18330984, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(24235104, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"gcCount\")));\n\n    // hbase master\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"HBASE_MASTER\");\n\n    // only ask for specific properties\n    properties = new HashSet<String>();\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/load\", \"AverageLoad\"));\n    request = PropertyHelper.getReadRequest(properties);\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:60010\"), streamProvider.getLastSpec());\n\n    Assert.assertEquals(7, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(1069416448, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(4806976, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(28971240, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n    Assert.assertEquals(3.0, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/load\", \"AverageLoad\")));\n\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"gcCount\")));\n  }","id":101446,"modified_method":"@Test\n  public void testGetResources() throws Exception {\n    TestStreamProvider  streamProvider = new TestStreamProvider();\n    TestJMXHostProvider hostProvider = new TestJMXHostProvider();\n\n    JMXPropertyProvider propertyProvider = new JMXPropertyProvider(\n        PropertyHelper.getJMXPropertyIds(Resource.Type.HostComponent),\n        streamProvider,\n        hostProvider, PropertyHelper.getPropertyId(\"HostRoles\", \"cluster_name\"), PropertyHelper.getPropertyId(\"HostRoles\", \"host_name\"), PropertyHelper.getPropertyId(\"HostRoles\", \"component_name\"));\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-0e-34-e1.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"NAMENODE\");\n\n    // request with an empty set should get all supported properties\n    Request request = PropertyHelper.getReadRequest(Collections.<String>emptySet());\n\n    Assert.assertEquals(1, propertyProvider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-0e-34-e1.compute-1.internal:50070\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_namenode_jmx.json for values\n    Assert.assertEquals(13670605,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/rpc\", \"ReceivedBytes\")));\n    Assert.assertEquals(28,      resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/dfs/namenode\", \"CreateFileOps\")));\n    Assert.assertEquals(1006632960, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(473433016, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(23634400, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n\n\n    // datanode\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // request with an empty set should get all supported properties\n    request = PropertyHelper.getReadRequest(Collections.<String>emptySet());\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:50075\"), streamProvider.getLastSpec());\n\n    // see test/resources/hdfs_datanode_jmx.json for values\n    Assert.assertEquals(856,  resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/rpc\", \"ReceivedBytes\")));\n    Assert.assertEquals(954466304, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(9772616, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(21933376, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n\n\n    // jobtracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"JOBTRACKER\");\n\n    // only ask for specific properties\n    Set<String> properties = new HashSet<String>();\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"threadsWaiting\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/jobtracker\", \"jobs_submitted\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/jobtracker\", \"jobs_completed\"));\n\n    request = PropertyHelper.getReadRequest(properties);\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:50030\"), streamProvider.getLastSpec());\n\n    // see test/resources/mapreduce_jobtracker_jmx.json for values\n    Assert.assertEquals(9, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(59, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"threadsWaiting\")));\n    Assert.assertEquals(1052770304, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(43580400, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(29602888, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n    Assert.assertEquals(1, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/jobtracker\", \"jobs_submitted\")));\n    Assert.assertEquals(1, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/jobtracker\", \"jobs_completed\")));\n\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"gcCount\")));\n\n    // tasktracker\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"TASKTRACKER\");\n\n    // only ask for specific properties\n    properties = new HashSet<String>();\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_exceptions_caught\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_failed_outputs\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_output_bytes\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_success_outputs\"));\n\n    request = PropertyHelper.getReadRequest(properties);\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:50060\"), streamProvider.getLastSpec());\n\n    Assert.assertEquals(10, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(954466304, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(18330984, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(24235104, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n    Assert.assertEquals(0, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_exceptions_caught\")));\n    Assert.assertEquals(0, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_failed_outputs\")));\n    Assert.assertEquals(1841, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_output_bytes\")));\n    Assert.assertEquals(1, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/mapred/shuffleOutput\", \"shuffle_success_outputs\")));\n\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"gcCount\")));\n\n    // hbase master\n    resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(HOST_COMPONENT_HOST_NAME_PROPERTY_ID, \"domu-12-31-39-14-ee-b3.compute-1.internal\");\n    resource.setProperty(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID, \"HBASE_MASTER\");\n\n    // only ask for specific properties\n    properties = new HashSet<String>();\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\"));\n    properties.add(PropertyHelper.getPropertyId(\"metrics/load\", \"AverageLoad\"));\n    request = PropertyHelper.getReadRequest(properties);\n\n    propertyProvider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(propertyProvider.getSpec(\"domu-12-31-39-14-ee-b3.compute-1.internal:60010\"), streamProvider.getLastSpec());\n\n    Assert.assertEquals(7, PropertyHelper.getProperties(resource).size());\n    Assert.assertEquals(1069416448, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryMax\")));\n    Assert.assertEquals(4806976, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"HeapMemoryUsed\")));\n    Assert.assertEquals(136314880, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryMax\")));\n    Assert.assertEquals(28971240, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"NonHeapMemoryUsed\")));\n    Assert.assertEquals(3.0, resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/load\", \"AverageLoad\")));\n\n    Assert.assertNull(resource.getPropertyValue(PropertyHelper.getPropertyId(\"metrics/jvm\", \"gcCount\")));\n  }","commit_id":"a4e7d8bc258f8ef539ee48b3e56901a615018c47","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Set<Resource> populateResources(Set<Resource> resources, Request request, Predicate predicate)\n      throws SystemException {\n    Set<Resource> keepers = new HashSet<Resource>();\n    try {\n      Connection connection = connectionFactory.getConnection();\n      try {\n        PreparedStatement preparedStatement = connection.prepareStatement(GET_METRICS_STATEMENT);\n        try {\n          for (Resource resource : resources) {\n            if (populateResource(resource, request, predicate, preparedStatement)) {\n              keepers.add(resource);\n            }\n          }\n        } finally {\n          preparedStatement.close();\n        }\n      } finally {\n        connection.close();\n      }\n    } catch (SQLException e) {\n      if (LOG.isErrorEnabled()) {\n        LOG.error(\"Error during populateResources call : caught exception\", e);\n      }\n      throw new SystemException(\"Error during populateResources call : caught exception\", e);\n    }\n    return keepers;\n  }","id":101447,"modified_method":"@Override\n  public Set<Resource> populateResources(Set<Resource> resources, Request request, Predicate predicate)\n      throws SystemException {\n    Set<Resource> keepers = new HashSet<Resource>();\n    try {\n      Connection connection = connectionFactory.getConnection();\n      try {\n        Statement statement = connection.createStatement();\n        try {\n          for (Resource resource : resources) {\n            if (populateResource(resource, request, predicate, statement)) {\n              keepers.add(resource);\n            }\n          }\n        } finally {\n          statement.close();\n        }\n      } finally {\n        connection.close();\n      }\n    } catch (SQLException e) {\n      if (LOG.isErrorEnabled()) {\n        LOG.error(\"Error during populateResources call : caught exception\", e);\n      }\n      throw new SystemException(\"Error during populateResources call : caught exception\", e);\n    }\n    return keepers;\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"private boolean populateResource(Resource resource, Request request, Predicate predicate, PreparedStatement preparedStatement) throws SystemException {\n\n    Set<String> ids = getRequestPropertyIds(request, predicate);\n    if (ids.isEmpty()) {\n      // no properties requested ... nothing to do.\n      return true;\n    }\n\n    String componentName = (String) resource.getPropertyValue(componentNamePropertyId);\n\n    if (getComponentMetrics().get(componentName) == null) {\n      // no metrics defined for the given component ... nothing to do.\n      return true;\n    }\n\n    String clusterName = (String) resource.getPropertyValue(clusterNamePropertyId);\n    String hostName    = getHost(resource, clusterName, componentName);\n\n    if (hostName == null) {\n      throw new SystemException(\n          \"Unable to get metrics.  No host name for \" + componentName, null);\n    }\n\n    for (String id : ids) {\n      Map<String, PropertyInfo> propertyInfoMap = getPropertyInfoMap(componentName, id);\n\n      for (Map.Entry<String, PropertyInfo> entry: propertyInfoMap.entrySet()) {\n        String       propertyKey  = entry.getKey();\n        PropertyInfo propertyInfo = entry.getValue();\n        String       propertyId   = propertyInfo.getPropertyId();\n        TemporalInfo temporalInfo = request.getTemporalInfo(id);\n\n        if ((propertyInfo.isPointInTime() && temporalInfo == null) ||\n            (propertyInfo.isTemporal()    && temporalInfo != null)) {\n\n          long startTime;\n          long endTime;\n\n          if (temporalInfo != null) {\n            Long endTimeSeconds = temporalInfo.getEndTime();\n\n            endTime   = endTimeSeconds != -1 ? endTimeSeconds * 1000 : Long.MAX_VALUE;\n            startTime = temporalInfo.getStartTime() * 1000;\n          } else {\n            startTime = 0L;\n            endTime   = Long.MAX_VALUE;\n          }\n\n          String[] parts = propertyId.split(\"\\\\.\");\n          int      size  = parts.length;\n\n          if (size >= 3) {\n            List<DataPoint> dataPoints = getMetric(startTime, endTime, parts[size - 3], parts[size - 2], parts[size - 1],\n                                                   componentName.toLowerCase(), hostName, preparedStatement);\n\n            if (dataPoints != null) {\n              if (temporalInfo == null){\n                // return the value of the last data point\n                int          length = dataPoints.size();\n                Serializable value  = length > 0 ? dataPoints.get(length - 1).getValue() : 0;\n                resource.setProperty(propertyKey, value);\n              } else {\n\n                Number[][] dp = new Number[dataPoints.size()][2];\n                for (int i = 0; i < dp.length; i++) {\n                  dp[i][0] = dataPoints.get(i).getValue();\n                  dp[i][1] = dataPoints.get(i).getTimestamp();\n                }\n                resource.setProperty(propertyKey, dp);\n              }\n            }\n          } else {\n            if (LOG.isWarnEnabled()) {\n              LOG.warn(\"Can't get metrics for \" + id + \" : \" + propertyId);\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","id":101448,"modified_method":"private boolean populateResource(Resource resource, Request request, Predicate predicate, Statement statement) throws SystemException {\n\n    Set<String> ids = getRequestPropertyIds(request, predicate);\n    if (ids.isEmpty()) {\n      // no properties requested ... nothing to do.\n      return true;\n    }\n\n    String componentName = (String) resource.getPropertyValue(componentNamePropertyId);\n\n    if (getComponentMetrics().get(componentName) == null) {\n      // no metrics defined for the given component ... nothing to do.\n      return true;\n    }\n\n    String clusterName = (String) resource.getPropertyValue(clusterNamePropertyId);\n    String hostName    = getHost(resource, clusterName, componentName);\n\n    if (hostName == null) {\n      throw new SystemException(\n          \"Unable to get metrics.  No host name for \" + componentName, null);\n    }\n\n    Set<MetricDefinition> metricsDefinitionSet = new HashSet<MetricDefinition>();\n    for (String id : ids) {\n      Map<String, PropertyInfo> propertyInfoMap = getPropertyInfoMap(componentName, id);\n\n      for (Map.Entry<String, PropertyInfo> entry: propertyInfoMap.entrySet()) {\n        String       propertyKey  = entry.getKey();\n        PropertyInfo propertyInfo = entry.getValue();\n        String       propertyId   = propertyInfo.getPropertyId();\n        TemporalInfo temporalInfo = request.getTemporalInfo(id);\n\n        if ((propertyInfo.isPointInTime() && temporalInfo == null) ||\n            (propertyInfo.isTemporal()    && temporalInfo != null)) {\n\n          long startTime;\n          long endTime;\n\n          if (temporalInfo != null) {\n            Long endTimeSeconds = temporalInfo.getEndTime();\n\n            endTime   = endTimeSeconds != -1 ? endTimeSeconds * 1000 : Long.MAX_VALUE;\n            startTime = temporalInfo.getStartTime() * 1000;\n          } else {\n            startTime = 0L;\n            endTime   = Long.MAX_VALUE;\n          }\n\n          String[] parts = propertyId.split(\"\\\\.\");\n          int      size  = parts.length;\n\n          if (size >= 3) {\n\n            metricsDefinitionSet.add(\n                    new MetricDefinition(\n                            startTime,\n                            endTime,\n                            parts[size - 3],\n                            parts[size - 2],\n                            parts[size - 1],\n                            componentName.toLowerCase(),\n                            hostName,\n                            propertyKey,\n                            temporalInfo)\n            );\n\n          } else {\n            if (LOG.isWarnEnabled()) {\n              LOG.warn(\"Can't get metrics for \" + id + \" : \" + propertyId);\n            }\n          }\n        }\n      }\n    }\n\n    Map<MetricDefinition, List<DataPoint>> results = getMetric(metricsDefinitionSet, statement);\n\n    for(MetricDefinition metricDefinition : metricsDefinitionSet) {\n        List<DataPoint> dataPoints = results.containsKey(metricDefinition) ? results.get(metricDefinition) : new ArrayList<DataPoint>();\n        TemporalInfo temporalInfo = metricDefinition.getTemporalInfo();\n        String propertyKey = metricDefinition.getPropertyKey();\n        if (dataPoints != null) {\n          if (temporalInfo == null){\n            // return the value of the last data point\n            int length = dataPoints.size();\n            Serializable value  = length > 0 ? dataPoints.get(length - 1).getValue() : 0;\n            resource.setProperty(propertyKey, value);\n          } else {\n            Number[][] dp = new Number[dataPoints.size()][2];\n            for (int i = 0; i < dp.length; i++) {\n              dp[i][0] = dataPoints.get(i).getValue();\n              dp[i][1] = dataPoints.get(i).getTimestamp();\n            }\n            resource.setProperty(propertyKey, dp);\n          }\n      }\n    }\n\n    return true;\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testPopulateResources_hostNameProperty() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    PreparedStatement statement = createNiceMock(PreparedStatement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.prepareStatement((String) anyObject())).andReturn(statement).once();\n    expect(statement.executeQuery()).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    TestHostInfoProvider hostProvider = new TestHostInfoProvider();\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, -1L, -1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    provider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(\"domU-12-31-39-0E-34-E1.compute-1.internal\", hostProvider.getHostId());\n    Assert.assertNull(hostProvider.getClusterName());\n    Assert.assertNull(hostProvider.getComponentName());\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","id":101449,"modified_method":"@Test\n  public void testPopulateResources_hostNameProperty() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    Statement statement = createNiceMock(Statement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.createStatement()).andReturn(statement).once();\n    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    TestHostInfoProvider hostProvider = new TestHostInfoProvider();\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, -1L, -1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    provider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertEquals(\"domU-12-31-39-0E-34-E1.compute-1.internal\", hostProvider.getHostId());\n    Assert.assertNull(hostProvider.getClusterName());\n    Assert.assertNull(hostProvider.getComponentName());\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testPopulateResources_temporalStartTimeOnly() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    PreparedStatement statement = createNiceMock(PreparedStatement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.prepareStatement((String) anyObject())).andReturn(statement).once();\n    expect(statement.executeQuery()).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    TestHostInfoProvider hostProvider = new TestHostInfoProvider();\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, -1L, -1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertTrue(resource.getPropertyValue(PROPERTY_ID_1) instanceof Number[][]);\n\n    Number[][] datapoints = (Number[][]) resource.getPropertyValue(PROPERTY_ID_1);\n\n    for (int i = 0; i < datapoints.length; ++i) {\n      Assert.assertEquals((long) i, datapoints[i][0]);\n      Assert.assertEquals(999990L + i, datapoints[i][1]);\n    }\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","id":101450,"modified_method":"@Test\n  public void testPopulateResources_temporalStartTimeOnly() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    Statement statement = createNiceMock(Statement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.createStatement()).andReturn(statement).once();\n    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    TestHostInfoProvider hostProvider = new TestHostInfoProvider();\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, -1L, -1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertTrue(resource.getPropertyValue(PROPERTY_ID_1) instanceof Number[][]);\n\n    Number[][] datapoints = (Number[][]) resource.getPropertyValue(PROPERTY_ID_1);\n\n    for (int i = 0; i < datapoints.length; ++i) {\n      Assert.assertEquals((long) i, datapoints[i][0]);\n      Assert.assertEquals(999990L + i, datapoints[i][1]);\n    }\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testPopulateResources_noHostNameProperty() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    PreparedStatement statement = createNiceMock(PreparedStatement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.prepareStatement((String) anyObject())).andReturn(statement).once();\n    expect(statement.executeQuery()).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    TestHostInfoProvider hostProvider = new TestHostInfoProvider();\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        null,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, -1L, -1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    provider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertNull(hostProvider.getHostId());\n    Assert.assertEquals(\"c1\", hostProvider.getClusterName());\n    Assert.assertEquals(\"DATANODE\", hostProvider.getComponentName());\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","id":101451,"modified_method":"@Test\n  public void testPopulateResources_noHostNameProperty() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    Statement statement = createNiceMock(Statement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.createStatement()).andReturn(statement).once();\n    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    TestHostInfoProvider hostProvider = new TestHostInfoProvider();\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        hostProvider,\n        CLUSTER_NAME_PROPERTY_ID,\n        null,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, -1L, -1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    provider.populateResources(Collections.singleton(resource), request, null);\n\n    Assert.assertNull(hostProvider.getHostId());\n    Assert.assertEquals(\"c1\", hostProvider.getClusterName());\n    Assert.assertEquals(\"DATANODE\", hostProvider.getComponentName());\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testPopulateResources_multi() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    PreparedStatement statement = createNiceMock(PreparedStatement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.prepareStatement((String) anyObject())).andReturn(statement).once();\n    expect(statement.executeQuery()).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(false);\n\n    expect(statement.executeQuery()).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        new TestHostInfoProvider(),\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // ask for two properties ... on temporal, one point in time\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, 20L, 1L));\n\n    Set<String> propertyIds = new LinkedHashSet<String>();\n    propertyIds.add(PROPERTY_ID_1);\n    propertyIds.add(PROPERTY_ID_2);\n\n    Request request = PropertyHelper.getReadRequest(propertyIds, temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    // check the temporal value\n    Assert.assertTrue(resource.getPropertyValue(PROPERTY_ID_1) instanceof Number[][]);\n\n    Number[][] datapoints = (Number[][]) resource.getPropertyValue(PROPERTY_ID_1);\n\n    for (int i = 0; i < datapoints.length; ++i) {\n      Assert.assertEquals((long) i, datapoints[i][0]);\n      Assert.assertEquals(999990L + i, datapoints[i][1]);\n    }\n\n    // check the point in time value ... should be the last value of the time series...\n    Assert.assertEquals( 3L, resource.getPropertyValue(PROPERTY_ID_2));\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","id":101452,"modified_method":"@Test\n  public void testPopulateResources_multi() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    Statement statement = createNiceMock(Statement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.createStatement()).andReturn(statement).once();\n    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcQueueTime_avg_time\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcQueueTime_avg_time\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcSlowResponse_num_ops\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcSlowResponse_num_ops\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        new TestHostInfoProvider(),\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // ask for two properties ... on temporal, one point in time\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, 20L, 1L));\n\n    Set<String> propertyIds = new LinkedHashSet<String>();\n    propertyIds.add(PROPERTY_ID_1);\n    propertyIds.add(PROPERTY_ID_2);\n\n    Request request = PropertyHelper.getReadRequest(propertyIds, temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    // check the temporal value\n    Assert.assertTrue(resource.getPropertyValue(PROPERTY_ID_1) instanceof Number[][]);\n\n    Number[][] datapoints = (Number[][]) resource.getPropertyValue(PROPERTY_ID_1);\n\n    for (int i = 0; i < datapoints.length; ++i) {\n      Assert.assertEquals((long) i, datapoints[i][0]);\n      Assert.assertEquals(999990L + i, datapoints[i][1]);\n    }\n\n    // check the point in time value ... should be the last value of the time series...\n    Assert.assertEquals( 3L, resource.getPropertyValue(PROPERTY_ID_2));\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testPopulateResources() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    PreparedStatement statement = createNiceMock(PreparedStatement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.prepareStatement((String) anyObject())).andReturn(statement).once();\n    expect(statement.executeQuery()).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        new TestHostInfoProvider(),\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, 20L, 1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertTrue(resource.getPropertyValue(PROPERTY_ID_1) instanceof Number[][]);\n\n    Number[][] datapoints = (Number[][]) resource.getPropertyValue(PROPERTY_ID_1);\n\n    for (int i = 0; i < datapoints.length; ++i) {\n      Assert.assertEquals((long) i, datapoints[i][0]);\n      Assert.assertEquals(999990L + i, datapoints[i][1]);\n    }\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","id":101453,"modified_method":"@Test\n  public void testPopulateResources() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    Statement statement = createNiceMock(Statement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.createStatement()).andReturn(statement).once();\n    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        new TestHostInfoProvider(),\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    temporalInfoMap.put(PROPERTY_ID_1, new TemporalInfoImpl(10L, 20L, 1L));\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_1), temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    Assert.assertTrue(resource.getPropertyValue(PROPERTY_ID_1) instanceof Number[][]);\n\n    Number[][] datapoints = (Number[][]) resource.getPropertyValue(PROPERTY_ID_1);\n\n    for (int i = 0; i < datapoints.length; ++i) {\n      Assert.assertEquals((long) i, datapoints[i][0]);\n      Assert.assertEquals(999990L + i, datapoints[i][1]);\n    }\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testPopulateResources_pointInTime() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    PreparedStatement statement = createNiceMock(PreparedStatement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.prepareStatement((String) anyObject())).andReturn(statement).once();\n    expect(statement.executeQuery()).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        new TestHostInfoProvider(),\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_2), temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    // should be the last value of the time series...\n    Assert.assertEquals( 3L, resource.getPropertyValue(PROPERTY_ID_2));\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","id":101454,"modified_method":"@Test\n  public void testPopulateResources_pointInTime() throws Exception {\n\n    ConnectionFactory connectionFactory = createNiceMock(ConnectionFactory.class);\n    Connection connection = createNiceMock(Connection.class);\n    Statement statement = createNiceMock(Statement.class);\n    ResultSet resultSet = createNiceMock(ResultSet.class);\n\n    // set expectations\n    expect(connectionFactory.getConnection()).andReturn(connection).once();\n    expect(connection.createStatement()).andReturn(statement).once();\n    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet).once();\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcSlowResponse_num_ops\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"0\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999990L);\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcSlowResponse_num_ops\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"1\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999991L);\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcSlowResponse_num_ops\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"2\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999992L);\n    expect(resultSet.next()).andReturn(true);\n    expect(resultSet.getString(\"RecordTypeContext\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"RecordTypeName\")).andReturn(\"rpc\");\n    expect(resultSet.getString(\"MetricName\")).andReturn(\"RpcSlowResponse_num_ops\");\n    expect(resultSet.getString(\"ServiceName\")).andReturn(\"datanode\");\n    expect(resultSet.getString(\"NodeName\")).andReturn(\"host1\");\n    expect(resultSet.getNString(\"MetricValue\")).andReturn(\"3\");\n    expect(resultSet.getLong(\"RecordTimeStamp\")).andReturn(999993L);\n    expect(resultSet.next()).andReturn(false);\n\n    // replay\n    replay(connectionFactory, connection, statement, resultSet);\n\n    SQLPropertyProvider provider = new SQLPropertyProvider(\n        PropertyHelper.getGangliaPropertyIds(Resource.Type.HostComponent),\n        new TestHostInfoProvider(),\n        CLUSTER_NAME_PROPERTY_ID,\n        HOST_NAME_PROPERTY_ID,\n        COMPONENT_NAME_PROPERTY_ID,\n        connectionFactory);\n\n    // namenode\n    Resource resource = new ResourceImpl(Resource.Type.HostComponent);\n\n    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, \"c1\");\n    resource.setProperty(HOST_NAME_PROPERTY_ID, \"domU-12-31-39-0E-34-E1.compute-1.internal\");\n    resource.setProperty(COMPONENT_NAME_PROPERTY_ID, \"DATANODE\");\n\n    // only ask for one property\n    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();\n    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID_2), temporalInfoMap);\n\n    Assert.assertEquals(1, provider.populateResources(Collections.singleton(resource), request, null).size());\n\n    // should be the last value of the time series...\n    Assert.assertEquals( 3L, resource.getPropertyValue(PROPERTY_ID_2));\n\n    // verify\n    verify(connectionFactory, connection, statement, resultSet);\n  }","commit_id":"a3403e5d625657fd4494edc66c5cd64f45da5c55","url":"https://github.com/apache/ambari"},{"original_method":"@Path(\"/system/services\")\n  @GET\n  public void getServiceSpec(final HttpRequest request, final HttpResponder responder) {\n    List<Map<String, String>> serviceSpec = new ArrayList<Map<String, String>>();\n    String json;\n\n    for (String service : reactorServiceManagementMap.keySet()) {\n      Map<String, String> spec = new HashMap<String, String>();\n      ReactorServiceManager serviceManager = reactorServiceManagementMap.get(service);\n      String logs = serviceManager.isLogAvailable() ? Constants.Monitor.STATUS_OK : Constants.Monitor.STATUS_NOTOK;\n      String canCheck = serviceManager.canCheckStatus() ? (\n        serviceManager.isServiceAvailable() ? STATUSOK : STATUSNOTOK) : NOTAPPLICABLE;\n      String minInstance = String.valueOf(serviceManager.getMinInstances());\n      String maxInstance = String.valueOf(serviceManager.getMaxInstances());\n      String curInstance = String.valueOf(serviceManager.getInstances());\n      spec.put(\"name\", service);\n      spec.put(\"logs\", logs);\n      spec.put(\"status\", canCheck);\n      spec.put(\"min\", minInstance);\n      spec.put(\"max\", maxInstance);\n      spec.put(\"cur\", curInstance);\n      //TODO: Add metric name for Event Rate monitoring\n      serviceSpec.add(spec);\n    }\n\n    json = (new Gson()).toJson(serviceSpec);\n    responder.sendByteArray(HttpResponseStatus.OK, json.getBytes(Charsets.UTF_8),\n                            ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE, \"application/json\"));\n  }","id":101455,"modified_method":"@Path(\"/system/services\")\n  @GET\n  public void getServiceSpec(final HttpRequest request, final HttpResponder responder) {\n    List<Map<String, String>> serviceSpec = new ArrayList<Map<String, String>>();\n    String json;\n    SortedSet<String> services = new TreeSet<String>(reactorServiceManagementMap.keySet());\n    List<String> serviceList = new ArrayList<String>(services);\n    for (String service : serviceList) {\n      Map<String, String> spec = new HashMap<String, String>();\n      ReactorServiceManager serviceManager = reactorServiceManagementMap.get(service);\n      String logs = serviceManager.isLogAvailable() ? Constants.Monitor.STATUS_OK : Constants.Monitor.STATUS_NOTOK;\n      String canCheck = serviceManager.canCheckStatus() ? (\n        serviceManager.isServiceAvailable() ? STATUSOK : STATUSNOTOK) : NOTAPPLICABLE;\n      String minInstance = String.valueOf(serviceManager.getMinInstances());\n      String maxInstance = String.valueOf(serviceManager.getMaxInstances());\n      String curInstance = String.valueOf(serviceManager.getInstances());\n      spec.put(\"name\", service);\n      spec.put(\"logs\", logs);\n      spec.put(\"status\", canCheck);\n      spec.put(\"min\", minInstance);\n      spec.put(\"max\", maxInstance);\n      spec.put(\"cur\", curInstance);\n      //TODO: Add metric name for Event Rate monitoring\n      serviceSpec.add(spec);\n    }\n\n    json = (new Gson()).toJson(serviceSpec);\n    responder.sendByteArray(HttpResponseStatus.OK, json.getBytes(Charsets.UTF_8),\n                            ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE, \"application/json\"));\n  }","commit_id":"4c44aabe9063b09ace109d441b719184f607b48f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Path(\"/system/services\")\n  @GET\n  public void getServiceSpec(final HttpRequest request, final HttpResponder responder) {\n    List<Map<String, String>> serviceSpec = new ArrayList<Map<String, String>>();\n    String json;\n\n    for (String service : reactorServiceManagementMap.keySet()) {\n      Map<String, String> spec = new HashMap<String, String>();\n      ReactorServiceManager serviceManager = reactorServiceManagementMap.get(service);\n      String logs = serviceManager.isLogAvailable() ? Constants.Monitor.STATUS_OK : Constants.Monitor.STATUS_NOTOK;\n      String canCheck = serviceManager.canCheckStatus() ? (\n        serviceManager.isServiceAvailable() ? STATUSOK : STATUSNOTOK) : NOTAPPLICABLE;\n      String minInstance = String.valueOf(serviceManager.getMinInstances());\n      String maxInstance = String.valueOf(serviceManager.getMaxInstances());\n      String curInstance = String.valueOf(serviceManager.getInstances());\n      spec.put(\"name\", service);\n      spec.put(\"logs\", logs);\n      spec.put(\"status\", canCheck);\n      spec.put(\"min\", minInstance);\n      spec.put(\"max\", maxInstance);\n      spec.put(\"cur\", curInstance);\n      //TODO: Add metric name for Event Rate monitoring\n      serviceSpec.add(spec);\n    }\n\n    json = (new Gson()).toJson(serviceSpec);\n    responder.sendByteArray(HttpResponseStatus.OK, json.getBytes(Charsets.UTF_8),\n                            ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE, \"application/json\"));\n  }","id":101456,"modified_method":"@Path(\"/system/services\")\n  @GET\n  public void getServiceSpec(final HttpRequest request, final HttpResponder responder) {\n    List<Map<String, String>> serviceSpec = new ArrayList<Map<String, String>>();\n    String json;\n    SortedSet<String> services = new TreeSet<String>(reactorServiceManagementMap.keySet());\n    List<String> serviceList = new ArrayList<String>(services);\n    for (String service : serviceList) {\n      Map<String, String> spec = new HashMap<String, String>();\n      ReactorServiceManager serviceManager = reactorServiceManagementMap.get(service);\n      String logs = serviceManager.isLogAvailable() ? Constants.Monitor.STATUS_OK : Constants.Monitor.STATUS_NOTOK;\n      String canCheck = serviceManager.canCheckStatus() ? (\n        serviceManager.isServiceAvailable() ? STATUSOK : STATUSNOTOK) : NOTAPPLICABLE;\n      String minInstance = String.valueOf(serviceManager.getMinInstances());\n      String maxInstance = String.valueOf(serviceManager.getMaxInstances());\n      String curInstance = String.valueOf(serviceManager.getInstances());\n      spec.put(\"name\", service);\n      spec.put(\"logs\", logs);\n      spec.put(\"status\", canCheck);\n      spec.put(\"min\", minInstance);\n      spec.put(\"max\", maxInstance);\n      spec.put(\"cur\", curInstance);\n      //TODO: Add metric name for Event Rate monitoring\n      serviceSpec.add(spec);\n    }\n\n    json = (new Gson()).toJson(serviceSpec);\n    responder.sendByteArray(HttpResponseStatus.OK, json.getBytes(Charsets.UTF_8),\n                            ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE, \"application/json\"));\n  }","commit_id":"c265a74abd453d02c9bc5022f30bf4c403057ea7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n    public void testWriteBlock() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(10000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        _writeCount = 10000;\n        String data = \"Now is the time for all good men to come to the aid of the party\";\n        client.getOutputStream().write(data.getBytes(\"UTF-8\"));\n        BufferedInputStream in = new BufferedInputStream(client.getInputStream());\n\n        for (int i = 0; i < _writeCount; i++)\n        {\n            if (i % 1000 == 0)\n            {\n                //System.out.println(i);\n                TimeUnit.MILLISECONDS.sleep(200);\n            }\n            // Verify echo server to client\n            for (int j = 0; j < data.length(); j++)\n            {\n                char c = data.charAt(j);\n                int b = in.read();\n                assertTrue(b > 0);\n                assertEquals(\"test-\" + i + \"/\" + j, c, (char)b);\n            }\n            if (i == 0)\n                _lastEndp.setIdleTimeout(60000);\n        }\n\n\n        client.close();\n\n        int i = 0;\n        while (server.isOpen())\n        {\n            assert (i++ < 10);\n            Thread.sleep(10);\n        }\n    }","id":101457,"modified_method":"@Test\n    public void testWriteBlock() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(10000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        _writeCount = 10000;\n        String data = \"Now is the time for all good men to come to the aid of the party\";\n        client.getOutputStream().write(data.getBytes(\"UTF-8\"));\n        BufferedInputStream in = new BufferedInputStream(client.getInputStream());\n\n        for (int i = 0; i < _writeCount; i++)\n        {\n            if (i % 1000 == 0)\n                TimeUnit.MILLISECONDS.sleep(200);\n\n            // Verify echo server to client\n            for (int j = 0; j < data.length(); j++)\n            {\n                char c = data.charAt(j);\n                int b = in.read();\n                assertTrue(b > 0);\n                assertEquals(\"test-\" + i + \"/\" + j, c, (char)b);\n            }\n\n            if (i == 0)\n                _lastEndp.setIdleTimeout(60000);\n        }\n\n        client.close();\n\n        for (int i = 0; i < 10; ++i)\n        {\n            if (server.isOpen())\n                Thread.sleep(10);\n            else\n                break;\n        }\n        Assert.assertFalse(server.isOpen());\n    }","commit_id":"929defa465d82b66a6951f8b7f155c4fbbbffe6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void testBlockRead() throws Exception\n    {\n        super.testBlockRead();\n    }","id":101458,"modified_method":"@Override\n    public void testReadBlocked() throws Exception\n    {\n        super.testReadBlocked();\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void testBlockedReadIdle() throws Exception\n    {\n        Socket client = newClient();\n        OutputStream clientOutputStream = client.getOutputStream();\n\n        client.setSoTimeout(5000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        clientOutputStream.write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b>0);\n            assertEquals(c,(char)b);\n        }\n\n        // Set Max idle\n        _lastEndp.setIdleTimeout(500);\n\n        // Write 8 and cause block waiting for 10\n        _blockAt=10;\n        clientOutputStream.write(\"12345678\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        // read until idle shutdown received\n        long start=System.currentTimeMillis();\n        int b=client.getInputStream().read();\n        assertEquals(-1,b);\n        long idle=System.currentTimeMillis()-start;\n        assertTrue(idle>400);\n        assertTrue(idle<2000);\n\n        Thread.sleep(1000);\n\n        assertFalse(_lastEndp.isOpen());\n    }","id":101459,"modified_method":"@Override\n    public void testBlockedReadIdle() throws Exception\n    {\n        Socket client = newClient();\n        OutputStream clientOutputStream = client.getOutputStream();\n\n        client.setSoTimeout(5000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        clientOutputStream.write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b>0);\n            assertEquals(c,(char)b);\n        }\n\n        assertTrue(_lastEndPointLatch.await(1, TimeUnit.SECONDS));\n        _lastEndPoint.setIdleTimeout(500);\n\n        // Write 8 and cause block waiting for 10\n        _blockAt=10;\n        clientOutputStream.write(\"12345678\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        // read until idle shutdown received\n        long start=System.currentTimeMillis();\n        int b=client.getInputStream().read();\n        assertEquals(-1,b);\n        long idle=System.currentTimeMillis()-start;\n        assertTrue(idle>400);\n        assertTrue(idle<2000);\n\n        Thread.sleep(1000);\n\n        assertFalse(_lastEndPoint.isOpen());\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    @Override\n    public void testWriteBlock() throws Exception\n    {\n        super.testWriteBlock();\n    }","id":101460,"modified_method":"@Test\n    @Override\n    public void testWriteBlocked() throws Exception\n    {\n        super.testWriteBlocked();\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testWriteBlock() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(10000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        _writeCount = 10000;\n        String data = \"Now is the time for all good men to come to the aid of the party\";\n        client.getOutputStream().write(data.getBytes(\"UTF-8\"));\n        BufferedInputStream in = new BufferedInputStream(client.getInputStream());\n\n        for (int i = 0; i < _writeCount; i++)\n        {\n            if (i % 1000 == 0)\n                TimeUnit.MILLISECONDS.sleep(200);\n\n            // Verify echo server to client\n            for (int j = 0; j < data.length(); j++)\n            {\n                char c = data.charAt(j);\n                int b = in.read();\n                assertTrue(b > 0);\n                assertEquals(\"test-\" + i + \"/\" + j, c, (char)b);\n            }\n\n            if (i == 0)\n                _lastEndp.setIdleTimeout(60000);\n        }\n\n        client.close();\n\n        for (int i = 0; i < 10; ++i)\n        {\n            if (server.isOpen())\n                Thread.sleep(10);\n            else\n                break;\n        }\n        Assert.assertFalse(server.isOpen());\n    }","id":101461,"modified_method":"@Test\n    public void testWriteBlocked() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(10000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        _writeCount = 10000;\n        String data = \"Now is the time for all good men to come to the aid of the party\";\n        client.getOutputStream().write(data.getBytes(\"UTF-8\"));\n        BufferedInputStream in = new BufferedInputStream(client.getInputStream());\n\n        for (int i = 0; i < _writeCount; i++)\n        {\n            if (i % 1000 == 0)\n                TimeUnit.MILLISECONDS.sleep(200);\n\n            // Verify echo server to client\n            for (int j = 0; j < data.length(); j++)\n            {\n                char c = data.charAt(j);\n                int b = in.read();\n                assertTrue(b > 0);\n                assertEquals(\"test-\" + i + \"/\" + j, c, (char)b);\n            }\n\n            if (i == 0)\n                _lastEndPoint.setIdleTimeout(60000);\n        }\n\n        client.close();\n\n        for (int i = 0; i < 10; ++i)\n        {\n            if (server.isOpen())\n                Thread.sleep(10);\n            else\n                break;\n        }\n        assertFalse(server.isOpen());\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testBlockedReadIdle() throws Exception\n    {\n        Socket client = newClient();\n        OutputStream clientOutputStream = client.getOutputStream();\n\n        client.setSoTimeout(5000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        clientOutputStream.write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        // Set Max idle\n        _lastEndp.setIdleTimeout(500);\n\n        // Write 8 and cause block waiting for 10\n        _blockAt = 10;\n        clientOutputStream.write(\"12345678\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        // read until idle shutdown received\n        long start = System.currentTimeMillis();\n        int b = client.getInputStream().read();\n        assertEquals('E', b);\n        long idle = System.currentTimeMillis() - start;\n        assertTrue(idle > 400);\n        assertTrue(idle < 2000);\n\n        for (char c : \"E: 12345678\".toCharArray())\n        {\n            b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        // But endpoint is still open.\n        assertTrue(_lastEndp.isOpen());\n\n        // Wait for another idle callback\n        Thread.sleep(2000);\n        // endpoint is closed.\n\n        assertFalse(_lastEndp.isOpen());\n    }","id":101462,"modified_method":"@Test\n    public void testBlockedReadIdle() throws Exception\n    {\n        Socket client = newClient();\n        OutputStream clientOutputStream = client.getOutputStream();\n\n        client.setSoTimeout(5000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        clientOutputStream.write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        Assert.assertTrue(_lastEndPointLatch.await(1, TimeUnit.SECONDS));\n        int idleTimeout = 500;\n        _lastEndPoint.setIdleTimeout(idleTimeout);\n\n        // Write 8 and cause block waiting for 10\n        _blockAt = 10;\n        clientOutputStream.write(\"12345678\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        // read until idle shutdown received\n        long start = System.currentTimeMillis();\n        int b = client.getInputStream().read();\n        assertEquals('E', b);\n        long idle = System.currentTimeMillis() - start;\n        assertTrue(idle > idleTimeout / 2);\n        assertTrue(idle < idleTimeout * 2);\n\n        for (char c : \"E: 12345678\".toCharArray())\n        {\n            b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        // But endpoint is still open.\n        assertTrue(_lastEndPoint.isOpen());\n\n        // Wait for another idle callback\n        Thread.sleep(idleTimeout * 2);\n        // endpoint is closed.\n\n        assertFalse(_lastEndPoint.isOpen());\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testEcho() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(600000); // TODO: restore to smaller value\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        client.getOutputStream().write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        // wait for read timeout\n        client.setSoTimeout(500);\n        long start = System.currentTimeMillis();\n        try\n        {\n            client.getInputStream().read();\n            Assert.fail();\n        }\n        catch (SocketTimeoutException e)\n        {\n            long duration = System.currentTimeMillis() - start;\n            Assert.assertThat(\"timeout duration\", duration, greaterThanOrEqualTo(400L));\n        }\n\n        // write then shutdown\n        client.getOutputStream().write(\"Goodbye Cruel TLS\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"Goodbye Cruel TLS\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            Assert.assertThat(\"expect valid char integer\", b, greaterThan(0));\n            assertEquals(\"expect characters to be same\", c, (char)b);\n        }\n        client.close();\n\n        int i = 0;\n        while (server.isOpen())\n        {\n            Thread.sleep(10);\n            if (++i == 10)\n                Assert.fail();\n        }\n    }","id":101463,"modified_method":"@Test\n    public void testEcho() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(600000); // TODO: restore to smaller value\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        client.getOutputStream().write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        // wait for read timeout\n        client.setSoTimeout(500);\n        long start = System.currentTimeMillis();\n        try\n        {\n            client.getInputStream().read();\n            Assert.fail();\n        }\n        catch (SocketTimeoutException e)\n        {\n            long duration = System.currentTimeMillis() - start;\n            Assert.assertThat(\"timeout duration\", duration, greaterThanOrEqualTo(400L));\n        }\n\n        // write then shutdown\n        client.getOutputStream().write(\"Goodbye Cruel TLS\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"Goodbye Cruel TLS\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            Assert.assertThat(\"expect valid char integer\", b, greaterThan(0));\n            assertEquals(\"expect characters to be same\", c, (char)b);\n        }\n        client.close();\n\n        for (int i = 0; i < 10; ++i)\n        {\n            if (server.isOpen())\n                Thread.sleep(10);\n            else\n                break;\n        }\n        assertFalse(server.isOpen());\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testIdle() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(3000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        client.getOutputStream().write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        // Set Max idle\n        _lastEndp.setIdleTimeout(500);\n\n        // read until idle shutdown received\n        long start = System.currentTimeMillis();\n        int b = client.getInputStream().read();\n        assertEquals(-1, b);\n        long idle = System.currentTimeMillis() - start;\n        assertTrue(idle > 400);\n        assertTrue(idle < 2000);\n\n        // But endpoint may still be open for a little bit.\n        if (_lastEndp.isOpen())\n            Thread.sleep(2000);\n\n        // endpoint is closed.\n        assertFalse(_lastEndp.isOpen());\n    }","id":101464,"modified_method":"@Test\n    public void testIdle() throws Exception\n    {\n        Socket client = newClient();\n\n        client.setSoTimeout(3000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        // Write client to server\n        client.getOutputStream().write(\"HelloWorld\".getBytes(\"UTF-8\"));\n\n        // Verify echo server to client\n        for (char c : \"HelloWorld\".toCharArray())\n        {\n            int b = client.getInputStream().read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n\n        Assert.assertTrue(_lastEndPointLatch.await(1, TimeUnit.SECONDS));\n        int idleTimeout = 500;\n        _lastEndPoint.setIdleTimeout(idleTimeout);\n\n        // read until idle shutdown received\n        long start = System.currentTimeMillis();\n        int b = client.getInputStream().read();\n        assertEquals(-1, b);\n        long idle = System.currentTimeMillis() - start;\n        assertTrue(idle > idleTimeout / 2);\n        assertTrue(idle < idleTimeout * 2);\n\n        // But endpoint may still be open for a little bit.\n        for (int i = 0; i < 10; ++i)\n        {\n            if (_lastEndPoint.isOpen())\n                Thread.sleep(2 * idleTimeout / 10);\n            else\n                break;\n        }\n        assertFalse(_lastEndPoint.isOpen());\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testBlockRead() throws Exception\n    {\n        Socket client = newClient();\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        OutputStream clientOutputStream = client.getOutputStream();\n        InputStream clientInputStream = client.getInputStream();\n\n        int specifiedTimeout = 1000;\n        client.setSoTimeout(specifiedTimeout);\n\n        // Write 8 and cause block waiting for 10\n        _blockAt = 10;\n        clientOutputStream.write(\"12345678\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        long wait = System.currentTimeMillis() + 1000;\n        while (_lastEndp == null && System.currentTimeMillis() < wait)\n            Thread.yield();\n\n        _lastEndp.setIdleTimeout(10 * specifiedTimeout);\n        Thread.sleep((11 * specifiedTimeout) / 10);\n\n        long start = System.currentTimeMillis();\n        try\n        {\n            int b = clientInputStream.read();\n            Assert.fail(\"Should have timed out waiting for a response, but read \" + b);\n        }\n        catch (SocketTimeoutException e)\n        {\n            int elapsed = Long.valueOf(System.currentTimeMillis() - start).intValue();\n            Assert.assertThat(\"Expected timeout\", elapsed, greaterThanOrEqualTo(3 * specifiedTimeout / 4));\n        }\n\n        // write remaining characters\n        clientOutputStream.write(\"90ABCDEF\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        // Verify echo server to client\n        for (char c : \"1234567890ABCDEF\".toCharArray())\n        {\n            int b = clientInputStream.read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n    }","id":101465,"modified_method":"@Test\n    public void testReadBlocked() throws Exception\n    {\n        Socket client = newClient();\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n\n        OutputStream clientOutputStream = client.getOutputStream();\n        InputStream clientInputStream = client.getInputStream();\n\n        int specifiedTimeout = 1000;\n        client.setSoTimeout(specifiedTimeout);\n\n        // Write 8 and cause block waiting for 10\n        _blockAt = 10;\n        clientOutputStream.write(\"12345678\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        Assert.assertTrue(_lastEndPointLatch.await(1, TimeUnit.SECONDS));\n        _lastEndPoint.setIdleTimeout(10 * specifiedTimeout);\n        Thread.sleep((11 * specifiedTimeout) / 10);\n\n        long start = System.currentTimeMillis();\n        try\n        {\n            int b = clientInputStream.read();\n            Assert.fail(\"Should have timed out waiting for a response, but read \" + b);\n        }\n        catch (SocketTimeoutException e)\n        {\n            int elapsed = Long.valueOf(System.currentTimeMillis() - start).intValue();\n            Assert.assertThat(\"Expected timeout\", elapsed, greaterThanOrEqualTo(3 * specifiedTimeout / 4));\n        }\n\n        // write remaining characters\n        clientOutputStream.write(\"90ABCDEF\".getBytes(\"UTF-8\"));\n        clientOutputStream.flush();\n\n        // Verify echo server to client\n        for (char c : \"1234567890ABCDEF\".toCharArray())\n        {\n            int b = clientInputStream.read();\n            assertTrue(b > 0);\n            assertEquals(c, (char)b);\n        }\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testStress() throws Exception\n    {\n        Socket client = newClient();\n        client.setSoTimeout(30000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n        final int writes = 200000;\n\n        final byte[] bytes = \"HelloWorld-\".getBytes(StringUtil.__UTF8_CHARSET);\n        byte[] count = \"0\\n\".getBytes(StringUtil.__UTF8_CHARSET);\n        BufferedOutputStream out = new BufferedOutputStream(client.getOutputStream());\n        final CountDownLatch latch = new CountDownLatch(writes);\n        final InputStream in = new BufferedInputStream(client.getInputStream());\n        final long start = System.currentTimeMillis();\n        out.write(bytes);\n        out.write(count);\n        out.flush();\n\n        while (_lastEndp == null)\n            Thread.sleep(10);\n        _lastEndp.setIdleTimeout(5000);\n\n        new Thread()\n        {\n            @Override\n            public void run()\n            {\n                Thread.currentThread().setPriority(MAX_PRIORITY);\n                long last = -1;\n                int count = -1;\n                try\n                {\n                    while (latch.getCount() > 0)\n                    {\n                        // Verify echo server to client\n                        for (byte b0 : bytes)\n                        {\n                            int b = in.read();\n                            Assert.assertThat(b, greaterThan(0));\n                            assertEquals(0xff & b0, b);\n                        }\n\n                        count = 0;\n                        int b = in.read();\n                        while (b > 0 && b != '\\n')\n                        {\n                            count = count * 10 + (b - '0');\n                            b = in.read();\n                        }\n                        last = System.currentTimeMillis();\n\n                        //if (latch.getCount()%1000==0)\n                        //    System.out.println(writes-latch.getCount());\n\n                        latch.countDown();\n                    }\n                }\n                catch (Throwable e)\n                {\n\n                    long now = System.currentTimeMillis();\n                    System.err.println(\"count=\" + count);\n                    System.err.println(\"latch=\" + latch.getCount());\n                    System.err.println(\"time=\" + (now - start));\n                    System.err.println(\"last=\" + (now - last));\n                    System.err.println(\"endp=\" + _lastEndp);\n                    System.err.println(\"conn=\" + _lastEndp.getAsyncConnection());\n\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n\n        // Write client to server\n        for (int i = 1; i < writes; i++)\n        {\n            out.write(bytes);\n            out.write(Integer.toString(i).getBytes(StringUtil.__ISO_8859_1_CHARSET));\n            out.write('\\n');\n            if (i % 1000 == 0)\n            {\n                //System.err.println(i+\"/\"+writes);\n                out.flush();\n            }\n            Thread.yield();\n        }\n        out.flush();\n\n        long last = latch.getCount();\n        while (!latch.await(5, TimeUnit.SECONDS))\n        {\n            //System.err.println(latch.getCount());\n            if (latch.getCount() == last)\n                Assert.fail();\n            last = latch.getCount();\n        }\n\n        assertEquals(0, latch.getCount());\n    }","id":101466,"modified_method":"@Test\n    public void testStress() throws Exception\n    {\n        Socket client = newClient();\n        client.setSoTimeout(30000);\n\n        SocketChannel server = _connector.accept();\n        server.configureBlocking(false);\n\n        _manager.accept(server);\n        final int writes = 200000;\n\n        final byte[] bytes = \"HelloWorld-\".getBytes(StringUtil.__UTF8_CHARSET);\n        byte[] count = \"0\\n\".getBytes(StringUtil.__UTF8_CHARSET);\n        BufferedOutputStream out = new BufferedOutputStream(client.getOutputStream());\n        final CountDownLatch latch = new CountDownLatch(writes);\n        final InputStream in = new BufferedInputStream(client.getInputStream());\n        final long start = System.currentTimeMillis();\n        out.write(bytes);\n        out.write(count);\n        out.flush();\n\n        Assert.assertTrue(_lastEndPointLatch.await(1, TimeUnit.SECONDS));\n        _lastEndPoint.setIdleTimeout(5000);\n\n        new Thread()\n        {\n            @Override\n            public void run()\n            {\n                Thread.currentThread().setPriority(MAX_PRIORITY);\n                long last = -1;\n                int count = -1;\n                try\n                {\n                    while (latch.getCount() > 0)\n                    {\n                        // Verify echo server to client\n                        for (byte b0 : bytes)\n                        {\n                            int b = in.read();\n                            Assert.assertThat(b, greaterThan(0));\n                            assertEquals(0xff & b0, b);\n                        }\n\n                        count = 0;\n                        int b = in.read();\n                        while (b > 0 && b != '\\n')\n                        {\n                            count = count * 10 + (b - '0');\n                            b = in.read();\n                        }\n                        last = System.currentTimeMillis();\n\n                        //if (latch.getCount()%1000==0)\n                        //    System.out.println(writes-latch.getCount());\n\n                        latch.countDown();\n                    }\n                }\n                catch (Throwable e)\n                {\n\n                    long now = System.currentTimeMillis();\n                    System.err.println(\"count=\" + count);\n                    System.err.println(\"latch=\" + latch.getCount());\n                    System.err.println(\"time=\" + (now - start));\n                    System.err.println(\"last=\" + (now - last));\n                    System.err.println(\"endp=\" + _lastEndPoint);\n                    System.err.println(\"conn=\" + _lastEndPoint.getAsyncConnection());\n\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n\n        // Write client to server\n        for (int i = 1; i < writes; i++)\n        {\n            out.write(bytes);\n            out.write(Integer.toString(i).getBytes(StringUtil.__ISO_8859_1_CHARSET));\n            out.write('\\n');\n            if (i % 1000 == 0)\n            {\n                //System.err.println(i+\"/\"+writes);\n                out.flush();\n            }\n            Thread.yield();\n        }\n        out.flush();\n\n        long last = latch.getCount();\n        while (!latch.await(5, TimeUnit.SECONDS))\n        {\n            //System.err.println(latch.getCount());\n            if (latch.getCount() == last)\n                Assert.fail();\n            last = latch.getCount();\n        }\n\n        assertEquals(0, latch.getCount());\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Before\n    public void startManager() throws Exception\n    {\n        _writeCount = 1;\n        _lastEndp = null;\n        _connector = ServerSocketChannel.open();\n        _connector.socket().bind(null);\n        _threadPool.start();\n        _manager.start();\n    }","id":101467,"modified_method":"@Before\n    public void startManager() throws Exception\n    {\n        _writeCount = 1;\n        _lastEndPoint = null;\n        _lastEndPointLatch = new CountDownLatch(1);\n        _connector = ServerSocketChannel.open();\n        _connector.socket().bind(null);\n        _threadPool.start();\n        _manager.start();\n    }","commit_id":"aa24693870b87ee19eb1d3f8c467aba23a3e88c1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void doOKAction() {\n    if (myUploadedPlugins != null) {\n      UpdateChecker.saveDisabledToUpdatePlugins();\n      if (UpdateChecker.install(myUploadedPlugins)) {\n        final ApplicationEx app = ApplicationManagerEx.getApplicationEx();\n        app.saveAll();\n        app.exit(true);\n      }\n    }\n    super.doOKAction();\n  }","id":101468,"modified_method":"protected void doOKAction() {\n    if (doDownloadAndPrepare()) {\n      final ApplicationEx app = ApplicationManagerEx.getApplicationEx();\n      app.saveAll();\n      app.exit(true);\n    }\n    super.doOKAction();\n  }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public UpdateUrlsImpl(Element element) {\n      if (element != null) {\n        myCheckingUrl = element.getAttributeValue(CHECK_ATTR);\n        myDownloadUrl = element.getAttributeValue(DOWNLOAD_ATTR);\n      }\n    }","id":101469,"modified_method":"public UpdateUrlsImpl(Element element) {\n      if (element != null) {\n        myCheckingUrl = element.getAttributeValue(CHECK_ATTR);\n        myPatchesUrl = element.getAttributeValue(PATCHES_ATTR);\n        myDownloadUrl = element.getAttributeValue(DOWNLOAD_ATTR);\n      }\n    }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static NewVersion checkForUpdates() throws ConnectionException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"enter: checkForUpdates()\");\n    }\n\n    final Document document;\n    try {\n      document = loadVersionInfo(getUpdateUrl());\n      if (document == null) return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      throw new ConnectionException(t);\n    }\n\n    final String availBuild = document.getRootElement().getChild(ELEMENT_BUILD).getTextTrim();\n    final String availVersion = document.getRootElement().getChild(ELEMENT_VERSION).getTextTrim();\n    String ourBuild = ApplicationInfo.getInstance().getBuildNumber().trim();\n    if (BUILD_NUMBER_STUB.equals(ourBuild)) ourBuild = Integer.toString(Integer.MAX_VALUE);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"build available:'\" + availBuild + \"' ourBuild='\" + ourBuild + \"' \");\n    }\n\n    try {\n      final int iAvailBuild = Integer.parseInt(availBuild);\n      final int iOurBuild = Integer.parseInt(ourBuild);\n      if (iAvailBuild > iOurBuild) {\n        return new NewVersion(iAvailBuild, availVersion);\n      }\n      return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      return null;\n    }\n    finally {\n      UpdateSettings.getInstance().LAST_TIME_CHECKED = System.currentTimeMillis();\n    }\n  }","id":101470,"modified_method":"@Nullable\n  public static NewVersion checkForUpdates() throws ConnectionException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"enter: checkForUpdates()\");\n    }\n\n    final Document document;\n    try {\n      document = loadVersionInfo(getUpdateUrl());\n      if (document == null) return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      throw new ConnectionException(t);\n    }\n\n    Element root = document.getRootElement();\n    final String availBuild = root.getChild(ELEMENT_BUILD).getTextTrim();\n    final String availVersion = root.getChild(ELEMENT_VERSION).getTextTrim();\n    String ourBuild = ApplicationInfo.getInstance().getBuildNumber().trim();\n    if (BUILD_NUMBER_STUB.equals(ourBuild)) ourBuild = Integer.toString(Integer.MAX_VALUE);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"build available:'\" + availBuild + \"' ourBuild='\" + ourBuild + \"' \");\n    }\n\n\n    Element patchElements = root.getChild(\"patches\");\n    List<PatchInfo> patches = new ArrayList<PatchInfo>();\n    if (patchElements != null) {\n      for (Element each : (List<Element>)patchElements.getChildren()) {\n        String fromBuild = each.getAttributeValue(\"from\").trim();\n        String toBuild = each.getAttributeValue(\"to\").trim();\n        String size = each.getAttributeValue(\"size\").trim();\n        patches.add(new PatchInfo(fromBuild, toBuild, size));\n      }\n    }\n\n    try {\n      final int iAvailBuild = Integer.parseInt(availBuild);\n      final int iOurBuild = Integer.parseInt(ourBuild);\n      if (iAvailBuild > iOurBuild) {\n        return new NewVersion(iAvailBuild, availVersion, patches);\n      }\n      return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      return null;\n    }\n    finally {\n      UpdateSettings.getInstance().LAST_TIME_CHECKED = System.currentTimeMillis();\n    }\n  }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getLatestBuild() {\n      return latestBuild;\n    }","id":101471,"modified_method":"public int getLatestBuild() {\n      return myLatestBuild;\n    }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getLatestVersion() {\n      return latestVersion;\n    }","id":101472,"modified_method":"public String getLatestVersion() {\n      return myLatestVersion;\n    }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NewVersion(int build, String version) {\n      latestBuild = build;\n      latestVersion = version;\n    }","id":101473,"modified_method":"public NewVersion(int build, String version, List<PatchInfo> patches) {\n      myLatestBuild = build;\n      myLatestVersion = version;\n      myPatches = patches;\n    }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getOkButtonText() {\n    return IdeBundle.message(\"updates.more.info.button\");\n  }","id":101474,"modified_method":"protected String getOkButtonText() {\n    return IdeBundle.message(\"updates.download.and.install.patch.button\");\n  }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public UpdateInfoPanel() {\n\n      final String build = ApplicationInfo.getInstance().getBuildNumber().trim();\n      myBuildNumber.setText(build + \")\");\n      final String majorVersion = ApplicationInfo.getInstance().getMajorVersion();\n      final String version;\n      if (majorVersion != null && majorVersion.trim().length() > 0) {\n        final String minorVersion = ApplicationInfo.getInstance().getMinorVersion();\n        if (minorVersion != null && minorVersion.trim().length() > 0) {\n          version = majorVersion + \".\" + minorVersion;\n        }\n        else {\n          version = majorVersion + \".0\";\n        }\n      }\n      else {\n        version = ApplicationInfo.getInstance().getVersionName();\n      }\n\n      myVersionNumber.setText(version);\n      myNewBuildNumber.setText(Integer.toString(myNewVersion.getLatestBuild()) + \")\");\n      myNewVersionNumber.setText(myNewVersion.getLatestVersion());\n\n      initPluginsPanel(myPanel, myUpdatedPluginsPanel, myWholePluginsPanel, myEditorPane);\n    }","id":101475,"modified_method":"public UpdateInfoPanel() {\n\n      final String build = ApplicationInfo.getInstance().getBuildNumber().trim();\n      myBuildNumber.setText(build + \")\");\n      final String majorVersion = ApplicationInfo.getInstance().getMajorVersion();\n      final String version;\n      if (majorVersion != null && majorVersion.trim().length() > 0) {\n        final String minorVersion = ApplicationInfo.getInstance().getMinorVersion();\n        if (minorVersion != null && minorVersion.trim().length() > 0) {\n          version = majorVersion + \".\" + minorVersion;\n        }\n        else {\n          version = majorVersion + \".0\";\n        }\n      }\n      else {\n        version = ApplicationInfo.getInstance().getVersionName();\n      }\n\n      myVersionNumber.setText(version);\n      myNewBuildNumber.setText(Integer.toString(myNewVersion.getLatestBuild()) + \")\");\n      myNewVersionNumber.setText(myNewVersion.getLatestVersion());\n\n      UpdateChecker.PatchInfo patch = myNewVersion.findPatchFor(build);\n      if (patch == null) {\n        myPatchAvailableLabel.setVisible(false);\n        myPatchSizeLabel.setVisible(false);\n      } else {\n        myPatchSizeLabel.setText(patch.getSize() + \"MB\");\n      }\n\n      initPluginsPanel(myPanel, myUpdatedPluginsPanel, myWholePluginsPanel, myEditorPane);\n    }","commit_id":"f10810172780e40b737fed1e93f63da82685d443","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Profile loadProfile(String path) throws IOException, JDOMException {\n    final File file = new File(path);\n    if (file.exists()){\n      InspectionProfileImpl profile = new InspectionProfileImpl(getProfileName(file), myRegistrar, this);\n      profile.load(JDOMUtil.loadDocument(file).getRootElement());\n      return profile;\n    }\n    return getProfile(path, false);\n  }","id":101476,"modified_method":"public Profile loadProfile(String path) throws IOException, JDOMException {\n    final File file = new File(path);\n    if (file.exists()){\n      InspectionProfileImpl profile = new InspectionProfileImpl(getProfileName(file), myRegistrar, this);\n      Element rootElement = JDOMUtil.loadDocument(file).getRootElement();\n      final Element profileElement = rootElement.getChild(\"profile\");\n      if (profileElement != null) {\n        rootElement = profileElement;\n      }\n      profile.load(rootElement);\n      return profile;\n    }\n    return getProfile(path, false);\n  }","commit_id":"ab07525d1342bde06d3f6c36d8cd08bf24f8d14e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction() {\n    if (myUploadedPlugins != null) {\n      UpdateChecker.saveDisabledToUpdatePlugins();\n      if (UpdateChecker.install(myUploadedPlugins)) {\n        final ApplicationEx app = ApplicationManagerEx.getApplicationEx();\n        app.saveAll();\n        app.exit(true);\n      }\n    }\n    super.doOKAction();\n  }","id":101477,"modified_method":"protected void doOKAction() {\n    if (doDownloadAndPrepare()) {\n      final ApplicationEx app = ApplicationManagerEx.getApplicationEx();\n      app.saveAll();\n      app.exit(true);\n    }\n    super.doOKAction();\n  }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public UpdateUrlsImpl(Element element) {\n      if (element != null) {\n        myCheckingUrl = element.getAttributeValue(CHECK_ATTR);\n        myDownloadUrl = element.getAttributeValue(DOWNLOAD_ATTR);\n      }\n    }","id":101478,"modified_method":"public UpdateUrlsImpl(Element element) {\n      if (element != null) {\n        myCheckingUrl = element.getAttributeValue(CHECK_ATTR);\n        myPatchesUrl = element.getAttributeValue(PATCHES_ATTR);\n        myDownloadUrl = element.getAttributeValue(DOWNLOAD_ATTR);\n      }\n    }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getBuildNumber() {\n    return myBuildNumber;\n  }","id":101479,"modified_method":"public String getBuildNumber() {\n    //return myBuildNumber;\n    return \"0\";\n  }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NewVersion(int build, String version) {\n      latestBuild = build;\n      latestVersion = version;\n    }","id":101480,"modified_method":"public NewVersion(int build, String version, List<PatchInfo> patches) {\n      myLatestBuild = build;\n      myLatestVersion = version;\n      myPatches = patches;\n    }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getUpdateUrl() {\n    return StringHolder.UPDATE_URL;\n  }","id":101481,"modified_method":"private static String getUpdateUrl() {\n    //return StringHolder.UPDATE_URL;\n    return \"file:///C:/temp/updater/update.xml\";\n  }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static NewVersion checkForUpdates() throws ConnectionException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"enter: checkForUpdates()\");\n    }\n\n    final Document document;\n    try {\n      document = loadVersionInfo(getUpdateUrl());\n      if (document == null) return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      throw new ConnectionException(t);\n    }\n\n    final String availBuild = document.getRootElement().getChild(ELEMENT_BUILD).getTextTrim();\n    final String availVersion = document.getRootElement().getChild(ELEMENT_VERSION).getTextTrim();\n    String ourBuild = ApplicationInfo.getInstance().getBuildNumber().trim();\n    if (BUILD_NUMBER_STUB.equals(ourBuild)) ourBuild = Integer.toString(Integer.MAX_VALUE);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"build available:'\" + availBuild + \"' ourBuild='\" + ourBuild + \"' \");\n    }\n\n    try {\n      final int iAvailBuild = Integer.parseInt(availBuild);\n      final int iOurBuild = Integer.parseInt(ourBuild);\n      if (iAvailBuild > iOurBuild) {\n        return new NewVersion(iAvailBuild, availVersion);\n      }\n      return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      return null;\n    }\n    finally {\n      UpdateSettings.getInstance().LAST_TIME_CHECKED = System.currentTimeMillis();\n    }\n  }","id":101482,"modified_method":"@Nullable\n  public static NewVersion checkForUpdates() throws ConnectionException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"enter: checkForUpdates()\");\n    }\n\n    final Document document;\n    try {\n      document = loadVersionInfo(getUpdateUrl());\n      if (document == null) return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      throw new ConnectionException(t);\n    }\n\n    Element root = document.getRootElement();\n    final String availBuild = root.getChild(ELEMENT_BUILD).getTextTrim();\n    final String availVersion = root.getChild(ELEMENT_VERSION).getTextTrim();\n    String ourBuild = ApplicationInfo.getInstance().getBuildNumber().trim();\n    if (BUILD_NUMBER_STUB.equals(ourBuild)) ourBuild = Integer.toString(Integer.MAX_VALUE);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"build available:'\" + availBuild + \"' ourBuild='\" + ourBuild + \"' \");\n    }\n\n\n    Element patchElements = root.getChild(\"patches\");\n    List<PatchInfo> patches = new ArrayList<PatchInfo>();\n    if (patchElements != null) {\n      for (Element each : (List<Element>)patchElements.getChildren()) {\n        String fromBuild = each.getAttributeValue(\"from\").trim();\n        String toBuild = each.getAttributeValue(\"to\").trim();\n        String size = each.getAttributeValue(\"size\").trim();\n        patches.add(new PatchInfo(fromBuild, toBuild, size));\n      }\n    }\n\n    try {\n      final int iAvailBuild = Integer.parseInt(availBuild);\n      final int iOurBuild = Integer.parseInt(ourBuild);\n      if (iAvailBuild > iOurBuild) {\n        return new NewVersion(iAvailBuild, availVersion, patches);\n      }\n      return null;\n    }\n    catch (Throwable t) {\n      LOG.debug(t);\n      return null;\n    }\n    finally {\n      UpdateSettings.getInstance().LAST_TIME_CHECKED = System.currentTimeMillis();\n    }\n  }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getLatestVersion() {\n      return latestVersion;\n    }","id":101483,"modified_method":"public String getLatestVersion() {\n      return myLatestVersion;\n    }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getLatestBuild() {\n      return latestBuild;\n    }","id":101484,"modified_method":"public int getLatestBuild() {\n      return myLatestBuild;\n    }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getOkButtonText() {\n    return IdeBundle.message(\"updates.more.info.button\");\n  }","id":101485,"modified_method":"protected String getOkButtonText() {\n    return IdeBundle.message(\"updates.download.and.install.patch.button\");\n  }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public UpdateInfoPanel() {\n\n      final String build = ApplicationInfo.getInstance().getBuildNumber().trim();\n      myBuildNumber.setText(build + \")\");\n      final String majorVersion = ApplicationInfo.getInstance().getMajorVersion();\n      final String version;\n      if (majorVersion != null && majorVersion.trim().length() > 0) {\n        final String minorVersion = ApplicationInfo.getInstance().getMinorVersion();\n        if (minorVersion != null && minorVersion.trim().length() > 0) {\n          version = majorVersion + \".\" + minorVersion;\n        }\n        else {\n          version = majorVersion + \".0\";\n        }\n      }\n      else {\n        version = ApplicationInfo.getInstance().getVersionName();\n      }\n\n      myVersionNumber.setText(version);\n      myNewBuildNumber.setText(Integer.toString(myNewVersion.getLatestBuild()) + \")\");\n      myNewVersionNumber.setText(myNewVersion.getLatestVersion());\n\n      initPluginsPanel(myPanel, myUpdatedPluginsPanel, myWholePluginsPanel, myEditorPane);\n    }","id":101486,"modified_method":"public UpdateInfoPanel() {\n\n      final String build = ApplicationInfo.getInstance().getBuildNumber().trim();\n      myBuildNumber.setText(build + \")\");\n      final String majorVersion = ApplicationInfo.getInstance().getMajorVersion();\n      final String version;\n      if (majorVersion != null && majorVersion.trim().length() > 0) {\n        final String minorVersion = ApplicationInfo.getInstance().getMinorVersion();\n        if (minorVersion != null && minorVersion.trim().length() > 0) {\n          version = majorVersion + \".\" + minorVersion;\n        }\n        else {\n          version = majorVersion + \".0\";\n        }\n      }\n      else {\n        version = ApplicationInfo.getInstance().getVersionName();\n      }\n\n      myVersionNumber.setText(version);\n      myNewBuildNumber.setText(Integer.toString(myNewVersion.getLatestBuild()) + \")\");\n      myNewVersionNumber.setText(myNewVersion.getLatestVersion());\n\n      UpdateChecker.PatchInfo patch = myNewVersion.findPatchFor(build);\n      if (patch == null) {\n        myPatchAvailableLabel.setVisible(false);\n        myPatchSizeLabel.setVisible(false);\n      } else {\n        myPatchSizeLabel.setText(patch.getSize() + \"MB\");\n      }\n\n      initPluginsPanel(myPanel, myUpdatedPluginsPanel, myWholePluginsPanel, myEditorPane);\n    }","commit_id":"487791591b07b5e258d0f822224624d2ff3f3f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hostToInjected(int hostOffset) {\n    synchronized (myLock) {\n      if (hostOffset < myShreds.get(0).getHostRangeMarker().getStartOffset()) return myShreds.get(0).getPrefix().length();\n      int offset = 0;\n      for (int i = 0; i < myShreds.size(); i++) {\n        offset += myShreds.get(i).getPrefix().length();\n        Segment currentRange = myShreds.get(i).getHostRangeMarker();\n        Segment nextRange = i == myShreds.size() - 1 ? null : myShreds.get(i + 1).getHostRangeMarker();\n        if (nextRange == null || hostOffset < nextRange.getStartOffset()) {\n          if (hostOffset >= currentRange.getEndOffset()) hostOffset = currentRange.getEndOffset();\n          return offset + hostOffset - currentRange.getStartOffset();\n        }\n        offset += currentRange.getEndOffset() - currentRange.getStartOffset();\n        offset += myShreds.get(i).getSuffix().length();\n      }\n      return getTextLength() - myShreds.get(myShreds.size() - 1).getSuffix().length();\n    }\n  }","id":101487,"modified_method":"@Override\n  public int hostToInjected(int hostOffset) {\n    synchronized (myLock) {\n      Segment hostRangeMarker = myShreds.get(0).getHostRangeMarker();\n      if (hostRangeMarker == null || hostOffset < hostRangeMarker.getStartOffset()) return myShreds.get(0).getPrefix().length();\n      int offset = 0;\n      for (int i = 0; i < myShreds.size(); i++) {\n        offset += myShreds.get(i).getPrefix().length();\n        Segment currentRange = myShreds.get(i).getHostRangeMarker();\n        if (currentRange == null) continue;\n        Segment nextRange = i == myShreds.size() - 1 ? null : myShreds.get(i + 1).getHostRangeMarker();\n        if (nextRange == null || hostOffset < nextRange.getStartOffset()) {\n          if (hostOffset >= currentRange.getEndOffset()) hostOffset = currentRange.getEndOffset();\n          return offset + hostOffset - currentRange.getStartOffset();\n        }\n        offset += currentRange.getEndOffset() - currentRange.getStartOffset();\n        offset += myShreds.get(i).getSuffix().length();\n      }\n      return getTextLength() - myShreds.get(myShreds.size() - 1).getSuffix().length();\n    }\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean containsRange(int start, int end) {\n    synchronized (myLock) {\n      if (end - start > myShreds.get(0).getHostRangeMarker().getEndOffset() - myShreds.get(0).getHostRangeMarker().getStartOffset()) return false;\n      for (PsiLanguageInjectionHost.Shred shred : myShreds) {\n        Segment hostRange = shred.getHostRangeMarker();\n        if (hostRange == null) continue;\n        TextRange textRange = ProperTextRange.create(hostRange);\n        if (textRange.contains(new ProperTextRange(start, end))) return true;\n      }\n      return false;\n    }\n  }","id":101488,"modified_method":"@Override\n  public boolean containsRange(int start, int end) {\n    synchronized (myLock) {\n      Segment hostRangeMarker = myShreds.get(0).getHostRangeMarker();\n      if (hostRangeMarker == null || end - start > hostRangeMarker.getEndOffset() - hostRangeMarker.getStartOffset()) return false;\n      for (PsiLanguageInjectionHost.Shred shred : myShreds) {\n        Segment hostRange = shred.getHostRangeMarker();\n        if (hostRange == null) continue;\n        TextRange textRange = ProperTextRange.create(hostRange);\n        if (textRange.contains(new ProperTextRange(start, end))) return true;\n      }\n      return false;\n    }\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int injectedToHostLine(int line) {\n    if (line < myPrefixLineCount) {\n      synchronized (myLock) {\n        return myDelegate.getLineNumber(myShreds.get(0).getHostRangeMarker().getStartOffset());\n      }\n    }\n    int lineCount = getLineCount();\n    if (line > lineCount - mySuffixLineCount) {\n      return lineCount;\n    }\n    int offset = getLineStartOffset(line);\n    int hostOffset = injectedToHost(offset);\n\n    return myDelegate.getLineNumber(hostOffset);\n  }","id":101489,"modified_method":"@Override\n  public int injectedToHostLine(int line) {\n    if (line < myPrefixLineCount) {\n      synchronized (myLock) {\n        Segment hostRangeMarker = myShreds.get(0).getHostRangeMarker();\n        return hostRangeMarker == null ? 0 : myDelegate.getLineNumber(hostRangeMarker.getStartOffset());\n      }\n    }\n    int lineCount = getLineCount();\n    if (line > lineCount - mySuffixLineCount) {\n      return lineCount;\n    }\n    int offset = getLineStartOffset(line);\n    int hostOffset = injectedToHost(offset);\n\n    return myDelegate.getLineNumber(hostOffset);\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int hashCode() {\n    synchronized (myLock) {\n      return myShreds.get(0).getHostRangeMarker().getStartOffset();\n    }\n  }","id":101490,"modified_method":"public int hashCode() {\n    synchronized (myLock) {\n      Segment hostRangeMarker = myShreds.get(0).getHostRangeMarker();\n      return hostRangeMarker == null ? -1 : hostRangeMarker.getStartOffset();\n    }\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getRangeText(String hostText, int hostNum) {\n    synchronized (myLock) {\n      PsiLanguageInjectionHost.Shred shred = myShreds.get(hostNum);\n      return shred.getPrefix() +\n             hostText.substring(shred.getHostRangeMarker().getStartOffset(), shred.getHostRangeMarker().getEndOffset()) +\n             shred.getSuffix();\n    }\n  }","id":101491,"modified_method":"private String getRangeText(@NotNull String hostText, int hostNum) {\n    synchronized (myLock) {\n      PsiLanguageInjectionHost.Shred shred = myShreds.get(hostNum);\n      Segment hostRangeMarker = shred.getHostRangeMarker();\n      return shred.getPrefix() +\n             (hostRangeMarker == null ? \"\" : hostText.substring(hostRangeMarker.getStartOffset(), hostRangeMarker.getEndOffset())) +\n             shred.getSuffix();\n    }\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int injectedToHost(int offset, boolean preferLeftFragment) {\n    synchronized (myLock) {\n      if (offset < myShreds.get(0).getPrefix().length()) return myShreds.get(0).getHostRangeMarker().getStartOffset();\n      int prevEnd = 0;\n      for (int i = 0; i < myShreds.size(); i++) {\n        Segment currentRange = myShreds.get(i).getHostRangeMarker();\n        if (currentRange == null) continue;\n        offset -= myShreds.get(i).getPrefix().length();\n        int length = currentRange.getEndOffset() - currentRange.getStartOffset();\n        if (offset < 0) {\n          return preferLeftFragment ? prevEnd : currentRange.getStartOffset() - 1;\n        }\n        if (offset == 0) {\n          return preferLeftFragment && i != 0 ? prevEnd : currentRange.getStartOffset();\n        }\n        if (offset < length || offset == length && preferLeftFragment) {\n          return currentRange.getStartOffset() + offset;\n        }\n        offset -= length;\n        offset -= myShreds.get(i).getSuffix().length();\n        prevEnd = currentRange.getEndOffset();\n      }\n      return myShreds.get(myShreds.size() - 1).getHostRangeMarker().getEndOffset();\n    }\n  }","id":101492,"modified_method":"private int injectedToHost(int offset, boolean preferLeftFragment) {\n    synchronized (myLock) {\n      if (offset < myShreds.get(0).getPrefix().length()) {\n        Segment hostRangeMarker = myShreds.get(0).getHostRangeMarker();\n        return hostRangeMarker == null ? 0 : hostRangeMarker.getStartOffset();\n      }\n      int prevEnd = 0;\n      for (int i = 0; i < myShreds.size(); i++) {\n        Segment currentRange = myShreds.get(i).getHostRangeMarker();\n        if (currentRange == null) continue;\n        offset -= myShreds.get(i).getPrefix().length();\n        int length = currentRange.getEndOffset() - currentRange.getStartOffset();\n        if (offset < 0) {\n          return preferLeftFragment ? prevEnd : currentRange.getStartOffset() - 1;\n        }\n        if (offset == 0) {\n          return preferLeftFragment && i != 0 ? prevEnd : currentRange.getStartOffset();\n        }\n        if (offset < length || offset == length && preferLeftFragment) {\n          return currentRange.getStartOffset() + offset;\n        }\n        offset -= length;\n        offset -= myShreds.get(i).getSuffix().length();\n        prevEnd = currentRange.getEndOffset();\n      }\n      Segment hostRangeMarker = myShreds.get(myShreds.size() - 1).getHostRangeMarker();\n      return hostRangeMarker == null ? 0 : hostRangeMarker.getEndOffset();\n    }\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    PsiLanguageInjectionHost.Shred shred = (PsiLanguageInjectionHost.Shred)o;\n\n    PsiLanguageInjectionHost host = getHost();\n    return host != null &&\n           host.equals(shred.getHost()) &&\n           prefix.equals(shred.getPrefix()) &&\n           suffix.equals(shred.getSuffix()) &&\n           range.equals(shred.getRange()) &&\n           TextRange.create(relevantRangeInHost).equals(TextRange.create(shred.getHostRangeMarker()));\n  }","id":101493,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    PsiLanguageInjectionHost.Shred shred = (PsiLanguageInjectionHost.Shred)o;\n\n    PsiLanguageInjectionHost host = getHost();\n    Segment hostRangeMarker = shred.getHostRangeMarker();\n    return host != null &&\n           host.equals(shred.getHost()) &&\n           prefix.equals(shred.getPrefix()) &&\n           suffix.equals(shred.getSuffix()) &&\n           range.equals(shred.getRange()) &&\n           hostRangeMarker != null &&\n           TextRange.create(relevantRangeInHost).equals(TextRange.create(hostRangeMarker));\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable(\"returns null when the host document marker is invalid\")\n  public Segment getHostRangeMarker() {\n    return relevantRangeInHost;\n  }","id":101494,"modified_method":"@Override\n  @Nullable(\"returns null when the host document marker is invalid\")\n  public Segment getHostRangeMarker() {\n    RangeMarker marker = relevantRangeInHost;\n    return marker == null || !marker.isValid() ? null : marker;\n  }","commit_id":"365e2ef50748ea7e5ee6aecbfb68c001e801a665","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** This method updates the local token on disk  */\n    public void setToken(Token token)\n    {\n        if (logger_.isDebugEnabled())\n            logger_.debug(\"Setting token to {}\", token);\n        SystemTable.updateToken(token);\n        tokenMetadata_.updateNormalToken(token, FBUtilities.getLocalAddress());\n    }","id":101495,"modified_method":"/** This method updates the local token on disk  */\n    public void setToken(Token token)\n    {\n        if (logger_.isDebugEnabled())\n            logger_.debug(\"Setting token to {}\", token);\n        SystemTable.updateToken(token);\n        tokenMetadata_.updateNormalToken(token, FBUtilities.getLocalAddress());\n        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(getLocalToken()));\n        setMode(\"Normal\", false);\n    }","commit_id":"d32fd5567a164d850e9490347b71624a1a17aadf","url":"https://github.com/apache/cassandra"},{"original_method":"public synchronized void initServer() throws IOException, org.apache.cassandra.config.ConfigurationException\n    {\n        logger_.info(\"Cassandra version: \" + FBUtilities.getReleaseVersionString());\n        logger_.info(\"Thrift API version: \" + Constants.VERSION);\n\n        if (initialized)\n        {\n            if (isClientMode)\n                throw new UnsupportedOperationException(\"StorageService does not support switching modes.\");\n            return;\n        }\n        initialized = true;\n        isClientMode = false;\n\n        try\n        {\n            GCInspector.instance.start();\n        }\n        catch (Throwable t)\n        {\n            logger_.warn(\"Unable to start GCInspector (currently only supported on the Sun JVM)\");\n        }\n\n        if (Boolean.valueOf(System.getProperty(\"cassandra.load_ring_state\", \"true\")))\n        {\n            logger_.info(\"Loading persisted ring state\");\n            for (Map.Entry<Token, InetAddress> entry : SystemTable.loadTokens().entrySet())\n            {\n                tokenMetadata_.updateNormalToken(entry.getKey(), entry.getValue());\n                Gossiper.instance.addSavedEndpoint(entry.getValue());\n            }\n        }\n\n        logger_.info(\"Starting up server gossip\");\n\n        // have to start the gossip service before we can see any info on other nodes.  this is necessary\n        // for bootstrap to get the load info it needs.\n        // (we won't be part of the storage ring though until we add a nodeId to our state, below.)\n        Gossiper.instance.register(this);\n        Gossiper.instance.register(migrationManager);\n        Gossiper.instance.start(FBUtilities.getLocalAddress(), SystemTable.incrementAndGetGeneration()); // needed for node-ring gathering.\n\n        MessagingService.instance.listen(FBUtilities.getLocalAddress());\n        StorageLoadBalancer.instance.startBroadcasting();\n        MigrationManager.announce(DatabaseDescriptor.getDefsVersion(), DatabaseDescriptor.getSeeds());\n\n        if (DatabaseDescriptor.isAutoBootstrap()\n                && DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress())\n                && !SystemTable.isBootstrapped())\n            logger_.info(\"This node will not auto bootstrap because it is configured to be a seed node.\");\n\n        Token token;\n        if (DatabaseDescriptor.isAutoBootstrap()\n            && !(DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress()) || SystemTable.isBootstrapped()))\n        {\n            setMode(\"Joining: getting load information\", true);\n            StorageLoadBalancer.instance.waitForLoadInfo();\n            if (logger_.isDebugEnabled())\n                logger_.debug(\"... got load info\");\n            if (tokenMetadata_.isMember(FBUtilities.getLocalAddress()))\n            {\n                String s = \"This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)\";\n                throw new UnsupportedOperationException(s);\n            }\n            setMode(\"Joining: getting bootstrap token\", true);\n            token = BootStrapper.getBootstrapToken(tokenMetadata_, StorageLoadBalancer.instance.getLoadInfo());\n            // don't bootstrap if there are no tables defined.\n            if (DatabaseDescriptor.getNonSystemTables().size() > 0)\n            {\n                bootstrap(token);\n                assert !isBootstrapMode; // bootstrap will block until finished\n            }\n            // else nothing to do, go directly to participating in ring\n        }\n        else\n        {\n            token = SystemTable.getSavedToken();\n            if (token == null)\n            {\n                String initialToken = DatabaseDescriptor.getInitialToken();\n                if (initialToken == null)\n                {\n                    token = partitioner_.getRandomToken();\n                    logger_.warn(\"Generated random token \" + token + \". Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations\");\n                }\n                else\n                {\n                    token = partitioner_.getTokenFactory().fromString(initialToken);\n                    logger_.info(\"Saved token not found. Using \" + token + \" from configuration\");\n                }\n            }\n            else\n            {\n                logger_.info(\"Using saved token \" + token);\n            }\n        } \n\n        SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap\n        setToken(token);\n        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(getLocalToken()));\n        setMode(\"Normal\", false);\n\n        assert tokenMetadata_.sortedTokens().size() > 0;\n    }","id":101496,"modified_method":"public synchronized void initServer() throws IOException, org.apache.cassandra.config.ConfigurationException\n    {\n        logger_.info(\"Cassandra version: \" + FBUtilities.getReleaseVersionString());\n        logger_.info(\"Thrift API version: \" + Constants.VERSION);\n\n        if (initialized)\n        {\n            if (isClientMode)\n                throw new UnsupportedOperationException(\"StorageService does not support switching modes.\");\n            return;\n        }\n        initialized = true;\n        isClientMode = false;\n\n        try\n        {\n            GCInspector.instance.start();\n        }\n        catch (Throwable t)\n        {\n            logger_.warn(\"Unable to start GCInspector (currently only supported on the Sun JVM)\");\n        }\n\n        if (Boolean.valueOf(System.getProperty(\"cassandra.load_ring_state\", \"true\")))\n        {\n            logger_.info(\"Loading persisted ring state\");\n            for (Map.Entry<Token, InetAddress> entry : SystemTable.loadTokens().entrySet())\n            {\n                tokenMetadata_.updateNormalToken(entry.getKey(), entry.getValue());\n                Gossiper.instance.addSavedEndpoint(entry.getValue());\n            }\n        }\n\n        logger_.info(\"Starting up server gossip\");\n\n        // have to start the gossip service before we can see any info on other nodes.  this is necessary\n        // for bootstrap to get the load info it needs.\n        // (we won't be part of the storage ring though until we add a nodeId to our state, below.)\n        Gossiper.instance.register(this);\n        Gossiper.instance.register(migrationManager);\n        Gossiper.instance.start(FBUtilities.getLocalAddress(), SystemTable.incrementAndGetGeneration()); // needed for node-ring gathering.\n\n        MessagingService.instance.listen(FBUtilities.getLocalAddress());\n        StorageLoadBalancer.instance.startBroadcasting();\n        MigrationManager.announce(DatabaseDescriptor.getDefsVersion(), DatabaseDescriptor.getSeeds());\n\n        if (DatabaseDescriptor.isAutoBootstrap()\n                && DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress())\n                && !SystemTable.isBootstrapped())\n            logger_.info(\"This node will not auto bootstrap because it is configured to be a seed node.\");\n\n        Token token;\n        boolean bootstrapped = false;\n        if (DatabaseDescriptor.isAutoBootstrap()\n            && !(DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress()) || SystemTable.isBootstrapped()))\n        {\n            setMode(\"Joining: getting load information\", true);\n            StorageLoadBalancer.instance.waitForLoadInfo();\n            if (logger_.isDebugEnabled())\n                logger_.debug(\"... got load info\");\n            if (tokenMetadata_.isMember(FBUtilities.getLocalAddress()))\n            {\n                String s = \"This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)\";\n                throw new UnsupportedOperationException(s);\n            }\n            setMode(\"Joining: getting bootstrap token\", true);\n            token = BootStrapper.getBootstrapToken(tokenMetadata_, StorageLoadBalancer.instance.getLoadInfo());\n            // don't bootstrap if there are no tables defined.\n            if (DatabaseDescriptor.getNonSystemTables().size() > 0)\n            {\n                bootstrap(token);\n                assert !isBootstrapMode; // bootstrap will block until finished\n                bootstrapped = true;\n                SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap\n            }\n            // else nothing to do, go directly to participating in ring\n        }\n        else\n        {\n            token = SystemTable.getSavedToken();\n            if (token == null)\n            {\n                String initialToken = DatabaseDescriptor.getInitialToken();\n                if (initialToken == null)\n                {\n                    token = partitioner_.getRandomToken();\n                    logger_.warn(\"Generated random token \" + token + \". Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations\");\n                }\n                else\n                {\n                    token = partitioner_.getTokenFactory().fromString(initialToken);\n                    logger_.info(\"Saved token not found. Using \" + token + \" from configuration\");\n                }\n            }\n            else\n            {\n                logger_.info(\"Using saved token \" + token);\n            }\n        } \n\n        if(!bootstrapped)\n            setToken(token);\n\n        assert tokenMetadata_.sortedTokens().size() > 0;\n    }","commit_id":"d32fd5567a164d850e9490347b71624a1a17aadf","url":"https://github.com/apache/cassandra"},{"original_method":"public void finishBootstrapping()\n    {\n        isBootstrapMode = false;\n        logger_.info(\"Bootstrap/move completed! Now serving reads.\");\n    }","id":101497,"modified_method":"public void finishBootstrapping()\n    {\n        isBootstrapMode = false;\n        setToken(getLocalToken());\n        logger_.info(\"Bootstrap/move completed! Now serving reads.\");\n    }","commit_id":"d32fd5567a164d850e9490347b71624a1a17aadf","url":"https://github.com/apache/cassandra"},{"original_method":"public synchronized void initServer() throws IOException, org.apache.cassandra.config.ConfigurationException\n    {\n        logger_.info(\"Cassandra version: \" + FBUtilities.getReleaseVersionString());\n        logger_.info(\"Thrift API version: \" + Constants.VERSION);\n\n        if (initialized)\n        {\n            if (isClientMode)\n                throw new UnsupportedOperationException(\"StorageService does not support switching modes.\");\n            return;\n        }\n        initialized = true;\n        isClientMode = false;\n\n        try\n        {\n            GCInspector.instance.start();\n        }\n        catch (Throwable t)\n        {\n            logger_.warn(\"Unable to start GCInspector (currently only supported on the Sun JVM)\");\n        }\n\n        if (Boolean.valueOf(System.getProperty(\"cassandra.load_ring_state\", \"true\")))\n        {\n            logger_.info(\"Loading persisted ring state\");\n            for (Map.Entry<Token, InetAddress> entry : SystemTable.loadTokens().entrySet())\n            {\n                tokenMetadata_.updateNormalToken(entry.getKey(), entry.getValue());\n                Gossiper.instance.addSavedEndpoint(entry.getValue());\n            }\n        }\n\n        logger_.info(\"Starting up server gossip\");\n\n        // have to start the gossip service before we can see any info on other nodes.  this is necessary\n        // for bootstrap to get the load info it needs.\n        // (we won't be part of the storage ring though until we add a nodeId to our state, below.)\n        Gossiper.instance.register(this);\n        Gossiper.instance.register(migrationManager);\n        Gossiper.instance.start(FBUtilities.getLocalAddress(), SystemTable.incrementAndGetGeneration()); // needed for node-ring gathering.\n\n        MessagingService.instance.listen(FBUtilities.getLocalAddress());\n        StorageLoadBalancer.instance.startBroadcasting();\n        MigrationManager.announce(DatabaseDescriptor.getDefsVersion(), DatabaseDescriptor.getSeeds());\n\n        if (DatabaseDescriptor.isAutoBootstrap()\n                && DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress())\n                && !SystemTable.isBootstrapped())\n            logger_.info(\"This node will not auto bootstrap because it is configured to be a seed node.\");\n\n        Token token;\n        if (DatabaseDescriptor.isAutoBootstrap()\n            && !(DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress()) || SystemTable.isBootstrapped()))\n        {\n            setMode(\"Joining: getting load information\", true);\n            StorageLoadBalancer.instance.waitForLoadInfo();\n            if (logger_.isDebugEnabled())\n                logger_.debug(\"... got load info\");\n            if (tokenMetadata_.isMember(FBUtilities.getLocalAddress()))\n            {\n                String s = \"This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)\";\n                throw new UnsupportedOperationException(s);\n            }\n            setMode(\"Joining: getting bootstrap token\", true);\n            token = BootStrapper.getBootstrapToken(tokenMetadata_, StorageLoadBalancer.instance.getLoadInfo());\n            // don't bootstrap if there are no tables defined.\n            if (DatabaseDescriptor.getNonSystemTables().size() > 0)\n            {\n                bootstrap(token);\n                assert !isBootstrapMode; // bootstrap will block until finished\n            }\n            // else nothing to do, go directly to participating in ring\n        }\n        else\n        {\n            token = SystemTable.getSavedToken();\n            if (token == null)\n            {\n                String initialToken = DatabaseDescriptor.getInitialToken();\n                if (initialToken == null)\n                {\n                    token = partitioner_.getRandomToken();\n                    logger_.warn(\"Generated random token \" + token + \". Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations\");\n                }\n                else\n                {\n                    token = partitioner_.getTokenFactory().fromString(initialToken);\n                    logger_.info(\"Saved token not found. Using \" + token + \" from configuration\");\n                }\n            }\n            else\n            {\n                logger_.info(\"Using saved token \" + token);\n            }\n        } \n\n        SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap\n        setToken(token);\n        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(getLocalToken()));\n        setMode(\"Normal\", false);\n\n        assert tokenMetadata_.sortedTokens().size() > 0;\n    }","id":101498,"modified_method":"public synchronized void initServer() throws IOException, org.apache.cassandra.config.ConfigurationException\n    {\n        logger_.info(\"Cassandra version: \" + FBUtilities.getReleaseVersionString());\n        logger_.info(\"Thrift API version: \" + Constants.VERSION);\n\n        if (initialized)\n        {\n            if (isClientMode)\n                throw new UnsupportedOperationException(\"StorageService does not support switching modes.\");\n            return;\n        }\n        initialized = true;\n        isClientMode = false;\n\n        try\n        {\n            GCInspector.instance.start();\n        }\n        catch (Throwable t)\n        {\n            logger_.warn(\"Unable to start GCInspector (currently only supported on the Sun JVM)\");\n        }\n\n        if (Boolean.valueOf(System.getProperty(\"cassandra.load_ring_state\", \"true\")))\n        {\n            logger_.info(\"Loading persisted ring state\");\n            for (Map.Entry<Token, InetAddress> entry : SystemTable.loadTokens().entrySet())\n            {\n                tokenMetadata_.updateNormalToken(entry.getKey(), entry.getValue());\n                Gossiper.instance.addSavedEndpoint(entry.getValue());\n            }\n        }\n\n        logger_.info(\"Starting up server gossip\");\n\n        // have to start the gossip service before we can see any info on other nodes.  this is necessary\n        // for bootstrap to get the load info it needs.\n        // (we won't be part of the storage ring though until we add a nodeId to our state, below.)\n        Gossiper.instance.register(this);\n        Gossiper.instance.register(migrationManager);\n        Gossiper.instance.start(FBUtilities.getLocalAddress(), SystemTable.incrementAndGetGeneration()); // needed for node-ring gathering.\n\n        MessagingService.instance.listen(FBUtilities.getLocalAddress());\n        StorageLoadBalancer.instance.startBroadcasting();\n        MigrationManager.announce(DatabaseDescriptor.getDefsVersion(), DatabaseDescriptor.getSeeds());\n\n        if (DatabaseDescriptor.isAutoBootstrap()\n                && DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress())\n                && !SystemTable.isBootstrapped())\n            logger_.info(\"This node will not auto bootstrap because it is configured to be a seed node.\");\n\n        Token token;\n        boolean bootstrapped = false;\n        if (DatabaseDescriptor.isAutoBootstrap()\n            && !(DatabaseDescriptor.getSeeds().contains(FBUtilities.getLocalAddress()) || SystemTable.isBootstrapped()))\n        {\n            setMode(\"Joining: getting load information\", true);\n            StorageLoadBalancer.instance.waitForLoadInfo();\n            if (logger_.isDebugEnabled())\n                logger_.debug(\"... got load info\");\n            if (tokenMetadata_.isMember(FBUtilities.getLocalAddress()))\n            {\n                String s = \"This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)\";\n                throw new UnsupportedOperationException(s);\n            }\n            setMode(\"Joining: getting bootstrap token\", true);\n            token = BootStrapper.getBootstrapToken(tokenMetadata_, StorageLoadBalancer.instance.getLoadInfo());\n            // don't bootstrap if there are no tables defined.\n            if (DatabaseDescriptor.getNonSystemTables().size() > 0)\n            {\n                bootstrap(token);\n                assert !isBootstrapMode; // bootstrap will block until finished\n                bootstrapped = true;\n                SystemTable.setBootstrapped(true); // first startup is only chance to bootstrap\n            }\n            // else nothing to do, go directly to participating in ring\n        }\n        else\n        {\n            token = SystemTable.getSavedToken();\n            if (token == null)\n            {\n                String initialToken = DatabaseDescriptor.getInitialToken();\n                if (initialToken == null)\n                {\n                    token = partitioner_.getRandomToken();\n                    logger_.warn(\"Generated random token \" + token + \". Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations\");\n                }\n                else\n                {\n                    token = partitioner_.getTokenFactory().fromString(initialToken);\n                    logger_.info(\"Saved token not found. Using \" + token + \" from configuration\");\n                }\n            }\n            else\n            {\n                logger_.info(\"Using saved token \" + token);\n            }\n        } \n\n        if(!bootstrapped)\n            setToken(token);\n\n        assert tokenMetadata_.sortedTokens().size() > 0;\n    }","commit_id":"1751579be28f0c0460fb01fdd797b7f7e5cc431f","url":"https://github.com/apache/cassandra"},{"original_method":"public void finishBootstrapping()\n    {\n        isBootstrapMode = false;\n        logger_.info(\"Bootstrap/move completed! Now serving reads.\");\n    }","id":101499,"modified_method":"public void finishBootstrapping()\n    {\n        isBootstrapMode = false;\n        setToken(getLocalToken());\n        logger_.info(\"Bootstrap/move completed! Now serving reads.\");\n    }","commit_id":"1751579be28f0c0460fb01fdd797b7f7e5cc431f","url":"https://github.com/apache/cassandra"},{"original_method":"/** This method updates the local token on disk  */\n    public void setToken(Token token)\n    {\n        if (logger_.isDebugEnabled())\n            logger_.debug(\"Setting token to {}\", token);\n        SystemTable.updateToken(token);\n        tokenMetadata_.updateNormalToken(token, FBUtilities.getLocalAddress());\n    }","id":101500,"modified_method":"/** This method updates the local token on disk  */\n    public void setToken(Token token)\n    {\n        if (logger_.isDebugEnabled())\n            logger_.debug(\"Setting token to {}\", token);\n        SystemTable.updateToken(token);\n        tokenMetadata_.updateNormalToken(token, FBUtilities.getLocalAddress());\n        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(getLocalToken()));\n        setMode(\"Normal\", false);\n    }","commit_id":"1751579be28f0c0460fb01fdd797b7f7e5cc431f","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n      public String toString()\n      {\n         SafeHtmlBuilder sb = new SafeHtmlBuilder();\n         \n         // Get an icon for the completion\n         // We use separate styles for file icons, so we can nudge them\n         // a bit differently\n         String style = RES.styles().completionIcon();\n         if (RCompletionType.isFileType(type))\n            style = RES.styles().fileIcon();\n            \n         SafeHtmlUtil.appendImage(\n               sb,\n               style,\n               getIcon());\n         \n         // Handle files specially\n         if (RCompletionType.isFileType(type))\n         {\n            ArrayList<Integer> slashIndices =\n                  StringUtil.indicesOf(name, '/');\n            \n            if (name.endsWith(\"/\"))\n               slashIndices.remove(slashIndices.size() - 1);\n            \n            if (slashIndices.size() < 1)\n               SafeHtmlUtil.appendSpan(\n                     sb,\n                     RES.styles().completion(),\n                     name);\n            else\n            {\n               int lastSlashIndex = slashIndices.get(\n                     slashIndices.size() - 1);\n               \n               int firstSlashIndex = 0;\n               if (slashIndices.size() > 2)\n                  firstSlashIndex = slashIndices.get(\n                        slashIndices.size() - 3);\n               \n               String endName = name.substring(lastSlashIndex + 1);\n               String startName = \"\";\n               if (slashIndices.size() > 2)\n                  startName += \"...\";\n               startName += name.substring(firstSlashIndex, lastSlashIndex);\n               \n               SafeHtmlUtil.appendSpan(\n                     sb,\n                     RES.styles().completion(),\n                     endName);\n\n               SafeHtmlUtil.appendSpan(\n                     sb,\n                     RES.styles().packageName(),\n                     startName);\n            }\n                     \n         }\n         \n         // Non-file completions\n         else\n         {\n            // Get the name for the completion\n            SafeHtmlUtil.appendSpan(\n                  sb,\n                  RES.styles().completion(),\n                  name);\n\n            // Get the associated package for functions\n            if (RCompletionType.isFunctionType(type))\n            {\n               SafeHtmlUtil.appendSpan(\n                     sb,\n                     RES.styles().packageName(),\n                     \"{\" + source.replaceAll(\"package:\", \"\") + \"}\");\n            }\n         }\n         \n         return sb.toSafeHtml().asString();\n      }","id":101501,"modified_method":"@Override\n      public String toString()\n      {\n         SafeHtmlBuilder sb = new SafeHtmlBuilder();\n         \n         // Get an icon for the completion\n         // We use separate styles for file icons, so we can nudge them\n         // a bit differently\n         String style = RES.styles().completionIcon();\n         if (RCompletionType.isFileType(type))\n            style = RES.styles().fileIcon();\n            \n         SafeHtmlUtil.appendImage(\n               sb,\n               style,\n               getIcon());\n         \n         // Get the display name. Note that for file completions this requires\n         // some munging of the 'name' and 'package' fields.\n         addDisplayName(sb);\n         \n         return sb.toSafeHtml().asString();\n      }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"private CompletionResult narrow(String token,\n                                   String diff,\n                                   CompletionResult cachedResult)\n   {\n      ArrayList<QualifiedName> newCompletions = new ArrayList<QualifiedName>();\n      newCompletions.ensureCapacity(cachedResult.completions.size());\n      \n      // For completions that are files or directories, we need to post-process\n      // the token and the qualified name to strip out just the basename (filename).\n      // Note that we normalize the paths such that files will have no trailing slash,\n      // while directories will have one trailing slash (but we defend against multiple\n      // trailing slashes)\n      \n      // Transform the token once beforehand for potential file completions.\n      int tokenSlashOffset = token.length() - 1;\n      while (tokenSlashOffset > 0 &&\n             token.charAt(tokenSlashOffset) == '/')\n         tokenSlashOffset--;\n      \n      String tokenSub = token.substring(\n            token.lastIndexOf('/'), tokenSlashOffset);\n      \n      for (QualifiedName qname : cachedResult.completions)\n      {\n         // File types are narrowed only by the file name\n         if (RCompletionType.isFileType(qname.type))\n         {\n            int fileNameSlashOffset = qname.name.length() - 1;\n            while (fileNameSlashOffset > 0 &&\n                   qname.name.charAt(fileNameSlashOffset) == '/')\n               fileNameSlashOffset--;\n            \n            String fileName = qname.name.substring(\n                  qname.name.lastIndexOf('/', fileNameSlashOffset));\n            \n            if (StringUtil.isSubsequence(fileName, tokenSub, true))\n               newCompletions.add(qname);\n         }\n         else\n            if (StringUtil.isSubsequence(qname.name, token, true))\n               newCompletions.add(qname) ;\n      }\n      \n      final String tokenLower = token.toLowerCase();\n      java.util.Collections.sort(newCompletions, new Comparator<QualifiedName>() {\n         \n         @Override\n         public int compare(QualifiedName lhs,\n                            QualifiedName rhs)\n         {\n            // Keep argument listings at the top\n            boolean lhsArg = lhs.type == RCompletionType.ARGUMENT;\n            boolean rhsArg = rhs.type == RCompletionType.ARGUMENT;\n            \n            if (lhsArg != rhsArg)\n            {\n               return lhsArg ? -1 : 1;\n            }\n            \n            int lhsScore = CodeSearchOracle.scoreMatch(lhs.name, tokenLower, false);\n            int rhsScore = CodeSearchOracle.scoreMatch(rhs.name, tokenLower, false);\n            \n            if (lhsScore == rhsScore)\n               return lhs.name.length() - rhs.name.length();\n            else\n               return lhsScore < rhsScore ? -1 : 1;\n         }\n      });\n       \n      \n      CompletionResult result = new CompletionResult(\n            token,\n            newCompletions,\n            cachedResult.guessedFunctionName,\n            cachedResult.suggestOnAccept,\n            cachedResult.dontInsertParens) ;\n      \n      cachedCompletions_.put(diff, result);\n      return result;\n   }","id":101502,"modified_method":"private CompletionResult narrow(String token,\n                                   String diff,\n                                   CompletionResult cachedResult)\n   {\n      ArrayList<QualifiedName> newCompletions = new ArrayList<QualifiedName>();\n      newCompletions.ensureCapacity(cachedResult.completions.size());\n      \n      // For completions that are files or directories, we need to post-process\n      // the token and the qualified name to strip out just the basename (filename).\n      // Note that we normalize the paths such that files will have no trailing slash,\n      // while directories will have one trailing slash (but we defend against multiple\n      // trailing slashes)\n      \n      // Transform the token once beforehand for potential file completions.\n      String tokenSub = token.toLowerCase().substring(\n            token.lastIndexOf('/') + 1);\n      \n      for (QualifiedName qname : cachedResult.completions)\n      {\n         // File types are narrowed only by the file name\n         if (RCompletionType.isFileType(qname.type))\n         {\n            String fileName = qname.name.toLowerCase().substring(\n                  qname.name.lastIndexOf('/'));\n            \n            if (StringUtil.isSubsequence(fileName, tokenSub, true))\n               newCompletions.add(qname);\n         }\n         else\n            if (StringUtil.isSubsequence(qname.name, token, true))\n               newCompletions.add(qname) ;\n      }\n      \n      final String tokenLower = token.toLowerCase();\n      final String tokenLowerSub = tokenLower.substring(tokenLower.lastIndexOf('/') + 1);\n      java.util.Collections.sort(newCompletions, new Comparator<QualifiedName>() {\n         \n         @Override\n         public int compare(QualifiedName lhs,\n                            QualifiedName rhs)\n         {\n            // Keep argument listings at the top\n            boolean lhsArg = lhs.type == RCompletionType.ARGUMENT;\n            boolean rhsArg = rhs.type == RCompletionType.ARGUMENT;\n            \n            if (lhsArg != rhsArg)\n            {\n               return lhsArg ? -1 : 1;\n            }\n            \n            // Files should first be ranked by their level of nesting\n            int lhsScore;\n            int rhsScore;\n            if (RCompletionType.isFileType(lhs.type) &&\n                RCompletionType.isFileType(rhs.type))\n            {\n               int lhsNestLevel = StringUtil.countMatches(lhs.name, '/');\n               int rhsNestLevel = StringUtil.countMatches(rhs.name, '/');\n               \n               if (lhsNestLevel != rhsNestLevel)\n                  return lhsNestLevel < rhsNestLevel ? -1 : 1;\n            }\n            \n            lhsScore = CodeSearchOracle.scoreMatch(lhs.name.toLowerCase(), tokenLower, false);\n            rhsScore = CodeSearchOracle.scoreMatch(rhs.name.toLowerCase(), tokenLower, false);\n\n            if (lhsScore == rhsScore)\n               return lhs.name.length() - rhs.name.length();\n            else\n               return lhsScore < rhsScore ? -1 : 1;\n         }\n      });\n      \n      CompletionResult result = new CompletionResult(\n            token,\n            newCompletions,\n            cachedResult.guessedFunctionName,\n            cachedResult.suggestOnAccept,\n            cachedResult.dontInsertParens) ;\n      \n      cachedCompletions_.put(diff, result);\n      return result;\n   }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void applyValue(final QualifiedName qualifiedName)\n      {\n         if (qualifiedName.source == \"`chunk-option`\")\n         {\n            applyValueRmdOption(qualifiedName.name);\n            return;\n         }\n         \n         boolean insertParen =\n               uiPrefs_.insertParensAfterFunctionCompletion().getValue() &&\n               RCompletionType.isFunctionType(qualifiedName.type);\n         \n         // Don't insert a paren if there is already a '(' following\n         // the cursor\n         AceEditor editor = (AceEditor) input_;\n         boolean textFollowingCursorIsOpenParen = false;\n         boolean textFollowingCursorIsClosingParen = false;\n         if (editor != null)\n         {\n            TokenCursor cursor =\n                  editor.getSession().getMode().getCodeModel().getTokenCursor();\n            cursor.moveToPosition(editor.getCursorPosition());\n            if (cursor.moveToNextToken())\n            {\n               textFollowingCursorIsOpenParen =\n                     cursor.currentValue() == \"(\";\n               textFollowingCursorIsClosingParen =\n                     cursor.currentValue() == \")\" && !cursor.bwdToMatchingToken();\n            }\n            \n         }\n\n         String value = qualifiedName.name;\n         String source = qualifiedName.source;\n         boolean shouldQuote = qualifiedName.shouldQuote;\n         \n         if (!RCompletionType.isFileType(qualifiedName.type))\n         {\n            if (value == \":=\")\n               value = quoteIfNotSyntacticNameCompletion(value);\n            else if (!value.matches(\".*[=:]\\\\s*$\") && \n                  !value.matches(\"^\\\\s*([`'\\\"]).*\\\\1\\\\s*$\") &&\n                  source != \"<file>\" &&\n                  source != \"<directory>\" &&\n                  source != \"`chunk-option`\" &&\n                  !value.startsWith(\"@\") &&\n                  !shouldQuote)\n               value = quoteIfNotSyntacticNameCompletion(value);\n         }\n\n         /* In some cases, applyValue can be called more than once\n          * as part of the same completion instance--specifically,\n          * if there's only one completion candidate and it is in\n          * a package. To make sure that the selection movement\n          * logic works the second time, we need to reset the\n          * selection.\n          */\n         \n         // Move range to beginning of token\n         input_.setSelection(new InputEditorSelection(\n               selection_.getStart().movePosition(-token_.length(), true),\n               input_.getSelection().getEnd()));\n\n         if (insertParen && !overrideInsertParens_ && !textFollowingCursorIsOpenParen)\n         {\n            // Don't replace the selection if the token ends with a ')'\n            // (implies an earlier replacement handled this)\n            if (token_.endsWith(\"(\"))\n            {\n               input_.setSelection(new InputEditorSelection(\n                     input_.getSelection().getEnd(),\n                     input_.getSelection().getEnd()));\n            }\n            else\n            {\n               // If the token after the cursor is already a ')', don't insert\n               // a closing paren\n               int relMovement = 0;\n               if (textFollowingCursorIsClosingParen || !uiPrefs_.insertMatching().getValue())\n               {\n                  input_.replaceSelection(value + \"(\", true);\n               }\n               else\n               {\n                  input_.replaceSelection(value + \"()\", true);\n                  relMovement = -1;\n               }\n               \n               // Move the cursor into the newly inserted parens\n               InputEditorSelection newSelection = new InputEditorSelection(\n                     input_.getSelection().getEnd().movePosition(\n                           relMovement, true));\n               \n               token_ = value + \"(\";\n               selection_ = new InputEditorSelection(\n                     input_.getSelection().getStart().movePosition(\n                           relMovement - 1, true),\n                     newSelection.getStart());\n\n               input_.setSelection(newSelection);\n            }\n         }\n         else\n         {\n            if (shouldQuote)\n               value = \"\\\"\" + value + \"\\\"\";\n            \n            // don't add spaces around equals if requested\n            final String kSpaceEquals = \" = \";\n            if (!uiPrefs_.insertSpacesAroundEquals().getValue() &&\n                value.endsWith(kSpaceEquals))\n            {\n               value = value.substring(0, value.length() - kSpaceEquals.length()) + \"=\";\n            }\n               \n\n            input_.replaceSelection(value, true);\n            token_ = value;\n            selection_ = input_.getSelection();\n         }\n         \n         // Show a signature popup if we just completed a function\n         if (RCompletionType.isFunctionType(qualifiedName.type))\n            displaySignatureToolTip(qualifiedName);\n      }","id":101503,"modified_method":"private void applyValue(final QualifiedName qualifiedName)\n      {\n         if (qualifiedName.source == \"`chunk-option`\")\n         {\n            applyValueRmdOption(qualifiedName.name);\n            return;\n         }\n         \n         boolean insertParen =\n               uiPrefs_.insertParensAfterFunctionCompletion().getValue() &&\n               RCompletionType.isFunctionType(qualifiedName.type);\n         \n         // Don't insert a paren if there is already a '(' following\n         // the cursor\n         AceEditor editor = (AceEditor) input_;\n         boolean textFollowingCursorIsOpenParen = false;\n         boolean textFollowingCursorIsClosingParen = false;\n         if (editor != null)\n         {\n            TokenCursor cursor =\n                  editor.getSession().getMode().getCodeModel().getTokenCursor();\n            cursor.moveToPosition(editor.getCursorPosition());\n            if (cursor.moveToNextToken())\n            {\n               textFollowingCursorIsOpenParen =\n                     cursor.currentValue() == \"(\";\n               textFollowingCursorIsClosingParen =\n                     cursor.currentValue() == \")\" && !cursor.bwdToMatchingToken();\n            }\n            \n         }\n\n         String value = qualifiedName.name;\n         String source = qualifiedName.source;\n         boolean shouldQuote = qualifiedName.shouldQuote;\n         \n         if (qualifiedName.type == RCompletionType.DIRECTORY)\n            value = value + \"/\";\n         \n         if (!RCompletionType.isFileType(qualifiedName.type))\n         {\n            if (value == \":=\")\n               value = quoteIfNotSyntacticNameCompletion(value);\n            else if (!value.matches(\".*[=:]\\\\s*$\") && \n                  !value.matches(\"^\\\\s*([`'\\\"]).*\\\\1\\\\s*$\") &&\n                  source != \"<file>\" &&\n                  source != \"<directory>\" &&\n                  source != \"`chunk-option`\" &&\n                  !value.startsWith(\"@\") &&\n                  !shouldQuote)\n               value = quoteIfNotSyntacticNameCompletion(value);\n         }\n\n         /* In some cases, applyValue can be called more than once\n          * as part of the same completion instance--specifically,\n          * if there's only one completion candidate and it is in\n          * a package. To make sure that the selection movement\n          * logic works the second time, we need to reset the\n          * selection.\n          */\n         \n         // Move range to beginning of token\n         input_.setSelection(new InputEditorSelection(\n               selection_.getStart().movePosition(-token_.length(), true),\n               input_.getSelection().getEnd()));\n\n         if (insertParen && !overrideInsertParens_ && !textFollowingCursorIsOpenParen)\n         {\n            // Don't replace the selection if the token ends with a ')'\n            // (implies an earlier replacement handled this)\n            if (token_.endsWith(\"(\"))\n            {\n               input_.setSelection(new InputEditorSelection(\n                     input_.getSelection().getEnd(),\n                     input_.getSelection().getEnd()));\n            }\n            else\n            {\n               // If the token after the cursor is already a ')', don't insert\n               // a closing paren\n               int relMovement = 0;\n               if (textFollowingCursorIsClosingParen || !uiPrefs_.insertMatching().getValue())\n               {\n                  input_.replaceSelection(value + \"(\", true);\n               }\n               else\n               {\n                  input_.replaceSelection(value + \"()\", true);\n                  relMovement = -1;\n               }\n               \n               // Move the cursor into the newly inserted parens\n               InputEditorSelection newSelection = new InputEditorSelection(\n                     input_.getSelection().getEnd().movePosition(\n                           relMovement, true));\n               \n               token_ = value + \"(\";\n               selection_ = new InputEditorSelection(\n                     input_.getSelection().getStart().movePosition(\n                           relMovement - 1, true),\n                     newSelection.getStart());\n\n               input_.setSelection(newSelection);\n            }\n         }\n         else\n         {\n            if (shouldQuote)\n               value = \"\\\"\" + value + \"\\\"\";\n            \n            // don't add spaces around equals if requested\n            final String kSpaceEquals = \" = \";\n            if (!uiPrefs_.insertSpacesAroundEquals().getValue() &&\n                value.endsWith(kSpaceEquals))\n            {\n               value = value.substring(0, value.length() - kSpaceEquals.length()) + \"=\";\n            }\n               \n\n            input_.replaceSelection(value, true);\n            token_ = value;\n            selection_ = input_.getSelection();\n         }\n         \n         // Show a signature popup if we just completed a function\n         if (RCompletionType.isFunctionType(qualifiedName.type))\n            displaySignatureToolTip(qualifiedName);\n      }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@-]\", \"\");\n      \n      // If we're in Markdown mode and have an appropriate string, try to get\n      // file completions\n      if (DocumentMode.isCursorInMarkdownMode(docDisplay_) &&\n            firstLine.matches(\".*\\\\[.*\\\\]\\\\(.*\"))\n         return getAutocompletionContextForFileMarkdownLink(firstLine);\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion. Note that we may need other contextual information\n      // to decide if e.g. we only want directories.\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n         addAutocompletionContextForFile(context, firstLine);\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', escape early as we'll be completing\n      // either from names or an overloaded `$` method\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', escape early as we'll be completing\n      // something from a namespace\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // Now strip the '$' and '@' post-hoc since they're not really part\n      // of the identifier\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      \n      // If this is an argument, return auto-completions tuned to that argument\n      TokenCursor argsCursor = startCursor.cloneCursor();\n      if (argsCursor.currentType() == \"identifier\")\n         argsCursor.moveToPreviousToken();\n      \n      if (argsCursor.currentValue() == \"=\")\n      {\n         if (argsCursor.moveToPreviousToken())\n         {\n            return new AutocompletionContext(\n                  token,\n                  argsCursor.currentValue(),\n                  AutocompletionContext.TYPE_ARGUMENT);\n         }\n      }\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\n               new String[]{ \"[\", \"(\" }, true);\n         \n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position\n      \n      // default case: use start cursor\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string\n      // We strip the current token so that the matched.call work later on\n      // can properly resolve the current argument\n      Position startPosition = startCursor.currentPosition();\n      if (startCursor.currentValue() == \"(\")\n         startPosition.setColumn(startPosition.getColumn() + 1);\n      \n      String beforeText = editor.getTextForRange(Range.fromPoints(\n            tokenCursor.currentPosition(),\n            startPosition));\n      \n      Position afterTokenPos = startCursor.currentPosition();\n      if (startCursor.currentType() == \"identifier\")\n         afterTokenPos.setColumn(afterTokenPos.getColumn() +\n               startCursor.currentValue().length());\n      \n      String afterText = editor.getTextForRange(Range.fromPoints(\n            afterTokenPos, endPos));\n            \n      context.setFunctionCallString(\n            (beforeText + afterText).trim());\n      \n      String initialData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition())).trim();\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition())).trim();\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","id":101504,"modified_method":"private AutocompletionContext getAutocompletionContext()\n   {\n      AutocompletionContext context = new AutocompletionContext();\n      \n      String firstLine = input_.getText();\n      int row = input_.getCursorPosition().getRow();\n      \n      // trim to cursor position\n      firstLine = firstLine.substring(0, input_.getCursorPosition().getColumn());\n      \n      // Get the token at the cursor position\n      String token = firstLine.replaceAll(\".*[^a-zA-Z0-9._:$@-]\", \"\");\n      \n      // If we're in Markdown mode and have an appropriate string, try to get\n      // file completions\n      if (DocumentMode.isCursorInMarkdownMode(docDisplay_) &&\n            firstLine.matches(\".*\\\\[.*\\\\]\\\\(.*\"))\n         return getAutocompletionContextForFileMarkdownLink(firstLine);\n      \n      // If we're completing an object within a string, assume it's a\n      // file-system completion. Note that we may need other contextual information\n      // to decide if e.g. we only want directories.\n      String firstLineStripped = StringUtil.stripBalancedQuotes(\n            StringUtil.stripRComment(firstLine));\n      \n      boolean isFileCompletion = false;\n      if (firstLineStripped.indexOf('\\'') != -1 || \n          firstLineStripped.indexOf('\"') != -1)\n      {\n         isFileCompletion = true;\n         addAutocompletionContextForFile(context, firstLine);\n      }\n      \n      // If this line starts with '```{', then we're completing chunk options\n      // pass the whole line as a token\n      if (firstLine.startsWith(\"```{\") || firstLine.startsWith(\"<<\"))\n         return new AutocompletionContext(firstLine, AutocompletionContext.TYPE_CHUNK);\n      \n      // If this line starts with a '?', assume it's a help query\n      if (firstLine.matches(\"^\\\\s*[?].*\"))\n         return new AutocompletionContext(token, AutocompletionContext.TYPE_HELP);\n      \n      // escape early for roxygen\n      if (firstLine.matches(\"\\\\s*#+'.*\"))\n         return new AutocompletionContext(\n               token, AutocompletionContext.TYPE_ROXYGEN);\n      \n      // If the token has '$' or '@', escape early as we'll be completing\n      // either from names or an overloaded `$` method\n      if (token.contains(\"$\") || token.contains(\"@\"))\n         addAutocompletionContextForDollar(context);\n      \n      // If the token has '::' or ':::', add that context. Note that\n      // we still need outer contexts (so that e.g., if we try\n      // 'debug(stats::rnorm)' we know not to auto-insert parens)\n      if (token.contains(\"::\"))\n         addAutocompletionContextForNamespace(token, context);\n      \n      // If this is not a file completion, we need to further strip and\n      // then set the token. Note that the token will have already been\n      // set if this is a file completion.\n      token = token.replaceAll(\".*[$@:]\", \"\");\n      if (!isFileCompletion)\n         context.setToken(token);\n      \n      // access to the R Code model\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return context;\n      \n      CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n      \n      // We might need to grab content from further up in the document than\n      // the current cursor position -- so tokenize ahead.\n      codeModel.tokenizeUpToRow(row + 100);\n      \n      // Make a token cursor and place it at the first token previous\n      // to the cursor.\n      TokenCursor tokenCursor = codeModel.getTokenCursor();\n      if (!tokenCursor.moveToPosition(input_.getCursorPosition()))\n         return context;\n      \n      TokenCursor startCursor = tokenCursor.cloneCursor();\n      \n      // If this is an argument, return auto-completions tuned to that argument\n      TokenCursor argsCursor = startCursor.cloneCursor();\n      if (argsCursor.currentType() == \"identifier\")\n         argsCursor.moveToPreviousToken();\n      \n      if (argsCursor.currentValue() == \"=\")\n      {\n         if (argsCursor.moveToPreviousToken())\n         {\n            return new AutocompletionContext(\n                  token,\n                  argsCursor.currentValue(),\n                  AutocompletionContext.TYPE_ARGUMENT);\n         }\n      }\n      \n      // Find an opening '(' or '[' -- this provides the function or object\n      // for completion.\n      int initialNumCommas = 0;\n      if (tokenCursor.currentValue() != \"(\" && tokenCursor.currentValue() != \"[\")\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\n               new String[]{ \"[\", \"(\" }, true);\n         \n         if (commaCount == -1)\n         {\n            commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n            if (commaCount == -1)\n               return context;\n            else\n               initialNumCommas = commaCount;\n         }\n         else\n         {\n            initialNumCommas = commaCount;\n         }\n      }\n      \n      // Figure out whether we're looking at '(', '[', or '[[',\n      // and place the token cursor on the first token preceding.\n      TokenCursor endOfDecl = tokenCursor.cloneCursor();\n      int initialDataType = AutocompletionContext.TYPE_UNKNOWN;\n      if (tokenCursor.currentValue() == \"(\")\n      {\n         initialDataType = AutocompletionContext.TYPE_FUNCTION;\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n      }\n      else if (tokenCursor.currentValue() == \"[\")\n      {\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!endOfDecl.moveToPreviousToken())\n               return context;\n            \n            initialDataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            initialDataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n      }\n      \n      // Get the string marking the function or data\n      if (!tokenCursor.findStartOfEvaluationContext())\n         return context;\n      \n      // Try to get the function call string -- either there's\n      // an associated closing paren we can use, or we should just go up\n      // to the current cursor position\n      \n      // default case: use start cursor\n      Position endPos = startCursor.currentPosition();\n      endPos.setColumn(endPos.getColumn() + startCursor.currentValue().length());\n      \n      // try to look forward for closing paren\n      if (endOfDecl.currentValue() == \"(\")\n      {\n         TokenCursor closingParenCursor = endOfDecl.cloneCursor();\n         if (closingParenCursor.fwdToMatchingToken())\n         {\n            endPos = closingParenCursor.currentPosition();\n            endPos.setColumn(endPos.getColumn() + 1);\n         }\n      }\n      \n      // We can now set the function call string\n      // We strip the current token so that the matched.call work later on\n      // can properly resolve the current argument\n      Position startPosition = startCursor.currentPosition();\n      if (startCursor.currentValue() == \"(\")\n         startPosition.setColumn(startPosition.getColumn() + 1);\n      \n      String beforeText = editor.getTextForRange(Range.fromPoints(\n            tokenCursor.currentPosition(),\n            startPosition));\n      \n      Position afterTokenPos = startCursor.currentPosition();\n      if (startCursor.currentType() == \"identifier\")\n         afterTokenPos.setColumn(afterTokenPos.getColumn() +\n               startCursor.currentValue().length());\n      \n      String afterText = editor.getTextForRange(Range.fromPoints(\n            afterTokenPos, endPos));\n            \n      context.setFunctionCallString(\n            (beforeText + afterText).trim());\n      \n      String initialData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  endOfDecl.currentPosition())).trim();\n      \n      // And the first context\n      context.add(initialData, initialDataType, initialNumCommas);\n\n      // Get the rest of the single-bracket contexts for completions as well\n      String assocData;\n      int dataType;\n      int numCommas;\n      while (true)\n      {\n         int commaCount = tokenCursor.findOpeningBracketCountCommas(\"[\", false);\n         if (commaCount == -1)\n            break;\n         \n         numCommas = commaCount;\n         \n         TokenCursor declEnd = tokenCursor.cloneCursor();\n         if (!tokenCursor.moveToPreviousToken())\n            return context;\n         \n         if (tokenCursor.currentValue() == \"[\")\n         {\n            if (!declEnd.moveToPreviousToken())\n               return context;\n            \n            dataType = AutocompletionContext.TYPE_DOUBLE_BRACKET;\n            if (!tokenCursor.moveToPreviousToken())\n               return context;\n         }\n         else\n         {\n            dataType = AutocompletionContext.TYPE_SINGLE_BRACKET;\n         }\n         \n         tokenCursor.findStartOfEvaluationContext();\n         \n         assocData =\n            docDisplay_.getTextForRange(Range.fromPoints(\n                  tokenCursor.currentPosition(),\n                  declEnd.currentPosition())).trim();\n         \n         context.add(assocData, dataType, numCommas);\n      }\n      \n      return context;\n      \n   }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"public boolean previewKeyDown(NativeEvent event)\n   {\n      if (sigTip_ != null)\n         if (sigTip_.previewKeyDown(event))\n            return true;\n      \n      /**\n       * KEYS THAT MATTER\n       *\n       * When popup not showing:\n       * Tab - attempt completion (handled in Console.java)\n       * \n       * When popup showing:\n       * Esc - dismiss popup\n       * Enter/Tab/Right-arrow - accept current selection\n       * Up-arrow/Down-arrow - change selected item\n       * Left-arrow - dismiss popup\n       * [identifier] - narrow suggestions--or if we're lame, just dismiss\n       * All others - dismiss popup\n       */\n      \n      nativeEvent_ = event;\n\n      int keycode = event.getKeyCode();\n      int modifier = KeyboardShortcut.getModifierValue(event);\n\n      if (!popup_.isShowing())\n      {\n         if (CompletionUtils.isCompletionRequest(event, modifier))\n         {\n            if (initFilter_ == null || initFilter_.shouldComplete(event))\n            {\n               // If we're in markdown mode, only autocomplete in '```{r',\n               // '[](', or '`r |' contexts\n               if (DocumentMode.isCursorInMarkdownMode(docDisplay_))\n               {\n                  String currentLine = docDisplay_.getCurrentLineUpToCursor();\n                  if (!(Pattern.create(\"^```{[rR]\").test(currentLine) ||\n                      Pattern.create(\".*\\\\[.*\\\\]\\\\(\").test(currentLine) ||\n                      (Pattern.create(\".*`r\").test(currentLine) &&\n                            StringUtil.countMatches(currentLine, '`') % 2 == 1)))\n                     return false;\n               }\n               \n               // If we're in tex mode, only provide completions in chunks\n               if (DocumentMode.isCursorInTexMode(docDisplay_))\n               {\n                  String currentLine = docDisplay_.getCurrentLineUpToCursor();\n                  if (!Pattern.create(\"^<<\").test(currentLine))\n                     return false;\n               }\n               return beginSuggest(true, false, true);\n            }\n         }\n         else if (keycode == 112 // F1\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToHelp();\n         }\n         else if (keycode == 113 // F2\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToFunctionDefinition();\n         }\n      }\n      else\n      {\n         switch (keycode)\n         {\n         // chrome on ubuntu now sends this before every keydown\n         // so we need to explicitly ignore it. see:\n         // https://github.com/ivaynberg/select2/issues/2482\n         case KeyCodes.KEY_WIN_IME: \n            return false ;\n            \n         case KeyCodes.KEY_SHIFT:\n         case KeyCodes.KEY_CTRL:\n         case KeyCodes.KEY_ALT:\n         case KeyCodes.KEY_MAC_FF_META:\n         case KeyCodes.KEY_WIN_KEY_LEFT_META:\n            return false ; // bare modifiers should do nothing\n         }\n         \n         if (modifier == KeyboardShortcut.NONE)\n         {\n            if (keycode == KeyCodes.KEY_ESCAPE)\n            {\n               invalidatePendingRequests() ;\n               return true ;\n            }\n            \n            // NOTE: It is possible for the popup to still be showing, but\n            // showing offscreen with no values. We only grab these keys\n            // when the popup is both showing, and has completions.\n            // This functionality is here to ensure backspace works properly;\n            // e.g \"stats::rna\" -> \"stats::rn\" brings completions if the user\n            // had originally requested completions at e.g. \"stats::\".\n            if (popup_.hasCompletions())\n            {\n               if (keycode == KeyCodes.KEY_TAB\n                     || keycode == KeyCodes.KEY_ENTER\n                     || keycode == KeyCodes.KEY_RIGHT)\n               {\n                  QualifiedName value = popup_.getSelectedValue() ;\n                  if (value != null)\n                  {\n                     context_.onSelection(value) ;\n                     return true ;\n                  }\n               }\n               \n               else if (keycode == KeyCodes.KEY_UP)\n                  return popup_.selectPrev() ;\n               else if (keycode == KeyCodes.KEY_DOWN)\n                  return popup_.selectNext() ;\n               else if (keycode == KeyCodes.KEY_PAGEUP)\n                  return popup_.selectPrevPage() ;\n               else if (keycode == KeyCodes.KEY_PAGEDOWN)\n                  return popup_.selectNextPage() ;\n               else if (keycode == KeyCodes.KEY_HOME)\n                  return popup_.selectFirst() ;\n               else if (keycode == KeyCodes.KEY_END)\n                  return popup_.selectLast() ;\n               else if (keycode == KeyCodes.KEY_LEFT)\n               {\n                  invalidatePendingRequests() ;\n                  return true ;\n               }\n               if (keycode == 112) // F1\n               {\n                  context_.showHelpTopic() ;\n                  return true ;\n               }\n               else if (keycode == 113) // F2\n               {\n                  goToFunctionDefinition();\n                  return true;\n               }\n            }\n            \n         }\n         \n         if (canContinueCompletions(event))\n            return false;\n         \n         // if we insert a '/', we're probably forming a directory --\n         // pop up completions\n         if (keycode == 191 && modifier == KeyboardShortcut.NONE)\n         {\n            input_.insertCode(\"/\");\n            return beginSuggest(true, true, false);\n         }\n         \n         // continue showing completions on backspace\n         if (keycode == KeyCodes.KEY_BACKSPACE && modifier == KeyboardShortcut.NONE)\n         {\n            int cursorColumn = input_.getCursorPosition().getColumn();\n            String currentLine = docDisplay_.getCurrentLine();\n            \n            // only suggest if the character previous to the cursor is an R identifier\n            // also halt suggestions if we're about to remove the only character on the line\n            if (cursorColumn > 0)\n            {\n               char ch = currentLine.charAt(cursorColumn - 2);\n               char prevCh = currentLine.charAt(cursorColumn - 3);\n               \n               boolean isAcceptableCharSequence = isValidForRIdentifier(ch) ||\n                     (ch == ':' && prevCh == ':') ||\n                     ch == '$' ||\n                     ch == '@' ||\n                     ch == '/'; // for file completions\n               \n               if (currentLine.length() > 0 &&\n                     cursorColumn > 0 &&\n                     isAcceptableCharSequence)\n               {\n                  // manually remove the previous character\n                  InputEditorSelection selection = input_.getSelection();\n                  InputEditorPosition start = selection.getStart().movePosition(-1, true);\n                  InputEditorPosition end = selection.getStart();\n\n                  if (currentLine.charAt(cursorColumn) == ')' && currentLine.charAt(cursorColumn - 1) == '(')\n                  {\n                     // flush cache as old completions no longer relevant\n                     requester_.flushCache();\n                     end = selection.getStart().movePosition(1, true);\n                  }\n\n                  input_.setSelection(new InputEditorSelection(start, end));\n                  input_.replaceSelection(\"\", false);\n                  \n                  return beginSuggest(false, false, false);\n               }\n            }\n            else\n            {\n               invalidatePendingRequests();\n               return true;\n            }\n         }\n         \n         invalidatePendingRequests();\n         return false ;\n      }\n      \n      return false ;\n   }","id":101505,"modified_method":"public boolean previewKeyDown(NativeEvent event)\n   {\n      if (sigTip_ != null)\n         if (sigTip_.previewKeyDown(event))\n            return true;\n      \n      /**\n       * KEYS THAT MATTER\n       *\n       * When popup not showing:\n       * Tab - attempt completion (handled in Console.java)\n       * \n       * When popup showing:\n       * Esc - dismiss popup\n       * Enter/Tab/Right-arrow - accept current selection\n       * Up-arrow/Down-arrow - change selected item\n       * Left-arrow - dismiss popup\n       * [identifier] - narrow suggestions--or if we're lame, just dismiss\n       * All others - dismiss popup\n       */\n      \n      nativeEvent_ = event;\n\n      int keycode = event.getKeyCode();\n      int modifier = KeyboardShortcut.getModifierValue(event);\n\n      if (!popup_.isShowing())\n      {\n         if (CompletionUtils.isCompletionRequest(event, modifier))\n         {\n            if (initFilter_ == null || initFilter_.shouldComplete(event))\n            {\n               // If we're in markdown mode, only autocomplete in '```{r',\n               // '[](', or '`r |' contexts\n               if (DocumentMode.isCursorInMarkdownMode(docDisplay_))\n               {\n                  String currentLine = docDisplay_.getCurrentLineUpToCursor();\n                  if (!(Pattern.create(\"^```{[rR]\").test(currentLine) ||\n                      Pattern.create(\".*\\\\[.*\\\\]\\\\(\").test(currentLine) ||\n                      (Pattern.create(\".*`r\").test(currentLine) &&\n                            StringUtil.countMatches(currentLine, '`') % 2 == 1)))\n                     return false;\n               }\n               \n               // If we're in tex mode, only provide completions in chunks\n               if (DocumentMode.isCursorInTexMode(docDisplay_))\n               {\n                  String currentLine = docDisplay_.getCurrentLineUpToCursor();\n                  if (!Pattern.create(\"^<<\").test(currentLine))\n                     return false;\n               }\n               return beginSuggest(true, false, true);\n            }\n         }\n         else if (keycode == 112 // F1\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToHelp();\n         }\n         else if (keycode == 113 // F2\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToFunctionDefinition();\n         }\n      }\n      else\n      {\n         switch (keycode)\n         {\n         // chrome on ubuntu now sends this before every keydown\n         // so we need to explicitly ignore it. see:\n         // https://github.com/ivaynberg/select2/issues/2482\n         case KeyCodes.KEY_WIN_IME: \n            return false ;\n            \n         case KeyCodes.KEY_SHIFT:\n         case KeyCodes.KEY_CTRL:\n         case KeyCodes.KEY_ALT:\n         case KeyCodes.KEY_MAC_FF_META:\n         case KeyCodes.KEY_WIN_KEY_LEFT_META:\n            return false ; // bare modifiers should do nothing\n         }\n         \n         if (modifier == KeyboardShortcut.NONE)\n         {\n            if (keycode == KeyCodes.KEY_ESCAPE)\n            {\n               invalidatePendingRequests() ;\n               return true ;\n            }\n            \n            // NOTE: It is possible for the popup to still be showing, but\n            // showing offscreen with no values. We only grab these keys\n            // when the popup is both showing, and has completions.\n            // This functionality is here to ensure backspace works properly;\n            // e.g \"stats::rna\" -> \"stats::rn\" brings completions if the user\n            // had originally requested completions at e.g. \"stats::\".\n            if (popup_.hasCompletions())\n            {\n               if (keycode == KeyCodes.KEY_ENTER)\n               {\n                  QualifiedName value = popup_.getSelectedValue() ;\n                  if (value != null)\n                  {\n                     context_.onSelection(value) ;\n                     return true ;\n                  }\n               }\n               \n               else if (keycode == KeyCodes.KEY_TAB ||\n                        keycode == KeyCodes.KEY_RIGHT)\n               {\n                  QualifiedName value = popup_.getSelectedValue() ;\n                  if (value != null)\n                  {\n                     if (value.type == RCompletionType.DIRECTORY)\n                        context_.suggestOnAccept_ = true;\n                     \n                     context_.onSelection(value);\n                     return true;\n                  }\n               }\n               \n               else if (keycode == KeyCodes.KEY_UP)\n                  return popup_.selectPrev() ;\n               else if (keycode == KeyCodes.KEY_DOWN)\n                  return popup_.selectNext() ;\n               else if (keycode == KeyCodes.KEY_PAGEUP)\n                  return popup_.selectPrevPage() ;\n               else if (keycode == KeyCodes.KEY_PAGEDOWN)\n                  return popup_.selectNextPage() ;\n               else if (keycode == KeyCodes.KEY_HOME)\n                  return popup_.selectFirst() ;\n               else if (keycode == KeyCodes.KEY_END)\n                  return popup_.selectLast() ;\n               else if (keycode == KeyCodes.KEY_LEFT)\n               {\n                  invalidatePendingRequests() ;\n                  return true ;\n               }\n               if (keycode == 112) // F1\n               {\n                  context_.showHelpTopic() ;\n                  return true ;\n               }\n               else if (keycode == 113) // F2\n               {\n                  goToFunctionDefinition();\n                  return true;\n               }\n            }\n            \n         }\n         \n         if (canContinueCompletions(event))\n            return false;\n         \n         // if we insert a '/', we're probably forming a directory --\n         // pop up completions\n         if (keycode == 191 && modifier == KeyboardShortcut.NONE)\n         {\n            input_.insertCode(\"/\");\n            return beginSuggest(true, true, false);\n         }\n         \n         // continue showing completions on backspace\n         if (keycode == KeyCodes.KEY_BACKSPACE && modifier == KeyboardShortcut.NONE)\n         {\n            int cursorColumn = input_.getCursorPosition().getColumn();\n            String currentLine = docDisplay_.getCurrentLine();\n            \n            // only suggest if the character previous to the cursor is an R identifier\n            // also halt suggestions if we're about to remove the only character on the line\n            if (cursorColumn > 0)\n            {\n               char ch = currentLine.charAt(cursorColumn - 2);\n               char prevCh = currentLine.charAt(cursorColumn - 3);\n               \n               boolean isAcceptableCharSequence = isValidForRIdentifier(ch) ||\n                     (ch == ':' && prevCh == ':') ||\n                     ch == '$' ||\n                     ch == '@' ||\n                     ch == '/'; // for file completions\n               \n               if (currentLine.length() > 0 &&\n                     cursorColumn > 0 &&\n                     isAcceptableCharSequence)\n               {\n                  // manually remove the previous character\n                  InputEditorSelection selection = input_.getSelection();\n                  InputEditorPosition start = selection.getStart().movePosition(-1, true);\n                  InputEditorPosition end = selection.getStart();\n\n                  if (currentLine.charAt(cursorColumn) == ')' && currentLine.charAt(cursorColumn - 1) == '(')\n                  {\n                     // flush cache as old completions no longer relevant\n                     requester_.flushCache();\n                     end = selection.getStart().movePosition(1, true);\n                  }\n\n                  input_.setSelection(new InputEditorSelection(start, end));\n                  input_.replaceSelection(\"\", false);\n                  \n                  return beginSuggest(false, false, false);\n               }\n            }\n            else\n            {\n               invalidatePendingRequests();\n               return true;\n            }\n         }\n         \n         invalidatePendingRequests();\n         return false ;\n      }\n      \n      return false ;\n   }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void addAutocompletionContextForFile(AutocompletionContext context,\n                                         String line)\n   {\n      int index = Math.max(line.lastIndexOf('\"'), line.lastIndexOf('\\''));\n      context.add(line.substring(index + 1), AutocompletionContext.TYPE_FILE);\n   }","id":101506,"modified_method":"private void addAutocompletionContextForFile(AutocompletionContext context,\n                                                String line)\n   {\n      int index = Math.max(line.lastIndexOf('\"'), line.lastIndexOf('\\''));\n      String token = line.substring(index + 1);\n      context.add(token, AutocompletionContext.TYPE_FILE);\n      context.setToken(token);\n   }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n      public void onResponseReceived(CompletionResult completions)\n      {\n         if (invalidationToken_.isInvalid())\n            return ;\n         \n         // Only display the top completions\n         final QualifiedName[] results =\n               completions.completions.toArray(new QualifiedName[0]);\n         \n         if (results.length == 0)\n         {\n            popup_.clearCompletions();\n            boolean lastInputWasTab =\n                  (nativeEvent_ != null && nativeEvent_.getKeyCode() == KeyCodes.KEY_TAB);\n            \n            boolean lineIsWhitespace = docDisplay_.getCurrentLine().matches(\"^\\\\s*$\");\n            \n            if (lastInputWasTab && lineIsWhitespace)\n            {\n               docDisplay_.insertCode(\"\\t\");\n               return;\n            }\n            \n            if (canAutoAccept_)\n            {\n               popup_.showErrorMessage(\n                     \"(No matches)\", \n                     new PopupPositioner(input_.getCursorBounds(), popup_));\n            }\n            else\n            {\n               // Show an empty popup message offscreen -- this is a hack to\n               // ensure that we can get completion results on backspace after a\n               // failed completion, e.g. 'stats::rna' -> 'stats::rn'\n               Rectangle offScreen = new Rectangle(-100, -100, 0, 0);\n               popup_.showErrorMessage(\n                     \"\",\n                     new PopupPositioner(offScreen, popup_));\n            }\n            \n            return ;\n         }\n\n         // Move range to beginning of token; we want to place the popup there.\n         final String token = completions.token ;\n\n         Rectangle rect = input_.getPositionBounds(\n               selection_.getStart().movePosition(-token.length(), true));\n\n         token_ = token;\n         suggestOnAccept_ = completions.suggestOnAccept;\n         overrideInsertParens_ = completions.dontInsertParens;\n\n         if (results.length == 1\n             && canAutoAccept_\n             && StringUtil.isNullOrEmpty(results[0].source))\n         {\n            onSelection(results[0]);\n         }\n         else\n         {\n            if (results.length == 1 && canAutoAccept_)\n               applyValue(results[0]);\n            else\n               popup_.showCompletionValues(\n                     results,\n                     new PopupPositioner(rect, popup_),\n                     false);\n         }\n      }","id":101507,"modified_method":"@Override\n      public void onResponseReceived(CompletionResult completions)\n      {\n         if (invalidationToken_.isInvalid())\n            return ;\n         \n         // Only display the top completions\n         final QualifiedName[] results =\n               completions.completions.toArray(new QualifiedName[0]);\n         \n         if (results.length == 0)\n         {\n            popup_.clearCompletions();\n            boolean lastInputWasTab =\n                  (nativeEvent_ != null && nativeEvent_.getKeyCode() == KeyCodes.KEY_TAB);\n            \n            boolean lineIsWhitespace = docDisplay_.getCurrentLine().matches(\"^\\\\s*$\");\n            \n            if (lastInputWasTab && lineIsWhitespace)\n            {\n               docDisplay_.insertCode(\"\\t\");\n               return;\n            }\n            \n            if (canAutoAccept_)\n            {\n               popup_.showErrorMessage(\n                     \"(No matches)\", \n                     new PopupPositioner(input_.getCursorBounds(), popup_));\n            }\n            else\n            {\n               // Show an empty popup message offscreen -- this is a hack to\n               // ensure that we can get completion results on backspace after a\n               // failed completion, e.g. 'stats::rna' -> 'stats::rn'\n               Rectangle offScreen = new Rectangle(-100, -100, 0, 0);\n               popup_.showErrorMessage(\n                     \"\",\n                     new PopupPositioner(offScreen, popup_));\n            }\n            \n            return ;\n         }\n\n         // Move range to beginning of token; we want to place the popup there.\n         final String token = completions.token ;\n\n         Rectangle rect = input_.getPositionBounds(\n               selection_.getStart().movePosition(-token.length(), true));\n\n         token_ = token;\n         suggestOnAccept_ = completions.suggestOnAccept;\n         overrideInsertParens_ = completions.dontInsertParens;\n\n         if (results.length == 1\n             && canAutoAccept_\n             && results[0].type != RCompletionType.DIRECTORY\n             && StringUtil.isNullOrEmpty(results[0].source))\n         {\n            onSelection(results[0]);\n         }\n         else\n         {\n            if (results.length == 1\n                  && results[0].type != RCompletionType.DIRECTORY\n                  && canAutoAccept_)\n               applyValue(results[0]);\n            else\n               popup_.showCompletionValues(\n                     results,\n                     new PopupPositioner(rect, popup_),\n                     false);\n         }\n      }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void onSelection(QualifiedName qname)\n      {\n         final String value = qname.name ;\n         \n         if (invalidationToken_.isInvalid())\n            return ;\n         \n         requester_.flushCache() ;\n         helpStrategy_.clearCache();\n         \n         if (value == null)\n         {\n            assert false : \"Selected comp value is null\" ;\n            return ;\n         }\n\n         applyValue(qname);\n         if (suggestOnAccept_ || qname.name.endsWith(\":\") ||\n             (qname.name.endsWith(\"/\") && nativeEvent_ != null &&\n              nativeEvent_.getKeyCode() == KeyCodes.KEY_TAB))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, false);\n               }\n            });\n         }\n         else\n         {\n            popup_.hide() ;\n            popup_.clearHelp(false);\n            popup_.setHelpVisible(false);\n         }\n         \n      }","id":101508,"modified_method":"private void onSelection(QualifiedName qname)\n      {\n         final String value = qname.name ;\n         \n         if (invalidationToken_.isInvalid())\n            return ;\n         \n         requester_.flushCache() ;\n         helpStrategy_.clearCache();\n         \n         if (value == null)\n         {\n            assert false : \"Selected comp value is null\" ;\n            return ;\n         }\n\n         applyValue(qname);\n         if (suggestOnAccept_ || qname.name.endsWith(\":\"))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, false);\n               }\n            });\n         }\n         else\n         {\n            popup_.hide() ;\n            popup_.clearHelp(false);\n            popup_.setHelpVisible(false);\n         }\n         \n      }","commit_id":"55f509d8282fdf207198ad187c9fb92ac6899bb0","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\n   * Delete a file optionally configuring trash on the server and client.\n   */\n  private void deleteFileUsingTrash(\n      boolean serverTrash, boolean clientTrash) throws Exception {\n    // Run a cluster, optionally with trash enabled on the server\n    Configuration serverConf = new HdfsConfiguration();\n    if (serverTrash) {\n      serverConf.setLong(FS_TRASH_INTERVAL_KEY, 1);\n    }\n\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(serverConf)\n      .numDataNodes(1).format(true).build();\n    Configuration clientConf = new Configuration(serverConf);\n\n    // Create a client, optionally with trash enabled\n    if (clientTrash) {\n      clientConf.setLong(FS_TRASH_INTERVAL_KEY, 1);\n    } else {\n      clientConf.setLong(FS_TRASH_INTERVAL_KEY, 0);\n    }\n\n    FsShell shell = new FsShell(clientConf);\n    FileSystem fs = null;\n\n    try {\n      // Create and delete a file\n      fs = cluster.getFileSystem();\n      writeFile(fs, new Path(TEST_ROOT_DIR, \"foo\"));\n      final String testFile = TEST_ROOT_DIR + \"/foo\";\n      final String trashFile = shell.getCurrentTrashDir() + \"/\" + testFile;\n      String[] argv = new String[] { \"-rm\", testFile };\n      int res = ToolRunner.run(shell, argv);\n      assertEquals(\"rm failed\", 0, res);\n\n      if (serverTrash) {\n        // If the server config was set we should use it unconditionally\n        assertTrue(\"File not in trash\", fs.exists(new Path(trashFile)));\n      } else if (clientTrash) {\n        // If the server config was not set but the client config was\n        // set then we should use it\n        assertTrue(\"File not in trashed\", fs.exists(new Path(trashFile)));\n      } else {\n        // If neither was set then we should not have trashed the file\n        assertFalse(\"File was not removed\", fs.exists(new Path(testFile)));\n        assertFalse(\"File was trashed\", fs.exists(new Path(trashFile)));\n      }\n    } finally {\n      if (fs != null) {\n        fs.close();\n      }\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n    }\n  }","id":101509,"modified_method":"/**\n   * Delete a file optionally configuring trash on the server and client.\n   */\n  private void deleteFileUsingTrash(\n      boolean serverTrash, boolean clientTrash) throws Exception {\n    // Run a cluster, optionally with trash enabled on the server\n    Configuration serverConf = new HdfsConfiguration();\n    if (serverTrash) {\n      serverConf.setLong(FS_TRASH_INTERVAL_KEY, 1);\n    }\n\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(serverConf)\n      .numDataNodes(1).format(true).build();\n    Configuration clientConf = new Configuration(serverConf);\n\n    // Create a client, optionally with trash enabled\n    if (clientTrash) {\n      clientConf.setLong(FS_TRASH_INTERVAL_KEY, 1);\n    } else {\n      clientConf.setLong(FS_TRASH_INTERVAL_KEY, 0);\n    }\n\n    FsShell shell = new FsShell(clientConf);\n    FileSystem fs = null;\n\n    try {\n      // Create and delete a file\n      fs = cluster.getFileSystem();\n\n      // Use a separate tmp dir for each invocation.\n      final String testdir = \"/tmp/TestDFSShell-deleteFileUsingTrash-\" +\n          counter.getAndIncrement();\n\n      writeFile(fs, new Path(testdir, \"foo\"));\n      final String testFile = testdir + \"/foo\";\n      final String trashFile = shell.getCurrentTrashDir() + \"/\" + testFile;\n      String[] argv = new String[] { \"-rm\", testFile };\n      int res = ToolRunner.run(shell, argv);\n      assertEquals(\"rm failed\", 0, res);\n\n      if (serverTrash) {\n        // If the server config was set we should use it unconditionally\n        assertTrue(\"File not in trash\", fs.exists(new Path(trashFile)));\n      } else if (clientTrash) {\n        // If the server config was not set but the client config was\n        // set then we should use it\n        assertTrue(\"File not in trashed\", fs.exists(new Path(trashFile)));\n      } else {\n        // If neither was set then we should not have trashed the file\n        assertFalse(\"File was not removed\", fs.exists(new Path(testFile)));\n        assertFalse(\"File was trashed\", fs.exists(new Path(trashFile)));\n      }\n    } finally {\n      if (fs != null) {\n        fs.close();\n      }\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n    }\n  }","commit_id":"c2e186bae61e0d6efe0279bd3565528b9bd47f41","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Test chmod.\n   */\n  void testChmod(Configuration conf, FileSystem fs, String chmodDir) \n                                                    throws IOException {\n    FsShell shell = new FsShell();\n    shell.setConf(conf);\n    \n    try {\n     //first make dir\n     Path dir = new Path(chmodDir);\n     fs.delete(dir, true);\n     fs.mkdirs(dir);\n\n     confirmPermissionChange(/* Setting */ \"u+rwx,g=rw,o-rwx\",\n                             /* Should give */ \"rwxrw----\", fs, shell, dir);\n     \n     //create an empty file\n     Path file = new Path(chmodDir, \"file\");\n     TestDFSShell.writeFile(fs, file);\n\n     //test octal mode\n     confirmPermissionChange( \"644\", \"rw-r--r--\", fs, shell, file);\n\n     //test recursive\n     runCmd(shell, \"-chmod\", \"-R\", \"a+rwX\", chmodDir);\n     assertEquals(\"rwxrwxrwx\",\n                  fs.getFileStatus(dir).getPermission().toString()); \n     assertEquals(\"rw-rw-rw-\",\n                  fs.getFileStatus(file).getPermission().toString());\n\n     // test sticky bit on directories\n     Path dir2 = new Path(dir, \"stickybit\" );\n     fs.mkdirs(dir2 );\n     LOG.info(\"Testing sticky bit on: \" + dir2);\n     LOG.info(\"Sticky bit directory initial mode: \" + \n                   fs.getFileStatus(dir2).getPermission());\n     \n     confirmPermissionChange(\"u=rwx,g=rx,o=rx\", \"rwxr-xr-x\", fs, shell, dir2);\n     \n     confirmPermissionChange(\"+t\", \"rwxr-xr-t\", fs, shell, dir2);\n\n     confirmPermissionChange(\"-t\", \"rwxr-xr-x\", fs, shell, dir2);\n\n     confirmPermissionChange(\"=t\", \"--------T\", fs, shell, dir2);\n\n     confirmPermissionChange(\"0000\", \"---------\", fs, shell, dir2);\n\n     confirmPermissionChange(\"1666\", \"rw-rw-rwT\", fs, shell, dir2);\n\n     confirmPermissionChange(\"777\", \"rwxrwxrwt\", fs, shell, dir2);\n     \n     fs.delete(dir2, true);\n     fs.delete(dir, true);\n     \n    } finally {\n      try {\n        fs.close();\n        shell.close();\n      } catch (IOException ignored) {}\n    }\n  }","id":101510,"modified_method":"/**\n   * Test chmod.\n   */\n  void testChmod(Configuration conf, FileSystem fs, String chmodDir) \n                                                    throws IOException {\n    FsShell shell = new FsShell();\n    shell.setConf(conf);\n    \n    try {\n      //first make dir\n      Path dir = new Path(chmodDir);\n      fs.delete(dir, true);\n      fs.mkdirs(dir);\n\n      confirmPermissionChange(/* Setting */ \"u+rwx,g=rw,o-rwx\",\n                             /* Should give */ \"rwxrw----\", fs, shell, dir);\n\n      //create an empty file\n      Path file = new Path(chmodDir, \"file\");\n      TestDFSShell.writeFile(fs, file);\n\n      //test octal mode\n      confirmPermissionChange(\"644\", \"rw-r--r--\", fs, shell, file);\n\n      //test recursive\n      runCmd(shell, \"-chmod\", \"-R\", \"a+rwX\", chmodDir);\n      assertEquals(\"rwxrwxrwx\",\n          fs.getFileStatus(dir).getPermission().toString());\n      assertEquals(\"rw-rw-rw-\",\n          fs.getFileStatus(file).getPermission().toString());\n\n      // Skip \"sticky bit\" tests on Windows.\n      //\n      if (!Path.WINDOWS) {\n        // test sticky bit on directories\n        Path dir2 = new Path(dir, \"stickybit\");\n        fs.mkdirs(dir2);\n        LOG.info(\"Testing sticky bit on: \" + dir2);\n        LOG.info(\"Sticky bit directory initial mode: \" +\n            fs.getFileStatus(dir2).getPermission());\n\n        confirmPermissionChange(\"u=rwx,g=rx,o=rx\", \"rwxr-xr-x\", fs, shell, dir2);\n\n        confirmPermissionChange(\"+t\", \"rwxr-xr-t\", fs, shell, dir2);\n\n        confirmPermissionChange(\"-t\", \"rwxr-xr-x\", fs, shell, dir2);\n\n        confirmPermissionChange(\"=t\", \"--------T\", fs, shell, dir2);\n\n        confirmPermissionChange(\"0000\", \"---------\", fs, shell, dir2);\n\n        confirmPermissionChange(\"1666\", \"rw-rw-rwT\", fs, shell, dir2);\n\n        confirmPermissionChange(\"777\", \"rwxrwxrwt\", fs, shell, dir2);\n\n        fs.delete(dir2, true);\n      } else {\n        LOG.info(\"Skipped sticky bit tests on Windows\");\n      }\n\n      fs.delete(dir, true);\n\n    } finally {\n      try {\n        fs.close();\n        shell.close();\n      } catch (IOException ignored) {}\n    }\n  }","commit_id":"c2e186bae61e0d6efe0279bd3565528b9bd47f41","url":"https://github.com/apache/hadoop"},{"original_method":"@Test (timeout = 30000)\n  public void testCopyCommandsWithForceOption() throws Exception {\n    Configuration conf = new Configuration();\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).numDataNodes(1)\n        .format(true).build();\n    FsShell shell = null;\n    FileSystem fs = null;\n    final File localFile = new File(TEST_ROOT_DIR, \"testFileForPut\");\n    final String localfilepath = localFile.getAbsolutePath();\n    final String testdir = TEST_ROOT_DIR + \"/ForceTestDir\";\n    final Path hdfsTestDir = new Path(testdir);\n    try {\n      fs = cluster.getFileSystem();\n      fs.mkdirs(hdfsTestDir);\n      localFile.createNewFile();\n      writeFile(fs, new Path(TEST_ROOT_DIR, \"testFileForPut\"));\n      shell = new FsShell();\n\n      // Tests for put\n      String[] argv = new String[] { \"-put\", \"-f\", localfilepath, testdir };\n      int res = ToolRunner.run(shell, argv);\n      int SUCCESS = 0;\n      int ERROR = 1;\n      assertEquals(\"put -f is not working\", SUCCESS, res);\n\n      argv = new String[] { \"-put\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"put command itself is able to overwrite the file\", ERROR,\n          res);\n\n      // Tests for copyFromLocal\n      argv = new String[] { \"-copyFromLocal\", \"-f\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"copyFromLocal -f is not working\", SUCCESS, res);\n\n      argv = new String[] { \"-copyFromLocal\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\n          \"copyFromLocal command itself is able to overwrite the file\", ERROR,\n          res);\n\n      // Tests for cp\n      argv = new String[] { \"-cp\", \"-f\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"cp -f is not working\", SUCCESS, res);\n\n      argv = new String[] { \"-cp\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"cp command itself is able to overwrite the file\", ERROR,\n          res);\n    } finally {\n      if (null != shell)\n        shell.close();\n\n      if (localFile.exists())\n        localFile.delete();\n\n      if (null != fs) {\n        fs.delete(hdfsTestDir, true);\n        fs.close();\n      }\n      cluster.shutdown();\n    }\n\n  }","id":101511,"modified_method":"@Test (timeout = 30000)\n  public void testCopyCommandsWithForceOption() throws Exception {\n    final int SUCCESS = 0;\n    final int ERROR = 1;\n\n    Configuration conf = new Configuration();\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).numDataNodes(1)\n        .format(true).build();\n    FsShell shell = null;\n    FileSystem fs = null;\n    final File localFile = new File(TEST_ROOT_DIR, \"testFileForPut\");\n    final String localfilepath = new Path(localFile.getAbsolutePath()).toUri().toString();\n    final String testdir = \"/tmp/TestDFSShell-testCopyCommandsWithForceOption-\"\n        + counter.getAndIncrement();\n    final Path hdfsTestDir = new Path(testdir);\n    try {\n      fs = cluster.getFileSystem();\n      fs.mkdirs(hdfsTestDir);\n      localFile.createNewFile();\n      writeFile(fs, new Path(testdir, \"testFileForPut\"));\n      shell = new FsShell();\n\n      // Tests for put\n      String[] argv = new String[] { \"-put\", \"-f\", localfilepath, testdir };\n      int res = ToolRunner.run(shell, argv);\n      assertEquals(\"put -f is not working\", SUCCESS, res);\n\n      argv = new String[] { \"-put\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"put command itself is able to overwrite the file\", ERROR,\n          res);\n\n      // Tests for copyFromLocal\n      argv = new String[] { \"-copyFromLocal\", \"-f\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"copyFromLocal -f is not working\", SUCCESS, res);\n\n      argv = new String[] { \"-copyFromLocal\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\n          \"copyFromLocal command itself is able to overwrite the file\", ERROR,\n          res);\n\n      // Tests for cp\n      argv = new String[] { \"-cp\", \"-f\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"cp -f is not working\", SUCCESS, res);\n\n      argv = new String[] { \"-cp\", localfilepath, testdir };\n      res = ToolRunner.run(shell, argv);\n      assertEquals(\"cp command itself is able to overwrite the file\", ERROR,\n          res);\n    } finally {\n      if (null != shell)\n        shell.close();\n\n      if (localFile.exists())\n        localFile.delete();\n\n      if (null != fs) {\n        fs.delete(hdfsTestDir, true);\n        fs.close();\n      }\n      cluster.shutdown();\n    }\n\n  }","commit_id":"c2e186bae61e0d6efe0279bd3565528b9bd47f41","url":"https://github.com/apache/hadoop"},{"original_method":"@Test (timeout = 30000)\n  public void testURIPaths() throws Exception {\n    Configuration srcConf = new HdfsConfiguration();\n    Configuration dstConf = new HdfsConfiguration();\n    MiniDFSCluster srcCluster =  null;\n    MiniDFSCluster dstCluster = null;\n    String bak = System.getProperty(\"test.build.data\");\n    try{\n      srcCluster = new MiniDFSCluster.Builder(srcConf).numDataNodes(2).build();\n      File nameDir = new File(new File(bak), \"dfs_tmp_uri/\");\n      nameDir.mkdirs();\n      System.setProperty(\"test.build.data\", nameDir.toString());\n      dstCluster = new MiniDFSCluster.Builder(dstConf).numDataNodes(2).build();\n      FileSystem srcFs = srcCluster.getFileSystem();\n      FileSystem dstFs = dstCluster.getFileSystem();\n      FsShell shell = new FsShell();\n      shell.setConf(srcConf);\n      //check for ls\n      String[] argv = new String[2];\n      argv[0] = \"-ls\";\n      argv[1] = dstFs.getUri().toString() + \"/\";\n      int ret = ToolRunner.run(shell, argv);\n      assertEquals(\"ls works on remote uri \", 0, ret);\n      //check for rm -r \n      dstFs.mkdirs(new Path(\"/hadoopdir\"));\n      argv = new String[2];\n      argv[0] = \"-rmr\";\n      argv[1] = dstFs.getUri().toString() + \"/hadoopdir\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"-rmr works on remote uri \" + argv[1], 0, ret);\n      //check du \n      argv[0] = \"-du\";\n      argv[1] = dstFs.getUri().toString() + \"/\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"du works on remote uri \", 0, ret);\n      //check put\n      File furi = new File(TEST_ROOT_DIR, \"furi\");\n      createLocalFile(furi);\n      argv = new String[3];\n      argv[0] = \"-put\";\n      argv[1] = furi.toString();\n      argv[2] = dstFs.getUri().toString() + \"/furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" put is working \", 0, ret);\n      //check cp \n      argv[0] = \"-cp\";\n      argv[1] = dstFs.getUri().toString() + \"/furi\";\n      argv[2] = srcFs.getUri().toString() + \"/furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" cp is working \", 0, ret);\n      assertTrue(srcFs.exists(new Path(\"/furi\")));\n      //check cat \n      argv = new String[2];\n      argv[0] = \"-cat\";\n      argv[1] = dstFs.getUri().toString() + \"/furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" cat is working \", 0, ret);\n      //check chown\n      dstFs.delete(new Path(\"/furi\"), true);\n      dstFs.delete(new Path(\"/hadoopdir\"), true);\n      String file = \"/tmp/chownTest\";\n      Path path = new Path(file);\n      Path parent = new Path(\"/tmp\");\n      Path root = new Path(\"/\");\n      TestDFSShell.writeFile(dstFs, path);\n      runCmd(shell, \"-chgrp\", \"-R\", \"herbivores\", dstFs.getUri().toString() +\"/*\");\n      confirmOwner(null, \"herbivores\", dstFs, parent, path);\n      runCmd(shell, \"-chown\", \"-R\", \":reptiles\", dstFs.getUri().toString() + \"/\");\n      confirmOwner(null, \"reptiles\", dstFs, root, parent, path);\n      //check if default hdfs:/// works \n      argv[0] = \"-cat\";\n      argv[1] = \"hdfs:///furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" default works for cat\", 0, ret);\n      argv[0] = \"-ls\";\n      argv[1] = \"hdfs:///\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"default works for ls \", 0, ret);\n      argv[0] = \"-rmr\";\n      argv[1] = \"hdfs:///furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"default works for rm/rmr\", 0, ret);\n    } finally {\n      System.setProperty(\"test.build.data\", bak);\n      if (null != srcCluster) {\n        srcCluster.shutdown();\n      }\n      if (null != dstCluster) {\n        dstCluster.shutdown();\n      }\n    }\n  }","id":101512,"modified_method":"@Test (timeout = 30000)\n  public void testURIPaths() throws Exception {\n    Configuration srcConf = new HdfsConfiguration();\n    Configuration dstConf = new HdfsConfiguration();\n    MiniDFSCluster srcCluster =  null;\n    MiniDFSCluster dstCluster = null;\n    String bak = System.getProperty(\"test.build.data\");\n    try{\n      srcCluster = new MiniDFSCluster.Builder(srcConf).numDataNodes(2).build();\n      File nameDir = new File(new File(bak), \"dfs_tmp_uri/\");\n      nameDir.mkdirs();\n      System.setProperty(\"test.build.data\", nameDir.toString());\n      dstCluster = new MiniDFSCluster.Builder(dstConf).numDataNodes(2).build();\n      FileSystem srcFs = srcCluster.getFileSystem();\n      FileSystem dstFs = dstCluster.getFileSystem();\n      FsShell shell = new FsShell();\n      shell.setConf(srcConf);\n      //check for ls\n      String[] argv = new String[2];\n      argv[0] = \"-ls\";\n      argv[1] = dstFs.getUri().toString() + \"/\";\n      int ret = ToolRunner.run(shell, argv);\n      assertEquals(\"ls works on remote uri \", 0, ret);\n      //check for rm -r \n      dstFs.mkdirs(new Path(\"/hadoopdir\"));\n      argv = new String[2];\n      argv[0] = \"-rmr\";\n      argv[1] = dstFs.getUri().toString() + \"/hadoopdir\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"-rmr works on remote uri \" + argv[1], 0, ret);\n      //check du \n      argv[0] = \"-du\";\n      argv[1] = dstFs.getUri().toString() + \"/\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"du works on remote uri \", 0, ret);\n      //check put\n      File furi = new File(TEST_ROOT_DIR, \"furi\");\n      createLocalFile(furi);\n      argv = new String[3];\n      argv[0] = \"-put\";\n      argv[1] = furi.toURI().toString();\n      argv[2] = dstFs.getUri().toString() + \"/furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" put is working \", 0, ret);\n      //check cp \n      argv[0] = \"-cp\";\n      argv[1] = dstFs.getUri().toString() + \"/furi\";\n      argv[2] = srcFs.getUri().toString() + \"/furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" cp is working \", 0, ret);\n      assertTrue(srcFs.exists(new Path(\"/furi\")));\n      //check cat \n      argv = new String[2];\n      argv[0] = \"-cat\";\n      argv[1] = dstFs.getUri().toString() + \"/furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" cat is working \", 0, ret);\n      //check chown\n      dstFs.delete(new Path(\"/furi\"), true);\n      dstFs.delete(new Path(\"/hadoopdir\"), true);\n      String file = \"/tmp/chownTest\";\n      Path path = new Path(file);\n      Path parent = new Path(\"/tmp\");\n      Path root = new Path(\"/\");\n      TestDFSShell.writeFile(dstFs, path);\n      runCmd(shell, \"-chgrp\", \"-R\", \"herbivores\", dstFs.getUri().toString() +\"/*\");\n      confirmOwner(null, \"herbivores\", dstFs, parent, path);\n      runCmd(shell, \"-chown\", \"-R\", \":reptiles\", dstFs.getUri().toString() + \"/\");\n      confirmOwner(null, \"reptiles\", dstFs, root, parent, path);\n      //check if default hdfs:/// works \n      argv[0] = \"-cat\";\n      argv[1] = \"hdfs:///furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\" default works for cat\", 0, ret);\n      argv[0] = \"-ls\";\n      argv[1] = \"hdfs:///\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"default works for ls \", 0, ret);\n      argv[0] = \"-rmr\";\n      argv[1] = \"hdfs:///furi\";\n      ret = ToolRunner.run(shell, argv);\n      assertEquals(\"default works for rm/rmr\", 0, ret);\n    } finally {\n      System.setProperty(\"test.build.data\", bak);\n      if (null != srcCluster) {\n        srcCluster.shutdown();\n      }\n      if (null != dstCluster) {\n        dstCluster.shutdown();\n      }\n    }\n  }","commit_id":"c2e186bae61e0d6efe0279bd3565528b9bd47f41","url":"https://github.com/apache/hadoop"},{"original_method":"public void addPersistentVolume( final String deviceName, final Volume vol ) {\n    final EntityTransaction db = Entities.get( VmInstance.class );\n    try {\n      final VmInstance entity = Entities.merge( this );\n      final VmVolumeAttachment volumeAttachment = new VmVolumeAttachment( entity, vol.getDisplayName( ), deviceName, vol.getRemoteDevice( ), AttachmentState.attached.name( ), new Date( ), true );\n      entity.bootRecord.getPersistentVolumes( ).add( volumeAttachment );\n      db.commit( );\n    } catch ( final RuntimeException ex ) {\n      Logs.extreme( ).error( ex, ex );\n      db.rollback( );\n      throw ex;\n    }\n  }","id":101513,"modified_method":"public void addPersistentVolume( final String deviceName, final Volume vol ) {\n    final Function<Volume, Volume> attachmentFunction = new Function<Volume, Volume>( ) {\n      public Volume apply( final Volume input ) {\n        final VmInstance entity = Entities.merge( VmInstance.this );\n        final Volume volEntity = Entities.merge( vol );\n        final VmVolumeAttachment volumeAttachment = new VmVolumeAttachment( entity, vol.getDisplayName( ), deviceName, vol.getRemoteDevice( ), AttachmentState.attached.name( ), new Date( ), true );\n        entity.bootRecord.getPersistentVolumes( ).add( volumeAttachment );\n        return volEntity;\n      }\n    };\n    Entities.asTransaction( VmInstance.class, attachmentFunction, VmInstances.TX_RETRIES );\n  }","commit_id":"707eac8b30ef7574f15073aafab6239ea821d805","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @param attachVol\n   */\n  public void addTransientVolume( String deviceName, String remoteDevice, Volume vol ) {\n    final EntityTransaction db = Entities.get( VmInstance.class );\n    try {\n      final VmInstance entity = Entities.merge( this );\n      final Volume volEntity = Entities.merge( vol );\n      VmVolumeAttachment attachVol = new VmVolumeAttachment( entity, vol.getDisplayName( ), deviceName, remoteDevice, AttachmentState.attaching.name( ), new Date( ), false );\n      volEntity.setState( State.BUSY );\n      entity.getTransientVolumeState( ).addVolumeAttachment( attachVol );\n      db.commit( );\n    } catch ( final RuntimeException ex ) {\n      Logs.extreme( ).error( ex, ex );\n      db.rollback( );\n      throw ex;\n    }\n  }","id":101514,"modified_method":"/**\n   * @param attachVol\n   */\n  public void addTransientVolume( final String deviceName, final String remoteDevice, final Volume vol ) {\n    final Function<Volume, Volume> attachmentFunction = new Function<Volume, Volume>( ) {\n      public Volume apply( final Volume input ) {\n        final VmInstance entity = Entities.merge( VmInstance.this );\n        final Volume volEntity = Entities.merge( vol );\n        VmVolumeAttachment attachVol = new VmVolumeAttachment( entity, volEntity.getDisplayName( ), deviceName, remoteDevice, AttachmentState.attaching.name( ), new Date( ), false );\n        volEntity.setState( State.BUSY );\n        entity.getTransientVolumeState( ).addVolumeAttachment( attachVol );\n        return volEntity;\n      }\n    };\n    Entities.asTransaction( VmInstance.class, attachmentFunction, VmInstances.TX_RETRIES );\n  }","commit_id":"707eac8b30ef7574f15073aafab6239ea821d805","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void addPermanentVolume( final String deviceName, final Volume vol ) {\n    final EntityTransaction db = Entities.get( VmInstance.class );\n    try {\n      final VmInstance entity = Entities.merge( this );\n      final VmVolumeAttachment volumeAttachment = new VmVolumeAttachment( entity, vol.getDisplayName( ), deviceName, vol.getRemoteDevice( ), AttachmentState.attached.name( ), new Date( ), false );\n      entity.bootRecord.getPersistentVolumes( ).add( volumeAttachment );\n      db.commit( );\n    } catch ( final RuntimeException ex ) {\n      Logs.extreme( ).error( ex, ex );\n      db.rollback( );\n      throw ex;\n    }\n  }","id":101515,"modified_method":"public void addPermanentVolume( final String deviceName, final Volume vol ) {\n    final Function<Volume, Volume> attachmentFunction = new Function<Volume, Volume>( ) {\n      public Volume apply( final Volume input ) {\n        final VmInstance entity = Entities.merge( VmInstance.this );\n        final Volume volEntity = Entities.merge( vol );\n        final VmVolumeAttachment volumeAttachment = new VmVolumeAttachment( entity, vol.getDisplayName( ), deviceName, vol.getRemoteDevice( ), AttachmentState.attached.name( ), new Date( ), false );\n        entity.bootRecord.getPersistentVolumes( ).add( volumeAttachment );\n        return volEntity;\n      }\n    };\n    Entities.asTransaction( VmInstance.class, attachmentFunction, VmInstances.TX_RETRIES );\n  }","commit_id":"707eac8b30ef7574f15073aafab6239ea821d805","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void doTestClientCertPost(int bodySize, boolean expectProtectedFail)\n            throws Exception {\n        if (!TesterSupport.isRenegotiationSupported(getTomcatInstance())) {\n            return;\n        }\n\n        byte[] body = new byte[bodySize];\n        Arrays.fill(body, TesterSupport.DATA);\n\n        // Unprotected resource\n        ByteChunk res = postUrl(body,\n                \"https://localhost:\" + getPort() + \"/unprotected\");\n        assertEquals(\"OK-\" + bodySize, res.toString());\n\n        // Protected resource\n        res.recycle();\n        int rc = postUrl(body, \"https://localhost:\" + getPort() + \"/protected\",\n                res, null);\n        if (expectProtectedFail) {\n            assertEquals(401, rc);\n        } else {\n            assertEquals(\"OK-\" + bodySize, res.toString());\n        }\n    }","id":101516,"modified_method":"private void doTestClientCertPost(int bodySize, boolean expectProtectedFail)\n            throws Exception {\n        Assume.assumeTrue(\"SSL renegotiation have to be supported\",\n                TesterSupport.isRenegotiationSupported(getTomcatInstance()));\n\n        byte[] body = new byte[bodySize];\n        Arrays.fill(body, TesterSupport.DATA);\n\n        // Unprotected resource\n        ByteChunk res = postUrl(body,\n                \"https://localhost:\" + getPort() + \"/unprotected\");\n        assertEquals(\"OK-\" + bodySize, res.toString());\n\n        // Protected resource\n        res.recycle();\n        int rc = postUrl(body, \"https://localhost:\" + getPort() + \"/protected\",\n                res, null);\n        if (expectProtectedFail) {\n            assertEquals(401, rc);\n        } else {\n            assertEquals(\"OK-\" + bodySize, res.toString());\n        }\n    }","commit_id":"5a436bce1e2a1a0106f69311cee6f47417ad4d3e","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testClientCertGet() throws Exception {\n        if (!TesterSupport.isRenegotiationSupported(getTomcatInstance())) {\n            return;\n        }\n\n        // Unprotected resource\n        ByteChunk res =\n                getUrl(\"https://localhost:\" + getPort() + \"/unprotected\");\n        assertEquals(\"OK\", res.toString());\n\n        // Protected resource\n        res = getUrl(\"https://localhost:\" + getPort() + \"/protected\");\n        assertEquals(\"OK\", res.toString());\n    }","id":101517,"modified_method":"@Test\n    public void testClientCertGet() throws Exception {\n        Assume.assumeTrue(\"SSL renegotiation have to be supported\",\n                TesterSupport.isRenegotiationSupported(getTomcatInstance()));\n\n        // Unprotected resource\n        ByteChunk res =\n                getUrl(\"https://localhost:\" + getPort() + \"/unprotected\");\n        assertEquals(\"OK\", res.toString());\n\n        // Protected resource\n        res = getUrl(\"https://localhost:\" + getPort() + \"/protected\");\n        assertEquals(\"OK\", res.toString());\n    }","commit_id":"5a436bce1e2a1a0106f69311cee6f47417ad4d3e","url":"https://github.com/apache/tomcat"},{"original_method":"private void doTestCustomTrustManager(boolean serverTrustAll)\n            throws Exception {\n\n        if (!TesterSupport.RFC_5746_SUPPORTED) {\n            // Make sure SSL renegotiation is not disabled in the JVM\n            System.setProperty(\"sun.security.ssl.allowUnsafeRenegotiation\",\n                    \"true\");\n        }\n\n        Tomcat tomcat = getTomcatInstance();\n\n        if (!TesterSupport.isRenegotiationSupported(getTomcatInstance())) {\n            return;\n        }\n\n        TesterSupport.configureClientCertContext(tomcat);\n\n        // Override the defaults\n        ProtocolHandler handler = tomcat.getConnector().getProtocolHandler();\n        if (handler instanceof AbstractHttp11JsseProtocol) {\n            ((AbstractHttp11JsseProtocol<?>) handler).setTruststoreFile(null);\n        } else {\n            // Unexpected\n            fail(\"Unexpected handler type\");\n        }\n        if (serverTrustAll) {\n            tomcat.getConnector().setAttribute(\"trustManagerClassName\",\n                    \"org.apache.tomcat.util.net.TesterSupport$TrustAllCerts\");\n        }\n\n        // Start Tomcat\n        tomcat.start();\n\n        TesterSupport.configureClientSsl();\n\n        // Unprotected resource\n        ByteChunk res =\n                getUrl(\"https://localhost:\" + getPort() + \"/unprotected\");\n        assertEquals(\"OK\", res.toString());\n\n        // Protected resource\n        res.recycle();\n        int rc = -1;\n        try {\n            rc = getUrl(\"https://localhost:\" + getPort() + \"/protected\", res,\n                null, null);\n        } catch (SocketException se) {\n            if (serverTrustAll) {\n                fail(se.getMessage());\n                se.printStackTrace();\n            }\n        } catch (SSLException he) {\n            if (serverTrustAll) {\n                fail(he.getMessage());\n                he.printStackTrace();\n            }\n        }\n        if (serverTrustAll) {\n            assertEquals(200, rc);\n            assertEquals(\"OK\", res.toString());\n        } else {\n            assertTrue(rc != 200);\n            assertEquals(\"\", res.toString());\n        }\n    }","id":101518,"modified_method":"private void doTestCustomTrustManager(boolean serverTrustAll)\n            throws Exception {\n\n        if (!TesterSupport.RFC_5746_SUPPORTED) {\n            // Make sure SSL renegotiation is not disabled in the JVM\n            System.setProperty(\"sun.security.ssl.allowUnsafeRenegotiation\",\n                    \"true\");\n        }\n\n        Tomcat tomcat = getTomcatInstance();\n\n        Assume.assumeTrue(\"SSL renegotiation have to be supported\",\n                TesterSupport.isRenegotiationSupported(getTomcatInstance()));\n\n        TesterSupport.configureClientCertContext(tomcat);\n\n        // Override the defaults\n        ProtocolHandler handler = tomcat.getConnector().getProtocolHandler();\n        if (handler instanceof AbstractHttp11JsseProtocol) {\n            ((AbstractHttp11JsseProtocol<?>) handler).setTruststoreFile(null);\n        } else {\n            // Unexpected\n            fail(\"Unexpected handler type\");\n        }\n        if (serverTrustAll) {\n            tomcat.getConnector().setAttribute(\"trustManagerClassName\",\n                    \"org.apache.tomcat.util.net.TesterSupport$TrustAllCerts\");\n        }\n\n        // Start Tomcat\n        tomcat.start();\n\n        TesterSupport.configureClientSsl();\n\n        // Unprotected resource\n        ByteChunk res =\n                getUrl(\"https://localhost:\" + getPort() + \"/unprotected\");\n        assertEquals(\"OK\", res.toString());\n\n        // Protected resource\n        res.recycle();\n        int rc = -1;\n        try {\n            rc = getUrl(\"https://localhost:\" + getPort() + \"/protected\", res,\n                null, null);\n        } catch (SocketException se) {\n            if (serverTrustAll) {\n                fail(se.getMessage());\n                se.printStackTrace();\n            }\n        } catch (SSLException he) {\n            if (serverTrustAll) {\n                fail(he.getMessage());\n                he.printStackTrace();\n            }\n        }\n        if (serverTrustAll) {\n            assertEquals(200, rc);\n            assertEquals(\"OK\", res.toString());\n        } else {\n            assertTrue(rc != 200);\n            assertEquals(\"\", res.toString());\n        }\n    }","commit_id":"5a436bce1e2a1a0106f69311cee6f47417ad4d3e","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testCustomSslImplementation() throws Exception {\n\n        TesterSupport.configureClientSsl();\n\n        Tomcat tomcat = getTomcatInstance();\n        Connector connector = tomcat.getConnector();\n        if (connector.getProtocolHandlerClassName().contains(\"Apr\")) {\n            // This test is only for JSSE based SSL connectors\n            return;\n        }\n\n        connector.setProperty(\"sslImplementationName\",\n                \"org.apache.tomcat.util.net.jsse.TesterBug50640SslImpl\");\n        connector.setProperty(TesterBug50640SslImpl.PROPERTY_NAME,\n                TesterBug50640SslImpl.PROPERTY_VALUE);\n\n        connector.setProperty(\"sslProtocol\", \"tls\");\n\n        File keystoreFile =\n            new File(\"test/org/apache/tomcat/util/net/localhost.jks\");\n        connector.setAttribute(\n                \"keystoreFile\", keystoreFile.getAbsolutePath());\n\n        connector.setSecure(true);\n        connector.setProperty(\"SSLEnabled\", \"true\");\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        Context ctxt  = tomcat.addWebapp(\n                null, \"/examples\", appDir.getAbsolutePath());\n        ctxt.addApplicationListener(new ApplicationListener(\n                WsContextListener.class.getName(), false));\n\n        tomcat.start();\n        ByteChunk res = getUrl(\"https://localhost:\" + getPort() +\n            \"/examples/servlets/servlet/HelloWorldExample\");\n        assertTrue(res.toString().indexOf(\"<h1>Hello World!<\/h1>\") > 0);\n    }","id":101519,"modified_method":"@Test\n    public void testCustomSslImplementation() throws Exception {\n\n        TesterSupport.configureClientSsl();\n\n        Tomcat tomcat = getTomcatInstance();\n        Connector connector = tomcat.getConnector();\n\n        Assume.assumeFalse(\"This test is only for JSSE based SSL connectors\",\n                connector.getProtocolHandlerClassName().contains(\"Apr\"));\n\n        connector.setProperty(\"sslImplementationName\",\n                \"org.apache.tomcat.util.net.jsse.TesterBug50640SslImpl\");\n        connector.setProperty(TesterBug50640SslImpl.PROPERTY_NAME,\n                TesterBug50640SslImpl.PROPERTY_VALUE);\n\n        connector.setProperty(\"sslProtocol\", \"tls\");\n\n        File keystoreFile =\n            new File(\"test/org/apache/tomcat/util/net/localhost.jks\");\n        connector.setAttribute(\n                \"keystoreFile\", keystoreFile.getAbsolutePath());\n\n        connector.setSecure(true);\n        connector.setProperty(\"SSLEnabled\", \"true\");\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        Context ctxt  = tomcat.addWebapp(\n                null, \"/examples\", appDir.getAbsolutePath());\n        ctxt.addApplicationListener(new ApplicationListener(\n                WsContextListener.class.getName(), false));\n\n        tomcat.start();\n        ByteChunk res = getUrl(\"https://localhost:\" + getPort() +\n            \"/examples/servlets/servlet/HelloWorldExample\");\n        assertTrue(res.toString().indexOf(\"<h1>Hello World!<\/h1>\") > 0);\n    }","commit_id":"5a436bce1e2a1a0106f69311cee6f47417ad4d3e","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testRenegotiateWorks() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        if (!TesterSupport.isRenegotiationSupported(tomcat)) {\n            return;\n        }\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        // app dir is relative to server home\n        Context ctxt = tomcat.addWebapp(null, \"/examples\",\n                appDir.getAbsolutePath());\n        ctxt.addApplicationListener(new ApplicationListener(\n                WsContextListener.class.getName(), false));\n\n        TesterSupport.initSsl(tomcat);\n\n        tomcat.start();\n\n        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n        sslCtx.init(null, TesterSupport.getTrustManagers(), null);\n        SSLSocketFactory socketFactory = sslCtx.getSocketFactory();\n        SSLSocket socket = (SSLSocket) socketFactory.createSocket(\"localhost\",\n                getPort());\n\n        OutputStream os = socket.getOutputStream();\n\n        os.write(\"GET /examples/servlets/servlet/HelloWorldExample HTTP/1.1\\n\".getBytes());\n        os.flush();\n\n        socket.startHandshake();\n\n        try {\n            os.write(\"Host: localhost\\n\\n\".getBytes());\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            fail(\"Re-negotiation failed\");\n        }\n\n        InputStream is = socket.getInputStream();\n        Reader r = new InputStreamReader(is);\n        BufferedReader br = new BufferedReader(r);\n        String line = br.readLine();\n        Assert.assertEquals(\"HTTP/1.1 200 OK\", line);\n        while (line != null) {\n            // For debugging System.out.println(line);\n            // Linux clients see a Connection Reset in some circumstances and a\n            // clean close in others.\n            try {\n                line = br.readLine();\n            } catch (IOException ioe) {\n                line = null;\n            }\n        }\n    }","id":101520,"modified_method":"@Test\n    public void testRenegotiateWorks() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Assume.assumeTrue(\"SSL renegotiation have to be supported\",\n                TesterSupport.isRenegotiationSupported(getTomcatInstance()));\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        // app dir is relative to server home\n        Context ctxt = tomcat.addWebapp(null, \"/examples\",\n                appDir.getAbsolutePath());\n        ctxt.addApplicationListener(new ApplicationListener(\n                WsContextListener.class.getName(), false));\n\n        TesterSupport.initSsl(tomcat);\n\n        tomcat.start();\n\n        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n        sslCtx.init(null, TesterSupport.getTrustManagers(), null);\n        SSLSocketFactory socketFactory = sslCtx.getSocketFactory();\n        SSLSocket socket = (SSLSocket) socketFactory.createSocket(\"localhost\",\n                getPort());\n\n        OutputStream os = socket.getOutputStream();\n\n        os.write(\"GET /examples/servlets/servlet/HelloWorldExample HTTP/1.1\\n\".getBytes());\n        os.flush();\n\n        socket.startHandshake();\n\n        try {\n            os.write(\"Host: localhost\\n\\n\".getBytes());\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            fail(\"Re-negotiation failed\");\n        }\n\n        InputStream is = socket.getInputStream();\n        Reader r = new InputStreamReader(is);\n        BufferedReader br = new BufferedReader(r);\n        String line = br.readLine();\n        Assert.assertEquals(\"HTTP/1.1 200 OK\", line);\n        while (line != null) {\n            // For debugging System.out.println(line);\n            // Linux clients see a Connection Reset in some circumstances and a\n            // clean close in others.\n            try {\n                line = br.readLine();\n            } catch (IOException ioe) {\n                line = null;\n            }\n        }\n    }","commit_id":"5a436bce1e2a1a0106f69311cee6f47417ad4d3e","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n\t * Caller must create bloomFile, but it may be empty.\n\t * @param newFilter If true, the bloom file is empty, and the bloom filter\n\t * should be created from scratch.\n\t * @throws IOException \n\t */\n\tpublic SplitFileFetcherKeyListener(SplitFileFetcher parent, int keyCount, File bloomFile, File altBloomFile, int mainBloomSizeBytes, int mainBloomK, byte[] localSalt, int segments, int segmentFilterSizeBytes, int segmentBloomK, boolean persistent, boolean newFilter, CountingBloomFilter cachedMainFilter, BinaryBloomFilter[] cachedSegFilters, ObjectContainer container, boolean onStartup, boolean realTime) throws IOException {\n\t\tfetcher = parent;\n\t\tthis.loadedOnStartup = onStartup;\n\t\tthis.persistent = persistent;\n\t\tthis.keyCount = keyCount;\n\t\tthis.realTime = realTime;\n\t\tassert(localSalt.length == 32);\n\t\tif(persistent) {\n\t\t\tthis.localSalt = new byte[32];\n\t\t\tSystem.arraycopy(localSalt, 0, this.localSalt, 0, 32);\n\t\t} else {\n\t\t\tthis.localSalt = localSalt;\n\t\t}\n\t\tsegmentFilters = new BinaryBloomFilter[segments];\n\t\tif(cachedSegFilters != null) {\n\t\t\tfor(int i=0;i<cachedSegFilters.length;i++) {\n\t\t\t\tsegmentFilters[i] = cachedSegFilters[i];\n\t\t\t\tcontainer.activate(cachedSegFilters[i], Integer.MAX_VALUE);\n\t\t\t\tcachedSegFilters[i].init(container);\n\t\t\t\tSystem.out.println(\"Restored segment \"+i+\" filter for \"+parent+\" : k=\"+cachedSegFilters[i].getK()+\" size = \"+cachedSegFilters[i].getSizeBytes()+\" bytes = \"+cachedSegFilters[i].getLength()+\" elements, filled: \"+cachedSegFilters[i].getFilledCount());\n\t\t\t}\n\t\t} else {\n\t\t\tbyte[] segmentsFilterBuffer = new byte[segmentFilterSizeBytes * segments];\n\t\t\tByteBuffer baseBuffer = ByteBuffer.wrap(segmentsFilterBuffer);\n\t\t\tif(!newFilter) {\n\t\t\t\tFileInputStream fis = new FileInputStream(altBloomFile);\n\t\t\t\tDataInputStream dis = new DataInputStream(fis);\n\t\t\t\tdis.readFully(segmentsFilterBuffer);\n\t\t\t\tdis.close();\n\t\t\t}\n\t\t\tint start = 0;\n\t\t\tint end = segmentFilterSizeBytes;\n\t\t\tfor(int i=0;i<segments;i++) {\n\t\t\t\tbaseBuffer.position(start);\n\t\t\t\tbaseBuffer.limit(end);\n\t\t\t\tByteBuffer slice;\n\t\t\t\t\n\t\t\t\tif(persistent) {\n\t\t\t\t\t// byte[] arrays get stored separately in each object, so we need to copy it.\n\t\t\t\t\tbyte[] buf = new byte[segmentFilterSizeBytes];\n\t\t\t\t\tSystem.arraycopy(segmentsFilterBuffer, start, buf, 0, segmentFilterSizeBytes);\n\t\t\t\t\tslice = ByteBuffer.wrap(buf);\n\t\t\t\t} else {\n\t\t\t\t\tslice = baseBuffer.slice();\n\t\t\t\t}\n\t\t\t\tsegmentFilters[i] = new BinaryBloomFilter(slice, segmentFilterSizeBytes * 8, segmentBloomK);\n\t\t\t\tstart += segmentFilterSizeBytes;\n\t\t\t\tend += segmentFilterSizeBytes;\n\t\t\t}\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=0;i<segments;i++) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Storing segment \"+i+\" filter to database for \"+parent+\" : k=\"+segmentFilters[i].getK()+\" size = \"+segmentFilters[i].getSizeBytes()+\" bytes = \"+segmentFilters[i].getLength()+\" elements, filled: \"+segmentFilters[i].getFilledCount());\n\t\t\t\t\tsegmentFilters[i].storeTo(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent.setCachedSegFilters(segmentFilters);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(parent);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbyte[] filterBuffer = new byte[mainBloomSizeBytes];\n\t\tif(cachedMainFilter != null) {\n\t\t\tfilter = cachedMainFilter;\n\t\t\tif(persistent) container.activate(filter, Integer.MAX_VALUE);\n\t\t\tfilter.init(container);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restored filter for \"+parent+\" : k=\"+filter.getK()+\" size = \"+filter.getSizeBytes()+\" bytes = \"+filter.getLength()+\" elements, filled: \"+filter.getFilledCount());\n\t\t} else if(newFilter) {\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t\tfilter.setWarnOnRemoveFromEmpty();\n\t\t\tparent.setCachedMainFilter(filter);\n\t\t\tif(persistent) {\n\t\t\t\tfilter.storeTo(container);\n\t\t\t\tcontainer.store(parent);\n\t\t\t}\n\t\t} else {\n\t\t\t// Read from file.\n\t\t\tFileInputStream fis = new FileInputStream(bloomFile);\n\t\t\tDataInputStream dis = new DataInputStream(fis);\n\t\t\tdis.readFully(filterBuffer);\n\t\t\tdis.close();\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t\tfilter.setWarnOnRemoveFromEmpty();\n\t\t\tparent.setCachedMainFilter(filter);\n\t\t\tif(persistent) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Storing filter to database for \"+parent+\" : k=\"+filter.getK()+\" size = \"+filter.getSizeBytes()+\" bytes = \"+filter.getLength()+\" elements, filled: \"+filter.getFilledCount());\n\t\t\t\tfilter.storeTo(container);\n\t\t\t\tcontainer.store(parent);\n\t\t\t}\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Created \"+this+\" for \"+fetcher);\n\t}","id":101521,"modified_method":"/**\n\t * Caller must create bloomFile, but it may be empty.\n\t * @param newFilter If true, the bloom file is empty, and the bloom filter\n\t * should be created from scratch.\n\t * @throws IOException \n\t */\n\tpublic SplitFileFetcherKeyListener(SplitFileFetcher parent, int keyCount, File bloomFile, File altBloomFile, int mainBloomSizeBytes, int mainBloomK, byte[] localSalt, int segments, int segmentFilterSizeBytes, int segmentBloomK, boolean persistent, boolean newFilter, CountingBloomFilter cachedMainFilter, BinaryBloomFilter[] cachedSegFilters, ObjectContainer container, boolean onStartup, boolean realTime) throws IOException {\n\t\tfetcher = parent;\n\t\tthis.loadedOnStartup = onStartup;\n\t\tthis.persistent = persistent;\n\t\tthis.keyCount = keyCount;\n\t\tthis.realTime = realTime;\n\t\tassert(localSalt.length == 32);\n\t\tif(persistent) {\n\t\t\tthis.localSalt = new byte[32];\n\t\t\tSystem.arraycopy(localSalt, 0, this.localSalt, 0, 32);\n\t\t} else {\n\t\t\tthis.localSalt = localSalt;\n\t\t}\n\t\tsegmentFilters = new BinaryBloomFilter[segments];\n\t\tif(cachedSegFilters != null) {\n\t\t\tfor(int i=0;i<cachedSegFilters.length;i++) {\n\t\t\t\tsegmentFilters[i] = cachedSegFilters[i];\n\t\t\t\tcontainer.activate(cachedSegFilters[i], Integer.MAX_VALUE);\n\t\t\t\tcachedSegFilters[i].init(container);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Restored segment \"+i+\" filter for \"+parent+\" : k=\"+cachedSegFilters[i].getK()+\" size = \"+cachedSegFilters[i].getSizeBytes()+\" bytes = \"+cachedSegFilters[i].getLength()+\" elements, filled: \"+cachedSegFilters[i].getFilledCount());\n\t\t\t}\n\t\t} else {\n\t\t\tbyte[] segmentsFilterBuffer = new byte[segmentFilterSizeBytes * segments];\n\t\t\tByteBuffer baseBuffer = ByteBuffer.wrap(segmentsFilterBuffer);\n\t\t\tif(!newFilter) {\n\t\t\t\tFileInputStream fis = new FileInputStream(altBloomFile);\n\t\t\t\tDataInputStream dis = new DataInputStream(fis);\n\t\t\t\tdis.readFully(segmentsFilterBuffer);\n\t\t\t\tdis.close();\n\t\t\t}\n\t\t\tint start = 0;\n\t\t\tint end = segmentFilterSizeBytes;\n\t\t\tfor(int i=0;i<segments;i++) {\n\t\t\t\tbaseBuffer.position(start);\n\t\t\t\tbaseBuffer.limit(end);\n\t\t\t\tByteBuffer slice;\n\t\t\t\t\n\t\t\t\tif(persistent) {\n\t\t\t\t\t// byte[] arrays get stored separately in each object, so we need to copy it.\n\t\t\t\t\tbyte[] buf = new byte[segmentFilterSizeBytes];\n\t\t\t\t\tSystem.arraycopy(segmentsFilterBuffer, start, buf, 0, segmentFilterSizeBytes);\n\t\t\t\t\tslice = ByteBuffer.wrap(buf);\n\t\t\t\t} else {\n\t\t\t\t\tslice = baseBuffer.slice();\n\t\t\t\t}\n\t\t\t\tsegmentFilters[i] = new BinaryBloomFilter(slice, segmentFilterSizeBytes * 8, segmentBloomK);\n\t\t\t\tstart += segmentFilterSizeBytes;\n\t\t\t\tend += segmentFilterSizeBytes;\n\t\t\t}\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=0;i<segments;i++) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Storing segment \"+i+\" filter to database for \"+parent+\" : k=\"+segmentFilters[i].getK()+\" size = \"+segmentFilters[i].getSizeBytes()+\" bytes = \"+segmentFilters[i].getLength()+\" elements, filled: \"+segmentFilters[i].getFilledCount());\n\t\t\t\t\tsegmentFilters[i].storeTo(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent.setCachedSegFilters(segmentFilters);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(parent);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbyte[] filterBuffer = new byte[mainBloomSizeBytes];\n\t\tif(cachedMainFilter != null) {\n\t\t\tfilter = cachedMainFilter;\n\t\t\tif(persistent) container.activate(filter, Integer.MAX_VALUE);\n\t\t\tfilter.init(container);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restored filter for \"+parent+\" : k=\"+filter.getK()+\" size = \"+filter.getSizeBytes()+\" bytes = \"+filter.getLength()+\" elements, filled: \"+filter.getFilledCount());\n\t\t} else if(newFilter) {\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t\tfilter.setWarnOnRemoveFromEmpty();\n\t\t\tparent.setCachedMainFilter(filter);\n\t\t\tif(persistent) {\n\t\t\t\tfilter.storeTo(container);\n\t\t\t\tcontainer.store(parent);\n\t\t\t}\n\t\t} else {\n\t\t\t// Read from file.\n\t\t\tFileInputStream fis = new FileInputStream(bloomFile);\n\t\t\tDataInputStream dis = new DataInputStream(fis);\n\t\t\tdis.readFully(filterBuffer);\n\t\t\tdis.close();\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t\tfilter.setWarnOnRemoveFromEmpty();\n\t\t\tparent.setCachedMainFilter(filter);\n\t\t\tif(persistent) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Storing filter to database for \"+parent+\" : k=\"+filter.getK()+\" size = \"+filter.getSizeBytes()+\" bytes = \"+filter.getLength()+\" elements, filled: \"+filter.getFilledCount());\n\t\t\t\tfilter.storeTo(container);\n\t\t\t\tcontainer.store(parent);\n\t\t\t}\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Created \"+this+\" for \"+fetcher);\n\t}","commit_id":"50af9a42508251e6993197cac3719b8f5b96f30e","url":"https://github.com/freenet/fred"},{"original_method":"public static void secureDelete(File file, Random random) throws IOException {\n\t\t// FIXME somebody who understands these things should have a look at this...\n\t\tif(!file.exists()) return;\n\t\tlong size = file.length();\n\t\tif(size > 0) {\n\t\t\tRandomAccessFile raf = null;\n\t\t\ttry {\n\t\t\t\tSystem.err.println(\"Securely deleting \"+file+\" which is of length \"+size+\" bytes...\");\n\t\t\t\traf = new RandomAccessFile(file, \"rw\");\n\t\t\t\traf.seek(0);\n\t\t\t\tlong count;\n\t\t\t\tbyte[] buf = new byte[4096];\n\t\t\t\t// First zero it out\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\t// Then ffffff it out\n\t\t\t\tfor(int i=0;i<buf.length;i++)\n\t\t\t\t\tbuf[i] = (byte)0xFF;\n\t\t\t\traf.seek(0);\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\t// Then random data\n\t\t\t\trandom.nextBytes(buf);\n\t\t\t\traf.seek(0);\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\traf.seek(0);\n\t\t\t\t// Then 0's again\n\t\t\t\tfor(int i=0;i<buf.length;i++)\n\t\t\t\t\tbuf[i] = 0;\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\traf.close();\n\t\t\t\traf = null;\n\t\t\t} finally {\n\t\t\t\tCloser.close(raf);\n\t\t\t}\n\t\t}\n\t\tif((!file.delete()) && file.exists())\n\t\t\tthrow new IOException(\"Unable to delete file \"+file);\n\t}","id":101522,"modified_method":"public static void secureDelete(File file, Random random) throws IOException {\n\t\t// FIXME somebody who understands these things should have a look at this...\n\t\tif(!file.exists()) return;\n\t\tlong size = file.length();\n\t\tif(size > 0) {\n\t\t\tRandomAccessFile raf = null;\n\t\t\ttry {\n\t\t\t\tSystem.out.println(\"Securely deleting \"+file+\" which is of length \"+size+\" bytes...\");\n\t\t\t\traf = new RandomAccessFile(file, \"rw\");\n\t\t\t\traf.seek(0);\n\t\t\t\tlong count;\n\t\t\t\tbyte[] buf = new byte[4096];\n\t\t\t\t// First zero it out\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\t// Then ffffff it out\n\t\t\t\tfor(int i=0;i<buf.length;i++)\n\t\t\t\t\tbuf[i] = (byte)0xFF;\n\t\t\t\traf.seek(0);\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\t// Then random data\n\t\t\t\trandom.nextBytes(buf);\n\t\t\t\traf.seek(0);\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\traf.seek(0);\n\t\t\t\t// Then 0's again\n\t\t\t\tfor(int i=0;i<buf.length;i++)\n\t\t\t\t\tbuf[i] = 0;\n\t\t\t\tcount = 0;\n\t\t\t\twhile(count < size) {\n\t\t\t\t\tint written = (int) Math.min(buf.length, size - count);\n\t\t\t\t\traf.write(buf, 0, written);\n\t\t\t\t\tcount += written;\n\t\t\t\t}\n\t\t\t\traf.getFD().sync();\n\t\t\t\traf.close();\n\t\t\t\traf = null;\n\t\t\t} finally {\n\t\t\t\tCloser.close(raf);\n\t\t\t}\n\t\t}\n\t\tif((!file.delete()) && file.exists())\n\t\t\tthrow new IOException(\"Unable to delete file \"+file);\n\t}","commit_id":"1c94d174382848dcd6f51f12626baa1d6657b255","url":"https://github.com/freenet/fred"},{"original_method":"public SplitFileFetcher(Metadata metadata, GetCompletionCallback rcb, ClientRequester parent2,\n\t\t\tFetchContext newCtx, boolean deleteFetchContext, List<? extends Compressor> decompressors2, ClientMetadata clientMetadata,\n\t\t\tArchiveContext actx, int recursionLevel, Bucket returnBucket, long token2, boolean topDontCompress, short topCompatibilityMode, ObjectContainer container, ClientContext context) throws FetchException, MetadataParseException {\n\t\tthis.persistent = parent2.persistent();\n\t\tthis.deleteFetchContext = deleteFetchContext;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Persistence = \"+persistent+\" from \"+parent2, new Exception(\"debug\"));\n\t\tint hash = super.hashCode();\n\t\tif(hash == 0) hash = 1;\n\t\tthis.hashCode = hash;\n\t\tthis.finished = false;\n\t\tthis.returnBucket = returnBucket;\n\t\tthis.fetchContext = newCtx;\n\t\tif(newCtx == null)\n\t\t\tthrow new NullPointerException();\n\t\tthis.archiveContext = actx;\n\t\tthis.decompressors = persistent ? new ArrayList<Compressor>(decompressors2) : decompressors2;\n\t\tif(decompressors.size() > 1) {\n\t\t\tLogger.error(this, \"Multiple decompressors: \"+decompressors.size()+\" - this is almost certainly a bug\", new Exception(\"debug\"));\n\t\t}\n\t\tthis.clientMetadata = clientMetadata == null ? new ClientMetadata() : clientMetadata.clone(); // copy it as in SingleFileFetcher\n\t\tthis.cb = rcb;\n\t\tthis.recursionLevel = recursionLevel + 1;\n\t\tthis.parent = parent2;\n\t\tlocalSalt = new byte[32];\n\t\tcontext.random.nextBytes(localSalt);\n\t\tif(parent2.isCancelled())\n\t\t\tthrow new FetchException(FetchException.CANCELLED);\n\t\toverrideLength = metadata.dataLength();\n\t\tthis.splitfileType = metadata.getSplitfileType();\n\t\tClientCHK[] splitfileDataBlocks = metadata.getSplitfileDataKeys();\n\t\tClientCHK[] splitfileCheckBlocks = metadata.getSplitfileCheckKeys();\n\t\tif(persistent) {\n\t\t\t// Clear them here so they don't get deleted and we don't need to clone them.\n\t\t\tmetadata.clearSplitfileKeys();\n\t\t\tcontainer.store(metadata);\n\t\t}\n\t\tfor(int i=0;i<splitfileDataBlocks.length;i++)\n\t\t\tif(splitfileDataBlocks[i] == null) throw new MetadataParseException(\"Null: data block \"+i+\" of \"+splitfileDataBlocks.length);\n\t\tfor(int i=0;i<splitfileCheckBlocks.length;i++)\n\t\t\tif(splitfileCheckBlocks[i] == null) throw new MetadataParseException(\"Null: check block \"+i+\" of \"+splitfileCheckBlocks.length);\n\t\tlong eventualLength = Math.max(overrideLength, metadata.uncompressedDataLength());\n\t\tboolean wasActive = true;\n\t\tif(persistent) {\n\t\t\twasActive = container.ext().isActive(cb);\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tcb.onExpectedSize(eventualLength, container, context);\n\t\tString mimeType = metadata.getMIMEType();\n\t\tif(mimeType != null)\n\t\t\tcb.onExpectedMIME(mimeType, container, context);\n\t\tif(metadata.uncompressedDataLength() > 0)\n\t\t\tcb.onFinalizedMetadata(container);\n\t\tif(!wasActive)\n\t\t\tcontainer.deactivate(cb, 1);\n\t\tif(eventualLength > 0 && newCtx.maxOutputLength > 0 && eventualLength > newCtx.maxOutputLength)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, eventualLength, true, clientMetadata.getMIMEType());\n\n\t\tthis.token = token2;\n\t\t\n\t\tCompatibilityMode minCompatMode = CompatibilityMode.COMPAT_UNKNOWN;\n\t\tCompatibilityMode maxCompatMode = CompatibilityMode.COMPAT_UNKNOWN;\n\n\t\tint crossCheckBlocks = 0;\n\t\t\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\t// Don't need to do much - just fetch everything and piece it together.\n\t\t\tblocksPerSegment = -1;\n\t\t\tcheckBlocksPerSegment = -1;\n\t\t\tsegmentCount = 1;\n\t\t\tdeductBlocksFromSegments = 0;\n\t\t\tif(splitfileCheckBlocks.length > 0) {\n\t\t\t\tLogger.error(this, \"Splitfile type is SPLITFILE_NONREDUNDANT yet \"+splitfileCheckBlocks.length+\" check blocks found!! : \"+this);\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile type is non-redundant yet have \"+splitfileCheckBlocks.length+\" check blocks\");\n\t\t\t}\n\t\t} else if(splitfileType == Metadata.SPLITFILE_ONION_STANDARD) {\n\t\t\tbyte[] params = metadata.splitfileParams();\n\t\t\tint checkBlocks;\n\t\t\tif(metadata.getParsedVersion() == 0) {\n\t\t\t\tif((params == null) || (params.length < 8))\n\t\t\t\t\tthrow new MetadataParseException(\"No splitfile params\");\n\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 0);\n\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 4);\n\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\tint countDataBlocks = splitfileDataBlocks.length;\n\t\t\t\tint countCheckBlocks = splitfileCheckBlocks.length;\n\t\t\t\tif(countDataBlocks == countCheckBlocks) {\n\t\t\t\t\t// No extra check blocks, so before 1251.\n\t\t\t\t\tif(blocksPerSegment == 128) {\n\t\t\t\t\t\t// Is the last segment small enough that we can't have used even splitting?\n\t\t\t\t\t\tint segs = (int)Math.ceil(((double)countDataBlocks) / 128);\n\t\t\t\t\t\tint segSize = (int)Math.ceil(((double)countDataBlocks) / ((double)segs));\n\t\t\t\t\t\tif(segSize == 128) {\n\t\t\t\t\t\t\t// Could be either\n\t\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1251;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1255;\n\t\t\t\tif(params.length < 10)\n\t\t\t\t\tthrow new MetadataParseException(\"Splitfile parameters too short for version 1\");\n\t\t\t\tshort paramsType = Fields.bytesToShort(params, 0);\n\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SIMPLE_SEGMENT || paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 2);\n\t\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 6);\n\t\t\t\t} else\n\t\t\t\t\tthrow new MetadataParseException(\"Unknown splitfile params type \"+paramsType);\n\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\tdeductBlocksFromSegments = Fields.bytesToInt(params, 10);\n\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\tcrossCheckBlocks = Fields.bytesToInt(params, 14);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t}\n\t\t\t\n\t\t\tboolean dontCompress = decompressors.isEmpty();\n\t\t\tif(topCompatibilityMode != 0) {\n\t\t\t\t// If we have top compatibility mode, then we can give a definitive answer immediately, with the splitfile key, with dontcompress, etc etc.\n\t\t\t\tif(minCompatMode == CompatibilityMode.COMPAT_UNKNOWN ||\n\t\t\t\t\t\t!(minCompatMode.ordinal() > topCompatibilityMode || maxCompatMode.ordinal() < topCompatibilityMode)) {\n\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.values()[topCompatibilityMode];\n\t\t\t\t\tdontCompress = topDontCompress;\n\t\t\t\t} else\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Top compatibility mode is incompatible with detected compatibility mode\");\n\t\t\t}\n\t\t\tcb.onSplitfileCompatibilityMode(minCompatMode, maxCompatMode, metadata.getCustomSplitfileKey(), dontCompress, true, topCompatibilityMode != 0, container, context);\n\n\t\t\t// FIXME remove this eventually. Will break compat with a few files inserted between 1135 and 1136.\n\t\t\t// Work around a bug around build 1135.\n\t\t\t// We were splitting as (128,255), but we were then setting the checkBlocksPerSegment to 64.\n\t\t\t// Detect this.\n\t\t\tif(checkBlocks == 64 && blocksPerSegment == 128 &&\n\t\t\t\t\tsplitfileCheckBlocks.length == splitfileDataBlocks.length - (splitfileDataBlocks.length / 128)) {\n\t\t\t\tLogger.normal(this, \"Activating 1135 wrong check blocks per segment workaround for \"+this);\n\t\t\t\tcheckBlocks = 127;\n\t\t\t}\n\t\t\tcheckBlocksPerSegment = checkBlocks;\n\n\t\t\tif((blocksPerSegment > fetchContext.maxDataBlocksPerSegment)\n\t\t\t\t\t|| (checkBlocksPerSegment > fetchContext.maxCheckBlocksPerSegment))\n\t\t\t\tthrow new FetchException(FetchException.TOO_MANY_BLOCKS_PER_SEGMENT, \"Too many blocks per segment: \"+blocksPerSegment+\" data, \"+checkBlocksPerSegment+\" check\");\n\t\t\tsegmentCount = (splitfileDataBlocks.length / (blocksPerSegment + crossCheckBlocks)) +\n\t\t\t\t(splitfileDataBlocks.length % (blocksPerSegment + crossCheckBlocks) == 0 ? 0 : 1);\n\t\t\t\t\n\t\t\t// Onion, 128/192.\n\t\t\t// Will be segmented.\n\t\t} else throw new MetadataParseException(\"Unknown splitfile format: \"+splitfileType);\n\t\tthis.maxTempLength = fetchContext.maxTempLength;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Algorithm: \"+splitfileType+\", blocks per segment: \"+blocksPerSegment+\n\t\t\t\t\t\", check blocks per segment: \"+checkBlocksPerSegment+\", segments: \"+segmentCount+\n\t\t\t\t\t\", data blocks: \"+splitfileDataBlocks.length+\", check blocks: \"+splitfileCheckBlocks.length);\n\t\tsegments = new SplitFileFetcherSegment[segmentCount]; // initially null on all entries\n\n\t\tthis.crossCheckBlocks = crossCheckBlocks;\n\t\t\n\t\tlong finalLength = 1L * (splitfileDataBlocks.length - segmentCount * crossCheckBlocks) * CHKBlock.DATA_LENGTH;\n\t\tif(finalLength > overrideLength) {\n\t\t\tif(finalLength - overrideLength > CHKBlock.DATA_LENGTH)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile is \"+finalLength+\" but length is \"+finalLength);\n\t\t\tfinalLength = overrideLength;\n\t\t}\n\t\t\n\t\t// Setup bloom parameters.\n\t\tif(persistent) {\n\t\t\t// FIXME: Should this be encrypted? It's protected to some degree by the salt...\n\t\t\t// Since it isn't encrypted, it's likely to be very sparse; we should name\n\t\t\t// it appropriately...\n\t\t\ttry {\n\t\t\t\tmainBloomFile = context.persistentFG.makeRandomFile();\n\t\t\t\taltBloomFile = context.persistentFG.makeRandomFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to create Bloom filter files\", e);\n\t\t\t}\n\t\t} else {\n\t\t\t// Not persistent, keep purely in RAM.\n\t\t\tmainBloomFile = null;\n\t\t\taltBloomFile = null;\n\t\t}\n\t\tint mainElementsPerKey = DEFAULT_MAIN_BLOOM_ELEMENTS_PER_KEY;\n\t\tint origSize = splitfileDataBlocks.length + splitfileCheckBlocks.length;\n\t\tmainBloomK = (int) (mainElementsPerKey * 0.7);\n\t\tlong elementsLong = origSize * mainElementsPerKey;\n\t\t// REDFLAG: SIZE LIMIT: 3.36TB limit!\n\t\tif(elementsLong > Integer.MAX_VALUE)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, \"Cannot fetch splitfiles with more than \"+(Integer.MAX_VALUE/mainElementsPerKey)+\" keys! (approx 3.3TB)\");\n\t\tint mainSizeBits = (int)elementsLong; // counting filter\n\t\tif((mainSizeBits & 7) != 0)\n\t\t\tmainSizeBits += (8 - (mainSizeBits & 7));\n\t\tmainBloomFilterSizeBytes = mainSizeBits / 8 * 2; // counting filter\n\t\tdouble acceptableFalsePositives = ACCEPTABLE_BLOOM_FALSE_POSITIVES_ALL_SEGMENTS / segments.length;\n\t\tint perSegmentBitsPerKey = (int) Math.ceil(Math.log(acceptableFalsePositives) / Math.log(0.6185));\n\t\tint segBlocks = blocksPerSegment + checkBlocksPerSegment;\n\t\tif(segBlocks > origSize)\n\t\t\tsegBlocks = origSize;\n\t\tint perSegmentSize = perSegmentBitsPerKey * segBlocks;\n\t\tif((perSegmentSize & 7) != 0)\n\t\t\tperSegmentSize += (8 - (perSegmentSize & 7));\n\t\tperSegmentBloomFilterSizeBytes = perSegmentSize / 8;\n\t\tperSegmentK = BloomFilter.optimialK(perSegmentSize, segBlocks);\n\t\tkeyCount = origSize;\n\t\t// Now create it.\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Creating block filter for \"+this+\": keys=\"+(splitfileDataBlocks.length+splitfileCheckBlocks.length)+\" main bloom size \"+mainBloomFilterSizeBytes+\" bytes, K=\"+mainBloomK+\", filename=\"+mainBloomFile+\" alt bloom filter: filename=\"+altBloomFile+\" segments: \"+segments.length+\" each is \"+perSegmentBloomFilterSizeBytes+\" bytes k=\"+perSegmentK);\n\t\ttry {\n\t\t\ttempListener = new SplitFileFetcherKeyListener(this, keyCount, mainBloomFile, altBloomFile, mainBloomFilterSizeBytes, mainBloomK, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, true);\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to write Bloom filters for splitfile\");\n\t\t}\n\n\t\tif(persistent)\n\t\t\tcontainer.store(this);\n\n\t\tboolean pre1254 = !(minCompatMode == CompatibilityMode.COMPAT_CURRENT || minCompatMode.ordinal() >= CompatibilityMode.COMPAT_1255.ordinal());\n\t\t\n\t\tblockFetchContext = new FetchContext(fetchContext, FetchContext.SPLITFILE_DEFAULT_BLOCK_MASK, true, null);\n\t\tif(segmentCount == 1) {\n\t\t\t// splitfile* will be overwritten, this is bad\n\t\t\t// so copy them\n\t\t\tClientCHK[] newSplitfileDataBlocks = new ClientCHK[splitfileDataBlocks.length];\n\t\t\tClientCHK[] newSplitfileCheckBlocks = new ClientCHK[splitfileCheckBlocks.length];\n\t\t\tSystem.arraycopy(splitfileDataBlocks, 0, newSplitfileDataBlocks, 0, splitfileDataBlocks.length);\n\t\t\tif(splitfileCheckBlocks.length > 0)\n\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, 0, newSplitfileCheckBlocks, 0, splitfileCheckBlocks.length);\n\t\t\tsegments[0] = new SplitFileFetcherSegment(splitfileType, newSplitfileDataBlocks, newSplitfileCheckBlocks,\n\t\t\t\t\tthis, archiveContext, blockFetchContext, maxTempLength, recursionLevel, parent, 0, true, pre1254, crossCheckBlocks, metadata.getSplitfileCryptoAlgorithm(), metadata.getSplitfileCryptoKey());\n\t\t\tfor(int i=0;i<newSplitfileDataBlocks.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Added data block \"+i+\" : \"+newSplitfileDataBlocks[i].getNodeKey(false));\n\t\t\t\ttempListener.addKey(newSplitfileDataBlocks[i].getNodeKey(true), 0, context);\n\t\t\t}\n\t\t\tfor(int i=0;i<newSplitfileCheckBlocks.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Added check block \"+i+\" : \"+newSplitfileCheckBlocks[i].getNodeKey(false));\n\t\t\t\ttempListener.addKey(newSplitfileCheckBlocks[i].getNodeKey(true), 0, context);\n\t\t\t}\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(segments[0]);\n\t\t\t\tsegments[0].deactivateKeys(container);\n\t\t\t\tcontainer.deactivate(segments[0], 1);\n\t\t\t}\n\t\t} else {\n\t\t\tint dataBlocksPtr = 0;\n\t\t\tint checkBlocksPtr = 0;\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t// Create a segment. Give it its keys.\n\t\t\t\tint copyDataBlocks = blocksPerSegment + crossCheckBlocks;\n\t\t\t\tint copyCheckBlocks = checkBlocksPerSegment;\n\t\t\t\tif(i == segments.length - 1) {\n\t\t\t\t\t// Always accept the remainder as the last segment, but do basic sanity checking.\n\t\t\t\t\t// In practice this can be affected by various things: 1) On old splitfiles before full even \n\t\t\t\t\t// segment splitting with deductBlocksFromSegments (i.e. pre-1255), the last segment could be\n\t\t\t\t\t// significantly smaller than the rest; 2) On 1251-1253, with partial even segment splitting,\n\t\t\t\t\t// up to 131 data blocks per segment, cutting the check blocks if necessary, and with an extra\n\t\t\t\t\t// check block if possible, the last segment could have *more* check blocks than the rest. \n\t\t\t\t\tcopyDataBlocks = splitfileDataBlocks.length - dataBlocksPtr;\n\t\t\t\t\tcopyCheckBlocks = splitfileCheckBlocks.length - checkBlocksPtr;\n\t\t\t\t\tif(copyCheckBlocks <= 0 || copyDataBlocks <= 0)\n\t\t\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Last segment has bogus block count: total data blocks \"+splitfileDataBlocks.length+\" total check blocks \"+splitfileCheckBlocks.length+\" segment size \"+blocksPerSegment+\" data \"+checkBlocksPerSegment+\" check \"+crossCheckBlocks+\" cross check blocks, deduct \"+deductBlocksFromSegments+\", segments \"+segments.length);\n\t\t\t\t\tif((copyDataBlocks > fetchContext.maxDataBlocksPerSegment)\n\t\t\t\t\t\t\t|| (copyCheckBlocks > fetchContext.maxCheckBlocksPerSegment))\n\t\t\t\t\t\tthrow new FetchException(FetchException.TOO_MANY_BLOCKS_PER_SEGMENT, \"Too many blocks per segment: \"+blocksPerSegment+\" data, \"+checkBlocksPerSegment+\" check\");\n\t\t\t\t} else if(segments.length - i <= deductBlocksFromSegments) {\n\t\t\t\t\t// Deduct one data block from each of the last deductBlocksFromSegments segments.\n\t\t\t\t\t// This ensures no segment is more than 1 block larger than any other.\n\t\t\t\t\t// We do not shrink the check blocks.\n\t\t\t\t\tcopyDataBlocks--;\n\t\t\t\t}\n\t\t\t\t//if(deductBlocksFromSegments != 0)\n\t\t\t\t\tSystem.err.println(\"REQUESTING: Segment \"+i+\" of \"+segments.length+\" : \"+copyDataBlocks+\" data blocks \"+copyCheckBlocks+\" check blocks\");\n\t\t\t\tClientCHK[] dataBlocks = new ClientCHK[copyDataBlocks];\n\t\t\t\tClientCHK[] checkBlocks = new ClientCHK[copyCheckBlocks];\n\t\t\t\tif(copyDataBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileDataBlocks, dataBlocksPtr, dataBlocks, 0, copyDataBlocks);\n\t\t\t\tif(copyCheckBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, checkBlocksPtr, checkBlocks, 0, copyCheckBlocks);\n\t\t\t\tsegments[i] = new SplitFileFetcherSegment(splitfileType, dataBlocks, checkBlocks, this, archiveContext,\n\t\t\t\t\t\tblockFetchContext, maxTempLength, recursionLevel+1, parent, i, i == segments.length-1, pre1254, crossCheckBlocks, metadata.getSplitfileCryptoAlgorithm(), metadata.getSplitfileCryptoKey());\n\t\t\t\tfor(int j=0;j<dataBlocks.length;j++)\n\t\t\t\t\ttempListener.addKey(dataBlocks[j].getNodeKey(true), i, context);\n\t\t\t\tfor(int j=0;j<checkBlocks.length;j++)\n\t\t\t\t\ttempListener.addKey(checkBlocks[j].getNodeKey(true), i, context);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(segments[i]);\n\t\t\t\t\tsegments[i].deactivateKeys(container);\n\t\t\t\t\tfor(int x=dataBlocksPtr;x<dataBlocksPtr+copyDataBlocks;x++)\n\t\t\t\t\t\tsplitfileDataBlocks[x] = null;\n\t\t\t\t\tfor(int x=checkBlocksPtr;x<checkBlocksPtr+copyCheckBlocks;x++)\n\t\t\t\t\t\tsplitfileCheckBlocks[x] = null;\n\t\t\t\t}\n\t\t\t\tdataBlocksPtr += copyDataBlocks;\n\t\t\t\tcheckBlocksPtr += copyCheckBlocks;\n\t\t\t}\n\t\t\tif(dataBlocksPtr != splitfileDataBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all data blocks to segments - buggy or malicious inserter\");\n\t\t\tif(checkBlocksPtr != splitfileCheckBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all check blocks to segments - buggy or malicious inserter\");\n\t\t}\n\t\tint totalCrossCheckBlocks = segments.length * crossCheckBlocks;\n\t\tparent.addMustSucceedBlocks(splitfileDataBlocks.length - totalCrossCheckBlocks, container);\n\t\tparent.addBlocks(splitfileCheckBlocks.length + totalCrossCheckBlocks, container);\n\t\tparent.notifyClients(container, context);\n\t\t\n\t\tif(crossCheckBlocks != 0) {\n\t\t\tRandom random = new MersenneTwister(Metadata.getCrossSegmentSeed(metadata.getHashes(), metadata.getHashThisLayerOnly()));\n\t\t\t// Cross segment redundancy: Allocate the blocks.\n\t\t\tcrossSegments = new SplitFileFetcherCrossSegment[segments.length];\n\t\t\tint segLen = blocksPerSegment;\n\t\t\tfor(int i=0;i<crossSegments.length;i++) {\n\t\t\t\tSystem.out.println(\"Allocating blocks (on fetch) for cross segment \"+i);\n\t\t\t\tif(segments.length - i == deductBlocksFromSegments) {\n\t\t\t\t\tsegLen--;\n\t\t\t\t}\n\t\t\t\tSplitFileFetcherCrossSegment seg = new SplitFileFetcherCrossSegment(persistent, segLen, crossCheckBlocks, parent, metadata.getSplitfileType());\n\t\t\t\tcrossSegments[i] = seg;\n\t\t\t\tfor(int j=0;j<segLen;j++) {\n\t\t\t\t\t// Allocate random data blocks\n\t\t\t\t\tallocateCrossDataBlock(seg, random);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<crossCheckBlocks;j++) {\n\t\t\t\t\t// Allocate check blocks\n\t\t\t\t\tallocateCrossCheckBlock(seg, random);\n\t\t\t\t}\n\t\t\t\tif(persistent) seg.storeTo(container);\n\t\t\t}\n\t\t} else {\n\t\t\tcrossSegments = null;\n\t\t}\n\t\t\n\t\tif(persistent) {\n\t\t\tfor(SplitFileFetcherSegment seg : segments) {\n\t\t\t\tif(crossCheckBlocks != 0)\n\t\t\t\t\tcontainer.store(seg);\n\t\t\t\tcontainer.deactivate(seg, 1);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\ttempListener.writeFilters();\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to write Bloom filters for splitfile\");\n\t\t}\n\t}","id":101523,"modified_method":"public SplitFileFetcher(Metadata metadata, GetCompletionCallback rcb, ClientRequester parent2,\n\t\t\tFetchContext newCtx, boolean deleteFetchContext, List<? extends Compressor> decompressors2, ClientMetadata clientMetadata,\n\t\t\tArchiveContext actx, int recursionLevel, Bucket returnBucket, long token2, boolean topDontCompress, short topCompatibilityMode, ObjectContainer container, ClientContext context) throws FetchException, MetadataParseException {\n\t\tthis.persistent = parent2.persistent();\n\t\tthis.deleteFetchContext = deleteFetchContext;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Persistence = \"+persistent+\" from \"+parent2, new Exception(\"debug\"));\n\t\tint hash = super.hashCode();\n\t\tif(hash == 0) hash = 1;\n\t\tthis.hashCode = hash;\n\t\tthis.finished = false;\n\t\tthis.returnBucket = returnBucket;\n\t\tthis.fetchContext = newCtx;\n\t\tif(newCtx == null)\n\t\t\tthrow new NullPointerException();\n\t\tthis.archiveContext = actx;\n\t\tthis.decompressors = persistent ? new ArrayList<Compressor>(decompressors2) : decompressors2;\n\t\tif(decompressors.size() > 1) {\n\t\t\tLogger.error(this, \"Multiple decompressors: \"+decompressors.size()+\" - this is almost certainly a bug\", new Exception(\"debug\"));\n\t\t}\n\t\tthis.clientMetadata = clientMetadata == null ? new ClientMetadata() : clientMetadata.clone(); // copy it as in SingleFileFetcher\n\t\tthis.cb = rcb;\n\t\tthis.recursionLevel = recursionLevel + 1;\n\t\tthis.parent = parent2;\n\t\tlocalSalt = new byte[32];\n\t\tcontext.random.nextBytes(localSalt);\n\t\tif(parent2.isCancelled())\n\t\t\tthrow new FetchException(FetchException.CANCELLED);\n\t\toverrideLength = metadata.dataLength();\n\t\tthis.splitfileType = metadata.getSplitfileType();\n\t\tClientCHK[] splitfileDataBlocks = metadata.getSplitfileDataKeys();\n\t\tClientCHK[] splitfileCheckBlocks = metadata.getSplitfileCheckKeys();\n\t\tif(persistent) {\n\t\t\t// Clear them here so they don't get deleted and we don't need to clone them.\n\t\t\tmetadata.clearSplitfileKeys();\n\t\t\tcontainer.store(metadata);\n\t\t}\n\t\tfor(int i=0;i<splitfileDataBlocks.length;i++)\n\t\t\tif(splitfileDataBlocks[i] == null) throw new MetadataParseException(\"Null: data block \"+i+\" of \"+splitfileDataBlocks.length);\n\t\tfor(int i=0;i<splitfileCheckBlocks.length;i++)\n\t\t\tif(splitfileCheckBlocks[i] == null) throw new MetadataParseException(\"Null: check block \"+i+\" of \"+splitfileCheckBlocks.length);\n\t\tlong eventualLength = Math.max(overrideLength, metadata.uncompressedDataLength());\n\t\tboolean wasActive = true;\n\t\tif(persistent) {\n\t\t\twasActive = container.ext().isActive(cb);\n\t\t\tif(!wasActive)\n\t\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tcb.onExpectedSize(eventualLength, container, context);\n\t\tString mimeType = metadata.getMIMEType();\n\t\tif(mimeType != null)\n\t\t\tcb.onExpectedMIME(mimeType, container, context);\n\t\tif(metadata.uncompressedDataLength() > 0)\n\t\t\tcb.onFinalizedMetadata(container);\n\t\tif(!wasActive)\n\t\t\tcontainer.deactivate(cb, 1);\n\t\tif(eventualLength > 0 && newCtx.maxOutputLength > 0 && eventualLength > newCtx.maxOutputLength)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, eventualLength, true, clientMetadata.getMIMEType());\n\n\t\tthis.token = token2;\n\t\t\n\t\tCompatibilityMode minCompatMode = CompatibilityMode.COMPAT_UNKNOWN;\n\t\tCompatibilityMode maxCompatMode = CompatibilityMode.COMPAT_UNKNOWN;\n\n\t\tint crossCheckBlocks = 0;\n\t\t\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\t// Don't need to do much - just fetch everything and piece it together.\n\t\t\tblocksPerSegment = -1;\n\t\t\tcheckBlocksPerSegment = -1;\n\t\t\tsegmentCount = 1;\n\t\t\tdeductBlocksFromSegments = 0;\n\t\t\tif(splitfileCheckBlocks.length > 0) {\n\t\t\t\tLogger.error(this, \"Splitfile type is SPLITFILE_NONREDUNDANT yet \"+splitfileCheckBlocks.length+\" check blocks found!! : \"+this);\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile type is non-redundant yet have \"+splitfileCheckBlocks.length+\" check blocks\");\n\t\t\t}\n\t\t} else if(splitfileType == Metadata.SPLITFILE_ONION_STANDARD) {\n\t\t\tbyte[] params = metadata.splitfileParams();\n\t\t\tint checkBlocks;\n\t\t\tif(metadata.getParsedVersion() == 0) {\n\t\t\t\tif((params == null) || (params.length < 8))\n\t\t\t\t\tthrow new MetadataParseException(\"No splitfile params\");\n\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 0);\n\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 4);\n\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\tint countDataBlocks = splitfileDataBlocks.length;\n\t\t\t\tint countCheckBlocks = splitfileCheckBlocks.length;\n\t\t\t\tif(countDataBlocks == countCheckBlocks) {\n\t\t\t\t\t// No extra check blocks, so before 1251.\n\t\t\t\t\tif(blocksPerSegment == 128) {\n\t\t\t\t\t\t// Is the last segment small enough that we can't have used even splitting?\n\t\t\t\t\t\tint segs = (int)Math.ceil(((double)countDataBlocks) / 128);\n\t\t\t\t\t\tint segSize = (int)Math.ceil(((double)countDataBlocks) / ((double)segs));\n\t\t\t\t\t\tif(segSize == 128) {\n\t\t\t\t\t\t\t// Could be either\n\t\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1251;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1255;\n\t\t\t\tif(params.length < 10)\n\t\t\t\t\tthrow new MetadataParseException(\"Splitfile parameters too short for version 1\");\n\t\t\t\tshort paramsType = Fields.bytesToShort(params, 0);\n\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SIMPLE_SEGMENT || paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 2);\n\t\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 6);\n\t\t\t\t} else\n\t\t\t\t\tthrow new MetadataParseException(\"Unknown splitfile params type \"+paramsType);\n\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\tdeductBlocksFromSegments = Fields.bytesToInt(params, 10);\n\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\tcrossCheckBlocks = Fields.bytesToInt(params, 14);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t}\n\t\t\t\n\t\t\tboolean dontCompress = decompressors.isEmpty();\n\t\t\tif(topCompatibilityMode != 0) {\n\t\t\t\t// If we have top compatibility mode, then we can give a definitive answer immediately, with the splitfile key, with dontcompress, etc etc.\n\t\t\t\tif(minCompatMode == CompatibilityMode.COMPAT_UNKNOWN ||\n\t\t\t\t\t\t!(minCompatMode.ordinal() > topCompatibilityMode || maxCompatMode.ordinal() < topCompatibilityMode)) {\n\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.values()[topCompatibilityMode];\n\t\t\t\t\tdontCompress = topDontCompress;\n\t\t\t\t} else\n\t\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Top compatibility mode is incompatible with detected compatibility mode\");\n\t\t\t}\n\t\t\tcb.onSplitfileCompatibilityMode(minCompatMode, maxCompatMode, metadata.getCustomSplitfileKey(), dontCompress, true, topCompatibilityMode != 0, container, context);\n\n\t\t\t// FIXME remove this eventually. Will break compat with a few files inserted between 1135 and 1136.\n\t\t\t// Work around a bug around build 1135.\n\t\t\t// We were splitting as (128,255), but we were then setting the checkBlocksPerSegment to 64.\n\t\t\t// Detect this.\n\t\t\tif(checkBlocks == 64 && blocksPerSegment == 128 &&\n\t\t\t\t\tsplitfileCheckBlocks.length == splitfileDataBlocks.length - (splitfileDataBlocks.length / 128)) {\n\t\t\t\tLogger.normal(this, \"Activating 1135 wrong check blocks per segment workaround for \"+this);\n\t\t\t\tcheckBlocks = 127;\n\t\t\t}\n\t\t\tcheckBlocksPerSegment = checkBlocks;\n\n\t\t\tif((blocksPerSegment > fetchContext.maxDataBlocksPerSegment)\n\t\t\t\t\t|| (checkBlocksPerSegment > fetchContext.maxCheckBlocksPerSegment))\n\t\t\t\tthrow new FetchException(FetchException.TOO_MANY_BLOCKS_PER_SEGMENT, \"Too many blocks per segment: \"+blocksPerSegment+\" data, \"+checkBlocksPerSegment+\" check\");\n\t\t\tsegmentCount = (splitfileDataBlocks.length / (blocksPerSegment + crossCheckBlocks)) +\n\t\t\t\t(splitfileDataBlocks.length % (blocksPerSegment + crossCheckBlocks) == 0 ? 0 : 1);\n\t\t\t\t\n\t\t\t// Onion, 128/192.\n\t\t\t// Will be segmented.\n\t\t} else throw new MetadataParseException(\"Unknown splitfile format: \"+splitfileType);\n\t\tthis.maxTempLength = fetchContext.maxTempLength;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Algorithm: \"+splitfileType+\", blocks per segment: \"+blocksPerSegment+\n\t\t\t\t\t\", check blocks per segment: \"+checkBlocksPerSegment+\", segments: \"+segmentCount+\n\t\t\t\t\t\", data blocks: \"+splitfileDataBlocks.length+\", check blocks: \"+splitfileCheckBlocks.length);\n\t\tsegments = new SplitFileFetcherSegment[segmentCount]; // initially null on all entries\n\n\t\tthis.crossCheckBlocks = crossCheckBlocks;\n\t\t\n\t\tlong finalLength = 1L * (splitfileDataBlocks.length - segmentCount * crossCheckBlocks) * CHKBlock.DATA_LENGTH;\n\t\tif(finalLength > overrideLength) {\n\t\t\tif(finalLength - overrideLength > CHKBlock.DATA_LENGTH)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile is \"+finalLength+\" but length is \"+finalLength);\n\t\t\tfinalLength = overrideLength;\n\t\t}\n\t\t\n\t\t// Setup bloom parameters.\n\t\tif(persistent) {\n\t\t\t// FIXME: Should this be encrypted? It's protected to some degree by the salt...\n\t\t\t// Since it isn't encrypted, it's likely to be very sparse; we should name\n\t\t\t// it appropriately...\n\t\t\ttry {\n\t\t\t\tmainBloomFile = context.persistentFG.makeRandomFile();\n\t\t\t\taltBloomFile = context.persistentFG.makeRandomFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to create Bloom filter files\", e);\n\t\t\t}\n\t\t} else {\n\t\t\t// Not persistent, keep purely in RAM.\n\t\t\tmainBloomFile = null;\n\t\t\taltBloomFile = null;\n\t\t}\n\t\tint mainElementsPerKey = DEFAULT_MAIN_BLOOM_ELEMENTS_PER_KEY;\n\t\tint origSize = splitfileDataBlocks.length + splitfileCheckBlocks.length;\n\t\tmainBloomK = (int) (mainElementsPerKey * 0.7);\n\t\tlong elementsLong = origSize * mainElementsPerKey;\n\t\t// REDFLAG: SIZE LIMIT: 3.36TB limit!\n\t\tif(elementsLong > Integer.MAX_VALUE)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, \"Cannot fetch splitfiles with more than \"+(Integer.MAX_VALUE/mainElementsPerKey)+\" keys! (approx 3.3TB)\");\n\t\tint mainSizeBits = (int)elementsLong; // counting filter\n\t\tif((mainSizeBits & 7) != 0)\n\t\t\tmainSizeBits += (8 - (mainSizeBits & 7));\n\t\tmainBloomFilterSizeBytes = mainSizeBits / 8 * 2; // counting filter\n\t\tdouble acceptableFalsePositives = ACCEPTABLE_BLOOM_FALSE_POSITIVES_ALL_SEGMENTS / segments.length;\n\t\tint perSegmentBitsPerKey = (int) Math.ceil(Math.log(acceptableFalsePositives) / Math.log(0.6185));\n\t\tint segBlocks = blocksPerSegment + checkBlocksPerSegment;\n\t\tif(segBlocks > origSize)\n\t\t\tsegBlocks = origSize;\n\t\tint perSegmentSize = perSegmentBitsPerKey * segBlocks;\n\t\tif((perSegmentSize & 7) != 0)\n\t\t\tperSegmentSize += (8 - (perSegmentSize & 7));\n\t\tperSegmentBloomFilterSizeBytes = perSegmentSize / 8;\n\t\tperSegmentK = BloomFilter.optimialK(perSegmentSize, segBlocks);\n\t\tkeyCount = origSize;\n\t\t// Now create it.\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Creating block filter for \"+this+\": keys=\"+(splitfileDataBlocks.length+splitfileCheckBlocks.length)+\" main bloom size \"+mainBloomFilterSizeBytes+\" bytes, K=\"+mainBloomK+\", filename=\"+mainBloomFile+\" alt bloom filter: filename=\"+altBloomFile+\" segments: \"+segments.length+\" each is \"+perSegmentBloomFilterSizeBytes+\" bytes k=\"+perSegmentK);\n\t\ttry {\n\t\t\ttempListener = new SplitFileFetcherKeyListener(this, keyCount, mainBloomFile, altBloomFile, mainBloomFilterSizeBytes, mainBloomK, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, true);\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to write Bloom filters for splitfile\");\n\t\t}\n\n\t\tif(persistent)\n\t\t\tcontainer.store(this);\n\n\t\tboolean pre1254 = !(minCompatMode == CompatibilityMode.COMPAT_CURRENT || minCompatMode.ordinal() >= CompatibilityMode.COMPAT_1255.ordinal());\n\t\t\n\t\tblockFetchContext = new FetchContext(fetchContext, FetchContext.SPLITFILE_DEFAULT_BLOCK_MASK, true, null);\n\t\tif(segmentCount == 1) {\n\t\t\t// splitfile* will be overwritten, this is bad\n\t\t\t// so copy them\n\t\t\tClientCHK[] newSplitfileDataBlocks = new ClientCHK[splitfileDataBlocks.length];\n\t\t\tClientCHK[] newSplitfileCheckBlocks = new ClientCHK[splitfileCheckBlocks.length];\n\t\t\tSystem.arraycopy(splitfileDataBlocks, 0, newSplitfileDataBlocks, 0, splitfileDataBlocks.length);\n\t\t\tif(splitfileCheckBlocks.length > 0)\n\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, 0, newSplitfileCheckBlocks, 0, splitfileCheckBlocks.length);\n\t\t\tsegments[0] = new SplitFileFetcherSegment(splitfileType, newSplitfileDataBlocks, newSplitfileCheckBlocks,\n\t\t\t\t\tthis, archiveContext, blockFetchContext, maxTempLength, recursionLevel, parent, 0, true, pre1254, crossCheckBlocks, metadata.getSplitfileCryptoAlgorithm(), metadata.getSplitfileCryptoKey());\n\t\t\tfor(int i=0;i<newSplitfileDataBlocks.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Added data block \"+i+\" : \"+newSplitfileDataBlocks[i].getNodeKey(false));\n\t\t\t\ttempListener.addKey(newSplitfileDataBlocks[i].getNodeKey(true), 0, context);\n\t\t\t}\n\t\t\tfor(int i=0;i<newSplitfileCheckBlocks.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Added check block \"+i+\" : \"+newSplitfileCheckBlocks[i].getNodeKey(false));\n\t\t\t\ttempListener.addKey(newSplitfileCheckBlocks[i].getNodeKey(true), 0, context);\n\t\t\t}\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.store(segments[0]);\n\t\t\t\tsegments[0].deactivateKeys(container);\n\t\t\t\tcontainer.deactivate(segments[0], 1);\n\t\t\t}\n\t\t} else {\n\t\t\tint dataBlocksPtr = 0;\n\t\t\tint checkBlocksPtr = 0;\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t// Create a segment. Give it its keys.\n\t\t\t\tint copyDataBlocks = blocksPerSegment + crossCheckBlocks;\n\t\t\t\tint copyCheckBlocks = checkBlocksPerSegment;\n\t\t\t\tif(i == segments.length - 1) {\n\t\t\t\t\t// Always accept the remainder as the last segment, but do basic sanity checking.\n\t\t\t\t\t// In practice this can be affected by various things: 1) On old splitfiles before full even \n\t\t\t\t\t// segment splitting with deductBlocksFromSegments (i.e. pre-1255), the last segment could be\n\t\t\t\t\t// significantly smaller than the rest; 2) On 1251-1253, with partial even segment splitting,\n\t\t\t\t\t// up to 131 data blocks per segment, cutting the check blocks if necessary, and with an extra\n\t\t\t\t\t// check block if possible, the last segment could have *more* check blocks than the rest. \n\t\t\t\t\tcopyDataBlocks = splitfileDataBlocks.length - dataBlocksPtr;\n\t\t\t\t\tcopyCheckBlocks = splitfileCheckBlocks.length - checkBlocksPtr;\n\t\t\t\t\tif(copyCheckBlocks <= 0 || copyDataBlocks <= 0)\n\t\t\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Last segment has bogus block count: total data blocks \"+splitfileDataBlocks.length+\" total check blocks \"+splitfileCheckBlocks.length+\" segment size \"+blocksPerSegment+\" data \"+checkBlocksPerSegment+\" check \"+crossCheckBlocks+\" cross check blocks, deduct \"+deductBlocksFromSegments+\", segments \"+segments.length);\n\t\t\t\t\tif((copyDataBlocks > fetchContext.maxDataBlocksPerSegment)\n\t\t\t\t\t\t\t|| (copyCheckBlocks > fetchContext.maxCheckBlocksPerSegment))\n\t\t\t\t\t\tthrow new FetchException(FetchException.TOO_MANY_BLOCKS_PER_SEGMENT, \"Too many blocks per segment: \"+blocksPerSegment+\" data, \"+checkBlocksPerSegment+\" check\");\n\t\t\t\t} else if(segments.length - i <= deductBlocksFromSegments) {\n\t\t\t\t\t// Deduct one data block from each of the last deductBlocksFromSegments segments.\n\t\t\t\t\t// This ensures no segment is more than 1 block larger than any other.\n\t\t\t\t\t// We do not shrink the check blocks.\n\t\t\t\t\tcopyDataBlocks--;\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"REQUESTING: Segment \"+i+\" of \"+segments.length+\" : \"+copyDataBlocks+\" data blocks \"+copyCheckBlocks+\" check blocks\");\n\t\t\t\tClientCHK[] dataBlocks = new ClientCHK[copyDataBlocks];\n\t\t\t\tClientCHK[] checkBlocks = new ClientCHK[copyCheckBlocks];\n\t\t\t\tif(copyDataBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileDataBlocks, dataBlocksPtr, dataBlocks, 0, copyDataBlocks);\n\t\t\t\tif(copyCheckBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, checkBlocksPtr, checkBlocks, 0, copyCheckBlocks);\n\t\t\t\tsegments[i] = new SplitFileFetcherSegment(splitfileType, dataBlocks, checkBlocks, this, archiveContext,\n\t\t\t\t\t\tblockFetchContext, maxTempLength, recursionLevel+1, parent, i, i == segments.length-1, pre1254, crossCheckBlocks, metadata.getSplitfileCryptoAlgorithm(), metadata.getSplitfileCryptoKey());\n\t\t\t\tfor(int j=0;j<dataBlocks.length;j++)\n\t\t\t\t\ttempListener.addKey(dataBlocks[j].getNodeKey(true), i, context);\n\t\t\t\tfor(int j=0;j<checkBlocks.length;j++)\n\t\t\t\t\ttempListener.addKey(checkBlocks[j].getNodeKey(true), i, context);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.store(segments[i]);\n\t\t\t\t\tsegments[i].deactivateKeys(container);\n\t\t\t\t\tfor(int x=dataBlocksPtr;x<dataBlocksPtr+copyDataBlocks;x++)\n\t\t\t\t\t\tsplitfileDataBlocks[x] = null;\n\t\t\t\t\tfor(int x=checkBlocksPtr;x<checkBlocksPtr+copyCheckBlocks;x++)\n\t\t\t\t\t\tsplitfileCheckBlocks[x] = null;\n\t\t\t\t}\n\t\t\t\tdataBlocksPtr += copyDataBlocks;\n\t\t\t\tcheckBlocksPtr += copyCheckBlocks;\n\t\t\t}\n\t\t\tif(dataBlocksPtr != splitfileDataBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all data blocks to segments - buggy or malicious inserter\");\n\t\t\tif(checkBlocksPtr != splitfileCheckBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all check blocks to segments - buggy or malicious inserter\");\n\t\t}\n\t\tint totalCrossCheckBlocks = segments.length * crossCheckBlocks;\n\t\tparent.addMustSucceedBlocks(splitfileDataBlocks.length - totalCrossCheckBlocks, container);\n\t\tparent.addBlocks(splitfileCheckBlocks.length + totalCrossCheckBlocks, container);\n\t\tparent.notifyClients(container, context);\n\t\t\n\t\tif(crossCheckBlocks != 0) {\n\t\t\tRandom random = new MersenneTwister(Metadata.getCrossSegmentSeed(metadata.getHashes(), metadata.getHashThisLayerOnly()));\n\t\t\t// Cross segment redundancy: Allocate the blocks.\n\t\t\tcrossSegments = new SplitFileFetcherCrossSegment[segments.length];\n\t\t\tint segLen = blocksPerSegment;\n\t\t\tfor(int i=0;i<crossSegments.length;i++) {\n\t\t\t\tSystem.out.println(\"Allocating blocks (on fetch) for cross segment \"+i);\n\t\t\t\tif(segments.length - i == deductBlocksFromSegments) {\n\t\t\t\t\tsegLen--;\n\t\t\t\t}\n\t\t\t\tSplitFileFetcherCrossSegment seg = new SplitFileFetcherCrossSegment(persistent, segLen, crossCheckBlocks, parent, metadata.getSplitfileType());\n\t\t\t\tcrossSegments[i] = seg;\n\t\t\t\tfor(int j=0;j<segLen;j++) {\n\t\t\t\t\t// Allocate random data blocks\n\t\t\t\t\tallocateCrossDataBlock(seg, random);\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<crossCheckBlocks;j++) {\n\t\t\t\t\t// Allocate check blocks\n\t\t\t\t\tallocateCrossCheckBlock(seg, random);\n\t\t\t\t}\n\t\t\t\tif(persistent) seg.storeTo(container);\n\t\t\t}\n\t\t} else {\n\t\t\tcrossSegments = null;\n\t\t}\n\t\t\n\t\tif(persistent) {\n\t\t\tfor(SplitFileFetcherSegment seg : segments) {\n\t\t\t\tif(crossCheckBlocks != 0)\n\t\t\t\t\tcontainer.store(seg);\n\t\t\t\tcontainer.deactivate(seg, 1);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\ttempListener.writeFilters();\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to write Bloom filters for splitfile\");\n\t\t}\n\t}","commit_id":"1c94d174382848dcd6f51f12626baa1d6657b255","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Group the blocks into segments.\n\t * @param deductBlocksFromSegments \n\t */\n\tprivate SplitFileInserterSegment[] splitIntoSegments(int segmentSize, int crossCheckBlocks, int segCount, int deductBlocksFromSegments, Bucket[] origDataBlocks, Executor executor, ObjectContainer container, ClientContext context, boolean persistent, BaseClientPutter putter, byte cryptoAlgorithm, byte[] splitfileCryptoKey) {\n\t\tint dataBlocks = origDataBlocks.length;\n\n\t\tArrayList<SplitFileInserterSegment> segs = new ArrayList<SplitFileInserterSegment>();\n\n\t\tCompatibilityMode cmode = ctx.getCompatibilityMode();\n\t\t// First split the data up\n\t\tif(segCount == 1) {\n\t\t\t// Single segment\n\t\t\tSplitFileInserterSegment onlySeg = new SplitFileInserterSegment(this, persistent, putter, splitfileAlgorithm, crossCheckBlocks, FECCodec.getCheckBlocks(splitfileAlgorithm, origDataBlocks.length + crossCheckBlocks, cmode), origDataBlocks, ctx, getCHKOnly, 0, cryptoAlgorithm, splitfileCryptoKey, container);\n\t\t\tsegs.add(onlySeg);\n\t\t} else {\n\t\t\tint j = 0;\n\t\t\tint segNo = 0;\n\t\t\tint data = segmentSize;\n\t\t\tint check = FECCodec.getCheckBlocks(splitfileAlgorithm, data + crossCheckBlocks, cmode);\n\t\t\tfor(int i=segmentSize;;) {\n\t\t\t\tif(i > dataBlocks) i = dataBlocks;\n\t\t\t\tif(data > (i-j)) {\n\t\t\t\t\t// Last segment.\n\t\t\t\t\tassert(segNo == segCount-1);\n\t\t\t\t\tdata = i-j;\n\t\t\t\t\tcheck = FECCodec.getCheckBlocks(splitfileAlgorithm, data + crossCheckBlocks, cmode);\n\t\t\t\t}\n\t\t\t\tBucket[] seg = new Bucket[i-j];\n\t\t\t\tSystem.arraycopy(origDataBlocks, j, seg, 0, data);\n\t\t\t\tj = i;\n\t\t\t\tfor(int x=0;x<seg.length;x++)\n\t\t\t\t\tif(seg[x] == null) throw new NullPointerException(\"In splitIntoSegs: \"+x+\" is null of \"+seg.length+\" of \"+segNo);\n\t\t\t\tSplitFileInserterSegment s = new SplitFileInserterSegment(this, persistent, putter, splitfileAlgorithm, crossCheckBlocks, check, seg, ctx, getCHKOnly, segNo, cryptoAlgorithm, splitfileCryptoKey, container);\n\t\t\t\tsegs.add(s);\n\t\t\t\t\n\t\t\t\tif(deductBlocksFromSegments != 0)\n\t\t\t\t\tSystem.err.println(\"INSERTING: Segment \"+segNo+\" of \"+segCount+\" : \"+data+\" data blocks \"+check+\" check blocks\");\n\n\t\t\t\tsegNo++;\n\t\t\t\tif(i == dataBlocks) break;\n\t\t\t\t// Deduct one block from each later segment, rather than having a really short last segment.\n\t\t\t\tif(segCount - segNo == deductBlocksFromSegments) {\n\t\t\t\t\tdata--;\n\t\t\t\t\t// Don't change check.\n\t\t\t\t}\n\t\t\t\ti += data;\n\t\t\t}\n\t\t\tassert(segNo == segCount);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.activate(parent, 1);\n\t\tparent.notifyClients(container, context);\n\t\treturn segs.toArray(new SplitFileInserterSegment[segs.size()]);\n\t}","id":101524,"modified_method":"/**\n\t * Group the blocks into segments.\n\t * @param deductBlocksFromSegments \n\t */\n\tprivate SplitFileInserterSegment[] splitIntoSegments(int segmentSize, int crossCheckBlocks, int segCount, int deductBlocksFromSegments, Bucket[] origDataBlocks, Executor executor, ObjectContainer container, ClientContext context, boolean persistent, BaseClientPutter putter, byte cryptoAlgorithm, byte[] splitfileCryptoKey) {\n\t\tint dataBlocks = origDataBlocks.length;\n\n\t\tArrayList<SplitFileInserterSegment> segs = new ArrayList<SplitFileInserterSegment>();\n\n\t\tCompatibilityMode cmode = ctx.getCompatibilityMode();\n\t\t// First split the data up\n\t\tif(segCount == 1) {\n\t\t\t// Single segment\n\t\t\tSplitFileInserterSegment onlySeg = new SplitFileInserterSegment(this, persistent, putter, splitfileAlgorithm, crossCheckBlocks, FECCodec.getCheckBlocks(splitfileAlgorithm, origDataBlocks.length + crossCheckBlocks, cmode), origDataBlocks, ctx, getCHKOnly, 0, cryptoAlgorithm, splitfileCryptoKey, container);\n\t\t\tsegs.add(onlySeg);\n\t\t} else {\n\t\t\tint j = 0;\n\t\t\tint segNo = 0;\n\t\t\tint data = segmentSize;\n\t\t\tint check = FECCodec.getCheckBlocks(splitfileAlgorithm, data + crossCheckBlocks, cmode);\n\t\t\tfor(int i=segmentSize;;) {\n\t\t\t\tif(i > dataBlocks) i = dataBlocks;\n\t\t\t\tif(data > (i-j)) {\n\t\t\t\t\t// Last segment.\n\t\t\t\t\tassert(segNo == segCount-1);\n\t\t\t\t\tdata = i-j;\n\t\t\t\t\tcheck = FECCodec.getCheckBlocks(splitfileAlgorithm, data + crossCheckBlocks, cmode);\n\t\t\t\t}\n\t\t\t\tBucket[] seg = new Bucket[i-j];\n\t\t\t\tSystem.arraycopy(origDataBlocks, j, seg, 0, data);\n\t\t\t\tj = i;\n\t\t\t\tfor(int x=0;x<seg.length;x++)\n\t\t\t\t\tif(seg[x] == null) throw new NullPointerException(\"In splitIntoSegs: \"+x+\" is null of \"+seg.length+\" of \"+segNo);\n\t\t\t\tSplitFileInserterSegment s = new SplitFileInserterSegment(this, persistent, putter, splitfileAlgorithm, crossCheckBlocks, check, seg, ctx, getCHKOnly, segNo, cryptoAlgorithm, splitfileCryptoKey, container);\n\t\t\t\tsegs.add(s);\n\t\t\t\t\n\t\t\t\tif(deductBlocksFromSegments != 0)\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"INSERTING: Segment \"+segNo+\" of \"+segCount+\" : \"+data+\" data blocks \"+check+\" check blocks\");\n\n\t\t\t\tsegNo++;\n\t\t\t\tif(i == dataBlocks) break;\n\t\t\t\t// Deduct one block from each later segment, rather than having a really short last segment.\n\t\t\t\tif(segCount - segNo == deductBlocksFromSegments) {\n\t\t\t\t\tdata--;\n\t\t\t\t\t// Don't change check.\n\t\t\t\t}\n\t\t\t\ti += data;\n\t\t\t}\n\t\t\tassert(segNo == segCount);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.activate(parent, 1);\n\t\tparent.notifyClients(container, context);\n\t\treturn segs.toArray(new SplitFileInserterSegment[segs.size()]);\n\t}","commit_id":"1c94d174382848dcd6f51f12626baa1d6657b255","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n  public boolean checkInput(String inputString) {\n    boolean firstToken = true;\n    for (String token : StringUtil.tokenize(inputString, myDelimiters)) {\n      if (token.equals(\".\") || token.equals(\"..\")) {\n        myErrorText = \"Can't create a directory with name '\" + token + \"'\";\n        return false;\n      }\n      if (firstToken) {\n        final VirtualFile vFile = myDirectory.getVirtualFile();\n        final VirtualFile child = vFile.findChild(token);\n        if (child != null) {\n          myErrorText = \"A \" + (child.isDirectory() ? \"directory\" : \"file\") +\n                        \" with name '\" + token + \"' already exists\";\n          return false;\n        }\n      }\n      firstToken = false;\n      if (FileTypeManager.getInstance().isFileIgnored(token)) {\n        myErrorText = \"Trying to create a \" + (myIsDirectory ? \"directory\" : \"package\") +\n                      \" with an ignored name, the result will not be visible\";\n        return true;\n      }\n      if (!myIsDirectory && token.length() > 0 && !PsiDirectoryFactory.getInstance(myProject).isValidPackageName(token)) {\n        myErrorText = \"Not a valid package name, it will not be possible to create a class inside\";\n        return true;\n      }\n    }\n    myErrorText = null;\n    return true;\n  }","id":101525,"modified_method":"@Override\n  public boolean checkInput(String inputString) {\n    final StringTokenizer tokenizer = new StringTokenizer(inputString, myDelimiters);\n    VirtualFile vFile = myDirectory.getVirtualFile();\n\n    while (tokenizer.hasMoreTokens()) {\n      final String token = tokenizer.nextToken();\n      if (!tokenizer.hasMoreTokens() && (token.equals(\".\") || token.equals(\"..\"))) {\n        myErrorText = \"Can't create a directory with name '\" + token + \"'\";\n        return false;\n      }\n      if (vFile != null) {\n        if (\"..\".equals(token)) {\n          vFile = vFile.getParent();\n          if (vFile == null) {\n            myErrorText = \"Not a valid directory\";\n            return false;\n          }\n        }\n        else if (!\".\".equals(token)){\n          final VirtualFile child = vFile.findChild(token);\n          if (child != null) {\n            if (!child.isDirectory()) {\n              myErrorText = \"A file with name '\" + token + \"' already exists\";\n              return false;\n            }\n            else if (!tokenizer.hasMoreTokens()) {\n              myErrorText = \"A directory with name '\" + token + \"' already exists\";\n              return false;\n            }\n          }\n          vFile = child;\n        }\n      }\n      if (FileTypeManager.getInstance().isFileIgnored(token)) {\n        myErrorText = \"Trying to create a \" + (myIsDirectory ? \"directory\" : \"package\") +\n                      \" with an ignored name, the result will not be visible\";\n        return true;\n      }\n      if (!myIsDirectory && token.length() > 0 && !PsiDirectoryFactory.getInstance(myProject).isValidPackageName(token)) {\n        myErrorText = \"Not a valid package name, it will not be possible to create a class inside\";\n        return true;\n      }\n    }\n    myErrorText = null;\n    return true;\n  }","commit_id":"dcc0d15e1972098e7d307cba05c6a1f8f51de0de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MkDirs(@NotNull String newName, @NotNull PsiDirectory directory) {\n      if (SystemInfo.isWindows) {\n        newName = newName.replace('\\\\', '/');\n      }\n      if (newName.contains(\"/\")) {\n        final List<String> subDirs = StringUtil.split(newName, \"/\");\n        newName = subDirs.remove(subDirs.size() - 1);\n        for (String dir : subDirs) {\n          final PsiDirectory sub = directory.findSubdirectory(dir);\n          directory = sub == null ? directory.createSubdirectory(dir) : sub;\n        }\n      }\n\n      this.newName = newName;\n      this.directory = directory;\n    }","id":101526,"modified_method":"public MkDirs(@NotNull String newName, @NotNull PsiDirectory directory) {\n      if (SystemInfo.isWindows) {\n        newName = newName.replace('\\\\', '/');\n      }\n      if (newName.contains(\"/\")) {\n        final List<String> subDirs = StringUtil.split(newName, \"/\");\n        newName = subDirs.remove(subDirs.size() - 1);\n        for (String dir : subDirs) {\n          if (\"..\".equals(dir)) {\n            final PsiDirectory parentDirectory = directory.getParentDirectory();\n            if (parentDirectory == null) throw new IncorrectOperationException(\"Not a valid directory\");\n            directory = parentDirectory;\n          }\n          else if (!\".\".equals(dir)){\n            final PsiDirectory sub = directory.findSubdirectory(dir);\n            directory = sub == null ? directory.createSubdirectory(dir) : sub;\n          }\n        }\n      }\n\n      this.newName = newName;\n      this.directory = directory;\n    }","commit_id":"dcc0d15e1972098e7d307cba05c6a1f8f51de0de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean checkInput(String inputString) {\n      final StringTokenizer tokenizer = new StringTokenizer(inputString, \"\\\\/\");\n      boolean firstToken = true;\n      while (tokenizer.hasMoreTokens()) {\n        final String token = tokenizer.nextToken();\n        if (token.equals(\".\") || token.equals(\"..\")) {\n          myErrorText = tokenizer.hasMoreTokens()\n                        ? \"Can't create directory with name '\" + token + \"'\"\n                        : \"Can't create file with name '\" + token + \"'\";\n          return false;\n        }\n        if (firstToken) {\n          final VirtualFile vFile = getDirectory().getVirtualFile();\n          final VirtualFile child = vFile.findChild(token);\n          if (child != null) {\n            myErrorText = \"A \" + (child.isDirectory() ? \"directory\" : \"file\") +\n                          \" with name '\" + token + \"' already exists\";\n            return false;\n          }\n        }\n        firstToken = false;\n        if (FileTypeManager.getInstance().isFileIgnored(getFileName(token))) {\n          myErrorText = \"'\" + token + \"' is an ignored name (Settings | Editor | File Types | Ignore files and folders)\";\n          return true;\n        }\n      }\n      myErrorText = null;\n      return true;\n    }","id":101527,"modified_method":"@Override\n    public boolean checkInput(String inputString) {\n      final StringTokenizer tokenizer = new StringTokenizer(inputString, \"\\\\/\");\n      VirtualFile vFile = getDirectory().getVirtualFile();\n      while (tokenizer.hasMoreTokens()) {\n        final String token = tokenizer.nextToken();\n        if ((token.equals(\".\") || token.equals(\"..\")) && !tokenizer.hasMoreTokens()) {\n          myErrorText = \"Can't create file with name '\" + token + \"'\";\n          return false;\n        }\n        if (vFile != null) {\n          if (\"..\".equals(token)) {\n            vFile = vFile.getParent();\n            if (vFile == null) {\n              myErrorText = \"Not a valid directory\";\n              return false;\n            }\n          }\n          else if (!\".\".equals(token)){\n            final VirtualFile child = vFile.findChild(token);\n            if (child != null) {\n              if (!child.isDirectory()) {\n                myErrorText = \"A file with name '\" + token + \"' already exists\";\n                return false;\n              }\n              else if (!tokenizer.hasMoreTokens()) {\n                myErrorText = \"A directory with name '\" + token + \"' already exists\";\n                return false;\n              }\n            }\n            vFile = child;\n          }\n        }\n        if (FileTypeManager.getInstance().isFileIgnored(getFileName(token))) {\n          myErrorText = \"'\" + token + \"' is an ignored name (Settings | Editor | File Types | Ignore files and folders)\";\n          return true;\n        }\n      }\n      myErrorText = null;\n      return true;\n    }","commit_id":"dcc0d15e1972098e7d307cba05c6a1f8f51de0de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiDirectory createSubdirectories(final String subDirName, PsiDirectory baseDirectory, final String delim) throws IncorrectOperationException {\n    StringTokenizer tokenizer = new StringTokenizer(subDirName, delim);\n    PsiDirectory dir = baseDirectory;\n    while (tokenizer.hasMoreTokens()) {\n      String packName = tokenizer.nextToken();\n      if (tokenizer.hasMoreTokens()) {\n        PsiDirectory existingDir = dir.findSubdirectory(packName);\n        if (existingDir != null) {\n          dir = existingDir;\n          continue;\n        }\n      }\n      dir = dir.createSubdirectory(packName);\n    }\n    return dir;\n  }","id":101528,"modified_method":"public static PsiDirectory createSubdirectories(final String subDirName, PsiDirectory baseDirectory, final String delim) throws IncorrectOperationException {\n    StringTokenizer tokenizer = new StringTokenizer(subDirName, delim);\n    PsiDirectory dir = baseDirectory;\n    while (tokenizer.hasMoreTokens()) {\n      String dirName = tokenizer.nextToken();\n      if (tokenizer.hasMoreTokens()) {\n        if (\"..\".equals(dirName)) {\n          dir = dir.getParentDirectory();\n          if (dir == null) throw new IncorrectOperationException(\"Not a valid directory\");\n          continue;\n        }\n        else if (\".\".equals(dirName)) {\n          continue;\n        }\n        PsiDirectory existingDir = dir.findSubdirectory(dirName);\n        if (existingDir != null) {\n          dir = existingDir;\n          continue;\n        }\n      }\n      dir = dir.createSubdirectory(dirName);\n    }\n    return dir;\n  }","commit_id":"dcc0d15e1972098e7d307cba05c6a1f8f51de0de","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean toResolve(VirtualFile virtualFile, @NotNull Project project) {\n    if (virtualFile != null &&\n        virtualFile.isValid() &&\n        project.isInitialized() &&\n        myProjectFileIndex.isInContent(virtualFile) &&\n        (virtualFile.isDirectory() || virtualFile.getFileType() == StdFileTypes.JAVA || virtualFile.getFileType() == StdFileTypes.XML)) {\n      return true;\n    }\n\n    // else mark it as resolved so we will not have to check it again\n    if (virtualFile instanceof VirtualFileWithId) {\n      int id = getAbsId(virtualFile);\n      fileIsResolved.set(id);\n    }\n\n    return false;\n  }","id":101529,"modified_method":"private boolean toResolve(VirtualFile virtualFile, @NotNull Project project) {\n    if (virtualFile != null &&\n        virtualFile.isValid() &&\n        project.isInitialized() &&\n        myProjectFileIndex.isInContent(virtualFile)) {\n      if (virtualFile.isDirectory()) return true;\n      if (virtualFile.getFileType() == StdFileTypes.JAVA) return true;\n      if (virtualFile.getFileType() == StdFileTypes.XML && !ProjectCoreUtil.isProjectOrWorkspaceFile(virtualFile)) return true;\n    }\n\n    // else mark it as resolved so we will not have to check it again\n    if (virtualFile instanceof VirtualFileWithId) {\n      int id = getAbsId(virtualFile);\n      fileIsResolved.set(id);\n    }\n\n    return false;\n  }","commit_id":"44a29195984d2ebb475861246df6fa92f365adb5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private OSProcessHandler launchBuildProcess(Project project, final int port, final UUID sessionId, boolean requestProjectPreload) throws ExecutionException {\n    final String compilerPath;\n    final String vmExecutablePath;\n    JavaSdkVersion sdkVersion = null;\n\n    final String forcedCompiledJdkHome = Registry.stringValue(COMPILER_PROCESS_JDK_PROPERTY);\n\n    if (StringUtil.isEmptyOrSpaces(forcedCompiledJdkHome)) {\n      // choosing sdk with which the build process should be run\n      Sdk projectJdk = null;\n      int sdkMinorVersion = 0;\n\n      final Set<Sdk> candidates = new HashSet<Sdk>();\n      final Sdk defaultSdk = ProjectRootManager.getInstance(project).getProjectSdk();\n      if (defaultSdk != null && defaultSdk.getSdkType() instanceof JavaSdkType) {\n        candidates.add(defaultSdk);\n      }\n\n      for (Module module : ModuleManager.getInstance(project).getModules()) {\n        final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n        if (sdk != null && sdk.getSdkType() instanceof JavaSdkType) {\n          candidates.add(sdk);\n        }\n      }\n\n      // now select the latest version from the sdks that are used in the project, but not older than the internal sdk version\n      final JavaSdk javaSdkType = JavaSdk.getInstance();\n      for (Sdk candidate : candidates) {\n        final String vs = candidate.getVersionString();\n        if (vs != null) {\n          final JavaSdkVersion candidateVersion = javaSdkType.getVersion(vs);\n          if (candidateVersion != null) {\n            final int candidateMinorVersion = getMinorVersion(vs);\n            if (projectJdk == null) {\n              sdkVersion = candidateVersion;\n              sdkMinorVersion = candidateMinorVersion;\n              projectJdk = candidate;\n            }\n            else {\n              final int result = candidateVersion.compareTo(sdkVersion);\n              if (result > 0 || (result == 0 && candidateMinorVersion > sdkMinorVersion)) {\n                sdkVersion = candidateVersion;\n                sdkMinorVersion = candidateMinorVersion;\n                projectJdk = candidate;\n              }\n            }\n          }\n        }\n      }\n\n      final Sdk internalJdk = JavaAwareProjectJdkTableImpl.getInstanceEx().getInternalJdk();\n      if (projectJdk == null || sdkVersion == null || !sdkVersion.isAtLeast(JavaSdkVersion.JDK_1_6)) {\n        projectJdk = internalJdk;\n      }\n\n      // validate tools.jar presence\n      final JavaSdkType projectJdkType = (JavaSdkType)projectJdk.getSdkType();\n      if (projectJdk.equals(internalJdk)) {\n        // important: because internal JDK can be either JDK or JRE,\n        // this is the most universal way to obtain tools.jar path in this particular case\n        final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n        if (systemCompiler == null) {\n          throw new ExecutionException(\"No system java compiler is provided by the JRE. Make sure tools.jar is present in IntelliJ IDEA classpath.\");\n        }\n        compilerPath = ClasspathBootstrap.getResourcePath(systemCompiler.getClass());\n      }\n      else {\n        compilerPath = projectJdkType.getToolsPath(projectJdk);\n        if (compilerPath == null) {\n          throw new ExecutionException(\"Cannot determine path to 'tools.jar' library for \" + projectJdk.getName() + \" (\" + projectJdk.getHomePath() + \")\");\n        }\n      }\n\n      vmExecutablePath = projectJdkType.getVMExecutablePath(projectJdk);\n    }\n    else {\n      compilerPath = new File(forcedCompiledJdkHome, \"lib/tools.jar\").getAbsolutePath();\n      vmExecutablePath = new File(forcedCompiledJdkHome, \"bin/java\").getAbsolutePath();\n    }\n\n    final CompilerWorkspaceConfiguration config = CompilerWorkspaceConfiguration.getInstance(project);\n    final GeneralCommandLine cmdLine = new GeneralCommandLine();\n    cmdLine.setExePath(vmExecutablePath);\n    //cmdLine.addParameter(\"-XX:MaxPermSize=150m\");\n    //cmdLine.addParameter(\"-XX:ReservedCodeCacheSize=64m\");\n    final int heapSize = config.getProcessHeapSize(JavacConfiguration.getOptions(project, JavacConfiguration.class).MAXIMUM_HEAP_SIZE);\n\n    cmdLine.addParameter(\"-Xmx\" + heapSize + \"m\");\n\n    if (SystemInfo.isMac && sdkVersion != null && JavaSdkVersion.JDK_1_6.equals(sdkVersion) && Registry.is(\"compiler.process.32bit.vm.on.mac\")) {\n      // unfortunately -d32 is supported on jdk 1.6 only\n      cmdLine.addParameter(\"-d32\");\n    }\n\n    cmdLine.addParameter(\"-Djava.awt.headless=true\");\n    cmdLine.addParameter(\"-Djava.endorsed.dirs=\\\"\\\"\"); // turn off all jre customizations for predictable behaviour\n    if (IS_UNIT_TEST_MODE) {\n      cmdLine.addParameter(\"-Dtest.mode=true\");\n    }\n    cmdLine.addParameter(\"-Djdt.compiler.useSingleThread=true\"); // always run eclipse compiler in single-threaded mode\n\n    if (requestProjectPreload) {\n      cmdLine.addParameter(\"-Dpreload.project.path=\" + FileUtil.toCanonicalPath(getProjectPath(project)));\n      cmdLine.addParameter(\"-Dpreload.config.path=\" + FileUtil.toCanonicalPath(PathManager.getOptionsPath()));\n    }\n\n    final String shouldGenerateIndex = System.getProperty(GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION);\n    if (shouldGenerateIndex != null) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION +\"=\" + shouldGenerateIndex);\n    }\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.COMPILE_PARALLEL_OPTION +\"=\" + Boolean.toString(config.PARALLEL_COMPILATION));\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.REBUILD_ON_DEPENDENCY_CHANGE_OPTION + \"=\" + Boolean.toString(config.REBUILD_ON_DEPENDENCY_CHANGE));\n\n    if (Boolean.TRUE.equals(Boolean.valueOf(System.getProperty(\"java.net.preferIPv4Stack\", \"false\")))) {\n      cmdLine.addParameter(\"-Djava.net.preferIPv4Stack=true\");\n    }\n\n    boolean isProfilingMode = false;\n    final String additionalOptions = config.COMPILER_PROCESS_ADDITIONAL_VM_OPTIONS;\n    if (!StringUtil.isEmpty(additionalOptions)) {\n      final StringTokenizer tokenizer = new StringTokenizer(additionalOptions, \" \", false);\n      while (tokenizer.hasMoreTokens()) {\n        final String option = tokenizer.nextToken();\n        if (\"-Dprofiling.mode=true\".equals(option)) {\n          isProfilingMode = true;\n        }\n        cmdLine.addParameter(option);\n      }\n    }\n\n    if (isProfilingMode) {\n      cmdLine.addParameter(\"-agentlib:yjpagent=disablej2ee,disablealloc,delay=10000,sessionname=ExternalBuild\");\n    }\n\n    // debugging\n    final int debugPort = Registry.intValue(\"compiler.process.debug.port\");\n    if (debugPort > 0) {\n      cmdLine.addParameter(\"-XX:+HeapDumpOnOutOfMemoryError\");\n      cmdLine.addParameter(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\" + debugPort);\n    }\n\n    if (!Registry.is(\"compiler.process.use.memory.temp.cache\")) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.USE_MEMORY_TEMP_CACHE_OPTION + \"=false\");\n    }\n\n    // javac's VM should use the same default locale that IDEA uses in order for javac to print messages in 'correct' language\n    cmdLine.setCharset(mySystemCharset);\n    cmdLine.addParameter(\"-D\" + CharsetToolkit.FILE_ENCODING_PROPERTY + \"=\" + mySystemCharset.name());\n    cmdLine.addParameter(\"-D\" + JpsGlobalLoader.FILE_TYPES_COMPONENT_NAME_KEY + \"=\" + FileTypeManagerImpl.getFileTypeComponentName());\n    for (String name : new String[]{\"user.language\", \"user.country\", \"user.region\", PathManager.PROPERTY_PATHS_SELECTOR}) {\n      final String value = System.getProperty(name);\n      if (value != null) {\n        cmdLine.addParameter(\"-D\" + name + \"=\" + value);\n      }\n    }\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_HOME_PATH + \"=\" + PathManager.getHomePath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_CONFIG_PATH + \"=\" + PathManager.getConfigPath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_PLUGINS_PATH + \"=\" + PathManager.getPluginsPath());\n\n    cmdLine.addParameter(\"-D\" + GlobalOptions.LOG_DIR_OPTION + \"=\" + FileUtil.toSystemIndependentName(getBuildLogDirectory().getAbsolutePath()));\n\n    final File workDirectory = getBuildSystemDirectory();\n    //noinspection ResultOfMethodCallIgnored\n    workDirectory.mkdirs();\n    cmdLine.addParameter(\"-Djava.io.tmpdir=\" + FileUtil.toSystemIndependentName(workDirectory.getPath()) + \"/\" + TEMP_DIR_NAME);\n\n    for (BuildProcessParametersProvider provider : project.getExtensions(BuildProcessParametersProvider.EP_NAME)) {\n      final List<String> args = provider.getVMArguments();\n      cmdLine.addParameters(args);\n    }\n\n    @SuppressWarnings(\"UnnecessaryFullyQualifiedName\")\n    final Class<?> launcherClass = org.jetbrains.jps.cmdline.Launcher.class;\n\n    final List<String> launcherCp = new ArrayList<String>();\n    launcherCp.add(ClasspathBootstrap.getResourcePath(launcherClass));\n    launcherCp.add(compilerPath);\n    ClasspathBootstrap.appendJavaCompilerClasspath(launcherCp);\n    launcherCp.addAll(BuildProcessClasspathManager.getLauncherClasspath(project));\n    cmdLine.addParameter(\"-classpath\");\n    cmdLine.addParameter(classpathToString(launcherCp));\n\n    cmdLine.addParameter(launcherClass.getName());\n\n    final List<String> cp = ClasspathBootstrap.getBuildProcessApplicationClasspath(true);\n    cp.addAll(myClasspathManager.getBuildProcessPluginsClasspath(project));\n    if (isProfilingMode) {\n      cp.add(new File(workDirectory, \"yjp-controller-api-redist.jar\").getPath());\n    }\n    cmdLine.addParameter(classpathToString(cp));\n\n    cmdLine.addParameter(BuildMain.class.getName());\n    cmdLine.addParameter(Boolean.valueOf(System.getProperty(\"java.net.preferIPv6Addresses\", \"false\"))? \"::1\" : \"127.0.0.1\");\n    cmdLine.addParameter(Integer.toString(port));\n    cmdLine.addParameter(sessionId.toString());\n\n    cmdLine.addParameter(FileUtil.toSystemIndependentName(workDirectory.getPath()));\n\n    cmdLine.setWorkDirectory(workDirectory);\n\n    final Process process = cmdLine.createProcess();\n\n    final OSProcessHandler processHandler = new OSProcessHandler(process, null, mySystemCharset) {\n      @Override\n      protected boolean shouldDestroyProcessRecursively() {\n        return true;\n      }\n    };\n    processHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        // re-translate builder's output to idea.log\n        final String text = event.getText();\n        if (!StringUtil.isEmptyOrSpaces(text)) {\n          LOG.info(\"BUILDER_PROCESS [\" + outputType.toString() + \"]: \" + text.trim());\n        }\n      }\n    });\n\n    return processHandler;\n  }","id":101530,"modified_method":"private OSProcessHandler launchBuildProcess(Project project, final int port, final UUID sessionId, boolean requestProjectPreload) throws ExecutionException {\n    final String compilerPath;\n    final String vmExecutablePath;\n    JavaSdkVersion sdkVersion = null;\n\n    final String forcedCompiledJdkHome = Registry.stringValue(COMPILER_PROCESS_JDK_PROPERTY);\n\n    if (StringUtil.isEmptyOrSpaces(forcedCompiledJdkHome)) {\n      // choosing sdk with which the build process should be run\n      Sdk projectJdk = null;\n      int sdkMinorVersion = 0;\n\n      final Set<Sdk> candidates = new HashSet<Sdk>();\n      final Sdk defaultSdk = ProjectRootManager.getInstance(project).getProjectSdk();\n      if (defaultSdk != null && defaultSdk.getSdkType() instanceof JavaSdkType) {\n        candidates.add(defaultSdk);\n      }\n\n      for (Module module : ModuleManager.getInstance(project).getModules()) {\n        final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n        if (sdk != null && sdk.getSdkType() instanceof JavaSdkType) {\n          candidates.add(sdk);\n        }\n      }\n\n      // now select the latest version from the sdks that are used in the project, but not older than the internal sdk version\n      final JavaSdk javaSdkType = JavaSdk.getInstance();\n      for (Sdk candidate : candidates) {\n        final String vs = candidate.getVersionString();\n        if (vs != null) {\n          final JavaSdkVersion candidateVersion = javaSdkType.getVersion(vs);\n          if (candidateVersion != null) {\n            final int candidateMinorVersion = getMinorVersion(vs);\n            if (projectJdk == null) {\n              sdkVersion = candidateVersion;\n              sdkMinorVersion = candidateMinorVersion;\n              projectJdk = candidate;\n            }\n            else {\n              final int result = candidateVersion.compareTo(sdkVersion);\n              if (result > 0 || (result == 0 && candidateMinorVersion > sdkMinorVersion)) {\n                sdkVersion = candidateVersion;\n                sdkMinorVersion = candidateMinorVersion;\n                projectJdk = candidate;\n              }\n            }\n          }\n        }\n      }\n\n      final Sdk internalJdk = JavaAwareProjectJdkTableImpl.getInstanceEx().getInternalJdk();\n      if (projectJdk == null || sdkVersion == null || !sdkVersion.isAtLeast(JavaSdkVersion.JDK_1_6)) {\n        projectJdk = internalJdk;\n      }\n\n      // validate tools.jar presence\n      final JavaSdkType projectJdkType = (JavaSdkType)projectJdk.getSdkType();\n      if (projectJdk.equals(internalJdk)) {\n        // important: because internal JDK can be either JDK or JRE,\n        // this is the most universal way to obtain tools.jar path in this particular case\n        final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n        if (systemCompiler == null) {\n          throw new ExecutionException(\"No system java compiler is provided by the JRE. Make sure tools.jar is present in IntelliJ IDEA classpath.\");\n        }\n        compilerPath = ClasspathBootstrap.getResourcePath(systemCompiler.getClass());\n      }\n      else {\n        compilerPath = projectJdkType.getToolsPath(projectJdk);\n        if (compilerPath == null) {\n          throw new ExecutionException(\"Cannot determine path to 'tools.jar' library for \" + projectJdk.getName() + \" (\" + projectJdk.getHomePath() + \")\");\n        }\n      }\n\n      vmExecutablePath = projectJdkType.getVMExecutablePath(projectJdk);\n    }\n    else {\n      compilerPath = new File(forcedCompiledJdkHome, \"lib/tools.jar\").getAbsolutePath();\n      vmExecutablePath = new File(forcedCompiledJdkHome, \"bin/java\").getAbsolutePath();\n    }\n\n    final CompilerWorkspaceConfiguration config = CompilerWorkspaceConfiguration.getInstance(project);\n    final GeneralCommandLine cmdLine = new GeneralCommandLine();\n    cmdLine.setExePath(vmExecutablePath);\n    //cmdLine.addParameter(\"-XX:MaxPermSize=150m\");\n    //cmdLine.addParameter(\"-XX:ReservedCodeCacheSize=64m\");\n    final int heapSize = config.getProcessHeapSize(JavacConfiguration.getOptions(project, JavacConfiguration.class).MAXIMUM_HEAP_SIZE);\n\n    cmdLine.addParameter(\"-Xmx\" + heapSize + \"m\");\n\n    if (SystemInfo.isMac && sdkVersion != null && JavaSdkVersion.JDK_1_6.equals(sdkVersion) && Registry.is(\"compiler.process.32bit.vm.on.mac\")) {\n      // unfortunately -d32 is supported on jdk 1.6 only\n      cmdLine.addParameter(\"-d32\");\n    }\n\n    cmdLine.addParameter(\"-Djava.awt.headless=true\");\n    if (sdkVersion != null && sdkVersion.ordinal() < JavaSdkVersion.JDK_1_9.ordinal()) {\n      //-Djava.endorsed.dirs is not supported in JDK 9+, may result in abnormal process termination\n      cmdLine.addParameter(\"-Djava.endorsed.dirs=\\\"\\\"\"); // turn off all jre customizations for predictable behaviour\n    }\n    if (IS_UNIT_TEST_MODE) {\n      cmdLine.addParameter(\"-Dtest.mode=true\");\n    }\n    cmdLine.addParameter(\"-Djdt.compiler.useSingleThread=true\"); // always run eclipse compiler in single-threaded mode\n\n    if (requestProjectPreload) {\n      cmdLine.addParameter(\"-Dpreload.project.path=\" + FileUtil.toCanonicalPath(getProjectPath(project)));\n      cmdLine.addParameter(\"-Dpreload.config.path=\" + FileUtil.toCanonicalPath(PathManager.getOptionsPath()));\n    }\n\n    final String shouldGenerateIndex = System.getProperty(GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION);\n    if (shouldGenerateIndex != null) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION +\"=\" + shouldGenerateIndex);\n    }\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.COMPILE_PARALLEL_OPTION +\"=\" + Boolean.toString(config.PARALLEL_COMPILATION));\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.REBUILD_ON_DEPENDENCY_CHANGE_OPTION + \"=\" + Boolean.toString(config.REBUILD_ON_DEPENDENCY_CHANGE));\n\n    if (Boolean.TRUE.equals(Boolean.valueOf(System.getProperty(\"java.net.preferIPv4Stack\", \"false\")))) {\n      cmdLine.addParameter(\"-Djava.net.preferIPv4Stack=true\");\n    }\n\n    boolean isProfilingMode = false;\n    final String additionalOptions = config.COMPILER_PROCESS_ADDITIONAL_VM_OPTIONS;\n    if (!StringUtil.isEmpty(additionalOptions)) {\n      final StringTokenizer tokenizer = new StringTokenizer(additionalOptions, \" \", false);\n      while (tokenizer.hasMoreTokens()) {\n        final String option = tokenizer.nextToken();\n        if (\"-Dprofiling.mode=true\".equals(option)) {\n          isProfilingMode = true;\n        }\n        cmdLine.addParameter(option);\n      }\n    }\n\n    if (isProfilingMode) {\n      cmdLine.addParameter(\"-agentlib:yjpagent=disablej2ee,disablealloc,delay=10000,sessionname=ExternalBuild\");\n    }\n\n    // debugging\n    final int debugPort = Registry.intValue(\"compiler.process.debug.port\");\n    if (debugPort > 0) {\n      cmdLine.addParameter(\"-XX:+HeapDumpOnOutOfMemoryError\");\n      cmdLine.addParameter(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\" + debugPort);\n    }\n\n    if (!Registry.is(\"compiler.process.use.memory.temp.cache\")) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.USE_MEMORY_TEMP_CACHE_OPTION + \"=false\");\n    }\n\n    // javac's VM should use the same default locale that IDEA uses in order for javac to print messages in 'correct' language\n    cmdLine.setCharset(mySystemCharset);\n    cmdLine.addParameter(\"-D\" + CharsetToolkit.FILE_ENCODING_PROPERTY + \"=\" + mySystemCharset.name());\n    cmdLine.addParameter(\"-D\" + JpsGlobalLoader.FILE_TYPES_COMPONENT_NAME_KEY + \"=\" + FileTypeManagerImpl.getFileTypeComponentName());\n    for (String name : new String[]{\"user.language\", \"user.country\", \"user.region\", PathManager.PROPERTY_PATHS_SELECTOR}) {\n      final String value = System.getProperty(name);\n      if (value != null) {\n        cmdLine.addParameter(\"-D\" + name + \"=\" + value);\n      }\n    }\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_HOME_PATH + \"=\" + PathManager.getHomePath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_CONFIG_PATH + \"=\" + PathManager.getConfigPath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_PLUGINS_PATH + \"=\" + PathManager.getPluginsPath());\n\n    cmdLine.addParameter(\"-D\" + GlobalOptions.LOG_DIR_OPTION + \"=\" + FileUtil.toSystemIndependentName(getBuildLogDirectory().getAbsolutePath()));\n\n    final File workDirectory = getBuildSystemDirectory();\n    //noinspection ResultOfMethodCallIgnored\n    workDirectory.mkdirs();\n    cmdLine.addParameter(\"-Djava.io.tmpdir=\" + FileUtil.toSystemIndependentName(workDirectory.getPath()) + \"/\" + TEMP_DIR_NAME);\n\n    for (BuildProcessParametersProvider provider : project.getExtensions(BuildProcessParametersProvider.EP_NAME)) {\n      final List<String> args = provider.getVMArguments();\n      cmdLine.addParameters(args);\n    }\n\n    @SuppressWarnings(\"UnnecessaryFullyQualifiedName\")\n    final Class<?> launcherClass = org.jetbrains.jps.cmdline.Launcher.class;\n\n    final List<String> launcherCp = new ArrayList<String>();\n    launcherCp.add(ClasspathBootstrap.getResourcePath(launcherClass));\n    launcherCp.add(compilerPath);\n    ClasspathBootstrap.appendJavaCompilerClasspath(launcherCp);\n    launcherCp.addAll(BuildProcessClasspathManager.getLauncherClasspath(project));\n    cmdLine.addParameter(\"-classpath\");\n    cmdLine.addParameter(classpathToString(launcherCp));\n\n    cmdLine.addParameter(launcherClass.getName());\n\n    final List<String> cp = ClasspathBootstrap.getBuildProcessApplicationClasspath(true);\n    cp.addAll(myClasspathManager.getBuildProcessPluginsClasspath(project));\n    if (isProfilingMode) {\n      cp.add(new File(workDirectory, \"yjp-controller-api-redist.jar\").getPath());\n    }\n    cmdLine.addParameter(classpathToString(cp));\n\n    cmdLine.addParameter(BuildMain.class.getName());\n    cmdLine.addParameter(Boolean.valueOf(System.getProperty(\"java.net.preferIPv6Addresses\", \"false\"))? \"::1\" : \"127.0.0.1\");\n    cmdLine.addParameter(Integer.toString(port));\n    cmdLine.addParameter(sessionId.toString());\n\n    cmdLine.addParameter(FileUtil.toSystemIndependentName(workDirectory.getPath()));\n\n    cmdLine.setWorkDirectory(workDirectory);\n\n    final Process process = cmdLine.createProcess();\n\n    final OSProcessHandler processHandler = new OSProcessHandler(process, null, mySystemCharset) {\n      @Override\n      protected boolean shouldDestroyProcessRecursively() {\n        return true;\n      }\n    };\n    processHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        // re-translate builder's output to idea.log\n        final String text = event.getText();\n        if (!StringUtil.isEmptyOrSpaces(text)) {\n          LOG.info(\"BUILDER_PROCESS [\" + outputType.toString() + \"]: \" + text.trim());\n        }\n      }\n    });\n\n    return processHandler;\n  }","commit_id":"01f5116737fa438bffd3e736bebf9c2c71160eaa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean compile(Collection<String> options,\n                                final Collection<File> sources,\n                                Collection<File> classpath,\n                                Collection<File> platformClasspath,\n                                Collection<File> sourcePath,\n                                Map<File, Set<File>> outputDirToRoots,\n                                final DiagnosticOutputConsumer diagnosticConsumer,\n                                final OutputFileConsumer outputSink,\n                                CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) {\n    JavaCompiler compiler;\n    try {\n      compiler = compilingTool.createCompiler();\n    }\n    catch (CannotCreateJavaCompilerException e) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()));\n      return false;\n    }\n\n    for (File outputDir : outputDirToRoots.keySet()) {\n      outputDir.mkdirs();\n    }\n\n    final List<JavaSourceTransformer> transformers = getSourceTransformers();\n\n    final boolean usingJavac = compilingTool instanceof JavacCompilerTool;\n    final JavacFileManager fileManager = new JavacFileManager(new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, usingJavac), transformers);\n\n    if (!platformClasspath.isEmpty()) {\n      // for javac6 this will prevent lazy initialization of Paths.bootClassPathRtJar \n      // and thus usage of symbol file for resolution, when this file is not expected to be used\n      fileManager.handleOption(\"-bootclasspath\", Collections.singleton(\"\").iterator());\n    }\n    fileManager.handleOption(\"-extdirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    fileManager.handleOption(\"-endorseddirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    final Collection<String> _options = prepareOptions(options, compilingTool);\n\n    try {\n      // to be on the safe side, we'll have to apply all options _before_ calling any of manager's methods\n      // i.e. getJavaFileObjectsFromFiles()\n      // This way the manager will be properly initialized. Namely, the encoding will be set correctly\n      // Note that due to lazy initialization in various components inside javac, handleOption() should be called before setLocation() and others\n      for (Iterator<String> iterator = _options.iterator(); iterator.hasNext(); ) {\n        fileManager.handleOption(iterator.next(), iterator);\n      }\n\n      try {\n        fileManager.setOutputDirectories(outputDirToRoots);\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n\n      if (!classpath.isEmpty()) {\n        try {\n          fileManager.setLocation(StandardLocation.CLASS_PATH, classpath);\n          if (!usingJavac && !isOptionSet(options, \"-processorpath\")) {\n            // for non-javac file manager ensure annotation processor path defaults to classpath\n            fileManager.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpath);\n          }\n        }\n        catch (IOException e) {\n          fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n          return false;\n        }\n      }\n      \n      if (!platformClasspath.isEmpty()) {\n        try {\n          fileManager.handleOption(\"-bootclasspath\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n          fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options));\n        }\n        catch (IOException e) {\n          fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n          return false;\n        }\n      }\n      \n      try {\n        // ensure the source path is set;\n        // otherwise, if not set, javac attempts to search both classes and sources in classpath;\n        // so if some classpath jars contain sources, it will attempt to compile them\n        fileManager.setLocation(StandardLocation.SOURCE_PATH, sourcePath);\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n\n      //noinspection IOResourceOpenedButNotSafelyClosed\n      final LineOutputWriter out = new LineOutputWriter() {\n        protected void lineAvailable(String line) {\n          if (usingJavac) {\n            diagnosticConsumer.outputLineAvailable(line);\n          }\n          else {\n            // todo: filter too verbose eclipse output?\n          }\n        }\n      };\n\n      final JavaCompiler.CompilationTask task = compiler.getTask(\n        out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources)\n      );\n      compilingTool.prepareCompilationTask(task, _options);\n\n      //if (!IS_VM_6_VERSION) { //todo!\n      //  // Do not add the processor for JDK 1.6 because of the bugs in javac\n      //  // The processor's presence may lead to NPE and resolve bugs in compiler\n      //  final JavacASTAnalyser analyzer = new JavacASTAnalyser(outConsumer, !annotationProcessingEnabled);\n      //  task.setProcessors(Collections.singleton(analyzer));\n      //}\n      return task.call();\n    }\n    catch(IllegalArgumentException e) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()));\n    }\n    catch (CompilationCanceledException ignored) {\n      handleCancelException(diagnosticConsumer);\n    }\n    catch (RuntimeException e) {\n      final Throwable cause = e.getCause();\n      if (cause instanceof CompilationCanceledException) {\n        handleCancelException(diagnosticConsumer);\n      }\n      else {\n        throw e;\n      }\n    }\n    finally {\n      fileManager.close();\n      if (usingJavac) {\n        cleanupJavacNameTable();\n      }\n    }\n    return false;\n  }","id":101531,"modified_method":"public static boolean compile(Collection<String> options,\n                                final Collection<File> sources,\n                                Collection<File> classpath,\n                                Collection<File> platformClasspath,\n                                Collection<File> sourcePath,\n                                Map<File, Set<File>> outputDirToRoots,\n                                final DiagnosticOutputConsumer diagnosticConsumer,\n                                final OutputFileConsumer outputSink,\n                                CanceledStatus canceledStatus, @NotNull JavaCompilingTool compilingTool) {\n    JavaCompiler compiler;\n    try {\n      compiler = compilingTool.createCompiler();\n    }\n    catch (CannotCreateJavaCompilerException e) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()));\n      return false;\n    }\n\n    for (File outputDir : outputDirToRoots.keySet()) {\n      outputDir.mkdirs();\n    }\n\n    final List<JavaSourceTransformer> transformers = getSourceTransformers();\n\n    final boolean usingJavac = compilingTool instanceof JavacCompilerTool;\n    final JavacFileManager fileManager = new JavacFileManager(\n      new ContextImpl(compiler, diagnosticConsumer, outputSink, canceledStatus, canUseOptimizedFileManager(compilingTool)), transformers\n    );\n\n    if (!platformClasspath.isEmpty()) {\n      // for javac6 this will prevent lazy initialization of Paths.bootClassPathRtJar \n      // and thus usage of symbol file for resolution, when this file is not expected to be used\n      fileManager.handleOption(\"-bootclasspath\", Collections.singleton(\"\").iterator());\n    }\n    fileManager.handleOption(\"-extdirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    fileManager.handleOption(\"-endorseddirs\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n    final Collection<String> _options = prepareOptions(options, compilingTool);\n\n    try {\n      // to be on the safe side, we'll have to apply all options _before_ calling any of manager's methods\n      // i.e. getJavaFileObjectsFromFiles()\n      // This way the manager will be properly initialized. Namely, the encoding will be set correctly\n      // Note that due to lazy initialization in various components inside javac, handleOption() should be called before setLocation() and others\n      for (Iterator<String> iterator = _options.iterator(); iterator.hasNext(); ) {\n        fileManager.handleOption(iterator.next(), iterator);\n      }\n\n      try {\n        fileManager.setOutputDirectories(outputDirToRoots);\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n\n      if (!classpath.isEmpty()) {\n        try {\n          fileManager.setLocation(StandardLocation.CLASS_PATH, classpath);\n          if (!usingJavac && !isOptionSet(options, \"-processorpath\")) {\n            // for non-javac file manager ensure annotation processor path defaults to classpath\n            fileManager.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, classpath);\n          }\n        }\n        catch (IOException e) {\n          fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n          return false;\n        }\n      }\n      \n      if (!platformClasspath.isEmpty()) {\n        try {\n          fileManager.handleOption(\"-bootclasspath\", Collections.singleton(\"\").iterator()); // this will clear cached stuff\n          fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, buildPlatformClasspath(platformClasspath, _options));\n        }\n        catch (IOException e) {\n          fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n          return false;\n        }\n      }\n      \n      try {\n        // ensure the source path is set;\n        // otherwise, if not set, javac attempts to search both classes and sources in classpath;\n        // so if some classpath jars contain sources, it will attempt to compile them\n        fileManager.setLocation(StandardLocation.SOURCE_PATH, sourcePath);\n      }\n      catch (IOException e) {\n        fileManager.getContext().reportMessage(Diagnostic.Kind.ERROR, e.getMessage());\n        return false;\n      }\n\n      //noinspection IOResourceOpenedButNotSafelyClosed\n      final LineOutputWriter out = new LineOutputWriter() {\n        protected void lineAvailable(String line) {\n          if (usingJavac) {\n            diagnosticConsumer.outputLineAvailable(line);\n          }\n          else {\n            // todo: filter too verbose eclipse output?\n          }\n        }\n      };\n\n      final JavaCompiler.CompilationTask task = compiler.getTask(\n        out, fileManager, diagnosticConsumer, _options, null, fileManager.getJavaFileObjectsFromFiles(sources)\n      );\n      compilingTool.prepareCompilationTask(task, _options);\n\n      //if (!IS_VM_6_VERSION) { //todo!\n      //  // Do not add the processor for JDK 1.6 because of the bugs in javac\n      //  // The processor's presence may lead to NPE and resolve bugs in compiler\n      //  final JavacASTAnalyser analyzer = new JavacASTAnalyser(outConsumer, !annotationProcessingEnabled);\n      //  task.setProcessors(Collections.singleton(analyzer));\n      //}\n      return task.call();\n    }\n    catch(IllegalArgumentException e) {\n      diagnosticConsumer.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR, e.getMessage()));\n    }\n    catch (CompilationCanceledException ignored) {\n      handleCancelException(diagnosticConsumer);\n    }\n    catch (RuntimeException e) {\n      final Throwable cause = e.getCause();\n      if (cause instanceof CompilationCanceledException) {\n        handleCancelException(diagnosticConsumer);\n      }\n      else {\n        throw e;\n      }\n    }\n    finally {\n      fileManager.close();\n      if (usingJavac) {\n        cleanupJavacNameTable();\n      }\n    }\n    return false;\n  }","commit_id":"01f5116737fa438bffd3e736bebf9c2c71160eaa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GeneralCommandLine setupJVMCommandLine(final String exePath,\n                                                       final SimpleJavaParameters javaParameters,\n                                                       final boolean forceDynamicClasspath) {\n    final GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setExePath(exePath);\n\n    final ParametersList vmParametersList = javaParameters.getVMParametersList();\n    commandLine.setEnvParams(javaParameters.getEnv());\n    commandLine.setPassParentEnvs(javaParameters.isPassParentEnvs());\n\n    final Class commandLineWrapper;\n    if ((commandLineWrapper = getCommandLineWrapperClass()) != null) {\n\n      if (javaParameters.isDynamicVMOptions() && useDynamicVMOptions()) {\n        File vmParamsFile = null;\n        try {\n          vmParamsFile = FileUtil.createTempFile(\"vm_params\", null);\n          final PrintWriter writer = new PrintWriter(vmParamsFile);\n          try {\n            for (String param : vmParametersList.getList()) {\n              if (param.startsWith(\"-D\")) {\n                writer.println(param);\n              }\n            }\n          }\n          finally {\n            writer.close();\n          }\n        }\n        catch (IOException e) {\n          LOG.error(e);\n        }\n        final List<String> list = vmParametersList.getList();\n        for (String param : list) {\n          if (!param.trim().startsWith(\"-D\")) {\n            commandLine.addParameter(param);\n          }\n        }\n\n        commandLine.addParameter(\"@vm_params\");\n        commandLine.addParameter(vmParamsFile.getAbsolutePath());\n      }\n      else {\n        commandLine.addParameters(vmParametersList.getList());\n      }\n\n      if (forceDynamicClasspath) {\n        File classpathFile = null;\n        if (!vmParametersList.hasParameter(\"-classpath\") && !vmParametersList.hasParameter(\"-cp\")) {\n          try {\n            classpathFile = FileUtil.createTempFile(\"classpath\", null);\n            final PrintWriter writer = new PrintWriter(classpathFile);\n            try {\n              for (String path : javaParameters.getClassPath().getPathList()) {\n                writer.println(path);\n              }\n            }\n            finally {\n              writer.close();\n            }\n  \n            String classpath = PathUtil.getJarPathForClass(commandLineWrapper);\n            final String utilRtPath = PathUtil.getJarPathForClass(StringUtilRt.class);\n            if (!classpath.equals(utilRtPath)) {\n              classpath += File.pathSeparator + utilRtPath;\n            }\n            final Class<UrlClassLoader> ourUrlClassLoader = UrlClassLoader.class;\n            if (ourUrlClassLoader.getName().equals(vmParametersList.getPropertyValue(\"java.system.class.loader\"))) {\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(ourUrlClassLoader);\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(THashMap.class);\n            }\n  \n            commandLine.addParameter(\"-classpath\");\n            commandLine.addParameter(classpath);\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n  \n        appendEncoding(javaParameters, commandLine, vmParametersList);\n        if (classpathFile != null) {\n          commandLine.addParameter(commandLineWrapper.getName());\n          commandLine.addParameter(classpathFile.getAbsolutePath());\n        }\n      }\n      else {\n        appendEncodingClasspath(javaParameters, commandLine, vmParametersList);\n      }\n    }\n    else {\n      appendParamsEncodingClasspath(javaParameters, commandLine, vmParametersList);\n    }\n\n    final String mainClass = javaParameters.getMainClass();\n    commandLine.addParameter(mainClass);\n    commandLine.addParameters(javaParameters.getProgramParametersList().getList());\n\n    commandLine.setWorkDirectory(javaParameters.getWorkingDirectory());\n\n    return commandLine;\n  }","id":101532,"modified_method":"public static GeneralCommandLine setupJVMCommandLine(final String exePath,\n                                                       final SimpleJavaParameters javaParameters,\n                                                       final boolean forceDynamicClasspath) {\n    final GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setExePath(exePath);\n\n    final ParametersList vmParametersList = javaParameters.getVMParametersList();\n    commandLine.setEnvParams(javaParameters.getEnv());\n    commandLine.setPassParentEnvs(javaParameters.isPassParentEnvs());\n\n    final Class commandLineWrapper;\n    if ((commandLineWrapper = getCommandLineWrapperClass()) != null) {\n      if (forceDynamicClasspath) {\n        File classpathFile = null;\n        File vmParamsFile = null;\n        if (!vmParametersList.hasParameter(\"-classpath\") && !vmParametersList.hasParameter(\"-cp\")) {\n          if (javaParameters.isDynamicVMOptions() && useDynamicVMOptions()) {\n            try {\n              vmParamsFile = FileUtil.createTempFile(\"vm_params\", null);\n              final PrintWriter writer = new PrintWriter(vmParamsFile);\n              try {\n                for (String param : vmParametersList.getList()) {\n                  if (param.startsWith(\"-D\")) {\n                    writer.println(param);\n                  }\n                }\n              }\n              finally {\n                writer.close();\n              }\n            }\n            catch (IOException e) {\n              LOG.error(e);\n            }\n            final List<String> list = vmParametersList.getList();\n            for (String param : list) {\n              if (!param.trim().startsWith(\"-D\")) {\n                commandLine.addParameter(param);\n              }\n            }\n          }\n          else {\n            commandLine.addParameters(vmParametersList.getList());\n          }\n          try {\n            classpathFile = FileUtil.createTempFile(\"classpath\", null);\n            final PrintWriter writer = new PrintWriter(classpathFile);\n            try {\n              for (String path : javaParameters.getClassPath().getPathList()) {\n                writer.println(path);\n              }\n            }\n            finally {\n              writer.close();\n            }\n  \n            String classpath = PathUtil.getJarPathForClass(commandLineWrapper);\n            final String utilRtPath = PathUtil.getJarPathForClass(StringUtilRt.class);\n            if (!classpath.equals(utilRtPath)) {\n              classpath += File.pathSeparator + utilRtPath;\n            }\n            final Class<UrlClassLoader> ourUrlClassLoader = UrlClassLoader.class;\n            if (ourUrlClassLoader.getName().equals(vmParametersList.getPropertyValue(\"java.system.class.loader\"))) {\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(ourUrlClassLoader);\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(THashMap.class);\n            }\n  \n            commandLine.addParameter(\"-classpath\");\n            commandLine.addParameter(classpath);\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n  \n        appendEncoding(javaParameters, commandLine, vmParametersList);\n        if (classpathFile != null) {\n          commandLine.addParameter(commandLineWrapper.getName());\n          commandLine.addParameter(classpathFile.getAbsolutePath());\n        }\n\n        if (vmParamsFile != null) {\n          commandLine.addParameter(\"@vm_params\");\n          commandLine.addParameter(vmParamsFile.getAbsolutePath());\n        }\n      }\n      else {\n        appendParamsEncodingClasspath(javaParameters, commandLine, vmParametersList);\n      }\n    }\n    else {\n      appendParamsEncodingClasspath(javaParameters, commandLine, vmParametersList);\n    }\n\n    final String mainClass = javaParameters.getMainClass();\n    commandLine.addParameter(mainClass);\n    commandLine.addParameters(javaParameters.getProgramParametersList().getList());\n\n    commandLine.setWorkDirectory(javaParameters.getWorkingDirectory());\n\n    return commandLine;\n  }","commit_id":"2725ca8e9927fc3d0100b2cd83bf00b2863704c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendParamsEncodingClasspath(SimpleJavaParameters javaParameters,\n                                                    GeneralCommandLine commandLine,\n                                                    ParametersList parametersList) {\n    commandLine.addParameters(parametersList.getList());\n    appendEncodingClasspath(javaParameters, commandLine, parametersList);\n  }","id":101533,"modified_method":"private static void appendParamsEncodingClasspath(SimpleJavaParameters javaParameters,\n                                                    GeneralCommandLine commandLine,\n                                                    ParametersList parametersList) {\n    commandLine.addParameters(parametersList.getList());\n    appendEncoding(javaParameters, commandLine, parametersList);\n    if (!parametersList.hasParameter(\"-classpath\") && !parametersList.hasParameter(\"-cp\")){\n      commandLine.addParameter(\"-classpath\");\n      commandLine.addParameter(javaParameters.getClassPath().getPathsString());\n    }\n  }","commit_id":"2725ca8e9927fc3d0100b2cd83bf00b2863704c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private OSProcessHandler launchBuildProcess(Project project, final int port, final UUID sessionId, boolean requestProjectPreload) throws ExecutionException {\n    final String compilerPath;\n    final String vmExecutablePath;\n    JavaSdkVersion sdkVersion = null;\n\n    final String forcedCompiledJdkHome = Registry.stringValue(COMPILER_PROCESS_JDK_PROPERTY);\n\n    if (StringUtil.isEmptyOrSpaces(forcedCompiledJdkHome)) {\n      // choosing sdk with which the build process should be run\n      Sdk projectJdk = null;\n      int sdkMinorVersion = 0;\n\n      final Set<Sdk> candidates = new HashSet<Sdk>();\n      final Sdk defaultSdk = ProjectRootManager.getInstance(project).getProjectSdk();\n      if (defaultSdk != null && defaultSdk.getSdkType() instanceof JavaSdkType) {\n        candidates.add(defaultSdk);\n      }\n\n      for (Module module : ModuleManager.getInstance(project).getModules()) {\n        final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n        if (sdk != null && sdk.getSdkType() instanceof JavaSdkType) {\n          candidates.add(sdk);\n        }\n      }\n\n      // now select the latest version from the sdks that are used in the project, but not older than the internal sdk version\n      final JavaSdk javaSdkType = JavaSdk.getInstance();\n      for (Sdk candidate : candidates) {\n        final String vs = candidate.getVersionString();\n        if (vs != null) {\n          final JavaSdkVersion candidateVersion = javaSdkType.getVersion(vs);\n          if (candidateVersion != null) {\n            final int candidateMinorVersion = getMinorVersion(vs);\n            if (projectJdk == null) {\n              sdkVersion = candidateVersion;\n              sdkMinorVersion = candidateMinorVersion;\n              projectJdk = candidate;\n            }\n            else {\n              final int result = candidateVersion.compareTo(sdkVersion);\n              if (result > 0 || (result == 0 && candidateMinorVersion > sdkMinorVersion)) {\n                sdkVersion = candidateVersion;\n                sdkMinorVersion = candidateMinorVersion;\n                projectJdk = candidate;\n              }\n            }\n          }\n        }\n      }\n\n      final Sdk internalJdk = JavaAwareProjectJdkTableImpl.getInstanceEx().getInternalJdk();\n      if (projectJdk == null || sdkVersion == null || !sdkVersion.isAtLeast(JavaSdkVersion.JDK_1_6)) {\n        projectJdk = internalJdk;\n      }\n\n      // validate tools.jar presence\n      final JavaSdkType projectJdkType = (JavaSdkType)projectJdk.getSdkType();\n      if (FileUtil.pathsEqual(projectJdk.getHomePath(), internalJdk.getHomePath())) {\n        // important: because internal JDK can be either JDK or JRE,\n        // this is the most universal way to obtain tools.jar path in this particular case\n        final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n        if (systemCompiler == null) {\n          throw new ExecutionException(\"No system java compiler is provided by the JRE. Make sure tools.jar is present in IntelliJ IDEA classpath.\");\n        }\n        compilerPath = ClasspathBootstrap.getResourcePath(systemCompiler.getClass());\n      }\n      else {\n        compilerPath = projectJdkType.getToolsPath(projectJdk);\n        if (compilerPath == null) {\n          throw new ExecutionException(\"Cannot determine path to 'tools.jar' library for \" + projectJdk.getName() + \" (\" + projectJdk.getHomePath() + \")\");\n        }\n      }\n\n      vmExecutablePath = projectJdkType.getVMExecutablePath(projectJdk);\n    }\n    else {\n      compilerPath = new File(forcedCompiledJdkHome, \"lib/tools.jar\").getAbsolutePath();\n      vmExecutablePath = new File(forcedCompiledJdkHome, \"bin/java\").getAbsolutePath();\n    }\n\n    final CompilerConfiguration projectConfig = CompilerConfiguration.getInstance(project);\n    final CompilerWorkspaceConfiguration config = CompilerWorkspaceConfiguration.getInstance(project);\n    final GeneralCommandLine cmdLine = new GeneralCommandLine();\n    cmdLine.setExePath(vmExecutablePath);\n    //cmdLine.addParameter(\"-XX:MaxPermSize=150m\");\n    //cmdLine.addParameter(\"-XX:ReservedCodeCacheSize=64m\");\n    final int heapSize = projectConfig.getBuildProcessHeapSize(JavacConfiguration.getOptions(project, JavacConfiguration.class).MAXIMUM_HEAP_SIZE);\n\n    cmdLine.addParameter(\"-Xmx\" + heapSize + \"m\");\n\n    if (SystemInfo.isMac && sdkVersion != null && JavaSdkVersion.JDK_1_6.equals(sdkVersion) && Registry.is(\"compiler.process.32bit.vm.on.mac\")) {\n      // unfortunately -d32 is supported on jdk 1.6 only\n      cmdLine.addParameter(\"-d32\");\n    }\n\n    cmdLine.addParameter(\"-Djava.awt.headless=true\");\n    if (sdkVersion != null && sdkVersion.ordinal() < JavaSdkVersion.JDK_1_9.ordinal()) {\n      //-Djava.endorsed.dirs is not supported in JDK 9+, may result in abnormal process termination\n      cmdLine.addParameter(\"-Djava.endorsed.dirs=\\\"\\\"\"); // turn off all jre customizations for predictable behaviour\n    }\n    if (IS_UNIT_TEST_MODE) {\n      cmdLine.addParameter(\"-Dtest.mode=true\");\n    }\n    cmdLine.addParameter(\"-Djdt.compiler.useSingleThread=true\"); // always run eclipse compiler in single-threaded mode\n\n    if (requestProjectPreload) {\n      cmdLine.addParameter(\"-Dpreload.project.path=\" + FileUtil.toCanonicalPath(getProjectPath(project)));\n      cmdLine.addParameter(\"-Dpreload.config.path=\" + FileUtil.toCanonicalPath(PathManager.getOptionsPath()));\n    }\n\n    final String shouldGenerateIndex = System.getProperty(GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION);\n    if (shouldGenerateIndex != null) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION +\"=\" + shouldGenerateIndex);\n    }\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.COMPILE_PARALLEL_OPTION +\"=\" + Boolean.toString(config.PARALLEL_COMPILATION));\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.REBUILD_ON_DEPENDENCY_CHANGE_OPTION + \"=\" + Boolean.toString(config.REBUILD_ON_DEPENDENCY_CHANGE));\n\n    if (Boolean.TRUE.equals(Boolean.valueOf(System.getProperty(\"java.net.preferIPv4Stack\", \"false\")))) {\n      cmdLine.addParameter(\"-Djava.net.preferIPv4Stack=true\");\n    }\n\n    // this will make netty initialization faster on some systems\n    cmdLine.addParameter(\"-Dio.netty.initialSeedUniquifier=\" + ThreadLocalRandom.getInitialSeedUniquifier());\n\n    boolean isProfilingMode = false;\n    final String userAdditionalVMOptions = config.COMPILER_PROCESS_ADDITIONAL_VM_OPTIONS;\n    final String additionalOptions = !StringUtil.isEmptyOrSpaces(userAdditionalVMOptions)? userAdditionalVMOptions : projectConfig.getBuildProcessVMOptions();\n    if (!StringUtil.isEmptyOrSpaces(additionalOptions)) {\n      final StringTokenizer tokenizer = new StringTokenizer(additionalOptions, \" \", false);\n      while (tokenizer.hasMoreTokens()) {\n        final String option = tokenizer.nextToken();\n        if (\"-Dprofiling.mode=true\".equals(option)) {\n          isProfilingMode = true;\n        }\n        cmdLine.addParameter(option);\n      }\n    }\n\n    if (isProfilingMode) {\n      cmdLine.addParameter(\"-agentlib:yjpagent=disablealloc,delay=10000,sessionname=ExternalBuild\");\n    }\n\n    // debugging\n    final int debugPort = Registry.intValue(\"compiler.process.debug.port\");\n    if (debugPort > 0) {\n      cmdLine.addParameter(\"-XX:+HeapDumpOnOutOfMemoryError\");\n      cmdLine.addParameter(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\" + debugPort);\n    }\n\n    if (!Registry.is(\"compiler.process.use.memory.temp.cache\")) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.USE_MEMORY_TEMP_CACHE_OPTION + \"=false\");\n    }\n\n    // javac's VM should use the same default locale that IDEA uses in order for javac to print messages in 'correct' language\n    cmdLine.setCharset(mySystemCharset);\n    cmdLine.addParameter(\"-D\" + CharsetToolkit.FILE_ENCODING_PROPERTY + \"=\" + mySystemCharset.name());\n    cmdLine.addParameter(\"-D\" + JpsGlobalLoader.FILE_TYPES_COMPONENT_NAME_KEY + \"=\" + FileTypeManagerImpl.getFileTypeComponentName());\n    String[] propertiesToPass = {\"user.language\", \"user.country\", \"user.region\", PathManager.PROPERTY_PATHS_SELECTOR, \"idea.case.sensitive.fs\"};\n    for (String name : propertiesToPass) {\n      final String value = System.getProperty(name);\n      if (value != null) {\n        cmdLine.addParameter(\"-D\" + name + \"=\" + value);\n      }\n    }\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_HOME_PATH + \"=\" + PathManager.getHomePath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_CONFIG_PATH + \"=\" + PathManager.getConfigPath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_PLUGINS_PATH + \"=\" + PathManager.getPluginsPath());\n\n    cmdLine.addParameter(\"-D\" + GlobalOptions.LOG_DIR_OPTION + \"=\" + FileUtil.toSystemIndependentName(getBuildLogDirectory().getAbsolutePath()));\n\n    final File workDirectory = getBuildSystemDirectory();\n    //noinspection ResultOfMethodCallIgnored\n    workDirectory.mkdirs();\n    cmdLine.addParameter(\"-Djava.io.tmpdir=\" + FileUtil.toSystemIndependentName(workDirectory.getPath()) + \"/\" + TEMP_DIR_NAME);\n\n    for (BuildProcessParametersProvider provider : project.getExtensions(BuildProcessParametersProvider.EP_NAME)) {\n      final List<String> args = provider.getVMArguments();\n      cmdLine.addParameters(args);\n    }\n\n    @SuppressWarnings(\"UnnecessaryFullyQualifiedName\")\n    final Class<?> launcherClass = org.jetbrains.jps.cmdline.Launcher.class;\n\n    final List<String> launcherCp = new ArrayList<String>();\n    launcherCp.add(ClasspathBootstrap.getResourcePath(launcherClass));\n    launcherCp.add(compilerPath);\n    ClasspathBootstrap.appendJavaCompilerClasspath(launcherCp);\n    launcherCp.addAll(BuildProcessClasspathManager.getLauncherClasspath(project));\n    cmdLine.addParameter(\"-classpath\");\n    cmdLine.addParameter(classpathToString(launcherCp));\n\n    cmdLine.addParameter(launcherClass.getName());\n\n    final List<String> cp = ClasspathBootstrap.getBuildProcessApplicationClasspath(true);\n    cp.addAll(myClasspathManager.getBuildProcessPluginsClasspath(project));\n    if (isProfilingMode) {\n      cp.add(new File(workDirectory, \"yjp-controller-api-redist.jar\").getPath());\n    }\n    cmdLine.addParameter(classpathToString(cp));\n\n    cmdLine.addParameter(BuildMain.class.getName());\n    cmdLine.addParameter(Boolean.valueOf(System.getProperty(\"java.net.preferIPv6Addresses\", \"false\"))? \"::1\" : \"127.0.0.1\");\n    cmdLine.addParameter(Integer.toString(port));\n    cmdLine.addParameter(sessionId.toString());\n\n    cmdLine.addParameter(FileUtil.toSystemIndependentName(workDirectory.getPath()));\n\n    cmdLine.setWorkDirectory(workDirectory);\n\n    final Process process = cmdLine.createProcess();\n\n    final OSProcessHandler processHandler = new OSProcessHandler(process, null, mySystemCharset) {\n      @Override\n      protected boolean shouldDestroyProcessRecursively() {\n        return true;\n      }\n    };\n    processHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        // re-translate builder's output to idea.log\n        final String text = event.getText();\n        if (!StringUtil.isEmptyOrSpaces(text)) {\n          LOG.info(\"BUILDER_PROCESS [\" + outputType.toString() + \"]: \" + text.trim());\n        }\n      }\n    });\n\n    return processHandler;\n  }","id":101534,"modified_method":"private OSProcessHandler launchBuildProcess(Project project, final int port, final UUID sessionId, boolean requestProjectPreload) throws ExecutionException {\n    final String compilerPath;\n    final String vmExecutablePath;\n    JavaSdkVersion sdkVersion = null;\n\n    final String forcedCompiledJdkHome = Registry.stringValue(COMPILER_PROCESS_JDK_PROPERTY);\n\n    if (StringUtil.isEmptyOrSpaces(forcedCompiledJdkHome)) {\n      // choosing sdk with which the build process should be run\n      Sdk projectJdk = null;\n      int sdkMinorVersion = 0;\n\n      final Set<Sdk> candidates = new HashSet<Sdk>();\n      final Sdk defaultSdk = ProjectRootManager.getInstance(project).getProjectSdk();\n      if (defaultSdk != null && defaultSdk.getSdkType() instanceof JavaSdkType) {\n        candidates.add(defaultSdk);\n      }\n\n      for (Module module : ModuleManager.getInstance(project).getModules()) {\n        final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n        if (sdk != null && sdk.getSdkType() instanceof JavaSdkType) {\n          candidates.add(sdk);\n        }\n      }\n\n      // now select the latest version from the sdks that are used in the project, but not older than the internal sdk version\n      final JavaSdk javaSdkType = JavaSdk.getInstance();\n      for (Sdk candidate : candidates) {\n        final String vs = candidate.getVersionString();\n        if (vs != null) {\n          final JavaSdkVersion candidateVersion = javaSdkType.getVersion(vs);\n          if (candidateVersion != null) {\n            final int candidateMinorVersion = getMinorVersion(vs);\n            if (projectJdk == null) {\n              sdkVersion = candidateVersion;\n              sdkMinorVersion = candidateMinorVersion;\n              projectJdk = candidate;\n            }\n            else {\n              final int result = candidateVersion.compareTo(sdkVersion);\n              if (result > 0 || (result == 0 && candidateMinorVersion > sdkMinorVersion)) {\n                sdkVersion = candidateVersion;\n                sdkMinorVersion = candidateMinorVersion;\n                projectJdk = candidate;\n              }\n            }\n          }\n        }\n      }\n\n      final Sdk internalJdk = JavaAwareProjectJdkTableImpl.getInstanceEx().getInternalJdk();\n      if (projectJdk == null || sdkVersion == null || !sdkVersion.isAtLeast(JavaSdkVersion.JDK_1_6)) {\n        projectJdk = internalJdk;\n      }\n\n      // validate tools.jar presence\n      final JavaSdkType projectJdkType = (JavaSdkType)projectJdk.getSdkType();\n      if (FileUtil.pathsEqual(projectJdk.getHomePath(), internalJdk.getHomePath())) {\n        // important: because internal JDK can be either JDK or JRE,\n        // this is the most universal way to obtain tools.jar path in this particular case\n        final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n        if (systemCompiler == null) {\n          throw new ExecutionException(\"No system java compiler is provided by the JRE. Make sure tools.jar is present in IntelliJ IDEA classpath.\");\n        }\n        compilerPath = ClasspathBootstrap.getResourcePath(systemCompiler.getClass());\n      }\n      else {\n        compilerPath = projectJdkType.getToolsPath(projectJdk);\n        if (compilerPath == null) {\n          throw new ExecutionException(\"Cannot determine path to 'tools.jar' library for \" + projectJdk.getName() + \" (\" + projectJdk.getHomePath() + \")\");\n        }\n      }\n\n      vmExecutablePath = projectJdkType.getVMExecutablePath(projectJdk);\n    }\n    else {\n      compilerPath = new File(forcedCompiledJdkHome, \"lib/tools.jar\").getAbsolutePath();\n      vmExecutablePath = new File(forcedCompiledJdkHome, \"bin/java\").getAbsolutePath();\n    }\n\n    final CompilerConfiguration projectConfig = CompilerConfiguration.getInstance(project);\n    final CompilerWorkspaceConfiguration config = CompilerWorkspaceConfiguration.getInstance(project);\n    final GeneralCommandLine cmdLine = new GeneralCommandLine();\n    cmdLine.setExePath(vmExecutablePath);\n    //cmdLine.addParameter(\"-XX:MaxPermSize=150m\");\n    //cmdLine.addParameter(\"-XX:ReservedCodeCacheSize=64m\");\n\n    boolean isProfilingMode = false;\n    String userDefinedHeapSize = null;\n    final List<String> userAdditionalOptionsList = new SmartList<String>();\n    final String userAdditionalVMOptions = config.COMPILER_PROCESS_ADDITIONAL_VM_OPTIONS;\n    final String additionalOptions = !StringUtil.isEmptyOrSpaces(userAdditionalVMOptions)? userAdditionalVMOptions : projectConfig.getBuildProcessVMOptions();\n    if (!StringUtil.isEmptyOrSpaces(additionalOptions)) {\n      final StringTokenizer tokenizer = new StringTokenizer(additionalOptions, \" \", false);\n      while (tokenizer.hasMoreTokens()) {\n        final String option = tokenizer.nextToken();\n        if (StringUtil.startsWithIgnoreCase(option, \"-Xmx\")) {\n          userDefinedHeapSize = option;\n        }\n        else {\n          if (\"-Dprofiling.mode=true\".equals(option)) {\n            isProfilingMode = true;\n          }\n          userAdditionalOptionsList.add(option);\n        }\n      }\n    }\n\n    if (userDefinedHeapSize != null) {\n      cmdLine.addParameter(userDefinedHeapSize);\n    }\n    else {\n      final int heapSize = projectConfig.getBuildProcessHeapSize(\n        JavacConfiguration.getOptions(project, JavacConfiguration.class).MAXIMUM_HEAP_SIZE);\n      cmdLine.addParameter(\"-Xmx\" + heapSize + \"m\");\n    }\n\n    if (SystemInfo.isMac && sdkVersion != null && JavaSdkVersion.JDK_1_6.equals(sdkVersion) && Registry.is(\"compiler.process.32bit.vm.on.mac\")) {\n      // unfortunately -d32 is supported on jdk 1.6 only\n      cmdLine.addParameter(\"-d32\");\n    }\n\n    cmdLine.addParameter(\"-Djava.awt.headless=true\");\n    if (sdkVersion != null && sdkVersion.ordinal() < JavaSdkVersion.JDK_1_9.ordinal()) {\n      //-Djava.endorsed.dirs is not supported in JDK 9+, may result in abnormal process termination\n      cmdLine.addParameter(\"-Djava.endorsed.dirs=\\\"\\\"\"); // turn off all jre customizations for predictable behaviour\n    }\n    if (IS_UNIT_TEST_MODE) {\n      cmdLine.addParameter(\"-Dtest.mode=true\");\n    }\n    cmdLine.addParameter(\"-Djdt.compiler.useSingleThread=true\"); // always run eclipse compiler in single-threaded mode\n\n    if (requestProjectPreload) {\n      cmdLine.addParameter(\"-Dpreload.project.path=\" + FileUtil.toCanonicalPath(getProjectPath(project)));\n      cmdLine.addParameter(\"-Dpreload.config.path=\" + FileUtil.toCanonicalPath(PathManager.getOptionsPath()));\n    }\n\n    final String shouldGenerateIndex = System.getProperty(GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION);\n    if (shouldGenerateIndex != null) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.GENERATE_CLASSPATH_INDEX_OPTION +\"=\" + shouldGenerateIndex);\n    }\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.COMPILE_PARALLEL_OPTION +\"=\" + Boolean.toString(config.PARALLEL_COMPILATION));\n    cmdLine.addParameter(\"-D\"+ GlobalOptions.REBUILD_ON_DEPENDENCY_CHANGE_OPTION + \"=\" + Boolean.toString(config.REBUILD_ON_DEPENDENCY_CHANGE));\n\n    if (Boolean.TRUE.equals(Boolean.valueOf(System.getProperty(\"java.net.preferIPv4Stack\", \"false\")))) {\n      cmdLine.addParameter(\"-Djava.net.preferIPv4Stack=true\");\n    }\n\n    // this will make netty initialization faster on some systems\n    cmdLine.addParameter(\"-Dio.netty.initialSeedUniquifier=\" + ThreadLocalRandom.getInitialSeedUniquifier());\n\n    for (String option : userAdditionalOptionsList) {\n      cmdLine.addParameter(option);\n    }\n    if (isProfilingMode) {\n      cmdLine.addParameter(\"-agentlib:yjpagent=disablealloc,delay=10000,sessionname=ExternalBuild\");\n    }\n\n    // debugging\n    final int debugPort = Registry.intValue(\"compiler.process.debug.port\");\n    if (debugPort > 0) {\n      cmdLine.addParameter(\"-XX:+HeapDumpOnOutOfMemoryError\");\n      cmdLine.addParameter(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\" + debugPort);\n    }\n\n    if (!Registry.is(\"compiler.process.use.memory.temp.cache\")) {\n      cmdLine.addParameter(\"-D\"+ GlobalOptions.USE_MEMORY_TEMP_CACHE_OPTION + \"=false\");\n    }\n\n    // javac's VM should use the same default locale that IDEA uses in order for javac to print messages in 'correct' language\n    cmdLine.setCharset(mySystemCharset);\n    cmdLine.addParameter(\"-D\" + CharsetToolkit.FILE_ENCODING_PROPERTY + \"=\" + mySystemCharset.name());\n    cmdLine.addParameter(\"-D\" + JpsGlobalLoader.FILE_TYPES_COMPONENT_NAME_KEY + \"=\" + FileTypeManagerImpl.getFileTypeComponentName());\n    String[] propertiesToPass = {\"user.language\", \"user.country\", \"user.region\", PathManager.PROPERTY_PATHS_SELECTOR, \"idea.case.sensitive.fs\"};\n    for (String name : propertiesToPass) {\n      final String value = System.getProperty(name);\n      if (value != null) {\n        cmdLine.addParameter(\"-D\" + name + \"=\" + value);\n      }\n    }\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_HOME_PATH + \"=\" + PathManager.getHomePath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_CONFIG_PATH + \"=\" + PathManager.getConfigPath());\n    cmdLine.addParameter(\"-D\" + PathManager.PROPERTY_PLUGINS_PATH + \"=\" + PathManager.getPluginsPath());\n\n    cmdLine.addParameter(\"-D\" + GlobalOptions.LOG_DIR_OPTION + \"=\" + FileUtil.toSystemIndependentName(getBuildLogDirectory().getAbsolutePath()));\n\n    final File workDirectory = getBuildSystemDirectory();\n    //noinspection ResultOfMethodCallIgnored\n    workDirectory.mkdirs();\n    cmdLine.addParameter(\"-Djava.io.tmpdir=\" + FileUtil.toSystemIndependentName(workDirectory.getPath()) + \"/\" + TEMP_DIR_NAME);\n\n    for (BuildProcessParametersProvider provider : project.getExtensions(BuildProcessParametersProvider.EP_NAME)) {\n      final List<String> args = provider.getVMArguments();\n      cmdLine.addParameters(args);\n    }\n\n    @SuppressWarnings(\"UnnecessaryFullyQualifiedName\")\n    final Class<?> launcherClass = org.jetbrains.jps.cmdline.Launcher.class;\n\n    final List<String> launcherCp = new ArrayList<String>();\n    launcherCp.add(ClasspathBootstrap.getResourcePath(launcherClass));\n    launcherCp.add(compilerPath);\n    ClasspathBootstrap.appendJavaCompilerClasspath(launcherCp);\n    launcherCp.addAll(BuildProcessClasspathManager.getLauncherClasspath(project));\n    cmdLine.addParameter(\"-classpath\");\n    cmdLine.addParameter(classpathToString(launcherCp));\n\n    cmdLine.addParameter(launcherClass.getName());\n\n    final List<String> cp = ClasspathBootstrap.getBuildProcessApplicationClasspath(true);\n    cp.addAll(myClasspathManager.getBuildProcessPluginsClasspath(project));\n    if (isProfilingMode) {\n      cp.add(new File(workDirectory, \"yjp-controller-api-redist.jar\").getPath());\n    }\n    cmdLine.addParameter(classpathToString(cp));\n\n    cmdLine.addParameter(BuildMain.class.getName());\n    cmdLine.addParameter(Boolean.valueOf(System.getProperty(\"java.net.preferIPv6Addresses\", \"false\"))? \"::1\" : \"127.0.0.1\");\n    cmdLine.addParameter(Integer.toString(port));\n    cmdLine.addParameter(sessionId.toString());\n\n    cmdLine.addParameter(FileUtil.toSystemIndependentName(workDirectory.getPath()));\n\n    cmdLine.setWorkDirectory(workDirectory);\n\n    final Process process = cmdLine.createProcess();\n\n    final OSProcessHandler processHandler = new OSProcessHandler(process, null, mySystemCharset) {\n      @Override\n      protected boolean shouldDestroyProcessRecursively() {\n        return true;\n      }\n    };\n    processHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        // re-translate builder's output to idea.log\n        final String text = event.getText();\n        if (!StringUtil.isEmptyOrSpaces(text)) {\n          LOG.info(\"BUILDER_PROCESS [\" + outputType.toString() + \"]: \" + text.trim());\n        }\n      }\n    });\n\n    return processHandler;\n  }","commit_id":"b13a47fd2f72cd25852b3dd4555f0e9b330e0e99","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<File> getJdkClassesRoots(File home, boolean isJre) {\n    FileFilter jarFileFilter = new FileFilter() {\n      @Override\n      @SuppressWarnings({\"HardCodedStringLiteral\"})\n      public boolean accept(File f) {\n        return !f.isDirectory() && f.getName().endsWith(\".jar\");\n      }\n    };\n\n    File[] jarDirs;\n    if (SystemInfo.isMac && !home.getName().startsWith(\"mockJDK\")) {\n      File openJdkRtJar = new File(home, \"jre/lib/rt.jar\");\n      if (openJdkRtJar.exists() && !openJdkRtJar.isDirectory()) {\n        File libDir = new File(home, \"lib\");\n        File classesDir = openJdkRtJar.getParentFile();\n        File libExtDir = new File(openJdkRtJar.getParentFile(), \"ext\");\n        File libEndorsedDir = new File(libDir, \"endorsed\");\n        jarDirs = new File[]{libEndorsedDir, libDir, classesDir, libExtDir};\n      }\n      else {\n        File libDir = new File(home, \"lib\");\n        File classesDir = new File(home, \"../Classes\");\n        File libExtDir = new File(libDir, \"ext\");\n        File libEndorsedDir = new File(libDir, \"endorsed\");\n        jarDirs = new File[]{libEndorsedDir, libDir, classesDir, libExtDir};\n      }\n    }\n    else {\n      File libDir = isJre ? new File(home, \"lib\") : new File(home, \"jre/lib\");\n      File libExtDir = new File(libDir, \"ext\");\n      File libEndorsedDir = new File(libDir, \"endorsed\");\n      jarDirs = new File[]{libEndorsedDir, libDir, libExtDir};\n    }\n\n    Set<String> pathFilter = ContainerUtil.newTroveSet(FileUtil.PATH_HASHING_STRATEGY);\n    List<File> rootFiles = ContainerUtil.newArrayList();\n    for (File jarDir : jarDirs) {\n      if (jarDir != null && jarDir.isDirectory()) {\n        File[] jarFiles = jarDir.listFiles(jarFileFilter);\n        for (File jarFile : jarFiles) {\n          String jarFileName = jarFile.getName();\n          if (jarFileName.equals(\"alt-rt.jar\") || jarFileName.equals(\"alt-string.jar\")) {\n            continue;  // filter out alternative implementations\n          }\n          String canonicalPath = getCanonicalPath(jarFile);\n          if (canonicalPath == null || !pathFilter.add(canonicalPath)) {\n            continue;  // filter out duplicate (symbolically linked) .jar files commonly found in OS X JDK distributions\n          }\n          rootFiles.add(jarFile);\n        }\n      }\n    }\n\n    String[] additionalJars = {\n      \"jre/bin/default/jclSC170/vm.jar\",\n      \"jre/lib/i386/default/jclSC170/vm.jar\",\n      \"jre/lib/amd64/default/jclSC170/vm.jar\",\n      \"jre/bin/default/jclSC160/vm.jar\",\n      \"jre/lib/i386/default/jclSC160/vm.jar\",\n      \"jre/lib/amd64/default/jclSC160/vm.jar\",\n      \"lib/classes.zip\"\n    };\n    for (String relativePath : additionalJars) {\n      File jar = new File(home, relativePath);\n      if (jar.isFile()) {\n        rootFiles.add(jar);\n      }\n    }\n\n    File classesDir = new File(home, \"classes\");\n    if (rootFiles.isEmpty() && classesDir.isDirectory()) {\n      rootFiles.add(classesDir);\n    }\n\n    return rootFiles;\n  }","id":101535,"modified_method":"@NotNull\n  public static List<File> getJdkClassesRoots(@NotNull File home, boolean isJre) {\n    FileFilter jarFileFilter = new FileFilter() {\n      @Override\n      public boolean accept(@NotNull File f) {\n        return !f.isDirectory() && f.getName().endsWith(\".jar\");\n      }\n    };\n\n    File[] jarDirs;\n    if (SystemInfo.isMac && !home.getName().startsWith(\"mockJDK\")) {\n      File openJdkRtJar = new File(home, \"jre/lib/rt.jar\");\n      if (openJdkRtJar.exists() && !openJdkRtJar.isDirectory()) {\n        File libDir = new File(home, \"lib\");\n        File classesDir = openJdkRtJar.getParentFile();\n        File libExtDir = new File(openJdkRtJar.getParentFile(), \"ext\");\n        File libEndorsedDir = new File(libDir, \"endorsed\");\n        jarDirs = new File[]{libEndorsedDir, libDir, classesDir, libExtDir};\n      }\n      else {\n        File libDir = new File(home, \"lib\");\n        File classesDir = new File(home, \"../Classes\");\n        File libExtDir = new File(libDir, \"ext\");\n        File libEndorsedDir = new File(libDir, \"endorsed\");\n        jarDirs = new File[]{libEndorsedDir, libDir, classesDir, libExtDir};\n      }\n    }\n    else {\n      File libDir = isJre ? new File(home, \"lib\") : new File(home, \"jre/lib\");\n      File libExtDir = new File(libDir, \"ext\");\n      File libEndorsedDir = new File(libDir, \"endorsed\");\n      jarDirs = new File[]{libEndorsedDir, libDir, libExtDir};\n    }\n\n    Set<String> pathFilter = ContainerUtil.newTroveSet(FileUtil.PATH_HASHING_STRATEGY);\n    List<File> rootFiles = ContainerUtil.newArrayList();\n    for (File jarDir : jarDirs) {\n      if (jarDir != null && jarDir.isDirectory()) {\n        File[] jarFiles = jarDir.listFiles(jarFileFilter);\n        for (File jarFile : jarFiles) {\n          String jarFileName = jarFile.getName();\n          if (jarFileName.equals(\"alt-rt.jar\") || jarFileName.equals(\"alt-string.jar\")) {\n            continue;  // filter out alternative implementations\n          }\n          String canonicalPath = getCanonicalPath(jarFile);\n          if (canonicalPath == null || !pathFilter.add(canonicalPath)) {\n            continue;  // filter out duplicate (symbolically linked) .jar files commonly found in OS X JDK distributions\n          }\n          rootFiles.add(jarFile);\n        }\n      }\n    }\n\n    String[] additionalJars = {\n      \"jre/bin/default/jclSC170/vm.jar\",\n      \"jre/lib/i386/default/jclSC170/vm.jar\",\n      \"jre/lib/amd64/default/jclSC170/vm.jar\",\n      \"jre/bin/default/jclSC160/vm.jar\",\n      \"jre/lib/i386/default/jclSC160/vm.jar\",\n      \"jre/lib/amd64/default/jclSC160/vm.jar\",\n      \"lib/classes.zip\"\n    };\n    for (String relativePath : additionalJars) {\n      File jar = new File(home, relativePath);\n      if (jar.isFile()) {\n        rootFiles.add(jar);\n      }\n    }\n\n    File classesDir = new File(home, \"classes\");\n    if (rootFiles.isEmpty() && classesDir.isDirectory()) {\n      rootFiles.add(classesDir);\n    }\n\n    return rootFiles;\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GeneralCommandLine setupJVMCommandLine(final String exePath,\n                                                       final SimpleJavaParameters javaParameters,\n                                                       final boolean forceDynamicClasspath) {\n    final GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setExePath(exePath);\n\n    final ParametersList vmParametersList = javaParameters.getVMParametersList();\n    commandLine.getEnvironment().putAll(javaParameters.getEnv());\n    commandLine.setPassParentEnvironment(javaParameters.isPassParentEnvs());\n\n    final Class commandLineWrapper;\n    if ((commandLineWrapper = getCommandLineWrapperClass()) != null) {\n      if (forceDynamicClasspath) {\n        File classpathFile = null;\n        File vmParamsFile = null;\n        if (!vmParametersList.hasParameter(\"-classpath\") && !vmParametersList.hasParameter(\"-cp\")) {\n          if (javaParameters.isDynamicVMOptions() && useDynamicVMOptions()) {\n            try {\n              vmParamsFile = FileUtil.createTempFile(\"vm_params\", null);\n              final PrintWriter writer = new PrintWriter(vmParamsFile);\n              try {\n                for (String param : vmParametersList.getList()) {\n                  if (param.startsWith(\"-D\")) {\n                    writer.println(param);\n                  }\n                }\n              }\n              finally {\n                writer.close();\n              }\n            }\n            catch (IOException e) {\n              LOG.error(e);\n            }\n            final List<String> list = vmParametersList.getList();\n            for (String param : list) {\n              if (!param.trim().startsWith(\"-D\")) {\n                commandLine.addParameter(param);\n              }\n            }\n          }\n          else {\n            commandLine.addParameters(vmParametersList.getList());\n          }\n          try {\n            classpathFile = FileUtil.createTempFile(\"classpath\", null);\n            final PrintWriter writer = new PrintWriter(classpathFile);\n            try {\n              for (String path : javaParameters.getClassPath().getPathList()) {\n                writer.println(path);\n              }\n            }\n            finally {\n              writer.close();\n            }\n\n            String classpath = PathUtil.getJarPathForClass(commandLineWrapper);\n            final String utilRtPath = PathUtil.getJarPathForClass(StringUtilRt.class);\n            if (!classpath.equals(utilRtPath)) {\n              classpath += File.pathSeparator + utilRtPath;\n            }\n            final Class<UrlClassLoader> ourUrlClassLoader = UrlClassLoader.class;\n            if (ourUrlClassLoader.getName().equals(vmParametersList.getPropertyValue(\"java.system.class.loader\"))) {\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(ourUrlClassLoader);\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(THashMap.class);\n            }\n\n            commandLine.addParameter(\"-classpath\");\n            commandLine.addParameter(classpath);\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n\n        appendEncoding(javaParameters, commandLine, vmParametersList);\n        if (classpathFile != null) {\n          commandLine.addParameter(commandLineWrapper.getName());\n          commandLine.addParameter(classpathFile.getAbsolutePath());\n        }\n\n        if (vmParamsFile != null) {\n          commandLine.addParameter(\"@vm_params\");\n          commandLine.addParameter(vmParamsFile.getAbsolutePath());\n        }\n      }\n      else {\n        appendParamsEncodingClasspath(javaParameters, commandLine, vmParametersList);\n      }\n    }\n    else {\n      appendParamsEncodingClasspath(javaParameters, commandLine, vmParametersList);\n    }\n\n    final String mainClass = javaParameters.getMainClass();\n    String jarPath = javaParameters.getJarPath();\n    if (mainClass != null) {\n      commandLine.addParameter(mainClass);\n    }\n    else if (jarPath != null) {\n      commandLine.addParameter(\"-jar\");\n      commandLine.addParameter(jarPath);\n    }\n\n    commandLine.addParameters(javaParameters.getProgramParametersList().getList());\n\n    commandLine.setWorkDirectory(javaParameters.getWorkingDirectory());\n\n    return commandLine;\n  }","id":101536,"modified_method":"public static GeneralCommandLine setupJVMCommandLine(final String exePath,\n                                                       final SimpleJavaParameters javaParameters,\n                                                       final boolean forceDynamicClasspath) {\n    final GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setExePath(exePath);\n\n    final ParametersList vmParametersList = javaParameters.getVMParametersList();\n    commandLine.getEnvironment().putAll(javaParameters.getEnv());\n    commandLine.setPassParentEnvironment(javaParameters.isPassParentEnvs());\n\n    final Class commandLineWrapper;\n    if ((commandLineWrapper = getCommandLineWrapperClass()) != null) {\n      if (forceDynamicClasspath) {\n        File classpathFile = null;\n        File vmParamsFile = null;\n        if (!vmParametersList.hasParameter(\"-classpath\") && !vmParametersList.hasParameter(\"-cp\")) {\n          if (javaParameters.isDynamicVMOptions() && useDynamicVMOptions()) {\n            try {\n              vmParamsFile = FileUtil.createTempFile(\"vm_params\", null);\n              final PrintWriter writer = new PrintWriter(vmParamsFile);\n              try {\n                for (String param : vmParametersList.getList()) {\n                  if (param.startsWith(\"-D\")) {\n                    writer.println(param);\n                  }\n                }\n              }\n              finally {\n                writer.close();\n              }\n            }\n            catch (IOException e) {\n              LOG.error(e);\n            }\n            final List<String> list = vmParametersList.getList();\n            for (String param : list) {\n              if (!param.trim().startsWith(\"-D\")) {\n                commandLine.addParameter(param);\n              }\n            }\n          }\n          else {\n            commandLine.addParameters(vmParametersList.getList());\n          }\n          try {\n            classpathFile = FileUtil.createTempFile(\"classpath\", null);\n            final PrintWriter writer = new PrintWriter(classpathFile);\n            try {\n              for (String path : javaParameters.getClassPath().getPathList()) {\n                writer.println(path);\n              }\n            }\n            finally {\n              writer.close();\n            }\n\n            String classpath = PathUtil.getJarPathForClass(commandLineWrapper);\n            final String utilRtPath = PathUtil.getJarPathForClass(StringUtilRt.class);\n            if (!classpath.equals(utilRtPath)) {\n              classpath += File.pathSeparator + utilRtPath;\n            }\n            final Class<UrlClassLoader> ourUrlClassLoader = UrlClassLoader.class;\n            if (ourUrlClassLoader.getName().equals(vmParametersList.getPropertyValue(\"java.system.class.loader\"))) {\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(ourUrlClassLoader);\n              classpath += File.pathSeparator + PathUtil.getJarPathForClass(THashMap.class);\n            }\n\n            commandLine.addParameter(\"-classpath\");\n            commandLine.addParameter(classpath);\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n\n        appendEncoding(javaParameters, commandLine, vmParametersList);\n        if (classpathFile != null) {\n          commandLine.addParameter(commandLineWrapper.getName());\n          commandLine.addParameter(classpathFile.getAbsolutePath());\n        }\n\n        if (vmParamsFile != null) {\n          commandLine.addParameter(\"@vm_params\");\n          commandLine.addParameter(vmParamsFile.getAbsolutePath());\n        }\n      }\n      else {\n        appendParamsEncodingClasspath(javaParameters, commandLine, vmParametersList);\n      }\n    }\n    else {\n      appendParamsEncodingClasspath(javaParameters, commandLine, vmParametersList);\n    }\n\n    final String mainClass = javaParameters.getMainClass();\n    String jarPath = javaParameters.getJarPath();\n    if (mainClass != null) {\n      commandLine.addParameter(mainClass);\n    }\n    else if (jarPath != null) {\n      commandLine.addParameter(\"-jar\");\n      commandLine.addParameter(jarPath);\n    }\n\n    commandLine.addParameters(javaParameters.getProgramParametersList().getList());\n\n    commandLine.withWorkDirectory(javaParameters.getWorkingDirectory());\n\n    return commandLine;\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean checkForJdk(final File homePath) {\n    File binPath = new File(homePath.getAbsolutePath() + File.separator + \"bin\");\n    if (!binPath.exists()) return false;\n\n    FileFilter fileFilter = new FileFilter() {\n      @Override\n      @SuppressWarnings({\"HardCodedStringLiteral\"})\n      public boolean accept(File f) {\n        if (f.isDirectory()) return false;\n        return Comparing.strEqual(FileUtil.getNameWithoutExtension(f), \"javac\") ||\n               Comparing.strEqual(FileUtil.getNameWithoutExtension(f), \"javah\");\n      }\n    };\n    File[] children = binPath.listFiles(fileFilter);\n\n    return children != null && children.length >= 2 &&\n           checkForRuntime(homePath.getAbsolutePath());\n  }","id":101537,"modified_method":"public static boolean checkForJdk(@NotNull File homePath) {\n    File binPath = new File(homePath.getAbsolutePath() + File.separator + \"bin\");\n    if (!binPath.exists()) return false;\n\n    FileFilter fileFilter = new FileFilter() {\n      @Override\n      public boolean accept(@NotNull File f) {\n        if (f.isDirectory()) return false;\n        String name = FileUtil.getNameWithoutExtension(f);\n        return \"javac\".equals(name) || \"javah\".equals(name);\n      }\n    };\n    File[] children = binPath.listFiles(fileFilter);\n\n    return children != null && children.length >= 2 &&\n           checkForRuntime(homePath.getAbsolutePath());\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean checkForRuntime(final String homePath) {\n    return new File(new File(new File(homePath, \"jre\"), \"lib\"), \"rt.jar\").exists() ||\n           new File(new File(homePath, \"lib\"), \"rt.jar\").exists() ||\n           new File(new File(new File(homePath, \"..\"), \"Classes\"), \"classes.jar\").exists() ||  // Apple JDK\n           new File(new File(new File(homePath, \"jre\"), \"lib\"), \"vm.jar\").exists() ||  // IBM JDK\n           new File(homePath, \"classes\").isDirectory();  // custom build\n  }","id":101538,"modified_method":"public static boolean checkForRuntime(@NotNull String homePath) {\n    return new File(homePath, \"jre/lib/rt.jar\").exists() ||          // JDK\n           new File(homePath, \"lib/rt.jar\").exists() ||              // JRE\n           new File(homePath, \"../Classes/classes.jar\").exists() ||  // Apple JDK\n           new File(homePath, \"jre/lib/vm.jar\").exists() ||          // IBM JDK\n           new File(homePath, \"classes\").isDirectory();              // custom build\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean checkForJre(String homePath) {\n    homePath = new File(FileUtil.toSystemDependentName(homePath)).getAbsolutePath();\n    File binPath = new File(homePath + File.separator + \"bin\");\n    if (!binPath.exists()) return false;\n\n    FileFilter fileFilter = new FileFilter() {\n      @Override\n      @SuppressWarnings({\"HardCodedStringLiteral\"})\n      public boolean accept(File f) {\n        return !f.isDirectory() && Comparing.strEqual(FileUtil.getNameWithoutExtension(f), \"java\");\n      }\n    };\n    File[] children = binPath.listFiles(fileFilter);\n\n    return children != null && children.length >= 1 &&\n           checkForRuntime(homePath);\n  }","id":101539,"modified_method":"public static boolean checkForJre(@NotNull String homePath) {\n    homePath = new File(FileUtil.toSystemDependentName(homePath)).getAbsolutePath();\n    File binPath = new File(homePath + File.separator + \"bin\");\n    if (!binPath.exists()) return false;\n\n    FileFilter fileFilter = new FileFilter() {\n      @Override\n      public boolean accept(@NotNull File f) {\n        return !f.isDirectory() && \"java\".equals(FileUtil.getNameWithoutExtension(f));\n      }\n    };\n    File[] children = binPath.listFiles(fileFilter);\n\n    return children != null && children.length >= 1 &&\n           checkForRuntime(homePath);\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendEncoding(SimpleJavaParameters javaParameters, GeneralCommandLine commandLine, ParametersList parametersList) {\n    // Value of -Dfile.encoding and charset of GeneralCommandLine should be in sync in order process's input and output be correctly handled.\n    String encoding = parametersList.getPropertyValue(\"file.encoding\");\n    if (encoding == null) {\n      Charset charset = javaParameters.getCharset();\n      if (charset == null) charset = EncodingManager.getInstance().getDefaultCharset();\n      if (charset == null) charset = CharsetToolkit.getDefaultSystemCharset();\n      commandLine.addParameter(\"-Dfile.encoding=\" + charset.name());\n      commandLine.setCharset(charset);\n    }\n    else {\n      try {\n        Charset charset = Charset.forName(encoding);\n        commandLine.setCharset(charset);\n      }\n      catch (UnsupportedCharsetException ignore) {\n      }\n      catch (IllegalCharsetNameException ignore) {\n      }\n    }\n  }","id":101540,"modified_method":"private static void appendEncoding(SimpleJavaParameters javaParameters, GeneralCommandLine commandLine, ParametersList parametersList) {\n    // Value of file.encoding and charset of GeneralCommandLine should be in sync in order process's input and output be correctly handled.\n    String encoding = parametersList.getPropertyValue(\"file.encoding\");\n    if (encoding == null) {\n      Charset charset = javaParameters.getCharset();\n      if (charset == null) charset = EncodingManager.getInstance().getDefaultCharset();\n      if (charset == null) charset = CharsetToolkit.getDefaultSystemCharset();\n      if (charset != null) {\n        commandLine.addParameter(\"-Dfile.encoding=\" + charset.name());\n        commandLine.withCharset(charset);\n      }\n    }\n    else {\n      try {\n        Charset charset = Charset.forName(encoding);\n        commandLine.withCharset(charset);\n      }\n      catch (UnsupportedCharsetException ignore) { }\n      catch (IllegalCharsetNameException ignore) { }\n    }\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return the specified attribute of the JDK (examines rt.jar) or null if cannot determine the value\n   */\n  @Nullable\n  public static String getJdkMainAttribute(@NotNull Sdk jdk, Attributes.Name attribute) {\n    VirtualFile homeDirectory = jdk.getHomeDirectory();\n    if (homeDirectory == null) return null;\n\n    VirtualFile rtJar = homeDirectory.findFileByRelativePath(\"jre/lib/rt.jar\");\n    if (rtJar == null) {\n      rtJar = homeDirectory.findFileByRelativePath(\"lib/rt.jar\");\n    }\n    if (rtJar == null) {\n      rtJar = homeDirectory.findFileByRelativePath(\"jre/lib/vm.jar\"); // for IBM jdk\n    }\n    if (rtJar == null) {\n      rtJar = homeDirectory.findFileByRelativePath(\"../Classes/classes.jar\"); // for mac\n    }\n\n    if (rtJar == null) {\n      String versionString = jdk.getVersionString();\n      if (versionString != null) {\n        final int start = versionString.indexOf(\"\\\"\");\n        final int end = versionString.lastIndexOf(\"\\\"\");\n        versionString = start >= 0 && (end > start)? versionString.substring(start + 1, end) : null;\n      }\n      return versionString;\n    }\n\n    VirtualFile jarRoot = JarFileSystem.getInstance().getJarRootForLocalFile(rtJar);\n    return jarRoot != null ? getJarMainAttribute(jarRoot, attribute) : null;\n  }","id":101541,"modified_method":"/**\n   * @return the specified attribute of the JDK (examines rt.jar) or null if cannot determine the value\n   */\n  @Nullable\n  public static String getJdkMainAttribute(@NotNull Sdk jdk, Attributes.Name attribute) {\n    VirtualFile homeDirectory = jdk.getHomeDirectory();\n    if (homeDirectory == null) return null;\n\n    VirtualFile rtJar = homeDirectory.findFileByRelativePath(\"jre/lib/rt.jar\");                 // JDK\n    if (rtJar == null) rtJar = homeDirectory.findFileByRelativePath(\"lib/rt.jar\");              // JRE\n    if (rtJar == null) rtJar = homeDirectory.findFileByRelativePath(\"jre/lib/vm.jar\");          // IBM JDK\n    if (rtJar == null) rtJar = homeDirectory.findFileByRelativePath(\"../Classes/classes.jar\");  // Apple JDK\n\n    if (rtJar == null) {\n      String versionString = jdk.getVersionString();\n      if (versionString != null) {\n        final int start = versionString.indexOf(\"\\\"\");\n        final int end = versionString.lastIndexOf(\"\\\"\");\n        versionString = start >= 0 && (end > start)? versionString.substring(start + 1, end) : null;\n      }\n      return versionString;\n    }\n\n    VirtualFile jarRoot = JarFileSystem.getInstance().getJarRootForLocalFile(rtJar);\n    return jarRoot != null ? getJarMainAttribute(jarRoot, attribute) : null;\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void createAddActions(DefaultActionGroup group,\n                               final JComponent parent,\n                               final Consumer<Sdk> updateTree,\n                               @Nullable Condition<SdkTypeId> filter) {\n    final SdkType[] types = SdkType.getAllTypes();\n    for (final SdkType type : types) {\n      if (filter != null && !filter.value(type)) continue;\n      final AnAction addAction = new DumbAwareAction(type.getPresentableName(),\n                                              null,\n                                              type.getIconForAddAction()) {\n          @Override\n          public void actionPerformed(AnActionEvent e) {\n            doAdd(parent, type, updateTree);\n          }\n        };\n      group.add(addAction);\n    }\n  }","id":101542,"modified_method":"public void createAddActions(DefaultActionGroup group,\n                               final JComponent parent,\n                               final Consumer<Sdk> updateTree,\n                               @Nullable Condition<SdkTypeId> filter) {\n    final SdkType[] types = SdkType.getAllTypes();\n    for (final SdkType type : types) {\n      if (filter != null && !filter.value(type)) continue;\n      final AnAction addAction = new DumbAwareAction(type.getPresentableName(), null, type.getIconForAddAction()) {\n        @Override\n        public void actionPerformed(@NotNull AnActionEvent e) {\n          doAdd(parent, type, updateTree);\n        }\n      };\n      group.add(addAction);\n    }\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setupSdk(Sdk newJdk, Consumer<Sdk> callback) {\n    String home = newJdk.getHomePath();\n    SdkType sdkType = (SdkType)newJdk.getSdkType();\n    if (!sdkType.setupSdkPaths(newJdk, this)) return;\n\n    if (newJdk.getVersionString() == null) {\n       Messages.showMessageDialog(ProjectBundle.message(\"sdk.java.corrupt.error\", home),\n                                  ProjectBundle.message(\"sdk.java.corrupt.title\"), Messages.getErrorIcon());\n    }\n\n    doAdd(newJdk, callback);\n  }","id":101543,"modified_method":"private void setupSdk(Sdk newJdk, Consumer<Sdk> callback) {\n    String home = newJdk.getHomePath();\n    SdkType sdkType = (SdkType)newJdk.getSdkType();\n    if (!sdkType.setupSdkPaths(newJdk, this)) return;\n\n    if (newJdk.getVersionString() == null) {\n      String message = ProjectBundle.message(\"sdk.java.corrupt.error\", home);\n      Messages.showMessageDialog(message, ProjectBundle.message(\"sdk.java.corrupt.title\"), Messages.getErrorIcon());\n    }\n\n    doAdd(newJdk, callback);\n  }","commit_id":"1232d9e230fcd164284612dce09391d9d1092868","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Main application Startup\n     * @param argArray Command-line arguments\n     */\n    public static void main(final String[] argArray) {\n        I18n.init();\n        Main.checkJavaVersion();\n\n        // construct argument table\n        Map<Option, Collection<String>> args = null;\n        try {\n            args = buildCommandLineArgumentMap(argArray);\n        } catch (IllegalArgumentException e) {\n            System.exit(1);\n            return;\n        }\n\n        final boolean languageGiven = args.containsKey(Option.LANGUAGE);\n\n        if (languageGiven) {\n            I18n.set(args.get(Option.LANGUAGE).iterator().next());\n        }\n\n        initApplicationPreferences();\n\n        Policy.setPolicy(new Policy() {\n            // Permissions for plug-ins loaded when josm is started via webstart\n            private PermissionCollection pc;\n\n            {\n                pc = new Permissions();\n                pc.add(new AllPermission());\n            }\n\n            @Override\n            public void refresh() { }\n\n            @Override\n            public PermissionCollection getPermissions(CodeSource codesource) {\n                return pc;\n            }\n        });\n\n        Thread.setDefaultUncaughtExceptionHandler(new BugReportExceptionHandler());\n\n        // initialize the platform hook, and\n        Main.determinePlatformHook();\n        // call the really early hook before we do anything else\n        Main.platform.preStartupHook();\n\n        Main.commandLineArgs = Utils.copyArray(argArray);\n\n        if (args.containsKey(Option.VERSION)) {\n            System.out.println(Version.getInstance().getAgentString());\n            System.exit(0);\n        }\n\n        if (args.containsKey(Option.DEBUG) || args.containsKey(Option.TRACE)) {\n            // Enable JOSM debug level\n            logLevel = 4;\n            Main.info(tr(\"Printing debugging messages to console\"));\n        }\n\n        if (args.containsKey(Option.TRACE)) {\n            // Enable JOSM debug level\n            logLevel = 5;\n            // Enable debug in OAuth signpost via system preference, but only at trace level\n            Utils.updateSystemProperty(\"debug\", \"true\");\n            Main.info(tr(\"Enabled detailed debug level (trace)\"));\n        }\n\n        Main.pref.init(args.containsKey(Option.RESET_PREFERENCES));\n\n        if (!languageGiven) {\n            I18n.set(Main.pref.get(\"language\", null));\n        }\n        Main.pref.updateSystemProperties();\n\n        // asking for help? show help and exit\n        if (args.containsKey(Option.HELP)) {\n            showHelp();\n            System.exit(0);\n        }\n\n        processOffline(args);\n\n        Main.platform.afterPrefStartupHook();\n\n        FontsManager.initialize();\n\n        handleSpecialLanguages();\n\n        final JFrame mainFrame = new JFrame(tr(\"Java OpenStreetMap Editor\"));\n        Main.parent = mainFrame;\n\n        if (args.containsKey(Option.LOAD_PREFERENCES)) {\n            CustomConfigurator.XMLCommandProcessor config = new CustomConfigurator.XMLCommandProcessor(Main.pref);\n            for (String i : args.get(Option.LOAD_PREFERENCES)) {\n                info(\"Reading preferences from \" + i);\n                try (InputStream is = Utils.openURL(new URL(i))) {\n                    config.openAndReadXML(is);\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }\n\n        if (args.containsKey(Option.SET)) {\n            for (String i : args.get(Option.SET)) {\n                String[] kv = i.split(\"=\", 2);\n                Main.pref.put(kv[0], \"null\".equals(kv[1]) ? null : kv[1]);\n            }\n        }\n\n        DefaultAuthenticator.createInstance();\n        Authenticator.setDefault(DefaultAuthenticator.getInstance());\n        DefaultProxySelector proxySelector = new DefaultProxySelector(ProxySelector.getDefault());\n        ProxySelector.setDefault(proxySelector);\n        OAuthAccessTokenHolder.getInstance().init(Main.pref, CredentialsManager.getInstance());\n\n        final SplashScreen splash = new SplashScreen();\n        final ProgressMonitor monitor = splash.getProgressMonitor();\n        monitor.beginTask(tr(\"Initializing\"));\n        splash.setVisible(Main.pref.getBoolean(\"draw.splashscreen\", true));\n        Main.setInitStatusListener(new InitStatusListener() {\n\n            @Override\n            public void updateStatus(String event) {\n                monitor.indeterminateSubTask(event);\n            }\n        });\n\n        Collection<PluginInformation> pluginsToLoad = PluginHandler.buildListOfPluginsToLoad(splash, monitor.createSubTaskMonitor(1, false));\n        if (!pluginsToLoad.isEmpty() && PluginHandler.checkAndConfirmPluginUpdate(splash)) {\n            monitor.subTask(tr(\"Updating plugins\"));\n            pluginsToLoad = PluginHandler.updatePlugins(splash, null, monitor.createSubTaskMonitor(1, false), false);\n        }\n\n        monitor.indeterminateSubTask(tr(\"Installing updated plugins\"));\n        PluginHandler.installDownloadedPlugins(true);\n\n        monitor.indeterminateSubTask(tr(\"Loading early plugins\"));\n        PluginHandler.loadEarlyPlugins(splash, pluginsToLoad, monitor.createSubTaskMonitor(1, false));\n\n        monitor.indeterminateSubTask(tr(\"Setting defaults\"));\n        preConstructorInit(args);\n\n        monitor.indeterminateSubTask(tr(\"Creating main GUI\"));\n        final Main main = new MainApplication(mainFrame);\n\n        monitor.indeterminateSubTask(tr(\"Loading plugins\"));\n        PluginHandler.loadLatePlugins(splash, pluginsToLoad,  monitor.createSubTaskMonitor(1, false));\n        toolbar.refreshToolbarControl();\n\n        // Wait for splash disappearance (fix #9714)\n        GuiHelper.runInEDTAndWait(new Runnable() {\n            @Override\n            public void run() {\n                splash.setVisible(false);\n                splash.dispose();\n                mainFrame.setVisible(true);\n                main.gettingStarted.requestFocusInWindow();\n            }\n        });\n\n        Main.MasterWindowListener.setup();\n\n        boolean maximized = Main.pref.getBoolean(\"gui.maximized\", false);\n        if ((!args.containsKey(Option.NO_MAXIMIZE) && maximized) || args.containsKey(Option.MAXIMIZE)) {\n            if (Toolkit.getDefaultToolkit().isFrameStateSupported(JFrame.MAXIMIZED_BOTH)) {\n                Main.windowState = JFrame.MAXIMIZED_BOTH;\n                mainFrame.setExtendedState(Main.windowState);\n            } else {\n                Main.debug(\"Main window: maximizing not supported\");\n            }\n        }\n        if (main.menu.fullscreenToggleAction != null) {\n            main.menu.fullscreenToggleAction.initial();\n        }\n\n        SwingUtilities.invokeLater(new GuiFinalizationWorker(args, proxySelector));\n\n        if (Main.isPlatformWindows()) {\n            try {\n                // Check for insecure certificates to remove.\n                // This is Windows-dependant code but it can't go to preStartupHook (need i18n) neither startupHook (need to be called before remote control)\n                PlatformHookWindows.removeInsecureCertificates();\n            } catch (NoSuchAlgorithmException | CertificateException | KeyStoreException | IOException e) {\n                error(e);\n            }\n        }\n\n        if (RemoteControl.PROP_REMOTECONTROL_ENABLED.get()) {\n            RemoteControl.start();\n        }\n\n        if (MessageNotifier.PROP_NOTIFIER_ENABLED.get()) {\n            MessageNotifier.start();\n        }\n\n        if (Main.pref.getBoolean(\"debug.edt-checker.enable\", Version.getInstance().isLocalBuild())) {\n            // Repaint manager is registered so late for a reason - there is lots of violation during startup process but they don't seem to break anything and are difficult to fix\n            info(\"Enabled EDT checker, wrongful access to gui from non EDT thread will be printed to console\");\n            RepaintManager.setCurrentManager(new CheckThreadViolationRepaintManager());\n        }\n    }","id":101544,"modified_method":"/**\n     * Main application Startup\n     * @param argArray Command-line arguments\n     */\n    public static void main(final String[] argArray) {\n        I18n.init();\n        Main.checkJavaVersion();\n\n        // construct argument table\n        Map<Option, Collection<String>> args = null;\n        try {\n            args = buildCommandLineArgumentMap(argArray);\n        } catch (IllegalArgumentException e) {\n            System.exit(1);\n            return;\n        }\n\n        final boolean languageGiven = args.containsKey(Option.LANGUAGE);\n\n        if (languageGiven) {\n            I18n.set(args.get(Option.LANGUAGE).iterator().next());\n        }\n\n        initApplicationPreferences();\n\n        Policy.setPolicy(new Policy() {\n            // Permissions for plug-ins loaded when josm is started via webstart\n            private PermissionCollection pc;\n\n            {\n                pc = new Permissions();\n                pc.add(new AllPermission());\n            }\n\n            @Override\n            public void refresh() { }\n\n            @Override\n            public PermissionCollection getPermissions(CodeSource codesource) {\n                return pc;\n            }\n        });\n\n        Thread.setDefaultUncaughtExceptionHandler(new BugReportExceptionHandler());\n\n        // initialize the platform hook, and\n        Main.determinePlatformHook();\n        // call the really early hook before we do anything else\n        Main.platform.preStartupHook();\n\n        Main.commandLineArgs = Utils.copyArray(argArray);\n\n        if (args.containsKey(Option.VERSION)) {\n            System.out.println(Version.getInstance().getAgentString());\n            System.exit(0);\n        }\n\n        if (args.containsKey(Option.DEBUG) || args.containsKey(Option.TRACE)) {\n            // Enable JOSM debug level\n            logLevel = 4;\n            Main.info(tr(\"Printing debugging messages to console\"));\n        }\n\n        Boolean skipLoadingPlugins = false;\n        if (args.containsKey(Option.SKIP_PLUGINS)) {\n            skipLoadingPlugins = true;\n            Main.info(tr(\"Plugins loaded skipped\"));\n        }\n\n        if (args.containsKey(Option.TRACE)) {\n            // Enable JOSM debug level\n            logLevel = 5;\n            // Enable debug in OAuth signpost via system preference, but only at trace level\n            Utils.updateSystemProperty(\"debug\", \"true\");\n            Main.info(tr(\"Enabled detailed debug level (trace)\"));\n        }\n\n        Main.pref.init(args.containsKey(Option.RESET_PREFERENCES));\n\n        if (!languageGiven) {\n            I18n.set(Main.pref.get(\"language\", null));\n        }\n        Main.pref.updateSystemProperties();\n\n        // asking for help? show help and exit\n        if (args.containsKey(Option.HELP)) {\n            showHelp();\n            System.exit(0);\n        }\n\n        processOffline(args);\n\n        Main.platform.afterPrefStartupHook();\n\n        FontsManager.initialize();\n\n        handleSpecialLanguages();\n\n        final JFrame mainFrame = new JFrame(tr(\"Java OpenStreetMap Editor\"));\n        Main.parent = mainFrame;\n\n        if (args.containsKey(Option.LOAD_PREFERENCES)) {\n            CustomConfigurator.XMLCommandProcessor config = new CustomConfigurator.XMLCommandProcessor(Main.pref);\n            for (String i : args.get(Option.LOAD_PREFERENCES)) {\n                info(\"Reading preferences from \" + i);\n                try (InputStream is = Utils.openURL(new URL(i))) {\n                    config.openAndReadXML(is);\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }\n\n        if (args.containsKey(Option.SET)) {\n            for (String i : args.get(Option.SET)) {\n                String[] kv = i.split(\"=\", 2);\n                Main.pref.put(kv[0], \"null\".equals(kv[1]) ? null : kv[1]);\n            }\n        }\n\n        DefaultAuthenticator.createInstance();\n        Authenticator.setDefault(DefaultAuthenticator.getInstance());\n        DefaultProxySelector proxySelector = new DefaultProxySelector(ProxySelector.getDefault());\n        ProxySelector.setDefault(proxySelector);\n        OAuthAccessTokenHolder.getInstance().init(Main.pref, CredentialsManager.getInstance());\n\n        final SplashScreen splash = new SplashScreen();\n        final ProgressMonitor monitor = splash.getProgressMonitor();\n        monitor.beginTask(tr(\"Initializing\"));\n        splash.setVisible(Main.pref.getBoolean(\"draw.splashscreen\", true));\n        Main.setInitStatusListener(new InitStatusListener() {\n\n            @Override\n            public void updateStatus(String event) {\n                monitor.indeterminateSubTask(event);\n            }\n        });\n\n        Collection<PluginInformation> pluginsToLoad = null;\n\n\n        if (!skipLoadingPlugins) {\n            pluginsToLoad = PluginHandler.buildListOfPluginsToLoad(splash, monitor.createSubTaskMonitor(1, false));\n            if (!pluginsToLoad.isEmpty() && PluginHandler.checkAndConfirmPluginUpdate(splash)) {\n                monitor.subTask(tr(\"Updating plugins\"));\n                pluginsToLoad = PluginHandler.updatePlugins(splash, null, monitor.createSubTaskMonitor(1, false), false);\n            }\n\n            monitor.indeterminateSubTask(tr(\"Installing updated plugins\"));\n            PluginHandler.installDownloadedPlugins(true);\n\n            monitor.indeterminateSubTask(tr(\"Loading early plugins\"));\n            PluginHandler.loadEarlyPlugins(splash, pluginsToLoad, monitor.createSubTaskMonitor(1, false));\n        }\n\n        monitor.indeterminateSubTask(tr(\"Setting defaults\"));\n        preConstructorInit(args);\n\n        monitor.indeterminateSubTask(tr(\"Creating main GUI\"));\n        final Main main = new MainApplication(mainFrame);\n\n        if (!skipLoadingPlugins) {\n            monitor.indeterminateSubTask(tr(\"Loading plugins\"));\n            PluginHandler.loadLatePlugins(splash, pluginsToLoad,  monitor.createSubTaskMonitor(1, false));\n            toolbar.refreshToolbarControl();\n        }\n\n        // Wait for splash disappearance (fix #9714)\n        GuiHelper.runInEDTAndWait(new Runnable() {\n            @Override\n            public void run() {\n                splash.setVisible(false);\n                splash.dispose();\n                mainFrame.setVisible(true);\n                main.gettingStarted.requestFocusInWindow();\n            }\n        });\n\n        Main.MasterWindowListener.setup();\n\n        boolean maximized = Main.pref.getBoolean(\"gui.maximized\", false);\n        if ((!args.containsKey(Option.NO_MAXIMIZE) && maximized) || args.containsKey(Option.MAXIMIZE)) {\n            if (Toolkit.getDefaultToolkit().isFrameStateSupported(JFrame.MAXIMIZED_BOTH)) {\n                Main.windowState = JFrame.MAXIMIZED_BOTH;\n                mainFrame.setExtendedState(Main.windowState);\n            } else {\n                Main.debug(\"Main window: maximizing not supported\");\n            }\n        }\n        if (main.menu.fullscreenToggleAction != null) {\n            main.menu.fullscreenToggleAction.initial();\n        }\n\n        SwingUtilities.invokeLater(new GuiFinalizationWorker(args, proxySelector));\n\n        if (Main.isPlatformWindows()) {\n            try {\n                // Check for insecure certificates to remove.\n                // This is Windows-dependant code but it can't go to preStartupHook (need i18n) neither startupHook (need to be called before remote control)\n                PlatformHookWindows.removeInsecureCertificates();\n            } catch (NoSuchAlgorithmException | CertificateException | KeyStoreException | IOException e) {\n                error(e);\n            }\n        }\n\n        if (RemoteControl.PROP_REMOTECONTROL_ENABLED.get()) {\n            RemoteControl.start();\n        }\n\n        if (MessageNotifier.PROP_NOTIFIER_ENABLED.get()) {\n            MessageNotifier.start();\n        }\n\n        if (Main.pref.getBoolean(\"debug.edt-checker.enable\", Version.getInstance().isLocalBuild())) {\n            // Repaint manager is registered so late for a reason - there is lots of violation during startup process but they don't seem to break anything and are difficult to fix\n            info(\"Enabled EDT checker, wrongful access to gui from non EDT thread will be printed to console\");\n            RepaintManager.setCurrentManager(new CheckThreadViolationRepaintManager());\n        }\n    }","commit_id":"afcd50f7fd48454f76ca6acef8aa1d480086a44c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Displays help on the console\n     * @since 2748\n     */\n    public static void showHelp() {\n        // TODO: put in a platformHook for system that have no console by default\n        System.out.println(tr(\"Java OpenStreetMap Editor\")+\" [\"\n                +Version.getInstance().getAgentString()+\"]\\n\\n\"+\n                tr(\"usage\")+\":\\n\"+\n                \"\\tjava -jar josm.jar <options>...\\n\\n\"+\n                tr(\"options\")+\":\\n\"+\n                \"\\t--help|-h                                 \"+tr(\"Show this help\")+\"\\n\"+\n                \"\\t--geometry=widthxheight(+|-)x(+|-)y       \"+tr(\"Standard unix geometry argument\")+\"\\n\"+\n                \"\\t[--download=]minlat,minlon,maxlat,maxlon  \"+tr(\"Download the bounding box\")+\"\\n\"+\n                \"\\t[--download=]<URL>                        \"+tr(\"Download the location at the URL (with lat=x&lon=y&zoom=z)\")+\"\\n\"+\n                \"\\t[--download=]<filename>                   \"+tr(\"Open a file (any file type that can be opened with File/Open)\")+\"\\n\"+\n                \"\\t--downloadgps=minlat,minlon,maxlat,maxlon \"+tr(\"Download the bounding box as raw GPS\")+\"\\n\"+\n                \"\\t--downloadgps=<URL>                       \"+tr(\"Download the location at the URL (with lat=x&lon=y&zoom=z) as raw GPS\")+\"\\n\"+\n                \"\\t--selection=<searchstring>                \"+tr(\"Select with the given search\")+\"\\n\"+\n                \"\\t--[no-]maximize                           \"+tr(\"Launch in maximized mode\")+\"\\n\"+\n                \"\\t--reset-preferences                       \"+tr(\"Reset the preferences to default\")+\"\\n\\n\"+\n                \"\\t--load-preferences=<url-to-xml>           \"+tr(\"Changes preferences according to the XML file\")+\"\\n\\n\"+\n                \"\\t--set=<key>=<value>                       \"+tr(\"Set preference key to value\")+\"\\n\\n\"+\n                \"\\t--language=<language>                     \"+tr(\"Set the language\")+\"\\n\\n\"+\n                \"\\t--version                                 \"+tr(\"Displays the JOSM version and exits\")+\"\\n\\n\"+\n                \"\\t--debug                                   \"+tr(\"Print debugging messages to console\")+\"\\n\\n\"+\n                \"\\t--offline=<osm_api|josm_website|all>      \"+tr(\"Disable access to the given resource(s), separated by comma\")+\"\\n\\n\"+\n                tr(\"options provided as Java system properties\")+\":\\n\"+\n                \"\\t-Djosm.pref=\"    +tr(\"/PATH/TO/JOSM/PREF    \")+tr(\"Set the preferences directory\")+\"\\n\\n\"+\n                \"\\t-Djosm.userdata=\"+tr(\"/PATH/TO/JOSM/USERDATA\")+tr(\"Set the user data directory\")+\"\\n\\n\"+\n                \"\\t-Djosm.cache=\"   +tr(\"/PATH/TO/JOSM/CACHE   \")+tr(\"Set the cache directory\")+\"\\n\\n\"+\n                \"\\t-Djosm.home=\"    +tr(\"/PATH/TO/JOSM/HOMEDIR \")+\n                tr(\"Relocate all 3 directories to homedir. Cache directory will be in homedir/cache\")+\"\\n\\n\"+\n                tr(\"-Djosm.home has lower precedence, i.e. the specific setting overrides the general one\")+\"\\n\\n\"+\n                tr(\"note: For some tasks, JOSM needs a lot of memory. It can be necessary to add the following\\n\" +\n                        \"      Java option to specify the maximum size of allocated memory in megabytes\")+\":\\n\"+\n                        \"\\t-Xmx...m\\n\\n\"+\n                        tr(\"examples\")+\":\\n\"+\n                        \"\\tjava -jar josm.jar track1.gpx track2.gpx london.osm\\n\"+\n                        \"\\tjava -jar josm.jar \"+OsmUrlToBounds.getURL(43.2, 11.1, 13)+\"\\n\"+\n                        \"\\tjava -jar josm.jar london.osm --selection=http://www.ostertag.name/osm/OSM_errors_node-duplicate.xml\\n\"+\n                        \"\\tjava -jar josm.jar 43.2,11.1,43.4,11.4\\n\"+\n                        \"\\tjava -Djosm.pref=$XDG_CONFIG_HOME -Djosm.userdata=$XDG_DATA_HOME -Djosm.cache=$XDG_CACHE_HOME -jar josm.jar\\n\"+\n                        \"\\tjava -Djosm.home=/home/user/.josm_dev -jar josm.jar\\n\"+\n                        \"\\tjava -Xmx1024m -jar josm.jar\\n\\n\"+\n                        tr(\"Parameters --download, --downloadgps, and --selection are processed in this order.\")+\"\\n\"+\n                        tr(\"Make sure you load some data if you use --selection.\")+\"\\n\"\n                );\n    }","id":101545,"modified_method":"/**\n     * Displays help on the console\n     * @since 2748\n     */\n    public static void showHelp() {\n        // TODO: put in a platformHook for system that have no console by default\n        System.out.println(tr(\"Java OpenStreetMap Editor\")+\" [\"\n                +Version.getInstance().getAgentString()+\"]\\n\\n\"+\n                tr(\"usage\")+\":\\n\"+\n                \"\\tjava -jar josm.jar <options>...\\n\\n\"+\n                tr(\"options\")+\":\\n\"+\n                \"\\t--help|-h                                 \"+tr(\"Show this help\")+\"\\n\"+\n                \"\\t--geometry=widthxheight(+|-)x(+|-)y       \"+tr(\"Standard unix geometry argument\")+\"\\n\"+\n                \"\\t[--download=]minlat,minlon,maxlat,maxlon  \"+tr(\"Download the bounding box\")+\"\\n\"+\n                \"\\t[--download=]<URL>                        \"+tr(\"Download the location at the URL (with lat=x&lon=y&zoom=z)\")+\"\\n\"+\n                \"\\t[--download=]<filename>                   \"+tr(\"Open a file (any file type that can be opened with File/Open)\")+\"\\n\"+\n                \"\\t--downloadgps=minlat,minlon,maxlat,maxlon \"+tr(\"Download the bounding box as raw GPS\")+\"\\n\"+\n                \"\\t--downloadgps=<URL>                       \"+tr(\"Download the location at the URL (with lat=x&lon=y&zoom=z) as raw GPS\")+\"\\n\"+\n                \"\\t--selection=<searchstring>                \"+tr(\"Select with the given search\")+\"\\n\"+\n                \"\\t--[no-]maximize                           \"+tr(\"Launch in maximized mode\")+\"\\n\"+\n                \"\\t--reset-preferences                       \"+tr(\"Reset the preferences to default\")+\"\\n\\n\"+\n                \"\\t--load-preferences=<url-to-xml>           \"+tr(\"Changes preferences according to the XML file\")+\"\\n\\n\"+\n                \"\\t--set=<key>=<value>                       \"+tr(\"Set preference key to value\")+\"\\n\\n\"+\n                \"\\t--language=<language>                     \"+tr(\"Set the language\")+\"\\n\\n\"+\n                \"\\t--version                                 \"+tr(\"Displays the JOSM version and exits\")+\"\\n\\n\"+\n                \"\\t--debug                                   \"+tr(\"Print debugging messages to console\")+\"\\n\\n\"+\n                \"\\t--skip-plugins                            \"+tr(\"Skip loading plugins\")+\"\\n\\n\"+\n                \"\\t--offline=<osm_api|josm_website|all>      \"+tr(\"Disable access to the given resource(s), separated by comma\")+\"\\n\\n\"+\n                tr(\"options provided as Java system properties\")+\":\\n\"+\n                \"\\t-Djosm.pref=\"    +tr(\"/PATH/TO/JOSM/PREF    \")+tr(\"Set the preferences directory\")+\"\\n\\n\"+\n                \"\\t-Djosm.userdata=\"+tr(\"/PATH/TO/JOSM/USERDATA\")+tr(\"Set the user data directory\")+\"\\n\\n\"+\n                \"\\t-Djosm.cache=\"   +tr(\"/PATH/TO/JOSM/CACHE   \")+tr(\"Set the cache directory\")+\"\\n\\n\"+\n                \"\\t-Djosm.home=\"    +tr(\"/PATH/TO/JOSM/HOMEDIR \")+\n                tr(\"Relocate all 3 directories to homedir. Cache directory will be in homedir/cache\")+\"\\n\\n\"+\n                tr(\"-Djosm.home has lower precedence, i.e. the specific setting overrides the general one\")+\"\\n\\n\"+\n                tr(\"note: For some tasks, JOSM needs a lot of memory. It can be necessary to add the following\\n\" +\n                        \"      Java option to specify the maximum size of allocated memory in megabytes\")+\":\\n\"+\n                        \"\\t-Xmx...m\\n\\n\"+\n                        tr(\"examples\")+\":\\n\"+\n                        \"\\tjava -jar josm.jar track1.gpx track2.gpx london.osm\\n\"+\n                        \"\\tjava -jar josm.jar \"+OsmUrlToBounds.getURL(43.2, 11.1, 13)+\"\\n\"+\n                        \"\\tjava -jar josm.jar london.osm --selection=http://www.ostertag.name/osm/OSM_errors_node-duplicate.xml\\n\"+\n                        \"\\tjava -jar josm.jar 43.2,11.1,43.4,11.4\\n\"+\n                        \"\\tjava -Djosm.pref=$XDG_CONFIG_HOME -Djosm.userdata=$XDG_DATA_HOME -Djosm.cache=$XDG_CACHE_HOME -jar josm.jar\\n\"+\n                        \"\\tjava -Djosm.home=/home/user/.josm_dev -jar josm.jar\\n\"+\n                        \"\\tjava -Xmx1024m -jar josm.jar\\n\\n\"+\n                        tr(\"Parameters --download, --downloadgps, and --selection are processed in this order.\")+\"\\n\"+\n                        tr(\"Make sure you load some data if you use --selection.\")+\"\\n\"\n                );\n    }","commit_id":"afcd50f7fd48454f76ca6acef8aa1d480086a44c","url":"https://github.com/openstreetmap/josm"},{"original_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tagame exists but wasn't found\", ex);\n                }\n            } catch (IllegalStateException ex) {\n                Logger.getLogger(DrawableTagsManager.class.getName()).log(Level.SEVERE, \"Case was closed out from underneath\", ex);\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","id":101546,"modified_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tagame exists but wasn't found\", ex);\n                }\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.SEVERE, \"Case was closed out from underneath\", ex);\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","commit_id":"3e45191012bfa9fc28b29870fdf479106440e6e1","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public Collection<TagName> getNonCategoryTagNames() {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                return autopsyTagsManager.getAllTagNames().stream()\n                        .filter(CategoryManager::isCategoryTagName)\n                        .collect(Collectors.toSet());\n            } catch (TskCoreException | IllegalStateException ex) {\n                Logger.getLogger(DrawableTagsManager.class.getName()).log(Level.WARNING, \"couldn't access case\", ex);\n            }\n            return Collections.emptySet();\n        }\n    }","id":101547,"modified_method":"public Collection<TagName> getNonCategoryTagNames() {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                return autopsyTagsManager.getAllTagNames().stream()\n                        .filter(CategoryManager::isCategoryTagName)\n                        .collect(Collectors.toSet());\n            } catch (TskCoreException | IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"couldn't access case\", ex);\n            }\n            return Collections.emptySet();\n        }\n    }","commit_id":"3e45191012bfa9fc28b29870fdf479106440e6e1","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.TAGS) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        } else if (groupBy == DrawableAttribute.CATEGORY) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        }\n        final long fileID = evt.getTag().getContent().getId();\n        DrawableGroup g = getGroupForKey(groupKey);\n        addFileToGroup(g, groupKey, fileID);\n\n    }","id":101548,"modified_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.CATEGORY && CategoryManager.isCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        } else if (groupBy == DrawableAttribute.TAGS && CategoryManager.isNotCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        }\n        if (groupKey != null) {\n            final long fileID = evt.getTag().getContent().getId();\n            DrawableGroup g = getGroupForKey(groupKey);\n            addFileToGroup(g, groupKey, fileID);\n        }\n    }","commit_id":"3e45191012bfa9fc28b29870fdf479106440e6e1","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.TAGS) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        } else if (groupBy == DrawableAttribute.CATEGORY) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        }\n        final long fileID = evt.getTag().getContent().getId();\n        DrawableGroup g = removeFromGroup(groupKey, fileID);\n    }","id":101549,"modified_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.CATEGORY && CategoryManager.isCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        } else if (groupBy == DrawableAttribute.TAGS && CategoryManager.isNotCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        }\n\n        if (groupKey != null) {\n            final long fileID = evt.getTag().getContent().getId();\n            DrawableGroup g = removeFromGroup(groupKey, fileID);\n        }\n    }","commit_id":"3e45191012bfa9fc28b29870fdf479106440e6e1","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tagame exists but wasn't found\", ex);\n                }\n            } catch (IllegalStateException ex) {\n                Logger.getLogger(DrawableTagsManager.class.getName()).log(Level.SEVERE, \"Case was closed out from underneath\", ex);\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","id":101550,"modified_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tagame exists but wasn't found\", ex);\n                }\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.SEVERE, \"Case was closed out from underneath\", ex);\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","commit_id":"1c16f9e4051471fe4f1fa75eada839f722b6a46d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public Collection<TagName> getNonCategoryTagNames() {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                return autopsyTagsManager.getAllTagNames().stream()\n                        .filter(CategoryManager::isCategoryTagName)\n                        .collect(Collectors.toSet());\n            } catch (TskCoreException | IllegalStateException ex) {\n                Logger.getLogger(DrawableTagsManager.class.getName()).log(Level.WARNING, \"couldn't access case\", ex);\n            }\n            return Collections.emptySet();\n        }\n    }","id":101551,"modified_method":"public Collection<TagName> getNonCategoryTagNames() {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                return autopsyTagsManager.getAllTagNames().stream()\n                        .filter(CategoryManager::isCategoryTagName)\n                        .collect(Collectors.toSet());\n            } catch (TskCoreException | IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"couldn't access case\", ex);\n            }\n            return Collections.emptySet();\n        }\n    }","commit_id":"1c16f9e4051471fe4f1fa75eada839f722b6a46d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.TAGS) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        } else if (groupBy == DrawableAttribute.CATEGORY) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        }\n        final long fileID = evt.getTag().getContent().getId();\n        DrawableGroup g = getGroupForKey(groupKey);\n        addFileToGroup(g, groupKey, fileID);\n\n    }","id":101552,"modified_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.CATEGORY && CategoryManager.isCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        } else if (groupBy == DrawableAttribute.TAGS && CategoryManager.isNotCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        }\n        if (groupKey != null) {\n            final long fileID = evt.getTag().getContent().getId();\n            DrawableGroup g = getGroupForKey(groupKey);\n            addFileToGroup(g, groupKey, fileID);\n        }\n    }","commit_id":"1c16f9e4051471fe4f1fa75eada839f722b6a46d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.TAGS) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        } else if (groupBy == DrawableAttribute.CATEGORY) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        }\n        final long fileID = evt.getTag().getContent().getId();\n        DrawableGroup g = removeFromGroup(groupKey, fileID);\n    }","id":101553,"modified_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.CATEGORY && CategoryManager.isCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        } else if (groupBy == DrawableAttribute.TAGS && CategoryManager.isNotCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        }\n\n        if (groupKey != null) {\n            final long fileID = evt.getTag().getContent().getId();\n            DrawableGroup g = removeFromGroup(groupKey, fileID);\n        }\n    }","commit_id":"1c16f9e4051471fe4f1fa75eada839f722b6a46d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tagame exists but wasn't found\", ex);\n                }\n            } catch (IllegalStateException ex) {\n                Logger.getLogger(DrawableTagsManager.class.getName()).log(Level.SEVERE, \"Case was closed out from underneath\", ex);\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","id":101554,"modified_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tagame exists but wasn't found\", ex);\n                }\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.SEVERE, \"Case was closed out from underneath\", ex);\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","commit_id":"ad39755fe4750dc6c7eb31e2b8b1c200d3e48008","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public Collection<TagName> getNonCategoryTagNames() {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                return autopsyTagsManager.getAllTagNames().stream()\n                        .filter(CategoryManager::isCategoryTagName)\n                        .collect(Collectors.toSet());\n            } catch (TskCoreException | IllegalStateException ex) {\n                Logger.getLogger(DrawableTagsManager.class.getName()).log(Level.WARNING, \"couldn't access case\", ex);\n            }\n            return Collections.emptySet();\n        }\n    }","id":101555,"modified_method":"public Collection<TagName> getNonCategoryTagNames() {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                return autopsyTagsManager.getAllTagNames().stream()\n                        .filter(CategoryManager::isCategoryTagName)\n                        .collect(Collectors.toSet());\n            } catch (TskCoreException | IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"couldn't access case\", ex);\n            }\n            return Collections.emptySet();\n        }\n    }","commit_id":"ad39755fe4750dc6c7eb31e2b8b1c200d3e48008","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.TAGS) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        } else if (groupBy == DrawableAttribute.CATEGORY) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        }\n        final long fileID = evt.getTag().getContent().getId();\n        DrawableGroup g = getGroupForKey(groupKey);\n        addFileToGroup(g, groupKey, fileID);\n\n    }","id":101556,"modified_method":"@Subscribe\n    public void handleTagAdded(ContentTagAddedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.CATEGORY && CategoryManager.isCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        } else if (groupBy == DrawableAttribute.TAGS && CategoryManager.isNotCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        }\n        if (groupKey != null) {\n            final long fileID = evt.getTag().getContent().getId();\n            DrawableGroup g = getGroupForKey(groupKey);\n            addFileToGroup(g, groupKey, fileID);\n        }\n    }","commit_id":"ad39755fe4750dc6c7eb31e2b8b1c200d3e48008","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.TAGS) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        } else if (groupBy == DrawableAttribute.CATEGORY) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        }\n        final long fileID = evt.getTag().getContent().getId();\n        DrawableGroup g = removeFromGroup(groupKey, fileID);\n    }","id":101557,"modified_method":"@Subscribe\n    public void handleTagDeleted(ContentTagDeletedEvent evt) {\n        GroupKey<?> groupKey = null;\n        if (groupBy == DrawableAttribute.CATEGORY && CategoryManager.isCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<Category>(DrawableAttribute.CATEGORY, CategoryManager.categoryFromTagName(evt.getTag().getName()));\n        } else if (groupBy == DrawableAttribute.TAGS && CategoryManager.isNotCategoryTagName(evt.getTag().getName())) {\n            groupKey = new GroupKey<TagName>(DrawableAttribute.TAGS, evt.getTag().getName());\n        }\n\n        if (groupKey != null) {\n            final long fileID = evt.getTag().getContent().getId();\n            DrawableGroup g = removeFromGroup(groupKey, fileID);\n        }\n    }","commit_id":"ad39755fe4750dc6c7eb31e2b8b1c200d3e48008","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n     \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    iface, satisfiedType);\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (Strategy.onlyOnCompanion(member)) {\n                // non-shared interface methods don't need implementing\n                // (they're just private methods on the $impl)\n                continue;\n            }\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(method, Collections.<ProducedType>emptyList());\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()\n                                || param.isSequenced()) {\n                            final ProducedTypedReference typedParameter = typedMember.getTypedParameter(param);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface,\n                                    typedParameter,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            \n                            final JCMethodDecl overload = makeDelegateToCompanion(iface,\n                                    typedMember,\n                                    PUBLIC | FINAL, \n                                    typeParameters,  \n                                    typedMember.getType(), \n                                    method.getName(), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(overload);\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    \n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            typedMember,\n                            PUBLIC, \n                            method.getTypeParameters(), \n                            method.getType(), \n                            method.getName(), \n                            method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter) {// Concrete getter\n                Getter getter = (Getter)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(getter, null);\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                            typedMember,\n                            PUBLIC | (getter.isDefault() ? 0 : FINAL), \n                            Collections.<TypeParameter>emptyList(), \n                            getter.getType(), \n                            CodegenUtil.getGetterName(member), \n                            Collections.<Parameter>emptyList(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(getterDelegate);\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getName() + \" \" + member.getClass());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            sat = satisfiedType.getSupertype(sat.getDeclaration());\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","id":101558,"modified_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n     \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    model,\n                    iface, satisfiedType);\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (Strategy.onlyOnCompanion(member)) {\n                // non-shared interface methods don't need implementing\n                // (they're just private methods on the $impl)\n                continue;\n            }\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(method, Collections.<ProducedType>emptyList());\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()\n                                || param.isSequenced()) {\n                            final ProducedTypedReference typedParameter = typedMember.getTypedParameter(param);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface,\n                                    typedParameter,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            \n                            final JCMethodDecl overload = makeDelegateToCompanion(iface,\n                                    typedMember,\n                                    PUBLIC | FINAL, \n                                    typeParameters,  \n                                    typedMember.getType(), \n                                    method.getName(), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(overload);\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    \n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            typedMember,\n                            PUBLIC, \n                            method.getTypeParameters(), \n                            method.getType(), \n                            method.getName(), \n                            method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter) {// Concrete getter\n                Getter getter = (Getter)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(getter, null);\n                if (needsCompanionDelegate(model, member)) {\n                    final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                            typedMember,\n                            PUBLIC | (getter.isDefault() ? 0 : FINAL), \n                            Collections.<TypeParameter>emptyList(), \n                            getter.getType(), \n                            CodegenUtil.getGetterName(member), \n                            Collections.<Parameter>emptyList(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(getterDelegate);\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getName() + \" \" + member.getClass());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            sat = satisfiedType.getSupertype(sat.getDeclaration());\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","commit_id":"6939d301d9e01a179d56aebe935eb77e77b7fa76","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void transformInstantiateCompanions(\n            ClassDefinitionBuilder classBuilder, \n            Interface iface, ProducedType satisfiedType) {\n        at(null);\n        final List<JCExpression> state = List.<JCExpression>of(makeUnquotedIdent(\"this\"));\n        final String fieldName = getCompanionFieldName(iface);\n        classBuilder.init(make().Exec(make().Assign(\n                makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                make().NewClass(null, \n                        null, // TODO Type args \n                        makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES),\n                        state,\n                        null))));\n        \n        classBuilder.field(PRIVATE | FINAL, fieldName, \n                makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES), null, false);\n    }","id":101559,"modified_method":"private void transformInstantiateCompanions(\n            ClassDefinitionBuilder classBuilder, \n            Class model,\n            Interface iface, ProducedType satisfiedType) {\n        at(null);\n        // We may need to cast 'this' because of refined variable inheritance\n        final List<JCExpression> state = List.<JCExpression>of(\n                expressionGen().applyErasureAndBoxing(makeUnquotedIdent(\"this\"), \n                model.getType(), true, BoxingStrategy.BOXED, satisfiedType));\n        final String fieldName = getCompanionFieldName(iface);\n        classBuilder.init(make().Exec(make().Assign(\n                makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                make().NewClass(null, \n                        null, // TODO Type args \n                        makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES),\n                        state,\n                        null))));\n        \n        classBuilder.field(PRIVATE | FINAL, fieldName, \n                makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES), null, false);\n    }","commit_id":"6939d301d9e01a179d56aebe935eb77e77b7fa76","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Used for \"static\" method or class references. For example:\n     * <pre>\n     *     value x = Integer.plus;\n     *     value y = Foo.method;\n     *     value z = Outer.Inner;\n     * <\/pre>\n     */\n    public static CallableBuilder unboundFunctionalMemberReference(\n            CeylonTransformer gen,\n            Tree.QualifiedMemberOrTypeExpression qmte,\n            ProducedType typeModel, \n            final Functional methodOrClass, \n            ProducedReference producedReference) {\n        final ParameterList parameterList = methodOrClass.getParameterLists().get(0);\n        final ProducedType type = gen.getReturnTypeOfCallable(typeModel);\n        CallableBuilder inner = new CallableBuilder(gen, type, parameterList);\n        inner.parameterTypes = inner.getParameterTypesFromCallableModel();//FromParameterModels();\n        inner.defaultValueCall = inner.new MemberReferenceDefaultValueCall(methodOrClass);\n        CallBuilder callBuilder = CallBuilder.instance(gen);\n        ProducedType accessType = gen.getParameterTypeOfCallable(typeModel, 0);\n        if (methodOrClass instanceof Method) {\n            callBuilder.invoke(gen.naming.makeQualifiedName(gen.naming.makeUnquotedIdent(Unfix.$instance$), (Method)methodOrClass, Naming.NA_MEMBER));\n            if (!((TypedDeclaration)methodOrClass).isShared()) {\n                accessType = Decl.getPrivateAccessType(qmte);\n            }\n        } else if (methodOrClass instanceof Method\n                && ((Method)methodOrClass).isParameter()) {\n            callBuilder.invoke(gen.naming.makeQualifiedName(gen.naming.makeUnquotedIdent(Unfix.$instance$), (Method)methodOrClass, Naming.NA_MEMBER));\n        } else if (methodOrClass instanceof Class) {\n            if (Strategy.generateInstantiator((Class)methodOrClass)) {\n                callBuilder.invoke(gen.naming.makeInstantiatorMethodName(gen.naming.makeUnquotedIdent(Unfix.$instance$), (Class)methodOrClass));\n            } else {\n                callBuilder.instantiate(new ExpressionAndType(gen.naming.makeUnquotedIdent(Unfix.$instance$), null), \n                        gen.makeJavaType(((Class)methodOrClass).getType(), JT_CLASS_NEW | AbstractTransformer.JT_NON_QUALIFIED));\n                if (!((Class)methodOrClass).isShared()) {\n                    accessType = Decl.getPrivateAccessType(qmte);\n                }\n            }\n        } else {\n            throw BugException.unhandledDeclarationCase((Declaration)methodOrClass, qmte);\n        }\n        ListBuffer<ExpressionAndType> reified = ListBuffer.lb();\n        \n        DirectInvocation.addReifiedArguments(gen, producedReference, reified);\n        for (ExpressionAndType reifiedArgument : reified) {\n            callBuilder.argument(reifiedArgument.expression);\n        }\n        \n        for (Parameter parameter : parameterList.getParameters()) {\n            callBuilder.argument(gen.naming.makeQuotedIdent(parameter.getName()));\n        }\n        JCExpression innerInvocation = callBuilder.build();\n        // Need to worry about boxing for Method and FunctionalParameter \n        if (methodOrClass instanceof TypedDeclaration) {\n            // use the method return type since the function is actually applied\n            ProducedType returnType = gen.getReturnTypeOfCallable(type);\n            innerInvocation = gen.expressionGen().applyErasureAndBoxing(innerInvocation, \n                    returnType,\n                    // make sure we use the type erased info as it has not been passed to the expression since the\n                    // expression is a Callable\n                    CodegenUtil.hasTypeErased((TypedDeclaration)methodOrClass),\n                    !CodegenUtil.isUnBoxed((TypedDeclaration)methodOrClass), \n                    BoxingStrategy.BOXED, returnType, 0);\n        } else if (Strategy.isInstantiatorUntyped((Class)methodOrClass)) {\n            // $new method declared to return Object, so needs typecast\n            innerInvocation = gen.make().TypeCast(gen.makeJavaType(\n                    ((Class)methodOrClass).getType()), innerInvocation);\n        }\n        List<JCStatement> innerBody = List.<JCStatement>of(gen.make().Return(innerInvocation));\n        inner.useDefaultTransformation(innerBody);\n        \n        ParameterList outerPl = new ParameterList();\n        Parameter instanceParameter = new Parameter();\n        instanceParameter.setName(Naming.name(Unfix.$instance$));\n        Value valueModel = new Value();\n        instanceParameter.setModel(valueModel);\n        valueModel.setName(instanceParameter.getName());\n        valueModel.setInitializerParameter(instanceParameter);\n        valueModel.setType(accessType);\n        valueModel.setUnboxed(false);\n        outerPl.getParameters().add(instanceParameter);\n        CallableBuilder outer = new CallableBuilder(gen, typeModel, outerPl);\n        outer.parameterTypes = outer.getParameterTypesFromParameterModels();\n        List<JCStatement> outerBody = List.<JCStatement>of(gen.make().Return(inner.build()));\n        outer.useDefaultTransformation(outerBody);\n        outer.companionAccess = Decl.isPrivateAccessRequiringCompanion(qmte);\n        \n        return outer;\n    }","id":101560,"modified_method":"/**\n     * Used for \"static\" method or class references. For example:\n     * <pre>\n     *     value x = Integer.plus;\n     *     value y = Foo.method;\n     *     value z = Outer.Inner;\n     * <\/pre>\n     */\n    public static CallableBuilder unboundFunctionalMemberReference(\n            CeylonTransformer gen,\n            Tree.QualifiedMemberOrTypeExpression qmte,\n            ProducedType typeModel, \n            final Functional methodOrClass, \n            ProducedReference producedReference) {\n        final ParameterList parameterList = methodOrClass.getParameterLists().get(0);\n        final ProducedType type = gen.getReturnTypeOfCallable(typeModel);\n        CallableBuilder inner = new CallableBuilder(gen, type, parameterList);\n        inner.parameterTypes = inner.getParameterTypesFromCallableModel();//FromParameterModels();\n        inner.defaultValueCall = inner.new MemberReferenceDefaultValueCall(methodOrClass);\n        CallBuilder callBuilder = CallBuilder.instance(gen);\n        ProducedType qualifyingType = qmte.getTarget().getQualifyingType();\n        ProducedType accessType = gen.getParameterTypeOfCallable(typeModel, 0);\n        JCExpression target = gen.naming.makeUnquotedIdent(Unfix.$instance$);\n        target = gen.expressionGen().applyErasureAndBoxing(target, producedReference.getQualifyingType(), true, BoxingStrategy.BOXED, qualifyingType);\n        if (methodOrClass instanceof Method) {\n            callBuilder.invoke(gen.naming.makeQualifiedName(target, (Method)methodOrClass, Naming.NA_MEMBER));\n            if (!((TypedDeclaration)methodOrClass).isShared()) {\n                accessType = Decl.getPrivateAccessType(qmte);\n            }\n        } else if (methodOrClass instanceof Method\n                && ((Method)methodOrClass).isParameter()) {\n            callBuilder.invoke(gen.naming.makeQualifiedName(target, (Method)methodOrClass, Naming.NA_MEMBER));\n        } else if (methodOrClass instanceof Class) {\n            if (Strategy.generateInstantiator((Class)methodOrClass)) {\n                callBuilder.invoke(gen.naming.makeInstantiatorMethodName(target, (Class)methodOrClass));\n            } else {\n                callBuilder.instantiate(new ExpressionAndType(target, null), \n                        gen.makeJavaType(((Class)methodOrClass).getType(), JT_CLASS_NEW | AbstractTransformer.JT_NON_QUALIFIED));\n                if (!((Class)methodOrClass).isShared()) {\n                    accessType = Decl.getPrivateAccessType(qmte);\n                }\n            }\n        } else {\n            throw BugException.unhandledDeclarationCase((Declaration)methodOrClass, qmte);\n        }\n        ListBuffer<ExpressionAndType> reified = ListBuffer.lb();\n        \n        DirectInvocation.addReifiedArguments(gen, producedReference, reified);\n        for (ExpressionAndType reifiedArgument : reified) {\n            callBuilder.argument(reifiedArgument.expression);\n        }\n        \n        for (Parameter parameter : parameterList.getParameters()) {\n            JCExpression parameterExpr = gen.naming.makeQuotedIdent(parameter.getName());\n            int flags = 0;\n            ProducedType parameterType = parameter.getType();\n            // this works on the parameter type as declared\n            if(!parameterType.isRaw())\n                flags |= ExpressionTransformer.EXPR_EXPECTED_TYPE_NOT_RAW;\n            if(gen.hasConstrainedTypeParameters(parameterType))\n                flags |= ExpressionTransformer.EXPR_EXPECTED_TYPE_HAS_CONSTRAINED_TYPE_PARAMETERS;\n            if(gen.hasDependentCovariantTypeParameters(parameterType))\n                flags |= ExpressionTransformer.EXPR_EXPECTED_TYPE_HAS_DEPENDENT_COVARIANT_TYPE_PARAMETERS;\n            // this gives me the parameter as typed in this invocation\n            ProducedTypedReference typedParameter = qmte.getTarget().getTypedParameter(parameter);\n            // this gives me the parameter as typed that the method expects\n            ProducedType targetParamType = gen.expressionGen().getTypeForParameter(parameter, qmte.getTarget(), ExpressionTransformer.TP_TO_BOUND);\n            // make sure it's compatible\n            parameterExpr = gen.expressionGen().applyErasureAndBoxing(parameterExpr, typedParameter.getType(), \n                    CodegenUtil.hasTypeErased(parameter.getModel()),\n                    !CodegenUtil.isUnBoxed(parameter.getModel()), \n                    CodegenUtil.getBoxingStrategy(parameter.getModel()), \n                    targetParamType, flags);\n            callBuilder.argument(parameterExpr);\n        }\n        JCExpression innerInvocation = callBuilder.build();\n        // Need to worry about boxing for Method and FunctionalParameter \n        if (methodOrClass instanceof TypedDeclaration) {\n            // use the method return type since the function is actually applied\n            ProducedType returnType = gen.getReturnTypeOfCallable(type);\n            innerInvocation = gen.expressionGen().applyErasureAndBoxing(innerInvocation, \n                    returnType,\n                    // make sure we use the type erased info as it has not been passed to the expression since the\n                    // expression is a Callable\n                    CodegenUtil.hasTypeErased((TypedDeclaration)methodOrClass),\n                    !CodegenUtil.isUnBoxed((TypedDeclaration)methodOrClass), \n                    BoxingStrategy.BOXED, returnType, 0);\n        } else if (Strategy.isInstantiatorUntyped((Class)methodOrClass)) {\n            // $new method declared to return Object, so needs typecast\n            innerInvocation = gen.make().TypeCast(gen.makeJavaType(\n                    ((Class)methodOrClass).getType()), innerInvocation);\n        }\n        List<JCStatement> innerBody = List.<JCStatement>of(gen.make().Return(innerInvocation));\n        inner.useDefaultTransformation(innerBody);\n        \n        ParameterList outerPl = new ParameterList();\n        Parameter instanceParameter = new Parameter();\n        instanceParameter.setName(Naming.name(Unfix.$instance$));\n        Value valueModel = new Value();\n        instanceParameter.setModel(valueModel);\n        valueModel.setName(instanceParameter.getName());\n        valueModel.setInitializerParameter(instanceParameter);\n        valueModel.setType(accessType);\n        valueModel.setUnboxed(false);\n        outerPl.getParameters().add(instanceParameter);\n        CallableBuilder outer = new CallableBuilder(gen, typeModel, outerPl);\n        outer.parameterTypes = outer.getParameterTypesFromParameterModels();\n        List<JCStatement> outerBody = List.<JCStatement>of(gen.make().Return(inner.build()));\n        outer.useDefaultTransformation(outerBody);\n        outer.companionAccess = Decl.isPrivateAccessRequiringCompanion(qmte);\n        \n        return outer;\n    }","commit_id":"25c04d6788684854642ee901c3ba83efb9323d8f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Used for \"static\" value references. For example:\n     * <pre>\n     *     value x = Integer.plus;\n     *     value y = Foo.method;\n     *     value z = Outer.Inner;\n     * <\/pre>\n     */\n    public static CallableBuilder unboundValueMemberReference(\n            CeylonTransformer gen,\n            Tree.QualifiedMemberOrTypeExpression qmte,\n            ProducedType typeModel,\n            final TypedDeclaration value) {\n        CallBuilder callBuilder = CallBuilder.instance(gen);\n        if (gen.expressionGen().isThrowableMessage(qmte)) {\n            callBuilder.invoke(gen.utilInvocation().throwableMessage());\n            callBuilder.argument(gen.naming.makeUnquotedIdent(Unfix.$instance$));\n        } else if (gen.expressionGen().isThrowableSuppressed(qmte)) {\n            callBuilder.invoke(gen.utilInvocation().suppressedExceptions());\n            callBuilder.argument(gen.naming.makeUnquotedIdent(Unfix.$instance$));\n        } else {\n            JCExpression memberName = gen.naming.makeQualifiedName(gen.naming.makeUnquotedIdent(Unfix.$instance$), value, Naming.NA_GETTER | Naming.NA_MEMBER);\n            if(value instanceof FieldValue){\n                callBuilder.fieldRead(memberName);\n            }else{\n                callBuilder.invoke(memberName);\n            }\n        }\n        JCExpression innerInvocation = callBuilder.build();\n        // use the return type since the value is actually applied\n        ProducedType returnType = gen.getReturnTypeOfCallable(typeModel);\n        innerInvocation = gen.expressionGen().applyErasureAndBoxing(innerInvocation, returnType, \n                // make sure we use the type erased info as it has not been passed to the expression since the\n                // expression is a Callable\n                CodegenUtil.hasTypeErased(value), !CodegenUtil.isUnBoxed(value), \n                BoxingStrategy.BOXED, returnType, 0);\n        \n        ParameterList outerPl = new ParameterList();\n        Parameter instanceParameter = new Parameter();\n        instanceParameter.setName(Naming.name(Unfix.$instance$));\n        Value valueModel = new Value();\n        instanceParameter.setModel(valueModel);\n        ProducedType accessType = gen.getParameterTypeOfCallable(typeModel, 0);;\n        if (!value.isShared()) {\n            accessType = Decl.getPrivateAccessType(qmte);\n        }\n        valueModel.setName(instanceParameter.getName());\n        valueModel.setInitializerParameter(instanceParameter);\n        valueModel.setType(accessType);\n        valueModel.setUnboxed(false);\n        outerPl.getParameters().add(instanceParameter);\n        CallableBuilder outer = new CallableBuilder(gen, typeModel, outerPl);\n        outer.parameterTypes = outer.getParameterTypesFromParameterModels();\n        List<JCStatement> innerBody = List.<JCStatement>of(gen.make().Return(innerInvocation));\n        outer.useDefaultTransformation(innerBody);\n        outer.companionAccess = Decl.isPrivateAccessRequiringCompanion(qmte);\n        \n        return outer;\n    }","id":101561,"modified_method":"/**\n     * Used for \"static\" value references. For example:\n     * <pre>\n     *     value x = Integer.plus;\n     *     value y = Foo.method;\n     *     value z = Outer.Inner;\n     * <\/pre>\n     */\n    public static CallableBuilder unboundValueMemberReference(\n            CeylonTransformer gen,\n            Tree.QualifiedMemberOrTypeExpression qmte,\n            ProducedType typeModel,\n            final TypedDeclaration value) {\n        CallBuilder callBuilder = CallBuilder.instance(gen);\n        ProducedType qualifyingType = qmte.getTarget().getQualifyingType();\n        JCExpression target = gen.naming.makeUnquotedIdent(Unfix.$instance$);\n        target = gen.expressionGen().applyErasureAndBoxing(target, qmte.getPrimary().getTypeModel(), true, BoxingStrategy.BOXED, qualifyingType);\n        if (gen.expressionGen().isThrowableMessage(qmte)) {\n            callBuilder.invoke(gen.utilInvocation().throwableMessage());\n            callBuilder.argument(target);\n        } else if (gen.expressionGen().isThrowableSuppressed(qmte)) {\n            callBuilder.invoke(gen.utilInvocation().suppressedExceptions());\n            callBuilder.argument(target);\n        } else {\n            JCExpression memberName = gen.naming.makeQualifiedName(target, value, Naming.NA_GETTER | Naming.NA_MEMBER);\n            if(value instanceof FieldValue){\n                callBuilder.fieldRead(memberName);\n            }else{\n                callBuilder.invoke(memberName);\n            }\n        }\n        JCExpression innerInvocation = callBuilder.build();\n        // use the return type since the value is actually applied\n        ProducedType returnType = gen.getReturnTypeOfCallable(typeModel);\n        innerInvocation = gen.expressionGen().applyErasureAndBoxing(innerInvocation, returnType, \n                // make sure we use the type erased info as it has not been passed to the expression since the\n                // expression is a Callable\n                CodegenUtil.hasTypeErased(value), !CodegenUtil.isUnBoxed(value), \n                BoxingStrategy.BOXED, returnType, 0);\n        \n        ParameterList outerPl = new ParameterList();\n        Parameter instanceParameter = new Parameter();\n        instanceParameter.setName(Naming.name(Unfix.$instance$));\n        Value valueModel = new Value();\n        instanceParameter.setModel(valueModel);\n        ProducedType accessType = gen.getParameterTypeOfCallable(typeModel, 0);;\n        if (!value.isShared()) {\n            accessType = Decl.getPrivateAccessType(qmte);\n        }\n        valueModel.setName(instanceParameter.getName());\n        valueModel.setInitializerParameter(instanceParameter);\n        valueModel.setType(accessType);\n        valueModel.setUnboxed(false);\n        outerPl.getParameters().add(instanceParameter);\n        CallableBuilder outer = new CallableBuilder(gen, typeModel, outerPl);\n        outer.parameterTypes = outer.getParameterTypesFromParameterModels();\n        List<JCStatement> innerBody = List.<JCStatement>of(gen.make().Return(innerInvocation));\n        outer.useDefaultTransformation(innerBody);\n        outer.companionAccess = Decl.isPrivateAccessRequiringCompanion(qmte);\n        \n        return outer;\n    }","commit_id":"25c04d6788684854642ee901c3ba83efb9323d8f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void transformInstantiateCompanions(\n            ClassDefinitionBuilder classBuilder, \n            Interface iface, ProducedType satisfiedType) {\n        at(null);\n        final List<JCExpression> state = List.<JCExpression>of(makeUnquotedIdent(\"this\"));\n        final String fieldName = getCompanionFieldName(iface);\n        classBuilder.init(make().Exec(make().Assign(\n                makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                make().NewClass(null, \n                        null,\n                        makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES),\n                        state,\n                        null))));\n        \n        classBuilder.field(PRIVATE | FINAL, fieldName, \n                makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES), null, false);\n    }","id":101562,"modified_method":"private void transformInstantiateCompanions(\n            ClassDefinitionBuilder classBuilder, \n            Class model, Interface iface, ProducedType satisfiedType) {\n        at(null);\n        final List<JCExpression> state = List.<JCExpression>of(\n                expressionGen().applyErasureAndBoxing(makeUnquotedIdent(\"this\"), \n                        model.getType(), true, BoxingStrategy.BOXED, \n                        satisfiedType));\n        final String fieldName = getCompanionFieldName(iface);\n        classBuilder.init(make().Exec(make().Assign(\n                makeSelect(\"this\", fieldName),// TODO Use qualified name for quoting? \n                make().NewClass(null, \n                        null,\n                        makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES),\n                        state,\n                        null))));\n        \n        classBuilder.field(PRIVATE | FINAL, fieldName, \n                makeJavaType(satisfiedType, AbstractTransformer.COMPANION | SATISFIES), null, false);\n    }","commit_id":"63eda286f39573194ad3202ece5700132689e63e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n     \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    iface, satisfiedType);\n        }\n        \n        if(!Decl.isCeylon(iface)){\n            // let's not try to implement CMI for Java interfaces\n            return;\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (Strategy.onlyOnCompanion(member)) {\n                // non-shared interface methods don't need implementing\n                // (they're just private methods on the $impl)\n                continue;\n            }\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(method, Collections.<ProducedType>emptyList());\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()\n                                || param.isSequenced()) {\n                            final ProducedTypedReference typedParameter = typedMember.getTypedParameter(param);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface,\n                                    typedParameter,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            \n                            final JCMethodDecl overload = makeDelegateToCompanion(iface,\n                                    typedMember,\n                                    PUBLIC | FINAL, \n                                    typeParameters,  \n                                    typedMember.getType(), \n                                    CodegenUtil.quoteMethodName(method), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(overload);\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    \n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            typedMember,\n                            PUBLIC, \n                            method.getTypeParameters(), \n                            method.getType(), \n                            CodegenUtil.quoteMethodName(method), \n                            method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter\n                    || member instanceof Setter\n                    || member instanceof Value) {\n                TypedDeclaration attr = (TypedDeclaration)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(attr, null);\n                if (needsCompanionDelegate(model, member)) {\n                    if (member instanceof Value \n                            || member instanceof Getter) {\n                        final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                                typedMember,\n                                PUBLIC | (attr.isDefault() ? 0 : FINAL), \n                                Collections.<TypeParameter>emptyList(), \n                                typedMember.getType(), \n                                CodegenUtil.getGetterName(attr), \n                                Collections.<Parameter>emptyList(),\n                                Decl.isAncestorLocal(model));\n                        classBuilder.defs(getterDelegate);\n                    }\n                    if (member instanceof Setter) { \n                        final JCMethodDecl setterDelegate = makeDelegateToCompanion(iface, \n                                typedMember,\n                                PUBLIC | (attr.isDefault() ? 0 : FINAL), \n                                Collections.<TypeParameter>emptyList(), \n                                typeFact().getVoidDeclaration().getType(), \n                                CodegenUtil.getSetterName(attr), \n                                Collections.<Parameter>singletonList(((Setter)member).getParameter()),\n                                Decl.isAncestorLocal(model));\n                        classBuilder.defs(setterDelegate);\n                    }\n                    if (member instanceof Value \n                            && ((Value)attr).isVariable()) {\n                        // I don't *think* this can happen because although a \n                        // variable Value can be declared on an interface it \n                        // will need to we refined as a Getter+Setter on a \n                        // subinterface in order for there to be a method in a \n                        // $impl to delegate to\n                        throw new RuntimeException();\n                    }\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getQualifiedNameString() + \" \" + member.getClass());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            sat = satisfiedType.getSupertype(sat.getDeclaration());\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","id":101563,"modified_method":"/**\n     * Generates companion fields ($Foo$impl) and methods\n     */\n    private void concreteMembersFromSuperinterfaces(final Class model,\n            ClassDefinitionBuilder classBuilder, \n            ProducedType satisfiedType, Set<Interface> satisfiedInterfaces) {\n        Interface iface = (Interface)satisfiedType.getDeclaration();\n        if (satisfiedInterfaces.contains(iface)) {\n            return;\n        }\n     \n        // If there is no $impl (e.g. implementing a Java interface) \n        // then don't instantiate it...\n        if (hasImpl(iface)) {\n            // ... otherwise for each satisfied interface, \n            // instantiate an instance of the \n            // companion class in the constructor and assign it to a\n            // $Interface$impl field\n            transformInstantiateCompanions(classBuilder,\n                    model, iface, satisfiedType);\n        }\n        \n        if(!Decl.isCeylon(iface)){\n            // let's not try to implement CMI for Java interfaces\n            return;\n        }\n        \n        // For each super interface\n        for (Declaration member : iface.getMembers()) {\n            if (Strategy.onlyOnCompanion(member)) {\n                // non-shared interface methods don't need implementing\n                // (they're just private methods on the $impl)\n                continue;\n            }\n            if (member instanceof Method) {\n                Method method = (Method)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(method, Collections.<ProducedType>emptyList());\n                final java.util.List<TypeParameter> typeParameters = method.getTypeParameters();\n                final java.util.List<Parameter> parameters = method.getParameterLists().get(0).getParameters();\n                if (!satisfiedInterfaces.contains((Interface)method.getContainer())) {\n                    \n                    for (Parameter param : parameters) {\n                        if (param.isDefaulted()\n                                || param.isSequenced()) {\n                            final ProducedTypedReference typedParameter = typedMember.getTypedParameter(param);\n                            // If that method has a defaulted parameter, \n                            // we need to generate a default value method\n                            // which also delegates to the $impl\n                            final JCMethodDecl defaultValueDelegate = makeDelegateToCompanion(iface,\n                                    typedParameter,\n                                    PUBLIC | FINAL, \n                                    typeParameters, \n                                    typedParameter.getType(), \n                                    CodegenUtil.getDefaultedParamMethodName(method, param), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(defaultValueDelegate);\n                            \n                            final JCMethodDecl overload = makeDelegateToCompanion(iface,\n                                    typedMember,\n                                    PUBLIC | FINAL, \n                                    typeParameters,  \n                                    typedMember.getType(), \n                                    CodegenUtil.quoteMethodName(method), \n                                    parameters.subList(0, parameters.indexOf(param)),\n                                    Decl.isAncestorLocal(model));\n                            classBuilder.defs(overload);\n                        }\n                    }\n                }\n                // if it has the *most refined* default concrete member, \n                // then generate a method on the class\n                // delegating to the $impl instance\n                if (needsCompanionDelegate(model, member)) {\n                    \n                    final JCMethodDecl concreteMemberDelegate = makeDelegateToCompanion(iface,\n                            typedMember,\n                            PUBLIC, \n                            method.getTypeParameters(), \n                            method.getType(), \n                            CodegenUtil.quoteMethodName(method), \n                            method.getParameterLists().get(0).getParameters(),\n                            Decl.isAncestorLocal(model));\n                    classBuilder.defs(concreteMemberDelegate);\n                     \n                }\n            } else if (member instanceof Getter\n                    || member instanceof Setter\n                    || member instanceof Value) {\n                TypedDeclaration attr = (TypedDeclaration)member;\n                final ProducedTypedReference typedMember = satisfiedType.getTypedMember(attr, null);\n                if (needsCompanionDelegate(model, member)) {\n                    if (member instanceof Value \n                            || member instanceof Getter) {\n                        final JCMethodDecl getterDelegate = makeDelegateToCompanion(iface, \n                                typedMember,\n                                PUBLIC | (attr.isDefault() ? 0 : FINAL), \n                                Collections.<TypeParameter>emptyList(), \n                                typedMember.getType(), \n                                CodegenUtil.getGetterName(attr), \n                                Collections.<Parameter>emptyList(),\n                                Decl.isAncestorLocal(model));\n                        classBuilder.defs(getterDelegate);\n                    }\n                    if (member instanceof Setter) { \n                        final JCMethodDecl setterDelegate = makeDelegateToCompanion(iface, \n                                typedMember,\n                                PUBLIC | (attr.isDefault() ? 0 : FINAL), \n                                Collections.<TypeParameter>emptyList(), \n                                typeFact().getVoidDeclaration().getType(), \n                                CodegenUtil.getSetterName(attr), \n                                Collections.<Parameter>singletonList(((Setter)member).getParameter()),\n                                Decl.isAncestorLocal(model));\n                        classBuilder.defs(setterDelegate);\n                    }\n                    if (member instanceof Value \n                            && ((Value)attr).isVariable()) {\n                        // I don't *think* this can happen because although a \n                        // variable Value can be declared on an interface it \n                        // will need to we refined as a Getter+Setter on a \n                        // subinterface in order for there to be a method in a \n                        // $impl to delegate to\n                        throw new RuntimeException();\n                    }\n                }\n            } else if (needsCompanionDelegate(model, member)) {\n                log.error(\"ceylon\", \"Unhandled concrete interface member \" + member.getQualifiedNameString() + \" \" + member.getClass());\n            }\n        }\n        \n        // Add $impl instances for the whole interface hierarchy\n        satisfiedInterfaces.add(iface);\n        for (ProducedType sat : iface.getSatisfiedTypes()) {\n            sat = satisfiedType.getSupertype(sat.getDeclaration());\n            concreteMembersFromSuperinterfaces(model, classBuilder, sat, satisfiedInterfaces);\n        }\n        \n    }","commit_id":"63eda286f39573194ad3202ece5700132689e63e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private static XmlTag findSpecialTag(@NonNls String name, @NonNls String specialName, XmlTag rootTag, XmlNSDescriptorImpl descriptor,\n                                       HashSet<XmlTag> visited) {\n    XmlNSDescriptorImpl nsDescriptor = getNSDescriptorToSearchIn(rootTag, name, descriptor);\n\n    if (nsDescriptor != descriptor) {\n      return findSpecialTag(\n        XmlUtil.findLocalNameByQualifiedName(name),\n        specialName,\n        nsDescriptor.getDescriptorFile().getDocument().getRootTag(),\n        nsDescriptor,\n        visited\n      );\n    }\n\n    if (visited == null) visited = new HashSet<XmlTag>(1);\n    else if (visited.contains(rootTag)) return null;\n    visited.add(rootTag);\n\n    XmlTag[] tags = rootTag.getSubTags();\n\n    return findSpecialTagIn(tags, specialName, name, rootTag, descriptor, visited);\n  }","id":101564,"modified_method":"private static @Nullable XmlTag findSpecialTag(@NonNls String name, @NonNls String specialName, XmlTag rootTag, XmlNSDescriptorImpl descriptor,\n                                       HashSet<XmlTag> visited) {\n    XmlNSDescriptorImpl nsDescriptor = getNSDescriptorToSearchIn(rootTag, name, descriptor);\n\n    if (nsDescriptor != descriptor) {\n      final XmlDocument document = nsDescriptor.getDescriptorFile() != null ? nsDescriptor.getDescriptorFile().getDocument():null;\n      if (document == null) return null;\n\n      return findSpecialTag(\n        XmlUtil.findLocalNameByQualifiedName(name),\n        specialName,\n        document.getRootTag(),\n        nsDescriptor,\n        visited\n      );\n    }\n\n    if (visited == null) visited = new HashSet<XmlTag>(1);\n    else if (visited.contains(rootTag)) return null;\n    visited.add(rootTag);\n\n    XmlTag[] tags = rootTag.getSubTags();\n\n    return findSpecialTagIn(tags, specialName, name, rootTag, descriptor, visited);\n  }","commit_id":"00e3adc2172eeb9882e857f83849644abbc94516","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean process(ComponentType type, XmlTag component, @Nullable XmlTagValue impl, @Nullable XmlTagValue intf) {\n      if (impl == null) {\n        addProblem(component,\n                DevKitBundle.message(\"inspections.registration.problems.missing.implementation.class\"),\n                ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      } else {\n        final PsiClass implClass = myPsiManager.findClass(impl.getTrimmedText(), myScope);\n        if (implClass == null) {\n          // TODO: Add \"Create Class\" QuickFix (should be able to choose which module to create class in)\n          addProblem(impl,\n                  DevKitBundle.message(\"inspections.registration.problems.cannot.resolve.class\",\n                          DevKitBundle.message(\"class.implementation\")),\n                  ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n        } else {\n          final PsiClass componentClass = myPsiManager.findClass(type.myClassName, myScope);\n          if (componentClass != null && !implClass.isInheritor(componentClass, true)) {\n            addProblem(impl,\n                    DevKitBundle.message(\"inspections.registration.problems.component.should.implement\", type.myClassName),\n                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                    ImplementOrExtendFix.createFix(componentClass, implClass, myOnTheFly));\n          }\n          if (isAbstract(implClass)) {\n            addProblem(impl,\n                    DevKitBundle.message(\"inspections.registration.problems.abstract\"),\n                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n          }\n        }\n\n        if (intf != null) {\n          final PsiClass intfClass = myPsiManager.findClass(intf.getTrimmedText(), myScope);\n          if (intfClass == null) {\n            // TODO: Add \"Create Class/Interface\" QuickFix (should be able to choose which module to create class in)\n            addProblem(intf,\n                    DevKitBundle.message(\"inspections.registration.problems.cannot.resolve.class\",\n                            DevKitBundle.message(\"class.interface\")),\n                    ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n          } else if (implClass != null) {\n            if (myInterfaceClasses.contains(intfClass)) {\n              addProblem(intf,\n                      DevKitBundle.message(\"inspections.registration.problems.component.duplicate.interface\", intfClass.getQualifiedName()),\n                      ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n            }\n            if (intfClass != implClass && !implClass.isInheritor(intfClass, true)) {\n              addProblem(impl,\n                      DevKitBundle.message(\"inspections.registration.problems.component.incompatible.interface\", intfClass.getQualifiedName()),\n                      ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n            }\n            myInterfaceClasses.add(intfClass);\n          }\n        }\n      }\n      return true;\n    }","id":101565,"modified_method":"public boolean process(ComponentType type, XmlTag component, @Nullable XmlTagValue impl, @Nullable XmlTagValue intf) {\n      if (impl == null) {\n        addProblem(component,\n                DevKitBundle.message(\"inspections.registration.problems.missing.implementation.class\"),\n                ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      } else {\n        final PsiClass implClass = myPsiManager.findClass(impl.getTrimmedText(), myScope);\n        if (implClass == null) {\n          // TODO: Add \"Create Class\" QuickFix (should be able to choose which module to create class in)\n          addProblem(impl,\n                  DevKitBundle.message(\"inspections.registration.problems.cannot.resolve.class\",\n                          DevKitBundle.message(\"class.implementation\")),\n                  ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n        } else {\n          final PsiClass componentClass = myPsiManager.findClass(type.myClassName, myScope);\n          if (componentClass != null && !implClass.isInheritor(componentClass, true)) {\n            addProblem(impl,\n                    DevKitBundle.message(\"inspections.registration.problems.component.should.implement\", type.myClassName),\n                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                    ImplementOrExtendFix.createFix(componentClass, implClass, myOnTheFly));\n          }\n          if (isAbstract(implClass)) {\n            addProblem(impl,\n                    DevKitBundle.message(\"inspections.registration.problems.abstract\"),\n                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n          }\n        }\n\n        if (intf != null) {\n          final PsiClass intfClass = myPsiManager.findClass(intf.getTrimmedText(), myScope);\n          if (intfClass == null) {\n            // TODO: Add \"Create Class/Interface\" QuickFix (should be able to choose which module to create class in)\n            addProblem(intf,\n                    DevKitBundle.message(\"inspections.registration.problems.cannot.resolve.class\",\n                            DevKitBundle.message(\"class.interface\")),\n                    ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n          } else if (implClass != null) {\n            final String fqn = intfClass.getQualifiedName();\n\n            if (type == ComponentType.MODULE) {\n              if (!checkInterface(fqn, intf)) {\n                // module components can be restricted to modules of certain types\n                final String[] keys = makeQualifiedModuleInterfaceNames(component, fqn);\n                for (String key : keys) {\n                  checkInterface(key, intf);\n                  myInterfaceClasses.add(key);\n            }\n              }\n            } else {\n              checkInterface(fqn, intf);\n              myInterfaceClasses.add(fqn);\n            }\n\n            if (intfClass != implClass && !implClass.isInheritor(intfClass, true)) {\n              addProblem(impl,\n                  DevKitBundle.message(\"inspections.registration.problems.component.incompatible.interface\", fqn),\n                      ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n            }\n          }\n        }\n      }\n      return true;\n    }","commit_id":"8775ec08b2d41eea27d599b9310e86a6e1f62261","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ProblemDescriptor[] checkPluginXml(XmlFile xmlFile, InspectionManager manager, boolean isOnTheFly) {\n    final XmlTag rootTag = xmlFile.getDocument().getRootTag();\n    assert rootTag != null;\n\n    final RegistrationChecker checker = new RegistrationChecker(manager, xmlFile, isOnTheFly);\n\n    DescriptorUtil.processComponents(rootTag, checker);\n\n    DescriptorUtil.processActions(rootTag, checker);\n\n    return checker.getProblems();\n  }","id":101566,"modified_method":"@Nullable\n  private ProblemDescriptor[] checkPluginXml(XmlFile xmlFile, InspectionManager manager, boolean isOnTheFly) {\n    final XmlDocument document = xmlFile.getDocument();\n    if (document == null) {\n      return null;\n    }\n\n    final XmlTag rootTag = document.getRootTag();\n    assert rootTag != null;\n\n    final RegistrationChecker checker = new RegistrationChecker(manager, xmlFile, isOnTheFly);\n\n    DescriptorUtil.processComponents(rootTag, checker);\n\n    DescriptorUtil.processActions(rootTag, checker);\n\n    return checker.getProblems();\n  }","commit_id":"8775ec08b2d41eea27d599b9310e86a6e1f62261","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public CharSequence getClosingQuote(HighlighterIterator iterator, int offset) {\n    if (offset >= 3) {\n      String quote = iterator.getDocument().getText(new TextRange(offset - 3, offset));\n      if (\"'''\".equals(quote)) return quote;\n      if (\"\\\"\\\"\\\"\".equals(quote)) return quote;\n    }\n    return null;\n  }","id":101567,"modified_method":"@Override\n  public CharSequence getClosingQuote(HighlighterIterator iterator, int offset) {\n    if (offset >= 3) {\n      Document document = iterator.getDocument();\n      if (document == null) return null;\n      String quote = document.getText(new TextRange(offset - 3, offset));\n      if (\"'''\".equals(quote)) return quote;\n      if (\"\\\"\\\"\\\"\".equals(quote)) return quote;\n    }\n    return null;\n  }","commit_id":"7e16ccb57849c75b09b3620f1f376c126ad69caf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic void rollback(\n\t\t\tPlatformTransactionManager platformTransactionManager,\n\t\t\tThrowable throwable,\n\t\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\t\tTransactionStatusAdapter transactionStatusAdapter)\n\t\tthrows Throwable {\n\n\t\tif (transactionAttributeAdapter.rollbackOn(throwable)) {\n\t\t\ttry {\n\t\t\t\tplatformTransactionManager.rollback(\n\t\t\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t\t\t}\n\t\t\tcatch (RuntimeException re) {\n\t\t\t\tre.addSuppressed(throwable);\n\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Application exception overridden by rollback exception\",\n\t\t\t\t\tre);\n\n\t\t\t\tthrow re;\n\t\t\t}\n\t\t\tcatch (Error e) {\n\t\t\t\te.addSuppressed(throwable);\n\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Application exception overridden by rollback error\", e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcommit(\n\t\t\t\tplatformTransactionManager, transactionAttributeAdapter,\n\t\t\t\ttransactionStatusAdapter);\n\t\t}\n\n\t\tthrow throwable;\n\t}","id":101568,"modified_method":"@Override\n\tpublic void rollback(\n\t\t\tPlatformTransactionManager platformTransactionManager,\n\t\t\tThrowable throwable,\n\t\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\t\tTransactionStatusAdapter transactionStatusAdapter)\n\t\tthrows Throwable {\n\n\t\tif (transactionAttributeAdapter.rollbackOn(throwable)) {\n\t\t\ttry {\n\t\t\t\tplatformTransactionManager.rollback(\n\t\t\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tt.addSuppressed(throwable);\n\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tplatformTransactionManager.commit(\n\t\t\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tt.addSuppressed(throwable);\n\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t}\n\n\t\tthrow throwable;\n\t}","commit_id":"63559a970622d72899b4e62c897da8313a73b3e1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void commit(\n\t\tPlatformTransactionManager platformTransactionManager,\n\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\tTransactionStatusAdapter transactionStatusAdapter) {\n\n\t\ttry {\n\t\t\tplatformTransactionManager.commit(\n\t\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t\t}\n\t\tcatch (RuntimeException re) {\n\t\t\t_log.error(\n\t\t\t\t\"Application exception overridden by commit exception\", re);\n\n\t\t\tthrow re;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\t_log.error(\"Application exception overridden by commit error\", e);\n\n\t\t\tthrow e;\n\t\t}\n\t}","id":101569,"modified_method":"@Override\n\tpublic void commit(\n\t\tPlatformTransactionManager platformTransactionManager,\n\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\tTransactionStatusAdapter transactionStatusAdapter) {\n\n\t\tplatformTransactionManager.commit(\n\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t}","commit_id":"63559a970622d72899b4e62c897da8313a73b3e1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void rollback(\n\t\t\tPlatformTransactionManager platformTransactionManager,\n\t\t\tThrowable throwable,\n\t\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\t\tTransactionStatusAdapter transactionStatusAdapter)\n\t\tthrows Throwable {\n\n\t\tif (transactionAttributeAdapter.rollbackOn(throwable)) {\n\t\t\ttry {\n\t\t\t\tplatformTransactionManager.rollback(\n\t\t\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t\t\t}\n\t\t\tcatch (RuntimeException re) {\n\t\t\t\tre.addSuppressed(throwable);\n\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Application exception overridden by rollback exception\",\n\t\t\t\t\tre);\n\n\t\t\t\tthrow re;\n\t\t\t}\n\t\t\tcatch (Error e) {\n\t\t\t\te.addSuppressed(throwable);\n\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Application exception overridden by rollback error\", e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tTransactionLifecycleManager.fireTransactionRollbackedEvent(\n\t\t\t\t\ttransactionAttributeAdapter, transactionStatusAdapter,\n\t\t\t\t\tthrowable);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcommit(\n\t\t\t\tplatformTransactionManager, transactionAttributeAdapter,\n\t\t\t\ttransactionStatusAdapter);\n\t\t}\n\n\t\tthrow throwable;\n\t}","id":101570,"modified_method":"@Override\n\tpublic void rollback(\n\t\t\tPlatformTransactionManager platformTransactionManager,\n\t\t\tThrowable throwable,\n\t\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\t\tTransactionStatusAdapter transactionStatusAdapter)\n\t\tthrows Throwable {\n\n\t\tif (transactionAttributeAdapter.rollbackOn(throwable)) {\n\t\t\ttry {\n\t\t\t\tplatformTransactionManager.rollback(\n\t\t\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tt.addSuppressed(throwable);\n\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tTransactionLifecycleManager.fireTransactionRollbackedEvent(\n\t\t\t\t\ttransactionAttributeAdapter, transactionStatusAdapter,\n\t\t\t\t\tthrowable);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_commit(\n\t\t\t\tplatformTransactionManager, transactionAttributeAdapter,\n\t\t\t\ttransactionStatusAdapter, throwable);\n\t\t}\n\n\t\tthrow throwable;\n\t}","commit_id":"63559a970622d72899b4e62c897da8313a73b3e1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void commit(\n\t\tPlatformTransactionManager platformTransactionManager,\n\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\tTransactionStatusAdapter transactionStatusAdapter) {\n\n\t\tThrowable throwable = null;\n\n\t\ttry {\n\t\t\tplatformTransactionManager.commit(\n\t\t\t\ttransactionStatusAdapter.getTransactionStatus());\n\t\t}\n\t\tcatch (RuntimeException re) {\n\t\t\t_log.error(\n\t\t\t\t\"Application exception overridden by commit exception\", re);\n\n\t\t\tthrowable = re;\n\n\t\t\tthrow re;\n\t\t}\n\t\tcatch (Error e) {\n\t\t\t_log.error(\"Application exception overridden by commit error\", e);\n\n\t\t\tthrowable = e;\n\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tif (throwable != null) {\n\t\t\t\tTransactionLifecycleManager.fireTransactionRollbackedEvent(\n\t\t\t\t\ttransactionAttributeAdapter, transactionStatusAdapter,\n\t\t\t\t\tthrowable);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tTransactionLifecycleManager.fireTransactionCommittedEvent(\n\t\t\t\t\ttransactionAttributeAdapter, transactionStatusAdapter);\n\t\t\t}\n\t\t}\n\t}","id":101571,"modified_method":"@Override\n\tpublic void commit(\n\t\tPlatformTransactionManager platformTransactionManager,\n\t\tTransactionAttributeAdapter transactionAttributeAdapter,\n\t\tTransactionStatusAdapter transactionStatusAdapter) {\n\n\t\t_commit(\n\t\t\tplatformTransactionManager, transactionAttributeAdapter,\n\t\t\ttransactionStatusAdapter, null);\n\t}","commit_id":"63559a970622d72899b4e62c897da8313a73b3e1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public TextRange getRangeInElement() {\n        return new TextRange(0, getElement().getTextLength());\n    }","id":101572,"modified_method":"@Override\n    public TextRange getRangeInElement() {\n        PsiElement element = getElement();\n        if (element == null) return null;\n        return new TextRange(0, element.getTextLength());\n    }","commit_id":"d58fa2184bfc53f5801440174ba24aba5bb7ec3c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static InspectionTool instantiateTool(Class toolClass) {\n    try {\n      Constructor constructor = toolClass.getDeclaredConstructor(ArrayUtil.EMPTY_CLASS_ARRAY);\n      constructor.setAccessible(true);\n      return (InspectionTool) constructor.newInstance(ArrayUtil.EMPTY_OBJECT_ARRAY);\n    } catch (SecurityException e) {\n      LOG.error(e);\n    } catch (NoSuchMethodException e) {\n      LOG.error(e);\n    } catch (InstantiationException e) {\n      LOG.error(e);\n    } catch (IllegalAccessException e) {\n      LOG.error(e);\n    } catch (IllegalArgumentException e) {\n      LOG.error(e);\n    } catch (InvocationTargetException e) {\n      LOG.error(e);\n    }\n\n    return null;\n  }","id":101573,"modified_method":"private static Object instantiateTool(Class toolClass) {\n    try {\n      Constructor constructor = toolClass.getDeclaredConstructor(ArrayUtil.EMPTY_CLASS_ARRAY);\n      constructor.setAccessible(true);\n      return constructor.newInstance(ArrayUtil.EMPTY_OBJECT_ARRAY);\n    } catch (SecurityException e) {\n      LOG.error(e);\n    } catch (NoSuchMethodException e) {\n      LOG.error(e);\n    } catch (InstantiationException e) {\n      LOG.error(e);\n    } catch (IllegalAccessException e) {\n      LOG.error(e);\n    } catch (IllegalArgumentException e) {\n      LOG.error(e);\n    } catch (InvocationTargetException e) {\n      LOG.error(e);\n    }\n\n    return null;\n  }","commit_id":"333cd1a82d2c202eea4eed1836ed7922f3c20563","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionTool[] createTools() {\n    int ordinaryToolsSize = myInspectionTools.size();\n    final int withLocal = ordinaryToolsSize + myLocalInspectionTools.size();\n    InspectionTool[] tools = new InspectionTool[withLocal + myGlobalInspectionTools.size()];\n    for (int i = 0; i < ordinaryToolsSize; i++) {\n      tools[i] = instantiateTool(myInspectionTools.get(i));\n    }\n    for(int i = ordinaryToolsSize; i < withLocal; i++){\n      tools[i] = new LocalInspectionToolWrapper((LocalInspectionTool)instantiateWrapper(myLocalInspectionTools.get(i - ordinaryToolsSize)));\n    }\n    for(int i = withLocal; i < tools.length; i++){\n      tools[i] = new GlobalInspectionToolWrapper((GlobalInspectionTool)instantiateWrapper(myGlobalInspectionTools.get(i - withLocal)));\n    }\n\n    buildInspectionIndex(tools);\n\n    return tools;\n  }","id":101574,"modified_method":"public InspectionTool[] createTools() {\n    int ordinaryToolsSize = myInspectionTools.size();\n    final int withLocal = ordinaryToolsSize + myLocalInspectionTools.size();\n    InspectionTool[] tools = new InspectionTool[withLocal + myGlobalInspectionTools.size()];\n    for (int i = 0; i < ordinaryToolsSize; i++) {\n      tools[i] = (InspectionTool)instantiateTool(myInspectionTools.get(i));\n    }\n    for(int i = ordinaryToolsSize; i < withLocal; i++){\n      tools[i] = new LocalInspectionToolWrapper((LocalInspectionTool)instantiateTool(myLocalInspectionTools.get(i - ordinaryToolsSize)));\n    }\n    for(int i = withLocal; i < tools.length; i++){\n      tools[i] = new GlobalInspectionToolWrapper((GlobalInspectionTool)instantiateTool(myGlobalInspectionTools.get(i - withLocal)));\n    }\n\n    buildInspectionIndex(tools);\n\n    return tools;\n  }","commit_id":"333cd1a82d2c202eea4eed1836ed7922f3c20563","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isSuppressed(final String toolId) {\n    if (mySuppressions != null) {\n      if (ArrayUtil.find(mySuppressions, toolId) != -1) {\n        return true;\n      }\n    }\n    final RefEntity entity = getOwner();\n    return entity instanceof RefElement && ((RefElementImpl)entity).isSuppressed(toolId);\n  }","id":101575,"modified_method":"public boolean isSuppressed(final String toolId) {\n    if (mySuppressions != null) {\n      for (@NonNls String suppression : mySuppressions) {\n        if (suppression.equals(toolId) || suppression.equals(\"ALL\")){\n          return true;\n        }\n      }\n    }\n    final RefEntity entity = getOwner();\n    return entity instanceof RefElement && ((RefElementImpl)entity).isSuppressed(toolId);\n  }","commit_id":"333cd1a82d2c202eea4eed1836ed7922f3c20563","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public URL getURL() {\n    try {\n      final PsiFile containingFile = getElement().getContainingFile();\n      if (containingFile == null) return null;\n      final VirtualFile virtualFile = containingFile.getVirtualFile();\n      if (virtualFile == null) return null;\n      return new URL(virtualFile.getUrl() + \"#\" + getElement().getTextRange().getStartOffset());\n    } catch (MalformedURLException e) {\n      LOG.error(e);\n    }\n\n    return null;\n  }","id":101576,"modified_method":"@Nullable\n  public URL getURL() {\n    try {\n      final PsiElement element = getElement();\n      if (element == null) return null;\n      final PsiFile containingFile = element.getContainingFile();\n      if (containingFile == null) return null;\n      final VirtualFile virtualFile = containingFile.getVirtualFile();\n      if (virtualFile == null) return null;\n      return new URL(virtualFile.getUrl() + \"#\" + element.getTextRange().getStartOffset());\n    } catch (MalformedURLException e) {\n      LOG.error(e);\n    }\n\n    return null;\n  }","commit_id":"333cd1a82d2c202eea4eed1836ed7922f3c20563","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Icon getIcon(boolean open) {\n    return getElement().getIcon(Iconable.ICON_FLAG_VISIBILITY | Iconable.ICON_FLAG_READ_STATUS);\n  }","id":101577,"modified_method":"public Icon getIcon(boolean open) {\n    final PsiElement element = getElement();\n    if (element == null) {\n      return element.getIcon(Iconable.ICON_FLAG_VISIBILITY | Iconable.ICON_FLAG_READ_STATUS);\n    } else {\n      return null;\n    }\n  }","commit_id":"ef091549c73f4290f07bddf3094e4927181c425c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private CommonProblemDescriptor[] checkElement(RefClass refEntity, InspectionManager manager, final Project project) {\n    return checkElement(refEntity.getElement(), manager, project);\n  }","id":101578,"modified_method":"@Nullable\n  private CommonProblemDescriptor[] checkElement(RefClass refEntity, InspectionManager manager, final Project project) {\n    final PsiClass psiClass = refEntity.getElement();\n    if (psiClass == null) return null;\n    return checkElement(psiClass, manager, project);\n  }","commit_id":"8e33c785b9f0ea681a69e286c154fe901a32d3ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addAndRemoveVisibleChildren(Set<SNode> removedNodes, Set<SNode> addedNodes) {\n      DefaultTreeModel treeModel = (DefaultTreeModel) getTree().getModel();\n      for (SNode removed : removedNodes) {\n        SNodeTreeNode node = (SNodeTreeNode) findDescendantWith(removed);\n        if (node == null) continue;\n        treeModel.removeNodeFromParent(node);\n      }\n\n      outer : for (SNode added : addedNodes) {\n        if (added.isDeleted()) continue;\n        SNodeTreeNode parent = (SNodeTreeNode) findDescendantWith(added.getParent());\n        if (parent == null) continue;\n        if (!parent.isInitialized()) continue;\n        SNode parentNode = parent.getSNode();\n        int indexof = parentNode.getChildren().indexOf(added);\n        for (Object childO : CollectionUtil.enumerationAsIterable(parent.children())) {\n          if (childO instanceof SNodeTreeNode) {\n            SNodeTreeNode child = (SNodeTreeNode) childO;\n            SNode childNode = child.getSNode();\n            int index = parentNode.getChildren().indexOf(childNode);\n            if (index > indexof) { // insert added before it\n              treeModel.insertNodeInto(new SNodeTreeNode(added, added.getRole_(), getOperationContext()),\n                      parent, treeModel.getIndexOfChild(parent, child));\n              continue outer;\n            }\n          }\n        }\n        treeModel.insertNodeInto(new SNodeTreeNode(added, added.getRole_(), getOperationContext()), parent, parent.getChildCount());\n      }\n    }","id":101579,"modified_method":"private void addAndRemoveVisibleChildren(Set<SNode> removedNodes, Set<SNode> addedNodes) {\n      DefaultTreeModel treeModel = (DefaultTreeModel) getTree().getModel();\n      for (SNode removed : removedNodes) {\n        SNodeTreeNode node = (SNodeTreeNode) findDescendantWith(removed);\n        if (node == null) continue;\n        treeModel.removeNodeFromParent(node);\n      }\n\n      outer : for (SNode added : addedNodes) {\n        if (added.isDeleted()) continue;\n        SNodeTreeNode parent = (SNodeTreeNode) findDescendantWith(added.getParent());\n        if (parent == null) continue;\n        if (!parent.isInitialized()) continue;\n        SNode parentNode = parent.getSNode();\n        int indexof = parentNode.getChildren().indexOf(added);\n        for (Object childO : CollectionUtil.enumerationAsIterable(parent.children())) {\n          if (childO instanceof SNodeTreeNode) {\n            SNodeTreeNode child = (SNodeTreeNode) childO;\n            SNode childNode = child.getSNode();\n            int index = parentNode.getChildren().indexOf(childNode);\n            if (index > indexof) { // insert added before it\n              treeModel.insertNodeInto(createSNodeTreeNode(added, added.getRole_(), getOperationContext()),\n                      parent, treeModel.getIndexOfChild(parent, child));\n              continue outer;\n            }\n          }\n        }\n        treeModel.insertNodeInto(createSNodeTreeNode(added, added.getRole_(), getOperationContext()), parent, parent.getChildCount());\n      }\n    }","commit_id":"a85868c5b2322f3c2de012a51d9877649fdd31dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void init() {\n    this.removeAllChildren();\n    SNode n = getSNode();\n    if (n == null) return;\n\n    if (showPropertiesAndReferences()) {\n      add(new PropertiesTreeNode(getOperationContext(), n));\n      add(new ReferencesTreeNode(getOperationContext(), n));\n    }\n    \n    for (SNode childNode : n.getChildren()) {\n      add(new SNodeTreeNode(childNode, childNode.getRole_(), getOperationContext()));\n    }\n\n    IDEProjectFrame projectFrame = (IDEProjectFrame) getOperationContext().getComponent(AbstractProjectFrame.class);\n    DefaultTreeModel treeModel = (DefaultTreeModel)projectFrame.getProjectPane().getTree().getModel();\n    treeModel.nodeStructureChanged(this);\n    myInitialized = true;\n  }","id":101580,"modified_method":"public void init() {\n    this.removeAllChildren();\n    SNode n = getSNode();\n    if (n == null) return;\n\n    if (showPropertiesAndReferences()) {\n      add(new PropertiesTreeNode(getOperationContext(), n));\n      add(new ReferencesTreeNode(getOperationContext(), n));\n    }\n    \n    for (SNode childNode : n.getChildren()) {\n      add(getSModelModelTreeNode().createSNodeTreeNode(childNode, childNode.getRole_(), getOperationContext()));\n    }\n\n    IDEProjectFrame projectFrame = (IDEProjectFrame) getOperationContext().getComponent(AbstractProjectFrame.class);\n    DefaultTreeModel treeModel = (DefaultTreeModel)projectFrame.getProjectPane().getTree().getModel();\n    treeModel.nodeStructureChanged(this);\n    myInitialized = true;\n  }","commit_id":"a85868c5b2322f3c2de012a51d9877649fdd31dc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Alarm(String severity, String nodeLabel, String description, int count) {\n        m_severity = severity;\n        m_nodeLabel = nodeLabel;\n        m_descrption = description;\n        m_count = count;\n    }","id":101581,"modified_method":"public Alarm(String severity, String nodeLabel, String description, int count, Date firstEventTime, Date lastEventTime) {\n        m_severity = severity;\n        m_nodeLabel = nodeLabel;\n        m_descrption = description;\n        m_count = count;\n        m_firstEventTime = firstEventTime;\n        m_lastEventTime = lastEventTime;\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"AlarmView(Dashlet dashlet) {\n\t\tsuper(dashlet, 5, new String[] { \"Node\", \"Description\", \"Count\" });\n\t}","id":101582,"modified_method":"AlarmView(Dashlet dashlet) {\n\t\tsuper(dashlet, 5, new String[] { \"Node\", \"Description\", \"Count\", \"First Time\", \"Last Time\" });\n\t}","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setRow(FlexTable table, int row, int elementIndex) {\n    \tAlarm alarm = m_alarms[elementIndex];\n        table.setText(row, 0, alarm.getNodeLabel());\n        table.setHTML(row, 1, alarm.getDescrption());\n        table.setText(row, 2, \"\"+alarm.getCount());\n        table.getRowFormatter().setStyleName(row, alarm.getSeverity());\n    }","id":101583,"modified_method":"protected void setRow(FlexTable table, int row, int elementIndex) {\n    \tAlarm alarm = m_alarms[elementIndex];\n        table.setText(row, 0, alarm.getNodeLabel());\n        table.setHTML(row, 1, alarm.getDescrption());\n        table.setText(row, 2, \"\"+alarm.getCount());\n        table.setText(row, 3, alarm.getFirstEventTime().toString());\n        table.setText(row, 4, alarm.getLastEventTime().toString());\n        table.getRowFormatter().setStyleName(row, alarm.getSeverity());\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private NodeStatusDashlet createNodeStatusDashlet() {\n\n        final NodeStatusDashlet nodeStatus = new NodeStatusDashlet(this);\n        \n        AsyncCallback cb = new AsyncCallback() {\n\n            public void onFailure(Throwable e) {\n               error(e);\n            }\n\n            public void onSuccess(Object arg) {\n                nodeStatus.setNodes((String[])arg);\n            }\n            \n        };\n\n        getSurveillanceService().getNodeNames(null, cb);\n\n        m_nodeStatus = nodeStatus;\n        return m_nodeStatus;\n    }","id":101584,"modified_method":"private NodeStatusDashlet createNodeStatusDashlet() {\n        m_nodeStatus = new NodeStatusDashlet(this);\n        m_nodeStatus.setSurveillanceService(getSurveillanceService());\n        m_nodeStatus.setSurveillanceSet(SurveillanceSet.DEFAULT);\n        return m_nodeStatus;\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onModuleLoad() {\n\n        add(createSurveillanceDashlet(), \"surveillanceView\");\n        add(createAlarmDashlet(),        \"alarms\");\n        add(createGraphDashlet(),        \"graphs\");\n        add(createNotificationDashlet(), \"notifications\");\n        //add(createOutageDashlet(),       \"outages\");\n        //add(createNodeStatusDashlet(),   \"nodeStatus\");\n        \n        \n        setSurveillanceSet(SurveillanceSet.DEFAULT);\n        \n    }","id":101585,"modified_method":"public void onModuleLoad() {\n\n        add(createSurveillanceDashlet(), \"surveillanceView\");\n        add(createAlarmDashlet(),        \"alarms\");\n        add(createGraphDashlet(),        \"graphs\");\n        add(createNotificationDashlet(), \"notifications\");\n        //add(createOutageDashlet(),       \"outages\");\n        add(createNodeStatusDashlet(),   \"nodeStatus\");\n        \n        \n        setSurveillanceSet(SurveillanceSet.DEFAULT);\n        \n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RtcNodeModel getNodeList() {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMonitoredService.class, \"monitoredService\");\n        criteria.add(Restrictions.eq(\"monitoredService.status\", \"A\"));\n        criteria.createAlias(\"ipInterface\", \"ipInterface\", CriteriaSpecification.INNER_JOIN);\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n        criteria.createAlias(\"ipInterface.node\", \"node\", CriteriaSpecification.INNER_JOIN);\n        criteria.add(Restrictions.ne(\"node.type\", \"D\"));\n        criteria.createAlias(\"serviceType\", \"serviceType\", CriteriaSpecification.INNER_JOIN);\n        criteria.createAlias(\"currentOutages\", \"currentOutages\", CriteriaSpecification.LEFT_JOIN);\n        criteria.addOrder(Order.asc(\"node.label\"));\n        criteria.addOrder(Order.asc(\"node.id\"));\n        criteria.addOrder(Order.asc(\"ipInterface.ipAddress\"));\n        criteria.addOrder(Order.asc(\"serviceType.name\"));\n        \n        OnmsCriteria outageCriteria = new OnmsCriteria(OnmsOutage.class, \"outage\");\n        outageCriteria.createAlias(\"monitoredService\", \"monitoredService\", CriteriaSpecification.INNER_JOIN);\n        outageCriteria.add(Restrictions.eq(\"monitoredService.status\", \"A\"));\n        outageCriteria.createAlias(\"monitoredService.ipInterface\", \"ipInterface\", CriteriaSpecification.INNER_JOIN);\n        outageCriteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n        outageCriteria.createAlias(\"monitoredService.ipInterface.node\", \"node\", CriteriaSpecification.INNER_JOIN);\n        outageCriteria.add(Restrictions.ne(\"node.type\", \"D\"));\n        \n        Date periodEnd = new Date(System.currentTimeMillis());\n        Date periodStart = new Date(periodEnd.getTime() - (24 * 60 * 60 * 1000));\n        \n        Disjunction disjunction = Restrictions.disjunction();\n        disjunction.add(Restrictions.isNull(\"ifRegainedService\"));\n        disjunction.add(Restrictions.gt(\"ifLostService\", periodStart));\n        disjunction.add(Restrictions.gt(\"ifRegainedService\", periodStart));\n        outageCriteria.add(disjunction);\n        \n        outageCriteria.addOrder(Order.asc(\"monitoredService\"));\n        outageCriteria.addOrder(Order.asc(\"ifLostService\"));\n        \n        List<OnmsMonitoredService> services = m_monitoredServiceDao.findMatching(criteria);\n        List<OnmsOutage> outages = m_outageDao.findMatching(outageCriteria);\n        \n        Map<OnmsMonitoredService, Long> serviceDownTime = calculateServiceDownTime(periodEnd, periodStart, outages);\n        \n        RtcNodeModel model = new RtcNodeModel();\n        \n        OnmsNode lastNode = null;\n        int serviceCount = 0;\n        int serviceDownCount = 0;\n        long downMillisCount = 0;\n        for (OnmsMonitoredService service : services) {\n            if (!service.getIpInterface().getNode().equals(lastNode) && lastNode != null) {\n                Double availability = calculateAvailability(serviceCount, downMillisCount);\n                \n                model.addNode(new RtcNodeModel.RtcNode(lastNode, serviceCount, serviceDownCount, availability));\n                \n                serviceCount = 0;\n                serviceDownCount = 0;\n                downMillisCount = 0;\n            }\n            \n            serviceCount++;\n            if (service.isDown()) {\n                serviceDownCount++;\n            }\n            \n            Long downMillis = serviceDownTime.get(service);\n            if  (downMillis != null) {\n                downMillisCount += downMillis;\n            }\n            \n            lastNode = service.getIpInterface().getNode();\n        }\n        if (lastNode != null) {\n            Double availability = calculateAvailability(serviceCount, downMillisCount);\n            \n            model.addNode(new RtcNodeModel.RtcNode(lastNode, serviceCount, serviceDownCount, availability));\n        }\n        \n        return model;\n    }","id":101586,"modified_method":"public RtcNodeModel getNodeList() {\n        OnmsCriteria serviceCriteria = createServiceCriteria();\n        OnmsCriteria outageCriteria = createOutageCriteria();\n        \n        return getNodeListForCriteria(serviceCriteria, outageCriteria);\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<OnmsMonitoredService, Long> calculateServiceDownTime(Date periodEnd, Date periodStart, List<OnmsOutage> outages) {\n        Map<OnmsMonitoredService, Long> map = new HashMap<OnmsMonitoredService, Long>();\n        for (OnmsOutage outage : outages) {\n            if (map.get(outage.getMonitoredService()) == null) {\n                map.put(outage.getMonitoredService(), new Long(0));\n            }\n            \n            Date begin;\n            if (outage.getIfLostService().before(periodStart)) {\n                begin = periodStart;\n            } else {\n                begin = outage.getIfLostService();\n            }\n            \n            Date end;\n            if (outage.getIfRegainedService() == null || outage.getIfRegainedService().after(periodEnd)) {\n                end = periodEnd;\n            } else {\n                end = outage.getIfRegainedService();\n            }\n            \n            Long count = map.get(outage.getMonitoredService());\n            count += (end.getTime() - begin.getTime());\n            map.put(outage.getMonitoredService(), count);\n        }\n        return map;\n    }","id":101587,"modified_method":"private Map<OnmsMonitoredService, Long> calculateServiceDownTime(Date periodEnd, Date periodStart, List<OnmsOutage> outages) {\n        Map<OnmsMonitoredService, Long> map = new HashMap<OnmsMonitoredService, Long>();\n        for (OnmsOutage outage : outages) {\n            if (map.get(outage.getMonitoredService()) == null) {\n                map.put(outage.getMonitoredService(), new Long(0));\n            }\n            \n            Date begin;\n            if (outage.getIfLostService().before(periodStart)) {\n                begin = periodStart;\n            } else {\n                begin = outage.getIfLostService();\n            }\n            \n            Date end;\n            if (outage.getIfRegainedService() == null || !outage.getIfRegainedService().before(periodEnd)) {\n                end = periodEnd;\n            } else {\n                end = outage.getIfRegainedService();\n            }\n            \n            Long count = map.get(outage.getMonitoredService());\n            count += (end.getTime() - begin.getTime());\n            map.put(outage.getMonitoredService(), count);\n        }\n        return map;\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Alarm[] getAlarmsForSet(SurveillanceSet set) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsAlarm.class, \"alarm\");\n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        criteria.addOrder(Order.desc(\"alarm.severity\"));\n        \n        List<OnmsAlarm> alarms = m_alarmDao.findMatching(criteria);\n\n        Alarm[] alarmArray = new Alarm[alarms.size()];\n        \n        int index = 0;\n        for (OnmsAlarm alarm : alarms) {\n            alarmArray[index] = new Alarm(getSeverityString(alarm.getSeverity()), alarm.getNode().getLabel(), alarm.getDescription(), alarm.getCounter());\n            index++;\n        }\n        \n        return alarmArray;\n    }","id":101588,"modified_method":"public Alarm[] getAlarmsForSet(SurveillanceSet set) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsAlarm.class, \"alarm\");\n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        criteria.addOrder(Order.desc(\"alarm.severity\"));\n        \n        List<OnmsAlarm> alarms = m_alarmDao.findMatching(criteria);\n\n        Alarm[] alarmArray = new Alarm[alarms.size()];\n        \n        int index = 0;\n        for (OnmsAlarm alarm : alarms) {\n            alarmArray[index] = new Alarm(getSeverityString(alarm.getSeverity()), alarm.getNode().getLabel(), alarm.getDescription(), alarm.getCounter(), new Date(alarm.getFirstEventTime().getTime()), new Date(alarm.getLastEventTime().getTime()));\n            index++;\n        }\n        \n        return alarmArray;\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<OnmsNotification> getNotificationsWithCriterion(SurveillanceSet set, Order order, Criterion... criterions) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNotification.class, \"notification\");\n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        for (Criterion criterion : criterions) {\n            criteria.add(criterion);\n        }\n        criteria.addOrder(order);\n        \n        return m_notificationDao.findMatching(criteria);\n    }","id":101589,"modified_method":"private List<Notification> getNotificationsWithCriterion(SurveillanceSet set, String severity, Criterion... criterions) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNotification.class, \"notification\");\n        \n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        \n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        for (Criterion criterion : criterions) {\n            criteria.add(criterion);\n        }\n        \n        criteria.addOrder(Order.desc(\"notification.pageTime\"));\n        \n        List<OnmsNotification> notifications = m_notificationDao.findMatching(criteria);\n        \n        return convertOnmsNotificationsToNotifications(notifications, severity);\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        Assert.state(m_nodeDao != null, \"nodeDao property must be set and cannot be null\");\n        Assert.state(m_resourceDao != null, \"resourceDao property must be set and cannot be null\");\n        Assert.state(m_graphDao != null, \"graphDao property must be set and cannot be null\");\n        Assert.state(m_webSurveillanceService != null, \"webSurveillanceService property must be set and cannot be null\");\n        Assert.state(m_surveillanceViewConfigDao != null, \"surveillanceViewConfigDao property must be set and cannot be null\");\n        Assert.state(m_categoryDao != null, \"categoryDao property must be set and cannot be null\");\n        Assert.state(m_alarmDao != null, \"alarmDao property must be set and cannot be null\");\n        Assert.state(m_notificationDao != null, \"notificationDao property must be set and cannot be null\");\n        Assert.state(m_groupManager != null, \"groupManager property must be set and cannot be null\");\n    }","id":101590,"modified_method":"public void afterPropertiesSet() throws Exception {\n        Assert.state(m_nodeDao != null, \"nodeDao property must be set and cannot be null\");\n        Assert.state(m_resourceDao != null, \"resourceDao property must be set and cannot be null\");\n        Assert.state(m_graphDao != null, \"graphDao property must be set and cannot be null\");\n        Assert.state(m_webSurveillanceService != null, \"webSurveillanceService property must be set and cannot be null\");\n        Assert.state(m_surveillanceViewConfigDao != null, \"surveillanceViewConfigDao property must be set and cannot be null\");\n        Assert.state(m_categoryDao != null, \"categoryDao property must be set and cannot be null\");\n        Assert.state(m_alarmDao != null, \"alarmDao property must be set and cannot be null\");\n        Assert.state(m_notificationDao != null, \"notificationDao property must be set and cannot be null\");\n        Assert.state(m_rtcService != null, \"rtcService property must be set and cannot be null\");\n        Assert.state(m_groupDao != null, \"groupDao property must be set and cannot be null\");\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<Notification> convertOnmsNotificationToNotification(List<OnmsNotification> notifications, String severity) {\n        List<Notification> notifs = new ArrayList<Notification>(notifications.size());\n        \n        for (OnmsNotification notification : notifications) {\n            notifs.add(createNotification(notification, severity));\n        }\n        \n        return notifs;\n    }","id":101591,"modified_method":"private List<Notification> convertOnmsNotificationsToNotifications(List<OnmsNotification> notifications, String severity) {\n        List<Notification> notifs = new ArrayList<Notification>(notifications.size());\n        for (OnmsNotification notification : notifications) {\n            notifs.add(createNotification(notification, severity));\n        }\n        return notifs;\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Notification[] getNotificationsForSet(SurveillanceSet set) {\n        List<Notification> notifications = new ArrayList<Notification>();\n        \n        Date fifteenMinutesAgo = new Date(System.currentTimeMillis() - (15 * 60 * 1000));\n        Date oneWeekAgo = new Date(System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000));\n        \n        notifications.addAll(convertOnmsNotificationToNotification(getNotificationsWithCriterion(set, Order.desc(\"notification.pageTime\"), Restrictions.isNull(\"notification.respondTime\"), Restrictions.le(\"notification.pageTime\", fifteenMinutesAgo)), \"Critical\"));\n        notifications.addAll(convertOnmsNotificationToNotification(getNotificationsWithCriterion(set, Order.desc(\"notification.pageTime\"), Restrictions.isNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", fifteenMinutesAgo)), \"Minor\"));\n        notifications.addAll(convertOnmsNotificationToNotification(getNotificationsWithCriterion(set, Order.desc(\"notification.pageTime\"), Restrictions.isNotNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", oneWeekAgo)), \"Normal\"));\n\n        \n        return notifications.toArray(new Notification[notifications.size()]);\n    }","id":101592,"modified_method":"public Notification[] getNotificationsForSet(SurveillanceSet set) {\n        List<Notification> notifications = new ArrayList<Notification>();\n        \n        Date fifteenMinutesAgo = new Date(System.currentTimeMillis() - (15 * 60 * 1000));\n        Date oneWeekAgo = new Date(System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000));\n        \n        notifications.addAll(getNotificationsWithCriterion(set, \"Critical\", Restrictions.isNull(\"notification.respondTime\"), Restrictions.le(\"notification.pageTime\", fifteenMinutesAgo)));\n        notifications.addAll(getNotificationsWithCriterion(set, \"Minor\", Restrictions.isNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", fifteenMinutesAgo)));\n        notifications.addAll(getNotificationsWithCriterion(set, \"Normal\", Restrictions.isNotNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", oneWeekAgo)));\n\n        \n        return notifications.toArray(new Notification[notifications.size()]);\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private View getView() {\n        String user = getUsername();\n        log().debug(\"Looking for surveillance view that matches user '\" + user + \"'\");\n        \n        View userView = m_surveillanceViewConfigDao.getView(user);\n        if (userView != null) {\n            log().debug(\"Found surveillance view '\" + userView.getName() + \"' matching user name '\" + user + \"'\");\n            return userView;\n        }\n        \n        List<Group> groups = GroupFactory.getInstance().findGroupsForUser(user);\n        for (Group group : groups) {\n            View groupView = m_surveillanceViewConfigDao.getView(group.getName());\n            if (groupView != null) {\n                log().debug(\"Found surveillance view '\" + groupView.getName() + \"' matching group '\" + group.getName() + \"' name for user '\" + user + \"'\");\n                return groupView;\n            }\n        }\n        \n        log().debug(\"Did not find a surveillance view matching the user's user name or one of their group names.  Using the default view for user '\" + user + \"'\");\n        return m_surveillanceViewConfigDao.getDefaultView();\n    }","id":101593,"modified_method":"private View getView() {\n        String user = getUsername();\n        log().debug(\"Looking for surveillance view that matches user '\" + user + \"'\");\n        \n        View userView = m_surveillanceViewConfigDao.getView(user);\n        if (userView != null) {\n            log().debug(\"Found surveillance view '\" + userView.getName() + \"' matching user name '\" + user + \"'\");\n            return userView;\n        }\n        \n        List<Group> groups = m_groupDao.findGroupsForUser(user);\n        for (Group group : groups) {\n            View groupView = m_surveillanceViewConfigDao.getView(group.getName());\n            if (groupView != null) {\n                log().debug(\"Found surveillance view '\" + groupView.getName() + \"' matching group '\" + group.getName() + \"' name for user '\" + user + \"'\");\n                return groupView;\n            }\n        }\n        \n        View defaultView = m_surveillanceViewConfigDao.getDefaultView();\n        Assert.state(defaultView != null, \"there is no default surveillance view and we could not find a surviellance view for the user's username or any of their groups\");\n        log().debug(\"Did not find a surveillance view matching the user's user name or one of their group names.  Using the default view for user '\" + user + \"'\");\n        return defaultView;\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetUsernameWithUserDetails() {\n        UserDetails details = new User(\"user\", \"password\", true, true, true, true, new GrantedAuthority[0]);\n        Authentication auth = new UsernamePasswordAuthenticationToken(details, null, details.getAuthorities());\n        SecurityContextHolder.getContext().setAuthentication(auth);\n        \n        String user = m_service.getUsername();\n        assertNotNull(\"user should not be null\", user);\n        assertEquals(\"user name\", details.getUsername(), user);\n    }","id":101594,"modified_method":"public void testGetUsernameWithUserDetails() {\n        UserDetails details = populateSecurityContext();\n        \n        String user = m_service.getUsername();\n        assertNotNull(\"user should not be null\", user);\n        assertEquals(\"user name\", details.getUsername(), user);\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public NodeStatusDashlet(Dashboard dashboard) {\n        super(dashboard, \"Node Status\");\n        \n        setView(m_listBox);\n    }","id":101595,"modified_method":"public NodeStatusDashlet(Dashboard dashboard) {\n        super(dashboard, \"Node Status\");\n        setLoader(m_loader);\n        setView(m_view);\n    }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String toString() {\n            return m_node.getLabel() + \": \" + m_downServiceCount + \" of \" + m_serviceCount + \": \" + AVAILABILITY_FORMAT.format(m_availability);\n        }","id":101596,"modified_method":"public String toString() {\n            return m_node.getLabel() + \": \" + m_downServiceCount + \" of \" + m_serviceCount + \": \" + getAvailabilityAsString();\n        }","commit_id":"44b91569828af0f449cfb2f7aadd64c3e3874e08","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Alarm(String severity, String nodeLabel, String description, int count) {\n        m_severity = severity;\n        m_nodeLabel = nodeLabel;\n        m_descrption = description;\n        m_count = count;\n    }","id":101597,"modified_method":"public Alarm(String severity, String nodeLabel, String description, int count, Date firstEventTime, Date lastEventTime) {\n        m_severity = severity;\n        m_nodeLabel = nodeLabel;\n        m_descrption = description;\n        m_count = count;\n        m_firstEventTime = firstEventTime;\n        m_lastEventTime = lastEventTime;\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"AlarmView(Dashlet dashlet) {\n\t\tsuper(dashlet, 5, new String[] { \"Node\", \"Description\", \"Count\" });\n\t}","id":101598,"modified_method":"AlarmView(Dashlet dashlet) {\n\t\tsuper(dashlet, 5, new String[] { \"Node\", \"Description\", \"Count\", \"First Time\", \"Last Time\" });\n\t}","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setRow(FlexTable table, int row, int elementIndex) {\n    \tAlarm alarm = m_alarms[elementIndex];\n        table.setText(row, 0, alarm.getNodeLabel());\n        table.setHTML(row, 1, alarm.getDescrption());\n        table.setText(row, 2, \"\"+alarm.getCount());\n        table.getRowFormatter().setStyleName(row, alarm.getSeverity());\n    }","id":101599,"modified_method":"protected void setRow(FlexTable table, int row, int elementIndex) {\n    \tAlarm alarm = m_alarms[elementIndex];\n        table.setText(row, 0, alarm.getNodeLabel());\n        table.setHTML(row, 1, alarm.getDescrption());\n        table.setText(row, 2, \"\"+alarm.getCount());\n        table.setText(row, 3, alarm.getFirstEventTime().toString());\n        table.setText(row, 4, alarm.getLastEventTime().toString());\n        table.getRowFormatter().setStyleName(row, alarm.getSeverity());\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private NodeStatusDashlet createNodeStatusDashlet() {\n\n        final NodeStatusDashlet nodeStatus = new NodeStatusDashlet(this);\n        \n        AsyncCallback cb = new AsyncCallback() {\n\n            public void onFailure(Throwable e) {\n               error(e);\n            }\n\n            public void onSuccess(Object arg) {\n                nodeStatus.setNodes((String[])arg);\n            }\n            \n        };\n\n        getSurveillanceService().getNodeNames(null, cb);\n\n        m_nodeStatus = nodeStatus;\n        return m_nodeStatus;\n    }","id":101600,"modified_method":"private NodeStatusDashlet createNodeStatusDashlet() {\n        m_nodeStatus = new NodeStatusDashlet(this);\n        m_nodeStatus.setSurveillanceService(getSurveillanceService());\n        m_nodeStatus.setSurveillanceSet(SurveillanceSet.DEFAULT);\n        return m_nodeStatus;\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onModuleLoad() {\n\n        add(createSurveillanceDashlet(), \"surveillanceView\");\n        add(createAlarmDashlet(),        \"alarms\");\n        add(createGraphDashlet(),        \"graphs\");\n        add(createNotificationDashlet(), \"notifications\");\n        //add(createOutageDashlet(),       \"outages\");\n        //add(createNodeStatusDashlet(),   \"nodeStatus\");\n        \n        \n        setSurveillanceSet(SurveillanceSet.DEFAULT);\n        \n    }","id":101601,"modified_method":"public void onModuleLoad() {\n\n        add(createSurveillanceDashlet(), \"surveillanceView\");\n        add(createAlarmDashlet(),        \"alarms\");\n        add(createGraphDashlet(),        \"graphs\");\n        add(createNotificationDashlet(), \"notifications\");\n        //add(createOutageDashlet(),       \"outages\");\n        add(createNodeStatusDashlet(),   \"nodeStatus\");\n        \n        \n        setSurveillanceSet(SurveillanceSet.DEFAULT);\n        \n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RtcNodeModel getNodeList() {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsMonitoredService.class, \"monitoredService\");\n        criteria.add(Restrictions.eq(\"monitoredService.status\", \"A\"));\n        criteria.createAlias(\"ipInterface\", \"ipInterface\", CriteriaSpecification.INNER_JOIN);\n        criteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n        criteria.createAlias(\"ipInterface.node\", \"node\", CriteriaSpecification.INNER_JOIN);\n        criteria.add(Restrictions.ne(\"node.type\", \"D\"));\n        criteria.createAlias(\"serviceType\", \"serviceType\", CriteriaSpecification.INNER_JOIN);\n        criteria.createAlias(\"currentOutages\", \"currentOutages\", CriteriaSpecification.LEFT_JOIN);\n        criteria.addOrder(Order.asc(\"node.label\"));\n        criteria.addOrder(Order.asc(\"node.id\"));\n        criteria.addOrder(Order.asc(\"ipInterface.ipAddress\"));\n        criteria.addOrder(Order.asc(\"serviceType.name\"));\n        \n        OnmsCriteria outageCriteria = new OnmsCriteria(OnmsOutage.class, \"outage\");\n        outageCriteria.createAlias(\"monitoredService\", \"monitoredService\", CriteriaSpecification.INNER_JOIN);\n        outageCriteria.add(Restrictions.eq(\"monitoredService.status\", \"A\"));\n        outageCriteria.createAlias(\"monitoredService.ipInterface\", \"ipInterface\", CriteriaSpecification.INNER_JOIN);\n        outageCriteria.add(Restrictions.ne(\"ipInterface.isManaged\", \"D\"));\n        outageCriteria.createAlias(\"monitoredService.ipInterface.node\", \"node\", CriteriaSpecification.INNER_JOIN);\n        outageCriteria.add(Restrictions.ne(\"node.type\", \"D\"));\n        \n        Date periodEnd = new Date(System.currentTimeMillis());\n        Date periodStart = new Date(periodEnd.getTime() - (24 * 60 * 60 * 1000));\n        \n        Disjunction disjunction = Restrictions.disjunction();\n        disjunction.add(Restrictions.isNull(\"ifRegainedService\"));\n        disjunction.add(Restrictions.gt(\"ifLostService\", periodStart));\n        disjunction.add(Restrictions.gt(\"ifRegainedService\", periodStart));\n        outageCriteria.add(disjunction);\n        \n        outageCriteria.addOrder(Order.asc(\"monitoredService\"));\n        outageCriteria.addOrder(Order.asc(\"ifLostService\"));\n        \n        List<OnmsMonitoredService> services = m_monitoredServiceDao.findMatching(criteria);\n        List<OnmsOutage> outages = m_outageDao.findMatching(outageCriteria);\n        \n        Map<OnmsMonitoredService, Long> serviceDownTime = calculateServiceDownTime(periodEnd, periodStart, outages);\n        \n        RtcNodeModel model = new RtcNodeModel();\n        \n        OnmsNode lastNode = null;\n        int serviceCount = 0;\n        int serviceDownCount = 0;\n        long downMillisCount = 0;\n        for (OnmsMonitoredService service : services) {\n            if (!service.getIpInterface().getNode().equals(lastNode) && lastNode != null) {\n                Double availability = calculateAvailability(serviceCount, downMillisCount);\n                \n                model.addNode(new RtcNodeModel.RtcNode(lastNode, serviceCount, serviceDownCount, availability));\n                \n                serviceCount = 0;\n                serviceDownCount = 0;\n                downMillisCount = 0;\n            }\n            \n            serviceCount++;\n            if (service.isDown()) {\n                serviceDownCount++;\n            }\n            \n            Long downMillis = serviceDownTime.get(service);\n            if  (downMillis != null) {\n                downMillisCount += downMillis;\n            }\n            \n            lastNode = service.getIpInterface().getNode();\n        }\n        if (lastNode != null) {\n            Double availability = calculateAvailability(serviceCount, downMillisCount);\n            \n            model.addNode(new RtcNodeModel.RtcNode(lastNode, serviceCount, serviceDownCount, availability));\n        }\n        \n        return model;\n    }","id":101602,"modified_method":"public RtcNodeModel getNodeList() {\n        OnmsCriteria serviceCriteria = createServiceCriteria();\n        OnmsCriteria outageCriteria = createOutageCriteria();\n        \n        return getNodeListForCriteria(serviceCriteria, outageCriteria);\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<OnmsMonitoredService, Long> calculateServiceDownTime(Date periodEnd, Date periodStart, List<OnmsOutage> outages) {\n        Map<OnmsMonitoredService, Long> map = new HashMap<OnmsMonitoredService, Long>();\n        for (OnmsOutage outage : outages) {\n            if (map.get(outage.getMonitoredService()) == null) {\n                map.put(outage.getMonitoredService(), new Long(0));\n            }\n            \n            Date begin;\n            if (outage.getIfLostService().before(periodStart)) {\n                begin = periodStart;\n            } else {\n                begin = outage.getIfLostService();\n            }\n            \n            Date end;\n            if (outage.getIfRegainedService() == null || outage.getIfRegainedService().after(periodEnd)) {\n                end = periodEnd;\n            } else {\n                end = outage.getIfRegainedService();\n            }\n            \n            Long count = map.get(outage.getMonitoredService());\n            count += (end.getTime() - begin.getTime());\n            map.put(outage.getMonitoredService(), count);\n        }\n        return map;\n    }","id":101603,"modified_method":"private Map<OnmsMonitoredService, Long> calculateServiceDownTime(Date periodEnd, Date periodStart, List<OnmsOutage> outages) {\n        Map<OnmsMonitoredService, Long> map = new HashMap<OnmsMonitoredService, Long>();\n        for (OnmsOutage outage : outages) {\n            if (map.get(outage.getMonitoredService()) == null) {\n                map.put(outage.getMonitoredService(), new Long(0));\n            }\n            \n            Date begin;\n            if (outage.getIfLostService().before(periodStart)) {\n                begin = periodStart;\n            } else {\n                begin = outage.getIfLostService();\n            }\n            \n            Date end;\n            if (outage.getIfRegainedService() == null || !outage.getIfRegainedService().before(periodEnd)) {\n                end = periodEnd;\n            } else {\n                end = outage.getIfRegainedService();\n            }\n            \n            Long count = map.get(outage.getMonitoredService());\n            count += (end.getTime() - begin.getTime());\n            map.put(outage.getMonitoredService(), count);\n        }\n        return map;\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<Notification> convertOnmsNotificationToNotification(List<OnmsNotification> notifications, String severity) {\n        List<Notification> notifs = new ArrayList<Notification>(notifications.size());\n        \n        for (OnmsNotification notification : notifications) {\n            notifs.add(createNotification(notification, severity));\n        }\n        \n        return notifs;\n    }","id":101604,"modified_method":"private List<Notification> convertOnmsNotificationsToNotifications(List<OnmsNotification> notifications, String severity) {\n        List<Notification> notifs = new ArrayList<Notification>(notifications.size());\n        for (OnmsNotification notification : notifications) {\n            notifs.add(createNotification(notification, severity));\n        }\n        return notifs;\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private View getView() {\n        String user = getUsername();\n        log().debug(\"Looking for surveillance view that matches user '\" + user + \"'\");\n        \n        View userView = m_surveillanceViewConfigDao.getView(user);\n        if (userView != null) {\n            log().debug(\"Found surveillance view '\" + userView.getName() + \"' matching user name '\" + user + \"'\");\n            return userView;\n        }\n        \n        List<Group> groups = GroupFactory.getInstance().findGroupsForUser(user);\n        for (Group group : groups) {\n            View groupView = m_surveillanceViewConfigDao.getView(group.getName());\n            if (groupView != null) {\n                log().debug(\"Found surveillance view '\" + groupView.getName() + \"' matching group '\" + group.getName() + \"' name for user '\" + user + \"'\");\n                return groupView;\n            }\n        }\n        \n        log().debug(\"Did not find a surveillance view matching the user's user name or one of their group names.  Using the default view for user '\" + user + \"'\");\n        return m_surveillanceViewConfigDao.getDefaultView();\n    }","id":101605,"modified_method":"private View getView() {\n        String user = getUsername();\n        log().debug(\"Looking for surveillance view that matches user '\" + user + \"'\");\n        \n        View userView = m_surveillanceViewConfigDao.getView(user);\n        if (userView != null) {\n            log().debug(\"Found surveillance view '\" + userView.getName() + \"' matching user name '\" + user + \"'\");\n            return userView;\n        }\n        \n        List<Group> groups = m_groupDao.findGroupsForUser(user);\n        for (Group group : groups) {\n            View groupView = m_surveillanceViewConfigDao.getView(group.getName());\n            if (groupView != null) {\n                log().debug(\"Found surveillance view '\" + groupView.getName() + \"' matching group '\" + group.getName() + \"' name for user '\" + user + \"'\");\n                return groupView;\n            }\n        }\n        \n        View defaultView = m_surveillanceViewConfigDao.getDefaultView();\n        Assert.state(defaultView != null, \"there is no default surveillance view and we could not find a surviellance view for the user's username or any of their groups\");\n        log().debug(\"Did not find a surveillance view matching the user's user name or one of their group names.  Using the default view for user '\" + user + \"'\");\n        return defaultView;\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        Assert.state(m_nodeDao != null, \"nodeDao property must be set and cannot be null\");\n        Assert.state(m_resourceDao != null, \"resourceDao property must be set and cannot be null\");\n        Assert.state(m_graphDao != null, \"graphDao property must be set and cannot be null\");\n        Assert.state(m_webSurveillanceService != null, \"webSurveillanceService property must be set and cannot be null\");\n        Assert.state(m_surveillanceViewConfigDao != null, \"surveillanceViewConfigDao property must be set and cannot be null\");\n        Assert.state(m_categoryDao != null, \"categoryDao property must be set and cannot be null\");\n        Assert.state(m_alarmDao != null, \"alarmDao property must be set and cannot be null\");\n        Assert.state(m_notificationDao != null, \"notificationDao property must be set and cannot be null\");\n        Assert.state(m_groupManager != null, \"groupManager property must be set and cannot be null\");\n    }","id":101606,"modified_method":"public void afterPropertiesSet() throws Exception {\n        Assert.state(m_nodeDao != null, \"nodeDao property must be set and cannot be null\");\n        Assert.state(m_resourceDao != null, \"resourceDao property must be set and cannot be null\");\n        Assert.state(m_graphDao != null, \"graphDao property must be set and cannot be null\");\n        Assert.state(m_webSurveillanceService != null, \"webSurveillanceService property must be set and cannot be null\");\n        Assert.state(m_surveillanceViewConfigDao != null, \"surveillanceViewConfigDao property must be set and cannot be null\");\n        Assert.state(m_categoryDao != null, \"categoryDao property must be set and cannot be null\");\n        Assert.state(m_alarmDao != null, \"alarmDao property must be set and cannot be null\");\n        Assert.state(m_notificationDao != null, \"notificationDao property must be set and cannot be null\");\n        Assert.state(m_rtcService != null, \"rtcService property must be set and cannot be null\");\n        Assert.state(m_groupDao != null, \"groupDao property must be set and cannot be null\");\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Alarm[] getAlarmsForSet(SurveillanceSet set) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsAlarm.class, \"alarm\");\n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        criteria.addOrder(Order.desc(\"alarm.severity\"));\n        \n        List<OnmsAlarm> alarms = m_alarmDao.findMatching(criteria);\n\n        Alarm[] alarmArray = new Alarm[alarms.size()];\n        \n        int index = 0;\n        for (OnmsAlarm alarm : alarms) {\n            alarmArray[index] = new Alarm(getSeverityString(alarm.getSeverity()), alarm.getNode().getLabel(), alarm.getDescription(), alarm.getCounter());\n            index++;\n        }\n        \n        return alarmArray;\n    }","id":101607,"modified_method":"public Alarm[] getAlarmsForSet(SurveillanceSet set) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsAlarm.class, \"alarm\");\n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        criteria.addOrder(Order.desc(\"alarm.severity\"));\n        \n        List<OnmsAlarm> alarms = m_alarmDao.findMatching(criteria);\n\n        Alarm[] alarmArray = new Alarm[alarms.size()];\n        \n        int index = 0;\n        for (OnmsAlarm alarm : alarms) {\n            alarmArray[index] = new Alarm(getSeverityString(alarm.getSeverity()), alarm.getNode().getLabel(), alarm.getDescription(), alarm.getCounter(), new Date(alarm.getFirstEventTime().getTime()), new Date(alarm.getLastEventTime().getTime()));\n            index++;\n        }\n        \n        return alarmArray;\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Notification[] getNotificationsForSet(SurveillanceSet set) {\n        List<Notification> notifications = new ArrayList<Notification>();\n        \n        Date fifteenMinutesAgo = new Date(System.currentTimeMillis() - (15 * 60 * 1000));\n        Date oneWeekAgo = new Date(System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000));\n        \n        notifications.addAll(convertOnmsNotificationToNotification(getNotificationsWithCriterion(set, Order.desc(\"notification.pageTime\"), Restrictions.isNull(\"notification.respondTime\"), Restrictions.le(\"notification.pageTime\", fifteenMinutesAgo)), \"Critical\"));\n        notifications.addAll(convertOnmsNotificationToNotification(getNotificationsWithCriterion(set, Order.desc(\"notification.pageTime\"), Restrictions.isNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", fifteenMinutesAgo)), \"Minor\"));\n        notifications.addAll(convertOnmsNotificationToNotification(getNotificationsWithCriterion(set, Order.desc(\"notification.pageTime\"), Restrictions.isNotNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", oneWeekAgo)), \"Normal\"));\n\n        \n        return notifications.toArray(new Notification[notifications.size()]);\n    }","id":101608,"modified_method":"public Notification[] getNotificationsForSet(SurveillanceSet set) {\n        List<Notification> notifications = new ArrayList<Notification>();\n        \n        Date fifteenMinutesAgo = new Date(System.currentTimeMillis() - (15 * 60 * 1000));\n        Date oneWeekAgo = new Date(System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000));\n        \n        notifications.addAll(getNotificationsWithCriterion(set, \"Critical\", Restrictions.isNull(\"notification.respondTime\"), Restrictions.le(\"notification.pageTime\", fifteenMinutesAgo)));\n        notifications.addAll(getNotificationsWithCriterion(set, \"Minor\", Restrictions.isNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", fifteenMinutesAgo)));\n        notifications.addAll(getNotificationsWithCriterion(set, \"Normal\", Restrictions.isNotNull(\"notification.respondTime\"), Restrictions.gt(\"notification.pageTime\", oneWeekAgo)));\n\n        \n        return notifications.toArray(new Notification[notifications.size()]);\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<OnmsNotification> getNotificationsWithCriterion(SurveillanceSet set, Order order, Criterion... criterions) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNotification.class, \"notification\");\n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        for (Criterion criterion : criterions) {\n            criteria.add(criterion);\n        }\n        criteria.addOrder(order);\n        \n        return m_notificationDao.findMatching(criteria);\n    }","id":101609,"modified_method":"private List<Notification> getNotificationsWithCriterion(SurveillanceSet set, String severity, Criterion... criterions) {\n        OnmsCriteria criteria = new OnmsCriteria(OnmsNotification.class, \"notification\");\n        \n        OnmsCriteria nodeCriteria = criteria.createCriteria(\"node\");\n        addCriteriaForSurveillanceSet(nodeCriteria, set);\n        \n        nodeCriteria.add(Restrictions.ne(\"type\", \"D\"));\n        for (Criterion criterion : criterions) {\n            criteria.add(criterion);\n        }\n        \n        criteria.addOrder(Order.desc(\"notification.pageTime\"));\n        \n        List<OnmsNotification> notifications = m_notificationDao.findMatching(criteria);\n        \n        return convertOnmsNotificationsToNotifications(notifications, severity);\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testGetUsernameWithUserDetails() {\n        UserDetails details = new User(\"user\", \"password\", true, true, true, true, new GrantedAuthority[0]);\n        Authentication auth = new UsernamePasswordAuthenticationToken(details, null, details.getAuthorities());\n        SecurityContextHolder.getContext().setAuthentication(auth);\n        \n        String user = m_service.getUsername();\n        assertNotNull(\"user should not be null\", user);\n        assertEquals(\"user name\", details.getUsername(), user);\n    }","id":101610,"modified_method":"public void testGetUsernameWithUserDetails() {\n        UserDetails details = populateSecurityContext();\n        \n        String user = m_service.getUsername();\n        assertNotNull(\"user should not be null\", user);\n        assertEquals(\"user name\", details.getUsername(), user);\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public NodeStatusDashlet(Dashboard dashboard) {\n        super(dashboard, \"Node Status\");\n        \n        setView(m_listBox);\n    }","id":101611,"modified_method":"public NodeStatusDashlet(Dashboard dashboard) {\n        super(dashboard, \"Node Status\");\n        setLoader(m_loader);\n        setView(m_view);\n    }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String toString() {\n            return m_node.getLabel() + \": \" + m_downServiceCount + \" of \" + m_serviceCount + \": \" + AVAILABILITY_FORMAT.format(m_availability);\n        }","id":101612,"modified_method":"public String toString() {\n            return m_node.getLabel() + \": \" + m_downServiceCount + \" of \" + m_serviceCount + \": \" + getAvailabilityAsString();\n        }","commit_id":"846d14b50a7aebd2cb959afc76b556c92dcadf78","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static String _trim(String value) {\n\t\tif (value != null) {\n\t\t\tvalue = value.trim();\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tchar[] charArray = value.toCharArray();\n\n\t\t\tfor (int i = 0; i < charArray.length; i++) {\n\t\t\t\tif ((Character.isDigit(charArray[i])) ||\n\t\t\t\t\t((charArray[i] == CharPool.DASH) && (i == 0)) ||\n\t\t\t\t\t(charArray[i] == CharPool.PERIOD) ||\n\t\t\t\t\t(charArray[i] == CharPool.UPPER_CASE_E) ||\n\t\t\t\t\t(charArray[i] == CharPool.LOWER_CASE_E)) {\n\n\t\t\t\t\tsb.append(charArray[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalue = sb.toString();\n\t\t}\n\n\t\treturn value;\n\t}","id":101613,"modified_method":"private static String _trim(String value) {\n\t\tvalue = value.trim();\n\n\t\tStringBuilder sb = new StringBuilder(value.length());\n\n\t\tfor (int i = 0; i < value.length(); i++) {\n\t\t\tchar ch = value.charAt(i);\n\t\t\tif ((Character.isDigit(ch)) ||\n\t\t\t\t((ch == CharPool.DASH) && (i == 0)) ||\n\t\t\t\t(ch == CharPool.PERIOD) || (ch == CharPool.UPPER_CASE_E) ||\n\t\t\t\t(ch == CharPool.LOWER_CASE_E)) {\n\n\t\t\t\tsb.append(ch);\n\t\t\t}\n\t\t}\n\n\t\tvalue = sb.toString();\n\n\t\treturn value;\n\t}","commit_id":"092886d801bfe8a5af44a01dbd641d8fcc12123a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static long get(String value, long defaultValue) {\n\t\ttry {\n\t\t\treturn Long.parseLong(_trim(value));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":101614,"modified_method":"public static long get(String value, long defaultValue) {\n\t\tif (value == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn _parseLong(_trim(value), defaultValue);\n\t}","commit_id":"092886d801bfe8a5af44a01dbd641d8fcc12123a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static float get(String value, float defaultValue) {\n\t\ttry {\n\t\t\treturn Float.parseFloat(_trim(value));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":101615,"modified_method":"public static float get(String value, float defaultValue) {\n\t\tif (value != null) {\n\t\t\ttry {\n\t\t\t\treturn Float.parseFloat(_trim(value));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t\treturn defaultValue;\n\t}","commit_id":"092886d801bfe8a5af44a01dbd641d8fcc12123a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int get(String value, int defaultValue) {\n\t\ttry {\n\t\t\treturn Integer.parseInt(_trim(value));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":101616,"modified_method":"public static int get(String value, int defaultValue) {\n\t\tif (value == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn _parseInt(_trim(value), defaultValue);\n\t}","commit_id":"092886d801bfe8a5af44a01dbd641d8fcc12123a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static short get(String value, short defaultValue) {\n\t\ttry {\n\t\t\treturn Short.parseShort(_trim(value));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":101617,"modified_method":"public static short get(String value, short defaultValue) {\n\t\tif (value == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn _parseShort(_trim(value), defaultValue);\n\t}","commit_id":"092886d801bfe8a5af44a01dbd641d8fcc12123a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Date get(String value, DateFormat df, Date defaultValue) {\n\t\ttry {\n\t\t\tDate date = df.parse(value.trim());\n\n\t\t\tif (date != null) {\n\t\t\t\treturn date;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":101618,"modified_method":"public static Date get(String value, DateFormat df, Date defaultValue) {\n\t\tif (value != null) {\n\t\t\ttry {\n\t\t\t\tDate date = df.parse(value.trim());\n\n\t\t\t\tif (date != null) {\n\t\t\t\t\treturn date;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t\treturn defaultValue;\n\t}","commit_id":"092886d801bfe8a5af44a01dbd641d8fcc12123a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static double get(String value, double defaultValue) {\n\t\ttry {\n\t\t\treturn Double.parseDouble(_trim(value));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":101619,"modified_method":"public static double get(String value, double defaultValue) {\n\t\tif (value != null) {\n\t\t\ttry {\n\t\t\t\treturn Double.parseDouble(_trim(value));\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t\treturn defaultValue;\n\t}","commit_id":"092886d801bfe8a5af44a01dbd641d8fcc12123a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void commonFinishEdit(HttpServletRequest request, Basethresholddef baseDef) {\n        String dsLabel = request.getParameter(\"dsLabel\");\n        if (dsLabel == null || \"\".equals(dsLabel)) {\n            baseDef.setDsLabel(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setDsLabel(dsLabel);\n        }\n\n        String description = request.getParameter(\"description\");\n        if (description == null || \"\".equals(description)) {\n            baseDef.setDescription(null);\n        }\n        else {\n            baseDef.setDescription(description);\n        }\n\n        String triggeredUEI = request.getParameter(\"triggeredUEI\");\n        if (triggeredUEI == null || \"\".equals(triggeredUEI)) {\n            baseDef.setTriggeredUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setTriggeredUEI(triggeredUEI);\n            this.ensureUEIInEventConf(triggeredUEI, \"exceeded\");\n        }\n\n        String rearmedUEI = request.getParameter(\"rearmedUEI\");\n        if (rearmedUEI == null || \"\".equals(rearmedUEI)) {\n            baseDef.setRearmedUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setRearmedUEI(rearmedUEI);\n            this.ensureUEIInEventConf(rearmedUEI, \"rearmed\");\n        }\n        baseDef.setDsType(request.getParameter(\"dsType\"));\n        baseDef.setType(request.getParameter(\"type\"));\n        baseDef.setRearm(WebSecurityUtils.safeParseDouble(request.getParameter(\"rearm\")));\n        baseDef.setTrigger(WebSecurityUtils.safeParseInt(request.getParameter(\"trigger\")));\n        baseDef.setValue(WebSecurityUtils.safeParseDouble(request.getParameter(\"value\")));\n\n    }","id":101620,"modified_method":"private void commonFinishEdit(HttpServletRequest request, Basethresholddef baseDef) {\n        String dsLabel = request.getParameter(\"dsLabel\");\n        if (dsLabel == null || \"\".equals(dsLabel)) {\n            baseDef.setDsLabel(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setDsLabel(dsLabel);\n        }\n\n        String description = request.getParameter(\"description\");\n        if (description == null || \"\".equals(description)) {\n            baseDef.setDescription(null);\n        }\n        else {\n            baseDef.setDescription(description);\n        }\n\n        baseDef.setDsType(request.getParameter(\"dsType\"));\n        baseDef.setType(request.getParameter(\"type\"));\n        baseDef.setRearm(WebSecurityUtils.safeParseDouble(request.getParameter(\"rearm\")));\n        baseDef.setTrigger(WebSecurityUtils.safeParseInt(request.getParameter(\"trigger\")));\n        baseDef.setValue(WebSecurityUtils.safeParseDouble(request.getParameter(\"value\")));\n\n        String clearKey = null;\n\n        String triggeredUEI = request.getParameter(\"triggeredUEI\");\n        if (triggeredUEI == null || \"\".equals(triggeredUEI)) {\n            baseDef.setTriggeredUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            org.opennms.netmgt.xml.eventconf.Event source = getSourceEvent(baseDef.getType(), true);\n            if (source != null && source.getAlarmData() != null && source.getAlarmData().getReductionKey() != null) {\n                clearKey = source.getAlarmData().getReductionKey().replace(\"%uei%\", triggeredUEI);\n            }\n            baseDef.setTriggeredUEI(triggeredUEI);\n            this.ensureUEIInEventConf(source, triggeredUEI, baseDef.getType(), null, true);\n        }\n\n        String rearmedUEI = request.getParameter(\"rearmedUEI\");\n        if (rearmedUEI == null || \"\".equals(rearmedUEI) || baseDef.getType().equals(\"relativeChange\") || baseDef.getType().equals(\"absoluteChange\")) { // It doesn't make sense a rearm UEI for relativeChange or absoluteChange\n            baseDef.setRearmedUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            org.opennms.netmgt.xml.eventconf.Event source = getSourceEvent(baseDef.getType(), false);\n            baseDef.setRearmedUEI(rearmedUEI);\n            this.ensureUEIInEventConf(source, rearmedUEI, baseDef.getType(), clearKey, false);\n        }\n    }","commit_id":"f67eabdfaad3a0b364e09f12c320617b1b4f0038","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void startServer() throws Exception\n    {\n        logger.debug(\"starting server on port \" + port);\n        ServerSetup setup = new ServerSetup(port, null, protocol);\n        server = new GreenMail(setup);\n        server.start();\n        if (protocol.startsWith(Pop3Connector.POP3) || protocol.startsWith(ImapConnector.IMAP))\n        {\n            GreenMailUtilities.storeEmail(server.getManagers().getUserManager(),\n                    email, user, password,\n                    GreenMailUtilities.toMessage(message, email));\n        }\n        logger.debug(\"server started for protocol \" + protocol);\n    }","id":101621,"modified_method":"private void startServer() throws Exception\n    {\n        logger.debug(\"starting server on port \" + port);\n        ServerSetup setup = new ServerSetup(port, null, protocol);\n        server = new GreenMail(setup);\n        server.start();\n        if (protocol.startsWith(Pop3Connector.POP3) || protocol.startsWith(ImapConnector.IMAP))\n        {\n            GreenMailUtilities.storeEmail(server.getManagers().getUserManager(),\n                    email, user, password,\n                    GreenMailUtilities.toMessage(message, email, charset));\n        }\n        logger.debug(\"server started for protocol \" + protocol);\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doSend() throws Exception\n    {\n        Object msg;\n        if (isMimeMessage)\n        {\n            msg = GreenMailUtilities.toMessage(message, email);\n        }\n        else\n        {\n            msg = message;\n        }\n\n        MuleClient client = new MuleClient();\n        client.send(\"vm://send\", msg, null);\n\n        server.waitForIncomingEmail(DELIVERY_DELAY_MS, 1);\n\n        MimeMessage[] messages = server.getReceivedMessages();\n        assertNotNull(\"did not receive any messages\", messages);\n        assertEquals(\"did not receive 1 mail\", 1, messages.length);\n        verifyMessage(messages[0]);\n    }","id":101622,"modified_method":"protected void doSend() throws Exception\n    {\n        Object msg;\n        if (isMimeMessage)\n        {\n            msg = GreenMailUtilities.toMessage(message, email, charset);\n        }\n        else\n        {\n            msg = message;\n        }\n\n        MuleClient client = new MuleClient();\n    \tMap<String, Object> props = null;\n        if (charset != null)\n        {\n        \tprops = new HashMap<String, Object>();\n        \tprops.put(MailProperties.CONTENT_TYPE_PROPERTY, \"text/plain; charset=\" + charset);\n        } \n        client.send(\"vm://send\", msg, props);        \t\n\n        server.waitForIncomingEmail(DELIVERY_DELAY_MS, 1);\n\n        MimeMessage[] messages = server.getReceivedMessages();\n        assertNotNull(\"did not receive any messages\", messages);\n        assertEquals(\"did not receive 1 mail\", 1, messages.length);\n        verifyMessage(messages[0]);\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"protected AbstractEmailFunctionalTestCase(int port, boolean isMimeMessage, String protocol, String configFile,\n                                              String email, String user, String message,\n                                              String password)\n    {\n        this.isMimeMessage = isMimeMessage;\n        this.protocol = protocol;\n        this.port = port;\n        this.configFile = configFile;\n        this.email = email;\n        this.user = user;\n        this.message = message;\n        this.password = password;\n    }","id":101623,"modified_method":"protected AbstractEmailFunctionalTestCase(int port, boolean isMimeMessage, String protocol, \n        String configFile, String email, String user, String message, String password, String charset)\n    {\n        this.isMimeMessage = isMimeMessage;\n        this.protocol = protocol;\n        this.port = port;\n        this.configFile = configFile;\n        this.email = email;\n        this.user = user;\n        this.message = message;\n        this.password = password;\n        this.charset = charset;\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"protected AbstractEmailFunctionalTestCase(int port, boolean isMimeMessage, String protocol)\n    {\n        this(port, isMimeMessage, protocol, protocol + CONFIG_BASE);\n    }","id":101624,"modified_method":"protected AbstractEmailFunctionalTestCase(int port, boolean isMimeMessage, String protocol)\n    {\n        this(port, isMimeMessage, protocol, protocol + CONFIG_BASE, null, null);\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"protected AbstractEmailFunctionalTestCase(int port, boolean isMimeMessage, String protocol, String configFile)\n    {\n        this(port, isMimeMessage, protocol, configFile,\n                DEFAULT_EMAIL, DEFAULT_USER, DEFAULT_MESSAGE, DEFAULT_PASSWORD);\n    }","id":101625,"modified_method":"protected AbstractEmailFunctionalTestCase(int port, boolean isMimeMessage, String protocol, String configFile)\n    {\n        this(port, isMimeMessage, protocol, configFile, null, null);\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public Object getValidMessage() throws Exception\n    {\n        if (null == message)\n        {\n            message = GreenMailUtilities.toMessage(MESSAGE, EMAIL);\n        }\n        return message;\n    }","id":101626,"modified_method":"@Override\n    public Object getValidMessage() throws Exception\n    {\n        if (null == message)\n        {\n            message = GreenMailUtilities.toMessage(MESSAGE, EMAIL, null);\n        }\n        return message;\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"public static MimeMessage toMessage(String text, String email) throws MessagingException\n    {\n        MimeMessage message = new MimeMessage(Session.getDefaultInstance(new Properties()));\n        message.setContent(text, \"text/plain\");\n        message.setRecipient(Message.RecipientType.TO, new InternetAddress(email));\n        return message;\n    }","id":101627,"modified_method":"public static MimeMessage toMessage(String text, String email, String charset) throws MessagingException\n    {\n        MimeMessage message = new MimeMessage(Session.getDefaultInstance(new Properties()));\n        if (charset != null) \n        {\n            message.setContent(text, \"text/plain; charset=\" + charset);\n        } \n        else \n        {\n        \tmessage.setContent(text, \"text/plain\");\n        }\n        message.setRecipient(Message.RecipientType.TO, new InternetAddress(email));\n        return message;\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testStringSourceTypeWithIgnoreBadInput() throws Exception\n    {\n        AbstractTransformer trans = (AbstractTransformer) getTransformer();\n        trans.setIgnoreBadInput(true);\n        Object result = trans.transform(getResultData());\n        trans.setIgnoreBadInput(false);\n        assertSame(result, getResultData());\n    }","id":101628,"modified_method":"public void testStringSourceTypeWithIgnoreBadInput() throws Exception\n    {\n        AbstractTransformer trans = (AbstractTransformer) getTransformer();\n        trans.setIgnoreBadInput(true);\n        Object result = trans.transform(getResultData());\n        trans.setIgnoreBadInput(false);\n        assertEquals(result, getResultData());\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object getTestData()\n    {\n        if (message == null)\n        {\n            message = new MimeMessage(Session.getDefaultInstance(new Properties()));\n            try\n            {\n                message.setContent(getResultData(), \"text/plain\");\n            }\n            catch (MessagingException e)\n            {\n                throw new RuntimeException(\"Failed to create Mime Message: \" + e.getMessage(), e);\n            }\n        }\n        return message;\n    }","id":101629,"modified_method":"@Override\n    public Object getTestData()\n    {\n        if (message == null)\n        {\n            message = new MimeMessage(Session.getDefaultInstance(new Properties()));\n            try\n            {\n                message.setContent(getResultData(), getContentType());\n            }\n            catch (MessagingException e)\n            {\n                throw new RuntimeException(\"Failed to create Mime Message: \" + e.getMessage(), e);\n            }\n        }\n        return message;\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"protected MimeMessage newMimeMessage() throws MessagingException\n    {\n        MimeMessage message = new MimeMessage(newSession());\n        message.setText(\"text\");\n        message.setFrom(new InternetAddress(\"bob@example.com\"));\n        return message;\n    }","id":101630,"modified_method":"protected MimeMessage newMimeMessage() throws MessagingException\n    {\n        MimeMessage message = new MimeMessage(newSession());\n        message.setText(\"text\");\n        message.setSubject(\"text\");\n        message.setFrom(new InternetAddress(\"bob@example.com\"));\n        return message;\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testToByteArrayAndBack() throws MessagingException, MuleException, IOException\n    {\n        MimeMessage first = newMimeMessage();\n        byte[] bytes = mimeMessageToByteArray(first);\n        MimeMessage second = byteArrayToMimeMessage(bytes);\n        assertEquals(first.getContent(), second.getContent());\n        assertEquals(1, second.getFrom().length);\n        assertEquals(first.getFrom().length, second.getFrom().length);\n        assertEquals(first.getFrom()[0], second.getFrom()[0]);\n    }","id":101631,"modified_method":"public void testToByteArrayAndBack() throws MessagingException, MuleException, IOException\n    {\n        MimeMessage first = newMimeMessage();\n        byte[] bytes = mimeMessageToByteArray(first);\n        MimeMessage second = byteArrayToMimeMessage(bytes);\n        assertEquals(first.getSubject(), second.getSubject());\n        assertEquals(first.getContent(), second.getContent());\n        assertEquals(1, second.getFrom().length);\n        assertEquals(first.getFrom().length, second.getFrom().length);\n        assertEquals(first.getFrom()[0], second.getFrom()[0]);\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(MuleMessage message, String outputEncoding) throws TransformerException\n    {\n        String endpointAddress = endpoint.getEndpointURI().getAddress();\n        SmtpConnector connector = (SmtpConnector) endpoint.getConnector();\n        String to = message.getStringProperty(MailProperties.TO_ADDRESSES_PROPERTY, endpointAddress);\n        String cc = message.getStringProperty(MailProperties.CC_ADDRESSES_PROPERTY,\n            connector.getCcAddresses());\n        String bcc = message.getStringProperty(MailProperties.BCC_ADDRESSES_PROPERTY,\n            connector.getBccAddresses());\n        String from = message.getStringProperty(MailProperties.FROM_ADDRESS_PROPERTY,\n            connector.getFromAddress());\n        String replyTo = message.getStringProperty(MailProperties.REPLY_TO_ADDRESSES_PROPERTY,\n            connector.getReplyToAddresses());\n        String subject = message.getStringProperty(MailProperties.SUBJECT_PROPERTY, connector.getSubject());\n        String contentType = message.getStringProperty(MailProperties.CONTENT_TYPE_PROPERTY,\n            connector.getContentType());\n\n        Properties headers = new Properties();\n        Properties customHeaders = connector.getCustomHeaders();\n\n        if (customHeaders != null && !customHeaders.isEmpty())\n        {\n            headers.putAll(customHeaders);\n        }\n\n        Properties otherHeaders = (Properties) message.getProperty(MailProperties.CUSTOM_HEADERS_MAP_PROPERTY);\n        if (otherHeaders != null && !otherHeaders.isEmpty())\n        {\n                //TODO Whats going on here?\n//                final MuleContext mc = context.getMuleContext();\n//                for (Iterator iterator = message.getPropertyNames().iterator(); iterator.hasNext();)\n//                {\n//                    String propertyKey = (String) iterator.next();\n//                    mc.getRegistry().registerObject(propertyKey, message.getProperty(propertyKey), mc);\n//                }\n                headers.putAll(templateParser.parse(new TemplateParser.TemplateCallback()\n                {\n                    public Object match(String token)\n                    {\n                        return muleContext.getRegistry().lookupObject(token);\n                    }\n                }, otherHeaders));\n\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            StringBuffer buf = new StringBuffer();\n            buf.append(\"Constructing email using:\\n\");\n            buf.append(\"To: \").append(to);\n            buf.append(\"From: \").append(from);\n            buf.append(\"CC: \").append(cc);\n            buf.append(\"BCC: \").append(bcc);\n            buf.append(\"Subject: \").append(subject);\n            buf.append(\"ReplyTo: \").append(replyTo);\n            buf.append(\"Content type: \").append(contentType);\n            buf.append(\"Payload type: \").append(message.getPayload().getClass().getName());\n            buf.append(\"Custom Headers: \").append(MapUtils.toString(headers, false));\n            logger.debug(buf.toString());\n        }\n\n        try\n        {\n            Message email = new MimeMessage(((SmtpConnector) endpoint.getConnector()).getSessionDetails(endpoint).getSession());\n\n            email.setRecipients(Message.RecipientType.TO, MailUtils.stringToInternetAddresses(to));\n\n            // sent date\n            email.setSentDate(Calendar.getInstance().getTime());\n\n            if (StringUtils.isNotBlank(from))\n            {\n                email.setFrom(MailUtils.stringToInternetAddresses(from)[0]);\n            }\n\n            if (StringUtils.isNotBlank(cc))\n            {\n                email.setRecipients(Message.RecipientType.CC, MailUtils.stringToInternetAddresses(cc));\n            }\n\n            if (StringUtils.isNotBlank(bcc))\n            {\n                email.setRecipients(Message.RecipientType.BCC, MailUtils.stringToInternetAddresses(bcc));\n            }\n\n            if (StringUtils.isNotBlank(replyTo))\n            {\n                email.setReplyTo(MailUtils.stringToInternetAddresses(replyTo));\n            }\n\n            email.setSubject(subject);\n\n            for (Iterator iterator = headers.entrySet().iterator(); iterator.hasNext();)\n            {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                email.setHeader(entry.getKey().toString(), entry.getValue().toString());\n            }\n\n            setContent(message.getPayload(), email, contentType, message);\n\n            return email;\n        }\n        catch (Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","id":101632,"modified_method":"public Object transform(MuleMessage message, String outputEncoding) throws TransformerException\n    {\n        String endpointAddress = endpoint.getEndpointURI().getAddress();\n        SmtpConnector connector = (SmtpConnector) endpoint.getConnector();\n        String to = message.getStringProperty(MailProperties.TO_ADDRESSES_PROPERTY, endpointAddress);\n        String cc = message.getStringProperty(MailProperties.CC_ADDRESSES_PROPERTY,\n            connector.getCcAddresses());\n        String bcc = message.getStringProperty(MailProperties.BCC_ADDRESSES_PROPERTY,\n            connector.getBccAddresses());\n        String from = message.getStringProperty(MailProperties.FROM_ADDRESS_PROPERTY,\n            connector.getFromAddress());\n        String replyTo = message.getStringProperty(MailProperties.REPLY_TO_ADDRESSES_PROPERTY,\n            connector.getReplyToAddresses());\n        String subject = message.getStringProperty(MailProperties.SUBJECT_PROPERTY, connector.getSubject());\n        String contentType = message.getStringProperty(MailProperties.CONTENT_TYPE_PROPERTY,\n            connector.getContentType());\n\n        Properties headers = new Properties();\n        Properties customHeaders = connector.getCustomHeaders();\n\n        if (customHeaders != null && !customHeaders.isEmpty())\n        {\n            headers.putAll(customHeaders);\n        }\n\n        Properties otherHeaders = (Properties) message.getProperty(MailProperties.CUSTOM_HEADERS_MAP_PROPERTY);\n        if (otherHeaders != null && !otherHeaders.isEmpty())\n        {\n                //TODO Whats going on here?\n//                final MuleContext mc = context.getMuleContext();\n//                for (Iterator iterator = message.getPropertyNames().iterator(); iterator.hasNext();)\n//                {\n//                    String propertyKey = (String) iterator.next();\n//                    mc.getRegistry().registerObject(propertyKey, message.getProperty(propertyKey), mc);\n//                }\n                headers.putAll(templateParser.parse(new TemplateParser.TemplateCallback()\n                {\n                    public Object match(String token)\n                    {\n                        return muleContext.getRegistry().lookupObject(token);\n                    }\n                }, otherHeaders));\n\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            StringBuffer buf = new StringBuffer();\n            buf.append(\"Constructing email using:\\n\");\n            buf.append(\"To: \").append(to);\n            buf.append(\", From: \").append(from);\n            buf.append(\", CC: \").append(cc);\n            buf.append(\", BCC: \").append(bcc);\n            buf.append(\", Subject: \").append(subject);\n            buf.append(\", ReplyTo: \").append(replyTo);\n            buf.append(\", Content type: \").append(contentType);\n            buf.append(\", Payload type: \").append(message.getPayload().getClass().getName());\n            buf.append(\", Custom Headers: \").append(MapUtils.toString(headers, false));\n            logger.debug(buf.toString());\n        }\n\n        try\n        {\n            Message email = new MimeMessage(((SmtpConnector) endpoint.getConnector()).getSessionDetails(endpoint).getSession());\n\n            email.setRecipients(Message.RecipientType.TO, MailUtils.stringToInternetAddresses(to));\n\n            // sent date\n            email.setSentDate(Calendar.getInstance().getTime());\n\n            if (StringUtils.isNotBlank(from))\n            {\n                email.setFrom(MailUtils.stringToInternetAddresses(from)[0]);\n            }\n\n            if (StringUtils.isNotBlank(cc))\n            {\n                email.setRecipients(Message.RecipientType.CC, MailUtils.stringToInternetAddresses(cc));\n            }\n\n            if (StringUtils.isNotBlank(bcc))\n            {\n                email.setRecipients(Message.RecipientType.BCC, MailUtils.stringToInternetAddresses(bcc));\n            }\n\n            if (StringUtils.isNotBlank(replyTo))\n            {\n                email.setReplyTo(MailUtils.stringToInternetAddresses(replyTo));\n            }\n\n            email.setSubject(subject);\n\n            for (Iterator iterator = headers.entrySet().iterator(); iterator.hasNext();)\n            {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                email.setHeader(entry.getKey().toString(), entry.getValue().toString());\n            }\n\n            setContent(message.getPayload(), email, contentType, message);\n\n            return email;\n        }\n        catch (Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"638bd266699c21066624d87029d611b58fb32267","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n  public void handleUpstream( ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n    if ( e instanceof MessageEvent && ( ( MessageEvent ) e ).getMessage( ) instanceof MappingHttpRequest ) {\n      MappingHttpRequest request = ( MappingHttpRequest ) ( ( MessageEvent ) e ).getMessage( );\n      String newUri = null;\n      String uri = request.getUri( );\n      InetSocketAddress remoteAddr = ( ( InetSocketAddress ) ctx.getChannel( ).getRemoteAddress( ) );\n      String remoteHost = remoteAddr.getAddress( ).getHostAddress( );//\"10.1.1.2\";//\n      if ( uri.startsWith( \"/latest/\" ) )\n        newUri = uri.replaceAll( \"/latest/\", remoteHost + \":\" );\n      else newUri = uri.replaceAll( \"/\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d/\", remoteHost + \":\" );\n      \n      HttpResponse response = null;\n      LOG.trace( \"Trying to get metadata: \" + newUri );\n      Object reply = \"\".getBytes( );\n      Exception replyEx = null;\n      try {\n        if ( Bootstrap.isShuttingDown( ) ) {\n          reply = \"System shutting down\".getBytes( );\n        } else if ( !Bootstrap.isFinished( ) ) {\n          reply = \"System is still starting up\".getBytes( );\n        } else {\n          reply = ServiceContext.send( \"VmMetadata\", newUri );\n        }\n      } catch ( ServiceDispatchException e1 ) {\n        LOG.debug( e1, e1 );\n        replyEx = e1;\n      } catch ( Exception e1 ) {\n        LOG.debug( e1, e1 );\n        replyEx = e1;\n      } finally {\n        Contexts.clear( request.getCorrelationId( ) );\n      }\n      Logs.extreme( ).debug( \"VmMetadata reply info: \" + reply + \" \" + replyEx );\n      if ( replyEx != null || reply == null || reply instanceof NullPayload ) {\n        response = new DefaultHttpResponse( request.getProtocolVersion( ), HttpResponseStatus.NOT_FOUND );\n        if ( Logs.isDebug( ) ) {\n          response.setHeader( HttpHeaders.Names.CONTENT_TYPE, \"text/plain\" );\n          ChannelBuffer buffer = ChannelBuffers.wrappedBuffer( Exceptions.string( replyEx ).getBytes( ) );\n          response.setContent( buffer );\n          response.addHeader( HttpHeaders.Names.CONTENT_LENGTH, Integer.toString( buffer.readableBytes( ) ) );\n        }\n      } else {\n        response = new DefaultHttpResponse( request.getProtocolVersion( ), HttpResponseStatus.OK );\n        response.setHeader( HttpHeaders.Names.CONTENT_TYPE, \"text/plain\" );\n        ChannelBuffer buffer = ChannelBuffers.wrappedBuffer( ( byte[] ) reply );\n        response.setContent( buffer );\n        response.addHeader( HttpHeaders.Names.CONTENT_LENGTH, Integer.toString( buffer.readableBytes( ) ) );\n      }\n      ctx.getChannel( ).write( response ).addListener( ChannelFutureListener.CLOSE );\n    } else {\n      ctx.sendUpstream( e );\n    }\n  }","id":101633,"modified_method":"@Override\n  public void handleUpstream( ChannelHandlerContext ctx, ChannelEvent e ) throws Exception {\n    if ( e instanceof MessageEvent && ( ( MessageEvent ) e ).getMessage( ) instanceof MappingHttpRequest ) {\n      MappingHttpRequest request = ( MappingHttpRequest ) ( ( MessageEvent ) e ).getMessage( );\n      String newUri = null;\n      String uri = request.getUri( );\n      InetSocketAddress remoteAddr = ( ( InetSocketAddress ) ctx.getChannel( ).getRemoteAddress( ) );\n      String remoteHost = remoteAddr.getAddress( ).getHostAddress( );//\"10.1.1.2\";//\n      if ( uri.startsWith( \"/latest/\" ) )\n        newUri = uri.replaceAll( \"/latest/\", remoteHost + \":\" );\n      else newUri = uri.replaceAll( \"/\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d/\", remoteHost + \":\" );\n      \n      HttpResponse response = null;\n      LOG.trace( \"Trying to get metadata: \" + newUri );\n      Object reply = \"\".getBytes( );\n      Exception replyEx = null;\n      try {\n        if ( Bootstrap.isShuttingDown( ) ) {\n          reply = \"System shutting down\".getBytes( );\n        } else if ( !Bootstrap.isFinished( ) ) {\n          reply = \"System is still starting up\".getBytes( );\n        } else {\n          reply = ServiceContext.send( \"VmMetadata\", newUri );\n        }\n      } catch ( ServiceDispatchException e1 ) {\n        LOG.debug( e1, e1 );\n        replyEx = e1;\n      } catch ( Exception e1 ) {\n        LOG.debug( e1, e1 );\n        replyEx = e1;\n      } finally {\n        Contexts.clear( request.getCorrelationId( ) );\n      }\n      Logs.extreme( ).debug( \"VmMetadata reply info: \" + reply + \" \" + replyEx );\n      if ( replyEx != null || reply == null || reply instanceof NullPayload ) {\n        response = new DefaultHttpResponse( request.getProtocolVersion( ), HttpResponseStatus.NOT_FOUND );\n        if ( Logs.isDebug( ) ) {\n          response.setHeader( HttpHeaders.Names.CONTENT_TYPE, \"text/plain\" );\n          ChannelBuffer buffer = null;\n          if ( replyEx != null && !( replyEx instanceof NoSuchElementException ) ) {\n            buffer = ChannelBuffers.wrappedBuffer(  Exceptions.string( replyEx ).getBytes( ) );\n            response.setContent( buffer );\n          } else {\n            buffer = ChannelBuffers.wrappedBuffer( \"\".getBytes( ) );\n            response.setContent( buffer );\n          }\n          response.addHeader( HttpHeaders.Names.CONTENT_LENGTH, Integer.toString( buffer.readableBytes( ) ) );\n        }\n      } else {\n        response = new DefaultHttpResponse( request.getProtocolVersion( ), HttpResponseStatus.OK );\n        response.setHeader( HttpHeaders.Names.CONTENT_TYPE, \"text/plain\" );\n        ChannelBuffer buffer = ChannelBuffers.wrappedBuffer( ( byte[] ) reply );\n        response.setContent( buffer );\n        response.addHeader( HttpHeaders.Names.CONTENT_LENGTH, Integer.toString( buffer.readableBytes( ) ) );\n      }\n      ctx.getChannel( ).write( response ).addListener( ChannelFutureListener.CLOSE );\n    } else {\n      ctx.sendUpstream( e );\n    }\n  }","commit_id":"f4adf423f5e9540ec88f4d5d2190a31319afdf9e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getByKey( final String pathArg ) {\n    final Map<String, String> m = this.getMetadataMap( );\n    String path = ( pathArg != null )\n      ? pathArg\n      : \"\";\n    LOG.debug( \"Servicing metadata request:\" + path + \" -> \" + m.get( path ) );\n    if ( m.containsKey( path + \"/\" ) ) path += \"/\";\n    return m.get( path ).replaceAll( \"\\n*\\\\z\", \"\" );\n  }","id":101634,"modified_method":"public String getByKey( final String pathArg ) {\n    final Map<String, String> m = this.getMetadataMap( );\n    String path = ( pathArg != null )\n      ? pathArg\n      : \"\";\n    LOG.debug( \"Servicing metadata request:\" + path + \" -> \" + m.get( path ) );\n    if ( m.containsKey( path + \"/\" ) ) path += \"/\";\n    if ( !m.containsKey( path ) ) {\n      throw new NoSuchElementException( \"No such key: \" + path );\n    } else {\n      return m.get( path ).replaceAll( \"\\n*\\\\z\", \"\" );\n    }\n  }","commit_id":"f4adf423f5e9540ec88f4d5d2190a31319afdf9e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public byte[] handle( String path ) {\n    String[] parts = path.split( \":\" );\n    try {\n      MetadataRequest request = new MetadataRequest( parts[0], parts.length == 2\n        ? parts[1]\n        : \"/\" );\n      if ( instanceMetadataEndpoints.containsKey( request.getMetadataName( ) ) && request.isInstance( ) ) {\n        return instanceMetadataEndpoints.get( request.getMetadataName( ) ).apply( request ).getBytes( );\n      } else if ( systemMetadataEndpoints.containsKey( request.getMetadataName( ) ) && request.isSystem( ) ) {\n        return systemMetadataEndpoints.get( request.getMetadataName( ) ).apply( request ).getBytes( );\n      } else if ( publicMetadataEndpoints.containsKey( request.getMetadataName( ) ) ) {\n        return publicMetadataEndpoints.get( request.getMetadataName( ) ).apply( request ).getBytes( );\n      } else {\n        return \"\".getBytes( );\n      }\n    } catch ( Exception ex ) {\n      String errorMsg = \"Metadata request failed: \" + path + ( Logs.isExtrrreeeme( )\n        ? \" cause: \" + ex.getMessage( )\n        : \"\" );\n      LOG.error( errorMsg, ex );\n      throw Exceptions.toUndeclared( ex );\n    }\n  }","id":101635,"modified_method":"public byte[] handle( String path ) {\n    String[] parts = path.split( \":\" );\n    try {\n      MetadataRequest request = new MetadataRequest( parts[0], parts.length == 2\n        ? parts[1]\n        : \"/\" );\n      if ( instanceMetadataEndpoints.containsKey( request.getMetadataName( ) ) && request.isInstance( ) ) {\n        return instanceMetadataEndpoints.get( request.getMetadataName( ) ).apply( request ).getBytes( );\n      } else if ( systemMetadataEndpoints.containsKey( request.getMetadataName( ) ) && request.isSystem( ) ) {\n        return systemMetadataEndpoints.get( request.getMetadataName( ) ).apply( request ).getBytes( );\n      } else if ( publicMetadataEndpoints.containsKey( request.getMetadataName( ) ) ) {\n        return publicMetadataEndpoints.get( request.getMetadataName( ) ).apply( request ).getBytes( );\n      } else {\n        return \"\".getBytes( );\n      }\n    } catch ( NoSuchElementException ex ) {\n      throw ex;\n    } catch ( Exception ex ) {\n      String errorMsg = \"Metadata request failed: \" + path + ( Logs.isExtrrreeeme( )\n        ? \" cause: \" + ex.getMessage( )\n        : \"\" );\n      LOG.error( errorMsg, ex );\n      throw Exceptions.toUndeclared( ex );\n    }\n  }","commit_id":"f4adf423f5e9540ec88f4d5d2190a31319afdf9e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void commonFinishEdit(HttpServletRequest request, Basethresholddef baseDef) {\n        String dsLabel = request.getParameter(\"dsLabel\");\n        if (dsLabel == null || \"\".equals(dsLabel)) {\n            baseDef.setDsLabel(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setDsLabel(dsLabel);\n        }\n\n        String description = request.getParameter(\"description\");\n        if (description == null || \"\".equals(description)) {\n            baseDef.setDescription(null);\n        }\n        else {\n            baseDef.setDescription(description);\n        }\n\n        String triggeredUEI = request.getParameter(\"triggeredUEI\");\n        if (triggeredUEI == null || \"\".equals(triggeredUEI)) {\n            baseDef.setTriggeredUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setTriggeredUEI(triggeredUEI);\n            this.ensureUEIInEventConf(triggeredUEI, \"exceeded\");\n        }\n\n        String rearmedUEI = request.getParameter(\"rearmedUEI\");\n        if (rearmedUEI == null || \"\".equals(rearmedUEI)) {\n            baseDef.setRearmedUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setRearmedUEI(rearmedUEI);\n            this.ensureUEIInEventConf(rearmedUEI, \"rearmed\");\n        }\n        baseDef.setDsType(request.getParameter(\"dsType\"));\n        baseDef.setType(request.getParameter(\"type\"));\n        baseDef.setRearm(WebSecurityUtils.safeParseDouble(request.getParameter(\"rearm\")));\n        baseDef.setTrigger(WebSecurityUtils.safeParseInt(request.getParameter(\"trigger\")));\n        baseDef.setValue(WebSecurityUtils.safeParseDouble(request.getParameter(\"value\")));\n\n    }","id":101636,"modified_method":"private void commonFinishEdit(HttpServletRequest request, Basethresholddef baseDef) {\n        String dsLabel = request.getParameter(\"dsLabel\");\n        if (dsLabel == null || \"\".equals(dsLabel)) {\n            baseDef.setDsLabel(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            baseDef.setDsLabel(dsLabel);\n        }\n\n        String description = request.getParameter(\"description\");\n        if (description == null || \"\".equals(description)) {\n            baseDef.setDescription(null);\n        }\n        else {\n            baseDef.setDescription(description);\n        }\n\n        baseDef.setDsType(request.getParameter(\"dsType\"));\n        baseDef.setType(request.getParameter(\"type\"));\n        baseDef.setRearm(WebSecurityUtils.safeParseDouble(request.getParameter(\"rearm\")));\n        baseDef.setTrigger(WebSecurityUtils.safeParseInt(request.getParameter(\"trigger\")));\n        baseDef.setValue(WebSecurityUtils.safeParseDouble(request.getParameter(\"value\")));\n\n        String clearKey = null;\n\n        String triggeredUEI = request.getParameter(\"triggeredUEI\");\n        if (triggeredUEI == null || \"\".equals(triggeredUEI)) {\n            baseDef.setTriggeredUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            org.opennms.netmgt.xml.eventconf.Event source = getSourceEvent(baseDef.getType(), true);\n            if (source != null && source.getAlarmData() != null && source.getAlarmData().getReductionKey() != null) {\n                clearKey = source.getAlarmData().getReductionKey().replace(\"%uei%\", triggeredUEI);\n            }\n            baseDef.setTriggeredUEI(triggeredUEI);\n            this.ensureUEIInEventConf(source, triggeredUEI, baseDef.getType(), null, true);\n        }\n\n        String rearmedUEI = request.getParameter(\"rearmedUEI\");\n        if (rearmedUEI == null || \"\".equals(rearmedUEI) || baseDef.getType().equals(\"relativeChange\") || baseDef.getType().equals(\"absoluteChange\")) { // It doesn't make sense a rearm UEI for relativeChange or absoluteChange\n            baseDef.setRearmedUEI(null); //Must set null in correct circumstances - empty string isn't quite the same thing\n        }\n        else {\n            org.opennms.netmgt.xml.eventconf.Event source = getSourceEvent(baseDef.getType(), false);\n            baseDef.setRearmedUEI(rearmedUEI);\n            this.ensureUEIInEventConf(source, rearmedUEI, baseDef.getType(), clearKey, false);\n        }\n    }","commit_id":"8141ba5c373b262071beb1eed2c3488cad3c3560","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * Test <code>void read(byte[] b, int off, int len)<\/code>. Read from remote data server.\n   */\n  @Test\n  public void readTest6() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      TachyonFile f =\n          TachyonFSTestUtils.createByteFile(mTfs, uniqPath + \"/file_\" + k, k, mWriteTachyon);\n\n      long blockId = mTfs.getInfo(f).getBlockIds().get(0);\n      BlockInfo info = TachyonBlockStore.get().getInfo(blockId);\n      RemoteBlockInStream is =\n          new RemoteBlockInStream(info.getBlockId(), info.getLength(), info.getLocations().get(0)\n              .getWorkerAddress());\n      byte[] ret = new byte[k / 2];\n      int start = 0;\n      while (start < k / 2) {\n        int read = is.read(ret, 0, (k / 2) - start);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(start, read, ret));\n        start += read;\n      }\n      is.close();\n      Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n    }\n  }","id":101637,"modified_method":"/**\n   * Test <code>void read(byte[] b, int off, int len)<\/code>. Read from remote data server.\n   */\n  @Test\n  public void readTest6() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      TachyonFile f =\n          TachyonFSTestUtils.createByteFile(mTfs, uniqPath + \"/file_\" + k, k, mWriteTachyon);\n\n      long blockId = mTfs.getInfo(f).getBlockIds().get(0);\n      BlockInfo info = TachyonBlockStore.get().getInfo(blockId);\n      NetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();\n      RemoteBlockInStream is =\n          new RemoteBlockInStream(info.getBlockId(), info.getLength(), new InetSocketAddress(\n              workerAddr.getHost(), workerAddr.getDataPort()));\n      byte[] ret = new byte[k / 2];\n      int start = 0;\n      while (start < k / 2) {\n        int read = is.read(ret, 0, (k / 2) - start);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(start, read, ret));\n        start += read;\n      }\n      is.close();\n      Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n    }\n  }","commit_id":"072f0dfea9a06fdcf359cb16c7fde0976755b5fe","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test <code>void read()<\/code>. Read from remote data server.\n   */\n  @Test\n  public void readTest4() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      TachyonFile f =\n          TachyonFSTestUtils.createByteFile(mTfs, uniqPath + \"/file_\" + k, k, mWriteTachyon);\n\n      long blockId = mTfs.getInfo(f).getBlockIds().get(0);\n      BlockInfo info = TachyonBlockStore.get().getInfo(blockId);\n      RemoteBlockInStream is =\n          new RemoteBlockInStream(info.getBlockId(), info.getLength(), info.getLocations().get(0)\n              .getWorkerAddress());\n      byte[] ret = new byte[k];\n      int value = is.read();\n      int cnt = 0;\n      while (value != -1) {\n        Assert.assertTrue(value >= 0);\n        Assert.assertTrue(value < 256);\n        ret[cnt ++] = (byte) value;\n        value = is.read();\n      }\n      Assert.assertEquals(cnt, k);\n      Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n      is.close();\n      Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n    }\n  }","id":101638,"modified_method":"/**\n   * Test <code>void read()<\/code>. Read from remote data server.\n   */\n  @Test\n  public void readTest4() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      TachyonFile f =\n          TachyonFSTestUtils.createByteFile(mTfs, uniqPath + \"/file_\" + k, k, mWriteTachyon);\n\n      long blockId = mTfs.getInfo(f).getBlockIds().get(0);\n      BlockInfo info = TachyonBlockStore.get().getInfo(blockId);\n      NetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();\n      RemoteBlockInStream is =\n          new RemoteBlockInStream(info.getBlockId(), info.getLength(), new InetSocketAddress(\n              workerAddr.getHost(), workerAddr.getDataPort()));\n      byte[] ret = new byte[k];\n      int value = is.read();\n      int cnt = 0;\n      while (value != -1) {\n        Assert.assertTrue(value >= 0);\n        Assert.assertTrue(value < 256);\n        ret[cnt ++] = (byte) value;\n        value = is.read();\n      }\n      Assert.assertEquals(cnt, k);\n      Assert.assertTrue(BufferUtils.equalIncreasingByteArray(k, ret));\n      is.close();\n      Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n    }\n  }","commit_id":"072f0dfea9a06fdcf359cb16c7fde0976755b5fe","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test <code>void read(byte[] b)<\/code>. Read from remote data server.\n   */\n  @Test\n  public void readTest5() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      TachyonFile f =\n          TachyonFSTestUtils.createByteFile(mTfs, uniqPath + \"/file_\" + k, k, mWriteTachyon);\n\n      long blockId = mTfs.getInfo(f).getBlockIds().get(0);\n      BlockInfo info = TachyonBlockStore.get().getInfo(blockId);\n      RemoteBlockInStream is =\n          new RemoteBlockInStream(info.getBlockId(), info.getLength(), info.getLocations().get(0)\n              .getWorkerAddress());\n      byte[] ret = new byte[k];\n      int start = 0;\n      while (start < k) {\n        int read = is.read(ret);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(start, read, ret));\n        start += read;\n      }\n      is.close();\n      Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n    }\n  }","id":101639,"modified_method":"/**\n   * Test <code>void read(byte[] b)<\/code>. Read from remote data server.\n   */\n  @Test\n  public void readTest5() throws IOException, TachyonException {\n    String uniqPath = PathUtils.uniqPath();\n    for (int k = MIN_LEN + DELTA; k <= MAX_LEN; k += DELTA) {\n      TachyonFile f =\n          TachyonFSTestUtils.createByteFile(mTfs, uniqPath + \"/file_\" + k, k, mWriteTachyon);\n\n      long blockId = mTfs.getInfo(f).getBlockIds().get(0);\n      BlockInfo info = TachyonBlockStore.get().getInfo(blockId);\n      NetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();\n      RemoteBlockInStream is =\n          new RemoteBlockInStream(info.getBlockId(), info.getLength(), new InetSocketAddress(\n              workerAddr.getHost(), workerAddr.getDataPort()));\n      byte[] ret = new byte[k];\n      int start = 0;\n      while (start < k) {\n        int read = is.read(ret);\n        Assert.assertTrue(BufferUtils.equalIncreasingByteArray(start, read, ret));\n        start += read;\n      }\n      is.close();\n      Assert.assertTrue(mTfs.getInfo(f).getInMemoryPercentage() == 100);\n    }\n  }","commit_id":"072f0dfea9a06fdcf359cb16c7fde0976755b5fe","url":"https://github.com/amplab/tachyon"},{"original_method":"protected void configureTaskJavadoc(Project project) {\n\t\tString exportPackage = getBundleInstruction(\n\t\t\tproject, Constants.EXPORT_PACKAGE);\n\n\t\tif (Validator.isNull(exportPackage)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJavadoc javadoc = (Javadoc)GradleUtil.getTask(\n\t\t\tproject, JavaPlugin.JAVADOC_TASK_NAME);\n\n\t\tString[] exportPackageArray = exportPackage.split(\",\");\n\n\t\tfor (String pattern : exportPackageArray) {\n\t\t\tpattern = pattern.trim();\n\n\t\t\tboolean excludePattern = false;\n\n\t\t\tint start = 0;\n\n\t\t\tif (pattern.startsWith(\"!\")) {\n\t\t\t\texcludePattern = true;\n\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tint end = pattern.indexOf(';');\n\n\t\t\tif (end == -1) {\n\t\t\t\tend = pattern.length();\n\t\t\t}\n\n\t\t\tpattern = pattern.substring(start, end);\n\n\t\t\tpattern = \"**/\" + pattern.replace('.', '/');\n\n\t\t\tif (pattern.endsWith(\"/*\")) {\n\t\t\t\tpattern = pattern.substring(0, pattern.length() - 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpattern += \"/*\";\n\t\t\t}\n\n\t\t\tif (excludePattern) {\n\t\t\t\tjavadoc.exclude(pattern);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjavadoc.include(pattern);\n\t\t\t}\n\t\t}\n\t}","id":101640,"modified_method":"protected void configureSourceSetTest(\n\t\tProject project, Configuration portalConfiguration,\n\t\tConfiguration portalTestConfiguration) {\n\n\t\tSourceSet sourceSet = GradleUtil.getSourceSet(\n\t\t\tproject, SourceSet.TEST_SOURCE_SET_NAME);\n\n\t\tconfigureSourceSetClassesDir(project, sourceSet, \"test-classes/unit\");\n\n\t\tConfiguration compileConfiguration = GradleUtil.getConfiguration(\n\t\t\tproject, JavaPlugin.COMPILE_CONFIGURATION_NAME);\n\n\t\tsourceSet.setCompileClasspath(\n\t\t\tFileUtil.join(\n\t\t\t\tcompileConfiguration, portalConfiguration,\n\t\t\t\tsourceSet.getCompileClasspath(), portalTestConfiguration));\n\n\t\tsourceSet.setRuntimeClasspath(\n\t\t\tFileUtil.join(\n\t\t\t\tcompileConfiguration, portalConfiguration,\n\t\t\t\tsourceSet.getRuntimeClasspath(), portalTestConfiguration));\n\t}","commit_id":"94b2dcf4f30d45725224db1efb4d848fcf713380","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureSourceSetMain(Project project) {\n\t\tconfigureSourceSetClassesDir(\n\t\t\tproject, SourceSet.MAIN_SOURCE_SET_NAME, \"classes\");\n\t}","id":101641,"modified_method":"protected void configureSourceSetMain(Project project) {\n\t\tSourceSet sourceSet = GradleUtil.getSourceSet(\n\t\t\tproject, SourceSet.MAIN_SOURCE_SET_NAME);\n\n\t\tconfigureSourceSetClassesDir(project, sourceSet, \"classes\");\n\t}","commit_id":"94b2dcf4f30d45725224db1efb4d848fcf713380","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureSourceSetClassesDir(\n\t\tProject project, String name, String classesDirName) {\n\n\t\tSourceSet sourceSet = GradleUtil.getSourceSet(project, name);\n\n\t\tSourceSetOutput sourceSetOutput = sourceSet.getOutput();\n\n\t\tif (FileUtil.isChild(\n\t\t\t\tsourceSetOutput.getClassesDir(), project.getBuildDir())) {\n\n\t\t\tsourceSetOutput.setClassesDir(classesDirName);\n\t\t\tsourceSetOutput.setResourcesDir(classesDirName);\n\t\t}\n\t}","id":101642,"modified_method":"protected void configureSourceSetClassesDir(\n\t\tProject project, SourceSet sourceSet, String classesDirName) {\n\n\t\tSourceSetOutput sourceSetOutput = sourceSet.getOutput();\n\n\t\tif (FileUtil.isChild(\n\t\t\t\tsourceSetOutput.getClassesDir(), project.getBuildDir())) {\n\n\t\t\tsourceSetOutput.setClassesDir(classesDirName);\n\t\t\tsourceSetOutput.setResourcesDir(classesDirName);\n\t\t}\n\t}","commit_id":"94b2dcf4f30d45725224db1efb4d848fcf713380","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void configureDefaults(\n\t\tfinal Project project, LiferayPlugin liferayPlugin) {\n\n\t\tapplyPlugins(project);\n\n\t\t// applyConfigScripts configures the \"install\" and \"uploadArchives\"\n\t\t// tasks, and this causes the conf2ScopeMappings.mappings convention\n\t\t// property to be cloned in a second map. Because we want to change\n\t\t// the default mappings, we must call configureMavenConf2ScopeMappings\n\t\t// before applyConfigScripts.\n\n\t\tconfigureMavenConf2ScopeMappings(project);\n\n\t\tapplyConfigScripts(project);\n\n\t\tboolean testProject = isTestProject(project);\n\n\t\taddTaskJarSources(project, testProject);\n\t\taddTaskZipJavadoc(project);\n\t\tconfigureJavaPlugin(project);\n\t\tconfigureProject(project);\n\t\tconfigureRepositories(project);\n\t\tconfigureSourceSetMain(project);\n\t\tconfigureSourceSetTest(project);\n\t\tconfigureSourceSetTestIntegration(project);\n\t\tconfigureTaskJar(project, testProject);\n\t\tconfigureTasksFindBugs(project);\n\t\tconfigureTasksJavaCompile(project);\n\n\t\twithPlugin(\n\t\t\tproject, BundlePlugin.class,\n\t\t\tnew Action<BundlePlugin>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(BundlePlugin bundlePlugin) {\n\t\t\t\t\taddTaskCopyLibs(project);\n\t\t\t\t\tconfigureTaskJavadoc(project);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tproject.afterEvaluate(\n\t\t\tnew Action<Project>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(Project project) {\n\t\t\t\t\tconfigureArtifacts(project);\n\t\t\t\t\tconfigureProjectBndProperties(project);\n\t\t\t\t\tconfigureProjectVersion(project);\n\n\t\t\t\t\t// configureProjectVersion must be called before\n\t\t\t\t\t// configureTaskUploadArchives, because the latter one needs\n\t\t\t\t\t// to know if we are publishing a snapshot or not.\n\n\t\t\t\t\tconfigureTaskUploadArchives(project);\n\t\t\t\t}\n\n\t\t\t});\n\t}","id":101643,"modified_method":"@Override\n\tprotected void configureDefaults(\n\t\tfinal Project project, LiferayPlugin liferayPlugin) {\n\n\t\tboolean testProject = isTestProject(project);\n\n\t\tapplyPlugins(project);\n\n\t\t// applyConfigScripts configures the \"install\" and \"uploadArchives\"\n\t\t// tasks, and this causes the conf2ScopeMappings.mappings convention\n\t\t// property to be cloned in a second map. Because we want to change\n\t\t// the default mappings, we must call configureMavenConf2ScopeMappings\n\t\t// before applyConfigScripts.\n\n\t\tconfigureMavenConf2ScopeMappings(project);\n\n\t\tapplyConfigScripts(project);\n\n\t\tConfiguration portalConfiguration = GradleUtil.getConfiguration(\n\t\t\tproject, LiferayJavaPlugin.PORTAL_CONFIGURATION_NAME);\n\t\tConfiguration portalTestConfiguration = addConfigurationPortalTest(\n\t\t\tproject);\n\n\t\taddDependenciesPortalTest(project);\n\t\taddTaskJarSources(project, testProject);\n\t\taddTaskZipJavadoc(project);\n\t\tconfigureEclipse(project, portalTestConfiguration);\n\t\tconfigureIdea(project, portalTestConfiguration);\n\t\tconfigureJavaPlugin(project);\n\t\tconfigureProject(project);\n\t\tconfigureRepositories(project);\n\t\tconfigureSourceSetMain(project);\n\t\tconfigureSourceSetTest(\n\t\t\tproject, portalConfiguration, portalTestConfiguration);\n\t\tconfigureSourceSetTestIntegration(\n\t\t\tproject, portalConfiguration, portalTestConfiguration);\n\t\tconfigureTaskJar(project, testProject);\n\t\tconfigureTasksFindBugs(project);\n\t\tconfigureTasksJavaCompile(project);\n\n\t\twithPlugin(\n\t\t\tproject, BundlePlugin.class,\n\t\t\tnew Action<BundlePlugin>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(BundlePlugin bundlePlugin) {\n\t\t\t\t\taddTaskCopyLibs(project);\n\t\t\t\t\tconfigureTaskJavadoc(project);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tproject.afterEvaluate(\n\t\t\tnew Action<Project>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(Project project) {\n\t\t\t\t\tconfigureArtifacts(project);\n\t\t\t\t\tconfigureProjectBndProperties(project);\n\t\t\t\t\tconfigureProjectVersion(project);\n\n\t\t\t\t\t// configureProjectVersion must be called before\n\t\t\t\t\t// configureTaskUploadArchives, because the latter one needs\n\t\t\t\t\t// to know if we are publishing a snapshot or not.\n\n\t\t\t\t\tconfigureTaskUploadArchives(project);\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"94b2dcf4f30d45725224db1efb4d848fcf713380","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureTaskUploadArchives(Project project) {\n\t\tString version = String.valueOf(project.getVersion());\n\n\t\tif (version.endsWith(_SNAPSHOT_VERSION_SUFFIX)) {\n\t\t\treturn;\n\t\t}\n\n\t\tTask uploadArchivesTask = GradleUtil.getTask(\n\t\t\tproject, BasePlugin.UPLOAD_ARCHIVES_TASK_NAME);\n\n\t\tTaskContainer taskContainer = project.getTasks();\n\n\t\tTaskCollection<PublishNodeModuleTask> publishNodeModuleTasks =\n\t\t\ttaskContainer.withType(PublishNodeModuleTask.class);\n\n\t\tuploadArchivesTask.dependsOn(publishNodeModuleTasks);\n\t}","id":101644,"modified_method":"protected void configureSourceSetTestIntegration(\n\t\tProject project, Configuration portalConfiguration,\n\t\tConfiguration portalTestConfiguration) {\n\n\t\tSourceSet sourceSet = GradleUtil.getSourceSet(\n\t\t\tproject,\n\t\t\tTestIntegrationBasePlugin.TEST_INTEGRATION_SOURCE_SET_NAME);\n\n\t\tconfigureSourceSetClassesDir(\n\t\t\tproject, sourceSet, \"test-classes/integration\");\n\n\t\tsourceSet.setCompileClasspath(\n\t\t\tFileUtil.join(\n\t\t\t\tportalConfiguration, sourceSet.getCompileClasspath(),\n\t\t\t\tportalTestConfiguration));\n\n\t\tsourceSet.setRuntimeClasspath(\n\t\t\tFileUtil.join(\n\t\t\t\tportalConfiguration, sourceSet.getRuntimeClasspath(),\n\t\t\t\tportalTestConfiguration));\n\t}","commit_id":"94b2dcf4f30d45725224db1efb4d848fcf713380","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** @see {@link #newStartEffector()} */\n    public Effector<Void> newStopEffector() {\n        return Effectors.effector(Startable.STOP)\n                .parameter(StopSoftwareParameters.STOP_MACHINE)\n                .impl(newStopEffectorTask())\n                .build();\n    }","id":101645,"modified_method":"/** @see {@link #newStartEffector()} */\n    public Effector<Void> newStopEffector() {\n        return Effectors.effector(Startable.STOP)\n                .parameter(StopSoftwareParameters.STOP_PROCESS_MODE)\n                .parameter(StopSoftwareParameters.STOP_MACHINE_MODE)\n                .impl(newStopEffectorTask())\n                .build();\n    }","commit_id":"6ac2cd95d1fa6385a6dce28cf4f0b7c0b129cb25","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Default stop implementation for an entity.\n     * <p>\n     * Aborts if already stopped, otherwise sets state {@link Lifecycle#STOPPING} then\n     * invokes {@link #preStopCustom()}, {@link #stopProcessesAtMachine()}, then finally\n     * {@link #stopAnyProvisionedMachines()} and sets state {@link Lifecycle#STOPPED}\n     */\n    public void stop(ConfigBag parameters) {\n        log.info(\"Stopping {} in {}\", entity(), entity().getLocations());\n\n        Boolean isStopMachine = parameters.get(StopSoftwareParameters.STOP_MACHINE);\n\n        if (isStopMachine==null)\n            isStopMachine = Boolean.TRUE;\n\n        DynamicTasks.queue(\"pre-stop\", new Callable<String>() { public String call() {\n            if (entity().getAttribute(SoftwareProcess.SERVICE_STATE_ACTUAL)==Lifecycle.STOPPED) {\n                log.debug(\"Skipping stop of entity \"+entity()+\" when already stopped\");\n                return \"Already stopped\";\n            }\n            ServiceStateLogic.setExpectedState(entity(), Lifecycle.STOPPING);\n            entity().setAttribute(SoftwareProcess.SERVICE_UP, false);\n            preStopCustom();\n            return null;\n        }});\n\n        if (entity().getAttribute(SoftwareProcess.SERVICE_STATE_ACTUAL)==Lifecycle.STOPPED) {\n            return;\n        }\n\n        Maybe<SshMachineLocation> sshMachine = Machines.findUniqueSshMachineLocation(entity().getLocations());\n        Task<String> stoppingProcess = DynamicTasks.queue(\"stopping (process)\", new Callable<String>() { public String call() {\n            DynamicTasks.markInessential();\n            stopProcessesAtMachine();\n            DynamicTasks.waitForLast();\n            return \"Stop at machine completed with no errors.\";\n        }});\n\n\n        Task<StopMachineDetails<Integer>> stoppingMachine = null;\n        if (isStopMachine) {\n            // Release this machine (even if error trying to stop process - we rethrow that after)\n            stoppingMachine = DynamicTasks.queue(\"stopping (machine)\", new Callable<StopMachineDetails<Integer>>() {\n                public StopMachineDetails<Integer> call() {\n                    if (entity().getAttribute(SoftwareProcess.SERVICE_STATE_ACTUAL) == Lifecycle.STOPPED) {\n                        log.debug(\"Skipping stop of entity \" + entity() + \" when already stopped\");\n                        return new StopMachineDetails<Integer>(\"Already stopped\", 0);\n                    }\n                    return stopAnyProvisionedMachines();\n                }\n            });\n\n            DynamicTasks.drain(entity().getConfig(STOP_PROCESS_TIMEOUT), false);\n\n            // shutdown the machine if stopping process fails or takes too long\n            synchronized (stoppingMachine) {\n                // task also used as mutex by DST when it submits it; ensure it only submits once!\n                if (!stoppingMachine.isSubmitted()) {\n                    // force the stoppingMachine task to run by submitting it here\n                    log.warn(\"Submitting machine stop early in background for \"+entity()+\" because process stop has \"+\n                            (stoppingProcess.isDone() ? \"finished abnormally\" : \"not finished\"));\n                    Entities.submit(entity(), stoppingMachine);\n                }\n            }\n        }\n\n        try {\n            // This maintains previous behaviour of silently squashing any errors on the stoppingProcess task if the\n            // stoppingMachine exits with a nonzero value\n            boolean checkStopProcesses = (stoppingMachine == null || stoppingMachine.get().value == 0);\n\n            if (checkStopProcesses) {\n                // TODO we should test for destruction above, not merely successful \"stop\", as things like localhost and ssh won't be destroyed\n                DynamicTasks.waitForLast();\n                if (sshMachine.isPresent()) {\n                    // throw early errors *only if* there is a machine and we have not destroyed it\n                    stoppingProcess.get();\n                }\n            }\n        } catch (Throwable e) {\n            ServiceStateLogic.setExpectedState(entity(), Lifecycle.ON_FIRE);\n            Exceptions.propagate(e);\n        }\n        entity().setAttribute(SoftwareProcess.SERVICE_UP, false);\n        ServiceStateLogic.setExpectedState(entity(), Lifecycle.STOPPED);\n\n        if (log.isDebugEnabled()) log.debug(\"Stopped software process entity \"+entity());\n    }","id":101646,"modified_method":"/**\n     * Default stop implementation for an entity.\n     * <p>\n     * Aborts if already stopped, otherwise sets state {@link Lifecycle#STOPPING} then\n     * invokes {@link #preStopCustom()}, {@link #stopProcessesAtMachine()}, then finally\n     * {@link #stopAnyProvisionedMachines()} and sets state {@link Lifecycle#STOPPED}\n     */\n    public void stop(ConfigBag parameters) {\n        log.info(\"Stopping {} in {}\", entity(), entity().getLocations());\n\n        final boolean hasStopMachine = parameters.containsKey(StopSoftwareParameters.STOP_MACHINE);\n        final Boolean isStopMachine = parameters.get(StopSoftwareParameters.STOP_MACHINE);\n\n        final StopMode stopProcessMode = parameters.get(StopSoftwareParameters.STOP_PROCESS_MODE);\n\n        final boolean hasStopMachineMode = parameters.containsKey(StopSoftwareParameters.STOP_MACHINE_MODE);\n        StopMode stopMachineMode = parameters.get(StopSoftwareParameters.STOP_MACHINE_MODE);\n\n        if (hasStopMachine && isStopMachine != null) {\n            checkCompatibleMachineModes(isStopMachine, hasStopMachineMode, stopMachineMode);\n            if (isStopMachine) {\n                stopMachineMode = StopMode.IF_NOT_STOPPED;\n            } else {\n                stopMachineMode = StopMode.NEVER;\n            }\n        }\n\n        boolean isEntityStopped = entity().getAttribute(SoftwareProcess.SERVICE_STATE_ACTUAL)==Lifecycle.STOPPED;\n\n        DynamicTasks.queue(\"pre-stop\", new Callable<String>() { public String call() {\n            if (entity().getAttribute(SoftwareProcess.SERVICE_STATE_ACTUAL)==Lifecycle.STOPPED) {\n                log.debug(\"Skipping stop of entity \"+entity()+\" when already stopped\");\n                return \"Already stopped\";\n            }\n            ServiceStateLogic.setExpectedState(entity(), Lifecycle.STOPPING);\n            entity().setAttribute(SoftwareProcess.SERVICE_UP, false);\n            preStopCustom();\n            return null;\n        }});\n\n        Maybe<SshMachineLocation> sshMachine = Machines.findUniqueSshMachineLocation(entity().getLocations());\n        Task<String> stoppingProcess = null;\n        if (canStop(stopProcessMode, isEntityStopped)) {\n            stoppingProcess = DynamicTasks.queue(\"stopping (process)\", new Callable<String>() { public String call() {\n                DynamicTasks.markInessential();\n                stopProcessesAtMachine();\n                DynamicTasks.waitForLast();\n                return \"Stop at machine completed with no errors.\";\n            }});\n        }\n\n        Task<StopMachineDetails<Integer>> stoppingMachine = null;\n        if (canStop(stopMachineMode, isEntityStopped)) {\n            // Release this machine (even if error trying to stop process - we rethrow that after)\n            stoppingMachine = DynamicTasks.queue(\"stopping (machine)\", new Callable<StopMachineDetails<Integer>>() {\n                public StopMachineDetails<Integer> call() {\n                    return stopAnyProvisionedMachines();\n                }\n            });\n\n            DynamicTasks.drain(entity().getConfig(STOP_PROCESS_TIMEOUT), false);\n\n            // shutdown the machine if stopping process fails or takes too long\n            synchronized (stoppingMachine) {\n                // task also used as mutex by DST when it submits it; ensure it only submits once!\n                if (!stoppingMachine.isSubmitted()) {\n                    // force the stoppingMachine task to run by submitting it here\n                    StringBuilder msg = new StringBuilder(\"Submitting machine stop early in background for \").append(entity());\n                    if (stoppingProcess == null) {\n                        msg.append(\". Process stop skipped, pre-stop not finished?\");\n                    } else {\n                        msg.append(\" because process stop has \"+\n                                (stoppingProcess.isDone() ? \"finished abnormally\" : \"not finished\"));\n                    }\n                    log.warn(msg.toString());\n                    Entities.submit(entity(), stoppingMachine);\n                }\n            }\n        }\n\n        try {\n            // This maintains previous behaviour of silently squashing any errors on the stoppingProcess task if the\n            // stoppingMachine exits with a nonzero value\n            boolean checkStopProcesses = (stoppingProcess != null && (stoppingMachine == null || stoppingMachine.get().value == 0));\n\n            if (checkStopProcesses) {\n                // TODO we should test for destruction above, not merely successful \"stop\", as things like localhost and ssh won't be destroyed\n                DynamicTasks.waitForLast();\n                if (sshMachine.isPresent()) {\n                    // throw early errors *only if* there is a machine and we have not destroyed it\n                    stoppingProcess.get();\n                }\n            }\n        } catch (Throwable e) {\n            ServiceStateLogic.setExpectedState(entity(), Lifecycle.ON_FIRE);\n            Exceptions.propagate(e);\n        }\n        entity().setAttribute(SoftwareProcess.SERVICE_UP, false);\n        ServiceStateLogic.setExpectedState(entity(), Lifecycle.STOPPED);\n\n        if (log.isDebugEnabled()) log.debug(\"Stopped software process entity \"+entity());\n    }","commit_id":"6ac2cd95d1fa6385a6dce28cf4f0b7c0b129cb25","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@BeforeMethod(alwaysRun=true)\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        loc = mgmt.getLocationManager().createLocation(LocationSpec.create(FixedListMachineProvisioningLocation.class));\n        machine = mgmt.getLocationManager().createLocation(LocationSpec.create(SshMachineLocation.class)\n                .configure(\"address\", \"localhost\"));\n        loc.addMachine(machine);\n    }","id":101647,"modified_method":"@BeforeMethod(alwaysRun=true)\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        loc = getLocation();\n    }","commit_id":"6ac2cd95d1fa6385a6dce28cf4f0b7c0b129cb25","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDLRecordSet recordSet)\n\t\tthrows Exception {\n\n\t\tElement recordSetElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(recordSet);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\trecordSetElement, StagedModelPathUtil.getPath(recordSet), recordSet,\n\t\t\tDDLPortletDataHandler.NAMESPACE);\n\n\t\tDDMStructure ddmStructure = recordSet.getDDMStructure();\n\n\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\tportletDataContext, ddmStructure);\n\n\t\tList<DDMTemplate> ddmTemplates = ddmStructure.getTemplates();\n\n\t\tfor (DDMTemplate ddmTemplate : ddmTemplates) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, ddmTemplate);\n\t\t}\n\t}","id":101648,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDLRecordSet recordSet)\n\t\tthrows Exception {\n\n\t\t// Structure\n\n\t\tDDMStructure ddmStructure = recordSet.getDDMStructure();\n\n\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\tportletDataContext, ddmStructure);\n\n\t\t// Templates\n\n\t\tList<DDMTemplate> ddmTemplates = ddmStructure.getTemplates();\n\n\t\tElement recordSetElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(recordSet);\n\n\t\tfor (DDMTemplate ddmTemplate : ddmTemplates) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, ddmTemplate);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\trecordSetElement, ddmTemplate);\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\trecordSetElement, StagedModelPathUtil.getPath(recordSet), recordSet,\n\t\t\tDDLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"80c8c54e3cc95429f59b8df410f42e085a43b1d7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDLRecordSet recordSet)\n\t\tthrows Exception {\n\n\t\tElement ddmStructuresElement =\n\t\t\tportletDataContext.getImportDataGroupElement(DDMStructure.class);\n\n\t\timportDDMStructures(portletDataContext, ddmStructuresElement);\n\n\t\tElement ddmTemplatesElement =\n\t\t\tportletDataContext.getImportDataGroupElement(DDMTemplate.class);\n\n\t\timportDDMTemplates(portletDataContext, ddmTemplatesElement);\n\n\t\tlong userId = portletDataContext.getUserId(recordSet.getUserUuid());\n\n\t\tMap<Long, Long> ddmStructureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong ddmStructureId = MapUtil.getLong(\n\t\t\tddmStructureIds, recordSet.getDDMStructureId(),\n\t\t\trecordSet.getDDMStructureId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\trecordSet, DDLPortletDataHandler.NAMESPACE);\n\n\t\tDDLRecordSet importedRecordSet = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDDLRecordSet existingRecordSet = DDLRecordSetUtil.fetchByUUID_G(\n\t\t\t\trecordSet.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingRecordSet == null) {\n\t\t\t\tserviceContext.setUuid(recordSet.getUuid());\n\n\t\t\t\timportedRecordSet = DDLRecordSetLocalServiceUtil.addRecordSet(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tddmStructureId, recordSet.getRecordSetKey(),\n\t\t\t\t\trecordSet.getNameMap(), recordSet.getDescriptionMap(),\n\t\t\t\t\trecordSet.getMinDisplayRows(), recordSet.getScope(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedRecordSet =\n\t\t\t\t\tDDLRecordSetLocalServiceUtil.updateRecordSet(\n\t\t\t\t\t\texistingRecordSet.getRecordSetId(), ddmStructureId,\n\t\t\t\t\t\trecordSet.getNameMap(), recordSet.getDescriptionMap(),\n\t\t\t\t\t\trecordSet.getMinDisplayRows(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedRecordSet = DDLRecordSetLocalServiceUtil.addRecordSet(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), ddmStructureId,\n\t\t\t\trecordSet.getRecordSetKey(), recordSet.getNameMap(),\n\t\t\t\trecordSet.getDescriptionMap(), recordSet.getMinDisplayRows(),\n\t\t\t\trecordSet.getScope(), serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\trecordSet, importedRecordSet, DDLPortletDataHandler.NAMESPACE);\n\t}","id":101649,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDLRecordSet recordSet)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(recordSet.getUserUuid());\n\n\t\t// Structure\n\n\t\tMap<Long, Long> ddmStructureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tString structurePath = StagedModelPathUtil.getPath(\n\t\t\tportletDataContext, DDMStructure.class.getName(),\n\t\t\trecordSet.getDDMStructureId());\n\n\t\tDDMStructure ddmStructure =\n\t\t\t(DDMStructure)portletDataContext.getZipEntryAsObject(structurePath);\n\n\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\tportletDataContext, ddmStructure);\n\n\t\tlong ddmStructureId = MapUtil.getLong(\n\t\t\tddmStructureIds, recordSet.getDDMStructureId(),\n\t\t\trecordSet.getDDMStructureId());\n\n\t\t// Templates\n\n\t\tList<Element> templateElements =\n\t\t\tportletDataContext.getReferencedElements(\n\t\t\t\trecordSet, DDMTemplate.class);\n\n\t\tfor (Element templateElement : templateElements) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, templateElement);\n\t\t}\n\n\t\t// Record set\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\trecordSet, DDLPortletDataHandler.NAMESPACE);\n\n\t\tDDLRecordSet importedRecordSet = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDDLRecordSet existingRecordSet = DDLRecordSetUtil.fetchByUUID_G(\n\t\t\t\trecordSet.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingRecordSet == null) {\n\t\t\t\tserviceContext.setUuid(recordSet.getUuid());\n\n\t\t\t\timportedRecordSet = DDLRecordSetLocalServiceUtil.addRecordSet(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tddmStructureId, recordSet.getRecordSetKey(),\n\t\t\t\t\trecordSet.getNameMap(), recordSet.getDescriptionMap(),\n\t\t\t\t\trecordSet.getMinDisplayRows(), recordSet.getScope(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedRecordSet =\n\t\t\t\t\tDDLRecordSetLocalServiceUtil.updateRecordSet(\n\t\t\t\t\t\texistingRecordSet.getRecordSetId(), ddmStructureId,\n\t\t\t\t\t\trecordSet.getNameMap(), recordSet.getDescriptionMap(),\n\t\t\t\t\t\trecordSet.getMinDisplayRows(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedRecordSet = DDLRecordSetLocalServiceUtil.addRecordSet(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), ddmStructureId,\n\t\t\t\trecordSet.getRecordSetKey(), recordSet.getNameMap(),\n\t\t\t\trecordSet.getDescriptionMap(), recordSet.getMinDisplayRows(),\n\t\t\t\trecordSet.getScope(), serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\trecordSet, importedRecordSet, DDLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"80c8c54e3cc95429f59b8df410f42e085a43b1d7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(template.getUserUuid());\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong classPK = MapUtil.getLong(\n\t\t\tstructureIds, template.getClassPK(), template.getClassPK());\n\n\t\tFile smallFile = null;\n\n\t\tif (template.isSmallImage()) {\n\t\t\tElement element =\n\t\t\t\tportletDataContext.getImportDataStagedModelElement(template);\n\n\t\t\tString smallImagePath = element.attributeValue(\"small-image-path\");\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tJournalPortletDataHandler.importReferencedContent(\n\t\t\t\t\t\tportletDataContext, element,\n\t\t\t\t\t\ttemplate.getSmallImageURL());\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(smallImagePath)) {\n\t\t\t\tbyte[] bytes = portletDataContext.getZipEntryAsByteArray(\n\t\t\t\t\tsmallImagePath);\n\n\t\t\t\tif (bytes != null) {\n\t\t\t\t\tsmallFile = FileUtil.createTempFile(\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\t\tFileUtil.write(smallFile, bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\ttemplate, DDMPortletDataHandler.NAMESPACE);\n\n\t\tDDMTemplate importedTemplate = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDDMTemplate existingTemplate = DDMTemplateUtil.fetchByUUID_G(\n\t\t\t\ttemplate.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingTemplate == null) {\n\t\t\t\tserviceContext.setUuid(template.getUuid());\n\n\t\t\t\timportedTemplate = addTemplate(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template,\n\t\t\t\t\tclassPK, smallFile, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedTemplate = DDMTemplateLocalServiceUtil.updateTemplate(\n\t\t\t\t\texistingTemplate.getTemplateId(), template.getNameMap(),\n\t\t\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\t\t\ttemplate.getMode(), template.getLanguage(),\n\t\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(),\n\t\t\t\t\tsmallFile, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedTemplate = addTemplate(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template, classPK,\n\t\t\t\tsmallFile, serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\ttemplate, importedTemplate, DDMPortletDataHandler.NAMESPACE);\n\t}","id":101650,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(template.getUserUuid());\n\n\t\t// Structure\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tString structurePath = StagedModelPathUtil.getPath(\n\t\t\tportletDataContext, DDMStructure.class.getName(),\n\t\t\ttemplate.getClassPK());\n\n\t\tDDMStructure structure =\n\t\t\t(DDMStructure)portletDataContext.getZipEntryAsObject(structurePath);\n\n\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\tportletDataContext, structure);\n\n\t\tlong classPK = MapUtil.getLong(\n\t\t\tstructureIds, template.getClassPK(), template.getClassPK());\n\n\t\tFile smallFile = null;\n\n\t\tif (template.isSmallImage()) {\n\t\t\tElement element =\n\t\t\t\tportletDataContext.getImportDataStagedModelElement(template);\n\n\t\t\tString smallImagePath = element.attributeValue(\"small-image-path\");\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tJournalPortletDataHandler.importReferencedContent(\n\t\t\t\t\t\tportletDataContext, element,\n\t\t\t\t\t\ttemplate.getSmallImageURL());\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(smallImagePath)) {\n\t\t\t\tbyte[] bytes = portletDataContext.getZipEntryAsByteArray(\n\t\t\t\t\tsmallImagePath);\n\n\t\t\t\tif (bytes != null) {\n\t\t\t\t\tsmallFile = FileUtil.createTempFile(\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\t\tFileUtil.write(smallFile, bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\ttemplate, DDMPortletDataHandler.NAMESPACE);\n\n\t\tDDMTemplate importedTemplate = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDDMTemplate existingTemplate = DDMTemplateUtil.fetchByUUID_G(\n\t\t\t\ttemplate.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingTemplate == null) {\n\t\t\t\tserviceContext.setUuid(template.getUuid());\n\n\t\t\t\timportedTemplate = addTemplate(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template,\n\t\t\t\t\tclassPK, smallFile, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedTemplate = DDMTemplateLocalServiceUtil.updateTemplate(\n\t\t\t\t\texistingTemplate.getTemplateId(), template.getNameMap(),\n\t\t\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\t\t\ttemplate.getMode(), template.getLanguage(),\n\t\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(),\n\t\t\t\t\tsmallFile, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedTemplate = addTemplate(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template, classPK,\n\t\t\t\tsmallFile, serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\ttemplate, importedTemplate, DDMPortletDataHandler.NAMESPACE);\n\t}","commit_id":"80c8c54e3cc95429f59b8df410f42e085a43b1d7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tElement dlFileEntryTypesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(DLFileEntryType.class);\n\t\tElement dlFoldersElement = portletDataContext.getExportDataGroupElement(\n\t\t\tDLFolder.class);\n\t\tElement dlFileEntriesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(DLFileEntry.class);\n\t\tElement dlFileRanksElement =\n\t\t\tportletDataContext.getExportDataGroupElement(DLFileRank.class);\n\t\tElement dlRepositoriesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(Repository.class);\n\t\tElement dlRepositoryEntriesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(RepositoryEntry.class);\n\n\t\tElement templateElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(template);\n\n\t\tif (template.isSmallImage()) {\n\t\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tDDMPortletDataHandler.exportReferencedContent(\n\t\t\t\t\t\tportletDataContext, dlFileEntryTypesElement,\n\t\t\t\t\t\tdlFoldersElement, dlFileEntriesElement,\n\t\t\t\t\t\tdlFileRanksElement, dlRepositoriesElement,\n\t\t\t\t\t\tdlRepositoryEntriesElement, templateElement,\n\t\t\t\t\t\ttemplate.getSmallImageURL().concat(StringPool.SPACE));\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = StagedModelPathUtil.getPath(\n\t\t\t\t\ttemplate,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\ttemplateElement.addAttribute(\n\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDDMPortletDataHandler.NAMESPACE, \"embedded-assets\")) {\n\n\t\t\tString content = DDMPortletDataHandler.exportReferencedContent(\n\t\t\t\tportletDataContext, dlFileEntryTypesElement, dlFoldersElement,\n\t\t\t\tdlFileEntriesElement, dlFileRanksElement, dlRepositoriesElement,\n\t\t\t\tdlRepositoryEntriesElement, templateElement,\n\t\t\t\ttemplate.getScript());\n\n\t\t\ttemplate.setScript(content);\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\ttemplateElement, StagedModelPathUtil.getPath(template), template,\n\t\t\tDDMPortletDataHandler.NAMESPACE);\n\t}","id":101651,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tDDMStructure structure = DDMStructureLocalServiceUtil.fetchStructure(\n\t\t\ttemplate.getClassPK());\n\n\t\tif (structure != null) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, structure);\n\t\t}\n\n\t\tElement dlFileEntryTypesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(DLFileEntryType.class);\n\t\tElement dlFoldersElement = portletDataContext.getExportDataGroupElement(\n\t\t\tDLFolder.class);\n\t\tElement dlFileEntriesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(DLFileEntry.class);\n\t\tElement dlFileRanksElement =\n\t\t\tportletDataContext.getExportDataGroupElement(DLFileRank.class);\n\t\tElement dlRepositoriesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(Repository.class);\n\t\tElement dlRepositoryEntriesElement =\n\t\t\tportletDataContext.getExportDataGroupElement(RepositoryEntry.class);\n\n\t\tElement templateElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(template);\n\n\t\tif (template.isSmallImage()) {\n\t\t\tImage smallImage = ImageUtil.fetchByPrimaryKey(\n\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tDDMPortletDataHandler.exportReferencedContent(\n\t\t\t\t\t\tportletDataContext, dlFileEntryTypesElement,\n\t\t\t\t\t\tdlFoldersElement, dlFileEntriesElement,\n\t\t\t\t\t\tdlFileRanksElement, dlRepositoriesElement,\n\t\t\t\t\t\tdlRepositoryEntriesElement, templateElement,\n\t\t\t\t\t\ttemplate.getSmallImageURL().concat(StringPool.SPACE));\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = StagedModelPathUtil.getPath(\n\t\t\t\t\ttemplate, smallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\ttemplateElement.addAttribute(\n\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDDMPortletDataHandler.NAMESPACE, \"embedded-assets\")) {\n\n\t\t\tString content = DDMPortletDataHandler.exportReferencedContent(\n\t\t\t\tportletDataContext, dlFileEntryTypesElement, dlFoldersElement,\n\t\t\t\tdlFileEntriesElement, dlFileRanksElement, dlRepositoriesElement,\n\t\t\t\tdlRepositoryEntriesElement, templateElement,\n\t\t\t\ttemplate.getScript());\n\n\t\t\ttemplate.setScript(content);\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\ttemplateElement, StagedModelPathUtil.getPath(template), template,\n\t\t\tDDMPortletDataHandler.NAMESPACE);\n\t}","commit_id":"80c8c54e3cc95429f59b8df410f42e085a43b1d7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected DDMTemplate addTemplate(\n\t\t\tlong userId, long groupId, DDMTemplate template, long classPK,\n\t\t\tFile smallFile, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDDMTemplate newTemplate = null;\n\n\t\ttry {\n\t\t\treturn DDMTemplateLocalServiceUtil.addTemplate(\n\t\t\t\tuserId, groupId, template.getClassNameId(), classPK,\n\t\t\t\ttemplate.getTemplateKey(), template.getNameMap(),\n\t\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\t\ttemplate.getMode(), template.getLanguage(),\n\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(), smallFile,\n\t\t\t\tserviceContext);\n\t\t}\n\t\tcatch (TemplateDuplicateTemplateKeyException tdtke) {\n\t\t\tnewTemplate = DDMTemplateLocalServiceUtil.addTemplate(\n\t\t\t\tuserId, groupId, template.getClassNameId(), classPK, null,\n\t\t\t\ttemplate.getNameMap(), template.getDescriptionMap(),\n\t\t\t\ttemplate.getType(), template.getMode(), template.getLanguage(),\n\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(), smallFile,\n\t\t\t\tserviceContext);\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"A template with the key \" + template.getTemplateKey() +\n\t\t\t\t\t\t\" already exists. The new generated key is \" +\n\t\t\t\t\t\t\tnewTemplate.getTemplateKey());\n\t\t\t}\n\t\t}\n\n\t\treturn newTemplate;\n\t}","id":101652,"modified_method":"protected DDMTemplate addTemplate(\n\t\t\tlong userId, long groupId, DDMTemplate template, long classPK,\n\t\t\tFile smallFile, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDDMTemplate newTemplate = null;\n\n\t\ttry {\n\t\t\treturn DDMTemplateLocalServiceUtil.addTemplate(\n\t\t\t\tuserId, groupId, template.getClassNameId(), classPK,\n\t\t\t\ttemplate.getTemplateKey(), template.getNameMap(),\n\t\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\t\ttemplate.getMode(), template.getLanguage(),\n\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(), smallFile,\n\t\t\t\tserviceContext);\n\t\t}\n\t\tcatch (TemplateDuplicateTemplateKeyException tdtke) {\n\t\t\tnewTemplate = DDMTemplateLocalServiceUtil.addTemplate(\n\t\t\t\tuserId, groupId, template.getClassNameId(), classPK, null,\n\t\t\t\ttemplate.getNameMap(), template.getDescriptionMap(),\n\t\t\t\ttemplate.getType(), template.getMode(), template.getLanguage(),\n\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\ttemplate.isSmallImage(), template.getSmallImageURL(), smallFile,\n\t\t\t\tserviceContext);\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\tsb.append(\"A template with the key \");\n\t\t\t\tsb.append(template.getTemplateKey());\n\t\t\t\tsb.append(\" already exists. The new generated key is \");\n\t\t\t\tsb.append(newTemplate.getTemplateKey());\n\n\t\t\t\t_log.warn(sb.toString());\n\t\t\t}\n\t\t}\n\n\t\treturn newTemplate;\n\t}","commit_id":"80c8c54e3cc95429f59b8df410f42e085a43b1d7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private DefaultGradleLauncher doNewInstance(StartParameter startParameter, BuildRequestMetaData requestMetaData) {\n        final TopLevelBuildServiceRegistry serviceRegistry = new TopLevelBuildServiceRegistry(sharedServices, startParameter);\n        serviceRegistry.add(BuildRequestMetaData.class, requestMetaData);\n        serviceRegistry.add(BuildClientMetaData.class, requestMetaData.getClient());\n        ListenerManager listenerManager = serviceRegistry.get(ListenerManager.class);\n        LoggingManagerInternal loggingManager = serviceRegistry.newInstance(LoggingManagerInternal.class);\n        loggingManager.setLevel(startParameter.getLogLevel());\n\n        //this hooks up the ListenerManager and LoggingConfigurer so you can call Gradle.addListener() with a StandardOutputListener.\n        loggingManager.addStandardOutputListener(listenerManager.getBroadcaster(StandardOutputListener.class));\n        loggingManager.addStandardErrorListener(listenerManager.getBroadcaster(StandardOutputListener.class));\n\n        listenerManager.useLogger(new TaskExecutionLogger(serviceRegistry.get(ProgressLoggerFactory.class)));\n        if (tracker.getCurrentBuild() == null) {\n            listenerManager.useLogger(new BuildLogger(Logging.getLogger(BuildLogger.class), serviceRegistry.get(StyledTextOutputFactory.class), startParameter, requestMetaData));\n        }\n        listenerManager.addListener(tracker);\n        listenerManager.addListener(new BuildCleanupListener(serviceRegistry));\n\n        listenerManager.addListener(serviceRegistry.get(ProfileEventAdapter.class));\n        if (startParameter.isProfile()) {\n            listenerManager.addListener(new ReportGeneratingProfileListener());\n        }\n\n        GradleInternal gradle = serviceRegistry.get(Instantiator.class).newInstance(DefaultGradle.class, tracker.getCurrentBuild(), startParameter, serviceRegistry);\n        return new DefaultGradleLauncher(\n                gradle,\n                serviceRegistry.get(InitScriptHandler.class),\n                new SettingsHandler(\n                        new DefaultSettingsFinder(\n                                new BuildLayoutFactory()),\n                        serviceRegistry.get(SettingsProcessor.class),\n                        new BuildSourceBuilder(\n                                this,\n                                serviceRegistry.get(ClassLoaderRegistry.class),\n                                serviceRegistry.get(CacheRepository.class))),\n                serviceRegistry.get(BuildLoader.class),\n                serviceRegistry.get(BuildConfigurer.class),\n                gradle.getBuildListenerBroadcaster(),\n                serviceRegistry.get(ExceptionAnalyser.class),\n                loggingManager,\n                listenerManager.getBroadcaster(ModelConfigurationListener.class),\n                listenerManager.getBroadcaster(TasksCompletionListener.class),\n                gradle.getServices().get(BuildExecuter.class));\n    }","id":101653,"modified_method":"private DefaultGradleLauncher doNewInstance(StartParameter startParameter, BuildRequestMetaData requestMetaData) {\n        final TopLevelBuildServiceRegistry serviceRegistry = new TopLevelBuildServiceRegistry(sharedServices, startParameter);\n        serviceRegistry.add(BuildRequestMetaData.class, requestMetaData);\n        serviceRegistry.add(BuildClientMetaData.class, requestMetaData.getClient());\n        ListenerManager listenerManager = serviceRegistry.get(ListenerManager.class);\n        LoggingManagerInternal loggingManager = serviceRegistry.newInstance(LoggingManagerInternal.class);\n        loggingManager.setLevel(startParameter.getLogLevel());\n\n        //this hooks up the ListenerManager and LoggingConfigurer so you can call Gradle.addListener() with a StandardOutputListener.\n        loggingManager.addStandardOutputListener(listenerManager.getBroadcaster(StandardOutputListener.class));\n        loggingManager.addStandardErrorListener(listenerManager.getBroadcaster(StandardOutputListener.class));\n\n        listenerManager.useLogger(new TaskExecutionLogger(serviceRegistry.get(ProgressLoggerFactory.class)));\n        if (tracker.getCurrentBuild() == null) {\n            listenerManager.useLogger(new BuildLogger(Logging.getLogger(BuildLogger.class), serviceRegistry.get(StyledTextOutputFactory.class), startParameter, requestMetaData));\n        }\n        listenerManager.addListener(tracker);\n        listenerManager.addListener(new BuildCleanupListener(serviceRegistry));\n\n        listenerManager.addListener(serviceRegistry.get(ProfileEventAdapter.class));\n        if (startParameter.isProfile()) {\n            listenerManager.addListener(new ReportGeneratingProfileListener());\n        }\n        ScriptUsageLocationReporter usageLocationReporter = new ScriptUsageLocationReporter();\n        listenerManager.addListener(usageLocationReporter);\n        DeprecationLogger.useLocationReporter(usageLocationReporter);\n\n        GradleInternal gradle = serviceRegistry.get(Instantiator.class).newInstance(DefaultGradle.class, tracker.getCurrentBuild(), startParameter, serviceRegistry);\n        return new DefaultGradleLauncher(\n                gradle,\n                serviceRegistry.get(InitScriptHandler.class),\n                new SettingsHandler(\n                        new DefaultSettingsFinder(\n                                new BuildLayoutFactory()),\n                        serviceRegistry.get(SettingsProcessor.class),\n                        new BuildSourceBuilder(\n                                this,\n                                serviceRegistry.get(ClassLoaderRegistry.class),\n                                serviceRegistry.get(CacheRepository.class))),\n                serviceRegistry.get(BuildLoader.class),\n                serviceRegistry.get(BuildConfigurer.class),\n                gradle.getBuildListenerBroadcaster(),\n                serviceRegistry.get(ExceptionAnalyser.class),\n                loggingManager,\n                listenerManager.getBroadcaster(ModelConfigurationListener.class),\n                listenerManager.getBroadcaster(TasksCompletionListener.class),\n                gradle.getServices().get(BuildExecuter.class));\n    }","commit_id":"57d2ab955a3caf39b1dca656e169984e3ed574e5","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Creates a copy of this usage with the stack trace populated. Implementation is a bit limited in that it assumes that\n     * this method is called from the same thread that triggered the usage.\n     */\n    public DeprecatedFeatureUsage withStackTrace() {\n        if (!stack.isEmpty()) {\n            return this;\n        }\n\n        StackTraceElement[] originalStack = StackTraceUtils.sanitize(new Exception()).getStackTrace();\n        int caller = 0;\n        while (caller < originalStack.length && !originalStack[caller].getClassName().startsWith(calledFrom.getName())) {\n            caller++;\n        }\n        while (caller < originalStack.length && originalStack[caller].getClassName().startsWith(calledFrom.getName())) {\n            caller++;\n        }\n        List<StackTraceElement> stack = new ArrayList<StackTraceElement>();\n        for (; caller < originalStack.length; caller++) {\n            stack.add(originalStack[caller]);\n        }\n        return new DeprecatedFeatureUsage(this, stack);\n    }","id":101654,"modified_method":"/**\n     * Creates a copy of this usage with the stack trace populated. Implementation is a bit limited in that it assumes that\n     * this method is called from the same thread that triggered the usage.\n     */\n    public DeprecatedFeatureUsage withStackTrace() {\n        if (!stack.isEmpty()) {\n            return this;\n        }\n\n        StackTraceElement[] originalStack = StackTraceUtils.sanitize(new Exception()).getStackTrace();\n        int caller = 0;\n        while (caller < originalStack.length && !originalStack[caller].getClassName().startsWith(calledFrom.getName())) {\n            caller++;\n        }\n        while (caller < originalStack.length && originalStack[caller].getClassName().startsWith(calledFrom.getName())) {\n            caller++;\n        }\n        caller++;\n        List<StackTraceElement> stack = new ArrayList<StackTraceElement>();\n        for (; caller < originalStack.length; caller++) {\n            stack.add(originalStack[caller]);\n        }\n        return new DeprecatedFeatureUsage(this, stack);\n    }","commit_id":"57d2ab955a3caf39b1dca656e169984e3ed574e5","url":"https://github.com/gradle/gradle"},{"original_method":"public void deprecatedFeatureUsed(DeprecatedFeatureUsage usage) {\n        if (messages.add(usage.getMessage())) {\n            usage = usage.withStackTrace();\n            LOGGER.warn(usage.getMessage());\n            logTraceIfNecessary(usage.getStack());\n        }\n    }","id":101655,"modified_method":"public void deprecatedFeatureUsed(DeprecatedFeatureUsage usage) {\n        if (messages.add(usage.getMessage())) {\n            usage = usage.withStackTrace();\n            StringBuilder message = new StringBuilder();\n            locationReporter.reportLocation(usage, message);\n            if (message.length() > 0) {\n                message.append(SystemProperties.getLineSeparator());\n            }\n            message.append(usage.getMessage());\n            logTraceIfNecessary(usage.getStack(), message);\n            LOGGER.warn(message.toString());\n        }\n    }","commit_id":"57d2ab955a3caf39b1dca656e169984e3ed574e5","url":"https://github.com/gradle/gradle"},{"original_method":"private void logTraceIfNecessary(List<StackTraceElement> stack) {\n        if (isTraceLoggingEnabled()) {\n            for (StackTraceElement frame : stack) {\n                LOGGER.warn(\"    {}\", frame.toString());\n            }\n        }\n    }","id":101656,"modified_method":"private void logTraceIfNecessary(List<StackTraceElement> stack, StringBuilder message) {\n        if (isTraceLoggingEnabled()) {\n            for (StackTraceElement frame : stack) {\n                message.append(SystemProperties.getLineSeparator());\n                message.append(\"    \");\n                message.append(frame.toString());\n            }\n        }\n    }","commit_id":"57d2ab955a3caf39b1dca656e169984e3ed574e5","url":"https://github.com/gradle/gradle"},{"original_method":"@Inject\n  public DashboardHttpHandler(Authenticator authenticator) {\n    super(authenticator);\n    this.configStore = HashBasedTable.create();\n  }","id":101657,"modified_method":"@Inject\n  public DashboardHttpHandler(Authenticator authenticator, ConfigStore configStore) {\n    super(authenticator);\n    this.configStore = configStore;\n  }","commit_id":"0a14aaf78b140fd39fb5ffa9c654397f1c0ac647","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getStandaloneModules() {\n\n    return Modules.combine(new AppFabricServiceModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n                             }\n                           });\n  }","id":101658,"modified_method":"@Override\n  public Module getStandaloneModules() {\n\n    return Modules.combine(new AppFabricServiceModule(),\n                           new ConfigStoreModule().getStandaloneModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n                             }\n                           });\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getDistributedModules() {\n\n\n    return Modules.combine(new AppFabricServiceModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(DistributedSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(LogSaverStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(TransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(MetricsProcessorStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(MetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(StreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(DatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(ExploreServiceManager.class);\n                             }\n                           });\n  }","id":101659,"modified_method":"@Override\n  public Module getDistributedModules() {\n\n\n    return Modules.combine(new AppFabricServiceModule(),\n                           new ConfigStoreModule().getDistributedModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(DistributedSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(LogSaverStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(TransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(MetricsProcessorStatusServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(MetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(StreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(DatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(ExploreServiceManager.class);\n                             }\n                           });\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Module getInMemoryModules() {\n    return Modules.combine(new AppFabricServiceModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n                             }\n                           });\n  }","id":101660,"modified_method":"@Override\n  public Module getInMemoryModules() {\n    return Modules.combine(new AppFabricServiceModule(),\n                           new ConfigStoreModule().getInMemoryModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               bind(SchedulerService.class).to(LocalSchedulerService.class).in(Scopes.SINGLETON);\n                               bind(Scheduler.class).to(SchedulerService.class);\n\n                               MapBinder<String, MasterServiceManager> mapBinder = MapBinder.newMapBinder(\n                                 binder(), String.class, MasterServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.LOGSAVER)\n                                        .to(InMemoryLogSaverServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.TRANSACTION)\n                                        .to(InMemoryTransactionServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS_PROCESSOR)\n                                        .to(InMemoryMetricsProcessorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.METRICS)\n                                        .to(InMemoryMetricsServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.APP_FABRIC_HTTP)\n                                        .to(AppFabricServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.STREAMS)\n                                        .to(InMemoryStreamServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.DATASET_EXECUTOR)\n                                        .to(InMemoryDatasetExecutorServiceManager.class);\n                               mapBinder.addBinding(Constants.Service.EXPLORE_HTTP_USER_SERVICE)\n                                        .to(InMemoryExploreServiceManager.class);\n                             }\n                           });\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public WorkflowSpecification configure() {\n      return WorkflowSpecification.Builder.with()\n        .setName(\"SampleWorkflow\")\n        .setDescription(\"SampleWorkflow description\")\n        .startWith(new DummyAction())\n        .last(new DummyAction())\n        .addSchedule(new Schedule(\"Schedule\", \"Run every second\", \"0/1 * * * * ?\",\n                                  Schedule.Action.START))\n        .build();\n    }","id":101661,"modified_method":"@Override\n    public WorkflowSpecification configure() {\n      return WorkflowSpecification.Builder.with()\n        .setName(\"SampleWorkflow\")\n        .setDescription(\"SampleWorkflow description\")\n        .onlyWith(new DummyAction())\n        .addSchedule(new Schedule(\"Schedule\", \"Run every second\", \"0/1 * * * * ?\",\n                                  Schedule.Action.START))\n        .build();\n    }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DashboardHttpHandler(Authenticator authenticator) {\n    super(authenticator);\n    this.configStore = HashBasedTable.create();\n  }","id":101662,"modified_method":"@Inject\n  public DashboardHttpHandler(Authenticator authenticator, ConfigStore configStore) {\n    super(authenticator);\n    this.configStore = configStore;\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCleanSlate() throws Exception {\n    JsonElement dash = getDashboards(\"mynamespace\");\n    Assert.assertTrue(dash.isJsonArray());\n    Assert.assertEquals(0, dash.getAsJsonArray().size());\n\n    String s = createDashboard(\"mynamespace\", 200);\n    dash = getDashboards(\"mynamespace\");\n    Assert.assertTrue(dash.isJsonArray());\n    Assert.assertEquals(1, dash.getAsJsonArray().size());\n\n    deleteDashboard(\"mynamespace\", s, 200);\n    deleteDashboard(\"mynamespace\", s, 404);\n\n    dash = getDashboards(\"mynamespace\");\n    Assert.assertTrue(dash.isJsonArray());\n    Assert.assertEquals(0, dash.getAsJsonArray().size());\n  }","id":101663,"modified_method":"@Test\n  public void testCleanSlate() throws Exception {\n    JsonElement dash = getDashboards(\"mynamespace\");\n    Assert.assertTrue(dash.isJsonArray());\n    Assert.assertEquals(0, dash.getAsJsonArray().size());\n\n    String s = createDashboard(\"mynamespace\", 200);\n    dash = getDashboards(\"mynamespace\");\n    Assert.assertTrue(dash.isJsonArray());\n    Assert.assertEquals(1, dash.getAsJsonArray().size());\n    String id = dash.getAsJsonArray().get(0).getAsJsonObject().get(\"id\").getAsString();\n    Assert.assertEquals(id, s);\n    Assert.assertEquals(new JsonParser().parse(\"{}\"), dash.getAsJsonArray().get(0).getAsJsonObject().get(\"config\"));\n\n    deleteDashboard(\"mynamespace\", s, 200);\n    deleteDashboard(\"mynamespace\", s, 404);\n\n    dash = getDashboards(\"mynamespace\");\n    Assert.assertTrue(dash.isJsonArray());\n    Assert.assertEquals(0, dash.getAsJsonArray().size());\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"private byte[] rowKey(String namespace, String type, String id) {\n    return Bytes.toBytes(rowKeyString(namespace, type, id));\n  }","id":101664,"modified_method":"private byte[] rowKey(String namespace, String type, String id) {\n    return getMultipartKey(namespace, type, id);\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"private byte[] rowKeyPrefix(String namespace, String type) {\n    return Bytes.toBytes(rowKeyPrefixString(namespace, type));\n  }","id":101665,"modified_method":"private byte[] rowKeyPrefix(String namespace, String type) {\n    return getMultipartKey(namespace, type);\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<Config> list(final String namespace, final String type) {\n    return txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, List<Config>>() {\n      @Override\n      public List<Config> apply(ConfigTable configTable) throws Exception {\n        List<Config> configList = Lists.newArrayList();\n        byte[] prefixBytes = rowKeyPrefix(namespace, type);\n        Scanner rows = configTable.table.scan(prefixBytes, Bytes.stopKeyForPrefix(prefixBytes));\n        Row row;\n        while ((row = rows.next()) != null) {\n          Map<String, String> properties = GSON.fromJson(Bytes.toString(row.get(Bytes.toBytes(PROPERTY_COLUMN))),\n                                                         MAP_STRING_STRING_TYPE);\n          configList.add(new Config(getId(row.getRow(), prefixBytes), properties));\n        }\n        return configList;\n      }\n    });\n  }","id":101666,"modified_method":"@Override\n  public List<Config> list(final String namespace, final String type) {\n    return txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, List<Config>>() {\n      @Override\n      public List<Config> apply(ConfigTable configTable) throws Exception {\n        List<Config> configList = Lists.newArrayList();\n        byte[] prefixBytes = rowKeyPrefix(namespace, type);\n        Scanner rows = configTable.table.scan(prefixBytes, Bytes.stopKeyForPrefix(prefixBytes));\n        Row row;\n        while ((row = rows.next()) != null) {\n          Map<String, String> properties = GSON.fromJson(Bytes.toString(row.get(Bytes.toBytes(PROPERTY_COLUMN))),\n                                                         MAP_STRING_STRING_TYPE);\n          configList.add(new Config(getPart(row.getRow(), prefixBytes.length), properties));\n        }\n        return configList;\n      }\n    });\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"public void setSystemServiceInstances(String serviceName, int instances)\n    throws IOException, NotFoundException, BadRequestException, UnAuthorizedAccessTokenException {\n\n    URL url = config.resolveURL(String.format(\"system/services/%s/instances\", serviceName));\n    HttpRequest request = HttpRequest.put(url).withBody(GSON.toJson(new Instances(instances))).build();\n    HttpResponse response = restClient.execute(request, config.getAccessToken(),\n                                               HttpURLConnection.HTTP_NOT_FOUND,\n                                               HttpURLConnection.HTTP_BAD_REQUEST);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotFoundException(\"system service\", serviceName);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_BAD_REQUEST) {\n      throw new BadRequestException(new String(response.getResponseBody()));\n    }\n  }","id":101667,"modified_method":"/**\n   * Sets the number of instances the system service is running on.\n   *\n   * @param serviceName name of the system service\n   * @param instances number of instances the system service is running on\n   * @throws IOException if a network error occurred\n   * @throws NotFoundException if the system service with the specified name was not found\n   * @throws UnAuthorizedAccessTokenException if the request is not authorized successfully in the gateway server\n   */\n  public void setSystemServiceInstances(String serviceName, int instances)\n    throws IOException, NotFoundException, BadRequestException, UnAuthorizedAccessTokenException {\n\n    URL url = config.resolveURL(String.format(\"system/services/%s/instances\", serviceName));\n    HttpRequest request = HttpRequest.put(url).withBody(GSON.toJson(new Instances(instances))).build();\n    HttpResponse response = restClient.execute(request, config.getAccessToken(),\n                                               HttpURLConnection.HTTP_NOT_FOUND,\n                                               HttpURLConnection.HTTP_BAD_REQUEST);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotFoundException(\"system service\", serviceName);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_BAD_REQUEST) {\n      throw new BadRequestException(new String(response.getResponseBody()));\n    }\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int read(Collection<? super StreamEventOffset> events, int maxEvents,\n                  long timeout, TimeUnit unit, ReadFilter readFilter) throws IOException, InterruptedException {\n    int eventsRead = 0;\n\n    Stopwatch stopwatch = new Stopwatch();\n    stopwatch.start();\n\n    while (eventsRead < maxEvents && !(emptySources.isEmpty() && eventSources.isEmpty())) {\n      if (!emptySources.isEmpty()) {\n        prepareEmptySources(readFilter);\n      }\n      eventsRead += read(events, readFilter);\n\n      if (eventSources.isEmpty() && stopwatch.elapsedTime(unit) > timeout) {\n        break;\n      }\n    }\n\n    return (eventsRead == 0 && emptySources.isEmpty() && eventSources.isEmpty()) ? -1 : eventsRead;\n  }","id":101668,"modified_method":"@Override\n  public int read(Collection<? super StreamEventOffset> events, int maxEvents,\n                  long timeout, TimeUnit unit, ReadFilter readFilter) throws IOException, InterruptedException {\n    int eventsRead = 0;\n\n    Stopwatch stopwatch = new Stopwatch();\n    stopwatch.start();\n\n    while (eventsRead < maxEvents && !(emptySources.isEmpty() && eventSources.isEmpty())) {\n      if (!emptySources.isEmpty()) {\n        prepareEmptySources(readFilter);\n      }\n      eventsRead += read(events, readFilter);\n\n      if (eventSources.isEmpty() && stopwatch.elapsedTime(unit) >= timeout) {\n        break;\n      }\n    }\n\n    return (eventsRead == 0 && emptySources.isEmpty() && eventSources.isEmpty()) ? -1 : eventsRead;\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int read(Collection<? super PositionStreamEvent> events, int maxEvents,\n                  long timeout, TimeUnit unit, ReadFilter readFilter) throws IOException, InterruptedException {\n    if (closed) {\n      throw new IOException(\"Reader already closed.\");\n    }\n\n    int eventCount = 0;\n    long sleepNano = computeSleepNano(timeout, unit);\n    try {\n      Stopwatch stopwatch = new Stopwatch();\n      stopwatch.start();\n\n      // Keep reading events until max events.\n      while (!eof && eventCount < maxEvents) {\n        try {\n          if (eventInput == null) {\n            doOpen();\n          }\n\n          PositionStreamEvent event = nextStreamEvent(readFilter);\n          if (event != null) {\n            events.add(event);\n            eventCount++;\n          } else if (eof) {\n            break;\n          }\n\n          position = eventInput.getPos();\n\n        } catch (IOException e) {\n          if (eventInput != null) {\n            eventInput.close();\n            eventInput = null;\n          }\n\n          if (!(e instanceof EOFException || e instanceof FileNotFoundException)) {\n            throw e;\n          }\n\n          // If end of stream file or no timeout is allowed, break the loop.\n          if (eof || timeout <= 0) {\n            break;\n          }\n\n          if (stopwatch.elapsedTime(unit) > timeout) {\n            break;\n          }\n\n          TimeUnit.NANOSECONDS.sleep(sleepNano);\n\n          if (stopwatch.elapsedTime(unit) > timeout) {\n            break;\n          }\n        }\n      }\n\n      return (eventCount == 0 && eof) ? -1 : eventCount;\n\n    } catch (IOException e) {\n      close();\n      throw e;\n    }\n  }","id":101669,"modified_method":"@Override\n  public int read(Collection<? super PositionStreamEvent> events, int maxEvents,\n                  long timeout, TimeUnit unit, ReadFilter readFilter) throws IOException, InterruptedException {\n    if (closed) {\n      throw new IOException(\"Reader already closed.\");\n    }\n\n    int eventCount = 0;\n    long sleepNano = computeSleepNano(timeout, unit);\n    try {\n      Stopwatch stopwatch = new Stopwatch();\n      stopwatch.start();\n\n      // Keep reading events until max events.\n      while (!eof && eventCount < maxEvents) {\n        try {\n          if (eventInput == null) {\n            doOpen();\n          }\n\n          PositionStreamEvent event = nextStreamEvent(readFilter);\n          if (event != null) {\n            events.add(event);\n            eventCount++;\n          } else if (eof) {\n            break;\n          }\n\n          position = eventInput.getPos();\n\n        } catch (IOException e) {\n          if (eventInput != null) {\n            eventInput.close();\n            eventInput = null;\n          }\n\n          if (!(e instanceof EOFException || e instanceof FileNotFoundException)) {\n            throw e;\n          }\n\n          // If end of stream file or no timeout is allowed, break the loop.\n          if (eof || timeout <= 0) {\n            break;\n          }\n\n          if (stopwatch.elapsedTime(unit) >= timeout) {\n            break;\n          }\n\n          TimeUnit.NANOSECONDS.sleep(sleepNano);\n\n          if (stopwatch.elapsedTime(unit) >= timeout) {\n            break;\n          }\n        }\n      }\n\n      return (eventCount == 0 && eof) ? -1 : eventCount;\n\n    } catch (IOException e) {\n      close();\n      throw e;\n    }\n  }","commit_id":"e2d1628a21fac7d1161470237565a4a79d19ee84","url":"https://github.com/caskdata/cdap"},{"original_method":"private ActionForward cancelActions(ActionMapping mapping, HttpServletRequest request) {\n        RequestContext requestContext = new RequestContext(request);\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        User user = requestContext.getLoggedInUser();\n        RhnSet set = getSetDecl().get(user);\n\n\n        List actionsToCancel = new LinkedList();\n\n        for (RhnSetElement element : set.getElements()) {\n            actionsToCancel.add(element.getElement());\n        }\n\n        ActionManager.removeActions(actionsToCancel);\n\n\n        ActionMessages msgs = new ActionMessages();\n        // If there was only one action cancelled, display the \"action\" cancelled\n        // message, else display the \"actions\" archived message.\n        if (set.size() == 1) {\n            msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                     new ActionMessage(\"message.actionCancelled\",\n                             LocalizationService.getInstance()\n                                                .formatNumber(new Integer(set.size()))));\n        }\n        else {\n            msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                     new ActionMessage(\"message.actionsCancelled\",\n                             LocalizationService.getInstance()\n                                                .formatNumber(new Integer(set.size()))));\n        }\n        strutsDelegate.saveMessages(request, msgs);\n\n        set.clear();\n        RhnSetManager.store(set);\n\n\n        return  mapping.findForward(\"success\");\n\n    }","id":101670,"modified_method":"private ActionForward cancelActions(ActionMapping mapping, HttpServletRequest request) {\n        RequestContext requestContext = new RequestContext(request);\n        StrutsDelegate strutsDelegate = getStrutsDelegate();\n\n        User user = requestContext.getLoggedInUser();\n        RhnSet set = getSetDecl().get(user);\n\n\n        List<Action> actionsToCancel = new LinkedList();\n\n        for (RhnSetElement element : set.getElements()) {\n            actionsToCancel.add(ActionFactory.lookupById(element.getElement()));\n        }\n        ActionManager.cancelActions(user, actionsToCancel);\n\n        ActionMessages msgs = new ActionMessages();\n        // If there was only one action cancelled, display the \"action\" cancelled\n        // message, else display the \"actions\" archived message.\n        if (set.size() == 1) {\n            msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                     new ActionMessage(\"message.actionCancelled\",\n                             LocalizationService.getInstance()\n                                                .formatNumber(new Integer(set.size()))));\n        }\n        else {\n            msgs.add(ActionMessages.GLOBAL_MESSAGE,\n                     new ActionMessage(\"message.actionsCancelled\",\n                             LocalizationService.getInstance()\n                                                .formatNumber(new Integer(set.size()))));\n        }\n        strutsDelegate.saveMessages(request, msgs);\n\n        set.clear();\n        RhnSetManager.store(set);\n\n        return  mapping.findForward(\"success\");\n    }","commit_id":"10fa99004b5d9a177cfe3aba8082c48bd6aa4227","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * @param scriptActionDetailsIn The scriptActionDetails to set.\n     */\n    public void setScriptActionDetails(ScriptActionDetails scriptActionDetailsIn) {\n        scriptActionDetailsIn.setParentAction(this);\n        scriptActionDetails = scriptActionDetailsIn;\n    }","id":101671,"modified_method":"/**\n     * @param scriptActionDetailsIn The scriptActionDetails to set.\n     */\n    public void setScriptActionDetails(ScriptActionDetails scriptActionDetailsIn) {\n        if (scriptActionDetailsIn != null) {\n            scriptActionDetailsIn.setParentAction(this);\n        }\n        scriptActionDetails = scriptActionDetailsIn;\n    }","commit_id":"10fa99004b5d9a177cfe3aba8082c48bd6aa4227","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private void render(String value) throws JspException {\n        writeStartingTd();\n        String id = ListTagHelper.getObjectId(getCurrent());\n        String checkboxId = makeCheckboxId(listName, id);\n        renderHiddenItem(id, value);\n        ListTagUtil.write(pageContext, \"<input type=\\\"checkbox\\\" \");\n        boolean selected = isSelected();\n        if (selected) {\n            ListTagUtil.incrementPersistentCounter(pageContext, listName + \"_selected\");\n            ListTagUtil.write(pageContext, \"checked \");\n        }\n        if (isDisabled()) {\n            ListTagUtil.write(pageContext, \"disabled \");\n        }\n        ListTagUtil.write(pageContext, \"id=\\\"\");\n\n        ListTagUtil.write(pageContext, checkboxId);\n\n\n        String itemsName = ListTagUtil.makeSelectedItemsName(listName);\n        ListTag parent = (ListTag)\n                    BodyTagSupport.findAncestorWithClass(this, ListTag.class);\n        if (!parent.isParentAnElement() &&\n                    RhnListTagFunctions.isExpandable(getCurrent())) {\n            itemsName = \"parent_\" + itemsName;\n        }\n        ListTagUtil.write(pageContext, \"\\\" name=\\\"\" + itemsName + \"\\\" \");\n        ListTagUtil.write(pageContext, \"value=\\\"\");\n        ListTagUtil.write(pageContext, value);\n        ListTagUtil.write(pageContext, \"\\\" \");\n        renderOnClick();\n\n        ListTagUtil.write(pageContext, \"/>\");\n        if (selected && !StringUtils.isBlank(rhnSet)) {\n            String scriptId = \"document.getElementById('\" + checkboxId + \"')\";\n            addPostScript(getOnClickScript(CLICKED_CLIENT_SIDE, scriptId),\n                                            listName, pageContext.getRequest());\n        }\n    }","id":101672,"modified_method":"private void render(String value) throws JspException {\n        writeStartingTd();\n        String id = ListTagHelper.getObjectId(getCurrent());\n        String checkboxId = makeCheckboxId(listName, id);\n        renderHiddenItem(id, value);\n\n        if (isHideDisabled() && isDisabled()) {\n            return;\n        }\n\n        ListTagUtil.write(pageContext, \"<input type=\\\"checkbox\\\" \");\n        boolean selected = isSelected();\n        if (selected) {\n            ListTagUtil.incrementPersistentCounter(pageContext, listName + \"_selected\");\n            ListTagUtil.write(pageContext, \"checked \");\n        }\n        if (isDisabled()) {\n            ListTagUtil.write(pageContext, \"disabled \");\n        }\n        ListTagUtil.write(pageContext, \"id=\\\"\");\n\n        ListTagUtil.write(pageContext, checkboxId);\n\n\n        String itemsName = ListTagUtil.makeSelectedItemsName(listName);\n        ListTag parent = (ListTag)\n                    BodyTagSupport.findAncestorWithClass(this, ListTag.class);\n        if (!parent.isParentAnElement() &&\n                    RhnListTagFunctions.isExpandable(getCurrent())) {\n            itemsName = \"parent_\" + itemsName;\n        }\n        ListTagUtil.write(pageContext, \"\\\" name=\\\"\" + itemsName + \"\\\" \");\n        ListTagUtil.write(pageContext, \"value=\\\"\");\n        ListTagUtil.write(pageContext, value);\n        ListTagUtil.write(pageContext, \"\\\" \");\n        renderOnClick();\n\n        ListTagUtil.write(pageContext, \"/>\");\n        if (selected && !StringUtils.isBlank(rhnSet)) {\n            String scriptId = \"document.getElementById('\" + checkboxId + \"')\";\n            addPostScript(getOnClickScript(CLICKED_CLIENT_SIDE, scriptId),\n                                            listName, pageContext.getRequest());\n        }\n    }","commit_id":"10fa99004b5d9a177cfe3aba8082c48bd6aa4227","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected List<Action> doSchedule(SsmPackageEvent event,\n                                      User user,\n                                      List<Long> sids,\n                                      Date earliest) {\n        SsmInstallPackagesEvent sipe = (SsmInstallPackagesEvent) event;\n\n        Set<String> data = sipe.getPackages();\n        // Convert the package list to domain objects\n        List<PackageListItem> packageListItems =\n                new ArrayList<PackageListItem>(data.size());\n        for (String key : data) {\n            packageListItems.add(PackageListItem.parse(key));\n        }\n\n        // Convert to list of maps\n        List<Map<String, Long>> packageListData = PackageListItem\n                .toKeyMaps(packageListItems);\n\n        List<Action> pkgActions = ActionManager.schedulePackageInstall(user, sids,\n                packageListData, earliest);\n\n        return pkgActions;\n    }","id":101673,"modified_method":"protected List<Action> doSchedule(SsmPackageEvent event, User user, List<Long> sids,\n                    Date earliest) {\n        SsmInstallPackagesEvent sipe = (SsmInstallPackagesEvent) event;\n\n        Set<String> data = sipe.getPackages();\n        // Convert the package list to domain objects\n        List<PackageListItem> pkgListItems = new ArrayList<PackageListItem>(data.size());\n        for (String key : data) {\n            pkgListItems.add(PackageListItem.parse(key));\n        }\n\n        // Convert to list of maps\n        List<Map<String, Long>> packageListData = PackageListItem\n                        .toKeyMaps(pkgListItems);\n\n        List<Action> pkgActions = ActionManager.schedulePackageInstall(user, sids,\n                        packageListData, earliest);\n\n        return pkgActions;\n    }","commit_id":"10fa99004b5d9a177cfe3aba8082c48bd6aa4227","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected void scheduleAction(SsmPackageEvent event, User user) {\n\n        log.debug(\"Scheduling package actions.\");\n        Date earliest = event.getEarliest();\n\n        List<Long> serverIds = getAffectedServers(event, user);\n\n        log.debug(\"Scheduling actions.\");\n        // If we have a remote-cmd, have to correctly order it and the package action(s)\n        if (event.getScriptDetails() != null) {\n            ScriptActionDetails sad = event.getScriptDetails();\n            if (event.isBefore()) {\n                log.debug(\"Scheduling remote-action BEFORE.\");\n\n                ScriptRunAction sra = ActionManager.scheduleScriptRun(user, serverIds,\n                        null, sad, earliest);\n                ActionManager.storeAction(sra);\n\n                List<Action> pkgActions = doSchedule(event, user, serverIds, earliest);\n\n                // Might be more than one action from schedPkgActions\n                Action prevAction = sra;\n                for (Action a : pkgActions) {\n                    a.setPrerequisite(prevAction);\n                    ActionManager.storeAction(a);\n                    prevAction = a;\n                }\n\n            }\n            else {\n                log.debug(\"Scheduling remote-action AFTER.\");\n\n                List<Action> pkgActions = doSchedule(event, user, serverIds, earliest);\n                ScriptRunAction sra = ActionManager.scheduleScriptRun(user, serverIds,\n                        null, sad, earliest);\n\n                // Might be more than one action from schedPkgActions\n                Action prevAction = null;\n                for (Action a : pkgActions) {\n                    if (prevAction != null) {\n                        a.setPrerequisite(prevAction);\n                    }\n                    ActionManager.storeAction(a);\n                    prevAction = a;\n                }\n\n                sra.setPrerequisite(prevAction);\n                ActionManager.storeAction(sra);\n            }\n        }\n        else { // No remote-script to schedule\n            doSchedule(event, user, serverIds, earliest);\n        }\n        log.debug(\"Done scheduling package actions.\");\n\n    }","id":101674,"modified_method":"protected void scheduleAction(SsmPackageEvent event, User user) {\n\n        log.debug(\"Scheduling package actions.\");\n        Date earliest = event.getEarliest();\n\n        List<Long> serverIds = getAffectedServers(event, user);\n\n        log.debug(\"Scheduling actions.\");\n\n        // If we have a remote-cmd, have to correctly order it and the package action(s)\n        if (event.getScriptDetails() != null) {\n            for (Long sid : serverIds) {\n                Server s = ServerFactory.lookupById(sid);\n                List<Long> sidList = new ArrayList<Long>();\n                sidList.add(sid);\n                ScriptActionDetails sad = event.getScriptDetails();\n                if (event.isBefore()) {\n                    log.debug(\"Scheduling remote-action BEFORE.\");\n\n                    ScriptRunAction sra = ActionManager.scheduleScriptRun(user, sidList,\n                                    null, sad, earliest);\n                    ActionManager.storeAction(sra);\n\n                    Action pkgAction = doSchedule(event, user, s, earliest);\n\n                    Action prevAction = sra;\n                        pkgAction.setPrerequisite(prevAction);\n                        ActionManager.storeAction(pkgAction);\n                        prevAction = pkgAction;\n\n                }\n                else {\n                    log.debug(\"Scheduling remote-action AFTER.\");\n\n                    Action pkgAction = doSchedule(event, user, s, earliest);\n                    ScriptRunAction sra = ActionManager.scheduleScriptRun(user, sidList,\n                                    null, sad, earliest);\n\n                    // Might be more than one action from schedPkgActions\n                    Action prevAction = null;\n                        if (prevAction != null) {\n                            pkgAction.setPrerequisite(prevAction);\n                        }\n                        ActionManager.storeAction(pkgAction);\n                        prevAction = pkgAction;\n\n                    sra.setPrerequisite(prevAction);\n                    ActionManager.storeAction(sra);\n                }\n            }\n        }\n        else { // No remote-script to schedule\n            doSchedule(event, user, serverIds, earliest);\n        }\n        log.debug(\"Done scheduling package actions.\");\n\n    }","commit_id":"10fa99004b5d9a177cfe3aba8082c48bd6aa4227","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected abstract List<Action> doSchedule(SsmPackageEvent event,\n                                               User user,\n                                               List<Long> sids,\n                                               Date earliest);","id":101675,"modified_method":"protected abstract List<Action> doSchedule(SsmPackageEvent event,\n                    User user,\n                    List<Long> sid,\n                    Date earliest);","commit_id":"10fa99004b5d9a177cfe3aba8082c48bd6aa4227","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected void scheduleAction(SsmPackageEvent event, User user) {\n\n        log.debug(\"Scheduling package actions.\");\n        Date earliest = event.getEarliest();\n\n        List<Long> serverIds = getAffectedServers(event, user);\n\n        log.debug(\"Scheduling actions.\");\n\n        // If we have a remote-cmd, have to correctly order it and the package action(s)\n        if (event.getScriptDetails() != null) {\n            for (Long sid : serverIds) {\n                Server s = ServerFactory.lookupById(sid);\n                List<Long> sidList = new ArrayList<Long>();\n                sidList.add(sid);\n                ScriptActionDetails sad = event.getScriptDetails();\n                if (event.isBefore()) {\n                    log.debug(\"Scheduling remote-action BEFORE.\");\n\n                    ScriptRunAction sra = ActionManager.scheduleScriptRun(user, sidList,\n                                    null, sad, earliest);\n                    ActionManager.storeAction(sra);\n\n                    Action pkgAction = doSchedule(event, user, s, earliest);\n\n                    Action prevAction = sra;\n                        pkgAction.setPrerequisite(prevAction);\n                        ActionManager.storeAction(pkgAction);\n                        prevAction = pkgAction;\n\n                }\n                else {\n                    log.debug(\"Scheduling remote-action AFTER.\");\n\n                    Action pkgAction = doSchedule(event, user, s, earliest);\n                    ScriptRunAction sra = ActionManager.scheduleScriptRun(user, sidList,\n                                    null, sad, earliest);\n\n                    // Might be more than one action from schedPkgActions\n                    Action prevAction = null;\n                        if (prevAction != null) {\n                            pkgAction.setPrerequisite(prevAction);\n                        }\n                        ActionManager.storeAction(pkgAction);\n                        prevAction = pkgAction;\n\n                    sra.setPrerequisite(prevAction);\n                    ActionManager.storeAction(sra);\n                }\n            }\n        }\n        else { // No remote-script to schedule\n            doSchedule(event, user, serverIds, earliest);\n        }\n        log.debug(\"Done scheduling package actions.\");\n\n    }","id":101676,"modified_method":"protected void scheduleAction(SsmPackageEvent event, User user) {\n\n        log.debug(\"Scheduling package actions.\");\n        Date earliest = event.getEarliest();\n\n        List<Long> sids = getAffectedServers(event, user);\n\n\n        log.debug(\"Scheduling actions.\");\n\n        // If we have a remote-cmd, have to correctly order it and the package\n        // action(s)\n        if (event.getScriptDetails() != null) {\n            // It's possible to have non-linux servers in the list, and different Actions\n            // are created for them.  Get the separate lists\n            List<Long> rhelIds = ServerFactory.listLinuxSystems(sids);\n            List<Long> solarisIds = ServerFactory.listSolarisSystems(sids);\n\n            ScriptActionDetails sad = event.getScriptDetails();\n            List<Action> pkgActions = doSchedule(event, user, sids, earliest);\n            for (Action a : pkgActions) {\n\n                if (event.isBefore()) {\n                    log.debug(\"Scheduling remote-action BEFORE.\");\n\n                    if (!rhelIds.isEmpty()) {\n                        ScriptRunAction sra = ActionManager.scheduleScriptRun(user,\n                                        rhelIds, null, sad, earliest);\n                        ActionManager.storeAction(sra);\n                        a.setPrerequisite(sra);\n                        ActionManager.storeAction(a);\n                    }\n\n                    if (!solarisIds.isEmpty()) {\n                        ScriptRunAction sra = ActionManager.scheduleScriptRun(user,\n                                        solarisIds, null, sad, earliest);\n                        ActionManager.storeAction(sra);\n                        a.setPrerequisite(sra);\n                        ActionManager.storeAction(a);\n                    }\n                }\n                else {\n                    log.debug(\"Scheduling remote-action AFTER.\");\n\n                    if (!rhelIds.isEmpty()) {\n                        ScriptRunAction sra = ActionManager.scheduleScriptRun(user,\n                                        rhelIds, null, sad, earliest);\n                        ActionManager.storeAction(a);\n                        sra.setPrerequisite(a);\n                        ActionManager.storeAction(sra);\n                    }\n\n                    if (!solarisIds.isEmpty()) {\n                        ScriptRunAction sra = ActionManager.scheduleScriptRun(user,\n                                        solarisIds, null, sad, earliest);\n                        ActionManager.storeAction(a);\n                        sra.setPrerequisite(a);\n                        ActionManager.storeAction(sra);\n                    }\n                }\n            }\n        }\n        else { // No remote-script to schedule\n            doSchedule(event, user, sids, earliest);\n        }\n        log.debug(\"Done scheduling package actions.\");\n\n    }","commit_id":"caac301bfbef1353df6fb8e4b0f7d71bb9fac7b4","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected List<Action> doSchedule(SsmPackageEvent event,\n                                      User user,\n                                      List<Long> sids,\n                                      Date earliest) {\n\n        SsmUpgradePackagesEvent supe = (SsmUpgradePackagesEvent) event;\n        Map<Long, List<Map<String, Long>>> packageListItems = supe.getSysPackageSet();\n\n        return ActionManager.schedulePackageUpgrades(user, packageListItems, earliest);\n\n    }","id":101677,"modified_method":"protected List<Action> doSchedule(SsmPackageEvent event,\n                                      User user,\n                                      List<Long> sids,\n                                      Date earliest) {\n\n        SsmUpgradePackagesEvent supe = (SsmUpgradePackagesEvent) event;\n        Map<Long, List<Map<String, Long>>> packageListItems = supe.getSysPackageSet();\n        List<Map<String, Long>> pkgs = new ArrayList<Map<String, Long>>();\n        for (List<Map<String, Long>> pkgList : packageListItems.values()) {\n            for (Map<String, Long> pkg : pkgList) {\n                pkgs.add(pkg);\n            }\n        }\n\n        return ActionManager.schedulePackageInstall(user, sids, pkgs, earliest);\n\n    }","commit_id":"caac301bfbef1353df6fb8e4b0f7d71bb9fac7b4","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"Statement processStatement(ForStatement x) {\n\n    // SEE NOTE ON JDT FORCED OPTIMIZATIONS\n    // If the condition is false, don't process the body\n    boolean removeBody = isOptimizedFalse(x.condition);\n\n    List<Statement> init = processStatements(x.initializations);\n    jetbrains.mps.baseLanguage.structure.Expression expr = processExpressionRefl(x.condition);\n    List<ExpressionStatement> incr = processExpressionStatements(x.increments);\n    Statement loopBody = removeBody ? null : processStatementRefl(x.action);\n    StatementList body = getStatementListFromStatement(loopBody);\n    jetbrains.mps.baseLanguage.structure.ForStatement forStatement =\n      jetbrains.mps.baseLanguage.structure.ForStatement.newInstance(myCurrentModel);\n    forStatement.setCondition(expr);\n    forStatement.setBody(body);\n    if (!incr.isEmpty()) {\n      jetbrains.mps.baseLanguage.structure.Expression expression = incr.get(0).getExpression();\n      expression.getParent().removeChild(expression);\n      forStatement.setIteration(expression); //todo add to BL multiple iterations\n    }\n    if (!init.isEmpty()) { //todo add to BL multiple for-loop variables\n      if (init.get(0) instanceof LocalVariableDeclarationStatement) {\n        LocalVariableDeclarationStatement lvds = (LocalVariableDeclarationStatement) init.get(0);\n        LocalVariableDeclaration variableDeclaration = lvds.getLocalVariableDeclaration();\n        lvds.removeChild(variableDeclaration);\n        forStatement.setVariable(variableDeclaration);\n      }\n    }\n    return forStatement;\n  }","id":101678,"modified_method":"Statement processStatement(ForStatement x) {\n\n    // SEE NOTE ON JDT FORCED OPTIMIZATIONS\n    // If the condition is false, don't process the body\n   // boolean removeBody = isOptimizedFalse(x.condition);\n\n    List<Statement> init = processStatements(x.initializations);\n    jetbrains.mps.baseLanguage.structure.Expression expr = processExpressionRefl(x.condition);\n    List<ExpressionStatement> incr = processExpressionStatements(x.increments);\n    Statement loopBody = processStatementRefl(x.action);\n    StatementList body = getStatementListFromStatement(loopBody);\n    jetbrains.mps.baseLanguage.structure.ForStatement forStatement =\n      jetbrains.mps.baseLanguage.structure.ForStatement.newInstance(myCurrentModel);\n    forStatement.setCondition(expr);\n    forStatement.setBody(body);\n    if (!incr.isEmpty()) {\n      jetbrains.mps.baseLanguage.structure.Expression expression = incr.get(0).getExpression();\n      expression.getParent().removeChild(expression);\n      forStatement.setIteration(expression); //todo add to BL multiple iterations\n    }\n    if (!init.isEmpty()) { //todo add to BL multiple for-loop variables\n      if (init.get(0) instanceof LocalVariableDeclarationStatement) {\n        LocalVariableDeclarationStatement lvds = (LocalVariableDeclarationStatement) init.get(0);\n        LocalVariableDeclaration variableDeclaration = lvds.getLocalVariableDeclaration();\n        lvds.removeChild(variableDeclaration);\n        forStatement.setVariable(variableDeclaration);\n      }\n    }\n    return forStatement;\n  }","commit_id":"5b63c5307c42cf14acd6003990505c8b3cf490be","url":"https://github.com/JetBrains/MPS"},{"original_method":"Statement processStatement(IfStatement x) {\n    // SEE NOTE ON JDT FORCED OPTIMIZATIONS\n    // If the condition is false, don't process the then statement\n    // If the condition is false, don't process the else statement\n    boolean removeThen = isOptimizedFalse(x.condition);\n    boolean removeElse = isOptimizedTrue(x.condition);\n\n    //SourceInfo info = makeSourceInfo(x);\n    jetbrains.mps.baseLanguage.structure.Expression expr = processExpressionRefl(x.condition);\n    Statement thenStmt = removeThen ? null\n      : processStatementRefl(x.thenStatement);\n    Statement elseStmt = removeElse ? null\n      : processStatementRefl(x.elseStatement);\n    jetbrains.mps.baseLanguage.structure.IfStatement result =\n      jetbrains.mps.baseLanguage.structure.IfStatement.newInstance(myCurrentModel);\n\n    result.setCondition(expr);\n    if (elseStmt != null) {\n      result.setIfFalseStatement(elseStmt);\n    }\n    StatementList ifTrue = getStatementListFromStatement(thenStmt);\n    result.setIfTrue(ifTrue);\n    return result;\n  }","id":101679,"modified_method":"Statement processStatement(IfStatement x) {\n    // SEE NOTE ON JDT FORCED OPTIMIZATIONS\n    // If the condition is false, don't process the then statement\n    // If the condition is false, don't process the else statement\n  //  boolean removeThen = isOptimizedFalse(x.condition);\n  //  boolean removeElse = isOptimizedTrue(x.condition);\n\n    //SourceInfo info = makeSourceInfo(x);\n    jetbrains.mps.baseLanguage.structure.Expression expr = processExpressionRefl(x.condition);\n    Statement thenStmt = processStatementRefl(x.thenStatement);\n    Statement elseStmt = processStatementRefl(x.elseStatement);\n    jetbrains.mps.baseLanguage.structure.IfStatement result =\n      jetbrains.mps.baseLanguage.structure.IfStatement.newInstance(myCurrentModel);\n\n    result.setCondition(expr);\n    if (elseStmt != null) {\n      result.setIfFalseStatement(elseStmt);\n    }\n    StatementList ifTrue = getStatementListFromStatement(thenStmt);\n    result.setIfTrue(ifTrue);\n    return result;\n  }","commit_id":"5b63c5307c42cf14acd6003990505c8b3cf490be","url":"https://github.com/JetBrains/MPS"},{"original_method":"Statement processStatement(WhileStatement x) {\n    // SEE NOTE ON JDT FORCED OPTIMIZATIONS\n    // If the condition is false, don't process the body\n    boolean removeBody = isOptimizedFalse(x.condition);\n\n    // SourceInfo info = makeSourceInfo(x);\n    jetbrains.mps.baseLanguage.structure.Expression loopTest = processExpressionRefl(x.condition);\n    Statement loopBody = removeBody ? null : processStatementRefl(x.action);\n    jetbrains.mps.baseLanguage.structure.WhileStatement result =\n      jetbrains.mps.baseLanguage.structure.WhileStatement.newInstance(myCurrentModel);\n    result.setCondition(loopTest);\n    result.setBody(getStatementListFromStatement(loopBody));\n    return result;\n  }","id":101680,"modified_method":"Statement processStatement(WhileStatement x) {\n    // SEE NOTE ON JDT FORCED OPTIMIZATIONS\n    // If the condition is false, don't process the body\n   // boolean removeBody = isOptimizedFalse(x.condition);\n\n    // SourceInfo info = makeSourceInfo(x);\n    jetbrains.mps.baseLanguage.structure.Expression loopTest = processExpressionRefl(x.condition);\n    Statement loopBody = processStatementRefl(x.action);\n    jetbrains.mps.baseLanguage.structure.WhileStatement result =\n      jetbrains.mps.baseLanguage.structure.WhileStatement.newInstance(myCurrentModel);\n    result.setCondition(loopTest);\n    result.setBody(getStatementListFromStatement(loopBody));\n    return result;\n  }","commit_id":"5b63c5307c42cf14acd6003990505c8b3cf490be","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into\n     * one large message and sends them back with an XMIT_RSP header. Note that since we cannot count on a\n     * fragmentation layer below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If\n     * this is the case, we split the message into multiple, smaller-chunked messages. But in most cases this\n     * still yields fewer messages than if each requested message was retransmitted separately.\n     * @param dest The sender of the XMIT_REQ, we have to send the requested copy\n     *             of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno The last sequence number to be retransmitted (>= first_seqno) */\n    void handleXmitReq(Address dest, long first_seqno, long last_seqno) {\n        Message    m, tmp;\n        LinkedList list;\n        long       size=0, marker=first_seqno, len;\n\n        if(log.isTraceEnabled())\n            log.trace(\"received xmit request for \" + dest + \" [\" + first_seqno + \" - \" + last_seqno + \"]\");\n\n        if(first_seqno > last_seqno) {\n            if(log.isErrorEnabled())\n                log.error(\"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            return;\n        }\n        list=new LinkedList();\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            m=(Message)sent_msgs.get(new Long(i)); // no need to synchronized\n            if(m == null) {\n                if(log.isErrorEnabled())\n                    log.error(\"(requester=\" + dest + \", local_addr=\" + this.local_addr + \") message with \" +\n                            \"seqno=\" + i + \" not found in sent_msgs ! sent_msgs=\" + printSentMsgs());\n                continue;\n            }\n            len=m.size();\n            size+=len;\n            if(size > max_xmit_size) { // changed from >= to > (yaron-r, bug #943709)\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if(log.isTraceEnabled())\n                    log.trace(\"xmitting msgs [\" + marker + \"-\" + (i - 1) + \"] to \" + dest);\n                sendXmitRsp(dest, (LinkedList)list.clone(), marker, i - 1);\n                marker=i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size=len;\n            }\n            if(Global.copy)\n                tmp=m.copy();\n            else\n                tmp=m;\n            tmp.setDest(dest);\n            tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if(list.size() > 0) {\n            if(log.isTraceEnabled())\n                log.trace(\"xmitting msgs [\" + marker + \"-\" + last_seqno + \"] to \" + dest);\n            sendXmitRsp(dest, (LinkedList)list.clone(), marker, last_seqno);\n        }\n    }","id":101681,"modified_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into one large\n     * message and sends them back with an XMIT_RSP header. Note that since we cannot count on a fragmentation layer\n     * below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If this is the case, we split the\n     * message into multiple, smaller-chunked messages. But in most cases this still yields fewer messages than if each\n     * requested message was retransmitted separately.\n     *\n     * @param dest        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     */\n    void handleXmitReq(Address dest, long first_seqno, long last_seqno) {\n        Message m, tmp;\n        LinkedList list;\n        long size = 0, marker = first_seqno, len;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"received xmit request for \" + dest + \" [\" + first_seqno + \" - \" + last_seqno + \"]\");\n        }\n\n        if (first_seqno > last_seqno) {\n            if (log.isErrorEnabled()) {\n                log.error(\n                        \"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            }\n            return;\n        }\n        list = new LinkedList();\n        for (long i = first_seqno; i <= last_seqno; i++) {\n            m = (Message) sent_msgs.get(new Long(i)); // no need to synchronized\n            if (m == null) {\n                if (log.isErrorEnabled()) {\n                    log.error(\n                            \"(requester=\" + dest + \", local_addr=\" + this.local_addr + \") message with \" +\n                            \"seqno=\" + i +\n                            \" not found in sent_msgs ! sent_msgs=\" +\n                            printSentMsgs());\n                }\n                continue;\n            }\n            len = m.size();\n            size += len;\n            if (size > max_xmit_size && list.size() > 0) { // changed from >= to > (yaron-r, bug #943709)\n                // yaronr: added &&listSize()>0 since protocols between FRAG and NAKACK add headers, and message exceeds size.\n\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if (log.isTraceEnabled()) {\n                    log.trace(\"xmitting msgs [\" + marker + \"-\" + (i - 1) + \"] to \" + dest);\n                }\n                sendXmitRsp(dest, (LinkedList) list.clone(), marker, i - 1);\n                marker = i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size = len;\n            }\n            if (Global.copy) {\n                tmp = m.copy();\n            } else {\n                tmp = m;\n            }\n            tmp.setDest(dest);\n            tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if (list.size() > 0) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"xmitting msgs [\" + marker + \"-\" + last_seqno + \"] to \" + dest);\n            }\n            sendXmitRsp(dest, (LinkedList) list.clone(), marker, last_seqno);\n        }\n    }","commit_id":"af38bc01316b342fe7f0be00bbcaaa9251ec50ca","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     <b>Callback<\/b>. Called by superclass when event may be handled.<p>\n     <b>Do not use <code>PassUp<\/code> in this method as the event is passed up\n     by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        Object       obj;\n        NakAckHeader hdr;\n        Message      msg;\n        Digest       digest;\n\n        switch(evt.getType()) {\n\n            case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n                stable((Digest)evt.getArg());\n                return;  // do not pass up further (Bela Aug 7 2001)\n\n            case Event.GET_DIGEST:\n                digest=getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_OK, digest));\n                return;\n\n            case Event.GET_DIGEST_STABLE:\n                digest=getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n                return;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                if(log.isDebugEnabled()) log.debug(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                obj=msg.getHeader(name);\n                if(obj == null || !(obj instanceof NakAckHeader))\n                    break;  // pass up (e.g. unicast msg)\n\n                // discard messages while not yet server (i.e., until JOIN has returned)\n                if(!is_server) {\n                    if(log.isDebugEnabled())\n                        log.debug(\"message was discarded (not yet server)\");\n                    return;\n                }\n\n                // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n                // further xmit requests will fail !\n                //hdr=(NakAckHeader)msg.removeHeader(getName());\n                hdr=(NakAckHeader)obj;\n\n                switch(hdr.type) {\n\n                    case NakAckHeader.MSG:\n                        handleMessage(msg, hdr);\n                        msg=null;\n                        return;        // transmitter passes message up for us !\n\n                    case NakAckHeader.XMIT_REQ:\n                        if(hdr.range == null) {\n                            if(log.isErrorEnabled())\n                                log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                            return;\n                        }\n                        handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                        return;\n\n                    case NakAckHeader.XMIT_RSP:\n                        if(log.isTraceEnabled())\n                            log.trace(\"received missing messages \" + hdr.range);\n                        handleXmitRsp(msg);\n                        return;\n\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                        return;\n                }\n        }\n        passUp(evt);\n    }","id":101682,"modified_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        Object obj;\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch (evt.getType()) {\n\n            case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n                stable((Digest) evt.getArg());\n                return;  // do not pass up further (Bela Aug 7 2001)\n\n            case Event.GET_DIGEST:\n                digest = getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_OK, digest));\n                return;\n\n            case Event.GET_DIGEST_STABLE:\n                digest = getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n                return;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr = (Address) evt.getArg();\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"received CONFIG event: \" + evt.getArg());\n                }\n                handleConfigEvent((HashMap) evt.getArg());\n                return;\n\n            case Event.MSG:\n                msg = (Message) evt.getArg();\n                obj = msg.getHeader(name);\n                if (obj == null || !(obj instanceof NakAckHeader)) {\n                    break;  // pass up (e.g. unicast msg)\n                }\n\n                // discard messages while not yet server (i.e., until JOIN has returned)\n                if (!is_server) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"message was discarded (not yet server)\");\n                    }\n                    return;\n                }\n\n                // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n                // further xmit requests will fail !\n                //hdr=(NakAckHeader)msg.removeHeader(getName());\n                hdr = (NakAckHeader) obj;\n\n                switch (hdr.type) {\n\n                    case NakAckHeader.MSG:\n                        handleMessage(msg, hdr);\n                        msg = null;\n                        return;        // transmitter passes message up for us !\n\n                    case NakAckHeader.XMIT_REQ:\n                        if (hdr.range == null) {\n                            if (log.isErrorEnabled()) {\n                                log.error(\n                                        \"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                            }\n                            return;\n                        }\n                        handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                        return;\n\n                    case NakAckHeader.XMIT_RSP:\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"received missing messages \" + hdr.range);\n                        }\n                        handleXmitRsp(msg);\n                        return;\n\n                    default:\n                        if (log.isErrorEnabled()) {\n                            log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                        }\n                        return;\n                }\n        }\n        passUp(evt);\n    }","commit_id":"af38bc01316b342fe7f0be00bbcaaa9251ec50ca","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into\n     * one large message and sends them back with an XMIT_RSP header. Note that since we cannot count on a\n     * fragmentation layer below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If\n     * this is the case, we split the message into multiple, smaller-chunked messages. But in most cases this\n     * still yields fewer messages than if each requested message was retransmitted separately.\n     * @param dest The sender of the XMIT_REQ, we have to send the requested copy\n     *             of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno The last sequence number to be retransmitted (>= first_seqno) */\n    void handleXmitReq(Address dest, long first_seqno, long last_seqno) {\n        Message    m, tmp;\n        LinkedList list;\n        long       size=0, marker=first_seqno, len;\n\n        if(log.isTraceEnabled())\n            log.trace(\"received xmit request for \" + dest + \" [\" + first_seqno + \" - \" + last_seqno + \"]\");\n\n        if(first_seqno > last_seqno) {\n            if(log.isErrorEnabled())\n                log.error(\"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            return;\n        }\n        list=new LinkedList();\n        for(long i=first_seqno; i <= last_seqno; i++) {\n            m=(Message)sent_msgs.get(new Long(i)); // no need to synchronized\n            if(m == null) {\n                if(log.isErrorEnabled())\n                    log.error(\"(requester=\" + dest + \", local_addr=\" + this.local_addr + \") message with \" +\n                            \"seqno=\" + i + \" not found in sent_msgs ! sent_msgs=\" + printSentMsgs());\n                continue;\n            }\n            len=m.size();\n            size+=len;\n            if(size > max_xmit_size) { // changed from >= to > (yaron-r, bug #943709)\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if(log.isTraceEnabled())\n                    log.trace(\"xmitting msgs [\" + marker + \"-\" + (i - 1) + \"] to \" + dest);\n                sendXmitRsp(dest, (LinkedList)list.clone(), marker, i - 1);\n                marker=i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size=len;\n            }\n            if(Global.copy)\n                tmp=m.copy();\n            else\n                tmp=m;\n            tmp.setDest(dest);\n            tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if(list.size() > 0) {\n            if(log.isTraceEnabled())\n                log.trace(\"xmitting msgs [\" + marker + \"-\" + last_seqno + \"] to \" + dest);\n            sendXmitRsp(dest, (LinkedList)list.clone(), marker, last_seqno);\n        }\n    }","id":101683,"modified_method":"/**\n     * Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into one large\n     * message and sends them back with an XMIT_RSP header. Note that since we cannot count on a fragmentation layer\n     * below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If this is the case, we split the\n     * message into multiple, smaller-chunked messages. But in most cases this still yields fewer messages than if each\n     * requested message was retransmitted separately.\n     *\n     * @param dest        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     */\n    void handleXmitReq(Address dest, long first_seqno, long last_seqno) {\n        Message m, tmp;\n        LinkedList list;\n        long size = 0, marker = first_seqno, len;\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"received xmit request for \" + dest + \" [\" + first_seqno + \" - \" + last_seqno + \"]\");\n        }\n\n        if (first_seqno > last_seqno) {\n            if (log.isErrorEnabled()) {\n                log.error(\n                        \"first_seqno (\" + first_seqno + \") > last_seqno (\" + last_seqno + \"): not able to retransmit\");\n            }\n            return;\n        }\n        list = new LinkedList();\n        for (long i = first_seqno; i <= last_seqno; i++) {\n            m = (Message) sent_msgs.get(new Long(i)); // no need to synchronized\n            if (m == null) {\n                if (log.isErrorEnabled()) {\n                    log.error(\n                            \"(requester=\" + dest + \", local_addr=\" + this.local_addr + \") message with \" +\n                            \"seqno=\" + i +\n                            \" not found in sent_msgs ! sent_msgs=\" +\n                            printSentMsgs());\n                }\n                continue;\n            }\n            len = m.size();\n            size += len;\n            if (size > max_xmit_size && list.size() > 0) { // changed from >= to > (yaron-r, bug #943709)\n                // yaronr: added &&listSize()>0 since protocols between FRAG and NAKACK add headers, and message exceeds size.\n\n                // size has reached max_xmit_size. go ahead and send message (excluding the current message)\n                if (log.isTraceEnabled()) {\n                    log.trace(\"xmitting msgs [\" + marker + \"-\" + (i - 1) + \"] to \" + dest);\n                }\n                sendXmitRsp(dest, (LinkedList) list.clone(), marker, i - 1);\n                marker = i;\n                list.clear();\n                // fixed Dec 15 2003 (bela, patch from Joel Dice (dicej)), see explanantion under\n                // bug report #854887\n                size = len;\n            }\n            if (Global.copy) {\n                tmp = m.copy();\n            } else {\n                tmp = m;\n            }\n            tmp.setDest(dest);\n            tmp.setSrc(local_addr);\n            list.add(tmp);\n        }\n\n        if (list.size() > 0) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"xmitting msgs [\" + marker + \"-\" + last_seqno + \"] to \" + dest);\n            }\n            sendXmitRsp(dest, (LinkedList) list.clone(), marker, last_seqno);\n        }\n    }","commit_id":"0f8d838a7fc93237a0ffbf14f3199cedce6933cd","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     <b>Callback<\/b>. Called by superclass when event may be handled.<p>\n     <b>Do not use <code>PassUp<\/code> in this method as the event is passed up\n     by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        Object       obj;\n        NakAckHeader hdr;\n        Message      msg;\n        Digest       digest;\n\n        switch(evt.getType()) {\n\n            case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n                stable((Digest)evt.getArg());\n                return;  // do not pass up further (Bela Aug 7 2001)\n\n            case Event.GET_DIGEST:\n                digest=getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_OK, digest));\n                return;\n\n            case Event.GET_DIGEST_STABLE:\n                digest=getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n                return;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                if(log.isDebugEnabled()) log.debug(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                obj=msg.getHeader(name);\n                if(obj == null || !(obj instanceof NakAckHeader))\n                    break;  // pass up (e.g. unicast msg)\n\n                // discard messages while not yet server (i.e., until JOIN has returned)\n                if(!is_server) {\n                    if(log.isDebugEnabled())\n                        log.debug(\"message was discarded (not yet server)\");\n                    return;\n                }\n\n                // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n                // further xmit requests will fail !\n                //hdr=(NakAckHeader)msg.removeHeader(getName());\n                hdr=(NakAckHeader)obj;\n\n                switch(hdr.type) {\n\n                    case NakAckHeader.MSG:\n                        handleMessage(msg, hdr);\n                        msg=null;\n                        return;        // transmitter passes message up for us !\n\n                    case NakAckHeader.XMIT_REQ:\n                        if(hdr.range == null) {\n                            if(log.isErrorEnabled())\n                                log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                            return;\n                        }\n                        handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                        return;\n\n                    case NakAckHeader.XMIT_RSP:\n                        if(log.isTraceEnabled())\n                            log.trace(\"received missing messages \" + hdr.range);\n                        handleXmitRsp(msg);\n                        return;\n\n                    default:\n                        if(log.isErrorEnabled()) log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                        return;\n                }\n        }\n        passUp(evt);\n    }","id":101684,"modified_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        Object obj;\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch (evt.getType()) {\n\n            case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n                stable((Digest) evt.getArg());\n                return;  // do not pass up further (Bela Aug 7 2001)\n\n            case Event.GET_DIGEST:\n                digest = getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_OK, digest));\n                return;\n\n            case Event.GET_DIGEST_STABLE:\n                digest = getDigestHighestDeliveredMsgs();\n                passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n                return;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr = (Address) evt.getArg();\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"received CONFIG event: \" + evt.getArg());\n                }\n                handleConfigEvent((HashMap) evt.getArg());\n                return;\n\n            case Event.MSG:\n                msg = (Message) evt.getArg();\n                obj = msg.getHeader(name);\n                if (obj == null || !(obj instanceof NakAckHeader)) {\n                    break;  // pass up (e.g. unicast msg)\n                }\n\n                // discard messages while not yet server (i.e., until JOIN has returned)\n                if (!is_server) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"message was discarded (not yet server)\");\n                    }\n                    return;\n                }\n\n                // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n                // further xmit requests will fail !\n                //hdr=(NakAckHeader)msg.removeHeader(getName());\n                hdr = (NakAckHeader) obj;\n\n                switch (hdr.type) {\n\n                    case NakAckHeader.MSG:\n                        handleMessage(msg, hdr);\n                        msg = null;\n                        return;        // transmitter passes message up for us !\n\n                    case NakAckHeader.XMIT_REQ:\n                        if (hdr.range == null) {\n                            if (log.isErrorEnabled()) {\n                                log.error(\n                                        \"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                            }\n                            return;\n                        }\n                        handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                        return;\n\n                    case NakAckHeader.XMIT_RSP:\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"received missing messages \" + hdr.range);\n                        }\n                        handleXmitRsp(msg);\n                        return;\n\n                    default:\n                        if (log.isErrorEnabled()) {\n                            log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                        }\n                        return;\n                }\n        }\n        passUp(evt);\n    }","commit_id":"0f8d838a7fc93237a0ffbf14f3199cedce6933cd","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    public List<TypeMirror> getInterfaces() {\n        Type[] javaInterfaces = klass.getGenericInterfaces();\n        List<TypeMirror> interfaces = new ArrayList<TypeMirror>(javaInterfaces.length);\n        for(Type javaInterface : javaInterfaces)\n            interfaces.add(new ReflectionType(javaInterface));\n        return interfaces;\n    }","id":101685,"modified_method":"@Override\n    public List<TypeMirror> getInterfaces() {\n        if(interfaces != null)\n            return interfaces;\n        Type[] javaInterfaces = klass.getGenericInterfaces();\n        interfaces = new ArrayList<TypeMirror>(javaInterfaces.length);\n        for(Type javaInterface : javaInterfaces)\n            interfaces.add(new ReflectionType(javaInterface));\n        return interfaces;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public List<MethodMirror> getDirectMethods() {\n        Method[] directMethods = klass.getDeclaredMethods();\n        Constructor<?>[] directConstructors = klass.getDeclaredConstructors();\n        List<MethodMirror> methods = new ArrayList<MethodMirror>(directMethods.length + directConstructors.length);\n        for(Method directMethod : directMethods){\n            if(!directMethod.isSynthetic())\n                methods.add(new ReflectionMethod(directMethod));\n        }\n        for(Constructor<?> directConstructor : directConstructors){\n            if(!directConstructor.isSynthetic())\n                methods.add(new ReflectionMethod(directConstructor));\n        }\n        return methods;\n    }","id":101686,"modified_method":"@Override\n    public List<MethodMirror> getDirectMethods() {\n        if(methods != null)\n            return methods;\n        Method[] directMethods = klass.getDeclaredMethods();\n        Constructor<?>[] directConstructors = klass.getDeclaredConstructors();\n        methods = new ArrayList<MethodMirror>(directMethods.length + directConstructors.length);\n        for(Method directMethod : directMethods){\n            if(!directMethod.isSynthetic())\n                methods.add(new ReflectionMethod(directMethod));\n        }\n        for(Constructor<?> directConstructor : directConstructors){\n            if(!directConstructor.isSynthetic())\n                methods.add(new ReflectionMethod(directConstructor));\n        }\n        return methods;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public TypeMirror getSuperclass() {\n        Type superclass = klass.getGenericSuperclass();\n        return superclass != null ? new ReflectionType(superclass) : null;\n    }","id":101687,"modified_method":"@Override\n    public TypeMirror getSuperclass() {\n        if(superClassSet)\n            return superClass;\n        Type sup = klass.getGenericSuperclass();\n        if(sup != null)\n            superClass = new ReflectionType(sup);\n        superClassSet = true;\n        return superClass;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public List<FieldMirror> getDirectFields() {\n        Field[] directFields = klass.getDeclaredFields();\n        List<FieldMirror> fields = new ArrayList<FieldMirror>(directFields.length);\n        for(Field field : directFields)\n            fields.add(new ReflectionField(field));\n        return fields;\n    }","id":101688,"modified_method":"@Override\n    public List<FieldMirror> getDirectFields() {\n        if(fields != null)\n            return fields;\n        Field[] directFields = klass.getDeclaredFields();\n        fields = new ArrayList<FieldMirror>(directFields.length);\n        for(Field field : directFields)\n            fields.add(new ReflectionField(field));\n        return fields;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public List<TypeParameterMirror> getTypeParameters() {\n        return ReflectionUtils.getTypeParameters(klass);\n    }","id":101689,"modified_method":"@Override\n    public List<TypeParameterMirror> getTypeParameters() {\n        if(typeParameters != null)\n            return typeParameters;\n        typeParameters = ReflectionUtils.getTypeParameters(klass);\n        return typeParameters;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public PackageMirror getPackage() {\n        return new ReflectionPackage(klass.getPackage());\n    }","id":101690,"modified_method":"@Override\n    public PackageMirror getPackage() {\n        if(pkg != null)\n            return pkg;\n        pkg = new ReflectionPackage(klass.getPackage());\n        return pkg;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public TypeMirror getType() {\n        return new ReflectionType(field.getGenericType());\n    }","id":101691,"modified_method":"@Override\n    public TypeMirror getType() {\n        if(type != null)\n            return type;\n        type = new ReflectionType(field.getGenericType());\n        return type;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public boolean isOverridingMethod() {\n        String name = method.getName();\n        Class<?>[] parameterTypes;\n        if(method instanceof Method)\n            parameterTypes = ((Method)method).getParameterTypes();\n        else\n            parameterTypes = ((Constructor<?>)method).getParameterTypes();\n        Class<?> declaringClass = method.getDeclaringClass();\n        // try the superclass first\n        Class<?> superclass = declaringClass.getSuperclass();\n        if(superclass != null){\n            try {\n                superclass.getMethod(name, parameterTypes);\n                // present\n                return true;\n            } catch (Exception e) {\n                // not present\n            }\n        }\n        // now try the interfaces\n        for(Class<?> interfce : declaringClass.getInterfaces()){\n            try {\n                interfce.getMethod(name, parameterTypes);\n                // present\n                return true;\n            } catch (Exception e) {\n                // not present\n            }\n        }\n        // not overriding anything\n        return false;\n    }","id":101692,"modified_method":"public boolean isOverridingMethod() {\n        if(overridingMethod != null)\n            return overridingMethod.booleanValue();\n        \n        String name = method.getName();\n        Class<?>[] parameterTypes;\n        if(method instanceof Method)\n            parameterTypes = ((Method)method).getParameterTypes();\n        else\n            parameterTypes = ((Constructor<?>)method).getParameterTypes();\n        Class<?> declaringClass = method.getDeclaringClass();\n        // try the superclass first\n        Class<?> superclass = declaringClass.getSuperclass();\n        if(superclass != null){\n            try {\n                superclass.getMethod(name, parameterTypes);\n                // present\n                overridingMethod = Boolean.TRUE;\n                return true;\n            } catch (Exception e) {\n                // not present\n            }\n        }\n        // now try the interfaces\n        for(Class<?> interfce : declaringClass.getInterfaces()){\n            try {\n                interfce.getMethod(name, parameterTypes);\n                // present\n                overridingMethod = Boolean.TRUE;\n                return true;\n            } catch (Exception e) {\n                // not present\n            }\n        }\n        // not overriding anything\n        overridingMethod = Boolean.FALSE;\n        return false;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public TypeMirror getReturnType() {\n        return new ReflectionType(((Method)method).getGenericReturnType());\n    }","id":101693,"modified_method":"@Override\n    public TypeMirror getReturnType() {\n        if(returnType != null)\n            return returnType;\n        returnType = new ReflectionType(((Method)method).getGenericReturnType());\n        return returnType;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public List<TypeParameterMirror> getTypeParameters() {\n        return ReflectionUtils.getTypeParameters((GenericDeclaration) method);\n    }","id":101694,"modified_method":"@Override\n    public List<TypeParameterMirror> getTypeParameters() {\n        if(typeParameters != null)\n            return typeParameters;\n        typeParameters = ReflectionUtils.getTypeParameters((GenericDeclaration) method);\n        return typeParameters;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public List<VariableMirror> getParameters() {\n        Type[] javaParameters;\n        Annotation[][] annotations;\n        if(method instanceof Method){\n            javaParameters = ((Method)method).getGenericParameterTypes();\n            annotations = ((Method)method).getParameterAnnotations();\n        }else{\n            javaParameters = ((Constructor<?>)method).getGenericParameterTypes();\n            annotations = ((Constructor<?>)method).getParameterAnnotations();\n        }\n        List<VariableMirror> parameters = new ArrayList<VariableMirror>(javaParameters.length);\n        for(int i=0;i<javaParameters.length;i++)\n            parameters.add(new ReflectionVariable(javaParameters[i], annotations[i]));\n        return parameters;\n    }","id":101695,"modified_method":"@Override\n    public List<VariableMirror> getParameters() {\n        if(parameters != null)\n            return parameters;\n        Type[] javaParameters;\n        Annotation[][] annotations;\n        if(method instanceof Method){\n            javaParameters = ((Method)method).getGenericParameterTypes();\n            annotations = ((Method)method).getParameterAnnotations();\n        }else{\n            javaParameters = ((Constructor<?>)method).getGenericParameterTypes();\n            annotations = ((Constructor<?>)method).getParameterAnnotations();\n        }\n        parameters = new ArrayList<VariableMirror>(javaParameters.length);\n        for(int i=0;i<javaParameters.length;i++)\n            parameters.add(new ReflectionVariable(javaParameters[i], annotations[i]));\n        return parameters;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public TypeMirror getComponentType() {\n        Type componentType = ((GenericArrayType)type).getGenericComponentType();\n        return new ReflectionType(componentType);\n    }","id":101696,"modified_method":"@Override\n    public TypeMirror getComponentType() {\n        if(componentType != null)\n            return componentType;\n        Type ct = ((GenericArrayType)type).getGenericComponentType();\n        componentType = new ReflectionType(ct);\n        return componentType;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public List<TypeMirror> getTypeArguments() {\n        if(type instanceof ParameterizedType){\n            Type[] javaTypeArguments = ((ParameterizedType)type).getActualTypeArguments();\n            List<TypeMirror> typeArguments = new ArrayList<TypeMirror>(javaTypeArguments.length);\n            for(Type typeArgument : javaTypeArguments)\n                typeArguments.add(new ReflectionType(typeArgument));\n            return typeArguments;\n        }\n        return Collections.emptyList();\n    }","id":101697,"modified_method":"@Override\n    public List<TypeMirror> getTypeArguments() {\n        if(typeArguments != null)\n            return typeArguments;\n        if(type instanceof ParameterizedType){\n            Type[] javaTypeArguments = ((ParameterizedType)type).getActualTypeArguments();\n            typeArguments = new ArrayList<TypeMirror>(javaTypeArguments.length);\n            for(Type typeArgument : javaTypeArguments)\n                typeArguments.add(new ReflectionType(typeArgument));\n            return typeArguments;\n        }else\n            typeArguments = Collections.<TypeMirror>emptyList(); \n        return typeArguments;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public List<TypeMirror> getBounds() {\n        Type[] javaBounds = type.getBounds();\n        List<TypeMirror> bounds = new ArrayList<TypeMirror>(javaBounds.length);\n        for(Type bound : javaBounds)\n            bounds.add(new ReflectionType(bound));\n        return bounds;\n    }","id":101698,"modified_method":"@Override\n    public List<TypeMirror> getBounds() {\n        if(bounds != null)\n            return bounds;\n        Type[] javaBounds = type.getBounds();\n        bounds = new ArrayList<TypeMirror>(javaBounds.length);\n        for(Type bound : javaBounds)\n            bounds.add(new ReflectionType(bound));\n        return bounds;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public TypeMirror getType() {\n        return new ReflectionType(type);\n    }","id":101699,"modified_method":"@Override\n    public TypeMirror getType() {\n        if(varType != null)\n            return varType;\n        varType = new ReflectionType(type);\n        return varType;\n    }","commit_id":"e5f582eae6bf709274044816a60ef98152480b60","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static PsiSubstitutor calculateMethodReturnTypeSubstitutor(PsiMethod method, final PsiType expected) {\n    PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n    PsiResolveHelper helper = JavaPsiFacade.getInstance(method.getProject()).getResolveHelper();\n    final PsiTypeParameter[] typeParameters = method.getTypeParameters();\n    for (PsiTypeParameter typeParameter : typeParameters) {\n      PsiType substitution = helper.getSubstitutionForTypeParameter(typeParameter, method.getReturnType(), expected,\n                                                                    false, PsiUtil.getLanguageLevel(method));\n      if (PsiType.NULL.equals(substitution)) {\n        substitution = TypeConversionUtil.typeParameterErasure(typeParameter);\n      }\n\n      substitutor = substitutor.put(typeParameter, substitution);\n    }\n    return substitutor;\n  }","id":101700,"modified_method":"public static PsiSubstitutor calculateMethodReturnTypeSubstitutor(@NotNull PsiMethod method, @NotNull final PsiType expected) {\n    PsiType returnType = method.getReturnType();\n    if (returnType == null) return PsiSubstitutor.EMPTY;\n\n    PsiResolveHelper helper = JavaPsiFacade.getInstance(method.getProject()).getResolveHelper();\n    return helper.inferTypeArguments(method.getTypeParameters(), new PsiType[]{expected}, new PsiType[]{returnType}, LanguageLevel.HIGHEST);\n  }","commit_id":"375bdad5697e5b10204b2660a985cc3ecf42982c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }               \n        \n        Sequence result;\n\t\tIntegerValue precision = new IntegerValue(0);\n\t\tSequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (seq.isEmpty())\n\t\t\tresult = Sequence.EMPTY_SEQUENCE;\n        else {\t\t\n            if (contextItem != null) \n    \t\t\tcontextSequence = contextItem.toSequence();\n            \n    \t\tif (getSignature().getArgumentCount() > 1) {\n    \t\t\tprecision = (IntegerValue) getArgument(1).eval(contextSequence, contextItem).itemAt(0).convertTo(Type.INTEGER);\n    \t\t}\n            \n    \t\tNumericValue value = (NumericValue) seq.itemAt(0).convertTo(Type.NUMBER);\n    \t\treturn value.round(precision);\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n\t}","id":101701,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }               \n        \n        Sequence result;\n\t\tIntegerValue precision = null;\n\t\tSequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (seq.isEmpty())\n\t\t\tresult = Sequence.EMPTY_SEQUENCE;\n        else {\t\t\n            if (contextItem != null) \n    \t\t\tcontextSequence = contextItem.toSequence();\n            \n    \t\tif (getSignature().getArgumentCount() > 1) {\n    \t\t\tprecision = (IntegerValue) getArgument(1).eval(contextSequence, contextItem).itemAt(0).convertTo(Type.INTEGER);\n    \t\t}\n            \n        \tItem item = seq.itemAt(0);\n        \tNumericValue value;\n        \tif (item instanceof NumericValue) {\n\t\t\t\tvalue = (NumericValue) item;\n\t\t\t} else {\n\t\t\t\tvalue = (NumericValue) item.convertTo(Type.NUMBER);\n\t\t\t}\n        \t\n    \t\tif (precision == null)\n    \t\t\tresult = value.round();\n    \t\telse\n    \t\t\tresult = value.round(precision);\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n\t}","commit_id":"9067cb798d390706347e7634a93f3cccfb540a7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES,\n                \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        Sequence result;\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n        if (seq.isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n            NumericValue value = (NumericValue)seq.itemAt(0).convertTo(Type.NUMBER);\n            result = value.abs();\n        }\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        return result;\n    }","id":101702,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES,\n                \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        Sequence result;\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n        if (seq.isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n        \tItem item = seq.itemAt(0);\n        \tNumericValue value;\n        \tif (item instanceof NumericValue) {\n\t\t\t\tvalue = (NumericValue) item;\n\t\t\t} else {\n\t\t\t\tvalue = (NumericValue) item.convertTo(Type.NUMBER);\n\t\t\t}\n            result = value.abs();\n        }\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        return result;\n    }","commit_id":"49904ce1058029ad6fb5075d93a9d610fbf54f57","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES,\n                \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                    \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                    \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n        Sequence result;\n        if (seq.isEmpty()) {\n            result = Sequence.EMPTY_SEQUENCE; \n        } else {\n            NumericValue value = (NumericValue)\tseq.itemAt(0).convertTo(Type.NUMBER);\n            result = value.ceiling();\n        }\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        return result;\n    }","id":101703,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES,\n                \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                    \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES,\n                    \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n        Sequence result;\n        if (seq.isEmpty()) {\n            result = Sequence.EMPTY_SEQUENCE; \n        } else {\n        \tItem item = seq.itemAt(0);\n        \tNumericValue value;\n        \tif (item instanceof NumericValue) {\n\t\t\t\tvalue = (NumericValue) item;\n\t\t\t} else {\n\t\t\t\tvalue = (NumericValue) item.convertTo(Type.NUMBER);\n\t\t\t}\n            result = value.ceiling();\n        }\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        return result;\n    }","commit_id":"49904ce1058029ad6fb5075d93a9d610fbf54f57","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t\t//if (contextItem != null)\n\t\t//\tcontextSequence = contextItem.toSequence();\n        \n\t\tSequence result;\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (seq.isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n    \t\tNumericValue value = (NumericValue) seq.itemAt(0).convertTo(Type.NUMBER);\n    \t\tresult = value.floor();\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;    \n        \n\t}","id":101704,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);\n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n        \n\t\t//if (contextItem != null)\n\t\t//\tcontextSequence = contextItem.toSequence();\n        \n\t\tSequence result;\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (seq.isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n        \tItem item = seq.itemAt(0);\n        \tNumericValue value;\n        \tif (item instanceof NumericValue) {\n\t\t\t\tvalue = (NumericValue) item;\n\t\t\t} else {\n\t\t\t\tvalue = (NumericValue) item.convertTo(Type.NUMBER);\n\t\t\t}\n    \t\tresult = value.floor();\n        }\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;    \n        \n\t}","commit_id":"49904ce1058029ad6fb5075d93a9d610fbf54f57","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }       \n        \n        if (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\t\n        Sequence result;\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (seq.isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n    \t\tNumericValue value = (NumericValue) seq.itemAt(0).convertTo(Type.NUMBER);\n            result = value.round();\n        }\n\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n\t}","id":101705,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n        if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }       \n        \n        if (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\t\n        Sequence result;\n        Sequence seq = getArgument(0).eval(contextSequence, contextItem);\n\t\tif (seq.isEmpty())\n            result = Sequence.EMPTY_SEQUENCE;\n        else {\n        \tItem item = seq.itemAt(0);\n        \tNumericValue value;\n        \tif (item instanceof NumericValue) {\n\t\t\t\tvalue = (NumericValue) item;\n\t\t\t} else {\n\t\t\t\tvalue = (NumericValue) item.convertTo(Type.NUMBER);\n\t\t\t}\n            result = value.round();\n        }\n\n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n\t}","commit_id":"49904ce1058029ad6fb5075d93a9d610fbf54f57","url":"https://github.com/eXist-db/exist"},{"original_method":"@Nullable\n  private static PsiClassType getClassType(PsiType type, PsiElement place) {\n    return (PsiClassType)(type instanceof PsiClassType ?\n                          type : ((PsiPrimitiveType)type).getBoxedType(place.getManager(), GlobalSearchScope.allScope(place.getProject())));\n  }","id":101706,"modified_method":"@Nullable\n  private static PsiClassType getClassType(PsiType type, PsiElement place) {\n    if (type instanceof PsiClassType) {\n      return (PsiClassType)type;\n    }\n    else if (type instanceof PsiPrimitiveType){\n      return ((PsiPrimitiveType)type).getBoxedType(place.getManager(), GlobalSearchScope.allScope(place.getProject()));\n    }\n    return null;\n  }","commit_id":"a7200784cdb5b8cfa594b15486e6b888b02d5293","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void registerWrapAction (JavaResolveResult[] candidates, PsiExpression[] expressions, HighlightInfo highlightInfo) {\n    PsiType expectedType = null;\n    PsiExpression expr = null;\n\n    nextMethod:\n    for (int i = 0; i < candidates.length && expectedType == null; i++) {\n      final JavaResolveResult candidate = candidates[i];\n      final PsiSubstitutor substitutor = candidate.getSubstitutor();\n      final PsiElement element = candidate.getElement();\n      assert element != null;\n      final PsiMethod method = (PsiMethod)element;\n      final PsiParameter[] parameters = method.getParameterList().getParameters();\n      if (!method.isVarArgs() && parameters.length != expressions.length) continue;\n      for (int j = 0; j < expressions.length; j++) {\n        PsiExpression expression = expressions[j];\n        final PsiType exprType = expression.getType();\n        if (exprType != null) {\n          PsiType paramType = parameters[Math.min(j, parameters.length -1)].getType();\n          if (paramType instanceof PsiEllipsisType) {\n            paramType = ((PsiEllipsisType)paramType).getComponentType();\n          }\n          paramType = substitutor != null ? substitutor.substitute(paramType) : paramType;\n          if (paramType.isAssignableFrom(exprType)) continue;\n          if (expectedType == null && findWrapper(exprType,\n                                                  getClassType(paramType, expression),\n                                                  paramType instanceof PsiPrimitiveType) != null) {\n            expectedType = paramType;\n            expr = expression;\n          } else {\n            expectedType = null;\n            expr = null;\n            continue nextMethod;\n          }\n        }\n      }\n    }\n\n    if (expectedType != null) {\n      QuickFixAction.registerQuickFixAction(highlightInfo, expr.getTextRange(), new WrapExpressionFix(expectedType, expr), null);\n    }\n  }","id":101707,"modified_method":"public static void registerWrapAction (JavaResolveResult[] candidates, PsiExpression[] expressions, HighlightInfo highlightInfo) {\n    PsiType expectedType = null;\n    PsiExpression expr = null;\n\n    nextMethod:\n    for (int i = 0; i < candidates.length && expectedType == null; i++) {\n      final JavaResolveResult candidate = candidates[i];\n      final PsiSubstitutor substitutor = candidate.getSubstitutor();\n      final PsiElement element = candidate.getElement();\n      assert element != null;\n      final PsiMethod method = (PsiMethod)element;\n      final PsiParameter[] parameters = method.getParameterList().getParameters();\n      if (!method.isVarArgs() && parameters.length != expressions.length) continue;\n      for (int j = 0; j < expressions.length; j++) {\n        PsiExpression expression = expressions[j];\n        final PsiType exprType = expression.getType();\n        if (exprType != null) {\n          PsiType paramType = parameters[Math.min(j, parameters.length -1)].getType();\n          if (paramType instanceof PsiEllipsisType) {\n            paramType = ((PsiEllipsisType)paramType).getComponentType();\n          }\n          paramType = substitutor != null ? substitutor.substitute(paramType) : paramType;\n          if (paramType.isAssignableFrom(exprType)) continue;\n          final PsiClassType classType = getClassType(paramType, expression);\n          if (expectedType == null && classType != null && findWrapper(exprType, classType, paramType instanceof PsiPrimitiveType) != null) {\n            expectedType = paramType;\n            expr = expression;\n          } else {\n            expectedType = null;\n            expr = null;\n            continue nextMethod;\n          }\n        }\n      }\n    }\n\n    if (expectedType != null) {\n      QuickFixAction.registerQuickFixAction(highlightInfo, expr.getTextRange(), new WrapExpressionFix(expectedType, expr), null);\n    }\n  }","commit_id":"a7200784cdb5b8cfa594b15486e6b888b02d5293","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {\n    final PsiVariable psiVariable = getVariable(element);\n    LOG.assertTrue(psiVariable != null);\n\n    final Query<PsiReference> refs = ReferencesSearch.search(psiVariable);\n\n    final Set<PsiElement> elements = new HashSet<PsiElement>();\n    elements.add(element);\n    for (PsiReference reference : refs) {\n      elements.add(reference.getElement());\n    }\n    if (!FileModificationService.getInstance().preparePsiElementsForWrite(elements)) return;\n\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    final PsiType fromType = psiVariable.getType();\n    PsiClassType toType;\n    final String atomicQualifiedName = myFromToMap.get(fromType);\n    if (atomicQualifiedName != null) {\n      final PsiClass atomicClass = psiFacade.findClass(atomicQualifiedName, GlobalSearchScope.allScope(project));\n      if (atomicClass == null) {//show warning\n        return;\n      }\n      toType = elementFactory.createType(atomicClass);\n    } else if (fromType instanceof PsiArrayType) {\n      final PsiClass atomicReferenceArrayClass = psiFacade.findClass(AtomicReferenceArray.class.getName(), GlobalSearchScope.allScope(project));\n      if (atomicReferenceArrayClass == null) {//show warning\n        return;\n      }\n      final HashMap<PsiTypeParameter, PsiType> substitutor = new HashMap<PsiTypeParameter, PsiType>();\n      final PsiTypeParameter[] typeParameters = atomicReferenceArrayClass.getTypeParameters();\n      if (typeParameters.length == 1) {\n        final PsiType componentType = ((PsiArrayType)fromType).getComponentType();\n        substitutor.put(typeParameters[0], componentType instanceof PsiPrimitiveType ? ((PsiPrimitiveType)componentType).getBoxedType(element): componentType);\n      }\n      toType = elementFactory.createType(atomicReferenceArrayClass, elementFactory.createSubstitutor(substitutor));\n    } else {\n      final PsiClass atomicReferenceClass = psiFacade.findClass(AtomicReference.class.getName(), GlobalSearchScope.allScope(project));\n      if (atomicReferenceClass == null) {//show warning\n        return;\n      }\n      final HashMap<PsiTypeParameter, PsiType> substitutor = new HashMap<PsiTypeParameter, PsiType>();\n      final PsiTypeParameter[] typeParameters = atomicReferenceClass.getTypeParameters();\n      if (typeParameters.length == 1) {\n        substitutor.put(typeParameters[0], fromType instanceof PsiPrimitiveType ? ((PsiPrimitiveType)fromType).getBoxedType(element): fromType);\n      }\n      toType = elementFactory.createType(atomicReferenceClass, elementFactory.createSubstitutor(substitutor));\n    }\n\n    try {\n      for (PsiReference reference : refs) {\n        PsiElement psiElement = reference.getElement();\n        if (psiElement instanceof PsiExpression) {\n          final PsiElement parent = psiElement.getParent();\n          if (parent instanceof PsiExpression && !(parent instanceof PsiReferenceExpression) && !(parent instanceof PsiPolyadicExpression)) {\n            psiElement = parent;\n          }\n          if (psiElement instanceof PsiBinaryExpression) {\n            PsiBinaryExpression binaryExpression = (PsiBinaryExpression)psiElement;\n            if (TypeConversionUtil.isBinaryOperatorApplicable(binaryExpression.getOperationTokenType(), binaryExpression.getLOperand(), binaryExpression.getROperand(), true)) {\n              continue;\n            }\n          } else if (psiElement instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression assignmentExpression = (PsiAssignmentExpression)psiElement;\n            IElementType opSign = TypeConversionUtil.convertEQtoOperation(assignmentExpression.getOperationTokenType());\n            if (opSign != null && TypeConversionUtil.isBinaryOperatorApplicable(opSign, assignmentExpression.getLExpression(), assignmentExpression.getRExpression(), true)) {\n              continue;\n            }\n          }\n          final TypeConversionDescriptor directConversion = AtomicConversionRule.findDirectConversion(psiElement, toType, fromType);\n          if (directConversion != null) {\n            TypeMigrationReplacementUtil.replaceExpression((PsiExpression)psiElement, project, directConversion);\n          }\n        }\n      }\n\n      final PsiExpression initializer = psiVariable.getInitializer();\n      if (initializer != null) {\n        final TypeConversionDescriptor directConversion = AtomicConversionRule.wrapWithNewExpression(toType, fromType, null, element);\n        if (directConversion != null) {\n          TypeMigrationReplacementUtil.replaceExpression(initializer, project, directConversion);\n        }\n      } else if (!psiVariable.getModifierList().hasModifierProperty(PsiModifier.FINAL)){\n        final PsiExpression defaultInitializer =\n          elementFactory.createExpressionFromText(\"new \" + toType.getPresentableText() + \"()\", psiVariable);\n        if (psiVariable instanceof PsiLocalVariable) {\n          ((PsiLocalVariable)psiVariable).setInitializer(defaultInitializer);\n        } else if (psiVariable instanceof PsiField) {\n          ((PsiField)psiVariable).setInitializer(defaultInitializer);\n        }\n      }\n\n      PsiElement replaced = psiVariable.getTypeElement().replace(elementFactory.createTypeElement(toType));\n      JavaCodeStyleManager.getInstance(project).shortenClassReferences(replaced);\n\n      if (psiVariable instanceof PsiField || CodeStyleSettingsManager.getSettings(project).GENERATE_FINAL_LOCALS) {\n        final PsiModifierList modifierList = psiVariable.getModifierList();\n        modifierList.setModifierProperty(PsiModifier.FINAL, true);\n        modifierList.setModifierProperty(PsiModifier.VOLATILE, false);\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":101708,"modified_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {\n    final PsiVariable psiVariable = getVariable(element);\n    LOG.assertTrue(psiVariable != null);\n\n    final Query<PsiReference> refs = ReferencesSearch.search(psiVariable);\n\n    final Set<PsiElement> elements = new HashSet<PsiElement>();\n    elements.add(element);\n    for (PsiReference reference : refs) {\n      elements.add(reference.getElement());\n    }\n    if (!FileModificationService.getInstance().preparePsiElementsForWrite(elements)) return;\n\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n    final PsiType fromType = psiVariable.getType();\n    PsiClassType toType;\n    final String atomicQualifiedName = myFromToMap.get(fromType);\n    if (atomicQualifiedName != null) {\n      final PsiClass atomicClass = psiFacade.findClass(atomicQualifiedName, GlobalSearchScope.allScope(project));\n      if (atomicClass == null) {//show warning\n        return;\n      }\n      toType = factory.createType(atomicClass);\n    }\n    else if (fromType instanceof PsiArrayType) {\n      final PsiClass atomicReferenceArrayClass =\n        psiFacade.findClass(AtomicReferenceArray.class.getName(), GlobalSearchScope.allScope(project));\n      if (atomicReferenceArrayClass == null) {//show warning\n        return;\n      }\n      final Map<PsiTypeParameter, PsiType> substitutor = ContainerUtil.newHashMap();\n      final PsiTypeParameter[] typeParameters = atomicReferenceArrayClass.getTypeParameters();\n      if (typeParameters.length == 1) {\n        PsiType componentType = ((PsiArrayType)fromType).getComponentType();\n        if (componentType instanceof PsiPrimitiveType) componentType = ((PsiPrimitiveType)componentType).getBoxedType(element);\n        substitutor.put(typeParameters[0], componentType);\n      }\n      toType = factory.createType(atomicReferenceArrayClass, factory.createSubstitutor(substitutor));\n    }\n    else {\n      final PsiClass atomicReferenceClass = psiFacade.findClass(AtomicReference.class.getName(), GlobalSearchScope.allScope(project));\n      if (atomicReferenceClass == null) {//show warning\n        return;\n      }\n      final Map<PsiTypeParameter, PsiType> substitutor = ContainerUtil.newHashMap();\n      final PsiTypeParameter[] typeParameters = atomicReferenceClass.getTypeParameters();\n      if (typeParameters.length == 1) {\n        PsiType type = fromType;\n        if (type instanceof PsiPrimitiveType) type = ((PsiPrimitiveType)fromType).getBoxedType(element);\n        substitutor.put(typeParameters[0], type);\n      }\n      toType = factory.createType(atomicReferenceClass, factory.createSubstitutor(substitutor));\n    }\n\n    try {\n      for (PsiReference reference : refs) {\n        PsiElement psiElement = reference.getElement();\n        if (psiElement instanceof PsiExpression) {\n          final PsiElement parent = psiElement.getParent();\n          if (parent instanceof PsiExpression && !(parent instanceof PsiReferenceExpression || parent instanceof PsiPolyadicExpression)) {\n            psiElement = parent;\n          }\n          if (psiElement instanceof PsiBinaryExpression) {\n            PsiBinaryExpression binary = (PsiBinaryExpression)psiElement;\n            if (isBinaryOperatorApplicable(binary.getOperationTokenType(), binary.getLOperand(), binary.getROperand(), true)) {\n              continue;\n            }\n          }\n          else if (psiElement instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression assignment = (PsiAssignmentExpression)psiElement;\n            final IElementType opSign = TypeConversionUtil.convertEQtoOperation(assignment.getOperationTokenType());\n            if (opSign != null && isBinaryOperatorApplicable(opSign, assignment.getLExpression(), assignment.getRExpression(), true)) {\n              continue;\n            }\n          }\n          final TypeConversionDescriptor directConversion = AtomicConversionRule.findDirectConversion(psiElement, toType, fromType);\n          if (directConversion != null) {\n            TypeMigrationReplacementUtil.replaceExpression((PsiExpression)psiElement, project, directConversion);\n          }\n        }\n      }\n\n      final PsiExpression initializer = psiVariable.getInitializer();\n      if (initializer != null) {\n        final TypeConversionDescriptor directConversion = AtomicConversionRule.wrapWithNewExpression(toType, fromType, null, element);\n        if (directConversion != null) {\n          TypeMigrationReplacementUtil.replaceExpression(initializer, project, directConversion);\n        }\n      }\n      else if (!assertNotNull(psiVariable.getModifierList()).hasModifierProperty(PsiModifier.FINAL)) {\n        final PsiExpression newInitializer = factory.createExpressionFromText(\"new \" + toType.getPresentableText() + \"()\", psiVariable);\n        if (psiVariable instanceof PsiLocalVariable) {\n          ((PsiLocalVariable)psiVariable).setInitializer(newInitializer);\n        }\n        else if (psiVariable instanceof PsiField) {\n          ((PsiField)psiVariable).setInitializer(newInitializer);\n        }\n      }\n\n      PsiElement replaced = assertNotNull(psiVariable.getTypeElement()).replace(factory.createTypeElement(toType));\n      JavaCodeStyleManager.getInstance(project).shortenClassReferences(replaced);\n\n      if (psiVariable instanceof PsiField || CodeStyleSettingsManager.getSettings(project).GENERATE_FINAL_LOCALS) {\n        final PsiModifierList modifierList = assertNotNull(psiVariable.getModifierList());\n        modifierList.setModifierProperty(PsiModifier.FINAL, true);\n        modifierList.setModifierProperty(PsiModifier.VOLATILE, false);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"c961cb5e28a05ef7209277468fa0e9ba35819c1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {\n    final PsiField psiField = PsiTreeUtil.getParentOfType(element, PsiField.class);\n    LOG.assertTrue(psiField != null);\n    final Query<PsiReference> refs = ReferencesSearch.search(psiField);\n\n    final Set<PsiElement> elements = new HashSet<PsiElement>();\n    elements.add(element);\n    for (PsiReference reference : refs) {\n      elements.add(reference.getElement());\n    }\n    if (!FileModificationService.getInstance().preparePsiElementsForWrite(elements)) return;\n\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    final PsiType fromType = psiField.getType();\n\n\n    final PsiClass threadLocalClass = psiFacade.findClass(ThreadLocal.class.getName(), GlobalSearchScope.allScope(project));\n    if (threadLocalClass == null) {//show warning\n      return;\n    }\n    final HashMap<PsiTypeParameter, PsiType> substitutor = new HashMap<PsiTypeParameter, PsiType>();\n    final PsiTypeParameter[] typeParameters = threadLocalClass.getTypeParameters();\n    if (typeParameters.length == 1) {\n      substitutor.put(typeParameters[0], fromType instanceof PsiPrimitiveType ? ((PsiPrimitiveType)fromType).getBoxedType(element) : fromType);\n    }\n    final PsiClassType toType = elementFactory.createType(threadLocalClass, elementFactory.createSubstitutor(substitutor));\n\n    try {\n      final TypeMigrationRules rules = new TypeMigrationRules(fromType);\n      rules.setMigrationRootType(toType);\n      rules.setBoundScope(GlobalSearchScope.fileScope(element.getContainingFile()));\n      final TypeMigrationLabeler labeler = new TypeMigrationLabeler(rules);\n      labeler.getMigratedUsages(false, psiField);\n      for (PsiReference reference : refs) {\n        PsiElement psiElement = reference.getElement();\n        if (psiElement instanceof PsiExpression) {\n          final PsiElement parent = psiElement.getParent();\n          if (parent instanceof PsiExpression && !(parent instanceof PsiReferenceExpression) && !(parent instanceof PsiPolyadicExpression)) {\n            psiElement = parent;\n          }\n          final TypeConversionDescriptor directConversion = ThreadLocalConversionRule.findDirectConversion(psiElement, toType, fromType, labeler);\n          if (directConversion != null) {\n            TypeMigrationReplacementUtil.replaceExpression((PsiExpression)psiElement, project, directConversion);\n          }\n        }\n      }\n\n      final PsiExpression initializer = psiField.getInitializer();\n      if (initializer != null) {\n        TypeMigrationReplacementUtil.replaceExpression(initializer, project, ThreadLocalConversionRule.wrapWithNewExpression(toType, fromType, initializer));\n        CodeStyleManager.getInstance(project).reformat(psiField);\n      }  else if (!psiField.getModifierList().hasModifierProperty(PsiModifier.FINAL)) {\n        final PsiExpression defaultInitializer =\n          elementFactory.createExpressionFromText(\"new \" + PsiDiamondTypeUtil.getCollapsedType(toType, psiField) + \"()\", psiField);\n        psiField.setInitializer(defaultInitializer);\n      }\n\n      psiField.getTypeElement().replace(elementFactory.createTypeElement(toType));\n      final PsiModifierList modifierList = psiField.getModifierList();\n      modifierList.setModifierProperty(PsiModifier.FINAL, true);\n      modifierList.setModifierProperty(PsiModifier.VOLATILE, false);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":101709,"modified_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {\n    final PsiField psiField = PsiTreeUtil.getParentOfType(element, PsiField.class);\n    LOG.assertTrue(psiField != null);\n    final Query<PsiReference> refs = ReferencesSearch.search(psiField);\n\n    final Set<PsiElement> elements = new HashSet<PsiElement>();\n    elements.add(element);\n    for (PsiReference reference : refs) {\n      elements.add(reference.getElement());\n    }\n    if (!FileModificationService.getInstance().preparePsiElementsForWrite(elements)) return;\n\n    final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n    final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n    final PsiType fromType = psiField.getType();\n\n    final PsiClass threadLocalClass = psiFacade.findClass(ThreadLocal.class.getName(), GlobalSearchScope.allScope(project));\n    if (threadLocalClass == null) {//show warning\n      return;\n    }\n    final Map<PsiTypeParameter, PsiType> substitutor = ContainerUtil.newHashMap();\n    final PsiTypeParameter[] typeParameters = threadLocalClass.getTypeParameters();\n    if (typeParameters.length == 1) {\n      PsiType type = fromType;\n      if (fromType instanceof PsiPrimitiveType) type = ((PsiPrimitiveType)fromType).getBoxedType(element);\n      substitutor.put(typeParameters[0], type);\n    }\n    final PsiClassType toType = factory.createType(threadLocalClass, factory.createSubstitutor(substitutor));\n\n    try {\n      final TypeMigrationRules rules = new TypeMigrationRules(fromType);\n      rules.setMigrationRootType(toType);\n      rules.setBoundScope(GlobalSearchScope.fileScope(element.getContainingFile()));\n      final TypeMigrationLabeler labeler = new TypeMigrationLabeler(rules);\n      labeler.getMigratedUsages(false, psiField);\n      for (PsiReference reference : refs) {\n        PsiElement psiElement = reference.getElement();\n        if (psiElement instanceof PsiExpression) {\n          final PsiElement parent = psiElement.getParent();\n          if (parent instanceof PsiExpression && !(parent instanceof PsiReferenceExpression || parent instanceof PsiPolyadicExpression)) {\n            psiElement = parent;\n          }\n          final TypeConversionDescriptor conversion = ThreadLocalConversionRule.findDirectConversion(psiElement, toType, fromType, labeler);\n          if (conversion != null) {\n            TypeMigrationReplacementUtil.replaceExpression((PsiExpression)psiElement, project, conversion);\n          }\n        }\n      }\n\n      final PsiExpression initializer = psiField.getInitializer();\n      if (initializer != null) {\n        final TypeConversionDescriptor conversion = ThreadLocalConversionRule.wrapWithNewExpression(toType, fromType, initializer);\n        TypeMigrationReplacementUtil.replaceExpression(initializer, project, conversion);\n        CodeStyleManager.getInstance(project).reformat(psiField);\n      }\n      else if (!assertNotNull(psiField.getModifierList()).hasModifierProperty(PsiModifier.FINAL)) {\n        final String text = \"new \" + PsiDiamondTypeUtil.getCollapsedType(toType, psiField) + \"()\";\n        final PsiExpression newInitializer = factory.createExpressionFromText(text, psiField);\n        psiField.setInitializer(newInitializer);\n      }\n\n      assertNotNull(psiField.getTypeElement()).replace(factory.createTypeElement(toType));\n\n      final PsiModifierList modifierList = assertNotNull(psiField.getModifierList());\n      modifierList.setModifierProperty(PsiModifier.FINAL, true);\n      modifierList.setModifierProperty(PsiModifier.VOLATILE, false);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"c961cb5e28a05ef7209277468fa0e9ba35819c1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Perform authorization-specific framework initializations for the Gradebook.\n     */\n    public void init() {\n    \tFunctionManager.registerFunction(PERMISSION_GRADE_ALL);\n    \tFunctionManager.registerFunction(PERMISSION_GRADE_SECTION);\n    \tFunctionManager.registerFunction(PERMISSION_EDIT_ASSIGNMENTS);\n    \tFunctionManager.registerFunction(PERMISSION_VIEW_OWN_GRADES);\n    }","id":101710,"modified_method":"/**\n     * Perform authorization-specific framework initializations for the Gradebook.\n     */\n    public void init() {\n        Collection registered = FunctionManager.getInstance().getRegisteredFunctions(\"gradebook\");\n        if(!registered.contains(PERMISSION_GRADE_ALL)) {\n            FunctionManager.registerFunction(PERMISSION_GRADE_ALL);\n        }\n\n        if(!registered.contains(PERMISSION_GRADE_SECTION)) {\n            FunctionManager.registerFunction(PERMISSION_GRADE_SECTION);\n        }\n\n        if(!registered.contains(PERMISSION_EDIT_ASSIGNMENTS)) {\n            FunctionManager.registerFunction(PERMISSION_EDIT_ASSIGNMENTS);\n        }\n\n        if(!registered.contains(PERMISSION_VIEW_OWN_GRADES)) {\n            FunctionManager.registerFunction(PERMISSION_VIEW_OWN_GRADES);\n        }\n    }","commit_id":"013f4e160a273e901656563228ac4423b202f1ad","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Test\n  public void failIfMetricNotFound() throws IOException {\n    File measures = new File(baseDir, \"src/foo.xoo.measures\");\n    FileUtils.write(measures, \"unknow:12\\n\\n#comment\");\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    fileSystem.add(inputFile);\n\n    thrown.expect(IllegalStateException.class);\n\n    sensor.execute(context);\n  }","id":101711,"modified_method":"@Test\n  public void failIfMetricNotFound() throws IOException {\n    File measures = new File(baseDir, \"src/foo.xoo.measures\");\n    FileUtils.write(measures, \"unknow:12\\n\\n#comment\");\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    context.fileSystem().add(inputFile);\n\n    thrown.expect(IllegalStateException.class);\n\n    sensor.execute(context);\n  }","commit_id":"ee09741a99176e635b310ab295dd898533828d69","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testExecution() throws IOException {\n    File measures = new File(baseDir, \"src/foo.xoo.measures\");\n    FileUtils.write(measures, \"ncloc:12\\nbranch_coverage:5.3\\nsqale_index:300\\nbool:true\\n\\n#comment\");\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    fileSystem.add(inputFile);\n\n    Metric<Boolean> booleanMetric = new Metric.Builder(\"bool\", \"Bool\", Metric.ValueType.BOOL)\n      .create();\n\n    when(metricFinder.findByKey(\"ncloc\")).thenReturn(CoreMetrics.NCLOC);\n    when(metricFinder.findByKey(\"branch_coverage\")).thenReturn(CoreMetrics.BRANCH_COVERAGE);\n    when(metricFinder.findByKey(\"sqale_index\")).thenReturn(CoreMetrics.TECHNICAL_DEBT);\n    when(metricFinder.findByKey(\"bool\")).thenReturn(booleanMetric);\n\n    sensor.execute(context);\n\n    verify(storage).store(new DefaultMeasure().forMetric(CoreMetrics.NCLOC).onFile(inputFile).withValue(12));\n    verify(storage).store(new DefaultMeasure().forMetric(CoreMetrics.BRANCH_COVERAGE).onFile(inputFile).withValue(5.3));\n    verify(storage).store(new DefaultMeasure().forMetric(CoreMetrics.TECHNICAL_DEBT).onFile(inputFile).withValue(300L));\n    verify(storage).store(new DefaultMeasure().forMetric(booleanMetric).onFile(inputFile).withValue(true));\n  }","id":101712,"modified_method":"@Test\n  public void testExecution() throws IOException {\n    File measures = new File(baseDir, \"src/foo.xoo.measures\");\n    FileUtils.write(measures, \"ncloc:12\\nbranch_coverage:5.3\\nsqale_index:300\\nbool:true\\n\\n#comment\");\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    context.fileSystem().add(inputFile);\n\n    Metric<Boolean> booleanMetric = new Metric.Builder(\"bool\", \"Bool\", Metric.ValueType.BOOL)\n      .create();\n\n    when(metricFinder.findByKey(\"ncloc\")).thenReturn(CoreMetrics.NCLOC);\n    when(metricFinder.findByKey(\"branch_coverage\")).thenReturn(CoreMetrics.BRANCH_COVERAGE);\n    when(metricFinder.findByKey(\"sqale_index\")).thenReturn(CoreMetrics.TECHNICAL_DEBT);\n    when(metricFinder.findByKey(\"bool\")).thenReturn(booleanMetric);\n\n    sensor.execute(context);\n\n    assertThat(context.measure(\"foo:src/foo.xoo\", CoreMetrics.NCLOC).value()).isEqualTo(12);\n    assertThat(context.measure(\"foo:src/foo.xoo\", CoreMetrics.BRANCH_COVERAGE).value()).isEqualTo(5.3);\n    assertThat(context.measure(\"foo:src/foo.xoo\", CoreMetrics.TECHNICAL_DEBT).value()).isEqualTo(300L);\n    assertThat(context.measure(\"foo:src/foo.xoo\", booleanMetric).value()).isTrue();\n  }","commit_id":"ee09741a99176e635b310ab295dd898533828d69","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testNoExecutionIfNoMeasureFile() {\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    fileSystem.add(inputFile);\n    sensor.execute(context);\n  }","id":101713,"modified_method":"@Test\n  public void testNoExecutionIfNoMeasureFile() {\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    context.fileSystem().add(inputFile);\n    sensor.execute(context);\n  }","commit_id":"ee09741a99176e635b310ab295dd898533828d69","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void prepare() throws IOException {\n    baseDir = temp.newFolder();\n    metricFinder = mock(MetricFinder.class);\n    sensor = new MeasureSensor(metricFinder);\n    fileSystem = new DefaultFileSystem(baseDir.toPath());\n    when(context.fileSystem()).thenReturn(fileSystem);\n    storage = mock(SensorStorage.class);\n    when(context.newMeasure()).then(new Answer<DefaultMeasure>() {\n      @Override\n      public DefaultMeasure answer(InvocationOnMock invocation) throws Throwable {\n        return new DefaultMeasure(storage);\n      }\n    });\n  }","id":101714,"modified_method":"@Before\n  public void prepare() throws IOException {\n    baseDir = temp.newFolder();\n    metricFinder = mock(MetricFinder.class);\n    sensor = new MeasureSensor(metricFinder);\n    context = SensorContextTester.create(baseDir);\n  }","commit_id":"ee09741a99176e635b310ab295dd898533828d69","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void prepare() throws IOException {\n    baseDir = temp.newFolder();\n    sensor = new SyntaxHighlightingSensor();\n    fileSystem = new DefaultFileSystem(baseDir.toPath());\n    when(context.fileSystem()).thenReturn(fileSystem);\n  }","id":101715,"modified_method":"@Before\n  public void prepare() throws IOException {\n    baseDir = temp.newFolder();\n    sensor = new SyntaxHighlightingSensor();\n    context = SensorContextTester.create(baseDir);\n  }","commit_id":"ee09741a99176e635b310ab295dd898533828d69","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testNoExecutionIfNoSyntaxFile() {\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    fileSystem.add(inputFile);\n    sensor.execute(context);\n  }","id":101716,"modified_method":"@Test\n  public void testNoExecutionIfNoSyntaxFile() {\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    context.fileSystem().add(inputFile);\n    sensor.execute(context);\n  }","commit_id":"ee09741a99176e635b310ab295dd898533828d69","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testExecution() throws IOException {\n    File symbol = new File(baseDir, \"src/foo.xoo.highlighting\");\n    FileUtils.write(symbol, \"1:4:k\\n12:15:cppd\\n\\n#comment\");\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    fileSystem.add(inputFile);\n    NewHighlighting builder = mock(NewHighlighting.class);\n    when(context.newHighlighting()).thenReturn(builder);\n    when(builder.onFile(any(InputFile.class))).thenReturn(builder);\n\n    sensor.execute(context);\n\n    verify(builder).highlight(1, 4, TypeOfText.KEYWORD);\n    verify(builder).highlight(12, 15, TypeOfText.CPP_DOC);\n    verify(builder).save();\n  }","id":101717,"modified_method":"@Test\n  public void testExecution() throws IOException {\n    File symbol = new File(baseDir, \"src/foo.xoo.highlighting\");\n    FileUtils.write(symbol, \"1:4:k\\n12:15:cppd\\n\\n#comment\");\n    DefaultInputFile inputFile = new DefaultInputFile(\"foo\", \"src/foo.xoo\").setLanguage(\"xoo\");\n    context.fileSystem().add(inputFile);\n\n    sensor.execute(context);\n\n    assertThat(context.highlightingTypeFor(\"foo:src/foo.xoo\", 2)).containsOnly(TypeOfText.KEYWORD);\n    assertThat(context.highlightingTypeFor(\"foo:src/foo.xoo\", 13)).containsOnly(TypeOfText.CPP_DOC);\n  }","commit_id":"ee09741a99176e635b310ab295dd898533828d69","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static void doInlineMethodTest(@NotNull final CodeInsightTestFixture fixture,\n                                        @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    new WriteCommandAction(fixture.getProject()) {\n      @Override\n      protected void run(@NotNull final Result result) throws Throwable {\n        final Editor editor = fixture.getEditor();\n        final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n        assert element instanceof PsiMethod : element;\n\n        final PsiReference ref = fixture.getFile().findReferenceAt(editor.getCaretModel().getOffset());\n        final PsiReferenceExpression refExpr = ref instanceof PsiReferenceExpression ? (PsiReferenceExpression)ref : null;\n\n        final PsiMethod method = (PsiMethod)element;\n        assert !(InlineMethodProcessor.checkBadReturns(method) && !InlineUtil.allUsagesAreTailCalls(method)) : \"Bad returns found\";\n        new InlineMethodProcessor(getProject(), method, refExpr, editor, false).run();\n      }\n    }.execute();\n    fixture.checkResultByFile(after, false);\n  }","id":101718,"modified_method":"public static void doInlineMethodTest(@NotNull final CodeInsightTestFixture fixture,\n                                        @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    final Editor editor = fixture.getEditor();\n    final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n    assert element instanceof PsiMethod : element;\n\n    final PsiReference ref = fixture.getFile().findReferenceAt(editor.getCaretModel().getOffset());\n    final PsiReferenceExpression refExpr = ref instanceof PsiReferenceExpression ? (PsiReferenceExpression)ref : null;\n\n    final PsiMethod method = (PsiMethod)element;\n    assert !(InlineMethodProcessor.checkBadReturns(method) && !InlineUtil.allUsagesAreTailCalls(method)) : \"Bad returns found\";\n    new InlineMethodProcessor(getProject(), method, refExpr, editor, false).run();\n    fixture.checkResultByFile(after, false);\n  }","commit_id":"6efe88ce3a328da525d6eec47a7f1da22a2f0f59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doInlineLocalTest(@NotNull final CodeInsightTestFixture fixture,\n                                       @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    new WriteCommandAction(fixture.getProject()) {\n      @Override\n      protected void run(@NotNull final Result result) throws Throwable {\n        final Editor editor = fixture.getEditor();\n        final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n        assert element instanceof PsiLocalVariable : element;\n        InlineLocalHandler.invoke(fixture.getProject(), editor, (PsiLocalVariable)element, null);\n      }\n    }.execute();\n    fixture.checkResultByFile(after, false);\n  }","id":101719,"modified_method":"public static void doInlineLocalTest(@NotNull final CodeInsightTestFixture fixture,\n                                       @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    final Editor editor = fixture.getEditor();\n    final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n    assert element instanceof PsiLocalVariable : element;\n    InlineLocalHandler.invoke(fixture.getProject(), editor, (PsiLocalVariable)element, null);\n    fixture.checkResultByFile(after, false);\n  }","commit_id":"6efe88ce3a328da525d6eec47a7f1da22a2f0f59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doInlineConstantTest(@NotNull final CodeInsightTestFixture fixture,\n                                          @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    new WriteCommandAction(fixture.getProject()) {\n      @Override\n      protected void run(@NotNull final Result result) throws Throwable {\n        final Editor editor = fixture.getEditor();\n        final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n        assert element instanceof PsiField : element;\n\n        final PsiReference ref = fixture.getFile().findReferenceAt(editor.getCaretModel().getOffset());\n        final PsiReferenceExpression refExpr = ref instanceof PsiReferenceExpression ? (PsiReferenceExpression)ref : null;\n\n        new InlineConstantFieldProcessor((PsiField)element, getProject(), refExpr, false).run();\n      }\n    }.execute();\n    fixture.checkResultByFile(after, false);\n  }","id":101720,"modified_method":"public static void doInlineConstantTest(@NotNull final CodeInsightTestFixture fixture,\n                                          @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    final Editor editor = fixture.getEditor();\n    final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n    assert element instanceof PsiField : element;\n\n    final PsiReference ref = fixture.getFile().findReferenceAt(editor.getCaretModel().getOffset());\n    final PsiReferenceExpression refExpr = ref instanceof PsiReferenceExpression ? (PsiReferenceExpression)ref : null;\n\n    new InlineConstantFieldProcessor((PsiField)element, getProject(), refExpr, false).run();\n    fixture.checkResultByFile(after, false);\n  }","commit_id":"6efe88ce3a328da525d6eec47a7f1da22a2f0f59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doInlineParameterTest(@NotNull final CodeInsightTestFixture fixture,\n                                           @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    new WriteCommandAction(fixture.getProject()) {\n      @Override\n      protected void run(@NotNull final Result result) throws Throwable {\n        final Editor editor = fixture.getEditor();\n        final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n        assert element instanceof PsiParameter : element;\n        new InlineParameterHandler().inlineElement(getProject(), editor, element);\n      }\n    }.execute();\n    fixture.checkResultByFile(after, false);\n  }","id":101721,"modified_method":"public static void doInlineParameterTest(@NotNull final CodeInsightTestFixture fixture,\n                                           @NotNull final String before, @NotNull final String after) {\n    fixture.configureByFile(before);\n    final Editor editor = fixture.getEditor();\n    final PsiElement element = TargetElementUtil.findTargetElement(editor, TARGET_FOR_INLINE_FLAGS);\n    assert element instanceof PsiParameter : element;\n    new InlineParameterHandler().inlineElement(getProject(), editor, element);\n    fixture.checkResultByFile(after, false);\n  }","commit_id":"6efe88ce3a328da525d6eec47a7f1da22a2f0f59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> getNonTypesystemRules(final SNode node) {\n    synchronized (RULES_LOCK) {\n    List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> result =\n        new LinkedList<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>>();\n      Set<NonTypesystemRule_Runtime> ruleSet = myNonTypesystemRules.getRules(node);\n      for (NonTypesystemRule_Runtime rule : ruleSet) {\n        IsApplicableStatus status = rule.isApplicableAndPattern(node);\n        if (status.isApplicable()) {\n          result.add(new Pair<NonTypesystemRule_Runtime, IsApplicableStatus>(rule, status));\n        }\n      }\n      return result;\n    }\n  }","id":101722,"modified_method":"public List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> getNonTypesystemRules(final SNode node) {\n    List<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>> result =\n      new LinkedList<Pair<NonTypesystemRule_Runtime, IsApplicableStatus>>();\n    Set<NonTypesystemRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      ruleSet = myNonTypesystemRules.getRules(node);\n    }\n    for (NonTypesystemRule_Runtime rule : ruleSet) {\n      IsApplicableStatus status = rule.isApplicableAndPattern(node);\n      if (status.isApplicable()) {\n        result.add(new Pair<NonTypesystemRule_Runtime, IsApplicableStatus>(rule, status));\n      }\n    }\n    return result;\n  }","commit_id":"6fda9d35fe9bbd1ed9cdadf9463c054146b383d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> getReplacementRules(final SNode node1, final SNode node2) {\n    synchronized (RULES_LOCK) {\n      List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>>();\n      Set<InequationReplacementRule_Runtime> ruleSet = myReplacementRules.getRules(node1, node2);\n      for (InequationReplacementRule_Runtime rule : ruleSet) {\n        IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n        if (status.isApplicable()) {\n          result.add(new Pair<InequationReplacementRule_Runtime, IsApplicable2Status>(rule, status));\n        }\n      }\n      return result;\n    }\n  }","id":101723,"modified_method":"public List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> getReplacementRules(final SNode node1, final SNode node2) {\n    List<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<InequationReplacementRule_Runtime, IsApplicable2Status>>();\n    Set<InequationReplacementRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      ruleSet = myReplacementRules.getRules(node1, node2);\n    }\n    for (InequationReplacementRule_Runtime rule : ruleSet) {\n      IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n      if (status.isApplicable()) {\n        result.add(new Pair<InequationReplacementRule_Runtime, IsApplicable2Status>(rule, status));\n      }\n    }\n    return result;\n  }","commit_id":"6fda9d35fe9bbd1ed9cdadf9463c054146b383d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> getComparisonRules(final SNode node1, final SNode node2, final boolean isWeak) {\n    synchronized (RULES_LOCK) {\n      loadLanguage(node1.getLanguageNamespace());\n      loadLanguage(node2.getLanguageNamespace());\n      List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<ComparisonRule_Runtime, IsApplicable2Status>>();\n      Set<ComparisonRule_Runtime> ruleSet = myComparisonRules.getRules(node1, node2);\n      for (ComparisonRule_Runtime rule : ruleSet) {\n        if (isWeak || !rule.isWeak()) {\n          IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n          if (status.isApplicable()) {\n            result.add(new Pair<ComparisonRule_Runtime, IsApplicable2Status>(rule, status));\n          }\n        }\n      }\n      return result;\n    }\n  }","id":101724,"modified_method":"public List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> getComparisonRules(final SNode node1, final SNode node2, final boolean isWeak) {\n    List<Pair<ComparisonRule_Runtime, IsApplicable2Status>> result = new LinkedList<Pair<ComparisonRule_Runtime, IsApplicable2Status>>();\n    Set<ComparisonRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      loadLanguage(node1.getLanguageNamespace());\n      loadLanguage(node2.getLanguageNamespace());\n      ruleSet = myComparisonRules.getRules(node1, node2);\n    }\n    for (ComparisonRule_Runtime rule : ruleSet) {\n      if (isWeak || !rule.isWeak()) {\n        IsApplicable2Status status = rule.isApplicableAndPatterns(node1, node2);\n        if (status.isApplicable()) {\n          result.add(new Pair<ComparisonRule_Runtime, IsApplicable2Status>(rule, status));\n        }\n      }\n    }\n    return result;\n  }","commit_id":"6fda9d35fe9bbd1ed9cdadf9463c054146b383d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> getSubtypingRules(final SNode node, final boolean isWeak) {\n    synchronized (RULES_LOCK) {\n      loadLanguage(node.getLanguageNamespace());\n      List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> result =\n        new LinkedList<Pair<SubtypingRule_Runtime, IsApplicableStatus>>();\n      Set<SubtypingRule_Runtime> ruleSet = mySubtypingRules.getRules(node);\n      for (SubtypingRule_Runtime rule : ruleSet) {\n        if ((isWeak || !rule.isWeak())) {\n          IsApplicableStatus status = rule.isApplicableAndPattern(node);\n          if (status.isApplicable()) {\n            result.add(new Pair<SubtypingRule_Runtime, IsApplicableStatus>(rule, status));\n          }\n        }\n      }\n      return result;\n    }\n  }","id":101725,"modified_method":"public List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> getSubtypingRules(final SNode node, final boolean isWeak) {\n   List<Pair<SubtypingRule_Runtime, IsApplicableStatus>> result = new LinkedList<Pair<SubtypingRule_Runtime, IsApplicableStatus>>();\n    Set<SubtypingRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      loadLanguage(node.getLanguageNamespace());\n      ruleSet = mySubtypingRules.getRules(node);\n    }\n    for (SubtypingRule_Runtime rule : ruleSet) {\n      if ((isWeak || !rule.isWeak())) {\n        IsApplicableStatus status = rule.isApplicableAndPattern(node);\n        if (status.isApplicable()) {\n          result.add(new Pair<SubtypingRule_Runtime, IsApplicableStatus>(rule, status));\n        }\n      }\n    }\n    return result;\n  }","commit_id":"6fda9d35fe9bbd1ed9cdadf9463c054146b383d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<Pair<InferenceRule_Runtime, IsApplicableStatus>> getInferenceRules(final SNode node) {\n    synchronized (RULES_LOCK) {\n      List<Pair<InferenceRule_Runtime, IsApplicableStatus>> result =\n        new LinkedList<Pair<InferenceRule_Runtime, IsApplicableStatus>>();\n      Set<InferenceRule_Runtime> ruleSet = myInferenceRules.getRules(node);\n      for (InferenceRule_Runtime rule : ruleSet) {\n        IsApplicableStatus status = rule.isApplicableAndPattern(node);\n        if (status.isApplicable()) {\n          result.add(new Pair<InferenceRule_Runtime, IsApplicableStatus>(rule, status));\n        }\n      }\n      return result;\n    }\n  }","id":101726,"modified_method":"public List<Pair<InferenceRule_Runtime, IsApplicableStatus>> getInferenceRules(final SNode node) {\n    List<Pair<InferenceRule_Runtime, IsApplicableStatus>> result = new LinkedList<Pair<InferenceRule_Runtime, IsApplicableStatus>>();\n    Set<InferenceRule_Runtime> ruleSet;\n    synchronized (RULES_LOCK) {\n      ruleSet = myInferenceRules.getRules(node);\n    }\n    for (InferenceRule_Runtime rule : ruleSet) {\n      IsApplicableStatus status = rule.isApplicableAndPattern(node);\n      if (status.isApplicable()) {\n        result.add(new Pair<InferenceRule_Runtime, IsApplicableStatus>(rule, status));\n      }\n    }\n    return result;\n  }","commit_id":"6fda9d35fe9bbd1ed9cdadf9463c054146b383d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<AbstractDependentComputation_Runtime> getDependentComputations(final SNode node) {\n    synchronized (RULES_LOCK) {\n      return CollectionUtil.filter(myDependentComputations.getRules(node), new Condition<AbstractDependentComputation_Runtime>() {\n        @Override\n        public boolean met(AbstractDependentComputation_Runtime dependentComputation) {\n          return dependentComputation.isApplicable(node);\n        }\n      });\n    }\n  }","id":101727,"modified_method":"public Set<AbstractDependentComputation_Runtime> getDependentComputations(final SNode node) {\n    Set<AbstractDependentComputation_Runtime> rules;\n    synchronized (RULES_LOCK) {\n      rules = myDependentComputations.getRules(node);\n    }\n    return CollectionUtil.filter(rules, new Condition<AbstractDependentComputation_Runtime>() {\n      @Override\n      public boolean met(AbstractDependentComputation_Runtime dependentComputation) {\n        return dependentComputation.isApplicable(node);\n      }\n    });\n  }","commit_id":"6fda9d35fe9bbd1ed9cdadf9463c054146b383d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isBlockingDependentComputationNode(SNode node) {\n    synchronized (RULES_LOCK) {\n      Set<DependentComputationWrapper> set = myDependentComputationsBlockedNodes.getRules(node);\n      if (set == null) return false;\n      for (DependentComputationWrapper wrapper : set) {\n        if (wrapper.isBlocking(node)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }","id":101728,"modified_method":"public boolean isBlockingDependentComputationNode(SNode node) {\n    Set<DependentComputationWrapper> set;\n    synchronized (RULES_LOCK) {\n      set = myDependentComputationsBlockedNodes.getRules(node);\n    }\n    if (set == null) return false;\n    for (DependentComputationWrapper wrapper : set) {\n      if (wrapper.isBlocking(node)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"6fda9d35fe9bbd1ed9cdadf9463c054146b383d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Default constructor\n     */\n    public AsfDoapProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        try\n        {\n            model =\n                pomReader.read( ReaderFactory.newXmlReader( new File( getBasedir(),\n                                                                      \"asf-doap-configuration-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setDescription( model.getDescription() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n    }","id":101729,"modified_method":"/**\n     * Default constructor\n     */\n    public AsfDoapProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        try\n        {\n            model =\n                pomReader.read( ReaderFactory.newXmlReader( new File( getBasedir(),\n                                                                      \"asf-doap-configuration-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setDescription( model.getDescription() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n        setDevelopers( model.getDevelopers() );\n    }","commit_id":"b1bf32803dc338b5a91f2c2084c7902547bc187e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Writer a single developer or contributor\n     *\n     * @param writer not null\n     * @param developerOrContributor not null, instance of <code>{@link Developer}/{@link Contributor}<\/code>\n     * @param doapType not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#maintainer\">http://usefulinc.com/ns/doap#maintainer<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#developer\">http://usefulinc.com/ns/doap#developer<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#documenter\">http://usefulinc.com/ns/doap#documenter<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#translator\">http://usefulinc.com/ns/doap#translator<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#tester\">http://usefulinc.com/ns/doap#tester<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#helper\">http://usefulinc.com/ns/doap#helper<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/Person\">http://xmlns.com/foaf/0.1/Person<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/name\">http://xmlns.com/foaf/0.1/name<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/mbox\">http://xmlns.com/foaf/0.1/mbox<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/Organization\">http://xmlns.com/foaf/0.1/Organization<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/homepage\">http://xmlns.com/foaf/0.1/homepage<\/a>\n     */\n    private void writeDeveloperOrContributor( XMLWriter writer, Object developerOrContributor, String doapType )\n    {\n        if ( developerOrContributor == null )\n        {\n            return;\n        }\n\n        if ( StringUtils.isEmpty( doapType ) )\n        {\n            throw new IllegalArgumentException( \"doapType is required.\" );\n        }\n\n        String name;\n        String email;\n        String organization;\n        String homepage;\n\n        if ( Developer.class.isAssignableFrom( developerOrContributor.getClass() ) )\n        {\n            Developer d = (Developer) developerOrContributor;\n            name = d.getName();\n            email = d.getEmail();\n            organization = d.getOrganization();\n            homepage = d.getUrl();\n        }\n        else\n        {\n            Contributor c = (Contributor) developerOrContributor;\n            name = c.getName();\n            email = c.getEmail();\n            organization = c.getOrganization();\n            homepage = c.getUrl();\n        }\n\n        // Name is required to write doap\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return;\n        }\n\n        writer.startElement( doapType );\n        writer.startElement( \"foaf:Person\" );\n        writer.startElement( \"foaf:name\" );\n        writer.writeText( name );\n        writer.endElement(); // foaf:name\n        if ( StringUtils.isNotEmpty( email ) )\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"foaf:mbox\", \"mailto:\" + email );\n        }\n        if ( StringUtils.isNotEmpty( organization ) )\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"foaf:Organization\", organization );\n        }\n        if ( StringUtils.isNotEmpty( homepage ) )\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"foaf:homepage\", homepage );\n        }\n        writer.endElement(); // foaf:Person\n        writer.endElement(); // doapType\n    }","id":101730,"modified_method":"/**\n     * Writer a single developer or contributor\n     *\n     * @param writer not null\n     * @param developerOrContributor not null, instance of <code>{@link Developer}/{@link Contributor}<\/code>\n     * @param doapType not null\n     * @see <a href=\"http://usefulinc.com/ns/doap#maintainer\">http://usefulinc.com/ns/doap#maintainer<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#developer\">http://usefulinc.com/ns/doap#developer<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#documenter\">http://usefulinc.com/ns/doap#documenter<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#translator\">http://usefulinc.com/ns/doap#translator<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#tester\">http://usefulinc.com/ns/doap#tester<\/a>\n     * @see <a href=\"http://usefulinc.com/ns/doap#helper\">http://usefulinc.com/ns/doap#helper<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/Person\">http://xmlns.com/foaf/0.1/Person<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/name\">http://xmlns.com/foaf/0.1/name<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/mbox\">http://xmlns.com/foaf/0.1/mbox<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/Organization\">http://xmlns.com/foaf/0.1/Organization<\/a>\n     * @see <a href=\"http://xmlns.com/foaf/0.1/homepage\">http://xmlns.com/foaf/0.1/homepage<\/a>\n     */\n    private void writeDeveloperOrContributor( XMLWriter writer, Object developerOrContributor, String doapType )\n    {\n        if ( developerOrContributor == null )\n        {\n            return;\n        }\n\n        if ( StringUtils.isEmpty( doapType ) )\n        {\n            throw new IllegalArgumentException( \"doapType is required.\" );\n        }\n\n        String name;\n        String email;\n        String organization;\n        String organizationUrl;\n        String homepage;\n        String nodeId = null;\n\n        if ( Developer.class.isAssignableFrom( developerOrContributor.getClass() ) )\n        {\n            Developer d = (Developer) developerOrContributor;\n            name = d.getName();\n            email = d.getEmail();\n            organization = d.getOrganization();\n            organizationUrl = d.getOrganizationUrl();\n            homepage = d.getUrl();\n        }\n        else\n        {\n            Contributor c = (Contributor) developerOrContributor;\n            name = c.getName();\n            email = c.getEmail();\n            organization = c.getOrganization();\n            organizationUrl = c.getOrganizationUrl();\n            homepage = c.getUrl();\n        }\n\n        // Name is required to write doap\n        if ( StringUtils.isEmpty( name ) )\n        {\n            return;\n        }\n\n        if ( !StringUtils.isEmpty( organization ) || !StringUtils.isEmpty( organizationUrl ) )\n        {\n            DoapUtil.Organization doapOrganization = DoapUtil.addOrganization( organization, organizationUrl );\n            nodeId = DoapUtil.getNodeId();\n            doapOrganization.addMember( nodeId );\n        }\n\n        writer.startElement( doapType );\n        writer.startElement( \"foaf:Person\" );\n        if ( StringUtils.isNotEmpty( nodeId ) )\n        {\n            writer.addAttribute( \"rdf:nodeID\", nodeId );\n        }\n        writer.startElement( \"foaf:name\" );\n        writer.writeText( name );\n        writer.endElement(); // foaf:name\n        if ( StringUtils.isNotEmpty( email ) )\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"foaf:mbox\", \"mailto:\" + email );\n        }\n        if ( StringUtils.isNotEmpty( organization ) || StringUtils.isNotEmpty( organizationUrl ) )\n        {\n            DoapUtil.addOrganization( organization, organizationUrl );\n        }\n        if ( StringUtils.isNotEmpty( homepage ) )\n        {\n            DoapUtil.writeRdfResourceElement( writer, \"foaf:homepage\", homepage );\n        }\n        writer.endElement(); // foaf:Person\n        writer.endElement(); // doapType\n    }","commit_id":"b1bf32803dc338b5a91f2c2084c7902547bc187e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // ----------------------------------------------------------------------------\n        // setup pretty print xml writer\n        // ----------------------------------------------------------------------------\n\n        Writer w;\n        try\n        {\n            if ( !doapFile.getParentFile().exists() )\n            {\n                FileUtils.mkdir( doapFile.getParentFile().getAbsolutePath() );\n            }\n\n            w = WriterFactory.newXmlWriter( doapFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error creating DOAP file.\", e );\n        }\n\n        if ( asfExtOptions.isIncluded() )\n        {\n            getLog().info( \"Generating an ASF DOAP file...\" );\n        }\n        else\n        {\n            getLog().info( \"Generating a pure DOAP file...\" );\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w, project.getModel().getModelEncoding(), null );\n\n        // ----------------------------------------------------------------------------\n        // Convert POM to DOAP\n        // ----------------------------------------------------------------------------\n\n        DoapUtil.writeHeader( writer );\n\n        // Heading\n        writer.startElement( \"rdf:RDF\" );\n        writer.addAttribute( \"xml:lang\", lang );\n        writer.addAttribute( \"xmlns\", \"http://usefulinc.com/ns/doap#\" );\n        writer.addAttribute( \"xmlns:rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" );\n        writer.addAttribute( \"xmlns:foaf\", \"http://xmlns.com/foaf/0.1/\" );\n        if ( asfExtOptions.isIncluded() )\n        {\n            writer.addAttribute( \"xmlns:asfext\", ASFExtOptions.ASFEXT_NAMESPACE );\n        }\n\n        // Project\n        writer.startElement( \"Project\" );\n        if ( StringUtils.isNotEmpty( about ) )\n        {\n            writer.addAttribute( \"rdf:about\", about );\n        }\n        else\n        {\n            getLog().warn( \"rdf:about should be required\" );\n        }\n\n        // name\n        writeName( writer );\n\n        // description\n        writeDescription( writer );\n\n        // created\n        writeCreated( writer );\n\n        // homepage and old-homepage\n        writeHomepage( writer );\n\n        // licenses\n        writeLicenses( writer );\n\n        // programming-language\n        writeProgrammingLanguage( writer );\n\n        // category\n        writeCategory( writer );\n\n        // os\n        writeOS( writer );\n\n        // SCM\n        writeSourceRepositories( writer );\n\n        // bug-database\n        writeBugDatabase( writer );\n\n        // mailing list\n        writeMailingList( writer );\n\n        // download-page and download-mirror\n        writeDownloadPage( writer );\n\n        // screenshots\n        writeScreenshots( writer );\n\n        // wiki\n        writeWiki( writer );\n\n        // Releases\n        writeReleases( writer );\n\n        // Developers\n        writeDevelopersOrContributors( writer, project.getDevelopers() );\n\n        // Contributors\n        writeDevelopersOrContributors( writer, project.getContributors() );\n\n        // ASFext\n        if ( asfExtOptions.isIncluded() )\n        {\n            writeASFext( writer );\n        }\n\n        writer.endElement(); // Project\n        writer.endElement(); // rdf:RDF\n\n        try\n        {\n            w.close();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error when closing the writer.\", e );\n        }\n\n        if ( validate )\n        {\n            List errors = DoapUtil.validate( doapFile );\n            if ( !errors.isEmpty() )\n            {\n                for ( int i = 0; i < errors.size(); i++ )\n                {\n                    getLog().error( errors.get( i ).toString() );\n                }\n\n                throw new MojoExecutionException( \"Error parsing the generated doap file, see above.\" );\n            }\n        }\n    }","id":101731,"modified_method":"/** {@inheritDoc} */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // ----------------------------------------------------------------------------\n        // setup pretty print xml writer\n        // ----------------------------------------------------------------------------\n\n        Writer w;\n        try\n        {\n            if ( !doapFile.getParentFile().exists() )\n            {\n                FileUtils.mkdir( doapFile.getParentFile().getAbsolutePath() );\n            }\n\n            w = WriterFactory.newXmlWriter( doapFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error creating DOAP file.\", e );\n        }\n\n        if ( asfExtOptions.isIncluded() )\n        {\n            getLog().info( \"Generating an ASF DOAP file...\" );\n        }\n        else\n        {\n            getLog().info( \"Generating a pure DOAP file...\" );\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w, project.getModel().getModelEncoding(), null );\n\n        // ----------------------------------------------------------------------------\n        // Convert POM to DOAP\n        // ----------------------------------------------------------------------------\n\n        DoapUtil.writeHeader( writer );\n\n        // Heading\n        writer.startElement( \"rdf:RDF\" );\n        writer.addAttribute( \"xml:lang\", lang );\n        writer.addAttribute( \"xmlns\", \"http://usefulinc.com/ns/doap#\" );\n        writer.addAttribute( \"xmlns:rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" );\n        writer.addAttribute( \"xmlns:foaf\", \"http://xmlns.com/foaf/0.1/\" );\n        if ( asfExtOptions.isIncluded() )\n        {\n            writer.addAttribute( \"xmlns:asfext\", ASFExtOptions.ASFEXT_NAMESPACE );\n        }\n\n        // Project\n        writer.startElement( \"Project\" );\n        if ( StringUtils.isNotEmpty( about ) )\n        {\n            writer.addAttribute( \"rdf:about\", about );\n        }\n        else\n        {\n            getLog().warn( \"rdf:about should be required\" );\n        }\n\n        // name\n        writeName( writer );\n\n        // description\n        writeDescription( writer );\n\n        // created\n        writeCreated( writer );\n\n        // homepage and old-homepage\n        writeHomepage( writer );\n\n        // licenses\n        writeLicenses( writer );\n\n        // programming-language\n        writeProgrammingLanguage( writer );\n\n        // category\n        writeCategory( writer );\n\n        // os\n        writeOS( writer );\n\n        // SCM\n        writeSourceRepositories( writer );\n\n        // bug-database\n        writeBugDatabase( writer );\n\n        // mailing list\n        writeMailingList( writer );\n\n        // download-page and download-mirror\n        writeDownloadPage( writer );\n\n        // screenshots\n        writeScreenshots( writer );\n\n        // wiki\n        writeWiki( writer );\n\n        // Releases\n        writeReleases( writer );\n\n        // Developers\n        writeDevelopersOrContributors( writer, project.getDevelopers() );\n\n        // Contributors\n        writeDevelopersOrContributors( writer, project.getContributors() );\n\n        // ASFext\n        if ( asfExtOptions.isIncluded() )\n        {\n            writeASFext( writer );\n        }\n\n        writer.endElement(); // Project\n\n        writeOrganizations( writer );\n\n        writer.endElement(); // rdf:RDF\n\n        try\n        {\n            w.close();\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error when closing the writer.\", e );\n        }\n\n        if ( validate )\n        {\n            List errors = DoapUtil.validate( doapFile );\n            if ( !errors.isEmpty() )\n            {\n                for ( int i = 0; i < errors.size(); i++ )\n                {\n                    getLog().error( errors.get( i ).toString() );\n                }\n\n                throw new MojoExecutionException( \"Error parsing the generated doap file, see above.\" );\n            }\n        }\n    }","commit_id":"b1bf32803dc338b5a91f2c2084c7902547bc187e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Verify the generation of a pure DOAP file.\n     *\n     * @throws Exception if any\n     */\n    public void testGeneratedDoap()\n        throws Exception\n    {\n        File pluginXmlFile =\n            new File( getBasedir(),\n                      \"src/test/resources/unit/doap-configuration/doap-configuration-plugin-config.xml\" );\n        DoapMojo mojo = (DoapMojo) lookupMojo( \"generate\", pluginXmlFile );\n        assertNotNull( \"Mojo found.\", mojo );\n\n        MavenProject mavenProject = (MavenProject) getVariableValueFromObject( mojo, \"project\" );\n        assertNotNull( mavenProject );\n\n        // Set some Mojo parameters\n        setVariableValueToObject( mojo, \"remoteRepositories\", getRemoteRepositories() );\n        setVariableValueToObject( mojo, \"about\", mavenProject.getUrl() );\n\n        mojo.execute();\n\n        File doapFile = new File( getBasedir(), \"target/test/unit/doap-configuration/doap-configuration.rdf\" );\n        assertTrue( \"Doap File was not generated!\", doapFile.exists() );\n\n        String readed = readFile( doapFile );\n\n        // Validate\n\n        // Pure DOAP\n        assertTrue( readed.indexOf( \"<rdf:RDF xml:lang=\\\"en\\\" xmlns=\\\"http://usefulinc.com/ns/doap#\\\" \"\n            + \"xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\" \"\n            + \"xmlns:foaf=\\\"http://xmlns.com/foaf/0.1/\\\">\" ) != -1 );\n        if ( StringUtils.isNotEmpty( mavenProject.getUrl() ) )\n        {\n            assertTrue( readed.indexOf( \"<Project rdf:about=\\\"\" + mavenProject.getUrl() + \"\\\">\" ) != -1 );\n            assertTrue( readed.indexOf( \"<homepage rdf:resource=\\\"\" + mavenProject.getUrl() + \"\\\"/>\" ) != -1 );\n        }\n        assertTrue( readed.indexOf( \"<name>\" + mavenProject.getName() + \"<\/name>\" ) != -1 );\n        assertTrue( readed.indexOf( \"<programming-language>java<\/programming-language>\" ) != -1 );\n\n        // ASF ext\n        assertFalse( readed.indexOf( \"<asfext:pmc rdf:resource=\\\"\" + mavenProject.getUrl() + \"\\\"/>\" ) != -1 );\n        assertFalse( readed.indexOf( \"<asfext:name>\" + mavenProject.getName() + \"<\/name>\" ) != -1 );\n    }","id":101732,"modified_method":"/**\n     * Verify the generation of a pure DOAP file.\n     *\n     * @throws Exception if any\n     */\n    public void testGeneratedDoap()\n        throws Exception\n    {\n        File pluginXmlFile =\n            new File( getBasedir(), \"src/test/resources/unit/doap-configuration/doap-configuration-plugin-config.xml\" );\n        DoapMojo mojo = (DoapMojo) lookupMojo( \"generate\", pluginXmlFile );\n        assertNotNull( \"Mojo found.\", mojo );\n\n        MavenProject mavenProject = (MavenProject) getVariableValueFromObject( mojo, \"project\" );\n        assertNotNull( mavenProject );\n\n        // Set some Mojo parameters\n        setVariableValueToObject( mojo, \"remoteRepositories\", getRemoteRepositories() );\n        setVariableValueToObject( mojo, \"about\", mavenProject.getUrl() );\n\n        mojo.execute();\n\n        File doapFile = new File( getBasedir(), \"target/test/unit/doap-configuration/doap-configuration.rdf\" );\n        assertTrue( \"Doap File was not generated!\", doapFile.exists() );\n\n        String readed = readFile( doapFile );\n\n        // Validate\n\n        // Pure DOAP\n        assertTrue( readed.indexOf( \"<rdf:RDF xml:lang=\\\"en\\\" xmlns=\\\"http://usefulinc.com/ns/doap#\\\" \"\n            + \"xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\" \"\n            + \"xmlns:foaf=\\\"http://xmlns.com/foaf/0.1/\\\">\" ) != -1 );\n        if ( StringUtils.isNotEmpty( mavenProject.getUrl() ) )\n        {\n            assertTrue( readed.indexOf( \"<Project rdf:about=\\\"\" + mavenProject.getUrl() + \"\\\">\" ) != -1 );\n            assertTrue( readed.indexOf( \"<homepage rdf:resource=\\\"\" + mavenProject.getUrl() + \"\\\"/>\" ) != -1 );\n        }\n        assertTrue( readed.indexOf( \"<name>\" + mavenProject.getName() + \"<\/name>\" ) != -1 );\n        assertTrue( readed.indexOf( \"<programming-language>java<\/programming-language>\" ) != -1 );\n\n        // ASF ext\n        assertFalse( readed.indexOf( \"<asfext:pmc rdf:resource=\\\"\" + mavenProject.getUrl() + \"\\\"/>\" ) != -1 );\n        assertFalse( readed.indexOf( \"<asfext:name>\" + mavenProject.getName() + \"<\/name>\" ) != -1 );\n\n        // Developers and Organizations\n        assertTrue( readed.indexOf( \"<maintainer>\" ) != -1 );\n        assertTrue( readed.indexOf( \"<foaf:Person rdf:nodeID=\\\"b1\\\">\" ) != -1 );\n        assertTrue( readed.indexOf( \"<foaf:name>Jane Doe<\/foaf:name>\" ) != -1 );\n        assertTrue( readed.indexOf( \"<foaf:Organization>\" ) != -1 );\n        assertTrue( readed.indexOf( \"<foaf:homepage rdf:resource=\\\"http://www.example.org\\\"/>\" ) != -1 );\n        assertTrue( readed.indexOf( \"<foaf:member rdf:nodeID=\\\"b1\\\"/>\" ) != -1 );\n    }","commit_id":"b1bf32803dc338b5a91f2c2084c7902547bc187e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Default constructor\n     */\n    public DoapProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        try\n        {\n            model =\n                pomReader.read( ReaderFactory.newXmlReader( new File( getBasedir(),\n                                                                      \"doap-configuration-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setDescription( model.getDescription() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n    }","id":101733,"modified_method":"/**\n     * Default constructor\n     */\n    public DoapProjectStub()\n    {\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        try\n        {\n            model =\n                pomReader.read( ReaderFactory.newXmlReader( new File( getBasedir(),\n                                                                      \"doap-configuration-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setDescription( model.getDescription() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n        setDevelopers( model.getDevelopers() );\n    }","commit_id":"b1bf32803dc338b5a91f2c2084c7902547bc187e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#getDefault(org.opencms.file.CmsObject, org.opencms.xml.types.I_CmsXmlSchemaType, java.util.Locale)\n     */\n    public String getDefault(CmsObject cms, I_CmsXmlSchemaType type, Locale locale) {\n\n        String defaultValue = (String)m_defaultValues.get(type.getElementName());\n        if (defaultValue != null) {\n            // return the string set in the appinfo with processed macros\n            return CmsStringUtil.substituteMacros(defaultValue, new CmsDefaultXmlStringMapper(this, null, locale, cms));\n        }\n\n        // default implementation currently just uses the \"getDefault\" mehod of the given value\n        return type.getDefault(locale);\n    }","id":101734,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#getDefault(org.opencms.file.CmsObject, org.opencms.xml.types.I_CmsXmlSchemaType, java.util.Locale)\n     */\n    public String getDefault(CmsObject cms, I_CmsXmlSchemaType type, Locale locale) {\n\n        String defaultValue = (String)m_defaultValues.get(type.getElementName());\n        if (defaultValue != null) {\n            // return the string set in the appinfo with processed macros\n            return CmsStringUtil.substituteMacros(defaultValue, new CmsStringMapper(this, null, locale, cms));\n        }\n\n        // default implementation currently just uses the \"getDefault\" mehod of the given value\n        return type.getDefault(locale);\n    }","commit_id":"2c76599546ac3ffb03ea9db265a3c8f623b7e3f7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the validation message to be displayed if a certain rule was violated.<p> \n     * \n     * @param cms the current users OpenCms context\n     * @param value the value to validate\n     * @param regex the rule that was vialoted\n     * @param valueStr the string value of the given value\n     * @param matchResult if false, the rule was negated\n     * @param isWarning if true, this validation indicate a warning, otherwise an error\n     * \n     * @return the validation message to be displayed \n     */\n    protected String getValidationMessage(\n        CmsObject cms,\n        I_CmsXmlContentValue value,\n        String regex,\n        String valueStr,\n        boolean matchResult,\n        boolean isWarning) {\n\n        String message = null;\n        if (isWarning) {\n            message = (String)m_validationWarningMessages.get(value.getElementName());\n        } else {\n            message = (String)m_validationErrorMessages.get(value.getElementName());\n        }\n\n        if (message == null) {\n            if (isWarning) {\n                message = MESSAGE_VALIDATION_DEFAULT_WARNING;\n            } else {\n                message = MESSAGE_VALIDATION_DEFAULT_ERROR;\n            }\n        }\n\n        Map additionalValues = new HashMap();\n        additionalValues.put(I_CmsStringMapper.KEY_VALIDATION_VALUE, valueStr);\n        additionalValues.put(I_CmsStringMapper.KEY_VALIDATION_REGEX, ((!matchResult) ? \"!\" : \"\") + regex);\n        additionalValues.put(I_CmsStringMapper.KEY_VALIDATION_PATH, value.getPath());\n\n        return CmsStringUtil\n            .substituteMacros(message, new CmsDefaultXmlStringMapper(this, additionalValues, null, cms));\n    }","id":101735,"modified_method":"/**\n     * Returns the validation message to be displayed if a certain rule was violated.<p> \n     * \n     * @param cms the current users OpenCms context\n     * @param value the value to validate\n     * @param regex the rule that was vialoted\n     * @param valueStr the string value of the given value\n     * @param matchResult if false, the rule was negated\n     * @param isWarning if true, this validation indicate a warning, otherwise an error\n     * \n     * @return the validation message to be displayed \n     */\n    protected String getValidationMessage(\n        CmsObject cms,\n        I_CmsXmlContentValue value,\n        String regex,\n        String valueStr,\n        boolean matchResult,\n        boolean isWarning) {\n\n        String message = null;\n        if (isWarning) {\n            message = (String)m_validationWarningMessages.get(value.getElementName());\n        } else {\n            message = (String)m_validationErrorMessages.get(value.getElementName());\n        }\n\n        if (message == null) {\n            if (isWarning) {\n                message = MESSAGE_VALIDATION_DEFAULT_WARNING;\n            } else {\n                message = MESSAGE_VALIDATION_DEFAULT_ERROR;\n            }\n        }\n\n        Map additionalValues = new HashMap();\n        additionalValues.put(I_CmsStringMapper.KEY_VALIDATION_VALUE, valueStr);\n        additionalValues.put(I_CmsStringMapper.KEY_VALIDATION_REGEX, ((!matchResult) ? \"!\" : \"\") + regex);\n        additionalValues.put(I_CmsStringMapper.KEY_VALIDATION_PATH, value.getPath());\n\n        return CmsStringUtil\n            .substituteMacros(message, new CmsStringMapper(this, additionalValues, null, cms));\n    }","commit_id":"2c76599546ac3ffb03ea9db265a3c8f623b7e3f7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the next resource from the collector.<p>\n     * \n     * @return the next resource from the collector\n     */\n    private CmsResource getNextResource() {\n\n        if ((m_collectorResult != null) && (m_collectorResult.size() > 0)) {\n            return (CmsResource)m_collectorResult.remove(0);\n        }\n        return null;\n    }","id":101736,"modified_method":"/**\n     * Returns the next resource from the collector.<p>\n     * \n     * @return the next resource from the collector\n     */\n    private CmsResource getNextResource() {\n\n        if ((m_collectorResult != null) && (m_collectorResult.size() > 0)) {\n            \n            m_contentInfoBean.incResultIndex();            \n            return (CmsResource)m_collectorResult.remove(0);\n        }\n        \n        return null;\n    }","commit_id":"2c76599546ac3ffb03ea9db265a3c8f623b7e3f7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // get the selected collector\n        String collectorName = getCollector();        \n        if (CmsStringUtil.isEmpty(collectorName)) {\n            throw new IllegalArgumentException(\"'contentload' tag requires 'collector' attribute\");\n        }\n\n        // initialize OpenCms access objects\n        m_controller = (CmsFlexController)pageContext.getRequest().getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        m_cms = m_controller.getCmsObject();\n\n        // store the current locale    \n        m_locale = m_cms.getRequestContext().getLocale();\n\n        // construct the parameters from the \"property\" and the \"param\" tag\n        String param = getProperty();\n        if (CmsStringUtil.isNotEmpty(param)) {\n            \n            // read the selected property value\n            CmsProperty property;\n            try {\n                property = m_cms.readPropertyObject(m_cms.getRequestContext().getUri(), param, true);\n            } catch (CmsException e) {\n                OpenCms.getLog(this).error(\n                    \"Error reading property '\" + param + \"' on resource \" + m_cms.getRequestContext().getUri(), e);\n                property = CmsProperty.getNullProperty();\n            }\n            param = property.getValue(\"\");\n                        \n            if (CmsStringUtil.isNotEmpty(getParam())) {\n                // property and param not empty, concat \"property\" and \"param\" tag\n                param = param.concat(getParam());\n            }\n        } else {\n            // resolve magic parameter name\n            param = resolveMagicName(getParam());\n        }\n        \n        // now collect the resources\n        I_CmsResourceCollector collector = OpenCms.getResourceManager().getContentCollector(collectorName);\n\n        try {\n            // execute the collector\n            m_collectorResult = collector.getResults(m_cms, collectorName, param);\n            if ((m_collectorResult == null) || (m_collectorResult.size() == 0)) {\n                // the collector returned an empty list, there's no content to iterate\n                return SKIP_BODY;\n            }\n            String createParam = collector.getCreateParam(m_cms, collectorName, param);\n            if (createParam != null) {\n                // use \"create link\" only if collector supports it\n                m_directEditCreateLink = CmsEncoder.encode(collectorName + \"|\" + createParam);\n            }\n            doLoadNextFile();\n        } catch (CmsException e) {\n            m_controller.setThrowable(e, m_cms.getRequestContext().getUri());\n            throw new JspException(e);\n        }\n\n        // check \"direct edit\" support\n        if (m_editable) {\n\n            // check options for first element\n            String directEditOptions;\n            if (m_directEditCreateLink != null) {\n                // if create link is not null, show \"edit\", \"delete\" and \"new\" button for first element\n                directEditOptions = CmsJspTagEditable.createEditOptions(true, true, true);\n                // show \"edit\" and \"delete\" button for 2nd to last element\n                m_directEditFollowOptions = CmsJspTagEditable.createEditOptions(true, true, false);\n            } else {\n                // if create link is null, show only \"edit\" button for first element\n                directEditOptions = CmsJspTagEditable.createEditOptions(true, false, false);\n                // also show only the \"edit\" button for 2nd to last element\n                m_directEditFollowOptions = directEditOptions;\n            }\n\n            m_directEditPermissions = CmsJspTagEditable.includeDirectEditElement(\n                pageContext,\n                I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_START,\n                m_resourceName,\n                null,\n                directEditOptions,\n                null,\n                m_directEditCreateLink);\n        }\n\n        return EVAL_BODY_INCLUDE;\n    }","id":101737,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n        \n        // check if the tag contains both a pageSize and pageIndex attribute, or none of them\n        if ((CmsStringUtil.isEmpty(m_pageSize) && CmsStringUtil.isNotEmpty(m_pageIndex))\n            || (CmsStringUtil.isNotEmpty(m_pageSize) && CmsStringUtil.isEmpty(m_pageIndex))) {            \n            throw new IllegalArgumentException(\"The 'cms:contentload' tag requires both a 'pageIndex' and 'pageSize' attribute!\");\n        }\n        \n        // check the tag contains a collector attribute\n        if (CmsStringUtil.isEmpty(m_collector)) {\n            throw new IllegalArgumentException(\"The 'cms:contentload' tag requires 'collector' attribute!\");\n        }\n        \n        // initialize OpenCms access objects\n        m_controller = (CmsFlexController)pageContext.getRequest().getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        m_cms = m_controller.getCmsObject();\n        \n        // initialize a string mapper to resolve EL like strings in tag attributes\n        m_stringMapper = new CmsStringMapper(m_cms, pageContext);\n\n        // resolve the collector name\n        String collectorName = m_stringMapper.map(getCollector(), this);        \n\n        // store the current locale    \n        m_locale = m_cms.getRequestContext().getLocale();\n\n        // resolve the parameter\n        String param = m_stringMapper.map(getParam(), this);\n        \n        // now collect the resources\n        I_CmsResourceCollector collector = OpenCms.getResourceManager().getContentCollector(collectorName);\n\n        try {\n            // execute the collector\n            m_collectorResult = collector.getResults(m_cms, collectorName, param); \n            \n            m_contentInfoBean = new CmsContentInfoBean();\n            m_contentInfoBean.setPageSizeAsString(m_stringMapper.map(m_pageSize, this));\n            m_contentInfoBean.setPageIndexAsString(m_stringMapper.map(m_pageIndex, this));            \n            m_contentInfoBean.setResultSize(m_collectorResult.size());\n            m_contentInfoBean.initResultIndex();\n        \n            m_collectorResult = CmsJspTagContentLoad.limitCollectorResult(m_contentInfoBean, m_collectorResult);\n            \n            if ((m_collectorResult == null) || (m_collectorResult.size() == 0)) {\n                // the collector returned an empty list, there's no content to iterate\n                return SKIP_BODY;\n            }\n            String createParam = collector.getCreateParam(m_cms, collectorName, param);\n            if (createParam != null) {\n                // use \"create link\" only if collector supports it\n                m_directEditCreateLink = CmsEncoder.encode(collectorName + \"|\" + createParam);\n            }\n            \n            doLoadNextFile();\n        } catch (CmsException e) {\n            m_controller.setThrowable(e, m_cms.getRequestContext().getUri());\n            throw new JspException(e);\n        }\n\n        // check \"direct edit\" support\n        if (m_editable) {\n\n            // check options for first element\n            String directEditOptions;\n            if (m_directEditCreateLink != null) {\n                // if create link is not null, show \"edit\", \"delete\" and \"new\" button for first element\n                directEditOptions = CmsJspTagEditable.createEditOptions(true, true, true);\n                // show \"edit\" and \"delete\" button for 2nd to last element\n                m_directEditFollowOptions = CmsJspTagEditable.createEditOptions(true, true, false);\n            } else {\n                // if create link is null, show only \"edit\" button for first element\n                directEditOptions = CmsJspTagEditable.createEditOptions(true, false, false);\n                // also show only the \"edit\" button for 2nd to last element\n                m_directEditFollowOptions = directEditOptions;\n            }\n\n            m_directEditPermissions = CmsJspTagEditable.includeDirectEditElement(\n                pageContext,\n                I_CmsEditorActionHandler.C_DIRECT_EDIT_AREA_START,\n                m_resourceName,\n                null,\n                directEditOptions,\n                null,\n                m_directEditCreateLink);\n        }\n\n        return EVAL_BODY_INCLUDE;\n    }","commit_id":"2c76599546ac3ffb03ea9db265a3c8f623b7e3f7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, I_CmsJspTagContentContainer.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag <contentshow> without required parent tag found!\");\n        }\n        I_CmsJspTagContentContainer contentContainer = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        A_CmsXmlDocument xmlContent = contentContainer.getXmlDocument();\n        Locale locale = contentContainer.getXmlDocumentLocale();\n\n        String element = getElement();\n\n        if (CmsStringUtil.isEmpty(element)) {\n            element = contentContainer.getXmlDocumentElement();\n        } else {\n            element = CmsXmlUtils.concatXpath(contentContainer.getXmlDocumentElement(), element);\n        }\n\n        String content;\n        if (element.startsWith(I_CmsJspTagContentContainer.C_MAGIC_PREFIX)) {\n\n            // this is a \"magic\" element name, resolve it\n            content = contentContainer.resolveMagicName(element);\n        } else {\n\n            // now get the content element value to display\n            content = contentShowTagAction(xmlContent, element, locale, pageContext.getRequest());\n\n            // make sure that no null String is returned\n            if (content == null) {\n                content = CmsMessages.formatUnknownKey(element);\n            }\n        }\n\n        try {\n            pageContext.getOut().print(content);\n        } catch (IOException e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error in Jsp <contentshow> tag processing\", e);\n            }\n            throw new JspException(e);\n        }\n\n        return SKIP_BODY;\n    }","id":101738,"modified_method":"/**\n     * @see javax.servlet.jsp.tagext.Tag#doStartTag()\n     */\n    public int doStartTag() throws JspException {\n        \n        // initialize a string mapper to resolve EL like strings in tag attributes\n        CmsFlexController controller = (CmsFlexController)pageContext.getRequest().getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n        CmsObject cms = controller.getCmsObject();        \n        m_stringMapper = new CmsStringMapper(cms, pageContext);\n\n        // get a reference to the parent \"content container\" class\n        Tag ancestor = findAncestorWithClass(this, I_CmsJspTagContentContainer.class);\n        if (ancestor == null) {\n            throw new JspTagException(\"Tag <contentshow> without required parent tag found!\");\n        }\n        I_CmsJspTagContentContainer contentContainer = (I_CmsJspTagContentContainer)ancestor;\n\n        // get loaded content from parent <contentload> tag\n        A_CmsXmlDocument xmlContent = contentContainer.getXmlDocument();\n        Locale locale = contentContainer.getXmlDocumentLocale();\n \n        String element = getElement();\n\n        if (CmsStringUtil.isEmpty(element)) {\n            element = contentContainer.getXmlDocumentElement();\n        } else {\n            element = CmsXmlUtils.concatXpath(contentContainer.getXmlDocumentElement(), element);\n        }\n\n        String content;\n        if (element.startsWith(CmsStringUtil.C_MACRO_DELIMITER + CmsStringUtil.C_MACRO_START)\n            && element.endsWith(CmsStringUtil.C_MACRO_END)) {\n\n            // this is an EL like string\n            content = m_stringMapper.map(element, contentContainer);\n        } else {\n\n            // now get the content element value to display\n            content = contentShowTagAction(xmlContent, element, locale, pageContext.getRequest());\n\n            // make sure that no null String is returned\n            if (content == null) {\n                content = CmsMessages.formatUnknownKey(element);\n            }\n        }\n\n        try {\n            pageContext.getOut().print(content);\n        } catch (IOException e) {\n            if (OpenCms.getLog(this).isErrorEnabled()) {\n                OpenCms.getLog(this).error(\"Error in Jsp <contentshow> tag processing\", e);\n            }\n            throw new JspException(e);\n        }\n\n        return SKIP_BODY;\n    }","commit_id":"2c76599546ac3ffb03ea9db265a3c8f623b7e3f7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag = (SearchContainerRowTag)\n\t\t\tfindAncestorWithClass(this, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tSearchContainerTag parentSearchContainerTag =\n\t\t\t\t(SearchContainerTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerTag.class);\n\n\t\t\tSearchContainer searchContainer =\n\t\t\t\tparentSearchContainerTag.getSearchContainer();\n\n\t\t\tList<String> headerNames = searchContainer.getHeaderNames();\n\n\t\t\tString name = getName();\n\n\t\t\tif (Validator.isNull(name) && Validator.isNotNull(_property)) {\n\t\t\t\tname = _property;\n\t\t\t}\n\n\t\t\tif (headerNames == null) {\n\t\t\t\theaderNames = new ArrayList<String>();\n\n\t\t\t\tsearchContainer.setHeaderNames(headerNames);\n\t\t\t}\n\n\t\t\theaderNames.add(name);\n\n\t\t\tif (_orderable) {\n\t\t\t\tMap<String,String> orderableHeaders =\n\t\t\t\t\tsearchContainer.getOrderableHeaders();\n\n\t\t\t\tif (orderableHeaders == null) {\n\t\t\t\t\torderableHeaders = new LinkedHashMap<String, String>();\n\n\t\t\t\t\tsearchContainer.setOrderableHeaders(orderableHeaders);\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNotNull(_orderableProperty)) {\n\t\t\t\t\torderableHeaders.put(getName(), _orderableProperty);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(_property)) {\n\t\t\t\t\torderableHeaders.put(getName(), _property);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(_property)) {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\telse if (Validator.isNotNull(_buffer)) {\n\t\t\t_sb = new StringBuilder();\n\n\t\t\tpageContext.setAttribute(_buffer, _sb);\n\n\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t}\n\t\telse if (Validator.isNull(_value)) {\n\t\t\treturn EVAL_BODY_BUFFERED;\n\t\t}\n\t\telse {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t}","id":101739,"modified_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag = (SearchContainerRowTag)\n\t\t\tfindAncestorWithClass(this, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tSearchContainerTag parentSearchContainerTag =\n\t\t\t\t(SearchContainerTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerTag.class);\n\n\t\t\tSearchContainer searchContainer =\n\t\t\t\tparentSearchContainerTag.getSearchContainer();\n\n\t\t\tList<String> headerNames =\n\t\t\t\tparentSearchContainerTag.getHeaderNames();\n\n\t\t\tString name = getName();\n\n\t\t\tif (Validator.isNull(name) && Validator.isNotNull(_property)) {\n\t\t\t\tname = _property;\n\t\t\t}\n\n\t\t\tif (headerNames == null) {\n\t\t\t\theaderNames = new ArrayList<String>();\n\n\t\t\t\tparentSearchContainerTag.setHeaderNames(headerNames);\n\t\t\t\tsearchContainer.setHeaderNames(headerNames);\n\t\t\t}\n\n\t\t\theaderNames.add(name);\n\n\t\t\tif (_orderable) {\n\t\t\t\tMap<String,String> orderableHeaders =\n\t\t\t\t\tsearchContainer.getOrderableHeaders();\n\n\t\t\t\tif (orderableHeaders == null) {\n\t\t\t\t\torderableHeaders = new LinkedHashMap<String, String>();\n\n\t\t\t\t\tsearchContainer.setOrderableHeaders(orderableHeaders);\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNotNull(_orderableProperty)) {\n\t\t\t\t\torderableHeaders.put(getName(), _orderableProperty);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(_property)) {\n\t\t\t\t\torderableHeaders.put(getName(), _property);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(_property)) {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\telse if (Validator.isNotNull(_buffer)) {\n\t\t\t_sb = new StringBuilder();\n\n\t\t\tpageContext.setAttribute(_buffer, _sb);\n\n\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t}\n\t\telse if (Validator.isNull(_value)) {\n\t\t\treturn EVAL_BODY_BUFFERED;\n\t\t}\n\t\telse {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t}","commit_id":"a099a0447bd6e935824f7a45422ba0a8fa5aab1e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag parentTag =\n\t\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow row = parentTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = String.valueOf(\n\t\t\t\t\tBeanPropertiesUtil.getObject(row.getObject(), _property));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNotNull(_buffer)) {\n\t\t\t\t\t_value = _sb.toString();\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNull(_value)) {\n\t\t\t\t\t_value = getBodyContent().getString();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_index <= -1) {\n\t\t\t\t_index = row.getEntries().size();\n\t\t\t}\n\n\t\t\tif (row.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\trow.addText(\n\t\t\t\t_index,\n\t\t\t\tnew TextSearchEntry(\n\t\t\t\t\tgetAlign(), getValign(), getColspan(), getValue(),\n\t\t\t\t\t(String)getHref(), getTarget(), getTitle()));\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\t_align = SearchEntry.DEFAULT_ALIGN;\n\t\t\t_buffer = null;\n\t\t\t_colspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t_href = null;\n\t\t\t_index = -1;\n\t\t\t_name = null;\n\t\t\t_orderable = false;\n\t\t\t_orderableProperty = null;\n\t\t\t_property = null;\n\t\t\t_target = null;\n\t\t\t_title = null;\n\t\t\t_valign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t_value = null;\n\t\t}\n\t}","id":101740,"modified_method":"public int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag parentTag =\n\t\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow row = parentTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = String.valueOf(\n\t\t\t\t\tBeanPropertiesUtil.getObject(row.getObject(), _property));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNotNull(_buffer)) {\n\t\t\t\t\t_value = _sb.toString();\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNull(_value)) {\n\t\t\t\t\tBodyContent bc = getBodyContent();\n\n\t\t\t\t\tif (bc != null) {\n\t\t\t\t\t\t_value = bc.getString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_index <= -1) {\n\t\t\t\t_index = row.getEntries().size();\n\t\t\t}\n\n\t\t\tif (row.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\trow.addText(\n\t\t\t\t_index,\n\t\t\t\tnew TextSearchEntry(\n\t\t\t\t\tgetAlign(), getValign(), getColspan(), getValue(),\n\t\t\t\t\t(String)getHref(), getTarget(), getTitle()));\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\t_align = SearchEntry.DEFAULT_ALIGN;\n\t\t\t_buffer = null;\n\t\t\t_colspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t_href = null;\n\t\t\t_index = -1;\n\t\t\t_name = null;\n\t\t\t_orderable = false;\n\t\t\t_orderableProperty = null;\n\t\t\t_property = null;\n\t\t\t_target = null;\n\t\t\t_title = null;\n\t\t\t_valign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t_value = null;\n\t\t}\n\t}","commit_id":"a099a0447bd6e935824f7a45422ba0a8fa5aab1e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag =\n\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tSearchContainerTag parentSearchContainerTag =\n\t\t\t\t(SearchContainerTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerTag.class);\n\n\t\t\tSearchContainer searchContainer =\n\t\t\t\tparentSearchContainerTag.getSearchContainer();\n\n\t\t\tList<String> headerNames = searchContainer.getHeaderNames();\n\n\t\t\theaderNames.add(getName());\n\t\t}\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}","id":101741,"modified_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag =\n\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tList<String> headerNames = parentRowTag.getHeaderNames();\n\n\t\t\theaderNames.add(_name);\n\t\t}\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag =\n\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tSearchContainerTag parentSearchContainerTag =\n\t\t\t\t(SearchContainerTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerTag.class);\n\n\t\t\tSearchContainer searchContainer =\n\t\t\t\tparentSearchContainerTag.getSearchContainer();\n\n\t\t\tList<String> headerNames = searchContainer.getHeaderNames();\n\n\t\t\theaderNames.add(getName());\n\t\t}\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}","id":101742,"modified_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag =\n\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tList<String> headerNames = parentRowTag.getHeaderNames();\n\n\t\t\theaderNames.add(_name);\n\t\t}\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag =\n\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tSearchContainerTag parentSearchContainerTag =\n\t\t\t\t(SearchContainerTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerTag.class);\n\n\t\t\tSearchContainer searchContainer =\n\t\t\t\tparentSearchContainerTag.getSearchContainer();\n\n\t\t\tList<String> headerNames = searchContainer.getHeaderNames();\n\n\t\t\theaderNames.add(getName());\n\t\t}\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}","id":101743,"modified_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag =\n\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tList<String> headerNames = parentRowTag.getHeaderNames();\n\n\t\t\theaderNames.add(_name);\n\t\t}\n\n\t\treturn EVAL_BODY_INCLUDE;\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag = (SearchContainerRowTag)\n\t\t\tfindAncestorWithClass(this, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tSearchContainerTag parentSearchContainerTag =\n\t\t\t\t(SearchContainerTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerTag.class);\n\n\t\t\tSearchContainer searchContainer =\n\t\t\t\tparentSearchContainerTag.getSearchContainer();\n\n\t\t\tList<String> headerNames = searchContainer.getHeaderNames();\n\n\t\t\tString name = getName();\n\n\t\t\tif (Validator.isNull(name) && Validator.isNotNull(_property)) {\n\t\t\t\tname = _property;\n\t\t\t}\n\n\t\t\tif (headerNames == null) {\n\t\t\t\theaderNames = new ArrayList<String>();\n\n\t\t\t\tsearchContainer.setHeaderNames(headerNames);\n\t\t\t}\n\n\t\t\theaderNames.add(name);\n\n\t\t\tif (_orderable) {\n\t\t\t\tMap<String,String> orderableHeaders =\n\t\t\t\t\tsearchContainer.getOrderableHeaders();\n\n\t\t\t\tif (orderableHeaders == null) {\n\t\t\t\t\torderableHeaders = new LinkedHashMap<String, String>();\n\n\t\t\t\t\tsearchContainer.setOrderableHeaders(orderableHeaders);\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNotNull(_orderableProperty)) {\n\t\t\t\t\torderableHeaders.put(getName(), _orderableProperty);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(_property)) {\n\t\t\t\t\torderableHeaders.put(getName(), _property);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(_property)) {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\telse if (Validator.isNotNull(_buffer)) {\n\t\t\t_sb = new StringBuilder();\n\n\t\t\tpageContext.setAttribute(_buffer, _sb);\n\n\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t}\n\t\telse if (Validator.isNull(_value)) {\n\t\t\treturn EVAL_BODY_BUFFERED;\n\t\t}\n\t\telse {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t}","id":101744,"modified_method":"public int doStartTag() throws JspException {\n\t\tSearchContainerRowTag parentRowTag = (SearchContainerRowTag)\n\t\t\tfindAncestorWithClass(this, SearchContainerRowTag.class);\n\n\t\tif (parentRowTag == null) {\n\t\t\tthrow new JspTagException(\n\t\t\t\t\"Requires liferay-ui:search-container-row\");\n\t\t}\n\n\t\tif (!parentRowTag.isHeaderNamesAssigned()) {\n\t\t\tList<String> headerNames = parentRowTag.getHeaderNames();\n\n\t\t\tString name = getName();\n\n\t\t\tif (Validator.isNull(name) && Validator.isNotNull(_property)) {\n\t\t\t\tname = _property;\n\t\t\t}\n\n\t\t\theaderNames.add(name);\n\n\t\t\tif (_orderable) {\n\t\t\t\tMap<String,String> orderableHeaders =\n\t\t\t\t\tparentRowTag.getOrderableHeaders();\n\n\t\t\t\tif (Validator.isNotNull(_orderableProperty)) {\n\t\t\t\t\torderableHeaders.put(name, _orderableProperty);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(_property)) {\n\t\t\t\t\torderableHeaders.put(name, _property);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(name)) {\n\t\t\t\t\torderableHeaders.put(name, name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(_property)) {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t\telse if (Validator.isNotNull(_buffer)) {\n\t\t\t_sb = new StringBuilder();\n\n\t\t\tpageContext.setAttribute(_buffer, _sb);\n\n\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t}\n\t\telse if (Validator.isNull(_value)) {\n\t\t\treturn EVAL_BODY_BUFFERED;\n\t\t}\n\t\telse {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag parentTag =\n\t\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow row = parentTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = String.valueOf(\n\t\t\t\t\tBeanPropertiesUtil.getObject(row.getObject(), _property));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNotNull(_buffer)) {\n\t\t\t\t\t_value = _sb.toString();\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNull(_value)) {\n\t\t\t\t\t_value = getBodyContent().getString();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_index <= -1) {\n\t\t\t\t_index = row.getEntries().size();\n\t\t\t}\n\n\t\t\tif (row.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\trow.addText(\n\t\t\t\t_index,\n\t\t\t\tnew TextSearchEntry(\n\t\t\t\t\tgetAlign(), getValign(), getColspan(), getValue(),\n\t\t\t\t\t(String)getHref(), getTarget(), getTitle()));\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\t_align = SearchEntry.DEFAULT_ALIGN;\n\t\t\t_buffer = null;\n\t\t\t_colspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t_href = null;\n\t\t\t_index = -1;\n\t\t\t_name = null;\n\t\t\t_orderable = false;\n\t\t\t_orderableProperty = null;\n\t\t\t_property = null;\n\t\t\t_target = null;\n\t\t\t_title = null;\n\t\t\t_valign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t_value = null;\n\t\t}\n\t}","id":101745,"modified_method":"public int doEndTag() {\n\t\ttry {\n\t\t\tSearchContainerRowTag parentTag =\n\t\t\t\t(SearchContainerRowTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerRowTag.class);\n\n\t\t\tResultRow row = parentTag.getRow();\n\n\t\t\tif (Validator.isNotNull(_property)) {\n\t\t\t\t_value = String.valueOf(\n\t\t\t\t\tBeanPropertiesUtil.getObject(row.getObject(), _property));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Validator.isNotNull(_buffer)) {\n\t\t\t\t\t_value = _sb.toString();\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNull(_value)) {\n\t\t\t\t\tBodyContent bc = getBodyContent();\n\n\t\t\t\t\tif (bc != null) {\n\t\t\t\t\t\t_value = bc.getString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_index <= -1) {\n\t\t\t\t_index = row.getEntries().size();\n\t\t\t}\n\n\t\t\tif (row.isRestricted()) {\n\t\t\t\t_href = null;\n\t\t\t}\n\n\t\t\trow.addText(\n\t\t\t\t_index,\n\t\t\t\tnew TextSearchEntry(\n\t\t\t\t\tgetAlign(), getValign(), getColspan(), getValue(),\n\t\t\t\t\t(String)getHref(), getTarget(), getTitle()));\n\n\t\t\treturn EVAL_PAGE;\n\t\t}\n\t\tfinally {\n\t\t\t_align = SearchEntry.DEFAULT_ALIGN;\n\t\t\t_buffer = null;\n\t\t\t_colspan = SearchEntry.DEFAULT_COLSPAN;\n\t\t\t_href = null;\n\t\t\t_index = -1;\n\t\t\t_name = null;\n\t\t\t_orderable = false;\n\t\t\t_orderableProperty = null;\n\t\t\t_property = null;\n\t\t\t_target = null;\n\t\t\t_title = null;\n\t\t\t_valign = SearchEntry.DEFAULT_VALIGN;\n\t\t\t_value = null;\n\t\t}\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() {\n\t\t_bold = false;\n\t\t_className = null;\n\t\t_escapedModel = false;\n\t\t_headerNamesAssigned = false;\n\t\t_indexVar = DEFAULT_INDEX_VAR;\n\t\t_keyProperty = null;\n\t\t_modelVar = DEFAULT_MODEL_VAR;\n\t\t_resultRows = null;\n\t\t_rowIndex = 0;\n\t\t_rowVar = DEFAULT_ROW_VAR;\n\t\t_row = null;\n\t\t_stringKey = false;\n\n\t\treturn EVAL_PAGE;\n\t}","id":101746,"modified_method":"public int doEndTag() {\n\t\t_bold = false;\n\t\t_className = null;\n\t\t_escapedModel = false;\n\t\t_headerNamesAssigned = false;\n\t\t_headerNames = null;\n\t\t_indexVar = DEFAULT_INDEX_VAR;\n\t\t_keyProperty = null;\n\t\t_modelVar = DEFAULT_MODEL_VAR;\n\t\t_orderableHeaders = null;\n\t\t_resultRows = null;\n\t\t_rowIndex = 0;\n\t\t_rowVar = DEFAULT_ROW_VAR;\n\t\t_row = null;\n\t\t_stringKey = false;\n\n\t\treturn EVAL_PAGE;\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doAfterBody() throws JspException {\n\t\t_resultRows.add(_row);\n\n\t\t_headerNamesAssigned = true;\n\n\t\t_rowIndex++;\n\n\t\tif (_rowIndex < (_results.size())) {\n\t\t\tprocessRow();\n\n\t\t\treturn EVAL_BODY_AGAIN;\n\t\t}\n\t\telse {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t}","id":101747,"modified_method":"public int doAfterBody() throws JspException {\n\t\tif (!_headerNamesAssigned) {\n\t\t\tSearchContainerTag parentTag =\n\t\t\t\t(SearchContainerTag)findAncestorWithClass(\n\t\t\t\t\tthis, SearchContainerTag.class);\n\n\t\t\tparentTag.getSearchContainer().setHeaderNames(_headerNames);\n\t\t\tparentTag.getSearchContainer().setOrderableHeaders(\n\t\t\t\t_orderableHeaders);\n\n\t\t\t_headerNamesAssigned = true;\n\t\t}\n\n\t\t_resultRows.add(_row);\n\n\t\t_rowIndex++;\n\n\t\tif (_rowIndex < (_results.size())) {\n\t\t\tprocessRow();\n\n\t\t\treturn EVAL_BODY_AGAIN;\n\t\t}\n\t\telse {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addParam(String name, String value) {\n\t\tif (name.equals(\"className\")) {\n\t\t\t_row.setClassName(value);\n\t\t}\n\t\telse if (name.equals(\"classHoverName\")) {\n\t\t\t_row.setClassHoverName(value);\n\t\t}\n\t\telse if (name.equals(\"restricted\")) {\n\t\t\t_row.setRestricted(GetterUtil.getBoolean(value, false));\n\t\t}\n\t\telse {\n\t\t\t_row.setParameter(name, value);\n\t\t}\n\t}","id":101748,"modified_method":"public void addParam(String name, String value) {\n\t\tif (name.equals(\"className\")) {\n\t\t\t_row.setClassName(value);\n\t\t}\n\t\telse if (name.equals(\"classHoverName\")) {\n\t\t\t_row.setClassHoverName(value);\n\t\t}\n\t\telse if (name.equals(\"restricted\")) {\n\t\t\t_row.setRestricted(GetterUtil.getBoolean(value, false));\n\t\t}\n\t\telse {\n\t\t\tObject obj = pageContext.getAttribute(value);\n\n\t\t\tif (obj == null) {\n\t\t\t\tobj = value;\n\t\t\t}\n\n\t\t\t_row.setParameter(name, obj);\n\t\t}\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tHttpServletRequest request = getServletRequest();\n\n\t\t\tPortletRequest portletRequest =\n\t\t\t\t(PortletRequest)request.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_PORTLET_REQUEST);\n\t\t\tPortletResponse portletResponse =\n\t\t\t\t(PortletResponse)request.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_PORTLET_RESPONSE);\n\n\t\t\tif (_iteratorURL == null) {\n\t\t\t\t_iteratorURL =\n\t\t\t\t\t((RenderResponse)portletResponse).createRenderURL();\n\t\t\t}\n\n\t\t\tif (_searchContainer == null) {\n\t\t\t\t_searchContainer = new SearchContainer(\n\t\t\t\t\tportletRequest, _displayTerms, _searchTerms, getCurParam(),\n\t\t\t\t\tgetDelta(), _iteratorURL, _headerNames,\n\t\t\t\t\t_emptyResultsMessage);\n\t\t\t}\n\n\t\t\t_searchContainer.setHover(_hover);\n\n\t\t\tif (_orderableHeaders != null) {\n\t\t\t\t_searchContainer.setOrderableHeaders(_orderableHeaders);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(_orderByCol)) {\n\t\t\t\t_searchContainer.setOrderByCol(_orderByCol);\n\t\t\t}\n\n\t\t\tif (_orderByComparator != null) {\n\t\t\t\t_searchContainer.setOrderByComparator(_orderByComparator);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(_orderByType)) {\n\t\t\t\t_searchContainer.setOrderByType(_orderByType);\n\t\t\t}\n\n\t\t\tif (_rowChecker != null) {\n\t\t\t\t_searchContainer.setRowChecker(_rowChecker);\n\t\t\t}\n\n\t\t\tpageContext.setAttribute(getVar(), _searchContainer);\n\n\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t}","id":101749,"modified_method":"public int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tHttpServletRequest request = getServletRequest();\n\n\t\t\tPortletRequest portletRequest =\n\t\t\t\t(PortletRequest)request.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_PORTLET_REQUEST);\n\t\t\tPortletResponse portletResponse =\n\t\t\t\t(PortletResponse)request.getAttribute(\n\t\t\t\t\tJavaConstants.JAVAX_PORTLET_RESPONSE);\n\n\t\t\tif (_iteratorURL == null) {\n\t\t\t\t_iteratorURL =\n\t\t\t\t\t((RenderResponse)portletResponse).createRenderURL();\n\t\t\t}\n\n\t\t\tif (_searchContainer == null) {\n\t\t\t\t_searchContainer = new SearchContainer(\n\t\t\t\t\tportletRequest, _displayTerms, _searchTerms, getCurParam(),\n\t\t\t\t\tgetDelta(), _iteratorURL,  null, _emptyResultsMessage);\n\t\t\t}\n\n\t\t\t_searchContainer.setHover(_hover);\n\n\t\t\tif (Validator.isNotNull(_orderByCol)) {\n\t\t\t\t_searchContainer.setOrderByCol(_orderByCol);\n\t\t\t}\n\n\t\t\tif (_orderByComparator != null) {\n\t\t\t\t_searchContainer.setOrderByComparator(_orderByComparator);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(_orderByType)) {\n\t\t\t\t_searchContainer.setOrderByType(_orderByType);\n\t\t\t}\n\n\t\t\tif (_rowChecker != null) {\n\t\t\t\t_searchContainer.setRowChecker(_rowChecker);\n\t\t\t}\n\n\t\t\tpageContext.setAttribute(getVar(), _searchContainer);\n\n\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doEndTag() {\n\t\t_curParam = SearchContainer.DEFAULT_CUR_PARAM;\n\t\t_delta = SearchContainer.DEFAULT_DELTA;\n\t\t_displayTerms = null;\n\t\t_emptyResultsMessage = null;\n\t\t_hasResults = false;\n\t\t_headerNames = null;\n\t\t_hover = false;\n\t\t_iteratorURL = null;\n\t\t_orderableHeaders = null;\n\t\t_orderByCol = null;\n\t\t_orderByComparator = null;\n\t\t_orderByType = null;\n\t\t_rowChecker = null;\n\t\t_searchContainer = null;\n\t\t_searchTerms = null;\n\t\t_var = DEFAULT_VAR;\n\n\t\treturn EVAL_PAGE;\n\t}","id":101750,"modified_method":"public int doEndTag() {\n\t\t_curParam = SearchContainer.DEFAULT_CUR_PARAM;\n\t\t_delta = SearchContainer.DEFAULT_DELTA;\n\t\t_displayTerms = null;\n\t\t_emptyResultsMessage = null;\n\t\t_hasResults = false;\n\t\t_hover = false;\n\t\t_iteratorURL = null;\n\t\t_orderByCol = null;\n\t\t_orderByComparator = null;\n\t\t_orderByType = null;\n\t\t_rowChecker = null;\n\t\t_searchContainer = null;\n\t\t_searchTerms = null;\n\t\t_var = DEFAULT_VAR;\n\n\t\treturn EVAL_PAGE;\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:search:searchContainer\", _searchContainer);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:search:showAddButton\", String.valueOf(_showAddButton));\n\n\t\treturn EVAL_BODY_BUFFERED;\n\t}","id":101751,"modified_method":"public int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tSearchContainerTag parentTag = (SearchContainerTag)\n\t\t\tfindAncestorWithClass(this, SearchContainerTag.class);\n\n\t\tif (parentTag != null) {\n\t\t\t_searchContainer = parentTag.getSearchContainer();\n\t\t}\n\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:search:searchContainer\", _searchContainer);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:search:showAddButton\", String.valueOf(_showAddButton));\n\n\t\treturn EVAL_BODY_BUFFERED;\n\t}","commit_id":"f4d33d7c92eaa66d07b8d0fafb1a5cfff87b4fee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int doAfterBody(){\n\t\tif (Validator.isNotNull(getBodyContent())) {\n\t\t\t_body = getBodyContent().getString();\n\t\t}\n\n\t\treturn SKIP_BODY;\n\t}","id":101752,"modified_method":"public int doAfterBody(){\n\t\tBodyContent bodyContent = getBodyContent();\n\n\t\tif (bodyContent != null) {\n\t\t\t_body = bodyContent.getString();\n\t\t}\n\n\t\treturn SKIP_BODY;\n\t}","commit_id":"d41a661b4af0655a5dcce92338dd66fc3d138c1e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void markUnboxed(TypedDeclaration decl, TypeMirror type) {\n        if(type.isPrimitive() || type.getKind() == TypeKind.ARRAY\n                || sameType(type, BOOLEAN_TYPE)\n                || sameType(type, INTEGER_TYPE)\n                || sameType(type, LONG_TYPE)\n                || sameType(type, FLOAT_TYPE)\n                || sameType(type, DOUBLE_TYPE)\n                || sameType(type, CHARACTER_TYPE)\n                || sameType(type, STRING_TYPE)) {\n            Util.markUnBoxed(decl);\n        }\n    }","id":101753,"modified_method":"private void markUnboxed(TypedDeclaration decl, TypeMirror type) {\n        if(type.isPrimitive() \n                || type.getKind() == TypeKind.ARRAY\n                || sameType(type, STRING_TYPE)) {\n            Util.markUnBoxed(decl);\n        }\n    }","commit_id":"322d28afcf51f5bfae16f2fcd37fe63b1c954956","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private ProducedType obtainType(TypeMirror type, Scope scope) {\n        // ERASURE\n        if (sameType(type, STRING_TYPE)) {\n            type = CEYLON_STRING_TYPE;\n        } else if (sameType(type, PRIM_BOOLEAN_TYPE)) {\n            type = CEYLON_BOOLEAN_TYPE;\n        } else if (sameType(type, BOOLEAN_TYPE)) {\n            type = CEYLON_BOOLEAN_TYPE;\n        } else if (sameType(type, PRIM_INT_TYPE)) {\n            // FIXME Really needs \"small\" annotation\n            type = CEYLON_INTEGER_TYPE;\n        } else if (sameType(type, INTEGER_TYPE)) {\n            // FIXME Really needs \"small\" annotation\n            type = CEYLON_INTEGER_TYPE;\n        } else if (sameType(type, PRIM_LONG_TYPE)) {\n            type = CEYLON_INTEGER_TYPE;\n        } else if (sameType(type, LONG_TYPE)) {\n            type = CEYLON_INTEGER_TYPE;\n        } else if (sameType(type, PRIM_FLOAT_TYPE)) {\n            // FIXME Really needs \"small\" annotation\n            type = CEYLON_FLOAT_TYPE;\n        } else if (sameType(type, FLOAT_TYPE)) {\n            // FIXME Really needs \"small\" annotation\n            type = CEYLON_FLOAT_TYPE;\n        } else if (sameType(type, PRIM_DOUBLE_TYPE)) {\n            type = CEYLON_FLOAT_TYPE;\n        } else if (sameType(type, DOUBLE_TYPE)) {\n            type = CEYLON_FLOAT_TYPE;\n        } else if (sameType(type, PRIM_CHAR_TYPE)) {\n            type = CEYLON_CHARACTER_TYPE;\n        } else if (sameType(type, CHARACTER_TYPE)) {\n            type = CEYLON_CHARACTER_TYPE;\n        } else if (sameType(type, OBJECT_TYPE)) {\n            type = CEYLON_IDENTIFIABLE_OBJECT_TYPE;\n        }\n        \n        return getType(type, scope);\n    }","id":101754,"modified_method":"private ProducedType obtainType(TypeMirror type, Scope scope) {\n        // ERASURE\n        if (sameType(type, STRING_TYPE)) {\n            type = CEYLON_STRING_TYPE;\n        } else if (sameType(type, PRIM_BOOLEAN_TYPE)) {\n            type = CEYLON_BOOLEAN_TYPE;\n        } else if (sameType(type, PRIM_INT_TYPE)) {\n            // FIXME Really needs \"small\" annotation\n            type = CEYLON_INTEGER_TYPE;\n        } else if (sameType(type, PRIM_LONG_TYPE)) {\n            type = CEYLON_INTEGER_TYPE;\n        } else if (sameType(type, PRIM_FLOAT_TYPE)) {\n            // FIXME Really needs \"small\" annotation\n            type = CEYLON_FLOAT_TYPE;\n        } else if (sameType(type, PRIM_DOUBLE_TYPE)) {\n            type = CEYLON_FLOAT_TYPE;\n        } else if (sameType(type, PRIM_CHAR_TYPE)) {\n            type = CEYLON_CHARACTER_TYPE;\n        } else if (sameType(type, OBJECT_TYPE)) {\n            type = CEYLON_IDENTIFIABLE_OBJECT_TYPE;\n        }\n        \n        return getType(type, scope);\n    }","commit_id":"322d28afcf51f5bfae16f2fcd37fe63b1c954956","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected SQLQuery buildKaleoTaskInstanceTokenQuerySQL(\n\t\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery,\n\t\t\tboolean count, Session session)\n\t\tthrows Exception {\n\n\t\tString sql = null;\n\n\t\tif (count) {\n\t\t\tsql = CustomSQLUtil.get(COUNT_BY_C_KTAI);\n\t\t}\n\t\telse {\n\t\t\tsql = CustomSQLUtil.get(FIND_BY_C_KTAI);\n\t\t}\n\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getAssigneeClassName(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getAssigneeClassPK(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getCompleted(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getKaleoInstanceId(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getRoleIds(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getSearchByUserRoles(kaleoTaskInstanceTokenQuery));\n\n\t\tif (appendSearchCriteria(kaleoTaskInstanceTokenQuery)) {\n\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \" AND (\");\n\n\t\t\tif ((kaleoTaskInstanceTokenQuery.getAssetPrimaryKeys() != null) ||\n\t\t\t\t(kaleoTaskInstanceTokenQuery.getAssetType() != null)) {\n\n\t\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \" (\");\n\t\t\t}\n\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql, getAssetPrimaryKey(kaleoTaskInstanceTokenQuery));\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetAssetType(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\t(kaleoTaskInstanceTokenQuery.getAssetPrimaryKeys() ==\n\t\t\t\t\t\tnull)));\n\n\t\t\tif ((kaleoTaskInstanceTokenQuery.getAssetPrimaryKeys() != null) ||\n\t\t\t\t(kaleoTaskInstanceTokenQuery.getAssetType() != null)) {\n\n\t\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \") \");\n\t\t\t}\n\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetDueDateGT(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\t(kaleoTaskInstanceTokenQuery.getAssetPrimaryKeys() ==\n\t\t\t\t\t\tnull) &&\n\t\t\t\t\t(kaleoTaskInstanceTokenQuery.getAssetType() == null)));\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetDueDateLT(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\t((kaleoTaskInstanceTokenQuery.getAssetPrimaryKeys() ==\n\t\t\t\t\t\tnull) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getAssetType() == null) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getDueDateGT() == null))));\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetTaskName(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\t((kaleoTaskInstanceTokenQuery.getAssetPrimaryKeys() ==\n\t\t\t\t\t\tnull) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getAssetType() == null) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getDueDateGT() == null) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getDueDateLT() == null))));\n\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \")\");\n\n\t\t\tsql = CustomSQLUtil.replaceAndOperator(\n\t\t\t\tsql, kaleoTaskInstanceTokenQuery.isAndOperator());\n\t\t}\n\n\t\tif (kaleoTaskInstanceTokenQuery.getOrderByComparator() != null) {\n\t\t\tStringBundler sb = new StringBundler(sql);\n\n\t\t\tappendOrderByComparator(\n\t\t\t\tsb, _ORDER_BY_ENTITY_ALIAS,\n\t\t\t\tkaleoTaskInstanceTokenQuery.getOrderByComparator());\n\n\t\t\tsql = sb.toString();\n\t\t}\n\n\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\tif (count) {\n\t\t\tq.addScalar(COUNT_COLUMN_NAME, Type.LONG);\n\t\t}\n\t\telse {\n\t\t\tq.addScalar(\"KaleoTaskInstanceTokenId\", Type.LONG);\n\t\t}\n\n\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\tqPos.add(kaleoTaskInstanceTokenQuery.getCompanyId());\n\n\t\tsetAssigneeClassName(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetAssigneeClassPK(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetCompleted(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetKaleoInstanceId(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetRoleIds(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetSearchByUserRoles(qPos, kaleoTaskInstanceTokenQuery);\n\n\t\tsetAssetPrimaryKey(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetAssetType(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetDueDateGT(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetDueDateLT(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetTaskName(qPos, kaleoTaskInstanceTokenQuery);\n\n\t\treturn q;\n\t}","id":101755,"modified_method":"protected SQLQuery buildKaleoTaskInstanceTokenQuerySQL(\n\t\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery,\n\t\t\tboolean count, Session session)\n\t\tthrows Exception {\n\n\t\tString sql = null;\n\n\t\tif (count) {\n\t\t\tsql = CustomSQLUtil.get(COUNT_BY_C_KTAI);\n\t\t}\n\t\telse {\n\t\t\tsql = CustomSQLUtil.get(FIND_BY_C_KTAI);\n\t\t}\n\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getAssigneeClassName(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getAssigneeClassPK(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getCompleted(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getKaleoInstanceId(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getRoleIds(kaleoTaskInstanceTokenQuery));\n\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\tsql, getSearchByUserRoles(kaleoTaskInstanceTokenQuery));\n\n\t\tif (appendSearchCriteria(kaleoTaskInstanceTokenQuery)) {\n\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \" AND (\");\n\n\t\t\tif (Validator.isNotNull(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys()) ||\n\t\t\t\t(Validator.isNotNull(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetType()))) {\n\n\t\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \" (\");\n\t\t\t}\n\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql, getAssetPrimaryKey(kaleoTaskInstanceTokenQuery));\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetAssetType(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\tValidator.isNull(\n\t\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys())));\n\n\t\t\tif (Validator.isNotNull(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys()) ||\n\t\t\t\t(Validator.isNotNull(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetType()))) {\n\n\t\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \") \");\n\t\t\t}\n\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetDueDateGT(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\t(Validator.isNull(\n\t\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys()) &&\n\t\t\t\t\t (Validator.isNull(\n\t\t\t\t\t\t kaleoTaskInstanceTokenQuery.getAssetType())))));\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetDueDateLT(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\t(Validator.isNull(\n\t\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys()) &&\n\t\t\t\t\t (Validator.isNull(\n\t\t\t\t\t\t kaleoTaskInstanceTokenQuery.getAssetType())) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getDueDateGT() == null))));\n\t\t\tsql = CustomSQLUtil.appendCriteria(\n\t\t\t\tsql,\n\t\t\t\tgetTaskName(\n\t\t\t\t\tkaleoTaskInstanceTokenQuery,\n\t\t\t\t\t(Validator.isNull(\n\t\t\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys()) &&\n\t\t\t\t\t (Validator.isNull(\n\t\t\t\t\t\t kaleoTaskInstanceTokenQuery.getAssetType())) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getDueDateGT() == null) &&\n\t\t\t\t\t (kaleoTaskInstanceTokenQuery.getDueDateLT() == null))));\n\t\t\tsql = CustomSQLUtil.appendCriteria(sql, \")\");\n\n\t\t\tsql = CustomSQLUtil.replaceAndOperator(\n\t\t\t\tsql, kaleoTaskInstanceTokenQuery.isAndOperator());\n\t\t}\n\n\t\tif (kaleoTaskInstanceTokenQuery.getOrderByComparator() != null) {\n\t\t\tStringBundler sb = new StringBundler(sql);\n\n\t\t\tappendOrderByComparator(\n\t\t\t\tsb, _ORDER_BY_ENTITY_ALIAS,\n\t\t\t\tkaleoTaskInstanceTokenQuery.getOrderByComparator());\n\n\t\t\tsql = sb.toString();\n\t\t}\n\n\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\tif (count) {\n\t\t\tq.addScalar(COUNT_COLUMN_NAME, Type.LONG);\n\t\t}\n\t\telse {\n\t\t\tq.addScalar(\"KaleoTaskInstanceTokenId\", Type.LONG);\n\t\t}\n\n\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\tqPos.add(kaleoTaskInstanceTokenQuery.getCompanyId());\n\n\t\tsetAssigneeClassName(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetAssigneeClassPK(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetCompleted(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetKaleoInstanceId(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetRoleIds(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetSearchByUserRoles(qPos, kaleoTaskInstanceTokenQuery);\n\n\t\tsetAssetPrimaryKey(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetAssetType(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetDueDateGT(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetDueDateLT(qPos, kaleoTaskInstanceTokenQuery);\n\t\tsetTaskName(qPos, kaleoTaskInstanceTokenQuery);\n\n\t\treturn q;\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected boolean appendSearchCriteria(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tif (kaleoTaskInstanceTokenQuery.getAssetPrimaryKeys() != null) {\n\t\t\treturn true;\n\t\t}\n\n \t\tif (Validator.isNotNull(kaleoTaskInstanceTokenQuery.getAssetType())) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (kaleoTaskInstanceTokenQuery.getDueDateGT() != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (kaleoTaskInstanceTokenQuery.getDueDateLT() != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (Validator.isNotNull(kaleoTaskInstanceTokenQuery.getTaskName())) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":101756,"modified_method":"protected boolean appendSearchCriteria(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tif (Validator.isNotNull(\n\t\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys())) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (Validator.isNotNull(kaleoTaskInstanceTokenQuery.getAssetType())) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (kaleoTaskInstanceTokenQuery.getDueDateGT() != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (kaleoTaskInstanceTokenQuery.getDueDateLT() != null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (Validator.isNotNull(kaleoTaskInstanceTokenQuery.getTaskName())) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setTaskName(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString taskName = kaleoTaskInstanceTokenQuery.getTaskName();\n\n\t\tif (taskName == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] taskNames = CustomSQLUtil.keywords(taskName, false);\n\n\t\tqPos.add(taskNames);\n\t}","id":101757,"modified_method":"protected void setTaskName(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString taskName = kaleoTaskInstanceTokenQuery.getTaskName();\n\n\t\tif (Validator.isNull(taskName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] taskNames = CustomSQLUtil.keywords(taskName, false);\n\n\t\tqPos.add(taskNames);\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getAssigneeClassName(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString assigneeClassName =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssigneeClassName();\n\n\t\tif (assigneeClassName == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\treturn \"AND (KaleoTaskAssignmentInstance.assigneeClassName = ?)\";\n\t}","id":101758,"modified_method":"protected String getAssigneeClassName(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString assigneeClassName =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssigneeClassName();\n\n\t\tif (Validator.isNull(assigneeClassName)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\treturn \"AND (KaleoTaskAssignmentInstance.assigneeClassName = ?)\";\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getAssetType(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery,\n\t\tboolean firstCriteria) {\n\n\t\tString assetType = kaleoTaskInstanceTokenQuery.getAssetType();\n\n\t\tif (assetType == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString[] assetTypes = CustomSQLUtil.keywords(assetType, false);\n\n\t\tif ((assetTypes == null) || (assetTypes.length == 0)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(assetTypes.length * 2 + 1);\n\n\t\tif (!firstCriteria) {\n\t\t\tsb.append(\" AND (\");\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"(\");\n\t\t}\n\n\t\tfor (int i = 0; i < assetTypes.length; i++) {\n\t\t\tsb.append(\"(KaleoTaskInstanceToken.className LIKE ?)\");\n\n\t\t\tif ((i + 1) < assetTypes.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":101759,"modified_method":"protected String getAssetType(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery,\n\t\tboolean firstCriteria) {\n\n\t\tString assetType = kaleoTaskInstanceTokenQuery.getAssetType();\n\n\t\tif (Validator.isNull(assetType)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString[] assetTypes = CustomSQLUtil.keywords(assetType, false);\n\n\t\tif (Validator.isNull(assetTypes)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(assetTypes.length * 2 + 1);\n\n\t\tif (!firstCriteria) {\n\t\t\tsb.append(\" AND (\");\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"(\");\n\t\t}\n\n\t\tfor (int i = 0; i < assetTypes.length; i++) {\n\t\t\tsb.append(\"(KaleoTaskInstanceToken.className LIKE ?)\");\n\n\t\t\tif ((i + 1) < assetTypes.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getAssetPrimaryKey(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tLong[] assetPrimaryKeys =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys();\n\n\t\tif (assetPrimaryKeys == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(assetPrimaryKeys.length * 2 + 1);\n\n\t\tsb.append(\"(\");\n\n\t\tfor (int i = 0; i < assetPrimaryKeys.length; i++) {\n\t\t\tsb.append(\"(KaleoTaskInstanceToken.classPK = ?)\");\n\n\t\t\tif ((i + 1) < assetPrimaryKeys.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":101760,"modified_method":"protected String getAssetPrimaryKey(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tLong[] assetPrimaryKeys =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys();\n\n\t\tif (Validator.isNull(assetPrimaryKeys)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(assetPrimaryKeys.length * 2 + 1);\n\n\t\tsb.append(\"(\");\n\n\t\tfor (int i = 0; i < assetPrimaryKeys.length; i++) {\n\t\t\tsb.append(\"(KaleoTaskInstanceToken.classPK = ?)\");\n\n\t\t\tif ((i + 1) < assetPrimaryKeys.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getTaskName(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery,\n\t\tboolean firstCriteria) {\n\n\t\tString taskName = kaleoTaskInstanceTokenQuery.getTaskName();\n\n\t\tif (taskName == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString[] taskNames = CustomSQLUtil.keywords(taskName, false);\n\n\t\tif ((taskNames == null) || (taskNames.length == 0)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(taskNames.length * 2 + 1);\n\n\t\tif (!firstCriteria) {\n\t\t\tsb.append(\"[$AND_OR_CONNECTOR$] (\");\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"(\");\n\t\t}\n\n\t\tfor (int i = 0; i < taskNames.length; i++) {\n\t\t\tsb.append(\"(KaleoTaskInstanceToken.kaleoTaskName LIKE ?)\");\n\n\t\t\tif ((i + 1) < taskNames.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":101761,"modified_method":"protected String getTaskName(\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery,\n\t\tboolean firstCriteria) {\n\n\t\tString taskName = kaleoTaskInstanceTokenQuery.getTaskName();\n\n\t\tif (Validator.isNull(taskName)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString[] taskNames = CustomSQLUtil.keywords(taskName, false);\n\n\t\tif (Validator.isNull(taskNames)) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(taskNames.length * 2 + 1);\n\n\t\tif (!firstCriteria) {\n\t\t\tsb.append(\"[$AND_OR_CONNECTOR$] (\");\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"(\");\n\t\t}\n\n\t\tfor (int i = 0; i < taskNames.length; i++) {\n\t\t\tsb.append(\"(KaleoTaskInstanceToken.kaleoTaskName LIKE ?)\");\n\n\t\t\tif ((i + 1) < taskNames.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setAssigneeClassName(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString assigneeClassName =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssigneeClassName();\n\n\t\tif (assigneeClassName == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tqPos.add(assigneeClassName);\n\t}","id":101762,"modified_method":"protected void setAssigneeClassName(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString assigneeClassName =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssigneeClassName();\n\n\t\tif (Validator.isNull(assigneeClassName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tqPos.add(assigneeClassName);\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setAssetType(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString assetType = kaleoTaskInstanceTokenQuery.getAssetType();\n\n\t\tif (assetType == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] assetTypes = CustomSQLUtil.keywords(assetType, false);\n\n\t\tqPos.add(assetTypes);\n\t}","id":101763,"modified_method":"protected void setAssetType(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tString assetType = kaleoTaskInstanceTokenQuery.getAssetType();\n\n\t\tif (Validator.isNull(assetType)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] assetTypes = CustomSQLUtil.keywords(assetType, false);\n\n\t\tqPos.add(assetTypes);\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void setAssetPrimaryKey(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tLong[] assetPrimaryKeys =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys();\n\n\t\tif (assetPrimaryKeys  == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tqPos.add(assetPrimaryKeys);\n\t}","id":101764,"modified_method":"protected void setAssetPrimaryKey(\n\t\tQueryPos qPos,\n\t\tKaleoTaskInstanceTokenQuery kaleoTaskInstanceTokenQuery) {\n\n\t\tLong[] assetPriamryKey =\n\t\t\tkaleoTaskInstanceTokenQuery.getAssetPrimaryKeys();\n\n\t\tif (Validator.isNull(assetPriamryKey)) {\n\t\t\treturn;\n\t\t}\n\n\t\tqPos.add(assetPriamryKey);\n\t}","commit_id":"39fe76003427e4a5311e76fbd84b6c9c42cb2648","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Nullable\n  public static List<HighlightInfo> checkMethodCall(PsiMethodCallExpression methodCall, PsiResolveHelper resolveHelper) {\n    final List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n\n    PsiExpressionList list = methodCall.getArgumentList();\n    PsiReferenceExpression referenceToMethod = methodCall.getMethodExpression();\n    JavaResolveResult resolveResult = referenceToMethod.advancedResolve(true);\n    PsiElement element = resolveResult.getElement();\n\n    final CandidateInfo[] candidates = resolveHelper.getReferencedMethodCandidates(methodCall, true);\n    \n    boolean isDummy = false;\n    boolean isThisOrSuper = referenceToMethod.getReferenceNameElement() instanceof PsiKeyword;\n    if (isThisOrSuper) {\n      // super(..) or this(..)\n      if (list.getExpressions().length == 0) { // implicit ctr call\n        if (candidates.length == 1 && !candidates[0].getElement().isPhysical()) {\n          isDummy = true;// dummy constructor\n        }\n      }\n    }\n    if (isDummy) return null;\n    HighlightInfo highlightInfo;\n\n    if (element instanceof PsiMethod && resolveResult.isValidResult()) {\n      TextRange fixRange = getFixRange(methodCall);\n      highlightInfo = HighlightUtil.checkUnhandledExceptions(methodCall, fixRange);\n\n      if (highlightInfo == null) {\n        highlightInfo = GenericsHighlightUtil.checkUncheckedCall(resolveResult, methodCall);\n      }\n      if (highlightInfo == null) {\n        highlightInfo = GenericsHighlightUtil.checkGenericCallWithRawArguments(resolveResult, methodCall);\n      }\n    }\n    else {\n      PsiMethod resolvedMethod = null;\n      MethodCandidateInfo candidateInfo = null;\n      if (resolveResult instanceof MethodCandidateInfo) {\n        candidateInfo = (MethodCandidateInfo)resolveResult;\n        resolvedMethod = candidateInfo.getElement();\n      }\n\n      ChangeStringLiteralToCharInMethodCallFix.createHighLighting(candidates, methodCall, result);\n\n      if (!resolveResult.isAccessible() || !resolveResult.isStaticsScopeCorrect()) {\n        highlightInfo = checkAmbiguousMethodCall(referenceToMethod, list, element, resolveResult, methodCall, resolveHelper);\n      }\n      else if (candidateInfo != null && !candidateInfo.isApplicable()) {\n        if (candidateInfo.isTypeArgumentsApplicable()) {\n          String methodName = HighlightMessageUtil.getSymbolName(element, resolveResult.getSubstitutor());\n          PsiElement parent = element.getParent();\n          String containerName = parent == null ? \"\" : HighlightMessageUtil.getSymbolName(parent, resolveResult.getSubstitutor());\n          String argTypes = buildArgTypesList(list);\n          String description = JavaErrorMessages.message(\"wrong.method.arguments\", methodName, containerName, argTypes);\n          String toolTip = parent instanceof PsiClass ?\n                           createMismatchedArgumentsHtmlTooltip(candidateInfo, list) : description;\n          highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description, toolTip);\n          registerMethodCallIntentions(highlightInfo, methodCall, list, resolveHelper);\n          highlightInfo.navigationShift = +1;\n        }\n        else {\n          PsiReferenceExpression methodExpression = methodCall.getMethodExpression();\n          PsiReferenceParameterList typeArgumentList = methodCall.getTypeArgumentList();\n          if (typeArgumentList.getTypeArguments().length == 0 && resolvedMethod.getTypeParameters().length > 0) {\n            highlightInfo = GenericsHighlightUtil.checkInferredTypeArguments(resolvedMethod, methodCall, resolveResult.getSubstitutor());\n          }\n          else {\n            highlightInfo = GenericsHighlightUtil.checkParameterizedReferenceTypeArguments(element, methodExpression,\n                                                                                           resolveResult.getSubstitutor());\n          }\n        }\n      }\n      else {\n        highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, methodCall, JavaErrorMessages.message(\"method.call.expected\"));\n        if (element instanceof PsiClass) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new InsertNewFix(methodCall, (PsiClass)element));\n        }\n        else {\n          TextRange range = getFixRange(methodCall);\n          QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateMethodFromUsageFix(methodCall), null);\n          QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreatePropertyFromUsageFix(methodCall), null);\n        }\n      }\n    }\n    if (highlightInfo == null) {\n      highlightInfo =\n      GenericsHighlightUtil.checkParameterizedReferenceTypeArguments(element, referenceToMethod, resolveResult.getSubstitutor());\n    }\n    result.add(highlightInfo);\n    return result;\n  }","id":101765,"modified_method":"@Nullable\n  public static List<HighlightInfo> checkMethodCall(PsiMethodCallExpression methodCall, PsiResolveHelper resolveHelper) {\n    final List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n\n    PsiExpressionList list = methodCall.getArgumentList();\n    PsiReferenceExpression referenceToMethod = methodCall.getMethodExpression();\n    JavaResolveResult resolveResult = referenceToMethod.advancedResolve(true);\n    PsiElement element = resolveResult.getElement();\n\n    final CandidateInfo[] candidates = resolveHelper.getReferencedMethodCandidates(methodCall, true);\n    \n    boolean isDummy = false;\n    boolean isThisOrSuper = referenceToMethod.getReferenceNameElement() instanceof PsiKeyword;\n    if (isThisOrSuper) {\n      // super(..) or this(..)\n      if (list.getExpressions().length == 0) { // implicit ctr call\n        if (candidates.length == 1 && !candidates[0].getElement().isPhysical()) {\n          isDummy = true;// dummy constructor\n        }\n      }\n    }\n    if (isDummy) return null;\n    HighlightInfo highlightInfo;\n\n    if (element instanceof PsiMethod && resolveResult.isValidResult()) {\n      TextRange fixRange = getFixRange(methodCall);\n      highlightInfo = HighlightUtil.checkUnhandledExceptions(methodCall, fixRange);\n\n      if (highlightInfo == null) {\n        highlightInfo = GenericsHighlightUtil.checkUncheckedCall(resolveResult, methodCall);\n      }\n      if (highlightInfo == null) {\n        highlightInfo = GenericsHighlightUtil.checkGenericCallWithRawArguments(resolveResult, methodCall);\n      }\n    }\n    else {\n      PsiMethod resolvedMethod = null;\n      MethodCandidateInfo candidateInfo = null;\n      if (resolveResult instanceof MethodCandidateInfo) {\n        candidateInfo = (MethodCandidateInfo)resolveResult;\n        resolvedMethod = candidateInfo.getElement();\n      }\n\n      ChangeStringLiteralToCharInMethodCallFix.createHighLighting(candidates, methodCall, result);\n\n      if (!resolveResult.isAccessible() || !resolveResult.isStaticsScopeCorrect()) {\n        highlightInfo = checkAmbiguousMethodCall(referenceToMethod, list, element, resolveResult, methodCall, resolveHelper);\n      }\n      else if (candidateInfo != null && !candidateInfo.isApplicable()) {\n        if (candidateInfo.isTypeArgumentsApplicable()) {\n          String methodName = HighlightMessageUtil.getSymbolName(element, resolveResult.getSubstitutor());\n          PsiElement parent = element.getParent();\n          String containerName = parent == null ? \"\" : HighlightMessageUtil.getSymbolName(parent, resolveResult.getSubstitutor());\n          String argTypes = buildArgTypesList(list);\n          String description = JavaErrorMessages.message(\"wrong.method.arguments\", methodName, containerName, argTypes);\n          String toolTip = parent instanceof PsiClass ?\n                           createMismatchedArgumentsHtmlTooltip(candidateInfo, list) : description;\n          highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, list, description, toolTip);\n          registerMethodCallIntentions(highlightInfo, methodCall, list, resolveHelper);\n          highlightInfo.navigationShift = +1;\n        }\n        else {\n          PsiReferenceExpression methodExpression = methodCall.getMethodExpression();\n          PsiReferenceParameterList typeArgumentList = methodCall.getTypeArgumentList();\n          if (typeArgumentList.getTypeArguments().length == 0 && resolvedMethod.hasTypeParameters()) {\n            highlightInfo = GenericsHighlightUtil.checkInferredTypeArguments(resolvedMethod, methodCall, resolveResult.getSubstitutor());\n          }\n          else {\n            highlightInfo = GenericsHighlightUtil.checkParameterizedReferenceTypeArguments(element, methodExpression,\n                                                                                           resolveResult.getSubstitutor());\n          }\n        }\n      }\n      else {\n        highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, methodCall, JavaErrorMessages.message(\"method.call.expected\"));\n        if (element instanceof PsiClass) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new InsertNewFix(methodCall, (PsiClass)element));\n        }\n        else {\n          TextRange range = getFixRange(methodCall);\n          QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreateMethodFromUsageFix(methodCall), null);\n          QuickFixAction.registerQuickFixAction(highlightInfo, range, new CreatePropertyFromUsageFix(methodCall), null);\n        }\n      }\n    }\n    if (highlightInfo == null) {\n      highlightInfo =\n      GenericsHighlightUtil.checkParameterizedReferenceTypeArguments(element, referenceToMethod, resolveResult.getSubstitutor());\n    }\n    result.add(highlightInfo);\n    return result;\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static HighlightInfo isWeaker(final PsiMethod method, final PsiModifierList modifierList, final String accessModifier, final int accessLevel,\n                                        final PsiMethod superMethod,\n                                        final boolean includeRealPositionInfo) {\n    int superAccessLevel = PsiUtil.getAccessLevel(superMethod.getModifierList());\n    if (accessLevel < superAccessLevel) {\n      String message = MessageFormat.format(JavaErrorMessages.message(\"weaker.privileges\"),\n                                            createClashMethodMessage(method, superMethod, true),\n                                            accessModifier,\n                                            PsiUtil.getAccessModifier(superAccessLevel));\n      TextRange textRange;\n      if (includeRealPositionInfo) {\n        if (modifierList.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) {\n          textRange = method.getNameIdentifier().getTextRange();\n        }\n        else {\n          PsiElement keyword = PsiUtil.findModifierInList(modifierList, accessModifier);\n          textRange = keyword.getTextRange();\n        }\n      }\n      else {\n        textRange = new TextRange(0, 0);\n      }\n      HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, textRange, message);\n      IntentionAction fix = QUICK_FIX_FACTORY.createModifierListFix(method, PsiUtil.getAccessModifier(superAccessLevel), true, false);\n      QuickFixAction.registerQuickFixAction(highlightInfo, fix);\n      return highlightInfo;\n    }\n    return null;\n  }","id":101766,"modified_method":"private static HighlightInfo isWeaker(final PsiMethod method, final PsiModifierList modifierList, final String accessModifier, final int accessLevel,\n                                        final PsiMethod superMethod,\n                                        final boolean includeRealPositionInfo) {\n    int superAccessLevel = PsiUtil.getAccessLevel(superMethod.getModifierList());\n    if (accessLevel < superAccessLevel) {\n      String message = JavaErrorMessages.message(\"weaker.privileges\",\n                                            createClashMethodMessage(method, superMethod, true),\n                                            accessModifier,\n                                            PsiUtil.getAccessModifier(superAccessLevel));\n      TextRange textRange;\n      if (includeRealPositionInfo) {\n        if (modifierList.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) {\n          textRange = method.getNameIdentifier().getTextRange();\n        }\n        else {\n          PsiElement keyword = PsiUtil.findModifierInList(modifierList, accessModifier);\n          textRange = keyword.getTextRange();\n        }\n      }\n      else {\n        textRange = new TextRange(0, 0);\n      }\n      HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR, textRange, message);\n      IntentionAction fix = QUICK_FIX_FACTORY.createModifierListFix(method, PsiUtil.getAccessModifier(superAccessLevel), true, false);\n      QuickFixAction.registerQuickFixAction(highlightInfo, fix);\n      return highlightInfo;\n    }\n    return null;\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSerializationRelatedMethod(PsiMethod method) {\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null || method.isConstructor()) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    @NonNls String name = method.getName();\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    PsiType returnType = method.getReturnType();\n    if (\"readObjectNoData\".equals(name)) {\n      return parameters.length == 0 && TypeConversionUtil.isVoidType(returnType) && HighlightUtil.isSerializable(aClass);\n    }\n    if (\"readObject\".equals(name)) {\n      return parameters.length == 1\n             && parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")\n             && TypeConversionUtil.isVoidType(returnType) && method.hasModifierProperty(PsiModifier.PRIVATE)\n             && HighlightUtil.isSerializable(aClass);\n    }\n    if (\"readResolve\".equals(name)) {\n      return parameters.length == 0\n             && returnType != null\n             && returnType.equalsToText(\"java.lang.Object\")\n             && HighlightUtil.isSerializable(aClass);\n    }\n    if (\"writeReplace\".equals(name)) {\n      return parameters.length == 0\n             && returnType != null\n             && returnType.equalsToText(\"java.lang.Object\")\n             && HighlightUtil.isSerializable(aClass);\n    }\n    if (\"writeObject\".equals(name)) {\n      return parameters.length == 1\n             && TypeConversionUtil.isVoidType(returnType)\n             && parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")\n             && method.hasModifierProperty(PsiModifier.PRIVATE)\n             && HighlightUtil.isSerializable(aClass);\n    }\n    return false;\n  }","id":101767,"modified_method":"public static boolean isSerializationRelatedMethod(PsiMethod method, PsiClass containingClass) {\n    if (containingClass == null || method.isConstructor()) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    @NonNls String name = method.getName();\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    PsiType returnType = method.getReturnType();\n    if (\"readObjectNoData\".equals(name)) {\n      return parameters.length == 0 && TypeConversionUtil.isVoidType(returnType) && HighlightUtil.isSerializable(containingClass);\n    }\n    if (\"readObject\".equals(name)) {\n      return parameters.length == 1\n             && parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")\n             && TypeConversionUtil.isVoidType(returnType) && method.hasModifierProperty(PsiModifier.PRIVATE)\n             && HighlightUtil.isSerializable(containingClass);\n    }\n    if (\"readResolve\".equals(name)) {\n      return parameters.length == 0\n             && returnType != null\n             && returnType.equalsToText(\"java.lang.Object\")\n             && HighlightUtil.isSerializable(containingClass);\n    }\n    if (\"writeReplace\".equals(name)) {\n      return parameters.length == 0\n             && returnType != null\n             && returnType.equalsToText(\"java.lang.Object\")\n             && HighlightUtil.isSerializable(containingClass);\n    }\n    if (\"writeObject\".equals(name)) {\n      return parameters.length == 1\n             && TypeConversionUtil.isVoidType(returnType)\n             && parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")\n             && method.hasModifierProperty(PsiModifier.PRIVATE)\n             && HighlightUtil.isSerializable(containingClass);\n    }\n    return false;\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private HighlightInfo processClass(PsiClass aClass) {\n    if (!isClassUnused(aClass)) return null;\n    if (aClass.getContainingClass() != null && aClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n      String pattern = aClass.isInterface()\n                       ? \"private.inner.interface.is.not.used\"\n                       : \"private.inner.class.is.not.used\";\n      return formatUnusedSymbolHighlightInfo(pattern, aClass);\n    }\n    else if (aClass.getParent() instanceof PsiDeclarationStatement) { // local class\n      return formatUnusedSymbolHighlightInfo(\"local.class.is.not.used\", aClass);\n    }\n    else if (aClass instanceof PsiTypeParameter) {\n      return formatUnusedSymbolHighlightInfo(\"type.parameter.is.not.used\", aClass);\n    }\n    else {\n      return formatUnusedSymbolHighlightInfo(\"class.is.not.used\", aClass);\n    }\n  }","id":101768,"modified_method":"@Nullable\n  private HighlightInfo processClass(PsiClass aClass) {\n    if (!isClassUnused(aClass)) return null;\n    if (aClass.getContainingClass() != null && aClass.hasModifierProperty(PsiModifier.PRIVATE)) {\n      String pattern = aClass.isInterface()\n                       ? \"private.inner.interface.is.not.used\"\n                       : \"private.inner.class.is.not.used\";\n      return formatUnusedSymbolHighlightInfo(pattern, aClass);\n    }\n    if (aClass.getParent() instanceof PsiDeclarationStatement) { // local class\n      return formatUnusedSymbolHighlightInfo(\"local.class.is.not.used\", aClass);\n    }\n    if (aClass instanceof PsiTypeParameter) {\n      return formatUnusedSymbolHighlightInfo(\"type.parameter.is.not.used\", aClass);\n    }\n    return formatUnusedSymbolHighlightInfo(\"class.is.not.used\", aClass);\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private HighlightInfo processMethod(final PsiMethod method) {\n    if (myRefCountHolder.isReferenced(method)) return null;\n    boolean isPrivate = method.hasModifierProperty(PsiModifier.PRIVATE);\n\n    if (!isPrivate) {\n      //class maybe used in some weird way, e.g. from XML, therefore the only constructor is used too\n      PsiClass containingClass = method.getContainingClass();\n      if (containingClass != null && method.isConstructor() && containingClass.getConstructors().length == 1 && !isClassUnused(containingClass)) return null;\n      \n      if (!method.getHierarchicalMethodSignature().getSuperSignatures().isEmpty() || !weAreSureThereAreNoUsages(method)) {\n        return null;\n      }\n    }\n    if (HighlightMethodUtil.isSerializationRelatedMethod(method) ||\n        isIntentionalPrivateConstructor(method) ||\n        isImplicitUsage(method)) {\n      return null;\n    }\n    String key = isPrivate\n                 ? method.isConstructor() ? \"private.constructor.is.not.used\" : \"private.method.is.not.used\"\n                 : method.isConstructor() ? \"constructor.is.not.used\" : \"method.is.not.used\";\n    String symbolName = HighlightMessageUtil.getSymbolName(method, PsiSubstitutor.EMPTY);\n    String message = JavaErrorMessages.message(key, symbolName);\n    PsiIdentifier identifier = method.getNameIdentifier();\n    final HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n    QuickFixAction.registerQuickFixAction(highlightInfo, new SafeDeleteFix(method), myUnusedSymbolKey);\n    if (PropertyUtil.isSimplePropertySetter(method)) {\n      SpecialAnnotationsUtil.createAddToSpecialAnnotationFixes(method, new Processor<String>() {\n        public boolean process(final String annoName) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, myUnusedSymbolInspection.createQuickFix(annoName, method));\n          return true;\n        }\n      });\n    }\n    return highlightInfo;\n  }","id":101769,"modified_method":"@Nullable\n  private HighlightInfo processMethod(final PsiMethod method) {\n    if (myRefCountHolder.isReferenced(method)) return null;\n    boolean isPrivate = method.hasModifierProperty(PsiModifier.PRIVATE);\n    PsiClass containingClass = method.getContainingClass();\n    if (isPrivate) {\n      if (HighlightMethodUtil.isSerializationRelatedMethod(method, containingClass) ||\n          isIntentionalPrivateConstructor(method, containingClass)) {\n        return null;\n      }\n      if (isImplicitUsage(method)) {\n        return null;\n      }\n    }\n    else {\n      //class maybe used in some weird way, e.g. from XML, therefore the only constructor is used too\n      if (containingClass != null && method.isConstructor() && containingClass.getConstructors().length == 1 && !isClassUnused(containingClass)) return null;\n      if (isImplicitUsage(method)) return null;\n\n      if (!method.getHierarchicalMethodSignature().getSuperSignatures().isEmpty() || !weAreSureThereAreNoUsages(method)) {\n        return null;\n      }\n    }\n    String key = isPrivate\n                 ? method.isConstructor() ? \"private.constructor.is.not.used\" : \"private.method.is.not.used\"\n                 : method.isConstructor() ? \"constructor.is.not.used\" : \"method.is.not.used\";\n    String symbolName = HighlightMessageUtil.getSymbolName(method, PsiSubstitutor.EMPTY);\n    String message = JavaErrorMessages.message(key, symbolName);\n    PsiIdentifier identifier = method.getNameIdentifier();\n    final HighlightInfo highlightInfo = createUnusedSymbolInfo(identifier, message);\n    QuickFixAction.registerQuickFixAction(highlightInfo, new SafeDeleteFix(method), myUnusedSymbolKey);\n    if (PropertyUtil.isSimplePropertySetter(method)) {\n      SpecialAnnotationsUtil.createAddToSpecialAnnotationFixes(method, new Processor<String>() {\n        public boolean process(final String annoName) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, myUnusedSymbolInspection.createQuickFix(annoName, method));\n          return true;\n        }\n      });\n    }\n    return highlightInfo;\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private HighlightInfo processParameter(PsiParameter parameter) {\n    PsiElement declarationScope = parameter.getDeclarationScope();\n    if (declarationScope instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)declarationScope;\n      if (PsiUtilBase.hasErrorElementChild(method)) return null;\n      if ((method.isConstructor() ||\n           method.hasModifierProperty(PsiModifier.PRIVATE) ||\n           method.hasModifierProperty(PsiModifier.STATIC) ||\n           !method.hasModifierProperty(PsiModifier.ABSTRACT) &&\n           myUnusedSymbolInspection.REPORT_PARAMETER_FOR_PUBLIC_METHODS &&\n           !isOverriddenOrOverrides(method)) &&\n          !method.hasModifierProperty(PsiModifier.NATIVE) &&\n          !HighlightMethodUtil.isSerializationRelatedMethod(method) &&\n          !isMainMethod(method)) {\n        HighlightInfo highlightInfo = checkUnusedParameter(parameter);\n        if (highlightInfo != null) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedParameterFix(parameter), myUnusedSymbolKey);\n          return highlightInfo;\n        }\n      }\n    }\n    else if (declarationScope instanceof PsiForeachStatement) {\n      HighlightInfo highlightInfo = checkUnusedParameter(parameter);\n      if (highlightInfo != null) {\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(UnusedSymbolLocalInspection.DISPLAY_NAME), myUnusedSymbolKey);\n        return highlightInfo;\n      }\n    }\n\n    return null;\n  }","id":101770,"modified_method":"@Nullable\n  private HighlightInfo processParameter(PsiParameter parameter) {\n    PsiElement declarationScope = parameter.getDeclarationScope();\n    if (declarationScope instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)declarationScope;\n      if (PsiUtilBase.hasErrorElementChild(method)) return null;\n      if ((method.isConstructor() ||\n           method.hasModifierProperty(PsiModifier.PRIVATE) ||\n           method.hasModifierProperty(PsiModifier.STATIC) ||\n           !method.hasModifierProperty(PsiModifier.ABSTRACT) &&\n           myUnusedSymbolInspection.REPORT_PARAMETER_FOR_PUBLIC_METHODS &&\n           !isOverriddenOrOverrides(method)) &&\n          !method.hasModifierProperty(PsiModifier.NATIVE) &&\n          !HighlightMethodUtil.isSerializationRelatedMethod(method, method.getContainingClass()) &&\n          !isMainMethod(method)) {\n        HighlightInfo highlightInfo = checkUnusedParameter(parameter);\n        if (highlightInfo != null) {\n          QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveUnusedParameterFix(parameter), myUnusedSymbolKey);\n          return highlightInfo;\n        }\n      }\n    }\n    else if (declarationScope instanceof PsiForeachStatement) {\n      HighlightInfo highlightInfo = checkUnusedParameter(parameter);\n      if (highlightInfo != null) {\n        QuickFixAction.registerQuickFixAction(highlightInfo, new EmptyIntentionAction(UnusedSymbolLocalInspection.DISPLAY_NAME), myUnusedSymbolKey);\n        return highlightInfo;\n      }\n    }\n\n    return null;\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean weAreSureThereAreNoUsages(PsiMember member) {\n    if (!myDeadCodeEnabled) return false;\n    if (myDeadCodeInspection.isEntryPoint(member)) return false;\n\n    String name = member.getName();\n    if (name == null) return false;\n    SearchScope useScope = member.getUseScope();\n    if (!(useScope instanceof GlobalSearchScope)) return false;\n    final int[] count = {0};\n    GlobalSearchScope scope = (GlobalSearchScope)useScope;\n    // some classes may have references from within XML outside dependent modules, e.g. our actions\n    if (member instanceof PsiClass) scope = scope.uniteWith(GlobalSearchScope.projectScope(myProject));\n\n    CacheManager cacheManager = ((PsiManagerEx)myFile.getManager()).getCacheManager();\n    if (!cacheManager.processFilesWithWord(new Processor<PsiFile>() {\n      public boolean process(PsiFile file) {\n        if (file == myFile) return true;\n        count[0]++;\n        return count[0] <= 10;\n      }\n    }, name, UsageSearchContext.ANY, scope, true)) return false;\n\n    //search usages if it cheap\n    //if count is 0 there is no usages since we've called myRefCountHolder.isReferenced() before\n    return count[0] == 0 || ReferencesSearch.search(member, scope, true).findFirst() == null;\n  }","id":101771,"modified_method":"private boolean weAreSureThereAreNoUsages(PsiMember member) {\n    if (!myDeadCodeEnabled) return false;\n    if (myDeadCodeInspection.isEntryPoint(member)) return false;\n\n    String name = member.getName();\n    if (name == null) return false;\n    SearchScope useScope = member.getUseScope();\n    if (!(useScope instanceof GlobalSearchScope)) return false;\n    final int[] count = {0};\n    GlobalSearchScope scope = (GlobalSearchScope)useScope;\n    // some classes may have references from within XML outside dependent modules, e.g. our actions\n    if (member instanceof PsiClass) scope = scope.uniteWith(GlobalSearchScope.projectScope(myProject));\n\n    CacheManager cacheManager = ((PsiManagerEx)myFile.getManager()).getCacheManager();\n    if (!cacheManager.processFilesWithWord(new Processor<PsiFile>() {\n      public boolean process(PsiFile file) {\n        if (file == myFile) return true;\n        count[0]++;\n        return count[0] <= 10;\n      }\n    }, name, UsageSearchContext.ANY, scope, true)) return false;\n\n    //search usages if it cheap\n    //if count is 0 there is no usages since we've called myRefCountHolder.isReferenced() before\n    if (count[0] == 0) return true;\n\n    Query<PsiReference> query = member instanceof PsiMethod\n                                ? MethodReferencesSearch.search((PsiMethod)member, scope, false)\n                                : ReferencesSearch.search(member, scope, true);\n    return query.findFirst() == null;\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isIntentionalPrivateConstructor(PsiMethod method) {\n    if (!method.isConstructor()) return false;\n    if (!method.hasModifierProperty(PsiModifier.PRIVATE)) return false;\n    if (method.getParameterList().getParametersCount() > 0) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass != null && aClass.getConstructors().length == 1;\n  }","id":101772,"modified_method":"private static boolean isIntentionalPrivateConstructor(PsiMethod method, PsiClass containingClass) {\n    return method.isConstructor() &&\n           method.getParameterList().getParametersCount() == 0 &&\n           containingClass != null &&\n           containingClass.getConstructors().length == 1;\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ProblemDescriptor checkExceptionsNeverThrown(PsiJavaCodeReferenceElement referenceElement, InspectionManager inspectionManager) {\n    if (!(referenceElement.getParent() instanceof PsiReferenceList)) return null;\n    PsiReferenceList referenceList = (PsiReferenceList)referenceElement.getParent();\n    if (!(referenceList.getParent() instanceof PsiMethod)) return null;\n    PsiMethod method = (PsiMethod)referenceList.getParent();\n    if (referenceList != method.getThrowsList()) return null;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null) return null;\n\n    PsiManager manager = referenceElement.getManager();\n    PsiClassType exceptionType = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createType(referenceElement);\n    if (ExceptionUtil.isUncheckedExceptionOrSuperclass(exceptionType)) return null;\n\n    PsiCodeBlock body = method.getBody();\n    if (body == null) return null;\n\n    PsiModifierList modifierList = method.getModifierList();\n    PsiClass containingClass = method.getContainingClass();\n    if (!modifierList.hasModifierProperty(PsiModifier.PRIVATE)\n        && !modifierList.hasModifierProperty(PsiModifier.STATIC)\n        && !modifierList.hasModifierProperty(PsiModifier.FINAL)\n        && !method.isConstructor()\n        && !(containingClass instanceof PsiAnonymousClass)\n        && !(containingClass != null && containingClass.hasModifierProperty(PsiModifier.FINAL))) {\n      return null;\n    }\n\n    Collection<PsiClassType> types = ExceptionUtil.collectUnhandledExceptions(body, method);\n    Collection<PsiClassType> unhandled = new HashSet<PsiClassType>(types);\n    if (method.isConstructor()) {\n      // there may be field initializer throwing exception\n      // that exception must be caught in the constructor\n      PsiField[] fields = aClass.getFields();\n      for (final PsiField field : fields) {\n        if (field.hasModifierProperty(PsiModifier.STATIC)) continue;\n        PsiExpression initializer = field.getInitializer();\n        if (initializer == null) continue;\n        unhandled.addAll(ExceptionUtil.collectUnhandledExceptions(initializer, field));\n      }\n    }\n\n    for (PsiClassType unhandledException : unhandled) {\n      if (unhandledException.isAssignableFrom(exceptionType) ||\n          exceptionType.isAssignableFrom(unhandledException)) {\n        return null;\n      }\n    }\n\n    if (HighlightMethodUtil.isSerializationRelatedMethod(method)) return null;\n\n    String description = JavaErrorMessages.message(\"exception.is.never.thrown\", HighlightUtil.formatType(exceptionType));\n\n    final LocalQuickFix quickFixes = new DeleteThrowsFix(method, exceptionType);\n    return inspectionManager.createProblemDescriptor(referenceElement, description, quickFixes, ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n  }","id":101773,"modified_method":"private static ProblemDescriptor checkExceptionsNeverThrown(PsiJavaCodeReferenceElement referenceElement, InspectionManager inspectionManager) {\n    if (!(referenceElement.getParent() instanceof PsiReferenceList)) return null;\n    PsiReferenceList referenceList = (PsiReferenceList)referenceElement.getParent();\n    if (!(referenceList.getParent() instanceof PsiMethod)) return null;\n    PsiMethod method = (PsiMethod)referenceList.getParent();\n    if (referenceList != method.getThrowsList()) return null;\n    PsiClass containingClass = method.getContainingClass();\n    if (containingClass == null) return null;\n\n    PsiManager manager = referenceElement.getManager();\n    PsiClassType exceptionType = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createType(referenceElement);\n    if (ExceptionUtil.isUncheckedExceptionOrSuperclass(exceptionType)) return null;\n\n    PsiCodeBlock body = method.getBody();\n    if (body == null) return null;\n\n    PsiModifierList modifierList = method.getModifierList();\n    if (!modifierList.hasModifierProperty(PsiModifier.PRIVATE)\n        && !modifierList.hasModifierProperty(PsiModifier.STATIC)\n        && !modifierList.hasModifierProperty(PsiModifier.FINAL)\n        && !method.isConstructor()\n        && !(containingClass instanceof PsiAnonymousClass)\n        && !containingClass.hasModifierProperty(PsiModifier.FINAL)) {\n      return null;\n    }\n\n    Collection<PsiClassType> types = ExceptionUtil.collectUnhandledExceptions(body, method);\n    Collection<PsiClassType> unhandled = new HashSet<PsiClassType>(types);\n    if (method.isConstructor()) {\n      // there may be field initializer throwing exception\n      // that exception must be caught in the constructor\n      PsiField[] fields = containingClass.getFields();\n      for (final PsiField field : fields) {\n        if (field.hasModifierProperty(PsiModifier.STATIC)) continue;\n        PsiExpression initializer = field.getInitializer();\n        if (initializer == null) continue;\n        unhandled.addAll(ExceptionUtil.collectUnhandledExceptions(initializer, field));\n      }\n    }\n\n    for (PsiClassType unhandledException : unhandled) {\n      if (unhandledException.isAssignableFrom(exceptionType) ||\n          exceptionType.isAssignableFrom(unhandledException)) {\n        return null;\n      }\n    }\n\n    if (HighlightMethodUtil.isSerializationRelatedMethod(method, containingClass)) return null;\n\n    String description = JavaErrorMessages.message(\"exception.is.never.thrown\", HighlightUtil.formatType(exceptionType));\n\n    final LocalQuickFix quickFixes = new DeleteThrowsFix(method, exceptionType);\n    return inspectionManager.createProblemDescriptor(referenceElement, description, quickFixes, ProblemHighlightType.LIKE_UNUSED_SYMBOL);\n  }","commit_id":"43faaa9d1201b832c3e541cf9964bfda43e91260","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(final Element element) throws InvalidDataException {\n    if (myProject.isDefault()) {\n      return; // TODO[max]: hack to enforce default project always has LangLevel == 1.5. This is necessary until StubUpdatingIndex\n      // is able to determine correct language level for stub parsing.\n    }\n\n    final boolean assertKeyword = Boolean.valueOf(element.getAttributeValue(ASSERT_KEYWORD_ATTR)).booleanValue();\n    final boolean jdk15 = Boolean.valueOf(element.getAttributeValue(JDK_15_ATTR)).booleanValue();\n    if (jdk15) {\n      myLanguageLevel = LanguageLevel.JDK_1_5;\n    }\n    else if (assertKeyword) {\n      myLanguageLevel = LanguageLevel.JDK_1_4;\n    }\n    else {\n      myLanguageLevel = LanguageLevel.JDK_1_3;\n    }\n    myOriginalLanguageLevel = myLanguageLevel;\n  }","id":101774,"modified_method":"private void readExternal(final Element element) {\n    if (myProject.isDefault()) {\n      return; // TODO[max]: hack to enforce default project always has LangLevel == 1.5. This is necessary until StubUpdatingIndex\n      // is able to determine correct language level for stub parsing.\n    }\n\n    final boolean assertKeyword = Boolean.valueOf(element.getAttributeValue(ASSERT_KEYWORD_ATTR)).booleanValue();\n    final boolean jdk15 = Boolean.valueOf(element.getAttributeValue(JDK_15_ATTR)).booleanValue();\n    if (jdk15) {\n      myLanguageLevel = LanguageLevel.JDK_1_5;\n    }\n    else if (assertKeyword) {\n      myLanguageLevel = LanguageLevel.JDK_1_4;\n    }\n    else {\n      myLanguageLevel = LanguageLevel.JDK_1_3;\n    }\n    myOriginalLanguageLevel = myLanguageLevel;\n  }","commit_id":"4459e0163cfdf9355a121da4c4b2020c321dd760","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(final Element element) throws WriteExternalException {\n    final boolean is14 = LanguageLevel.JDK_1_4.equals(myLanguageLevel);\n    final boolean is15 = LanguageLevel.JDK_1_5.equals(myLanguageLevel);\n    element.setAttribute(ASSERT_KEYWORD_ATTR, Boolean.toString(is14 || is15));\n    element.setAttribute(JDK_15_ATTR, Boolean.toString(is15));\n  }","id":101775,"modified_method":"private void writeExternal(final Element element) {\n    final boolean is14 = LanguageLevel.JDK_1_4.equals(myLanguageLevel);\n    final boolean is15 = LanguageLevel.JDK_1_5.equals(myLanguageLevel);\n    element.setAttribute(ASSERT_KEYWORD_ATTR, Boolean.toString(is14 || is15));\n    element.setAttribute(JDK_15_ATTR, Boolean.toString(is15));\n  }","commit_id":"4459e0163cfdf9355a121da4c4b2020c321dd760","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType fun(final PsiExpression call) {\n      PsiReferenceExpression methodExpression = ((PsiMethodCallExpression)call).getMethodExpression();\n      final JavaResolveResult result = methodExpression.advancedResolve(false);\n      final PsiMethod method = (PsiMethod)result.getElement();\n      if (method == null) return null;\n      PsiManager manager = call.getManager();\n\n      final LanguageLevel languageLevel = PsiUtil.getLanguageLevel(call);\n      if (languageLevel.compareTo(LanguageLevel.JDK_1_5) >= 0) {\n        //JLS3 15.8.2\n        if (GET_CLASS_METHOD.equals(method.getName()) && \"java.lang.Object\".equals(method.getContainingClass().getQualifiedName())) {\n          PsiExpression qualifier = methodExpression.getQualifierExpression();\n          PsiType qualifierType = null;\n          if (qualifier != null) {\n            qualifierType = TypeConversionUtil.erasure(qualifier.getType());\n          }\n          else {\n            ASTNode parent = call.getNode().getTreeParent();\n            while (parent != null && parent.getElementType() != CLASS) parent = parent.getTreeParent();\n            if (parent != null) {\n              qualifierType = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createType((PsiClass)parent.getPsi());\n            }\n          }\n          if (qualifierType != null) {\n            PsiClass javaLangClass = JavaPsiFacade.getInstance(manager.getProject()).findClass(\"java.lang.Class\", call.getResolveScope());\n            if (javaLangClass != null && javaLangClass.getTypeParameters().length == 1) {\n              Map<PsiTypeParameter, PsiType> map = new HashMap<PsiTypeParameter, PsiType>();\n              map.put(javaLangClass.getTypeParameters()[0], PsiWildcardType.createExtends(manager, qualifierType));\n              PsiSubstitutor substitutor = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createSubstitutor(map);\n              return JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createType(javaLangClass, substitutor, languageLevel);\n            }\n          }\n        }\n      }\n\n      PsiType ret = method.getReturnType();\n      if (ret == null) return null;\n      if (ret instanceof PsiClassType) {\n        ret = ((PsiClassType)ret).setLanguageLevel(languageLevel);\n      }\n      if (languageLevel.compareTo(LanguageLevel.JDK_1_5) >= 0) {\n        final PsiSubstitutor substitutor = result.getSubstitutor();\n        if (PsiUtil.isRawSubstitutor(method, substitutor)) return TypeConversionUtil.erasure(ret);\n        PsiType substitutedReturnType = substitutor.substitute(ret);\n        return PsiImplUtil.normalizeWildcardTypeByPosition(substitutedReturnType, call);\n      }\n      return TypeConversionUtil.erasure(ret);\n    }","id":101776,"modified_method":"public PsiType fun(final PsiExpression call) {\n      PsiReferenceExpression methodExpression = ((PsiMethodCallExpression)call).getMethodExpression();\n      final JavaResolveResult result = methodExpression.advancedResolve(false);\n      final PsiMethod method = (PsiMethod)result.getElement();\n      if (method == null) return null;\n      PsiManager manager = call.getManager();\n\n      final LanguageLevel languageLevel = PsiUtil.getLanguageLevel(call);\n      boolean is15OrHigher = languageLevel.compareTo(LanguageLevel.JDK_1_5) >= 0;\n      if (is15OrHigher) {\n        //JLS3 15.8.2\n        if (GET_CLASS_METHOD.equals(method.getName()) && \"java.lang.Object\".equals(method.getContainingClass().getQualifiedName())) {\n          PsiExpression qualifier = methodExpression.getQualifierExpression();\n          PsiType qualifierType = null;\n          if (qualifier != null) {\n            qualifierType = TypeConversionUtil.erasure(qualifier.getType());\n          }\n          else {\n            ASTNode parent = call.getNode().getTreeParent();\n            while (parent != null && parent.getElementType() != CLASS) parent = parent.getTreeParent();\n            if (parent != null) {\n              qualifierType = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createType((PsiClass)parent.getPsi());\n            }\n          }\n          if (qualifierType != null) {\n            PsiClass javaLangClass = JavaPsiFacade.getInstance(manager.getProject()).findClass(\"java.lang.Class\", call.getResolveScope());\n            if (javaLangClass != null && javaLangClass.getTypeParameters().length == 1) {\n              Map<PsiTypeParameter, PsiType> map = new HashMap<PsiTypeParameter, PsiType>();\n              map.put(javaLangClass.getTypeParameters()[0], PsiWildcardType.createExtends(manager, qualifierType));\n              PsiSubstitutor substitutor = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createSubstitutor(map);\n              return JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createType(javaLangClass, substitutor, languageLevel);\n            }\n          }\n        }\n      }\n\n      PsiType ret = method.getReturnType();\n      if (ret == null) return null;\n      if (ret instanceof PsiClassType) {\n        ret = ((PsiClassType)ret).setLanguageLevel(languageLevel);\n      }\n      if (is15OrHigher) {\n        final PsiSubstitutor substitutor = result.getSubstitutor();\n        if (PsiUtil.isRawSubstitutor(method, substitutor)) return TypeConversionUtil.erasure(ret);\n        PsiType substitutedReturnType = substitutor.substitute(ret);\n        return PsiImplUtil.normalizeWildcardTypeByPosition(substitutedReturnType, call);\n      }\n      return TypeConversionUtil.erasure(ret);\n    }","commit_id":"4459e0163cfdf9355a121da4c4b2020c321dd760","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isAccessibleFromPackage(@NotNull PsiModifierListOwner element, @NotNull PsiPackage aPackage) {\n    if (element.hasModifierProperty(PsiModifier.PUBLIC)) return true;\n    if (element.hasModifierProperty(PsiModifier.PRIVATE)) return false;\n    return JavaPsiFacade.getInstance(element.getProject()).isInPackage(element, aPackage);\n  }","id":101777,"modified_method":"public static boolean isAccessibleFromPackage(@NotNull PsiModifierListOwner element, @NotNull PsiPackage aPackage) {\n    if (element.hasModifierProperty(PsiModifier.PUBLIC)) return true;\n    return !element.hasModifierProperty(PsiModifier.PRIVATE) &&\n           JavaPsiFacade.getInstance(element.getProject()).isInPackage(element, aPackage);\n  }","commit_id":"4459e0163cfdf9355a121da4c4b2020c321dd760","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static LanguageLevel getLanguageLevel(@NotNull PsiElement element) {\n    if (element instanceof PsiDirectory) return JavaDirectoryService.getInstance().getLanguageLevel((PsiDirectory)element);\n    final PsiFile file = element.getContainingFile();\n    if (file == null) {\n      return LanguageLevelProjectExtension.getInstance(element.getProject()).getLanguageLevel();\n    }\n\n    if (!(file instanceof PsiJavaFile)) {\n      final PsiElement context = file.getContext();\n      if (context != null) return getLanguageLevel(context);\n      return LanguageLevelProjectExtension.getInstance(element.getProject()).getLanguageLevel();\n    }\n    return ((PsiJavaFile)file).getLanguageLevel();\n  }","id":101778,"modified_method":"@NotNull\n  public static LanguageLevel getLanguageLevel(@NotNull PsiElement element) {\n    if (element instanceof PsiDirectory) return JavaDirectoryService.getInstance().getLanguageLevel((PsiDirectory)element);\n    final PsiFile file = element.getContainingFile();\n    if (file == null) {\n      return LanguageLevelProjectExtension.getInstance(element.getProject()).getLanguageLevel();\n    }\n\n    if (!(file instanceof PsiJavaFile)) {\n      final PsiElement context = file.getContext();\n      if (context != null) return getLanguageLevel(context);\n      return LanguageLevelProjectExtension.getInstance(file.getProject()).getLanguageLevel();\n    }\n    return ((PsiJavaFile)file).getLanguageLevel();\n  }","commit_id":"4459e0163cfdf9355a121da4c4b2020c321dd760","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean canBeOverriden(PsiMethod method) {\n    PsiClass parentClass = method.getContainingClass();\n    if (parentClass == null) return false;\n    if (method.isConstructor()) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    if (method.hasModifierProperty(PsiModifier.FINAL)) return false;\n    if (method.hasModifierProperty(PsiModifier.PRIVATE)) return false;\n    if (parentClass instanceof PsiAnonymousClass) return false;\n    return !parentClass.hasModifierProperty(PsiModifier.FINAL);\n  }","id":101779,"modified_method":"public static boolean canBeOverriden(PsiMethod method) {\n    PsiClass parentClass = method.getContainingClass();\n    return parentClass != null &&\n           !method.isConstructor() &&\n           !method.hasModifierProperty(PsiModifier.STATIC) &&\n           !method.hasModifierProperty(PsiModifier.FINAL) &&\n           !method.hasModifierProperty(PsiModifier.PRIVATE) &&\n           !(parentClass instanceof PsiAnonymousClass) &&\n           !parentClass.hasModifierProperty(PsiModifier.FINAL);\n  }","commit_id":"4459e0163cfdf9355a121da4c4b2020c321dd760","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n         public void sawOpcode(int seen) {\n\n\t\tswitch (seen) {\n\t\tcase LDC:\n\t\t\tconstantOnTOS = true;\n\t\t\t// stringOnTop = stringConstant;\n\t\t\treturn;\n\t\tcase INVOKEVIRTUAL:\n\t\t\tif (getRefConstantOperand().equals(\"java.lang.String.intern : ()Ljava.lang.String;\")\n\t\t\t        || getRefConstantOperand().equals(\"java.lang.String.equals : (Ljava.lang.Object;)Z\"))\n\t\t\t\tcallToInternSeen = true;\n\t\t\tbreak;\n\t\tcase IF_ACMPEQ:\n\t\tcase IF_ACMPNE:\n\t\t\tif (constantOnTOS && !callToInternSeen)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"ES_COMPARING_STRINGS_WITH_EQ\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t        .addClass(\"java.lang.String\").describe(\"CLASS_REFTYPE\")\n\t\t\t\t        .addSourceLine(this, getPC()));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tconstantOnTOS = false;\n\t}","id":101780,"modified_method":"@Override\n         public void sawOpcode(int seen) {\n\n\t\tswitch (seen) {\n\t\tcase LDC:\n\t\t\tconstantOnTOS = true;\n\t\t\t// stringOnTop = stringConstant;\n\t\t\treturn;\n\t\tcase INVOKEVIRTUAL:\n\t\t\tif (getRefConstantOperand().equals(\"java.lang.String.intern : ()Ljava.lang.String;\")\n\t\t\t        || getRefConstantOperand().equals(\"java.lang.String.equals : (Ljava.lang.Object;)Z\"))\n\t\t\t\tcallToInternSeen = true;\n\t\t\tbreak;\n\t\tcase IF_ACMPEQ:\n\t\tcase IF_ACMPNE:\n\t\t\tif (constantOnTOS && !callToInternSeen)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"ES_COMPARING_STRINGS_WITH_EQ\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t        .addType(\"Ljava/lang/String;\")\n\t\t\t\t        .addSourceLine(this, getPC()));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tconstantOnTOS = false;\n\t}","commit_id":"4fce7aa43d01453e61d610ede304af0d8d1021c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tif (isSynthetic(method) || !prescreen(classContext, method))\n\t\t\treturn;\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\t\n\t\t\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t\tSet<ValueNumber> paramValueNumberSet = null;\n\t\t\n\t\tValueNumberDataflow vnaDataflow = null;\n\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t+ methodGen.getName();\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tSet<SourceLineAnnotation> haveInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveCast = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleCast = new HashSet<SourceLineAnnotation>();\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\tif (ins instanceof CHECKCAST) {\n\t\t\t\tif (!haveCast.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleCast.add(sourceLineAnnotation);\n\t\t\t} else {\n\t\t\t\tif (!haveInstanceOf.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleInstanceOf.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tint pc = handle.getPosition();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\t\t\tif (handle.getNext() == null) continue;\n\t\t\tInstruction nextIns = handle.getNext().getInstruction();\n\n\t\t\tboolean isCast = ins instanceof CHECKCAST;\n\t\t\tString kind = isCast ? \"checkedCast\" : \"instanceof\";\n\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\tpc).size();\n\t\t\tboolean split = occurrences > 1;\n\t\t\tIsNullValueFrame nullFrame = isNullDataflow.getFactAtLocation(location);\n\t\t\tIsNullValue operandNullness = nullFrame.getTopValue();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out\n\t\t\t\t\t\t.println(kind + \" at pc: \" + pc + \" in \" + methodName);\n\t\t\t\tSystem.out.println(\" occurrences: \" + occurrences);\n\t\t\t\tSystem.out.println(\"XXX: \" + operandNullness);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (split && !isCast) {\n\t\t\t\t// don't report this case; it might be infeasible due to inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tType operandType = frame.getTopValue();\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean operandTypeIsExact = frame.isExact(frame.getStackLocation(0));\n\t\t\tType castType = ((TypedInstruction) ins).getType(cpg);\n\n\t\t\tif (!(castType instanceof ReferenceType)) {\n\t\t\t\t// This shouldn't happen either\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castSig = castType.getSignature();\n\t\t\t\n\t\t\tif (operandType.equals(NullType.instance()) || operandNullness.isDefinitelyNull()) {\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tString castName = castSig.substring(1, castSig.length() - 1)\n\t\t\t\t.replace('/', '.');\n\t\t\t\tif (!isCast) accumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_NULL_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addClass(castName), sourceLineAnnotation);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\n\t\t\tif (refType.equals(castType)) {\n\t\t\t\t// System.out.println(\"self-cast to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tString refSig = refType.getSignature();\n\t\t\tString castSig2 = castSig;\n\t\t\tString refSig2 = refSig;\n\t\t\twhile (castSig2.charAt(0) == '[' && refSig2.charAt(0) == '[') {\n\t\t\t\tcastSig2 = castSig2.substring(1);\n\t\t\t\trefSig2 = refSig2.substring(1);\n\t\t\t}\n\n\t\t\t\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\n\t\t\tif (refSig2.charAt(0) != 'L' || castSig2.charAt(0) != 'L') {\n\t\t\t\tif ( castSig2.charAt(0) == '[' && (refSig2.equals(\"Ljava/io/Serializable;\") \n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Object;\")\n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Cloneable;\"))) continue;\n\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\tnew BugInstance(this,\n\t\t\t\t\t\t\"BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY\", HIGH_PRIORITY )\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (refSig2.equals(\"Ljava/lang/Object;\")  &!operandTypeIsExact) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (false && isCast && haveMultipleCast.contains(sourceLineAnnotation)\n\t\t\t\t\t|| !isCast\n\t\t\t\t\t&& haveMultipleInstanceOf.contains(sourceLineAnnotation)) {\n\t\t\t\t// skip; might be due to JSR inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castName = castSig2.substring(1, castSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\t\t\tString refName = refSig2.substring(1, refSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\n\t\t\tif (vnaDataflow == null)\n\t\t\t\tvnaDataflow = classContext\n\t\t\t\t.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame vFrame = vnaDataflow.getFactAtLocation(location);\n\t\t\tif (paramValueNumberSet == null) \n\t\t\t\tparamValueNumberSet = getParameterValueNumbers(classContext, method, cfg);\n\t\t\tboolean isParameter = paramValueNumberSet.contains(vFrame\n\t\t\t\t\t.getTopValue());\n\t\t\ttry {\n\t\t\t\tJavaClass castJavaClass = Repository.lookupClass(castName);\n\t\t\t\tJavaClass refJavaClass = Repository.lookupClass(refName);\n\t\t\t\tboolean upcast = Repository.instanceOf(refJavaClass,\n\t\t\t\t\t\tcastJavaClass);\n\t\t\t\tif (upcast) {\n\t\t\t\t\tif (!isCast)\n\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"BC_VACUOUS_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addClass(refName.replace('/', '.'))\n\t\t\t\t\t\t\t\t.addClass(castName.replace('/', '.'))\n\t\t\t\t\t\t\t\t,sourceLineAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tboolean downcast = Repository.instanceOf(castJavaClass,\n\t\t\t\t\t\t\trefJavaClass);\n\t\t\t\t\t\n\t\t\t\t\tif (refName.equals(\"java.lang.Object\")  &!operandTypeIsExact) continue;\n\t\t\t\t\tdouble rank = 0.0;\n\t\t\t\t\tboolean castToConcreteCollection = concreteCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& abstractCollectionClasses.contains(refName);\n\t\t\t\t\tboolean castToAbstractCollection = \n\t\t\t\t\t\t\tabstractCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName);\n\t\n\t\t\t\t\tif (!operandTypeIsExact) {\n\t\t\t\t\t\trank = DeepSubtypeAnalysis.deepInstanceOf(refJavaClass,\n\t\t\t\t\t\t\t\tcastJavaClass);\n\t\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& rank > 0.6)\n\t\t\t\t\t\t  rank = (rank + 0.6) /2;\n\t\t\t\t\t\telse if (castToAbstractCollection\n\t\t\t\t\t\t\t&& rank > 0.3)\n\t\t\t\t\t\t  rank = (rank + 0.3) /2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tif (false)\n\t\t\t\t\t\tSystem.out.println(\"Rank:\\t\" + rank + \"\\t\" + refName\n\t\t\t\t\t\t\t\t+ \"\\t\" + castName);\n\t\t\t\t\tboolean completeInformation =  (!castJavaClass.isInterface() && !refJavaClass\n\t\t\t\t\t\t\t.isInterface())\n\t\t\t\t\t\t\t|| refJavaClass.isFinal()\n\t\t\t\t\t\t\t|| castJavaClass.isFinal();\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"cast from \" + refName + \" to \"\n\t\t\t\t\t\t\t\t+ castName);\n\t\t\t\t\t\tSystem.out.println(\"  is downcast: \" + downcast);\n\t\t\t\t\t\tSystem.out.println(\"  operand type is exact: \" + operandTypeIsExact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"  complete information: \"\n\t\t\t\t\t\t\t\t+ completeInformation);\n\t\t\t\t\t\tSystem.out.println(\"  isParameter: \"\n\t\t\t\t\t\t\t\t+ vFrame.getTopValue());\n\t\t\t\t\t\tSystem.out.println(\"  score: \" + rank);\n\t\t\t\t\t}\n\t\t\t\t\tif (!downcast && completeInformation || operandTypeIsExact)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\t\tisCast ? \"BC_IMPOSSIBLE_CAST\"\n\t\t\t\t\t\t\t\t\t\t: \"BC_IMPOSSIBLE_INSTANCEOF\",\n\t\t\t\t\t\t\t\tisCast ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addClass(refName.replace('/', '.'))\n\t\t\t\t\t\t\t\t.addClass(castName.replace('/', '.'))\n\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\t\telse if (isCast && rank < 0.9) {\n\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tif (rank > 0.75)\n\t\t\t\t\t\t\tpriority += 2;\n\t\t\t\t\t\telse if (rank > 0.5)\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\telse if (rank > 0.25)\n\t\t\t\t\t\t\tpriority += 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpriority--;\n\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority a: \" + priority);\n\t\t\t\t\t\tif (methodGen.getClassName().startsWith(refName)\n\t\t\t\t\t\t\t\t|| methodGen.getClassName().startsWith(castName))\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority b: \" + priority);\n\t\t\t\t\t\tif (castJavaClass.isInterface() && !castToAbstractCollection)\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority c: \" + priority);\n\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName))\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority d: \" + priority);\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY \n\t\t\t\t\t\t\t\t&& !castToAbstractCollection\n\t\t\t\t\t\t\t\t&& !castToConcreteCollection\n\t\t\t\t\t\t\t\t&& (refJavaClass.isInterface() || refJavaClass\n\t\t\t\t\t\t\t\t\t\t.isAbstract()))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority e: \" + priority);\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" ref name: \" + refName);\n\t\t\t\t\t\tif (methodGen.getName().equals(\"compareTo\"))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\telse if (methodGen.isPublic() && isParameter)\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority h: \" + priority);\n\t\t\t\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY) {\n\t\t\t\t\t\t\tString bug = \"BC_UNCONFIRMED_CAST\";\n\t\t\t\t\t\t\tif (castToConcreteCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_CONCRETE_COLLECTION\";\n\t\t\t\t\t\t\telse if (castToAbstractCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_ABSTRACT_COLLECTION\";\n\n\t\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this, bug, priority)\n\t\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\t.addClass(refName.replace('/', '.'))\n\t\t\t\t\t\t\t\t\t.addClass(castName.replace('/', '.')),\n\t\t\t\t\t\t\t\t\tsourceLineAnnotation\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","id":101781,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tif (isSynthetic(method) || !prescreen(classContext, method))\n\t\t\treturn;\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\t\n\t\t\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t\tSet<ValueNumber> paramValueNumberSet = null;\n\t\t\n\t\tValueNumberDataflow vnaDataflow = null;\n\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t+ methodGen.getName();\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tSet<SourceLineAnnotation> haveInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveCast = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleCast = new HashSet<SourceLineAnnotation>();\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\tif (ins instanceof CHECKCAST) {\n\t\t\t\tif (!haveCast.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleCast.add(sourceLineAnnotation);\n\t\t\t} else {\n\t\t\t\tif (!haveInstanceOf.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleInstanceOf.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tint pc = handle.getPosition();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\t\t\tif (handle.getNext() == null) continue;\n\t\t\tInstruction nextIns = handle.getNext().getInstruction();\n\n\t\t\tboolean isCast = ins instanceof CHECKCAST;\n\t\t\tString kind = isCast ? \"checkedCast\" : \"instanceof\";\n\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\tpc).size();\n\t\t\tboolean split = occurrences > 1;\n\t\t\tIsNullValueFrame nullFrame = isNullDataflow.getFactAtLocation(location);\n\t\t\tIsNullValue operandNullness = nullFrame.getTopValue();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out\n\t\t\t\t\t\t.println(kind + \" at pc: \" + pc + \" in \" + methodName);\n\t\t\t\tSystem.out.println(\" occurrences: \" + occurrences);\n\t\t\t\tSystem.out.println(\"XXX: \" + operandNullness);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (split && !isCast) {\n\t\t\t\t// don't report this case; it might be infeasible due to inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tType operandType = frame.getTopValue();\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean operandTypeIsExact = frame.isExact(frame.getStackLocation(0));\n\t\t\tType castType = ((TypedInstruction) ins).getType(cpg);\n\n\t\t\tif (!(castType instanceof ReferenceType)) {\n\t\t\t\t// This shouldn't happen either\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castSig = castType.getSignature();\n\t\t\t\n\t\t\tif (operandType.equals(NullType.instance()) || operandNullness.isDefinitelyNull()) {\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tString castName = castSig.substring(1, castSig.length() - 1)\n\t\t\t\t.replace('/', '.');\n\t\t\t\tif (!isCast) accumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_NULL_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addClass(castName), sourceLineAnnotation);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\n\t\t\tif (refType.equals(castType)) {\n\t\t\t\t// System.out.println(\"self-cast to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tString refSig = refType.getSignature();\n\t\t\tString castSig2 = castSig;\n\t\t\tString refSig2 = refSig;\n\t\t\twhile (castSig2.charAt(0) == '[' && refSig2.charAt(0) == '[') {\n\t\t\t\tcastSig2 = castSig2.substring(1);\n\t\t\t\trefSig2 = refSig2.substring(1);\n\t\t\t}\n\n\t\t\t\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\n\t\t\tif (refSig2.charAt(0) != 'L' || castSig2.charAt(0) != 'L') {\n\t\t\t\tif ( castSig2.charAt(0) == '[' && (refSig2.equals(\"Ljava/io/Serializable;\") \n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Object;\")\n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Cloneable;\"))) continue;\n\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\tnew BugInstance(this,\n\t\t\t\t\t\t\"BC_IMPOSSIBLE_CAST\", HIGH_PRIORITY )\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t.addType(castSig)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (refSig2.equals(\"Ljava/lang/Object;\")  &!operandTypeIsExact) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (false && isCast && haveMultipleCast.contains(sourceLineAnnotation)\n\t\t\t\t\t|| !isCast\n\t\t\t\t\t&& haveMultipleInstanceOf.contains(sourceLineAnnotation)) {\n\t\t\t\t// skip; might be due to JSR inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castName = castSig2.substring(1, castSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\t\t\tString refName = refSig2.substring(1, refSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\n\t\t\tif (vnaDataflow == null)\n\t\t\t\tvnaDataflow = classContext\n\t\t\t\t.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame vFrame = vnaDataflow.getFactAtLocation(location);\n\t\t\tif (paramValueNumberSet == null) \n\t\t\t\tparamValueNumberSet = getParameterValueNumbers(classContext, method, cfg);\n\t\t\tboolean isParameter = paramValueNumberSet.contains(vFrame\n\t\t\t\t\t.getTopValue());\n\t\t\ttry {\n\t\t\t\tJavaClass castJavaClass = Repository.lookupClass(castName);\n\t\t\t\tJavaClass refJavaClass = Repository.lookupClass(refName);\n\t\t\t\tboolean upcast = Repository.instanceOf(refJavaClass,\n\t\t\t\t\t\tcastJavaClass);\n\t\t\t\tif (upcast) {\n\t\t\t\t\tif (!isCast)\n\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"BC_VACUOUS_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t\t\t.addType(castSig)\n\t\t\t\t\t\t\t\t,sourceLineAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tboolean downcast = Repository.instanceOf(castJavaClass,\n\t\t\t\t\t\t\trefJavaClass);\n\t\t\t\t\t\n\t\t\t\t\tif (refName.equals(\"java.lang.Object\")  &!operandTypeIsExact) continue;\n\t\t\t\t\tdouble rank = 0.0;\n\t\t\t\t\tboolean castToConcreteCollection = concreteCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& abstractCollectionClasses.contains(refName);\n\t\t\t\t\tboolean castToAbstractCollection = \n\t\t\t\t\t\t\tabstractCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName);\n\t\n\t\t\t\t\tif (!operandTypeIsExact) {\n\t\t\t\t\t\trank = DeepSubtypeAnalysis.deepInstanceOf(refJavaClass,\n\t\t\t\t\t\t\t\tcastJavaClass);\n\t\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& rank > 0.6)\n\t\t\t\t\t\t  rank = (rank + 0.6) /2;\n\t\t\t\t\t\telse if (castToAbstractCollection\n\t\t\t\t\t\t\t&& rank > 0.3)\n\t\t\t\t\t\t  rank = (rank + 0.3) /2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tif (false)\n\t\t\t\t\t\tSystem.out.println(\"Rank:\\t\" + rank + \"\\t\" + refName\n\t\t\t\t\t\t\t\t+ \"\\t\" + castName);\n\t\t\t\t\tboolean completeInformation =  (!castJavaClass.isInterface() && !refJavaClass\n\t\t\t\t\t\t\t.isInterface())\n\t\t\t\t\t\t\t|| refJavaClass.isFinal()\n\t\t\t\t\t\t\t|| castJavaClass.isFinal();\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"cast from \" + refName + \" to \"\n\t\t\t\t\t\t\t\t+ castName);\n\t\t\t\t\t\tSystem.out.println(\"  is downcast: \" + downcast);\n\t\t\t\t\t\tSystem.out.println(\"  operand type is exact: \" + operandTypeIsExact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"  complete information: \"\n\t\t\t\t\t\t\t\t+ completeInformation);\n\t\t\t\t\t\tSystem.out.println(\"  isParameter: \"\n\t\t\t\t\t\t\t\t+ vFrame.getTopValue());\n\t\t\t\t\t\tSystem.out.println(\"  score: \" + rank);\n\t\t\t\t\t}\n\t\t\t\t\tif (!downcast && completeInformation || operandTypeIsExact)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\t\tisCast ? \"BC_IMPOSSIBLE_CAST\"\n\t\t\t\t\t\t\t\t\t\t: \"BC_IMPOSSIBLE_INSTANCEOF\",\n\t\t\t\t\t\t\t\tisCast ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t\t\t.addType(castSig)\n\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\t\telse if (isCast && rank < 0.9) {\n\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tif (rank > 0.75)\n\t\t\t\t\t\t\tpriority += 2;\n\t\t\t\t\t\telse if (rank > 0.5)\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\telse if (rank > 0.25)\n\t\t\t\t\t\t\tpriority += 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpriority--;\n\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority a: \" + priority);\n\t\t\t\t\t\tif (methodGen.getClassName().startsWith(refName)\n\t\t\t\t\t\t\t\t|| methodGen.getClassName().startsWith(castName))\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority b: \" + priority);\n\t\t\t\t\t\tif (castJavaClass.isInterface() && !castToAbstractCollection)\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority c: \" + priority);\n\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName))\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority d: \" + priority);\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY \n\t\t\t\t\t\t\t\t&& !castToAbstractCollection\n\t\t\t\t\t\t\t\t&& !castToConcreteCollection\n\t\t\t\t\t\t\t\t&& (refJavaClass.isInterface() || refJavaClass\n\t\t\t\t\t\t\t\t\t\t.isAbstract()))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority e: \" + priority);\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" ref name: \" + refName);\n\t\t\t\t\t\tif (methodGen.getName().equals(\"compareTo\"))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\telse if (methodGen.isPublic() && isParameter)\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority h: \" + priority);\n\t\t\t\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY) {\n\t\t\t\t\t\t\tString bug = \"BC_UNCONFIRMED_CAST\";\n\t\t\t\t\t\t\tif (castToConcreteCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_CONCRETE_COLLECTION\";\n\t\t\t\t\t\t\telse if (castToAbstractCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_ABSTRACT_COLLECTION\";\n\n\t\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this, bug, priority)\n\t\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t\t\t\t.addType(castSig),\n\t\t\t\t\t\t\t\t\tsourceLineAnnotation\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","commit_id":"4fce7aa43d01453e61d610ede304af0d8d1021c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void handleStringComparison(\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tRefComparisonTypeFrameModelingVisitor visitor,\n\t\t\tList<WarningWithProperties> stringComparisonList,\n\t\t\tLocation location,\n\t\t\tType lhsType,\n\t\t\tType rhsType) {\n\t\tif (DEBUG) System.out.println(\"String/String comparison at \" + location.getHandle());\n\n\t\t// Compute the priority:\n\t\t// - two static strings => do not report\n\t\t// - dynamic string and anything => high\n\t\t// - static string and unknown => medium\n\t\t// - all other cases => low\n\t\t// System.out.println(\"Compare \" + lhsType + \" == \" + rhsType);\n\t\tbyte type1 = lhsType.getType();\n\t\tbyte type2 = rhsType.getType();\n\t\t\n\t\tString bugPattern = \"ES_COMPARING_STRINGS_WITH_EQ\";\n\t\t// T1 T2 result\n\t\t// S  S  no-op\n\t\t// D  ?  high\n\t\t// ?  D  high\n\t\t// S  ?  normal\n\t\t// ?  S  normal\n\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\tif (type1 == T_STATIC_STRING && type2 == T_STATIC_STRING) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.COMPARE_STATIC_STRINGS);\n\t\t} else if (type1 == T_DYNAMIC_STRING || type2 == T_DYNAMIC_STRING) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.DYNAMIC_AND_UNKNOWN);\n\t\t} else if (type2 == T_PARAMETER_STRING || type1 == T_PARAMETER_STRING) {\n\t\t\tbugPattern = \"ES_COMPARING_PARAMETER_STRING_WITH_EQ\";\n\t\t\tif (methodGen.isPublic() || methodGen.isProtected()) propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER_IN_PUBLIC_METHOD);\n\t\t\telse propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER);\n\t\t} else if (type1 == T_STATIC_STRING || type2 == T_STATIC_STRING) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.STATIC_AND_UNKNOWN);\n\t\t} else if (visitor.sawStringIntern()) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.SAW_INTERN);\n\t\t}\n\t\t\n\t\tString sourceFile = jclass.getSourceFileName();\n\t\tBugInstance instance =\n\t\t\tnew BugInstance(this, bugPattern, BASE_ES_PRIORITY)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addClass(\"java.lang.String\").describe(\"CLASS_REFTYPE\")\n\t\t\t.addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle());\n\t\t\n\t\tWarningWithProperties warn = new WarningWithProperties(instance, propertySet, location);\n\t\tstringComparisonList.add(warn);\n\t}","id":101782,"modified_method":"private void handleStringComparison(\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tRefComparisonTypeFrameModelingVisitor visitor,\n\t\t\tList<WarningWithProperties> stringComparisonList,\n\t\t\tLocation location,\n\t\t\tType lhsType,\n\t\t\tType rhsType) {\n\t\tif (DEBUG) System.out.println(\"String/String comparison at \" + location.getHandle());\n\n\t\t// Compute the priority:\n\t\t// - two static strings => do not report\n\t\t// - dynamic string and anything => high\n\t\t// - static string and unknown => medium\n\t\t// - all other cases => low\n\t\t// System.out.println(\"Compare \" + lhsType + \" == \" + rhsType);\n\t\tbyte type1 = lhsType.getType();\n\t\tbyte type2 = rhsType.getType();\n\t\t\n\t\tString bugPattern = \"ES_COMPARING_STRINGS_WITH_EQ\";\n\t\t// T1 T2 result\n\t\t// S  S  no-op\n\t\t// D  ?  high\n\t\t// ?  D  high\n\t\t// S  ?  normal\n\t\t// ?  S  normal\n\t\tWarningPropertySet propertySet = new WarningPropertySet();\n\t\tif (type1 == T_STATIC_STRING && type2 == T_STATIC_STRING) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.COMPARE_STATIC_STRINGS);\n\t\t} else if (type1 == T_DYNAMIC_STRING || type2 == T_DYNAMIC_STRING) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.DYNAMIC_AND_UNKNOWN);\n\t\t} else if (type2 == T_PARAMETER_STRING || type1 == T_PARAMETER_STRING) {\n\t\t\tbugPattern = \"ES_COMPARING_PARAMETER_STRING_WITH_EQ\";\n\t\t\tif (methodGen.isPublic() || methodGen.isProtected()) propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER_IN_PUBLIC_METHOD);\n\t\t\telse propertySet.addProperty(RefComparisonWarningProperty.STRING_PARAMETER);\n\t\t} else if (type1 == T_STATIC_STRING || type2 == T_STATIC_STRING) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.STATIC_AND_UNKNOWN);\n\t\t} else if (visitor.sawStringIntern()) {\n\t\t\tpropertySet.addProperty(RefComparisonWarningProperty.SAW_INTERN);\n\t\t}\n\t\t\n\t\tString sourceFile = jclass.getSourceFileName();\n\t\tBugInstance instance =\n\t\t\tnew BugInstance(this, bugPattern, BASE_ES_PRIORITY)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addType(\"Ljava/lang/String;\")\n\t\t\t.addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle());\n\t\t\n\t\tWarningWithProperties warn = new WarningWithProperties(instance, propertySet, location);\n\t\tstringComparisonList.add(warn);\n\t}","commit_id":"4fce7aa43d01453e61d610ede304af0d8d1021c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void handleSuspiciousRefComparison(\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tList<WarningWithProperties> refComparisonList,\n\t\t\tLocation location,\n\t\t\tString lhs) {\n\t\tString sourceFile = jclass.getSourceFileName();\n\t\tBugInstance instance = new BugInstance(this, \"RC_REF_COMPARISON\", lhs.equals(\"java.lang.Boolean\") ? NORMAL_PRIORITY : HIGH_PRIORITY)\n\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t        .addClass(lhs).describe(\"CLASS_REFTYPE\");\n\t\trefComparisonList.add(new WarningWithProperties(instance, new WarningPropertySet(), location));\n\t}","id":101783,"modified_method":"private void handleSuspiciousRefComparison(\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tList<WarningWithProperties> refComparisonList,\n\t\t\tLocation location,\n\t\t\tString lhs) {\n\t\tString sourceFile = jclass.getSourceFileName();\n\t\tBugInstance instance = new BugInstance(this, \"RC_REF_COMPARISON\", lhs.equals(\"java.lang.Boolean\") ? NORMAL_PRIORITY : HIGH_PRIORITY)\n\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t         .addType(\"L\" + lhs.replace('.', '/')+\";\")\n\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle());\n\t\t     \n\t\trefComparisonList.add(new WarningWithProperties(instance, new WarningPropertySet(), location));\n\t}","commit_id":"4fce7aa43d01453e61d610ede304af0d8d1021c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void checkEqualsComparison(\n\t\t\tLocation location,\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tTypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n\t\tInstructionHandle handle = location.getHandle();\n\t\tString sourceFile = jclass.getSourceFileName();\n\n\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\tif (frame.getStackDepth() < 2)\n\t\t\tthrow new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n\n\t\tint numSlots = frame.getNumSlots();\n\t\tType lhsType_ = frame.getValue(numSlots - 2);\n\t\tType rhsType_ = frame.getValue(numSlots - 1);\n\n\t\n\t\t// Ignore top and bottom values\n\t\tif (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM\n\t\t        || rhsType_.getType() == T_TOP || rhsType_.getType() == T_BOTTOM)\n\t\t\treturn;\n\n\t\tif (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n\t\t\tif (rhsType_.getType() == T_NULL) {\n\t\t\t\tboolean isTestCase = false;\n\t\t\t\tMethod method = methodGen.getMethod();\n\t\t\t\tif (method.getName().startsWith(\"test\") && method.isPublic() && method.getSignature().equals(\"()V\")\n\t\t\t\t\t\t|| methodGen.getClassName().endsWith(\"Test\"))\n\t\t\t\t\tisTestCase = true;\n\t\t\t\t// A literal null value was passed directly to equals().\n\t\t\t\tif (!isTestCase)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_NULL_ARG\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle()));\n\t\t\t} else if (lhsType_.getType() == T_NULL) {\n\t\t\t\t// Hmm...in this case, equals() is being invoked on\n\t\t\t\t// a literal null value.  This is really the\n\t\t\t\t// purview of FindNullDeref.  So, we'll just do nothing.\n\t\t\t} else {\n\t\t\t\tbugReporter.logError(\"equals() used to compare non-object type(s) \" +\n\t\t\t\t        lhsType_ + \" and \" + rhsType_ +\n\t\t\t\t        \" in \" +\n\t\t\t\t        SignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t        \" at \" + location.getHandle());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\tdo {\n\t\t\tlhsType_ = ((ArrayType)lhsType_).getElementType();\n\t\t\trhsType_ = ((ArrayType)rhsType_).getElementType();\n\t\t} while  (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType);\n\t\t}\n\t\t\n\t\tif (lhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (rhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (rhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (lhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(rhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(lhsType_.getSignature()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (lhsType_.equals(rhsType_))\n\t\t\treturn;\n\n\t\t// For now, ignore the case where either reference is not\n\t\t// of an object type.  (It could be either an array or null.)\n\t\tif (!(lhsType_ instanceof ObjectType) || !(rhsType_ instanceof ObjectType))\n\t\t\treturn;\n\n\t\tObjectType lhsType = (ObjectType) lhsType_;\n\t\tObjectType rhsType = (ObjectType) rhsType_;\n\n\t\tint priority = LOW_PRIORITY + 1;\n\t\tString bugType = \"EC_UNRELATED_TYPES\";\n\n\t\t// See if the types are related by inheritance.\n\t\ttry {\n\t\t\tif (!Hierarchy.isSubtype(lhsType, rhsType) && !Hierarchy.isSubtype(rhsType, lhsType)) {\n\t\t\t\tAnalysisContext analysisContext = AnalysisContext.currentAnalysisContext();\n\t\t\t\t\n\t\t\t\t// Look up the classes\n\t\t\t\tJavaClass lhsClass = analysisContext.lookupClass(lhsType.getClassName());\n\t\t\t\tJavaClass rhsClass = analysisContext.lookupClass(rhsType.getClassName());\n\n\t\t\t\tif (!lhsClass.isInterface() && !rhsClass.isInterface()) {\n\t\t\t\t\t// Both are class types, and therefore there is no possible way\n\t\t\t\t\t// the compared objects can have the same runtime type.\n\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + lhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(lhsClass)));\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + rhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(rhsClass)));\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t// Look up the common subtypes of the two types.  If the\n\t\t\t\t\t// intersection does not contain at least one instantiable class,\n\t\t\t\t\t// then issue a warning of the appropriate type.\n\t\t\t\t\tSet<JavaClass> commonSubtypes =\n\t\t\t\t\t\tanalysisContext.getSubtypes().getTransitiveCommonSubtypes(lhsClass, rhsClass);\n\t\t\t\t\t\n\t\t\t\t\tif (!containsAtLeastOneInstantiableClass(commonSubtypes)) {\n\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tbugType = (lhsClass.isInterface() && rhsClass.isInterface())\n\t\t\t\t\t\t\t? \"EC_UNRELATED_INTERFACES\" : \"EC_UNRELATED_CLASS_AND_INTERFACE\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t\treturn;\n\t\t}\n\n\t\tif (methodGen.getName().startsWith(\"test\") && methodGen.getSignature().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(methodGen.getClassName(), \"junit.framework.TestCase\"))\n\t\t\t\t\tpriority+=2;\n\t\t\t} catch (ClassNotFoundException e) { priority+=2; }\n\t\t\t}\n\n\n\t\t\n\n\t\tif (priority <= LOW_PRIORITY) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, bugType, priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addClass(lhsType.getClassName()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addClass(rhsType.getClassName()).describe(\"CLASS_REFTYPE\")\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t        );\n\t\t}\n\t}","id":101784,"modified_method":"private void checkEqualsComparison(\n\t\t\tLocation location,\n\t\t\tJavaClass jclass,\n\t\t\tMethodGen methodGen,\n\t\t\tTypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n\t\tInstructionHandle handle = location.getHandle();\n\t\tString sourceFile = jclass.getSourceFileName();\n\n\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\tif (frame.getStackDepth() < 2)\n\t\t\tthrow new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n\n\t\tint numSlots = frame.getNumSlots();\n\t\tType lhsType_ = frame.getValue(numSlots - 2);\n\t\tType rhsType_ = frame.getValue(numSlots - 1);\n\n\t\n\t\t// Ignore top and bottom values\n\t\tif (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM\n\t\t        || rhsType_.getType() == T_TOP || rhsType_.getType() == T_BOTTOM)\n\t\t\treturn;\n\n\t\tif (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n\t\t\tif (rhsType_.getType() == T_NULL) {\n\t\t\t\tboolean isTestCase = false;\n\t\t\t\tMethod method = methodGen.getMethod();\n\t\t\t\tif (method.getName().startsWith(\"test\") && method.isPublic() && method.getSignature().equals(\"()V\")\n\t\t\t\t\t\t|| methodGen.getClassName().endsWith(\"Test\"))\n\t\t\t\t\tisTestCase = true;\n\t\t\t\t// A literal null value was passed directly to equals().\n\t\t\t\tif (!isTestCase)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_NULL_ARG\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle()));\n\t\t\t} else if (lhsType_.getType() == T_NULL) {\n\t\t\t\t// Hmm...in this case, equals() is being invoked on\n\t\t\t\t// a literal null value.  This is really the\n\t\t\t\t// purview of FindNullDeref.  So, we'll just do nothing.\n\t\t\t} else {\n\t\t\t\tbugReporter.logError(\"equals() used to compare non-object type(s) \" +\n\t\t\t\t        lhsType_ + \" and \" + rhsType_ +\n\t\t\t\t        \" in \" +\n\t\t\t\t        SignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t        \" at \" + location.getHandle());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tReferenceType originalLhsType = (ReferenceType) lhsType_;\n\t\tReferenceType originalRhsType = (ReferenceType) rhsType_;\n\t\t\n\t\tif (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addType(originalLhsType.getSignature())\n\t\t\t        .addType(originalRhsType.getSignature())\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\tdo {\n\t\t\tlhsType_ = ((ArrayType)lhsType_).getElementType();\n\t\t\trhsType_ = ((ArrayType)rhsType_).getElementType();\n\t\t} while  (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType);\n\t\t}\n\t\t\n\t\tif (lhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (rhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t         .addType(originalLhsType.getSignature())\n\t\t\t        .addType(originalRhsType.getSignature())\n\t\t\t       .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (rhsType_ instanceof ArrayType) {\n\t\t\tint priority = HIGH_PRIORITY;\n\t\t\tif (lhsType_.equals(ObjectType.OBJECT)) priority = LOW_PRIORITY;\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t         .addType(originalLhsType.getSignature())\n\t\t\t        .addType(originalRhsType.getSignature())\n\t\t\t       .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t         );\n\t\t}\n\t\tif (lhsType_.equals(rhsType_))\n\t\t\treturn;\n\n\t\t// For now, ignore the case where either reference is not\n\t\t// of an object type.  (It could be either an array or null.)\n\t\tif (!(lhsType_ instanceof ObjectType) || !(rhsType_ instanceof ObjectType))\n\t\t\treturn;\n\n\t\tObjectType lhsType = (ObjectType) lhsType_;\n\t\tObjectType rhsType = (ObjectType) rhsType_;\n\n\t\tint priority = LOW_PRIORITY + 1;\n\t\tString bugType = \"EC_UNRELATED_TYPES\";\n\n\t\t// See if the types are related by inheritance.\n\t\ttry {\n\t\t\tif (!Hierarchy.isSubtype(lhsType, rhsType) && !Hierarchy.isSubtype(rhsType, lhsType)) {\n\t\t\t\tAnalysisContext analysisContext = AnalysisContext.currentAnalysisContext();\n\t\t\t\t\n\t\t\t\t// Look up the classes\n\t\t\t\tJavaClass lhsClass = analysisContext.lookupClass(lhsType.getClassName());\n\t\t\t\tJavaClass rhsClass = analysisContext.lookupClass(rhsType.getClassName());\n\n\t\t\t\tif (!lhsClass.isInterface() && !rhsClass.isInterface()) {\n\t\t\t\t\t// Both are class types, and therefore there is no possible way\n\t\t\t\t\t// the compared objects can have the same runtime type.\n\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + lhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(lhsClass)));\n\t\t\t\t\t\tSystem.out.println(\"Subtypes of \" + rhsClass.getClassName() + \" are \" +\n\t\t\t\t\t\t\t\tclassSetToString(analysisContext.getSubtypes().getTransitiveSubtypes(rhsClass)));\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t// Look up the common subtypes of the two types.  If the\n\t\t\t\t\t// intersection does not contain at least one instantiable class,\n\t\t\t\t\t// then issue a warning of the appropriate type.\n\t\t\t\t\tSet<JavaClass> commonSubtypes =\n\t\t\t\t\t\tanalysisContext.getSubtypes().getTransitiveCommonSubtypes(lhsClass, rhsClass);\n\t\t\t\t\t\n\t\t\t\t\tif (!containsAtLeastOneInstantiableClass(commonSubtypes)) {\n\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tbugType = (lhsClass.isInterface() && rhsClass.isInterface())\n\t\t\t\t\t\t\t? \"EC_UNRELATED_INTERFACES\" : \"EC_UNRELATED_CLASS_AND_INTERFACE\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t\treturn;\n\t\t}\n\n\t\tif (methodGen.getName().startsWith(\"test\") && methodGen.getSignature().equals(\"()V\")) {\n\t\t\ttry {\n\t\t\t\tif (Hierarchy.isSubtype(methodGen.getClassName(), \"junit.framework.TestCase\"))\n\t\t\t\t\tpriority+=2;\n\t\t\t} catch (ClassNotFoundException e) { priority+=2; }\n\t\t\t}\n\n\n\t\t\n\n\t\tif (priority <= LOW_PRIORITY) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, bugType, priority)\n\t\t\t        .addClassAndMethod(methodGen, sourceFile)\n\t\t\t        .addType(originalLhsType.getSignature())\n\t\t\t        .addType(originalRhsType.getSignature())\n\t\t\t        .addSourceLine(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t        );\n\t\t}\n\t}","commit_id":"4fce7aa43d01453e61d610ede304af0d8d1021c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n         public void sawOpcode( int seen) {\n\t\t// System.out.println(\"State:\" + state);\n\t\tif (seen == GOTO && getBranchOffset() == 4) {\n\t\t\tstate = SEEN_GOTO;\n\t\t} else\n\t\t\tswitch (state) {\n\t\t\tcase SEEN_NOTHING:\n\t\t\t\tif ((seen == ICONST_1))\n\t\t\t\t\tstate = SEEN_ICONST_1;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ICONST_1:\n\t\t\t\tif (seen == ANEWARRAY && primitiveArray.matcher(getClassConstantOperand()).matches()) {\n\t\t\t\t\t// System.out.println(\"Allocation of array of type \" + getClassConstantOperand());\n\t\t\t\t\tstate = SEEN_ANEWARRAY; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ANEWARRAY:\n\t\t\t\tif (seen == DUP)\n\t\t\t\t\tstate = SEEN_DUP;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_DUP:\n\t\t\t\tif (seen == ICONST_0)\n\t\t\t\t\tstate = SEEN_ICONST_0;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_ICONST_0:\n\t\t\t\tif (((seen >= ALOAD_0) && (seen < ALOAD_3)) || (seen == ALOAD))\n\t\t\t\t\tstate = SEEN_ALOAD;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ALOAD:\n\t\t\t\tif (seen == AASTORE)\n\t\t\t\t\tstate = SEEN_AASTORE;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_AASTORE:\n\t\t\t\tif (seen == INVOKESTATIC || seen == INVOKEINTERFACE\n\t\t\t\t\t\t|| seen == INVOKESPECIAL || seen == INVOKEVIRTUAL) {\n//\t\t\t\t\tSystem.out.println(getClassConstantOperand());\n//\t\t\t\t\tSystem.out.println(getNameConstantOperand());\n//\t\t\t\t\tSystem.out.println(getSigConstantOperand());\n\t\t\t\t\tif (getSigConstantOperand().indexOf(\"Ljava/lang/Object;)\") == -1) break;\n\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\tif (getNameConstantOperand().equals(\"asList\") \n\t\t\t\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Arrays\"))\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\tbugReporter.reportBug( new BugInstance( this, \"VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG\", priority)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addSourceLine(this));\n\t\t\t\t}\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_GOTO:\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"State \" + state\n\t\t\t\t\t\t+ \" not expected\");\n\n\t\t\t}\n\t}","id":101785,"modified_method":"@Override\n         public void sawOpcode( int seen) {\n\t\t// System.out.println(\"State:\" + state);\n\t\tif (seen == GOTO && getBranchOffset() == 4) {\n\t\t\tstate = SEEN_GOTO;\n\t\t} else\n\t\t\tswitch (state) {\n\t\t\tcase SEEN_NOTHING:\n\t\t\t\tif ((seen == ICONST_1))\n\t\t\t\t\tstate = SEEN_ICONST_1;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ICONST_1:\n\t\t\t\tif (seen == ANEWARRAY && primitiveArray.matcher(getClassConstantOperand()).matches()) {\n\t\t\t\t\t// System.out.println(\"Allocation of array of type \" + getClassConstantOperand());\n\t\t\t\t\tprimitiveArraySig = getClassConstantOperand();\n\t\t\t\t\tstate = SEEN_ANEWARRAY; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ANEWARRAY:\n\t\t\t\tif (seen == DUP)\n\t\t\t\t\tstate = SEEN_DUP;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_DUP:\n\t\t\t\tif (seen == ICONST_0)\n\t\t\t\t\tstate = SEEN_ICONST_0;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_ICONST_0:\n\t\t\t\tif (((seen >= ALOAD_0) && (seen < ALOAD_3)) || (seen == ALOAD))\n\t\t\t\t\tstate = SEEN_ALOAD;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ALOAD:\n\t\t\t\tif (seen == AASTORE)\n\t\t\t\t\tstate = SEEN_AASTORE;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_AASTORE:\n\t\t\t\tif (seen == INVOKESTATIC || seen == INVOKEINTERFACE\n\t\t\t\t\t\t|| seen == INVOKESPECIAL || seen == INVOKEVIRTUAL) {\n//\t\t\t\t\tSystem.out.println(getClassConstantOperand());\n//\t\t\t\t\tSystem.out.println(getNameConstantOperand());\n//\t\t\t\t\tSystem.out.println(getSigConstantOperand());\n\t\t\t\t\tif (getSigConstantOperand().indexOf(\"Ljava/lang/Object;)\") == -1) break;\n\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\tif (getNameConstantOperand().equals(\"asList\") \n\t\t\t\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Arrays\"))\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\tbugReporter.reportBug( new BugInstance( this, \"VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG\", priority)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addType(primitiveArraySig)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addSourceLine(this));\n\t\t\t\t}\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_GOTO:\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"State \" + state\n\t\t\t\t\t\t+ \" not expected\");\n\n\t\t\t}\n\t}","commit_id":"4fce7aa43d01453e61d610ede304af0d8d1021c2","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void onMultipleValues(AttributeDefinition[] definitions)\n    {\n    }","id":101786,"modified_method":"@Override\n    public void onMultipleValues(KeyAttributeDefinitionPair[] definitions)\n    {\n    }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n         * Used when several attributes or child components needs to be mapped to a\n         * single attribute. The attribute must be of type Map where the key are\n         * the attribute name or the child element name and the value is the actual object.\n         *\n         * @param definitions the set of attribute definitions\n         * @return the builder\n         */\n        public static Builder fromMultipleDefinitions(AttributeDefinition... definitions)\n        {\n            Builder builder = new Builder();\n            builder.attributeDefinition.definitions = definitions;\n            return builder;\n        }","id":101787,"modified_method":"/**\n         * Used when several attributes or child components needs to be mapped to a\n         * single attribute. The attribute must be of type Map where the key are\n         * the attribute name or the child element name and the value is the actual object.\n         *\n         * @param definitions the set of attribute definitions along with its keys\n         * @return the builder\n         */\n        public static Builder fromMultipleDefinitions(KeyAttributeDefinitionPair... definitions)\n        {\n            Builder builder = new Builder();\n            builder.attributeDefinition.definitions = definitions;\n            return builder;\n        }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"private Map<String, WrapperComponentConfig> getWrapperIdentifierAndTypeMap(ComponentBuildingDefinition buildingDefinition)\n    {\n        final Map<String, WrapperComponentConfig> wrapperIdentifierAndTypeMap = new HashMap<>();\n        AbstractAttributeDefinitionVisitor wrapperIdentifiersCollector = new AbstractAttributeDefinitionVisitor()\n        {\n            @Override\n            public void onComplexChildCollection(Class<?> type, Optional<String> wrapperIdentifier, Optional<Class<? extends Collection>> collectionTypeOptional)\n            {\n                wrapperIdentifier.ifPresent( identifier -> {\n                    wrapperIdentifierAndTypeMap.put(identifier, new WrapperComponentConfig(COLLECTION, collectionTypeOptional));\n                });\n            }\n\n            @Override\n            public void onComplexChild(Class<?> type, Optional<String> wrapperIdentifier)\n            {\n                wrapperIdentifier.ifPresent(identifier -> {\n                    wrapperIdentifierAndTypeMap.put(identifier, new WrapperComponentConfig(SINGLE, empty()));\n                });\n            }\n\n            @Override\n            public void onMultipleValues(AttributeDefinition[] definitions)\n            {\n                for (AttributeDefinition attributeDefinition : definitions)\n                {\n                    attributeDefinition.accept(this);\n                }\n            }\n        };\n        Consumer<AttributeDefinition> collectWrappersConsumer = attributeDefinition -> {\n            attributeDefinition.accept(wrapperIdentifiersCollector);\n        };\n        buildingDefinition.getSetterParameterDefinitions().values().stream().forEach(collectWrappersConsumer);\n        buildingDefinition.getConstructorAttributeDefinition().stream().forEach(collectWrappersConsumer);\n        return wrapperIdentifierAndTypeMap;\n    }","id":101788,"modified_method":"private Map<String, WrapperComponentConfig> getWrapperIdentifierAndTypeMap(ComponentBuildingDefinition buildingDefinition)\n    {\n        final Map<String, WrapperComponentConfig> wrapperIdentifierAndTypeMap = new HashMap<>();\n        AbstractAttributeDefinitionVisitor wrapperIdentifiersCollector = new AbstractAttributeDefinitionVisitor()\n        {\n            @Override\n            public void onComplexChildCollection(Class<?> type, Optional<String> wrapperIdentifier, Optional<Class<? extends Collection>> collectionTypeOptional)\n            {\n                wrapperIdentifier.ifPresent( identifier -> {\n                    wrapperIdentifierAndTypeMap.put(identifier, new WrapperComponentConfig(COLLECTION, collectionTypeOptional));\n                });\n            }\n\n            @Override\n            public void onComplexChild(Class<?> type, Optional<String> wrapperIdentifier)\n            {\n                wrapperIdentifier.ifPresent(identifier -> {\n                    wrapperIdentifierAndTypeMap.put(identifier, new WrapperComponentConfig(SINGLE, empty()));\n                });\n            }\n\n            @Override\n            public void onMultipleValues(KeyAttributeDefinitionPair[] definitions)\n            {\n                for (KeyAttributeDefinitionPair attributeDefinition : definitions)\n                {\n                    attributeDefinition.getAttributeDefinition().accept(this);\n                }\n            }\n        };\n        Consumer<AttributeDefinition> collectWrappersConsumer = attributeDefinition -> {\n            attributeDefinition.accept(wrapperIdentifiersCollector);\n        };\n        buildingDefinition.getSetterParameterDefinitions().values().stream().forEach(collectWrappersConsumer);\n        buildingDefinition.getConstructorAttributeDefinition().stream().forEach(collectWrappersConsumer);\n        return wrapperIdentifierAndTypeMap;\n    }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"private BeanDefinitionCreator buildComponentModelProcessorChainOfResponsability()\n    {\n        ExceptionStrategyRefBeanDefinitionCreator exceptionStrategyRefBeanDefinitionCreator = new ExceptionStrategyRefBeanDefinitionCreator();\n        FilterReferenceBeanDefinitionCreator filterReferenceBeanDefinitionCreator = new FilterReferenceBeanDefinitionCreator();\n        ReferenceBeanDefinitionCreator referenceBeanDefinitionCreator = new ReferenceBeanDefinitionCreator();\n        CommonBeanDefinitionCreator commonComponentModelProcessor = new CommonBeanDefinitionCreator();\n        exceptionStrategyRefBeanDefinitionCreator.setNext(exceptionStrategyRefBeanDefinitionCreator);\n        exceptionStrategyRefBeanDefinitionCreator.setNext(filterReferenceBeanDefinitionCreator);\n        filterReferenceBeanDefinitionCreator.setNext(referenceBeanDefinitionCreator);\n        referenceBeanDefinitionCreator.setNext(commonComponentModelProcessor);\n        return exceptionStrategyRefBeanDefinitionCreator;\n    }","id":101789,"modified_method":"private BeanDefinitionCreator buildComponentModelProcessorChainOfResponsability()\n    {\n        ExceptionStrategyRefBeanDefinitionCreator exceptionStrategyRefBeanDefinitionCreator = new ExceptionStrategyRefBeanDefinitionCreator();\n        FilterReferenceBeanDefinitionCreator filterReferenceBeanDefinitionCreator = new FilterReferenceBeanDefinitionCreator();\n        ReferenceBeanDefinitionCreator referenceBeanDefinitionCreator = new ReferenceBeanDefinitionCreator();\n        SimpleTypeBeanDefinitionCreator simpleTypeBeanDefinitionCreator = new SimpleTypeBeanDefinitionCreator();\n        CommonBeanDefinitionCreator commonComponentModelProcessor = new CommonBeanDefinitionCreator();\n        exceptionStrategyRefBeanDefinitionCreator.setNext(exceptionStrategyRefBeanDefinitionCreator);\n        exceptionStrategyRefBeanDefinitionCreator.setNext(filterReferenceBeanDefinitionCreator);\n        filterReferenceBeanDefinitionCreator.setNext(referenceBeanDefinitionCreator);\n        referenceBeanDefinitionCreator.setNext(simpleTypeBeanDefinitionCreator);\n        simpleTypeBeanDefinitionCreator.setNext(commonComponentModelProcessor);\n        return exceptionStrategyRefBeanDefinitionCreator;\n    }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"private void processComponentWrapper(ComponentModel componentModel)\n    {\n        componentModel.setType(componentModel.getInnerComponents().get(0).getType());\n        ComponentBuildingDefinition parentBuildingDefinition = componentBuildingDefinitionRegistry.getBuildingDefinition(componentModel.getParent().getIdentifier()).get();\n        Map<String, WrapperComponentConfig> wrapperIdentifierAndTypeMap = getWrapperIdentifierAndTypeMap(parentBuildingDefinition);\n        WrapperComponentConfig wrapperComponentConfig = wrapperIdentifierAndTypeMap.get(componentModel.getIdentifier().getName());\n        if (wrapperComponentConfig.getChildType().equals(COLLECTION))\n        {\n            ManagedList<Object> managedList = new ManagedList<>();\n            for (ComponentModel innerComponentModel : componentModel.getInnerComponents())\n            {\n                Object value = innerComponentModel.getBeanDefinition() != null ? innerComponentModel.getBeanDefinition() : innerComponentModel.getBeanReference();\n                managedList.add(value);\n            }\n            componentModel.setBeanDefinition(genericBeanDefinition(wrapperComponentConfig.getCollectionTypeOptional().orElse(ArrayList.class))\n                                                     .addConstructorArgValue(managedList)\n                                                     .getBeanDefinition());\n        }\n        else\n        {\n            componentModel.setBeanDefinition(componentModel.getInnerComponents().get(0).getBeanDefinition());\n            componentModel.setBeanReference(componentModel.getInnerComponents().get(0).getBeanReference());\n        }\n    }","id":101790,"modified_method":"private void processComponentWrapper(ComponentModel componentModel)\n    {\n        componentModel.setType(componentModel.getInnerComponents().get(0).getType());\n        ComponentBuildingDefinition parentBuildingDefinition = componentBuildingDefinitionRegistry.getBuildingDefinition(componentModel.getParent().getIdentifier()).get();\n        Map<String, WrapperComponentConfig> wrapperIdentifierAndTypeMap = getWrapperIdentifierAndTypeMap(parentBuildingDefinition);\n        WrapperComponentConfig wrapperComponentConfig = wrapperIdentifierAndTypeMap.get(componentModel.getIdentifier().getName());\n        if (wrapperComponentConfig.getWrapperType().equals(COLLECTION))\n        {\n            Class<? extends Collection> type = wrapperComponentConfig.getCollectionTypeOptional().orElse(ArrayList.class);\n            ManagedList<Object> managedList = new ManagedList<>();\n            for (ComponentModel innerComponentModel : componentModel.getInnerComponents())\n            {\n                Object value = innerComponentModel.getBeanDefinition() != null ? innerComponentModel.getBeanDefinition() : innerComponentModel.getBeanReference();\n                managedList.add(value);\n            }\n            componentModel.setBeanDefinition(genericBeanDefinition(type)\n                                                     .addConstructorArgValue(managedList)\n                                                     .getBeanDefinition());\n        }\n        else\n        {\n            componentModel.setBeanDefinition(componentModel.getInnerComponents().get(0).getBeanDefinition());\n            componentModel.setBeanReference(componentModel.getInnerComponents().get(0).getBeanReference());\n        }\n    }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n        public void onMultipleValues(AttributeDefinition[] definitions)\n        {\n            for (AttributeDefinition definition : definitions)\n            {\n                definition.accept(this);\n            }\n        }","id":101791,"modified_method":"@Override\n        public void onMultipleValues(KeyAttributeDefinitionPair[] definitions)\n        {\n            for (KeyAttributeDefinitionPair definition : definitions)\n            {\n                definition.getAttributeDefinition().accept(this);\n            }\n        }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n        public void onMultipleValues(AttributeDefinition[] definitions)\n        {\n            ManagedMap managedMap = new ManagedMap();\n            for (AttributeDefinition definition : definitions)\n            {\n                ValueExtractorAttributeDefinitionVisitor valueExtractor = new ValueExtractorAttributeDefinitionVisitor();\n                KeyExtractorAttributeDefinitionVisitor keyExtractor = new KeyExtractorAttributeDefinitionVisitor();\n                definition.accept(keyExtractor);\n                definition.accept(valueExtractor);\n                Object value = valueExtractor.getValue();\n                if (value != null)\n                {\n                    managedMap.put(keyExtractor.getKey(), value);\n                }\n            }\n            valueConsumer.accept(managedMap);\n        }","id":101792,"modified_method":"@Override\n        public void onMultipleValues(KeyAttributeDefinitionPair[] definitions)\n        {\n            ManagedMap managedMap = new ManagedMap();\n            for (KeyAttributeDefinitionPair definition : definitions)\n            {\n                ValueExtractorAttributeDefinitionVisitor valueExtractor = new ValueExtractorAttributeDefinitionVisitor();\n                definition.getAttributeDefinition().accept(valueExtractor);\n                Object value = valueExtractor.getValue();\n                if (value != null)\n                {\n                    managedMap.put(definition.getKey(), value);\n                }\n            }\n            valueConsumer.accept(managedMap);\n        }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"private Predicate<ComponentValue> getTypeAndIdentifierPredicate(Class<?> type, Optional<String> identifierOptional)\n        {\n            return beanDefinitionTypePair -> {\n                        AtomicReference<Boolean> matchesIdentifier = new AtomicReference<>(true);\n                        identifierOptional.ifPresent(identifier -> {\n                            matchesIdentifier.set(identifier.equals(beanDefinitionTypePair.getIdentifier().getName()));\n                        });\n                        return areMatchingTypes(type, beanDefinitionTypePair.getType()) && matchesIdentifier.get();\n                    };\n        }","id":101793,"modified_method":"private Predicate<ComponentValue> getTypeAndIdentifierPredicate(Class<?> type, Optional<String> wrapperIdentifierOptional)\n        {\n            return componentValue -> {\n                        AtomicReference<Boolean> matchesIdentifier = new AtomicReference<>(true);\n                        wrapperIdentifierOptional.ifPresent(wrapperIdentifier -> {\n                            matchesIdentifier.set(wrapperIdentifier.equals(componentValue.getIdentifier().getName()));\n                        });\n                        return matchesIdentifier.get() && areMatchingTypes(type, componentValue.getType());\n                    };\n        }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n        public void onComplexChildCollection(Class<?> type, Optional<String> wrapperIdentifier, Optional<Class<? extends Collection>> collectionTypeOptional)\n        {\n            Predicate<ComponentValue> matchesTypeAndIdentifierPredicate = getTypeAndIdentifierPredicate(type, wrapperIdentifier);\n            List<ComponentValue> matchingComponentValues = complexParameters.stream()\n                    .filter(matchesTypeAndIdentifierPredicate)\n                    .collect(toList());\n\n            matchingComponentValues.stream().forEach(beanDefinitionTypePair -> {\n                complexParameters.remove(beanDefinitionTypePair);\n            });\n            if (wrapperIdentifier.isPresent() && !matchingComponentValues.isEmpty())\n            {\n                this.value = matchingComponentValues.get(0).getBean();\n            }\n            else\n            {\n                if (!matchingComponentValues.isEmpty())\n                {\n                    this.value = constructManagedList(fromBeanDefinitionTypePairToBeanDefinition(matchingComponentValues), collectionTypeOptional);\n                }\n            }\n        }","id":101794,"modified_method":"@Override\n        public void onComplexChildCollection(Class<?> type, Optional<String> wrapperIdentifier, Optional<Class<? extends Collection>> collectionTypeOptional)\n        {\n            Predicate<ComponentValue> matchesTypeAndIdentifierPredicate = getTypeAndIdentifierPredicate(type, wrapperIdentifier);\n            List<ComponentValue> matchingComponentValues = complexParameters.stream()\n                    .filter(matchesTypeAndIdentifierPredicate)\n                    .collect(toList());\n\n            matchingComponentValues.stream().forEach(complexParameters::remove);\n            if (wrapperIdentifier.isPresent() && !matchingComponentValues.isEmpty())\n            {\n                this.value = matchingComponentValues.get(0).getBean();\n            }\n            else\n            {\n                if (!matchingComponentValues.isEmpty())\n                {\n                    this.value = constructManagedList(fromBeanDefinitionTypePairToBeanDefinition(matchingComponentValues), collectionTypeOptional);\n                }\n            }\n        }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public List<ComponentBuildingDefinition> getComponentBuildingDefinitions()\n    {\n        List<ComponentBuildingDefinition> definitions = new ArrayList<>();\n        definitions.add(new ComponentBuildingDefinition.Builder()\n                                .withNamespace(PARSERS_TEST_NAMESACE)\n                                .withIdentifier(\"parameter-collection-parser\")\n                                .withTypeDefinition(fromType(SimpleCollectionObject.class))\n                                .withSetterParameterDefinition(\"simpleParameters\", fromMultipleDefinitions(fromSimpleParameter(\"firstname\").build(),\n                                                                                                           fromSimpleParameter(\"lastname\").build(),\n                                                                                                           fromSimpleParameter(\"age\").build(),\n                                                                                                           fromChildConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"first-child\").build(),\n                                                                                                           fromChildConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"second-child\").build(),\n                                                                                                           fromChildCollectionConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"other-children\").build(),\n                                                                                                           fromChildCollectionConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"other-children-custom-collection-type\").withCollectionType(LinkedList.class).build())\n                                        .build())\n                                .build());\n        return definitions;\n    }","id":101795,"modified_method":"@Override\n    public List<ComponentBuildingDefinition> getComponentBuildingDefinitions()\n    {\n        List<ComponentBuildingDefinition> definitions = new ArrayList<>();\n        ComponentBuildingDefinition.Builder baseBuilder = new ComponentBuildingDefinition.Builder()\n                .withNamespace(PARSERS_TEST_NAMESACE);\n        definitions.add(baseBuilder\n                                .copy()\n                                .withIdentifier(\"parameter-collection-parser\")\n                                .withTypeDefinition(fromType(SimpleCollectionObject.class))\n                                .withSetterParameterDefinition(\"simpleTypeList\", fromChildCollectionConfiguration(String.class).withWrapperIdentifier(\"simple-type-child-list\").build())\n                                .withSetterParameterDefinition(\"simpleTypeSet\", fromChildCollectionConfiguration(String.class).withWrapperIdentifier(\"simple-type-child-set\").withCollectionType(HashSet.class).build())\n                                .withSetterParameterDefinition(\"simpleParameters\", fromMultipleDefinitions(\n                                        newBuilder()\n                                                .withAttributeDefinition(fromSimpleParameter(\"firstname\").build())\n                                                .withKey(\"firstname\")\n                                                .build(),\n                                        newBuilder()\n                                                .withAttributeDefinition(fromSimpleParameter(\"lastname\").build())\n                                                .withKey(\"lastname\")\n                                                .build(),\n                                        newBuilder()\n                                                .withAttributeDefinition(fromSimpleParameter(\"age\").build())\n                                                .withKey(\"age\")\n                                                .build(),\n                                        newBuilder()\n                                                .withAttributeDefinition(fromChildConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"first-child\").build())\n                                                .withKey(\"first-child\")\n                                                .build(),\n                                        newBuilder()\n                                                .withAttributeDefinition(fromChildConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"second-child\").build())\n                                                .withKey(\"second-child\")\n                                                .build(),\n                                        newBuilder()\n                                                .withAttributeDefinition(fromChildCollectionConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"other-children\").build())\n                                                .withKey(\"other-children\")\n                                                .build(),\n                                        newBuilder()\n                                                .withAttributeDefinition(fromChildCollectionConfiguration(SimpleCollectionObject.class).withWrapperIdentifier(\"other-children-custom-collection-type\").withCollectionType(LinkedList.class).build())\n                                                .withKey(\"other-children-custom-collection-type\")\n                                                .build(),\n                                        newBuilder()\n                                                .withAttributeDefinition(fromChildCollectionConfiguration(String.class).withWrapperIdentifier(\"other-simple-type-child-list\").build())\n                                                .withKey(\"other-simple-type-child-list-custom-key\")\n                                                .build())\n                                        .build())\n                                .build());\n\n        definitions.add(baseBuilder\n                                .copy()\n                                .withIdentifier(\"simple-type-child\")\n                                .withTypeDefinition(fromType(String.class))\n                                .build());\n\n        return definitions;\n    }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"public WrapperComponentConfig(ChildType childType, Optional<Class<? extends Collection>> collectionTypeOptional)\n    {\n        this.childType = childType;\n        this.collectionTypeOptional = collectionTypeOptional;\n    }","id":101796,"modified_method":"public WrapperComponentConfig(WrapperType wrapperType, Optional<Class<? extends Collection>> collectionTypeOptional)\n    {\n        this.wrapperType = wrapperType;\n        this.collectionTypeOptional = collectionTypeOptional;\n    }","commit_id":"0f0b4fd746f726abd77378bfcf25fffb02208740","url":"https://github.com/mulesoft/mule"},{"original_method":"private List<ComponentBuildingDefinition> getComponentsDefinitions() {\n    List<ComponentBuildingDefinition> buildingDefinitions = new ArrayList<>();\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"clazz\", fromSimpleParameter(\"class\").build())\n        .withSetterParameterDefinition(\"objectFactory\",\n                                       fromChildConfiguration(org.mule.runtime.core.api.object.ObjectFactory.class).build())\n        .withSetterParameterDefinition(\"entryPointResolverSet\", fromChildConfiguration(EntryPointResolverSet.class).build())\n        .withSetterParameterDefinition(\"entryPointResolver\", fromChildConfiguration(EntryPointResolver.class).build())\n        .withSetterParameterDefinition(\"lifecycleAdapterFactory\", fromChildConfiguration(LifecycleAdapterFactory.class).build())\n        .withSetterParameterDefinition(\"interceptors\", fromChildCollectionConfiguration(Interceptor.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"pooled-component\")\n        .withTypeDefinition(fromType(PooledJavaComponent.class))\n        .withObjectFactoryType(PooledComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"clazz\", fromSimpleParameter(\"class\").build())\n        .withSetterParameterDefinition(\"objectFactory\",\n                                       fromChildConfiguration(org.mule.runtime.core.api.object.ObjectFactory.class).build())\n        .withSetterParameterDefinition(\"entryPointResolverSet\", fromChildConfiguration(EntryPointResolverSet.class).build())\n        .withSetterParameterDefinition(\"entryPointResolver\", fromChildConfiguration(EntryPointResolver.class).build())\n        .withSetterParameterDefinition(\"lifecycleAdapterFactory\", fromChildConfiguration(LifecycleAdapterFactory.class).build())\n        .withSetterParameterDefinition(\"poolingProfile\", fromChildConfiguration(PoolingProfile.class).build())\n        .withSetterParameterDefinition(\"interceptors\", fromChildCollectionConfiguration(Interceptor.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"custom-interceptor\")\n        .withTypeDefinition(fromConfigurationAttribute(CLASS_ATTRIBUTE))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"timer-interceptor\")\n        .withTypeDefinition(fromType(TimerInterceptor.class))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"logging-interceptor\")\n        .withTypeDefinition(fromType(LoggingInterceptor.class))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"log-component\")\n        .withTypeDefinition(fromType(LogComponent.class))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"null-component\")\n        .withTypeDefinition(fromType(NullComponent.class))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"static-component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"usePrototypeObjectFactory\", fromFixedValue(false).build())\n        .withSetterParameterDefinition(\"clazz\", fromFixedValue(StaticComponent.class).build())\n        .withSetterParameterDefinition(\"staticData\", fromChildConfiguration(String.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"echo-component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"usePrototypeObjectFactory\", fromFixedValue(false).build())\n        .withSetterParameterDefinition(\"clazz\", fromFixedValue(EchoComponent.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"pooling-profile\")\n        .withTypeDefinition(fromType(PoolingProfile.class))\n        .withConstructorParameterDefinition(fromSimpleParameter(\"maxActive\").withDefaultValue(DEFAULT_MAX_POOL_ACTIVE).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"maxIdle\").withDefaultValue(DEFAULT_MAX_POOL_IDLE).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"maxWait\", value -> Long.valueOf((String) value))\n            .withDefaultValue(valueOf(DEFAULT_MAX_POOL_WAIT)).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"exhaustedAction\", POOL_EXHAUSTED_ACTIONS::get)\n            .withDefaultValue(valueOf(DEFAULT_POOL_EXHAUSTED_ACTION)).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"initialisationPolicy\", POOL_INITIALISATION_POLICIES::get)\n            .withDefaultValue(valueOf(DEFAULT_POOL_INITIALISATION_POLICY)).build())\n        .withSetterParameterDefinition(\"disabled\", fromSimpleParameter(\"disabled\").build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"return-data\")\n        .withTypeDefinition(fromType(String.class))\n        .build());\n\n\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(SINGLETON_OBJECT_ELEMENT)\n        .withTypeDefinition(fromType(SingletonObjectFactory.class))\n        .withConstructorParameterDefinition(fromSimpleParameter(CLASS_ATTRIBUTE, stringToClassConverter()).build())\n        .withConstructorParameterDefinition(fromChildConfiguration(Map.class).withDefaultValue(new HashMap<>()).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(PROTOTYPE_OBJECT_ELEMENT)\n        .withTypeDefinition(fromType(PrototypeObjectFactory.class))\n        .withConstructorParameterDefinition(fromSimpleParameter(CLASS_ATTRIBUTE, stringToClassConverter()).build())\n        .withConstructorParameterDefinition(fromChildConfiguration(Map.class).withDefaultValue(new HashMap<>()).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(\"spring-object\")\n        .withTypeDefinition(fromType(SpringBeanLookup.class))\n        .withSetterParameterDefinition(\"bean\", fromSimpleParameter(\"bean\").build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(\"custom-lifecycle-adapter-factory\")\n        .withTypeDefinition(fromConfigurationAttribute(CLASS_ATTRIBUTE))\n        .build());\n\n    return buildingDefinitions;\n  }","id":101797,"modified_method":"private List<ComponentBuildingDefinition> getComponentsDefinitions() {\n    List<ComponentBuildingDefinition> buildingDefinitions = new ArrayList<>();\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"clazz\", fromSimpleParameter(\"class\").build())\n        .withSetterParameterDefinition(\"objectFactory\",\n                                       fromChildConfiguration(org.mule.runtime.core.api.object.ObjectFactory.class).build())\n        .withSetterParameterDefinition(\"entryPointResolverSet\", fromChildConfiguration(EntryPointResolverSet.class).build())\n        .withSetterParameterDefinition(\"entryPointResolver\", fromChildConfiguration(EntryPointResolver.class).build())\n        .withSetterParameterDefinition(\"lifecycleAdapterFactory\", fromChildConfiguration(LifecycleAdapterFactory.class).build())\n        .withSetterParameterDefinition(\"interceptors\", fromChildCollectionConfiguration(Interceptor.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"pooled-component\")\n        .withTypeDefinition(fromType(PooledJavaComponent.class))\n        .withObjectFactoryType(PooledComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"clazz\", fromSimpleParameter(\"class\").build())\n        .withSetterParameterDefinition(\"objectFactory\",\n                                       fromChildConfiguration(org.mule.runtime.core.api.object.ObjectFactory.class).build())\n        .withSetterParameterDefinition(\"entryPointResolverSet\", fromChildConfiguration(EntryPointResolverSet.class).build())\n        .withSetterParameterDefinition(\"entryPointResolver\", fromChildConfiguration(EntryPointResolver.class).build())\n        .withSetterParameterDefinition(\"lifecycleAdapterFactory\", fromChildConfiguration(LifecycleAdapterFactory.class).build())\n        .withSetterParameterDefinition(\"poolingProfile\", fromChildConfiguration(PoolingProfile.class).build())\n        .withSetterParameterDefinition(\"interceptors\", fromChildCollectionConfiguration(Interceptor.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"custom-interceptor\")\n        .withTypeDefinition(fromConfigurationAttribute(CLASS_ATTRIBUTE))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"timer-interceptor\")\n        .withTypeDefinition(fromType(TimerInterceptor.class))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"logging-interceptor\")\n        .withTypeDefinition(fromType(LoggingInterceptor.class))\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"log-component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"usePrototypeObjectFactory\", fromFixedValue(false).build())\n        .withSetterParameterDefinition(\"clazz\", fromFixedValue(LogComponent.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"null-component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"usePrototypeObjectFactory\", fromFixedValue(false).build())\n        .withSetterParameterDefinition(\"clazz\", fromFixedValue(NullComponent.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"static-component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"usePrototypeObjectFactory\", fromFixedValue(false).build())\n        .withSetterParameterDefinition(\"clazz\", fromFixedValue(StaticComponent.class).build())\n        .withSetterParameterDefinition(\"staticData\", fromChildConfiguration(String.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"echo-component\")\n        .withTypeDefinition(fromType(DefaultJavaComponent.class))\n        .withObjectFactoryType(ComponentObjectFactory.class)\n        .withSetterParameterDefinition(\"usePrototypeObjectFactory\", fromFixedValue(false).build())\n        .withSetterParameterDefinition(\"clazz\", fromFixedValue(EchoComponent.class).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"pooling-profile\")\n        .withTypeDefinition(fromType(PoolingProfile.class))\n        .withConstructorParameterDefinition(fromSimpleParameter(\"maxActive\").withDefaultValue(DEFAULT_MAX_POOL_ACTIVE).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"maxIdle\").withDefaultValue(DEFAULT_MAX_POOL_IDLE).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"maxWait\", value -> Long.valueOf((String) value))\n            .withDefaultValue(valueOf(DEFAULT_MAX_POOL_WAIT)).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"exhaustedAction\", POOL_EXHAUSTED_ACTIONS::get)\n            .withDefaultValue(valueOf(DEFAULT_POOL_EXHAUSTED_ACTION)).build())\n        .withConstructorParameterDefinition(fromSimpleParameter(\"initialisationPolicy\", POOL_INITIALISATION_POLICIES::get)\n            .withDefaultValue(valueOf(DEFAULT_POOL_INITIALISATION_POLICY)).build())\n        .withSetterParameterDefinition(\"disabled\", fromSimpleParameter(\"disabled\").build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition\n        .copy()\n        .withIdentifier(\"return-data\")\n        .withTypeDefinition(fromType(String.class))\n        .build());\n\n\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(SINGLETON_OBJECT_ELEMENT)\n        .withTypeDefinition(fromType(SingletonObjectFactory.class))\n        .withConstructorParameterDefinition(fromSimpleParameter(CLASS_ATTRIBUTE, stringToClassConverter()).build())\n        .withConstructorParameterDefinition(fromChildConfiguration(Map.class).withDefaultValue(new HashMap<>()).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(PROTOTYPE_OBJECT_ELEMENT)\n        .withTypeDefinition(fromType(PrototypeObjectFactory.class))\n        .withConstructorParameterDefinition(fromSimpleParameter(CLASS_ATTRIBUTE, stringToClassConverter()).build())\n        .withConstructorParameterDefinition(fromChildConfiguration(Map.class).withDefaultValue(new HashMap<>()).build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(\"spring-object\")\n        .withTypeDefinition(fromType(SpringBeanLookup.class))\n        .withSetterParameterDefinition(\"bean\", fromSimpleParameter(\"bean\").build())\n        .build());\n\n    buildingDefinitions.add(baseDefinition.copy()\n        .withIdentifier(\"custom-lifecycle-adapter-factory\")\n        .withTypeDefinition(fromConfigurationAttribute(CLASS_ATTRIBUTE))\n        .build());\n\n    return buildingDefinitions;\n  }","commit_id":"6318111e43dccc484325befdb33eb7c60fb763f4","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n  public SearchResults find(SearchQuery query, @NotNull ProgressMonitor monitor) {\n    SearchResults<SNode> searchResults = new SearchResults<SNode>();\n    IHolder holder = query.getObjectHolder();\n    assert holder instanceof ModuleHolder;\n    SModule module = ((ModuleHolder) holder).getObject();\n    assert module instanceof Language;\n    Language language = (Language) module;\n    SModel structureModel = language.getStructureModelDescriptor();\n    if (structureModel == null) {\n      return searchResults;\n    }\n    if (IterableUtil.asCollection(structureModel.getRootNodes()).size() == 0) {\n      return searchResults;\n    }\n    List<SNode> roots = new LinkedList<SNode>();\n    for (SNode root : structureModel.getRootNodes()) {\n      roots.add(root);\n    }\n    searchResults.getSearchedNodes().addAll(roots);\n\n    monitor.start(\"\", IterableUtil.asCollection(structureModel.getRootNodes()).size() + 1);\n    try {\n      SearchResults<SModel> modelResults = FindUtils.getSearchResults(monitor.subTask(1), new SearchQuery(structureModel.getReference(), GlobalScopeMinusTransient.getInstance()), new ModelImportsUsagesFinder());\n      List<SModel> models = new ArrayList<SModel>();\n      for (SearchResult<SModel> sModelSearchResult : modelResults.getSearchResults()) {\n        models.add(sModelSearchResult.getObject());\n      }\n      SearchScope scope = new ModelsScope(models.toArray(new SModel[models.size()]));\n      SearchResults<SNode> results = new SearchResults();\n      for (SNode node : roots) {\n        if (monitor.isCanceled()) {\n          break;\n        }\n        results.addAll(FindUtils.getSearchResults(monitor.subTask(1), node, scope, \"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\"));\n        results.removeDuplicates();\n      }\n      searchResults.getSearchResults().addAll(results.getSearchResults());\n      return searchResults;\n    } finally {\n      monitor.done();\n    }\n  }","id":101798,"modified_method":"@Override\n  public SearchResults find(SearchQuery query, @NotNull ProgressMonitor monitor) {\n    SearchResults<SNode> searchResults = new SearchResults<SNode>();\n    Object value = query.getObjectHolder().getObject();\n    SModule module = null;\n    if (value instanceof SModule) {\n      module = ((SModule) value);\n    } else if (value instanceof SModuleReference) {\n      module = query.getScope().resolve(((SModuleReference) value));\n    }\n    if (!(module instanceof Language)) {\n      return searchResults;\n    }\n    Language language = (Language) module;\n    SModel structureModel = language.getStructureModelDescriptor();\n    if (structureModel == null) {\n      return searchResults;\n    }\n    if (!(structureModel.getRootNodes().iterator().hasNext())) {\n      return searchResults;\n    }\n    List<SNode> roots = new LinkedList<SNode>();\n    for (SNode root : structureModel.getRootNodes()) {\n      roots.add(root);\n    }\n    searchResults.getSearchedNodes().addAll(roots);\n\n    monitor.start(\"\", IterableUtil.asCollection(structureModel.getRootNodes()).size() + 1);\n    try {\n      SearchResults<SModel> modelResults = FindUtils.getSearchResults(monitor.subTask(1), new SearchQuery(structureModel.getReference(), GlobalScopeMinusTransient.getInstance()), new ModelImportsUsagesFinder());\n      List<SModel> models = new ArrayList<SModel>();\n      for (SearchResult<SModel> sModelSearchResult : modelResults.getSearchResults()) {\n        models.add(sModelSearchResult.getObject());\n      }\n      SearchScope scope = new ModelsScope(models.toArray(new SModel[models.size()]));\n      SearchResults<SNode> results = new SearchResults();\n      for (SNode node : roots) {\n        if (monitor.isCanceled()) {\n          break;\n        }\n        results.addAll(FindUtils.getSearchResults(monitor.subTask(1), node, scope, \"jetbrains.mps.lang.structure.findUsages.NodeUsages_Finder\"));\n        results.removeDuplicates();\n      }\n      searchResults.getSearchResults().addAll(results.getSearchResults());\n      return searchResults;\n    } finally {\n      monitor.done();\n    }\n  }","commit_id":"008a826653bfbebe311ab4c9c8dec78f241e8181","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    IHolder objectHolder = query.getObjectHolder();\n    if (!((objectHolder instanceof ModuleHolder))) {\n      return searchResults;\n    }\n    ModuleHolder moduleHolder = (ModuleHolder) objectHolder;\n    SModule searchedModule = moduleHolder.getObject();\n    if (searchedModule instanceof DevKit) {\n      for (Language devKiltLanguage : ((DevKit) searchedModule).getAllExportedLanguages()) {\n        SearchQuery innerQuery = new SearchQuery(devKiltLanguage, query.getScope());\n        searchResults.addAll(find(innerQuery, monitor));\n      }\n    }\n    if (!((searchedModule instanceof Language))) {\n      return searchResults;\n    }\n    Language language = (Language) searchedModule;\n    SearchScope scope = query.getScope();\n    if (scope instanceof GlobalScope) {\n      ModuleUsagesFinder moduleFinder = new ModuleUsagesFinder();\n      for (SModule module : (as_m2sz3c_a0a0b0j0d(scope, GlobalScope.class)).getModules()) {\n        if (monitor.isCanceled()) {\n          return searchResults;\n        }\n        if (module instanceof Solution) {\n          moduleFinder.collectUsagesInSolution(language, (Solution) module, searchResults);\n        }\n        if (module instanceof Language) {\n          moduleFinder.collectUsagesInLanguage(language, (Language) module, searchResults);\n          for (Generator g : ((Language) module).getGenerators()) {\n            moduleFinder.collectUsagesInGenerator(language, g, searchResults);\n          }\n        }\n        if (module instanceof DevKit) {\n          moduleFinder.collectUsagesInDevKit(language, (DevKit) module, searchResults);\n        }\n      }\n    } else if (query.getScope() instanceof ModelsScope) {\n      searchResults.getSearchedNodes().add(language);\n      for (SModel modelDescriptor : (as_m2sz3c_a0a0b0a9a3(query.getScope(), ModelsScope.class)).getModels()) {\n        collectUsagesInModel(language, modelDescriptor, searchResults);\n      }\n    }\n    return searchResults;\n  }","id":101799,"modified_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    Object value = query.getObjectHolder().getObject();\n    SModule searchedModule;\n    if (value instanceof SModule) {\n      searchedModule = ((SModule) value);\n    } else if (value instanceof SModuleReference) {\n      searchedModule = query.getScope().resolve(((SModuleReference) value));\n    } else {\n      return searchResults;\n    }\n    // FIXME likely it's smarter to unwrap devkit at the caller's, wrapped with CompositeFinder \n    if (searchedModule instanceof DevKit) {\n      for (Language devKiltLanguage : ((DevKit) searchedModule).getAllExportedLanguages()) {\n        SearchQuery innerQuery = new SearchQuery(devKiltLanguage, query.getScope());\n        searchResults.addAll(find(innerQuery, monitor));\n      }\n    }\n    if (!((searchedModule instanceof Language))) {\n      return searchResults;\n    }\n    Language language = (Language) searchedModule;\n    SearchScope scope = query.getScope();\n    if (scope instanceof GlobalScope) {\n      ModuleUsagesFinder moduleFinder = new ModuleUsagesFinder();\n      for (SModule module : (as_m2sz3c_a0a0b0j0d(scope, GlobalScope.class)).getModules()) {\n        if (monitor.isCanceled()) {\n          return searchResults;\n        }\n        if (module instanceof Solution) {\n          moduleFinder.collectUsagesInSolution(language, (Solution) module, searchResults);\n        }\n        if (module instanceof Language) {\n          moduleFinder.collectUsagesInLanguage(language, (Language) module, searchResults);\n          for (Generator g : ((Language) module).getGenerators()) {\n            moduleFinder.collectUsagesInGenerator(language, g, searchResults);\n          }\n        }\n        if (module instanceof DevKit) {\n          moduleFinder.collectUsagesInDevKit(language, (DevKit) module, searchResults);\n        }\n      }\n    } else if (query.getScope() instanceof ModelsScope) {\n      searchResults.getSearchedNodes().add(language);\n      for (SModel modelDescriptor : (as_m2sz3c_a0a0b0a9a3(query.getScope(), ModelsScope.class)).getModels()) {\n        collectUsagesInModel(language, modelDescriptor, searchResults);\n      }\n    }\n    return searchResults;\n  }","commit_id":"008a826653bfbebe311ab4c9c8dec78f241e8181","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n    @Override\n    protected FindAnActionButton getFindAnAction(JBTable table) {\n      return new FindAnActionButton(table) {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          final SearchQuery[] query = new SearchQuery[1];\n          final IResultProvider[] provider = new IResultProvider[1];\n          final SearchScope scope = new ModelsScope(myModelDescriptor);\n          myProject.getModelAccess().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              List<SModule> modules = new LinkedList<SModule>();\n              for (int i : myTable.getSelectedRows()) {\n                Object value = myUsedLangsTableModel.getValueAt(i, UsedLangsTableModel.ITEM_COLUMN);\n                if (value instanceof UsedLangsTableModel.Import) {\n                  // FIXME dedicated search for SLanguage\n                  final Import entry = (Import) value;\n                  if (entry.myLanguage != null) {\n                    modules.add(entry.myLanguage.getSourceModule());\n                  } else {\n                    final SModule devkit = entry.myDevKit.resolve(myProject.getRepository());\n                    if (devkit instanceof DevKit) {\n                      // FIXME update DevKit to use SLanguage\n                      modules.addAll(((DevKit) devkit).getAllExportedLanguages());\n                    }\n                  }\n                }\n              }\n              query[0] = new SearchQuery(new MyModulesHolder(modules), scope);\n              provider[0] = FindUtils.makeProvider(new LanguageUsagesFinder() {\n                @Override\n                public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n                  if (!(query.getObjectHolder() instanceof ModulesHolder))\n                    return super.find(query, monitor);\n\n                  SearchResults searchResults = new SearchResults();\n                  ModulesHolder modulesHolder = (ModulesHolder) query.getObjectHolder();\n                  for (SModule searchedModule : modulesHolder.getObject()) {\n                    SearchQuery searchQuery = new SearchQuery(searchedModule, query.getScope());\n                    searchResults.addAll(super.find(searchQuery, monitor));\n                  }\n\n                  return searchResults;\n                }\n              });\n            }\n          });\n          UsagesViewTool usagesViewTool = myProject.getComponent(UsagesViewTool.class);\n          usagesViewTool.findUsages(provider[0], query[0], true, true, true, \"No usages found\");\n          forceCancelCloseDialog();\n        }\n      };\n    }","id":101800,"modified_method":"@Nullable\n    @Override\n    protected FindAnActionButton getFindAnAction(JBTable table) {\n      return new FindAnActionButton(table) {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          final SearchQuery[] query = new SearchQuery[1];\n          final SearchScope scope = new ModelsScope(myModelDescriptor);\n          myProject.getModelAccess().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              List<SModule> modules = new LinkedList<SModule>();\n              for (int i : myTable.getSelectedRows()) {\n                Object value = myUsedLangsTableModel.getValueAt(i, UsedLangsTableModel.ITEM_COLUMN);\n                if (value instanceof UsedLangsTableModel.Import) {\n                  // FIXME dedicated search for SLanguage\n                  final Import entry = (Import) value;\n                  if (entry.myLanguage != null) {\n                    modules.add(entry.myLanguage.getSourceModule());\n                  } else {\n                    final SModule devkit = entry.myDevKit.resolve(myProject.getRepository());\n                    if (devkit instanceof DevKit) {\n                      // FIXME update DevKit to use SLanguage\n                      modules.addAll(((DevKit) devkit).getAllExportedLanguages());\n                    }\n                  }\n                }\n              }\n              query[0] = new SearchQuery(new MyModulesHolder(modules), scope);\n            }\n          });\n          final IResultProvider provider = FindUtils.makeProvider(new CompositeFinder(new LanguageUsagesFinder()));\n          UsagesViewTool usagesViewTool = myProject.getComponent(UsagesViewTool.class);\n          usagesViewTool.findUsages(provider, query[0], true, true, true, \"No usages found\");\n          forceCancelCloseDialog();\n        }\n      };\n    }","commit_id":"008a826653bfbebe311ab4c9c8dec78f241e8181","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SearchQuery(SModule module, SearchScope scope) {\n    this(new ModuleHolder(module), scope);\n  }","id":101801,"modified_method":"public SearchQuery(SModule module, SearchScope scope) {\n    this(new ModuleRefHolder(module.getModuleReference()), scope);\n  }","commit_id":"008a826653bfbebe311ab4c9c8dec78f241e8181","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults<SNode> find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults<SNode> results = new SearchResults<SNode>();\n    IHolder holder = query.getObjectHolder();\n    assert holder instanceof NodeHolder;\n    SNode node = ((NodeHolder) holder).getObject();\n    SConcept c = SConceptRepository.getInstance().getInstanceConcept(getConcept());\n    if (node.getConcept().isSubConceptOf(c) && isApplicable(node)) {\n      List<SNode> resSN = ListSequence.fromList(new ArrayList<SNode>());\n      getSearchedNodes(node, query.getScope(), resSN);\n      for (SNode resnode : resSN) {\n        results.getSearchedNodes().add(resnode);\n      }\n      List<SNode> res = new ArrayList<SNode>();\n      doFind(node, query.getScope(), res, monitor);\n      for (SNode resnode : res) {\n        results.getSearchResults().add(new SearchResult<SNode>(resnode, getNodeCategory(resnode)));\n      }\n    } else {\n      LOG.debug(\"Trying to use finder that is not applicable to the concept. Returning empty results.[finder: \\\"\" + getDescription() + \"\\\"; \" + \"concept: \" + node.getConcept().getQualifiedName());\n    }\n    return results;\n  }","id":101802,"modified_method":"@Override\n  public SearchResults<SNode> find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults<SNode> results = new SearchResults<SNode>();\n    Object value = query.getObjectHolder().getObject();\n    if (!(value instanceof SNode)) {\n      return results;\n    }\n    SNode node = (SNode) value;\n    SConcept c = SConceptRepository.getInstance().getInstanceConcept(getConcept());\n    if (node.getConcept().isSubConceptOf(c) && isApplicable(node)) {\n      List<SNode> resSN = ListSequence.fromList(new ArrayList<SNode>());\n      getSearchedNodes(node, query.getScope(), resSN);\n      for (SNode resnode : resSN) {\n        results.getSearchedNodes().add(resnode);\n      }\n      List<SNode> res = new ArrayList<SNode>();\n      doFind(node, query.getScope(), res, monitor);\n      for (SNode resnode : res) {\n        results.getSearchResults().add(new SearchResult<SNode>(resnode, getNodeCategory(resnode)));\n      }\n    } else {\n      LOG.debug(\"Trying to use finder that is not applicable to the concept. Returning empty results.[finder: \\\"\" + getDescription() + \"\\\"; \" + \"concept: \" + node.getConcept().getQualifiedName());\n    }\n    return results;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    for (SLanguage lang : LanguageUsagesFinder.getLanguageToLookUp(query)) {\n      // FIXME !!! refactor to look up SLanguage, not SModule, no reason to re-use ModuleUsagesFinder here, rather LanguageUsagesFinder \n      Language language = (Language) lang.getSourceModule();\n      SearchScope scope = query.getScope();\n      ModuleUsagesFinder moduleFinder = new ModuleUsagesFinder();\n      for (SModule module : scope.getModules()) {\n        if (monitor.isCanceled()) {\n          return searchResults;\n        }\n        if (module instanceof Solution) {\n          moduleFinder.collectUsagesInSolution(language, (Solution) module, searchResults);\n        }\n        if (module instanceof Language) {\n          moduleFinder.collectUsagesInLanguage(language, (Language) module, searchResults);\n          for (Generator g : ((Language) module).getGenerators()) {\n            moduleFinder.collectUsagesInGenerator(language, g, searchResults);\n          }\n        }\n        if (module instanceof DevKit) {\n          moduleFinder.collectUsagesInDevKit(language, (DevKit) module, searchResults);\n        }\n      }\n    }\n    return searchResults;\n  }","id":101803,"modified_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    for (SLanguage lang : LanguageUsagesFinder.getLanguageToLookUp(query)) {\n      // FIXME !!! refactor to look up SLanguage, not SModule, no reason to re-use ModuleUsagesFinder here, rather LanguageUsagesFinder \n      Language language = (Language) lang.getSourceModule();\n      searchResults.getSearchedNodes().add(lang);\n      SearchScope scope = query.getScope();\n      ModuleUsagesFinder moduleFinder = new ModuleUsagesFinder();\n      for (SModule module : scope.getModules()) {\n        if (monitor.isCanceled()) {\n          return searchResults;\n        }\n        if (module instanceof Solution) {\n          moduleFinder.collectUsagesInSolution(language, (Solution) module, searchResults);\n        }\n        if (module instanceof Language) {\n          moduleFinder.collectUsagesInLanguage(language, (Language) module, searchResults);\n          for (Generator g : ((Language) module).getGenerators()) {\n            moduleFinder.collectUsagesInGenerator(language, g, searchResults);\n          }\n        }\n        if (module instanceof DevKit) {\n          moduleFinder.collectUsagesInDevKit(language, (DevKit) module, searchResults);\n        }\n      }\n    }\n    return searchResults;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    HashSet<SLanguage> languages = new HashSet<SLanguage>(getLanguageToLookUp(query));\n\n    Collection<SModel> models = IterableUtil.asCollection(query.getScope().getModels());\n    monitor.start(\"Look up instances of language concepts\", models.size());\n    for (SModel model : models) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n      if (!(SModelStereotype.isUserModel(model))) {\n        continue;\n      }\n\n      for (SNode node : SNodeUtil.getDescendants(model)) {\n        if (languages.contains(node.getConcept().getLanguage())) {\n          searchResults.add(new SearchResult<SNode>(node, NODES_IN_LANGUAGE));\n        }\n      }\n      monitor.advance(1);\n    }\n    monitor.done();\n    return searchResults;\n  }","id":101804,"modified_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    HashSet<SLanguage> languages = new HashSet<SLanguage>(getLanguageToLookUp(query));\n    searchResults.getSearchedNodes().addAll(languages);\n    Collection<SModel> models = IterableUtil.asCollection(query.getScope().getModels());\n    monitor.start(\"Look up instances of language concepts\", models.size());\n    for (SModel model : models) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n      if (!(SModelStereotype.isUserModel(model))) {\n        continue;\n      }\n\n      for (SNode node : SNodeUtil.getDescendants(model)) {\n        if (languages.contains(node.getConcept().getLanguage())) {\n          searchResults.add(new SearchResult<SNode>(node, NODES_IN_LANGUAGE));\n        }\n      }\n      monitor.advance(1);\n    }\n    monitor.done();\n    return searchResults;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults<SModel> searchResults = new SearchResults<SModel>();\n    Object value = query.getObjectHolder().getObject();\n    if (!(value instanceof SModelReference)) {\n      return searchResults;\n    }\n    SModelReference modelReference = (SModelReference) value;\n    Set<SModel> usages = FindUsagesFacade.getInstance().findModelUsages(query.getScope(), Collections.singleton(modelReference), monitor);\n    for (SModel modelDescriptor : usages) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n      if (!(SModelStereotype.isUserModel(modelDescriptor))) {\n        continue;\n      }\n      searchResults.getSearchResults().add(new SearchResult<SModel>(modelDescriptor, \"usages in imports\"));\n    }\n    return searchResults;\n  }","id":101805,"modified_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults<SModel> searchResults = new SearchResults<SModel>();\n    Object value = query.getObjectHolder().getObject();\n    if (!(value instanceof SModelReference)) {\n      return searchResults;\n    }\n    SModelReference modelReference = (SModelReference) value;\n    searchResults.getSearchedNodes().add(modelReference);\n    Set<SModel> usages = FindUsagesFacade.getInstance().findModelUsages(query.getScope(), Collections.singleton(modelReference), monitor);\n    for (SModel modelDescriptor : usages) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n      if (!(SModelStereotype.isUserModel(modelDescriptor))) {\n        continue;\n      }\n      searchResults.add(new SearchResult<SModel>(modelDescriptor, \"usages in imports\"));\n    }\n    return searchResults;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults<SNode> searchResults = new SearchResults<SNode>();\n    Object value = query.getObjectHolder().getObject();\n    if (!(value instanceof SModelReference)) {\n      return searchResults;\n    }\n    SModelReference modelReference = (SModelReference) value;\n\n    Collection<SModel> models = IterableUtil.asCollection(query.getScope().getModels());\n    monitor.start(\"Looking up references to a model\", models.size());\n    for (SModel modelDescriptor : models) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n      if (!(SModelStereotype.isUserModel(modelDescriptor))) {\n        continue;\n      }\n      for (SNode node : SNodeUtil.getDescendants(modelDescriptor)) {\n        for (SReference reference : node.getReferences()) {\n          SModelReference targetModelReference = reference.getTargetSModelReference();\n          if (targetModelReference == null) {\n            continue;\n          }\n          if (targetModelReference.equals(modelReference)) {\n            searchResults.getSearchResults().add(new SearchResult<SNode>(node, \"nodes from model\"));\n          }\n        }\n      }\n      monitor.advance(1);\n    }\n    monitor.done();\n    return searchResults;\n  }","id":101806,"modified_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults<SNode> searchResults = new SearchResults<SNode>();\n    Object value = query.getObjectHolder().getObject();\n    if (!(value instanceof SModelReference)) {\n      return searchResults;\n    }\n    SModelReference modelReference = (SModelReference) value;\n    searchResults.getSearchedNodes().add(modelReference);\n    Collection<SModel> models = IterableUtil.asCollection(query.getScope().getModels());\n    monitor.start(\"Looking up references to a model\", models.size());\n    for (SModel modelDescriptor : models) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n      if (!(SModelStereotype.isUserModel(modelDescriptor))) {\n        continue;\n      }\n      for (SNode node : SNodeUtil.getDescendants(modelDescriptor)) {\n        for (SReference reference : node.getReferences()) {\n          SModelReference targetModelReference = reference.getTargetSModelReference();\n          if (targetModelReference == null) {\n            continue;\n          }\n          if (targetModelReference.equals(modelReference)) {\n            searchResults.getSearchResults().add(new SearchResult<SNode>(node, \"nodes from model\"));\n          }\n        }\n      }\n      monitor.advance(1);\n    }\n    monitor.done();\n    return searchResults;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    Object value = query.getObjectHolder().getObject();\n    SModule searchedModule = null;\n    if (value instanceof SModule) {\n      searchedModule = ((SModule) value);\n    } else if (value instanceof SModuleReference) {\n      SModuleReference moduleRef = (SModuleReference) value;\n      searchedModule = query.getScope().resolve(moduleRef);\n    }\n    if (searchedModule == null) {\n      return searchResults;\n    }\n    Collection<SModule> modules = IterableUtil.asCollection(query.getScope().getModules());\n    monitor.start(\"Looking up module uses\", modules.size());\n    for (SModule module : modules) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n\n      if (module instanceof Solution) {\n        collectUsagesInSolution(searchedModule, (Solution) module, searchResults);\n      } else if (module instanceof Language) {\n        collectUsagesInLanguage(searchedModule, (Language) module, searchResults);\n      } else if (module instanceof DevKit) {\n        collectUsagesInDevKit(searchedModule, (DevKit) module, searchResults);\n      } else if (module instanceof Generator) {\n        collectUsagesInGenerator(searchedModule, (Generator) module, searchResults);\n      }\n      monitor.advance(1);\n    }\n    monitor.done();\n    return searchResults;\n  }","id":101807,"modified_method":"@Override\n  public SearchResults find(SearchQuery query, ProgressMonitor monitor) {\n    SearchResults searchResults = new SearchResults();\n    Object value = query.getObjectHolder().getObject();\n    SModule searchedModule = null;\n    if (value instanceof SModule) {\n      searchedModule = ((SModule) value);\n    } else if (value instanceof SModuleReference) {\n      SModuleReference moduleRef = (SModuleReference) value;\n      searchedModule = query.getScope().resolve(moduleRef);\n    }\n    if (searchedModule == null) {\n      return searchResults;\n    }\n    searchResults.getSearchedNodes().add(searchedModule);\n    Collection<SModule> modules = IterableUtil.asCollection(query.getScope().getModules());\n    monitor.start(\"Looking up module uses\", modules.size());\n    for (SModule module : modules) {\n      if (monitor.isCanceled()) {\n        return searchResults;\n      }\n\n      if (module instanceof Solution) {\n        collectUsagesInSolution(searchedModule, (Solution) module, searchResults);\n      } else if (module instanceof Language) {\n        collectUsagesInLanguage(searchedModule, (Language) module, searchResults);\n      } else if (module instanceof DevKit) {\n        collectUsagesInDevKit(searchedModule, (DevKit) module, searchResults);\n      } else if (module instanceof Generator) {\n        collectUsagesInGenerator(searchedModule, (Generator) module, searchResults);\n      }\n      monitor.advance(1);\n    }\n    monitor.done();\n    return searchResults;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void removeDuplicates() {\n    mySearchResults = new ArrayList(new LinkedHashSet(mySearchResults));\n  }","id":101808,"modified_method":"public void removeDuplicates() {\n    mySearchResults = new ArrayList<SearchResult<T>>(new LinkedHashSet<SearchResult<T>>(mySearchResults));\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<T> getAliveNodes() {\n    Set<T> alive = new HashSet<T>();\n    for (T node : mySearchedNodes) {\n      if (node != null) {\n        alive.add(node);\n      }\n    }\n    return alive;\n  }","id":101809,"modified_method":"public Set<?> getAliveNodes() {\n    Set<Object> alive = new HashSet<Object>();\n    for (Object node : mySearchedNodes) {\n      if (node != null) {\n        alive.add(node);\n      }\n    }\n    return alive;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SearchResults(Set<T> searchedNodes, List<SearchResult<T>> searchResults) {\n    mySearchedNodes = searchedNodes;\n    mySearchResults = searchResults;\n  }","id":101810,"modified_method":"public SearchResults(Set<?> searchedNodes, List<SearchResult<T>> searchResults) {\n    mySearchedNodes = new HashSet<Object>(searchedNodes);\n    mySearchResults = searchResults;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SearchResults() {\n    mySearchedNodes = new HashSet<T>();\n    mySearchResults = new ArrayList<SearchResult<T>>();\n  }","id":101811,"modified_method":"public SearchResults() {\n    mySearchedNodes = new HashSet<Object>();\n    mySearchResults = new ArrayList<SearchResult<T>>();\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<T> getSearchedNodes() {\n    return mySearchedNodes;\n  }","id":101812,"modified_method":"public Set<Object> getSearchedNodes() {\n    // mySearchNodes lists elements we looked for; elements our results 'derived' from. They are not necessarily of the same \n    // kind as our results, hence we use <?>, not <T> (I don't feel there's reason introduce <E> as it \n    // (a) limits where we can look; (b) complicates the code \n    return mySearchedNodes;\n  }","commit_id":"3e9ed7d9b8aa16f2bb221ec8fca92c3e6474cafc","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void execute(Editor editor, DataContext dataContext){\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n\n    editor.setHeaderComponent(null);\n    if (project != null) {\n      if (((HighlightManagerImpl)HighlightManager.getInstance(project)).hideHighlights(editor, HighlightManager.HIDE_BY_ESCAPE |\n                                                                                               HighlightManager.HIDE_BY_ANY_KEY)) {\n        WindowManager.getInstance().getStatusBar(project).setInfo(\"\"); //??\n        FindManager findManager = FindManager.getInstance(project);\n        FindModel model = findManager.getFindNextModel(editor);\n        if (model != null) {\n          model.setSearchHighlighters(false);\n          findManager.setFindNextModel(model);\n        }\n        return;\n      }\n    }\n    myOriginalHandler.execute(editor, dataContext);\n  }","id":101813,"modified_method":"@Override\n  public void execute(Editor editor, DataContext dataContext){\n    editor.setHeaderComponent(null);\n\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project != null) {\n      HighlightManagerImpl highlightManager = (HighlightManagerImpl)HighlightManager.getInstance(project);\n      if (highlightManager != null && highlightManager.hideHighlights(editor, HighlightManager.HIDE_BY_ESCAPE | HighlightManager.HIDE_BY_ANY_KEY)) {\n\n        StatusBar statusBar = WindowManager.getInstance().getStatusBar(project);\n        if (statusBar != null) {\n          statusBar.setInfo(\"\");\n        }\n\n        FindManager findManager = FindManager.getInstance(project);\n        if (findManager != null) {\n          FindModel model = findManager.getFindNextModel(editor);\n          if (model != null) {\n            model.setSearchHighlighters(false);\n            findManager.setFindNextModel(model);\n          }\n        }\n\n        return;\n      }\n    }\n\n    myOriginalHandler.execute(editor, dataContext);\n  }","commit_id":"311c0d614597b638213635a74182b286400dad80","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isEnabled(Editor editor, DataContext dataContext) {\n    if (editor.hasHeaderComponent()) return true;\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n\n    if (project != null) {\n      HighlightManagerImpl highlightManager = (HighlightManagerImpl)HighlightManager.getInstance(project);\n      Map<RangeHighlighter, HighlightManagerImpl.HighlightInfo> map = highlightManager.getHighlightInfoMap(editor, false);\n\n      if (map != null) {\n        for (HighlightManagerImpl.HighlightInfo info : map.values()) {\n          if (!info.editor.equals(editor)) continue;\n          if ((info.flags & HighlightManager.HIDE_BY_ESCAPE) != 0) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return myOriginalHandler.isEnabled(editor, dataContext);\n  }","id":101814,"modified_method":"@Override\n  public boolean isEnabled(Editor editor, DataContext dataContext) {\n    if (editor.hasHeaderComponent()) return true;\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n\n    if (project != null) {\n      HighlightManagerImpl highlightManager = (HighlightManagerImpl)HighlightManager.getInstance(project);\n      if (highlightManager != null) {\n        Map<RangeHighlighter, HighlightManagerImpl.HighlightInfo> map = highlightManager.getHighlightInfoMap(editor, false);\n        if (map != null) {\n          for (HighlightManagerImpl.HighlightInfo info : map.values()) {\n            if (!info.editor.equals(editor)) continue;\n            if ((info.flags & HighlightManager.HIDE_BY_ESCAPE) != 0) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return myOriginalHandler.isEnabled(editor, dataContext);\n  }","commit_id":"311c0d614597b638213635a74182b286400dad80","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void showDescriptionInStatusBar(boolean isIncluded, Component component, String description) {\n    IdeFrame frame = component instanceof IdeFrame\n                         ? (IdeFrame)component\n                         : (IdeFrame)SwingUtilities.getAncestorOfClass(IdeFrame.class, component);\n    if (frame != null) {\n      StatusBar statusBar = frame.getStatusBar();\n      if (isIncluded) {\n        statusBar.setInfo(description);\n      }\n      else {\n        statusBar.setInfo(null);\n      }\n    }\n  }","id":101815,"modified_method":"public static void showDescriptionInStatusBar(boolean isIncluded, Component component, String description) {\n    IdeFrame frame = component instanceof IdeFrame\n                         ? (IdeFrame)component\n                         : (IdeFrame)SwingUtilities.getAncestorOfClass(IdeFrame.class, component);\n    StatusBar statusBar;\n    if (frame != null && (statusBar = frame.getStatusBar()) != null) {\n      statusBar.setInfo(isIncluded ? description : null);\n    }\n  }","commit_id":"ced296df0c17be396162dcdcef3ea1c907621384","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setStatusBarText(String statusBarText) {\n    if (ApplicationManager.getApplication() == null) return; // makes this component work in UIDesigner preview.\n    final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    for (Project project : projects) {\n      WindowManager.getInstance().getStatusBar(project).setInfo(statusBarText);\n    }\n  }","id":101816,"modified_method":"private void setStatusBarText(String statusBarText) {\n    if (ApplicationManager.getApplication() == null) return; // makes this component work in UIDesigner preview.\n    final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    for (Project project : projects) {\n      final StatusBar bar = WindowManager.getInstance().getStatusBar(project);\n      if (bar != null) {\n        bar.setInfo(statusBarText);\n      }\n    }\n  }","commit_id":"b8f2df5559700a4e95dd6651f67a2403660f136b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * One rectangle left, add it and continue with its children.\n   * @param r parent rectangle\n   * @param level indicates level which is calculated\n   */\n  private void putRect(final MapRect r, final int level) {\n    rectangles.add(r);\n\n    // position, with and height calculated using sizes of former level\n    final int x = r.x + layout.x;\n    final int y = r.y + layout.y;\n    final int w = r.w - layout.w;\n    final int h = r.h - layout.h;\n\n    // skip too small rectangles and meta data in file systems\n    if((w < off && h < off) || w == 0 || h == 0 || GUIProp.mapfs && \n        ViewData.isLeaf(data, r.pre)) return;\n\n    final MapList ch = children(r.pre);\n    if(ch.size != 0) makeMap(new MapRect(x, y, w, h, r.pre, r.level + 1),\n        ch, 0, ch.size - 1, level + 1);\n  }","id":101817,"modified_method":"/**\n   * One rectangle left, add it and continue with its children.\n   * @param r parent rectangle\n   * @param level indicates level which is calculated\n   */\n  private void putRect(final MapRect r, final int level) {\n    rectangles.add(r);\n\n    // position, with and height calculated using sizes of former level\n    final int x = r.x + layout.x;\n    final int y = r.y + layout.y;\n    final int w = r.w - layout.w;\n    final int h = r.h - layout.h;\n\n    // skip too small rectangles and meta data in file systems\n//    if((w < off && h < off) || w == 0 || h == 0 || GUIProp.mapfs && \n//        ViewData.isLeaf(data, r.pre)) return;\n//    final MapList ch = children(r.pre);\n//    if(ch.size != 0) makeMap(new MapRect(x, y, w, h, r.pre, r.level + 1),\n//        ch, 0, ch.size - 1, level + 1);\n    // skip too small rectangles and leaf nodes (= meta data in deepfs)\n    if((w >= off || h >= off) && w > 0 && h > 0 && \n        (!GUIProp.mapfs || !ViewData.isLeaf(data, r.pre))) {\n      final MapList ch = children(r.pre);\n\n      if(ch.size != 0) makeMap(new MapRect(x, y, w, h, r.pre, r.level + 1),\n          ch, 0, ch.size - 1, level + 1);\n    }\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns all children of the specified node.\n   * @param par parent node\n   * @return children\n   */\n  private MapList children(final int par) {\n    final MapList list = new MapList();\n\n    final int kind = data.kind(par);\n    final int last = par + data.size(par, kind);\n    final boolean atts = GUIProp.mapatts && data.fs == null;\n    int p = par + (atts ? 1 : data.attSize(par, kind));\n    while(p < last) {\n      list.add(p);\n      p += data.size(p, data.kind(p));\n    }\n\n    // paint all children\n    if(list.size != 0) list.add(p);\n    return list;\n  }","id":101818,"modified_method":"/**\n   * Returns all children of the specified node.\n   * @param par parent node\n   * @return children\n   */\n  private MapList children(final int par) {\n    final MapList list = new MapList();\n\n    final int kind = data.kind(par);\n    final int last = par + data.size(par, kind);\n    final boolean atts = GUIProp.mapatts && data.fs == null;\n    int p = par + (atts ? 1 : data.attSize(par, kind));\n    while(p < last) {\n      list.add(p);\n      p += data.size(p, data.kind(p));\n    }\n\n    // paint all children\n//    if(list.size != 0) list.add(p);\n    return list;\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Adds all the sizes attribute of the nodes in the given list.\n   * @param l list of nodes\n   * @param start at element\n   * @param end here\n   * @return sum of the size attribute\n   */\n  private long addSizes(final IntList l, final int start, final int end) {\n    long sum = 0;\n    for (int i = start; i < end; i++) {\n      final byte[] val = data.attValue(data.sizeID, l.list[i]);\n      if(val != null) sum += Token.toLong(val);\n    }\n    return sum;\n  }","id":101819,"modified_method":"/**\n   * Adds all the sizes attribute of the nodes in the given list.\n   * @param l list of nodes\n   * @return sum of the size attribute\n   */\n  private long addSizes(final IntList l) {\n    long sum = 0;\n    for (int i = 0; i < l.size; i++) {\n      final byte[] val = data.attValue(data.sizeID, l.list[i]);\n      if(val != null) sum += Token.toLong(val);\n    }\n    return sum;\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns <= 1) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);  \n    } else {\n      final long parsize = data.fs != null ? addSizes(l, ns, ne) : 0;\n      int nn;\n      //System.out.println(l.toString());\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        // [JH] may first level layout should not be defined to splitalgo\n        nn = 0;\n        for (int i = 0; i < l.size; i++) {\n          nn += data.size(l.list[i], data.kind(l.list[i]));\n        }\n        l.initWeights(parsize, nn, data);\n        \n        final MapAlgo tmp = new SplitAlgo();\n        rects = tmp.calcMap(r, l, l.weight, ns, ne, level);\n      } else {\n        nn = l.list[ne] - l.list[ns];\n        // init weights of nodes\n        if(GUIProp.usetextlength) {\n          l.initWeights(textLen, nn);\n        } else l.initWeights(parsize, nn, data);\n        rects = algo.calcMap(r, l, l.weight, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(final MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","id":101820,"modified_method":"/**\n   * Recursively splits rectangles.\n   * @param r parent rectangle\n   * @param l children array\n   * @param ns start array position\n   * @param ne end array position\n   * @param level indicates level which is calculated\n   */\n  void makeMap(final MapRect r, final MapList l, final int ns, final int ne, \n      final int level) {\n    if(ne - ns == 0) {\n      // one rectangle left, add it and go deeper\n      r.pre = l.list[ns];\n      putRect(r, level);  \n    } else {\n      final long parsize = data.fs != null ? addSizes(l) : 0;\n      int nn;\n      ArrayList<MapRect> rects;\n      if(level == 0) {\n        // [JH] may first level layout should not be defined to splitalgo\n        // [JH] use textLen\n        nn = 0;\n        for (int i = 0; i < l.size; i++) {\n          nn += data.size(l.list[i], data.kind(l.list[i]));\n        }\n        l.initWeights(parsize, nn, data);\n        \n        final MapAlgo tmp = new SplitAlgo();\n        rects = tmp.calcMap(r, l, l.weight, ns, ne, level);\n      } else {\n        nn = l.list[ne] - l.list[ns] + \n            data.size(l.list[ne], data.kind(l.list[ne]));\n        \n        // init weights of nodes\n        if(GUIProp.usetextlength && data.fs == null) {\n          l.initWeights(textLen, nn, data);\n        } else l.initWeights(parsize, nn, data);\n        rects = algo.calcMap(r, l, l.weight, ns, ne, level);\n      }\n      // call recursion for next deeper levels\n      for(final MapRect rect : rects) putRect(rect, rect.level);\n    }\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Initializes the weights of each list using text lengths of nodes.\n   * @param textLen array holding pre vals to textlengths\n   * @param children number of children\n   */\n  void initWeights(final int[] textLen, final int children) {\n    weight = new double[list.length];\n    int[] nrchildren = new int[list.length];\n    int textSum = 0;\n    for(int i = 0; i < size - 1; i++) textSum += textLen[list[i]];\n    // only children\n    for(int i = 0; i < size - 1; i++) {\n      nrchildren[i] = list[i + 1] - list[i];\n      weight[i] = GUIProp.mapweight / 100d * textLen[list[i]] / textSum + \n          (1 - GUIProp.mapweight / 100d) * nrchildren[i] / children;\n    }\n  }","id":101821,"modified_method":"/**\n   * Initializes the weights of each list using text lengths of nodes.\n   * @param textLen array holding pre vals to textlengths\n   * @param children number of children\n   * @param data reference\n   */\n  void initWeights(final int[] textLen, final int children, final Data data) {\n    weight = new double[size];\n    int[] nrchildren = new int[size];\n    int textSum = 0;\n    for(int i = 0; i < size; i++) {\n      textSum += textLen[list[i]];\n    }\n    // only children\n    for(int i = 0; i < size; i++) {\n      nrchildren[i] = data.size(list[i], data.kind(list[i]));\n      if(nrchildren[i] < 0) System.out.println(nrchildren[i]);\n      weight[i] = GUIProp.mapweight / 100d * textLen[list[i]] / textSum + \n          (1 - GUIProp.mapweight / 100d) * nrchildren[i] / children;\n    }\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Initializes the weights of each list entry and stores it in an extra list.\n   * @param parsize reference size\n   * @param parchildren reference number of nodes\n   * @param data reference\n   * [JH] some weight problems occur displaying folders without any files and \n   * children\n   */\n  void initWeights(final long parsize, final int parchildren, final Data data) {\n    weight = new double[list.length];\n    int[] nrchildren = new int[list.length];\n    long[] sizes = new long[list.length];\n    int sizeP = GUIProp.mapweight;\n    \n    // only children\n    // [JH] gui.context.current() stores not existing node sometimes \n    // pre_val(last node) + 1?\n    if (GUIProp.mapweight == 0 || data.fs == null || !GUIProp.mapfs) {\n      for(int i = 0; i < size - 1; i++) {\n        nrchildren[i] = data.size(list[i], data.kind(list[i]));\n        weight[i] = nrchildren[i] * 1d / parchildren;\n      }\n    // use #children and size for weight\n    } else if (0 < GUIProp.mapweight && GUIProp.mapweight < 100 && \n        data.fs != null) {\n      for(int i = 0; i < size - 1; i++) {\n        sizes[i] = data.fs != null ? \n            Token.toLong(data.attValue(data.sizeID, list[i])) : 0;\n        nrchildren[i] = list[i + 1] - list[i];\n        weight[i] = sizeP / 100d * sizes[i] / parsize + \n            (1 - sizeP / 100d) * nrchildren[i] / parchildren;\n      }\n    // only sizes\n    } else if (GUIProp.mapweight == 100 && data.fs != null) {\n      for(int i = 0; i < size - 1; i++) {\n        sizes[i] = data.fs != null ? \n            Token.toLong(data.attValue(data.sizeID, list[i])) : 0;\n        weight[i] = sizes[i] * 1d / parsize;\n      }\n    }\n  }","id":101822,"modified_method":"/**\n   * Initializes the weights of each list entry and stores it in an extra list.\n   * @param parsize reference size\n   * @param parchildren reference number of nodes\n   * @param data reference\n   * [JH] some weight problems occur displaying folders without any files and \n   * children\n   */\n  void initWeights(final long parsize, final int parchildren, final Data data) {\n    weight = new double[size];\n    int[] nrchildren = new int[size];\n    long[] sizes = new long[size];\n    int sizeP = GUIProp.mapweight;\n    \n    if(size == 1) {\n      initWeights();\n      return;\n    }\n    \n    // only children\n    if (GUIProp.mapweight == 0 || data.fs == null || !GUIProp.mapfs) {\n      initWeights(parchildren, data);\n    // use #children and size for weight\n    } else if (0 < GUIProp.mapweight && GUIProp.mapweight < 100 && \n        data.fs != null) {\n      for(int i = 0; i < size; i++) {\n        if(data.attValue(data.sizeID, list[i]) != null) \n          sizes[i] = Token.toLong(data.attValue(data.sizeID, list[i]));\n        else {\n          sizes[i] = 0;\n        }\n        nrchildren[i] = data.size(list[i], data.kind(list[i]));\n        weight[i] = sizeP / 100d * sizes[i] / parsize + \n            (1 - sizeP / 100d) * nrchildren[i] / parchildren;\n      }\n    // only sizes\n    } else if (GUIProp.mapweight == 100 && data.fs != null) {\n      for(int i = 0; i < size; i++) {\n        if(data.attValue(data.sizeID, list[i]) != null) \n          sizes[i] = Token.toLong(data.attValue(data.sizeID, list[i]));\n        else  {\n          sizes[i] = 0;\n        }\n        weight[i] = sizes[i] * 1d / parsize;\n      }\n    }\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] weights, final int ns, final int ne, final int l) {\n    \n    // setting initial proportions\n    double xx = r.x;\n    double yy = r.y;\n    double ww = 0;\n    double hh = 0;\n\n    final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n    // calculate map for each rectangle on this level\n    for(int i = 0; i < ml.size - 1; i++) {      \n      if((l & 1) == 0) {\n        yy += hh;\n        hh = ml.weight[i] * r.h;\n        ww = r.w;\n      } else {\n        xx += ww;\n        ww = ml.weight[i] * r.w;\n        hh = r.h;\n      }\n      \n      if(ww > 0 && hh > 0) rects.add(new MapRect((int) xx, (int) yy, (int) ww, \n          (int) hh, ml.list[i], r.level));\n    }\n    return rects;\n  }","id":101823,"modified_method":"@Override\n  public ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] weights, final int ns, final int ne, final int l) {\n    \n    // setting initial proportions\n    double xx = r.x;\n    double yy = r.y;\n    double ww = 0;\n    double hh = 0;\n\n    final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n    // calculate map for each rectangle on this level\n    for(int i = 0; i < ml.size; i++) {      \n      if((l & 1) == 0) {\n        yy += hh;\n        hh = ml.weight[i] * r.h;\n        ww = r.w;\n      } else {\n        xx += ww;\n        ww = ml.weight[i] * r.w;\n        hh = r.h;\n      }\n      \n      if(ww > 0 && hh > 0) rects.add(new MapRect((int) xx, (int) yy, (int) ww, \n          (int) hh, ml.list[i], r.level));\n    }\n    return rects;\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Uses recursive SplitLayout algorithm to divide rectangles on one level.\n   * \n   * @param r parent rectangle\n   * @param ml children array\n   * @param w weights array\n   * @param ns start array position\n   * @param ne end array position\n   * @param l indicates level which is calculated\n   * @param sumweight weight of this recursion level\n   * @return ArrayList containing rectangles\n   */\n  private ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] w, final int ns, final int ne, final int l,\n      final double sumweight) {\n    if(ne - ns == 1) {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      rects.add(new MapRect(r, ml.list[ns], l));\n      return rects;\n    } else {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      double weight;\n      int ni = ns;\n  \n      // increment pivot until left rectangle contains more or equal\n      // than half the weight or leave with just setting it to ne - 1\n      weight = 0;\n      for(; ni < ne - 1; ni++)  {\n        if(weight >= sumweight / 2) break;\n        weight += w[ni];\n      }\n      \n      int xx = r.x;\n      int yy = r.y;\n      int ww = !(r.w > r.h) ? r.w : (int) (r.w * 1 / sumweight * weight);\n      int hh = r.w > r.h ? r.h : (int) (r.h * 1 / sumweight * weight);\n  \n      // paint both rectangles if enough space is left\n      if(ww > 0 && hh > 0 && weight > 0) rects.addAll(calcMap(\n          new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ns, ni, l, weight));\n      if(r.w > r.h) {\n        xx += ww;\n        ww = r.w - ww;\n      } else {\n        yy += hh;\n        hh = r.h - hh;\n      }\n\n      if(ww > 0 && hh > 0 && sumweight - weight > 0) rects.addAll(calcMap(\n          new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ni, ne, l, sumweight - weight));\n      \n      return rects;\n    }\n  }","id":101824,"modified_method":"/**\n   * Uses recursive SplitLayout algorithm to divide rectangles on one level.\n   * \n   * @param r parent rectangle\n   * @param ml children array\n   * @param w weights array\n   * @param ns start array position\n   * @param ne end array position\n   * @param l indicates level which is calculated\n   * @param sumweight weight of this recursion level\n   * @return ArrayList containing rectangles\n   */\n  private ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] w, final int ns, final int ne, final int l,\n      final double sumweight) {\n    if(ne - ns == 0) {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      rects.add(new MapRect(r, ml.list[ns], l));\n      return rects;\n    } else {\n      final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n      double weight;\n      int ni = ns - 1;\n  \n      // increment pivot until left rectangle contains more or equal\n      // than half the weight or leave with just setting it to ne - 1\n      weight = 0;\n      for(; ni < ne;) {\n        weight += w[++ni];\n        if(weight >= sumweight / 2 || ni == ne - 1) break;\n      }\n      \n      int xx = r.x;\n      int yy = r.y;\n      int ww = !(r.w > r.h) ? r.w : (int) (r.w * 1 / sumweight * weight);\n      int hh = r.w > r.h ? r.h : (int) (r.h * 1 / sumweight * weight);\n      // paint both rectangles if enough space is left\n      if(ww > 0 && hh > 0 && weight > 0) rects.addAll(calcMap(\n          new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ns, ni, l, weight));\n      if(r.w > r.h) {\n        xx += ww;\n        ww = r.w - ww;\n      } else {\n        yy += hh;\n        hh = r.h - hh;\n      }\n      if(ww > 0 && hh > 0 && sumweight - weight > 0) rects.addAll(calcMap(\n          new MapRect(xx, yy, ww, hh, 0, r.level), \n          ml, w, ni + 1, ne, l, sumweight - weight));\n      \n      return rects;\n    }\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] weights, final int ns, final int ne, final int l) {\n\n    ml.sort();\n    \n    final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n    int ni = ns;\n    // running start holding first element of current row\n    int start = ns;\n\n    // setting initial proportions\n    double xx = r.x;\n    double yy = r.y;\n    double ww = r.w;\n    double hh = r.h;\n    \n    ArrayList<MapRect> row = new ArrayList<MapRect>();\n    double height = 0;\n    double width = 0;\n    double weight = 0;\n    double sumweight = 1;\n    \n    while(ni < ne) {\n      if(ww < hh) {\n        weight += ml.weight[ni];\n        height = weight / sumweight * hh;\n        \n        final ArrayList<MapRect> tmp = new ArrayList<MapRect>();\n\n        double x = xx;\n        for(int i = start; i <= ni; i++) {\n          final double w = i == ni ? xx + ww - x : ml.weight[i] / weight * ww;\n          tmp.add(new MapRect((int) x, (int) yy, (int) w, (int) height,\n              ml.list[i], l));\n          x += (int) w;\n        }\n\n        // if ar has increased discard tmp and add row\n        if(lineRatio(tmp) > lineRatio(row)) {\n          // add rects of row to solution\n          rects.addAll(row);\n          // preparing next line\n          hh -= row.get(0).h;\n          yy += row.get(0).h;\n          tmp.clear();\n          row.clear();\n          start = ni;\n          sumweight -= weight - ml.weight[ni];\n          weight = 0;\n          // sometimes there has to be one rectangles to fill the left space\n          if(ne == ni + 1) {\n            row.add(new MapRect((int) xx, (int) yy, (int) ww, (int) hh,\n                ml.list[ni], l));\n            break;\n          }\n        } else {\n          row = tmp;\n          ni++;\n        }\n      } else {\n        weight += ml.weight[ni];\n        width = weight / sumweight * ww;\n        final ArrayList<MapRect> tmp = new ArrayList<MapRect>();\n\n        double y = yy;\n        for(int i = start; i <= ni; i++) {\n          final double h = i == ni ? yy + hh - y : ml.weight[i] / weight * hh;\n          tmp.add(new MapRect((int) xx, (int) y, (int) width, (int) h,\n              ml.list[i], l));\n          y += (int) h;\n        }\n\n        // if ar has increased discard tmp and add row\n        if(lineRatio(tmp) > lineRatio(row)) {\n          // add rects of row to solution\n          rects.addAll(row);\n          // preparing next line\n          ww -= row.get(0).w;\n          xx += row.get(0).w;\n          tmp.clear();\n          row.clear();\n          start = ni;\n          sumweight -= weight - ml.weight[ni];\n          weight = 0;\n          // sometimes there has to be one rectangles to fill the left space\n          if(ne == ni + 1) {\n            row.add(new MapRect((int) xx, (int) yy, (int) ww, (int) hh,\n                ml.list[ni], l));\n            break;\n          }\n        } else {\n          row = tmp;\n          ni++;\n        }\n      }\n    }\n    \n    for(final MapRect rect : row) rect.h = (int) hh;\n    // adding last row\n    rects.addAll(row);\n    \n    return rects;\n  }","id":101825,"modified_method":"@Override\n  public ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] weights, final int ns, final int ne, final int l) {\n\n    ml.sort();\n    \n    final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n    int ni = ns;\n    // running start holding first element of current row\n    int start = ns;\n\n    // setting initial proportions\n    double xx = r.x;\n    double yy = r.y;\n    double ww = r.w;\n    double hh = r.h;\n    \n    ArrayList<MapRect> row = new ArrayList<MapRect>();\n    double height = 0;\n    double width = 0;\n    double weight = 0;\n    double sumweight = 1;\n    \n    while(ni <= ne) {\n      if(ww < hh) {\n        weight += ml.weight[ni];\n        height = weight / sumweight * hh;\n        \n        final ArrayList<MapRect> tmp = new ArrayList<MapRect>();\n\n        double x = xx;\n        for(int i = start; i <= ni; i++) {\n          final double w = i == ni ? xx + ww - x : ml.weight[i] / weight * ww;\n          tmp.add(new MapRect((int) x, (int) yy, (int) w, (int) height,\n              ml.list[i], l));\n          x += (int) w;\n        }\n\n        // if ar has increased discard tmp and add row\n        if(lineRatio(tmp) > lineRatio(row)) {\n          // add rects of row to solution\n          rects.addAll(row);\n          // preparing next line\n          hh -= row.get(0).h;\n          yy += row.get(0).h;\n          tmp.clear();\n          row.clear();\n          start = ni;\n          sumweight -= weight - ml.weight[ni];\n          weight = 0;\n          // sometimes there has to be one rectangles to fill the left space\n          if(ne == ni + 1) {\n            row.add(new MapRect((int) xx, (int) yy, (int) ww, (int) hh,\n                ml.list[ni], l));\n            break;\n          }\n        } else {\n          row = tmp;\n          ni++;\n        }\n      } else {\n        weight += ml.weight[ni];\n        width = weight / sumweight * ww;\n        final ArrayList<MapRect> tmp = new ArrayList<MapRect>();\n\n        double y = yy;\n        for(int i = start; i <= ni; i++) {\n          final double h = i == ni ? yy + hh - y : ml.weight[i] / weight * hh;\n          tmp.add(new MapRect((int) xx, (int) y, (int) width, (int) h,\n              ml.list[i], l));\n          y += (int) h;\n        }\n\n        // if ar has increased discard tmp and add row\n        if(lineRatio(tmp) > lineRatio(row)) {\n          // add rects of row to solution\n          rects.addAll(row);\n          // preparing next line\n          ww -= row.get(0).w;\n          xx += row.get(0).w;\n          tmp.clear();\n          row.clear();\n          start = ni;\n          sumweight -= weight - ml.weight[ni];\n          weight = 0;\n          // sometimes there has to be one rectangles to fill the left space\n          if(ne == ni + 1) {\n            row.add(new MapRect((int) xx, (int) yy, (int) ww, (int) hh,\n                ml.list[ni], l));\n            break;\n          }\n        } else {\n          row = tmp;\n          ni++;\n        }\n      }\n    }\n    \n    for(final MapRect rect : row) rect.h = (int) hh;\n    // adding last row\n    rects.addAll(row);\n    \n    return rects;\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] weights, final int ns, final int ne, final int l) {\n    // stores all calculated rectangles\n    final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n    \n    // node iterator\n    int ni = ns;\n    // first node of current row\n    int start = ns;\n\n    // setting initial proportions\n    final double xx = r.x;\n    double yy = r.y;\n    final double ww = r.w;\n    double hh = r.h;\n\n    ArrayList<MapRect> row = new ArrayList<MapRect>();\n    double height = 0;\n    double weight = 0;\n    double sumweight = 1;\n    \n    while(ni < ne) {\n      weight += ml.weight[ni];\n      height = weight / sumweight * hh;\n      \n      final ArrayList<MapRect> tmp = new ArrayList<MapRect>();\n\n      double x = xx;\n      for(int i = start; i <= ni; i++) {\n        final double w = i == ni ? xx + ww - x : ml.weight[i] / weight * ww;\n        tmp.add(new MapRect((int) x, (int) yy, (int) w, (int) height,\n            ml.list[i], l));\n        x += (int) w;\n      }\n\n      // if ar has increased discard tmp and add row\n      if(lineRatio(tmp) > lineRatio(row)) {\n        // add rects of row to solution\n        rects.addAll(row);\n        // preparing next line\n        hh -= row.get(0).h;\n        yy += row.get(0).h;\n        tmp.clear();\n        row.clear();\n        start = ni;\n        sumweight -= weight - ml.weight[ni];\n        weight = 0;\n        // sometimes there has to be one rectangles to fill the left space\n        if(ne == ni + 1) {\n          row.add(new MapRect((int) xx, (int) yy, (int) ww, (int) hh,\n              ml.list[ni], l));\n          break;\n        }\n      } else {\n        row = tmp;\n        ni++;\n      }\n    }\n    for(final MapRect rect : row) rect.h = (int) hh;\n    // adding last row\n    rects.addAll(row);\n    \n    return rects;\n  }","id":101826,"modified_method":"@Override\n  public ArrayList<MapRect> calcMap(final MapRect r, final MapList ml, \n      final double[] weights, final int ns, final int ne, final int l) {\n    // stores all calculated rectangles\n    final ArrayList<MapRect> rects = new ArrayList<MapRect>();\n    \n    // node iterator\n    int ni = ns;\n    // first node of current row\n    int start = ns;\n\n    // setting initial proportions\n    final double xx = r.x;\n    double yy = r.y;\n    final double ww = r.w;\n    double hh = r.h;\n\n    ArrayList<MapRect> row = new ArrayList<MapRect>();\n    double height = 0;\n    double weight = 0;\n    double sumweight = 1;\n    \n    while(ni <= ne) {\n      weight += ml.weight[ni];\n      height = weight / sumweight * hh;\n      \n      final ArrayList<MapRect> tmp = new ArrayList<MapRect>();\n\n      double x = xx;\n      for(int i = start; i <= ni; i++) {\n        final double w = i == ni ? xx + ww - x : ml.weight[i] / weight * ww;\n        tmp.add(new MapRect((int) x, (int) yy, (int) w, (int) height,\n            ml.list[i], l));\n        x += (int) w;\n      }\n\n      // if ar has increased discard tmp and add row\n      if(lineRatio(tmp) > lineRatio(row)) {\n        // add rects of row to solution\n        rects.addAll(row);\n        // preparing next line\n        hh -= row.get(0).h;\n        yy += row.get(0).h;\n        tmp.clear();\n        row.clear();\n        start = ni;\n        sumweight -= weight - ml.weight[ni];\n        weight = 0;\n        // sometimes there has to be one rectangles to fill the left space\n        if(ne == ni + 1) {\n          row.add(new MapRect((int) xx, (int) yy, (int) ww, (int) hh,\n              ml.list[ni], l));\n          break;\n        }\n      } else {\n        row = tmp;\n        ni++;\n      }\n    }\n    for(final MapRect rect : row) rect.h = (int) hh;\n    // adding last row\n    rects.addAll(row);\n    \n    return rects;\n  }","commit_id":"2c23579634b62b205876e4da9712a8aff2cfd232","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogMapLayout(final GUI main) {\r\n    super(main, MAPLAYOUTTITLE, false);\r\n    \r\n    final BaseXBack p = new BaseXBack();\r\n    // [JH] complete layout\r\n    p.setLayout(new TableLayout(9, 1, 0, 5));\r\n\r\n    // create list\r\n    choice = new BaseXListChooser(this, MAPLAYOUTCHOICE, HELPMAPLAYOUT);\r\n    choice.setSize(500, 300);\r\n    choice.setIndex(GUIProp.maplayout);\r\n    p.add(choice);\r\n\r\n    // create checkbox\r\n    simple = new BaseXCheckBox(MAPSIMPLE, HELPMAPSIMPLE,\r\n        GUIProp.mapsimple, 0, this);\r\n    p.add(simple);\r\n    atts = new BaseXCheckBox(MAPATTS, HELPMAPATTS, GUIProp.mapatts, this);\r\n    if(gui.context.data().fs != null) {\r\n      atts.setEnabled(false);\r\n    }\r\n    p.add(atts);\r\n    \r\n    // create drop down\r\n    BaseXBack tmpback = new BaseXBack();\r\n    tmpback.setLayout(new TableLayout(1, 2, 3, 5));\r\n    BaseXLabel label = new BaseXLabel(MAPPROPALGO);\r\n    tmpback.add(label);\r\n    propalgo = new BaseXCombo(new String[] {\"SplitLayout\", \r\n        \"SliceAndDice Layout\", \"SquarifiedLayout\", \"StripLayout\"}, HELPMODE, \r\n        false);\r\n    propalgo.setSelectedIndex(GUIProp.mapalgo);\r\n\r\n    propalgo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        final int s = propalgo.getSelectedIndex();\r\n        if(s == GUIProp.mapalgo || !propalgo.isEnabled()) return;\r\n        action(null);\r\n      }\r\n    });\r\n    tmpback.add(propalgo);\r\n    if(GUIProp.algchanger) {\r\n      p.add(tmpback);\r\n    }\r\n    // create slider\r\n    propLabel = new BaseXLabel(MAPPROP);\r\n    p.add(propLabel);\r\n    prop = new BaseXSlider(gui, -234, 248, GUIProp.mapprop, HELPMAPALIGN, this);\r\n    BaseXLayout.setWidth(prop, p.getPreferredSize().width);\r\n    p.add(prop);\r\n    set(p, BorderLayout.CENTER);\r\n    sizeLabel = new BaseXLabel(MAPSIZE);\r\n    sizeSlider = new BaseXSlider(gui, 0, 100, GUIProp.sizep, HELPMAPSIZE, this);\r\n    BaseXLayout.setWidth(sizeSlider, p.getPreferredSize().width);\r\n    \r\n    // add slider only to dialog if we are using fs data\r\n    if(gui.context.data().fs != null && GUIProp.fsslider) {\r\n      p.add(sizeLabel);\r\n      p.add(sizeSlider);\r\n    }\r\n    set(p, BorderLayout.CENTER);\r\n    \r\n    finish(GUIProp.maplayoutloc);\r\n    action(null);\r\n  }","id":101827,"modified_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogMapLayout(final GUI main) {\r\n    super(main, MAPLAYOUTTITLE, false);\r\n    \r\n    final BaseXBack p = new BaseXBack();\r\n    // [JH] complete layout\r\n    p.setLayout(new TableLayout(9, 1, 0, 5));\r\n\r\n    // create list\r\n    choice = new BaseXListChooser(this, MAPLAYOUTCHOICE, HELPMAPLAYOUT);\r\n    choice.setSize(500, 200);\r\n    choice.setIndex(GUIProp.maplayout);\r\n    p.add(choice);\r\n\r\n    // create checkbox\r\n//    simple = new BaseXCheckBox(MAPSIMPLE, HELPMAPSIMPLE,\r\n//        GUIProp.mapsimple, 0, this);\r\n//    p.add(simple);\r\n    atts = new BaseXCheckBox(MAPATTS, HELPMAPATTS, GUIProp.mapatts, this);\r\n    if(gui.context.data().fs != null) {\r\n      atts.setEnabled(false);\r\n    }\r\n    p.add(atts);\r\n    \r\n    // create drop down\r\n    BaseXBack tmpback = new BaseXBack();\r\n    tmpback.setLayout(new TableLayout(1, 2, 3, 5));\r\n    BaseXLabel label = new BaseXLabel(MAPPROPALGO);\r\n    tmpback.add(label);\r\n    propalgo = new BaseXCombo(new String[] {\"SplitLayout\", \r\n        \"SliceAndDice Layout\", \"SquarifiedLayout\", \"StripLayout\"}, HELPMODE, \r\n        false);\r\n    propalgo.setSelectedIndex(GUIProp.mapalgo);\r\n\r\n    propalgo.addActionListener(new ActionListener() {\r\n      public void actionPerformed(final ActionEvent e) {\r\n        final int s = propalgo.getSelectedIndex();\r\n        if(s == GUIProp.mapalgo || !propalgo.isEnabled()) return;\r\n        action(null);\r\n      }\r\n    });\r\n    tmpback.add(propalgo);\r\n    if(GUIProp.algchanger) {\r\n      p.add(tmpback);\r\n    }\r\n    // create slider\r\n    propLabel = new BaseXLabel(MAPPROP);\r\n    p.add(propLabel);\r\n    prop = new BaseXSlider(gui, -234, 248, GUIProp.mapprop, HELPMAPALIGN, this);\r\n    BaseXLayout.setWidth(prop, p.getPreferredSize().width);\r\n    p.add(prop);\r\n    set(p, BorderLayout.CENTER);\r\n    sizeLabel = new BaseXLabel(MAPSIZE);\r\n    sizeSlider = new BaseXSlider(gui, 0, 100, GUIProp.sizep, HELPMAPSIZE, this);\r\n    BaseXLayout.setWidth(sizeSlider, p.getPreferredSize().width);\r\n    \r\n    // add slider only to dialog if we are using fs data\r\n    if(gui.context.data().fs != null && GUIProp.fsslider) {\r\n      p.add(sizeLabel);\r\n      p.add(sizeSlider);\r\n    }\r\n    set(p, BorderLayout.CENTER);\r\n    \r\n    finish(GUIProp.maplayoutloc);\r\n    action(null);\r\n  }","commit_id":"c03285240b3df0321954f80af750a3cc230808ed","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void action(final String cmd) {\r\n    GUIProp.maplayout = choice.getIndex();\r\n    final int prp = prop.value();\r\n    GUIProp.mapprop = prp;\r\n    GUIProp.mapalgo = propalgo.getSelectedIndex();\r\n    GUIProp.mapsimple = simple.isSelected();\r\n    GUIProp.mapatts = atts.isSelected();\r\n    propLabel.setText(MAPPROP + \" \" + (prp > 2 && prp < 7 ? \"Centered\" :\r\n      prp < 3 ? \"Vertical\" : \"Horizontal\"));\r\n    final int sizeprp = sizeSlider.value();\r\n    GUIProp.sizep = sizeprp;\r\n    sizeLabel.setText(MAPSIZE + \" \" + (sizeprp > 45 && sizeprp < 55 ? \r\n      MAPBOTH :\r\n      sizeprp < 45 ?  MAPCHILDREN  : MAPFSSIZE));\r\n    gui.notify.layout();\r\n  }","id":101828,"modified_method":"@Override\r\n  public void action(final String cmd) {\r\n    GUIProp.maplayout = choice.getIndex();\r\n    final int prp = prop.value();\r\n    GUIProp.mapprop = prp;\r\n    GUIProp.mapalgo = propalgo.getSelectedIndex();\r\n//    GUIProp.mapsimple = simple.isSelected();\r\n    GUIProp.mapatts = atts.isSelected();\r\n    propLabel.setText(MAPPROP + \" \" + (prp > 2 && prp < 7 ? \"Centered\" :\r\n      prp < 3 ? \"Vertical\" : \"Horizontal\"));\r\n    final int sizeprp = sizeSlider.value();\r\n    GUIProp.sizep = sizeprp;\r\n    sizeLabel.setText(MAPSIZE + \" \" + (sizeprp > 45 && sizeprp < 55 ? \r\n      MAPBOTH :\r\n      sizeprp < 45 ?  MAPCHILDREN  : MAPFSSIZE));\r\n    gui.notify.layout();\r\n  }","commit_id":"c03285240b3df0321954f80af750a3cc230808ed","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  void calcMap(final Data data, final ViewRect r,\n      final ArrayList<ViewRect> mainRects, final IntList l,\n      final int ns, final int ne, final int level) {\n\n    // one rectangle left.. continue with this child\n    if(ne - ns == 1) {\n      putRect(data, r, mainRects, l, ns, level);\n      \n      /* replaced by putRect()\n      // calculate rectangle sizes\n      final ViewRect t = new ViewRect(r.x, r.y, r.w, r.h, l.list[ns], r.level);\n\n      // position, with and height are calculated using split sizes of\n      //  former recursion level\n      final int x = t.x + layout.x;\n      final int y = t.y + layout.y;\n      final int w = t.w - layout.w;\n      final int h = t.h - layout.h;\n      mainRects.add(t);\n      // skip too small rectangles and leaf nodes (= meta data in deepfs)\n      if(w > 0 && h > 0 && !ViewData.isLeaf(data, t.pre)) {\n        final IntList ch = children(data, t.pre);\n        if(ch.size >= 0) calcMap(data, new ViewRect(x, y, w, h,\n            l.list[ns], t.level + 1), mainRects, ch, 0, ch.size - 1, level + 1);\n      }*/\n    } else {\n      // number of nodes used to calculate rect size\n      int nn = ne - ns;\n\n      long parsize = 1;\n      int par;\n      par = data.parent(l.list[ns], Data.ELEM);\n      int parchilds;\n//      parchilds = children(data, par).size;\n      parchilds = l.list[ne] - l.list[ns];\n      \n      // determine direction\n      final boolean v = (level % 2) == 0 ? true : false;\n//      final boolean v = (r.w > r.h) ? false : true;\n\n      // setting initial proportions\n      double xx = r.x;\n      double yy = r.y;\n      double ww, hh;\n\n      // use filesize to calculate rect sizes\n      if(data.fs != null && GUIProp.mapaggr) {\n        parsize = data.fs != null ? \n            Token.toLong(data.attValue(par + FSParser.SIZEOFFSET)) : 0;\n        hh = 0;\n        ww = 0;\n      // [JH] remove this and use number of childs if not a fs\n      // problems occur while zooming into to thin rectangles\n      } else {\n        if(v) {\n          ww = r.w;\n          hh = (double) r.h / nn;\n        } else {\n          ww = (double) r.w / nn;\n          hh = r.h;\n        }\n      }\n\n      // calculate map for each rectangel on this level\n      for(int i = 0; i < l.size - 1; i++) {\n        int[] liste = new int[1];\n        liste[0] = l.list[i];\n        \n        // draw map taking sizes into account\n        // [JH] remove else statement\n        if(data.fs != null && GUIProp.mapaggr) {\n          long size = data.fs != null ? \n              Token.toLong(data.attValue(data.sizeID, l.list[i])) : 0;\n          int childs = l.list[i + 1] - l.list[i];\n          double weight = calcWeight(size, childs, parsize, parchilds, data);\n          \n//          if(Double.isNaN(weight)) System.out.println(\"[\" + l.list[i] + \"]\"\n//              + \"(\" + size + \";\" + childs + \"/\" + parsize + \";\" + parchilds + \n//              \")\" + weight);\n          if(v) {\n            yy += hh;\n              // old calculation\n//            hh = (double) size * r.h / parsize;\n            hh = weight * r.h;\n            ww = r.w;\n          } else {\n            xx += ww;\n            // old calculation\n//            ww = (double) size * r.w / parsize;\n            ww = weight * r.w;\n            hh = r.h;\n          }\n          if(ww > 0 && hh > 0) calcMap(data,\n            new ViewRect((int) xx, (int) yy, (int) ww, (int) hh, 0, r.level),\n            mainRects, new IntList(liste), 0, 1, level);\n        } else {\n          if(ww > 0 && hh > 0) {\n            if(v) {\n              calcMap(data, new ViewRect((int) xx, (int) yy, (int) ww, (int) hh,\n                0, r.level), mainRects, new IntList(liste), 0, 1, level);\n              yy += hh;\n            } else {\n              calcMap(data, new ViewRect((int) xx, (int) yy, (int) ww, (int) hh,\n                0, r.level), mainRects, new IntList(liste), 0, 1, level);\n              xx += ww;\n            }\n          }\n        }\n      }\n    }\n  }","id":101829,"modified_method":"@Override\n  void calcMap(final Data data, final ViewRect r,\n      final ArrayList<ViewRect> mainRects, final IntList l,\n      final int ns, final int ne, final int level) {\n\n    // one rectangle left.. continue with this child\n    if(ne - ns == 1) {\n      putRect(data, r, mainRects, l, ns, level);\n    } else {\n      // number of nodes used to calculate rect size\n      int nn = ne - ns;\n\n      long parsize = 1;\n      int par;\n      par = data.parent(l.list[ns], Data.ELEM);\n      int parchilds = l.list[ne] - l.list[ns];\n      \n      // determine direction\n      final boolean v = (level % 2) == 0 ? true : false;\n//      final boolean v = (r.w > r.h) ? false : true;\n\n      // setting initial proportions\n      double xx = r.x;\n      double yy = r.y;\n      double ww, hh;\n\n      // use filesize to calculate rect sizes\n      if(data.fs != null && GUIProp.mapaggr) {\n        parsize = data.fs != null ? \n            Token.toLong(data.attValue(data.sizeID, par)) : 0;\n        hh = 0;\n        ww = 0;\n      // [JH] remove this and use number of childs if not a fs\n      // problems occur while zooming into to thin rectangles\n      } else {\n        if(v) {\n          ww = r.w;\n          hh = (double) r.h / nn;\n        } else {\n          ww = (double) r.w / nn;\n          hh = r.h;\n        }\n      }\n\n      // calculate map for each rectangel on this level\n      for(int i = 0; i < l.size - 1; i++) {\n        int[] liste = new int[1];\n        liste[0] = l.list[i];\n        \n        // draw map taking sizes into account\n        // [JH] remove else statement\n        if(data.fs != null && GUIProp.mapaggr) {\n          long size = data.fs != null ? \n              Token.toLong(data.attValue(data.sizeID, l.list[i])) : 0;\n          int childs = l.list[i + 1] - l.list[i];\n          double weight = calcWeight(size, childs, parsize, parchilds, data);\n          \n//          if(Double.isNaN(weight)) System.out.println(\"[\" + l.list[i] + \"]\"\n//              + \"(\" + size + \";\" + childs + \"/\" + parsize + \";\" + parchilds + \n//              \")\" + weight);\n          if(v) {\n            yy += hh;\n            hh = weight * r.h;\n            ww = r.w;\n          } else {\n            xx += ww;\n            ww = weight * r.w;\n            hh = r.h;\n          }\n          if(ww > 0 && hh > 0) calcMap(data,\n            new ViewRect((int) xx, (int) yy, (int) ww, (int) hh, 0, r.level),\n            mainRects, new IntList(liste), 0, 1, level);\n        } else {\n          if(ww > 0 && hh > 0) {\n            if(v) {\n              calcMap(data, new ViewRect((int) xx, (int) yy, (int) ww, (int) hh,\n                0, r.level), mainRects, new IntList(liste), 0, 1, level);\n              yy += hh;\n            } else {\n              calcMap(data, new ViewRect((int) xx, (int) yy, (int) ww, (int) hh,\n                0, r.level), mainRects, new IntList(liste), 0, 1, level);\n              xx += ww;\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"c03285240b3df0321954f80af750a3cc230808ed","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  void calcMap(final Data data, final ViewRect r,\n      final ArrayList<ViewRect> mainRects, final IntList l,\n      final int ns, final int ne, final int level) {\n\n    // one rectangle left.. continue with this child\n    if(ne - ns == 1) {\n      putRect(data, r, mainRects, l, ns, level);\n      \n      /* replaced by putRect()\n      // calculate rectangle sizes\n      final ViewRect t = new ViewRect(r.x, r.y, r.w, r.h, l.list[ns], r.level);\n      mainRects.add(t);\n\n      // position, with and height calculated using sizes of former level\n      final int x = t.x + layout.x;\n      final int y = t.y + layout.y;\n      final int w = t.w - layout.w;\n      final int h = t.h - layout.h;\n\n      // skip too small rectangles and leaf nodes (= meta data in deepfs)\n      if((w >= o || h >= o) && w > 0 && h > 0 &&\n          !ViewData.isLeaf(data, t.pre)) {\n        final IntList ch = children(data, t.pre);\n        if(ch.size != 0) calcMap(data, new ViewRect(x, y, w, h, l.list[ns],\n            r.level + 1), mainRects, ch, 0, ch.size - 1, level + 1);\n      }*/\n    } else {\n      long nn, ln;\n      int ni;\n      // number of nodes used to calculate space\n      nn = ne - ns;\n      // nn / 2, pretends to be the middle of the handled list\n      // except if starting point in the list is not at position 0\n      ln = nn >> 1;\n      // pivot with integrated list start\n      ni = (int) (ns + ln);\n        // consider number of descendants to calculate split point\n      if(!GUIProp.mapsimple && level != 0) {\n        // calculating real number of nodes of this recursion\n        nn = l.list[ne] - l.list[ns];\n\n        // let pivot be the first element of the list\n        ni = ns;\n\n        if(data.fs != null && GUIProp.mapaggr) {\n          // parents size\n          int par = data.parent(l.list[ns], Data.ELEM);\n          long parsize = Token.toLong(data.attValue(data.sizeID, par));\n          // temporary to sum up the child sizes\n          long sum = 0;\n\n          // increment pivot until left rectangle contains more or equal\n          // than the half descendants or if left node is greater than half of\n          // all descendants leave with just setting it to ne - 1\n          for(; ni < ne - 1; ni++)  {\n            // use file sizes to calculate breakpoint\n            if(sum >= parsize / 2) break;\n            sum += Token.toLong(data.attValue(data.sizeID, l.list[ni]));\n          }\n          nn = parsize;\n          ln = sum;\n        } else {\n          // increment pivot until left rectangle contains more or equal\n          // than the half descendants or if left node is greater than half of\n          // all descendants leave with just setting it to ne - 1\n          for(; ni < ne - 1; ni++)  {\n            if(l.list[ni] - l.list[ns] >= (nn >> 1)) break;\n          }\n          ln = l.list[ni] - l.list[ns];\n        }\n      }\n\n      // determine rectangle orientation (horizontal/vertical)\n      // mapprop contains preferred alignment influence\n      final int p = GUIProp.mapprop;\n      final boolean v = p > 4 ? r.w > r.h * (p + 4) / 8 :\n        r.w * (13 - p) / 8 > r.h;\n\n      int xx = r.x;\n      int yy = r.y;\n\n      int ww = !v ? r.w : (int) (r.w * ln / nn);\n      int hh = v ? r.h : (int) (r.h * ln / nn);\n\n      // paint both rectangles if enough space is left\n      if(ww > 0 && hh > 0) calcMap(data, new ViewRect(xx, yy, ww, hh, 0,\n          r.level), mainRects, l, ns, ni, level);\n      if(v) {\n        xx += ww;\n        ww = r.w - ww;\n      } else {\n        yy += hh;\n        hh = r.h - hh;\n      }\n      if(ww > 0 && hh > 0) calcMap(data, new ViewRect(xx, yy, ww, hh, 0,\n          r.level), mainRects, l, ni, ne, level);\n    }\n  }","id":101830,"modified_method":"@Override\n  void calcMap(final Data data, final ViewRect r,\n      final ArrayList<ViewRect> mainRects, final IntList l,\n      final int ns, final int ne, final int level) {\n\n    // one rectangle left.. continue with this child\n    if(ne - ns <= 1) {\n      putRect(data, r, mainRects, l, ns, level);\n    } else {\n      double weight = 0;\n      int ni = ns;\n  \n      // parents size\n      int par = data.parent(l.list[ns], Data.ELEM);\n      long parsize = data.fs != null ?\n          Token.toLong(data.attValue(data.sizeID, par)) : 0;\n      int parchilds = l.list[ne] - l.list[ni];\n      if(parsize == 0) parsize = l.list[ne] - l.list[ns];\n      weight = 0;\n\n      // increment pivot until left rectangle contains more or equal\n      // than half the weight or leave with just setting it to ne - 1\n      for(; ni < ne - 1; ni++)  {\n        long size = data.fs != null ? \n            Token.toLong(data.attValue(data.sizeID, l.list[ni])) : 0;\n        int childs = l.list[ni + 1] - l.list[ni];\n        if(weight >= 0.5) break;\n        weight += calcWeight(size, childs, parsize, parchilds, data);\n      }\n\n      // determine rectangle orientation (horizontal/vertical)\n      // mapprop contains preferred alignment influence\n      // [JH] alignment should always be centered....\n      final int p = GUIProp.mapprop;\n      final boolean v = p > 4 ? r.w > r.h * (p + 4) / 8 :\n        r.w * (13 - p) / 8 > r.h;\n\n      int xx = r.x;\n      int yy = r.y;\n\n      // needs to be replaced by something like this\n      int ww = !v ? r.w : (int) (r.w * weight);\n      int hh = v ? r.h : (int) (r.h * weight);\n\n      // paint both rectangles if enough space is left\n      if(ww > 0 && hh > 0) calcMap(data, new ViewRect(xx, yy, ww, hh, 0,\n          r.level), mainRects, l, ns, ni, level);\n      if(v) {\n        xx += ww;\n        ww = r.w - ww;\n      } else {\n        yy += hh;\n        hh = r.h - hh;\n      }\n      if(ww > 0 && hh > 0) calcMap(data, new ViewRect(xx, yy, ww, hh, 0,\n          r.level), mainRects, l, ni, ne, level);\n    }\n  }","commit_id":"c03285240b3df0321954f80af750a3cc230808ed","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * @see clean(long, byte[], int)\n     * @param index\n     * @throws IOException\n     */\n    public final synchronized void clean(final long index) throws IOException {\n        final long s = size();\n        if (index >= s) throw new IndexOutOfBoundsException(\"kelondroEcoFS.clean(\" + index + \") outside bounds (\" + s + \")\");\n        if (index == s - 1) {\n            cleanLast();\n            return;\n        }\n        \n        // check if index is inside of cache\n        final int p = inCache(index);\n        final int q = (p >= 0) ? -1 : inBuffer(index);\n        if (p >= 0) {\n            // write zero bytes to the cache and to the file\n            System.arraycopy(zero, 0, this.cache, p * this.recordsize, this.recordsize);\n            raf.seek(index * this.recordsize);\n            raf.write(zero, 0, this.recordsize);\n            return;\n        }\n        if (q >= 0) {\n            // write zero to the buffer\n            System.arraycopy(zero, 0, this.buffer, q * this.recordsize, this.recordsize);\n            return;\n        }\n        \n        raf.seek(index * this.recordsize);\n        raf.write(zero, 0, this.recordsize);\n    }","id":101831,"modified_method":"/**\n     * @see clean(long, byte[], int)\n     * @param index\n     * @throws IOException\n     */\n    private final void clean(final long index) throws IOException {\n        final long s = size();\n        if (index >= s) throw new IndexOutOfBoundsException(\"kelondroEcoFS.clean(\" + index + \") outside bounds (\" + s + \")\");\n        if (index == s - 1) {\n            cleanLast();\n            return;\n        }\n        \n        // check if index is inside of cache\n        final int q = inBuffer(index);\n        if (q >= 0) {\n            // write zero to the buffer\n            System.arraycopy(zero, 0, this.buffer, q * this.recordsize, this.recordsize);\n            return;\n        }\n        \n        raf.seek(index * this.recordsize);\n        raf.write(zero, 0, this.recordsize);\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private final boolean isClean(final long index) throws IOException {\n         assert index < size();\n         // check if index is inside of cache\n         int p = inCache(index);\n         final int q = (p >= 0) ? -1 : inBuffer(index);\n         if ((p < 0) && (q < 0)) {\n             // the index is outside of cache and buffer index. shift cache window\n             fillCache(index);\n             p = inCache(index);\n             assert p >= 0;\n         }\n         if (p >= 0) {\n             // check entry from the cache\n             return isClean(this.cache, p * this.recordsize, this.recordsize);\n         }\n         if (q >= 0) {\n             // check entry from the buffer\n             return isClean(this.buffer, q * this.recordsize, this.recordsize);\n         }\n         assert false;\n         return false;\n    }","id":101832,"modified_method":"private final boolean isClean(final long index) throws IOException {\n         assert index < size();\n         // check if index is inside of buffer\n         final int q = inBuffer(index);\n         if (q >= 0) {\n             // check entry from the buffer\n             return isClean(this.buffer, q * this.recordsize, this.recordsize);\n         }\n         byte[] b = new byte[this.recordsize];\n         raf.seek(index * this.recordsize);\n         raf.readFully(b, 0, this.recordsize);\n         return isClean(b, 0, this.recordsize);\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Records(final File tablefile, final int recordsize) throws IOException {\n        this.tablefile = tablefile;\n        this.recordsize = recordsize;\n\n        // initialize zero buffer\n        this.zero = new byte[recordsize];\n        for (int i = 0; i < recordsize; i++) this.zero[i] = 0;\n        \n        // initialize table file\n        if (!tablefile.exists()) {\n            // make new file\n            FileOutputStream fos = null;\n            try {\n                fos = new FileOutputStream(tablefile);\n            } catch (final FileNotFoundException e) {\n                // should not happen\n                Log.logException(e);\n            }\n            try { if (fos != null) fos.close(); } catch (final IOException e) {}\n        }\n        \n        // open an existing table file\n        try {\n            raf = new RandomAccessFile(tablefile,\"rw\");\n        } catch (final FileNotFoundException e) {\n            // should never happen\n            Log.logException(e);\n        }\n        \n        // initialize cache and buffer\n        int cachesize = Math.max(1, (maxReadCache / recordsize)) * recordsize;\n        int buffersize = Math.max(1, (maxWriteBuffer / recordsize)) * recordsize;\n        if (!MemoryControl.request(cachesize + buffersize + 1024 * 1024 * 20, true)) {\n        \t// not enough memory there, take less\n        \tlong lessmem = Math.min(Math.min(maxReadCache, maxWriteBuffer) / 8, MemoryControl.available() - (1024 * 1024 * 6) / 6);\n        \t//System.out.println(\"newmem vorher: cachesize = \" + cachesize + \", buffersize = \" + buffersize + \", available = \" + serverMemory.available() + \", lessmem = \" + lessmem);\n        \tcachesize = Math.max(1, (int) (lessmem / recordsize)) * recordsize;\n            buffersize = Math.max(1, (int) (lessmem / recordsize)) * recordsize;\n            //System.out.println(\"newmem nachher: cachesize = \" + cachesize + \", buffersize = \" + buffersize);\n        }\n        \n        this.cache = new byte[cachesize];\n        this.buffer = new byte[buffersize];\n        this.buffercount = 0;\n        \n        // first-time read of cache\n        fillCache(0);\n    }","id":101833,"modified_method":"public Records(final File tablefile, final int recordsize) {\n        this.tablefile = tablefile;\n        this.recordsize = recordsize;\n\n        // initialize zero buffer\n        this.zero = new byte[recordsize];\n        for (int i = 0; i < recordsize; i++) this.zero[i] = 0;\n        \n        // initialize table file\n        if (!tablefile.exists()) {\n            // make new file\n            FileOutputStream fos = null;\n            try {\n                fos = new FileOutputStream(tablefile);\n            } catch (final FileNotFoundException e) {\n                // should not happen\n                Log.logException(e);\n            }\n            try { if (fos != null) fos.close(); } catch (final IOException e) {}\n        }\n        \n        // open an existing table file\n        try {\n            raf = new RandomAccessFile(tablefile,\"rw\");\n        } catch (final FileNotFoundException e) {\n            // should never happen\n            Log.logException(e);\n        }\n        \n        // initialize write buffer\n        int buffersize = Math.max(1, (maxWriteBuffer / recordsize)) * recordsize;\n        if (!MemoryControl.request(buffersize + 1024 * 1024 * 20, true)) {\n        \t// not enough memory there, take less\n        \tlong lessmem = Math.min(maxWriteBuffer / 8, MemoryControl.available() - (1024 * 1024 * 6) / 6);\n        \t//System.out.println(\"newmem vorher: cachesize = \" + cachesize + \", buffersize = \" + buffersize + \", available = \" + serverMemory.available() + \", lessmem = \" + lessmem);\n        \tbuffersize = Math.max(1, (int) (lessmem / recordsize)) * recordsize;\n            //System.out.println(\"newmem nachher: cachesize = \" + cachesize + \", buffersize = \" + buffersize);\n        }\n        \n        this.buffer = new byte[buffersize];\n        this.buffercount = 0;\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public final synchronized void close() {\n        flushBuffer();\n        \n        // then close the file\n        if (raf != null) try {\n            raf.close();\n        } catch (final IOException e) {\n            Log.logException(e);\n        }\n        this.raf = null;\n        this.buffer = null;\n        this.cache = null;\n    }","id":101834,"modified_method":"public final synchronized void close() {\n        flushBuffer();\n        \n        // then close the file\n        if (raf != null) try {\n            raf.close();\n        } catch (final IOException e) {\n            Log.logException(e);\n        }\n        this.raf = null;\n        this.buffer = null;\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private final synchronized void cleanLast0() throws IOException {\n\n        // check if index is inside of cache\n        final long s = this.size();\n        final long p = inCache(s - 1);\n        final long q = (p >= 0) ? -1 : inBuffer(s - 1);\n        if (p >= 0) {\n            // shrink cache and file\n            assert this.buffercount == 0;\n            this.raf.setLength((s - 1) * this.recordsize);\n            this.cachecount--;\n            return;\n        }\n        if (q >= 0) {\n            // shrink buffer\n            assert this.buffercount > 0;\n            this.buffercount--;\n            return;\n        }\n        // check if file should shrink\n        assert this.buffercount == 0;\n        this.raf.setLength((s - 1) * this.recordsize);\n    }","id":101835,"modified_method":"private final void cleanLast0() throws IOException {\n\n        // check if index is inside of cache\n        if (this.buffercount > 0) {\n            // shrink buffer\n            this.buffercount--;\n            return;\n        }\n        // shrink file\n        this.raf.setLength(raf.length() - this.recordsize);\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public final synchronized void put(final long index, final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        final long s = filesize() + this.buffercount;\n        if (index > s) throw new IndexOutOfBoundsException(\"kelondroEcoFS.put(\" + index + \") outside bounds (\" + this.size() + \")\");\n        \n        // check if this is an empty entry\n        if (isClean(b , start, this.recordsize)) {\n            clean(index);\n            return;\n        }\n        \n        // check if index is inside of cache\n        final int p = inCache(index);\n        final int q = (p >= 0) ? -1 : inBuffer(index);\n        if (p >= 0) {\n            // write entry to the cache and to the file\n            System.arraycopy(b, start, this.cache, p * this.recordsize, this.recordsize);\n            raf.seek(index * this.recordsize);\n            raf.write(b, start, this.recordsize);\n            return;\n        }\n        if (q >= 0) {\n            // write entry to the buffer\n            System.arraycopy(b, start, this.buffer, q * this.recordsize, this.recordsize);\n            return;\n        }\n        if (index == s) {\n            // append the record to the end of the file;\n            \n            // look if there is space in the buffer\n            if (this.buffercount >= this.buffer.length / this.recordsize) {\n                assert this.buffercount == this.buffer.length / this.recordsize;\n                // the record does not fit in current buffer\n                // write buffer\n                flushBuffer();\n                // write new entry to buffer\n                System.arraycopy(b, start, this.buffer, 0, this.recordsize);\n                this.buffercount = 1;\n            } else {\n                System.arraycopy(b, start, this.buffer, this.buffercount * this.recordsize, this.recordsize);\n                this.buffercount++;\n            }\n            assert this.buffercount <= this.buffer.length / this.recordsize;\n        } else {\n            // write the record directly to the file,\n            // do not care about the cache; this case was checked before\n            raf.seek(index * this.recordsize);\n            raf.write(b, start, this.recordsize);\n        }\n    }","id":101836,"modified_method":"public final synchronized void put(final long index, final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        final long s = filesize() + this.buffercount;\n        if (index > s) throw new IndexOutOfBoundsException(\"kelondroEcoFS.put(\" + index + \") outside bounds (\" + this.size() + \")\");\n        \n        // check if this is an empty entry\n        if (isClean(b , start, this.recordsize)) {\n            clean(index);\n            return;\n        }\n        \n        // check if index is inside of cache\n        final int q = inBuffer(index);\n        if (q >= 0) {\n            // write entry to the buffer\n            System.arraycopy(b, start, this.buffer, q * this.recordsize, this.recordsize);\n            return;\n        }\n        if (index == s) {\n            // append the record to the end of the file;\n            \n            // look if there is space in the buffer\n            if (this.buffercount >= this.buffer.length / this.recordsize) {\n                assert this.buffercount == this.buffer.length / this.recordsize;\n                // the record does not fit in current buffer\n                // write buffer\n                flushBuffer();\n                // write new entry to buffer\n                System.arraycopy(b, start, this.buffer, 0, this.recordsize);\n                this.buffercount = 1;\n            } else {\n                System.arraycopy(b, start, this.buffer, this.buffercount * this.recordsize, this.recordsize);\n                this.buffercount++;\n            }\n            assert this.buffercount <= this.buffer.length / this.recordsize;\n        } else {\n            // write the record directly to the file,\n            // do not care about the cache; this case was checked before\n            raf.seek(index * this.recordsize);\n            raf.write(b, start, this.recordsize);\n        }\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * @param index record which should be read\n     * @param b destination array\n     * @param start offset in b to store data\n     * @throws IOException\n     */\n    public final synchronized void get(final long index, final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        if (index >= size()) throw new IndexOutOfBoundsException(\"kelondroEcoFS.get(\" + index + \") outside bounds (\" + this.size() + \")\");\n        // check if index is inside of cache\n        int p = inCache(index);\n        final int q = (p >= 0) ? -1 : inBuffer(index);\n        if ((p < 0) && (q < 0)) {\n            // the index is outside of cache and buffer index. shift cache window\n            fillCache(index);\n            p = inCache(index);\n            assert p >= 0;\n        }\n        if (p >= 0) {\n            // read entry from the cache\n            System.arraycopy(this.cache, p * this.recordsize, b, start, this.recordsize); \n            return;\n        }\n        if (q >= 0) {\n            // read entry from the buffer\n            System.arraycopy(this.buffer, q * this.recordsize, b, start, this.recordsize); \n            return;\n        }\n        assert false;\n    }","id":101837,"modified_method":"/**\n     * @param index record which should be read\n     * @param b destination array\n     * @param start offset in b to store data\n     * @throws IOException\n     */\n    public final synchronized void get(final long index, final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        if (index >= size()) throw new IndexOutOfBoundsException(\"kelondroEcoFS.get(\" + index + \") outside bounds (\" + this.size() + \")\");\n        // check if index is inside of cache\n        final int q = inBuffer(index);\n        if (q < 0) {\n            // copy records from file to given buffer\n            raf.seek(this.recordsize * index);\n            raf.readFully(b, start, this.recordsize);\n            return;\n        }\n        // read entry from the buffer\n        System.arraycopy(this.buffer, q * this.recordsize, b, start, this.recordsize); \n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * this is like\n     * <code>clean(this.size() - 1, b, start);<\/code>\n     * \n     * @see clean(long, byte[], int)\n     * @param b\n     * @param start\n     * @throws IOException\n     */\n    private final synchronized void cleanLast0(final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        // check if index is inside of cache\n        final long s = this.size();\n        int p = inCache(s - 1);\n        final int q = (p >= 0) ? -1 : inBuffer(s - 1);\n        if ((p < 0) && (q < 0)) {\n            // the index is outside of cache and buffer index. shift cache window\n            fillCache(this.size() - 1);\n            p = inCache(this.size() - 1);\n            assert p >= 0;\n        }\n        if (p >= 0) {\n            // read entry from the cache\n            System.arraycopy(this.cache, p * this.recordsize, b, start, this.recordsize); \n            // shrink cache and file\n            assert this.buffercount == 0;\n            this.raf.setLength((s - 1) * this.recordsize);\n            this.cachecount--;\n            return;\n        }\n        if (q >= 0) {\n            // read entry from the buffer\n            System.arraycopy(this.buffer, q * this.recordsize, b, start, this.recordsize);\n            // shrink buffer\n            assert this.buffercount > 0;\n            this.buffercount--;\n            return;\n        }\n        assert false;\n    }","id":101838,"modified_method":"/**\n     * this is like\n     * <code>clean(this.size() - 1, b, start);<\/code>\n     * \n     * @see clean(long, byte[], int)\n     * @param b\n     * @param start\n     * @throws IOException\n     */\n    private final void cleanLast0(final byte[] b, final int start) throws IOException {\n        assert b.length - start >= this.recordsize;\n        // check if index is inside of buffer\n        if (this.buffercount > 0) {\n            // read entry from the buffer\n            System.arraycopy(this.buffer, (this.buffercount - 1) * this.recordsize, b, start, this.recordsize);\n            // shrink buffer\n            this.buffercount--;\n            return;\n        }\n        // read entry from the file\n        final long endpos = this.raf.length() - this.recordsize;\n        raf.seek(endpos);\n        raf.readFully(b, start, this.recordsize);\n        \n        // write zero bytes to the cache and to the file\n        this.raf.seek(endpos);\n        this.raf.write(zero, 0, this.recordsize);\n\n        // shrink file\n        this.raf.setLength(endpos);\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * write buffer to end of file \n     */\n    public final void flushBuffer() {\n        try {\n            raf.seek(raf.length());\n            raf.write(this.buffer, 0, this.recordsize * this.buffercount);\n        } catch (final IOException e) {\n            Log.logException(e);\n        }\n        this.buffercount = 0;\n    }","id":101839,"modified_method":"/**\n     * write buffer to end of file \n     */\n    protected final synchronized void flushBuffer() {\n        try {\n            raf.seek(raf.length());\n            raf.write(this.buffer, 0, this.recordsize * this.buffercount);\n        } catch (final IOException e) {\n            Log.logException(e);\n        }\n        this.buffercount = 0;\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized Entry removeOne() throws IOException {\n        assert file.size() == index.size() : \"file.size() = \" + file.size() + \", index.size() = \" + index.size();\n        assert table == null || table.size() == index.size() : \"table.size() = \" + table.size() + \", index.size() = \" + index.size();\n        final byte[] le = new byte[rowdef.objectsize];\n        long fsb = file.size();\n        assert fsb != 0 : \"file.size() = \" + fsb;\n        file.cleanLast(le, 0);\n        assert file.size() < fsb : \"file.size() = \" + file.size();\n        final Row.Entry lr = rowdef.newEntry(le);\n        assert lr != null;\n        assert lr.getPrimaryKeyBytes() != null;\n        final int is = index.size();\n        assert index.has(lr.getPrimaryKeyBytes());\n        final int i = (int) index.remove(lr.getPrimaryKeyBytes());\n        assert i < 0 || index.size() < is : \"index.size() = \" + index.size() + \", is = \" + is;\n        assert i >= 0;\n        if (table != null) table.removeOne();\n        assert file.size() == index.size() : \"file.size() = \" + file.size() + \", index.size() = \" + index.size();\n        assert table == null || table.size() == index.size() : \"table.size() = \" + table.size() + \", index.size() = \" + index.size();\n        return lr;\n    }","id":101840,"modified_method":"public synchronized Entry removeOne() throws IOException {\n        assert file.size() == index.size() : \"file.size() = \" + file.size() + \", index.size() = \" + index.size();\n        assert table == null || table.size() == index.size() : \"table.size() = \" + table.size() + \", index.size() = \" + index.size();\n        final byte[] le = new byte[rowdef.objectsize];\n        long fsb = file.size();\n        assert fsb != 0 : \"file.size() = \" + fsb;\n        file.cleanLast(le, 0);\n        assert file.size() < fsb : \"file.size() = \" + file.size();\n        final Row.Entry lr = rowdef.newEntry(le);\n        assert lr != null;\n        assert lr.getPrimaryKeyBytes() != null;\n        final int is = index.size();\n        assert index.has(lr.getPrimaryKeyBytes());\n        final int i = (int) index.remove(lr.getPrimaryKeyBytes());\n        assert i < 0 || index.size() < is : \"index.size() = \" + index.size() + \", is = \" + is;\n        assert i >= 0;\n        if (table != null) {\n            int tsb = table.size();\n            table.removeOne();\n            assert table.size() < tsb : \"table.size() = \" + table.size() + \", tsb = \" + tsb;\n        }\n        assert file.size() == index.size() : \"file.size() = \" + file.size() + \", index.size() = \" + index.size();\n        assert table == null || table.size() == index.size() : \"table.size() = \" + table.size() + \", index.size() = \" + index.size();\n        return lr;\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized void clear() throws IOException {\n        final File f = file.filename();\n        file.close();\n        FileUtils.deletedelete(f);\n        \n        // make new file\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(f);\n        } catch (final FileNotFoundException e) {\n            // should not happen\n            Log.logSevere(\"Table\", \"\", e);\n        }\n        if (fos != null) try { fos.close(); } catch (final IOException e) {}\n        \n        \n        // open an existing table file\n        try {\n            this.file = new BufferedRecords(new Records(f, rowdef.objectsize), this.buffersize);\n        } catch (final FileNotFoundException e) {\n            // should never happen\n            Log.logSevere(\"Table\", \"\", e);\n        }\n        \n        // initialize index and copy table\n        table = (table == null) ? null : new RowSet(taildef);\n        index.clear();        \n    }","id":101841,"modified_method":"public synchronized void clear() throws IOException {\n        final File f = file.filename();\n        file.close();\n        FileUtils.deletedelete(f);\n        \n        // make new file\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(f);\n        } catch (final FileNotFoundException e) {\n            // should not happen\n            Log.logSevere(\"Table\", \"\", e);\n        }\n        if (fos != null) try { fos.close(); } catch (final IOException e) {}\n        \n        this.file = new BufferedRecords(new Records(f, rowdef.objectsize), this.buffersize);\n        \n        // initialize index and copy table\n        table = (table == null) ? null : new RowSet(taildef);\n        index.clear();        \n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Entry get(final byte[] key) throws IOException {\n        if ((file == null) || (index == null)) return null;\n        synchronized (this) {\n            assert file.size() == index.size() : \"file.size() = \" + file.size() + \", index.size() = \" + index.size() + \", file = \" + this.filename();\n            assert table == null || table.size() == index.size() : \"table.size() = \" + table.size() + \", index.size() = \" + index.size() + \", file = \" + this.filename();\n        }\n        Entry e = get0(key);\n        if (e != null && this.rowdef.objectOrder.equal(key, e.getPrimaryKeyBytes())) return e;\n        synchronized (this) {\n            e = get0(key);\n            assert e == null || this.rowdef.objectOrder.equal(key, e.getPrimaryKeyBytes());\n            return e;\n        }\n    }","id":101842,"modified_method":"public Entry get(final byte[] key) throws IOException {\n        if (file == null || index == null) return null;\n        Entry e = get0(key);\n        if (e != null && this.rowdef.objectOrder.equal(key, e.getPrimaryKeyBytes())) return e;\n        synchronized (this) {\n            assert file.size() == index.size() : \"file.size() = \" + file.size() + \", index.size() = \" + index.size() + \", file = \" + this.filename();\n            assert table == null || table.size() == index.size() : \"table.size() = \" + table.size() + \", index.size() = \" + index.size() + \", file = \" + this.filename();\n            e = get0(key);\n            assert e == null || this.rowdef.objectOrder.equal(key, e.getPrimaryKeyBytes());\n            return e;\n        }\n    }","commit_id":"d607b30b6a0b36d5d80d08102ca4735be69d8691","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Test\n   public void exactSearchMatchesExactOnly()\n   {\n      setDefaultMockBehaviour();\n      // should match 1 of the 3 sample documents\n      String filterText = \"match/exact/filter\";\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(true).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate firing history change event\n      HistoryToken historyTokenWithExactFilter = new HistoryToken();\n      historyTokenWithExactFilter.setDocFilterText(filterText);\n      historyTokenWithExactFilter.setDocFilterExact(true);\n      capturedHistoryValueChangeHandler.getValue().onValueChange(new ValueChangeEvent<String>(historyTokenWithExactFilter.toTokenString())\n      {\n      });\n\n      verifyAllMocks();\n\n      ArrayList<DocumentInfo> expectedDocs = buildSampleDocumentArray();\n      expectedDocs.remove(2); // third doc does not match the filter\n      expectedDocs.remove(0); // first doc does not match the filter\n      ArrayList<DocumentInfo> actualDocInfos = new ArrayList<DocumentInfo>();\n      for (DocumentNode node : dataProviderList)\n      {\n         assertThat(\"the data provider should have only documents that exactly match the current filter\", node.getDocInfo(), isIn(expectedDocs));\n         actualDocInfos.add(node.getDocInfo());\n      }\n      assertThat(\"the data provider should have all documents that exactly match the filter\", actualDocInfos, hasItems(expectedDocs.get(0)));\n      assertThat(\"the data provider list should contain exactly the number of documents matching the filter\", dataProviderList.size(), is(1));\n   }","id":101843,"modified_method":"@Test\n   public void exactSearchMatchesExactOnly()\n   {\n      setDefaultMockBehaviour();\n      // should match 1 of the 3 sample documents\n      String filterText = \"match/exact/filter\";\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(true).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate firing history change event\n      HistoryToken historyTokenWithExactFilter = new HistoryToken();\n      historyTokenWithExactFilter.setDocFilterText(filterText);\n      historyTokenWithExactFilter.setDocFilterExact(true);\n      valueChangeEvent(capturedHistoryValueChangeHandler, historyTokenWithExactFilter.toTokenString());\n\n      verifyAllMocks();\n\n      ArrayList<DocumentInfo> expectedDocs = buildSampleDocumentArray();\n      expectedDocs.remove(2); // third doc does not match the filter\n      expectedDocs.remove(0); // first doc does not match the filter\n      ArrayList<DocumentInfo> actualDocInfos = new ArrayList<DocumentInfo>();\n      for (DocumentNode node : dataProviderList)\n      {\n         assertThat(\"the data provider should have only documents that exactly match the current filter\", node.getDocInfo(), isIn(expectedDocs));\n         actualDocInfos.add(node.getDocInfo());\n      }\n      assertThat(\"the data provider should have all documents that exactly match the filter\", actualDocInfos, hasItems(expectedDocs.get(0)));\n      assertThat(\"the data provider list should contain exactly the number of documents matching the filter\", dataProviderList.size(), is(1));\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@SuppressWarnings(\"unchecked\")\n   @Test\n   public void filterTextboxUpdatedFromHistory()\n   {\n      setDefaultMockBehaviour();\n      String filterText = \"some filter text\";\n      // must use fireEvents=true to prevent value being used as greyed-out\n      // 'hint' text that automatically clears\n      mockFilterTextbox.setValue(filterText, true);\n      // value should only be set if current value is different from history\n      expect(mockFilterTextbox.getValue()).andReturn(\"different text\").anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n      // simulate firing history change event\n      HistoryToken historyTokenWithFilter = new HistoryToken();\n      historyTokenWithFilter.setDocFilterText(filterText);\n      capturedHistoryValueChangeHandler.getValue().onValueChange(new ValueChangeEvent<String>(historyTokenWithFilter.toTokenString())\n      {\n      });\n      verifyAllMocks();\n   }","id":101844,"modified_method":"@SuppressWarnings(\"unchecked\")\n   @Test\n   public void filterTextboxUpdatedFromHistory()\n   {\n      setDefaultMockBehaviour();\n      String filterText = \"some filter text\";\n      // must use fireEvents=true to prevent value being used as greyed-out\n      // 'hint' text that automatically clears\n      mockFilterTextbox.setValue(filterText, true);\n      // value should only be set if current value is different from history\n      expect(mockFilterTextbox.getValue()).andReturn(\"different text\").anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n      // simulate firing history change event\n      HistoryToken historyTokenWithFilter = new HistoryToken();\n      historyTokenWithFilter.setDocFilterText(filterText);\n      valueChangeEvent(capturedHistoryValueChangeHandler, historyTokenWithFilter.toTokenString());\n      verifyAllMocks();\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void checkExactSearchCheckboxGeneratesHistoryToken()\n   {\n      setDefaultMockBehaviour();\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate checking 'exact search' checkbox\n      capturedCheckboxChangeHandler.getValue().onValueChange(new ValueChangeEvent<Boolean>(true)\n      {\n      });\n\n      verifyAllMocks();\n\n      HistoryToken exactSearchToken = new HistoryToken();\n      exactSearchToken.setDocFilterExact(true);\n      assertThat(\"checking the 'exact search' checkbox should be reflected in a new history token\", capturedHistoryTokenString.getValue(), is(exactSearchToken.toTokenString()));\n   }","id":101845,"modified_method":"@Test\n   public void checkExactSearchCheckboxGeneratesHistoryToken()\n   {\n      setDefaultMockBehaviour();\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate checking 'exact search' checkbox\n      valueChangeEvent(capturedCheckboxChangeHandler, true);\n\n      verifyAllMocks();\n\n      HistoryToken exactSearchToken = new HistoryToken();\n      exactSearchToken.setDocFilterExact(true);\n      assertThat(\"checking the 'exact search' checkbox should be reflected in a new history token\", capturedHistoryTokenString.getValue(), is(exactSearchToken.toTokenString()));\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void uncheckExactSearchCheckboxGeneratesHistoryToken()\n   {\n      setupDefaultDoclistRequestAnswer();\n      expectDefaultWindowLocationCalls();\n\n      // history reflects checkbox already checked\n      HistoryToken exactSearchToken = new HistoryToken();\n      exactSearchToken.setDocFilterExact(true);\n      setupMockHistory(exactSearchToken.toTokenString());\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      capturedCheckboxChangeHandler.getValue().onValueChange(new ValueChangeEvent<Boolean>(false)\n      {\n      });\n\n      verifyAllMocks();\n\n      HistoryToken inexactSearchToken = new HistoryToken();\n      inexactSearchToken.setDocFilterExact(false);\n      assertThat(\"unchecking the 'exact search' checkbox should be reflected in a new history token\", capturedHistoryTokenString.getValue(), is(inexactSearchToken.toTokenString()));\n   }","id":101846,"modified_method":"@Test\n   public void uncheckExactSearchCheckboxGeneratesHistoryToken()\n   {\n      setupDefaultDoclistRequestAnswer();\n      expectDefaultWindowLocationCalls();\n\n      // history reflects checkbox already checked\n      HistoryToken exactSearchToken = new HistoryToken();\n      exactSearchToken.setDocFilterExact(true);\n      setupMockHistory(exactSearchToken.toTokenString());\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      valueChangeEvent(capturedCheckboxChangeHandler, false);\n\n      verifyAllMocks();\n\n      HistoryToken inexactSearchToken = new HistoryToken();\n      inexactSearchToken.setDocFilterExact(false);\n      assertThat(\"unchecking the 'exact search' checkbox should be reflected in a new history token\", capturedHistoryTokenString.getValue(), is(inexactSearchToken.toTokenString()));\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@SuppressWarnings(\"unchecked\")\n   private void setupMockHistory(String tokenToReturn)\n   {\n      expect(mockHistory.addValueChangeHandler(and(capture(capturedHistoryValueChangeHandler), isA(ValueChangeHandler.class)))).andReturn(createMock(HandlerRegistration.class)).anyTimes();\n      expect(mockHistory.getToken()).andReturn(tokenToReturn).anyTimes();\n      expect(mockHistory.getHistoryToken()).andReturn(HistoryToken.fromTokenString(tokenToReturn)).anyTimes();\n      mockHistory.fireCurrentHistoryState();\n      expectLastCall().anyTimes();\n\n      mockHistory.newItem(capture(capturedHistoryTokenString));\n      expectLastCall().anyTimes();\n\n      mockHistory.newItem(capture(capturedHistoryToken));\n      expectLastCall().anyTimes();\n   }","id":101847,"modified_method":"@SuppressWarnings(\"unchecked\")\n   private void setupMockHistory(String tokenToReturn)\n   {\n      // TODO set up History to properly extend ValueChangeHandler<String>, then use convenience method for handler registration\n      expect(mockHistory.addValueChangeHandler(and(capture(capturedHistoryValueChangeHandler), isA(ValueChangeHandler.class)))).andReturn(mockHandlerRegistration()).anyTimes();\n      expect(mockHistory.getToken()).andReturn(tokenToReturn).anyTimes();\n      expect(mockHistory.getHistoryToken()).andReturn(HistoryToken.fromTokenString(tokenToReturn)).anyTimes();\n      mockHistory.fireCurrentHistoryState();\n      expectLastCall().anyTimes();\n\n      mockHistory.newItem(capture(capturedHistoryTokenString));\n      expectLastCall().anyTimes();\n\n      mockHistory.newItem(capture(capturedHistoryToken));\n      expectLastCall().anyTimes();\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@SuppressWarnings(\"unchecked\")\n   @Test\n   public void filterCheckboxUpdatedFromHistory()\n   {\n      setDefaultMockBehaviour();\n      mockExactSearchCheckbox.setValue(true);\n      expect(mockFilterTextbox.getValue()).andReturn(\"\").anyTimes();\n      // value should only be set if current value is different from history\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n      // simulate firing history change event\n      HistoryToken historyTokenWithExactFilter = new HistoryToken();\n      historyTokenWithExactFilter.setDocFilterExact(true);\n      capturedHistoryValueChangeHandler.getValue().onValueChange(new ValueChangeEvent<String>(historyTokenWithExactFilter.toTokenString())\n      {\n      });\n      verifyAllMocks();\n   }","id":101848,"modified_method":"@SuppressWarnings(\"unchecked\")\n   @Test\n   public void filterCheckboxUpdatedFromHistory()\n   {\n      setDefaultMockBehaviour();\n      mockExactSearchCheckbox.setValue(true);\n      expect(mockFilterTextbox.getValue()).andReturn(\"\").anyTimes();\n      // value should only be set if current value is different from history\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n      // simulate firing history change event\n      HistoryToken historyTokenWithExactFilter = new HistoryToken();\n      historyTokenWithExactFilter.setDocFilterExact(true);\n      valueChangeEvent(capturedHistoryValueChangeHandler, historyTokenWithExactFilter.toTokenString());\n      verifyAllMocks();\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@SuppressWarnings(\"unchecked\")\n   @Override\n   protected void setDefaultBindExpectations()\n   {\n      setupMockDataProvider();\n\n      setupMockDisplay();\n\n      expect(mockMessages.loadDocFailed()).andReturn(TEST_DOC_LOAD_FAIL_MESSAGE).anyTimes();\n\n      expect(mockDocList.addSelectionHandler(and(capture(capturedDocumentSelectionHandler), isA(SelectionHandler.class)))).andReturn(createMock(HandlerRegistration.class));\n      setupMockEventBus(true);\n      expect(mockExactSearchCheckbox.addValueChangeHandler(and(capture(capturedCheckboxChangeHandler), isA(ValueChangeHandler.class)))).andReturn(createMock(HandlerRegistration.class)).once();\n      expect(mockCaseSensitiveCheckbox.addValueChangeHandler(and(capture(capturedCaseSensitiveCheckboxChangeHandler), isA(ValueChangeHandler.class)))).andReturn(createMock(HandlerRegistration.class)).once();\n      expect(mockFilterTextbox.addValueChangeHandler(and(capture(capturedTextboxChangeHandler), isA(ValueChangeHandler.class)))).andReturn(createMock(HandlerRegistration.class)).once();\n\n      expect(mockUserWorkspaceContext.getWorkspaceContext()).andReturn(mockWorkspaceContext).anyTimes();\n      expect(mockWorkspaceContext.getWorkspaceId()).andReturn(new WorkspaceId(new ProjectIterationId(testProjectSlug, testIterationSlug), new LocaleId(testLocaleId))).anyTimes();\n\n      mockUserWorkspaceContext.setSelectedDoc(new DocumentInfo(new DocumentId(2222L), \"doc122\", \"second/path/\", LocaleId.EN_US, new TranslationStats()));\n      expectLastCall().anyTimes();\n   }","id":101849,"modified_method":"@SuppressWarnings(\"unchecked\")\n   @Override\n   protected void setDefaultBindExpectations()\n   {\n      setupMockDataProvider();\n\n      setupMockDisplay();\n\n      expect(mockMessages.loadDocFailed()).andReturn(TEST_DOC_LOAD_FAIL_MESSAGE).anyTimes();\n\n      expect(mockDocList.addSelectionHandler(and(capture(capturedDocumentSelectionHandler), isA(SelectionHandler.class)))).andReturn(mockHandlerRegistration());\n      setupMockEventBus(true);\n      expectValueChangeHandlerRegistration(mockExactSearchCheckbox, capturedCheckboxChangeHandler);\n      expectValueChangeHandlerRegistration(mockCaseSensitiveCheckbox, capturedCaseSensitiveCheckboxChangeHandler);\n      expectValueChangeHandlerRegistration(mockFilterTextbox, capturedTextboxChangeHandler);\n\n      expect(mockUserWorkspaceContext.getWorkspaceContext()).andReturn(mockWorkspaceContext).anyTimes();\n      expect(mockWorkspaceContext.getWorkspaceId()).andReturn(new WorkspaceId(new ProjectIterationId(testProjectSlug, testIterationSlug), new LocaleId(testLocaleId))).anyTimes();\n\n      mockUserWorkspaceContext.setSelectedDoc(new DocumentInfo(new DocumentId(2222L), \"doc122\", \"second/path/\", LocaleId.EN_US, new TranslationStats()));\n      expectLastCall().anyTimes();\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void commaSeparatedFilter()\n   {\n      setDefaultMockBehaviour();\n      // should match first and last of the 3 sample documents\n      // multiple matching strings for third to check that there is no\n      // duplication, also variable whitespace\n      String filterText = \" does/not, not/match ,no/filter \";\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate firing history change event\n      HistoryToken historyTokenWithFilter = new HistoryToken();\n      historyTokenWithFilter.setDocFilterText(filterText);\n      capturedHistoryValueChangeHandler.getValue().onValueChange(new ValueChangeEvent<String>(historyTokenWithFilter.toTokenString())\n      {\n      });\n\n      verifyAllMocks();\n\n      ArrayList<DocumentInfo> expectedDocs = buildSampleDocumentArray();\n      expectedDocs.remove(1); // second doc does not match any of the filter\n                              // strings\n      ArrayList<DocumentInfo> actualDocInfos = new ArrayList<DocumentInfo>();\n      for (DocumentNode node : dataProviderList)\n      {\n         assertThat(\"the data provider should have only documents that match the current filter\", node.getDocInfo(), isIn(expectedDocs));\n         actualDocInfos.add(node.getDocInfo());\n      }\n      assertThat(\"the data provider should have all documents that match the filter\", actualDocInfos, hasItems(expectedDocs.get(0), expectedDocs.get(1)));\n      assertThat(\"the data provider list should contain exactly the number of documents matching the filter\", dataProviderList.size(), is(2));\n   }","id":101850,"modified_method":"@Test\n   public void commaSeparatedFilter()\n   {\n      setDefaultMockBehaviour();\n      // should match first and last of the 3 sample documents\n      // multiple matching strings for third to check that there is no\n      // duplication, also variable whitespace\n      String filterText = \" does/not, not/match ,no/filter \";\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate firing history change event\n      HistoryToken historyTokenWithFilter = new HistoryToken();\n      historyTokenWithFilter.setDocFilterText(filterText);\n      valueChangeEvent(capturedHistoryValueChangeHandler, historyTokenWithFilter.toTokenString());\n\n      verifyAllMocks();\n\n      ArrayList<DocumentInfo> expectedDocs = buildSampleDocumentArray();\n      expectedDocs.remove(1); // second doc does not match any of the filter\n                              // strings\n      ArrayList<DocumentInfo> actualDocInfos = new ArrayList<DocumentInfo>();\n      for (DocumentNode node : dataProviderList)\n      {\n         assertThat(\"the data provider should have only documents that match the current filter\", node.getDocInfo(), isIn(expectedDocs));\n         actualDocInfos.add(node.getDocInfo());\n      }\n      assertThat(\"the data provider should have all documents that match the filter\", actualDocInfos, hasItems(expectedDocs.get(0), expectedDocs.get(1)));\n      assertThat(\"the data provider list should contain exactly the number of documents matching the filter\", dataProviderList.size(), is(2));\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@SuppressWarnings(\"unchecked\")\n   private void setupMockEventBus(boolean expectAllEvents)\n   {\n      expect(mockEventBus.addHandler(eq(TransUnitUpdatedEvent.getType()), and(capture(capturedTransUnitUpdatedEventHandler), isA(TransUnitUpdatedEventHandler.class)))).andReturn(createMock(HandlerRegistration.class)).once();\n      expect(mockEventBus.addHandler((GwtEvent.Type<EventHandler>) notNull(), (EventHandler) notNull())).andReturn(createMock(HandlerRegistration.class)).anyTimes();\n\n      mockEventBus.fireEvent(and(capture(capturedEventBusEvent), isA(GwtEvent.class)));\n      expectLastCall().anyTimes();\n   }","id":101851,"modified_method":"@SuppressWarnings(\"unchecked\")\n   private void setupMockEventBus(boolean expectAllEvents)\n   {\n      expect(mockEventBus.addHandler(eq(TransUnitUpdatedEvent.getType()), and(capture(capturedTransUnitUpdatedEventHandler), isA(TransUnitUpdatedEventHandler.class)))).andReturn(mockHandlerRegistration());\n      expect(mockEventBus.addHandler((GwtEvent.Type<EventHandler>) notNull(), (EventHandler) notNull())).andReturn(mockHandlerRegistration()).anyTimes();\n\n      mockEventBus.fireEvent(and(capture(capturedEventBusEvent), isA(GwtEvent.class)));\n      expectLastCall().anyTimes();\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void historyTokenFiltersDoclist()\n   {\n      setDefaultMockBehaviour();\n      // should match 2 of the 3 sample documents\n      String filterText = \"match/exact/filter\";\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate firing history change event\n      HistoryToken historyTokenWithFilter = new HistoryToken();\n      historyTokenWithFilter.setDocFilterText(filterText);\n      capturedHistoryValueChangeHandler.getValue().onValueChange(new ValueChangeEvent<String>(historyTokenWithFilter.toTokenString())\n      {\n      });\n      verifyAllMocks();\n\n      ArrayList<DocumentInfo> expectedDocs = buildSampleDocumentArray();\n      expectedDocs.remove(0); // first doc does not match the filter\n      ArrayList<DocumentInfo> actualDocInfos = new ArrayList<DocumentInfo>();\n      for (DocumentNode node : dataProviderList)\n      {\n         assertThat(\"the data provider should have only documents that match the current filter\", node.getDocInfo(), isIn(expectedDocs));\n         actualDocInfos.add(node.getDocInfo());\n      }\n      assertThat(\"the data provider should have all documents that match the filter\", actualDocInfos, hasItems(expectedDocs.get(0), expectedDocs.get(1)));\n      assertThat(\"the data provider list should contain exactly the number of documents matching the filter\", dataProviderList.size(), is(2));\n   }","id":101852,"modified_method":"@Test\n   public void historyTokenFiltersDoclist()\n   {\n      setDefaultMockBehaviour();\n      // should match 2 of the 3 sample documents\n      String filterText = \"match/exact/filter\";\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n      expect(mockCaseSensitiveCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      // simulate firing history change event\n      HistoryToken historyTokenWithFilter = new HistoryToken();\n      historyTokenWithFilter.setDocFilterText(filterText);\n      valueChangeEvent(capturedHistoryValueChangeHandler, historyTokenWithFilter.toTokenString());\n      verifyAllMocks();\n\n      ArrayList<DocumentInfo> expectedDocs = buildSampleDocumentArray();\n      expectedDocs.remove(0); // first doc does not match the filter\n      ArrayList<DocumentInfo> actualDocInfos = new ArrayList<DocumentInfo>();\n      for (DocumentNode node : dataProviderList)\n      {\n         assertThat(\"the data provider should have only documents that match the current filter\", node.getDocInfo(), isIn(expectedDocs));\n         actualDocInfos.add(node.getDocInfo());\n      }\n      assertThat(\"the data provider should have all documents that match the filter\", actualDocInfos, hasItems(expectedDocs.get(0), expectedDocs.get(1)));\n      assertThat(\"the data provider list should contain exactly the number of documents matching the filter\", dataProviderList.size(), is(2));\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void filterTextUpdateGeneratesHistoryToken()\n   {\n      setDefaultMockBehaviour();\n      String filterText = \"path/doc12\";\n      // these seem to persist beyond verify, so setting them up here is fine\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      capturedTextboxChangeHandler.getValue().onValueChange(new ValueChangeEvent<String>(filterText)\n            { // overriding gives access to protected constructor\n            });\n\n      verifyAllMocks();\n\n      HistoryToken capturedHistoryToken = HistoryToken.fromTokenString(capturedHistoryTokenString.getValue());\n      assertThat(\"generated history token filter text should match the filter textbox\", capturedHistoryToken.getDocFilterText(), is(filterText));\n      assertThat(\"generated history token filter exact flag should match the exact match checkbox\", capturedHistoryToken.getDocFilterExact(), is(false));\n   }","id":101853,"modified_method":"@Test\n   public void filterTextUpdateGeneratesHistoryToken()\n   {\n      setDefaultMockBehaviour();\n      String filterText = \"path/doc12\";\n      // these seem to persist beyond verify, so setting them up here is fine\n      expect(mockFilterTextbox.getValue()).andReturn(filterText).anyTimes();\n      expect(mockExactSearchCheckbox.getValue()).andReturn(false).anyTimes();\n\n      replayAllMocks();\n      documentListPresenter.bind();\n\n      valueChangeEvent(capturedTextboxChangeHandler, filterText);\n\n      verifyAllMocks();\n\n      HistoryToken capturedHistoryToken = HistoryToken.fromTokenString(capturedHistoryTokenString.getValue());\n      assertThat(\"generated history token filter text should match the filter textbox\", capturedHistoryToken.getDocFilterText(), is(filterText));\n      assertThat(\"generated history token filter exact flag should match the exact match checkbox\", capturedHistoryToken.getDocFilterExact(), is(false));\n   }","commit_id":"129a6927bff5e27f7b3b2b76a8d500fd1ca5a212","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void setDefaults(Map<String, String> map)\n   {\n      map.put(HApplicationConfiguration.KEY_HELP, \"http://code.google.com/p/flies/wiki/Introduction\");\n      map.put(HApplicationConfiguration.KEY_REGISTER, \"/flies/account/register\");\n      map.put(HApplicationConfiguration.KEY_HOST, \"http://localhost:8080/flies\");\n   }","id":101854,"modified_method":"private void setDefaults(Map<String, String> map)\n   {\n      map.put(HApplicationConfiguration.KEY_HELP, \"http://code.google.com/p/flies/wiki/Introduction\");\n      map.put(HApplicationConfiguration.KEY_REGISTER, \"/flies/account/register\");\n      map.put(HApplicationConfiguration.KEY_HOST, \"http://localhost:8080/flies\");\n      map.put(HApplicationConfiguration.KEY_DOMAIN, \"example.com\");\n      map.put(HApplicationConfiguration.KEY_ADMIN_EMAIL, \"asgeirf@redhat.com\");\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Observer(Identity.EVENT_LOGIN_SUCCESSFUL)\n   public void loginInSuccessful()\n   {\n      log.debug(\"Account logged in successfully\");\n      FliesJpaIdentityStore authenticator = (FliesJpaIdentityStore) Component.getInstance(\"org.jboss.seam.security.identityStore\", ScopeType.APPLICATION, true);\n      if (!authenticator.isInternalAuthentication() && !authenticator.isNewUser())\n      {\n         authenticator.jaasUserLoggedIn();\n      }\n   }","id":101855,"modified_method":"@Observer(Identity.EVENT_LOGIN_SUCCESSFUL)\n   public void loginInSuccessful()\n   {\n      log.debug(\"Account logged in successfully\");\n      if (fliesExternalLoginBean.externalLogin() && !fliesExternalLoginBean.isNewUser())\n      {\n         if (!fliesExternalLoginBean.checkDisabledUser())\n         {\n            fliesExternalLoginBean.applyAuthentication();\n         }\n      }\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean isInternalAuthentication()\r\n   {\r\n      FliesInit instance = (FliesInit) Component.getInstance(FliesInit.class, ScopeType.APPLICATION);\r\n      return instance.isInternalAuthentication();\r\n   }","id":101856,"modified_method":"public boolean isNewUser(String username)\r\n   {\r\n      Object user = lookupUser(username);\r\n      return user == null;\r\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void testGetAllJavaLanguages() throws Exception\n   {\n      List<LocaleId> loc = this.testLocaleServiceImpl.getAllJavaLanguages();\n      StringBuilder st = new StringBuilder(\"\");\n      for (LocaleId localeId : loc)\n      {\n         st.append(localeId.getId() + \",\");\n      }\n      System.out.println(st);\n\n      String re = \"af,af-NA,af-ZA,ak,ak-GH,am,am-ET,ar,ar-AE,ar-BH,ar-DZ,ar-EG,ar-IQ,ar-JO,ar-KW,ar-LB,ar-LY,ar-MA,ar-OM,ar-QA,ar-SA,ar-SD,ar-SY,ar-TN,ar-YE,as,as-IN,asa,asa-TZ,az,az-Cyrl,az-AZ-Cyrl,az-Latn,az-AZ-Latn,be,be-BY,bem,bem-ZM,bez,bez-TZ,bg,bg-BG,bm,bm-ML,bn,bn-BD,bn-IN,bo,bo-CN,bo-IN,ca,ca-ES,cgg,cgg-UG,chr,chr-US,cs,cs-CZ,cy,cy-GB,da,da-DK,dav,dav-KE,de,de-AT,de-BE,de-CH,de-DE,de-LI,de-LU,ebu,ebu-KE,ee,ee-GH,ee-TG,el,el-CY,el-GR,en,en-AU,en-BE,en-BW,en-BZ,en-CA,en-GB,en-HK,en-IE,en-IN,en-JM,en-MH,en-MT,en-MU,en-NA,en-NZ,en-PH,en-PK,en-SG,en-TT,en-US,en-US-POSIX,en-VI,en-ZA,en-ZW,eo,es,es-AR,es-BO,es-CL,es-CO,es-CR,es-DO,es-EC,es-ES,es-GQ,es-GT,es-HN,es-MX,es-NI,es-PA,es-PE,es-PR,es-PY,es-SV,es-US,es-UY,es-VE,et,et-EE,eu,eu-ES,fa,fa-AF,fa-IR,ff,ff-SN,fi,fi-FI,fil,fil-PH,fo,fo-FO,fr,fr-BE,fr-BL,fr-CA,fr-CF,fr-CH,fr-CI,fr-CM,fr-FR,fr-GN,fr-GP,fr-LU,fr-MC,fr-MF,fr-MG,fr-ML,fr-MQ,fr-NE,fr-RE,fr-SN,ga,ga-IE,gl,gl-ES,gsw,gsw-CH,gu,gu-IN,guz,guz-KE,gv,gv-GB,ha,ha-Latn,ha-GH-Latn,ha-NE-Latn,ha-NG-Latn,haw,haw-US,he,he-IL,hi,hi-IN,hr,hr-HR,hu,hu-HU,hy,hy-AM,id,id-ID,ig,ig-NG,ii,ii-CN,is,is-IS,it,it-CH,it-IT,ja,ja-JP,jmc,jmc-TZ,ka,ka-GE,kab,kab-DZ,kam,kam-KE,kde,kde-TZ,kea,kea-CV,khq,khq-ML,ki,ki-KE,kk,kk-Cyrl,kk-KZ-Cyrl,kl,kl-GL,kln,kln-KE,km,km-KH,kn,kn-IN,ko,ko-KR,kok,kok-IN,kw,kw-GB,lag,lag-TZ,lg,lg-UG,lt,lt-LT,luo,luo-KE,luy,luy-KE,lv,lv-LV,mas,mas-KE,mas-TZ,mer,mer-KE,mfe,mfe-MU,mg,mg-MG,mk,mk-MK,ml,ml-IN,mr,mr-IN,ms,ms-BN,ms-MY,mt,mt-MT,naq,naq-NA,nb,nb-NO,nd,nd-ZW,ne,ne-IN,ne-NP,nl,nl-BE,nl-NL,nn,nn-NO,nyn,nyn-UG,om,om-ET,om-KE,or,or-IN,pa,pa-Arab,pa-PK-Arab,pa-Guru,pa-IN-Guru,pl,pl-PL,ps,ps-AF,pt,pt-BR,pt-GW,pt-MZ,pt-PT,rm,rm-CH,ro,ro-MD,ro-RO,rof,rof-TZ,ru,ru-MD,ru-RU,ru-UA,rw,rw-RW,rwk,rwk-TZ,saq,saq-KE,seh,seh-MZ,ses,ses-ML,sg,sg-CF,shi,shi-Latn,shi-MA-Latn,shi-Tfng,shi-MA-Tfng,si,si-LK,sk,sk-SK,sl,sl-SI,sn,sn-ZW,so,so-DJ,so-ET,so-KE,so-SO,sq,sq-AL,sr,sr-Cyrl,sr-BA-Cyrl,sr-ME-Cyrl,sr-RS-Cyrl,sr-Latn,sr-BA-Latn,sr-ME-Latn,sr-RS-Latn,sv,sv-FI,sv-SE,sw,sw-KE,sw-TZ,ta,ta-IN,ta-LK,te,te-IN,teo,teo-KE,teo-UG,th,th-TH,ti,ti-ER,ti-ET,to,to-TO,tr,tr-TR,tzm,tzm-Latn,tzm-MA-Latn,uk,uk-UA,ur,ur-IN,ur-PK,uz,uz-Arab,uz-AF-Arab,uz-Cyrl,uz-UZ-Cyrl,uz-Latn,uz-UZ-Latn,vi,vi-VN,vun,vun-TZ,xog,xog-UG,yo,yo-NG,zh,zh-Hans,zh-CN-Hans,zh-HK-Hans,zh-MO-Hans,zh-SG-Hans,zh-Hant,zh-HK-Hant,zh-MO-Hant,zh-TW-Hant,zu,zu-ZA,\";\n      Assert.assertEquals(st.toString(), re);\n   }","id":101857,"modified_method":"@Test\n   public void testGetAllJavaLanguages() throws Exception\n   {\n      List<LocaleId> loc = this.testLocaleServiceImpl.getAllJavaLanguages();\n      StringBuilder st = new StringBuilder(\"\");\n      for (LocaleId localeId : loc)\n      {\n         st.append(localeId.getId() + \",\");\n      }\n      System.out.println(st);\n\n      String re = \"af,af-NA,af-ZA,ak,ak-GH,am,am-ET,ar,ar-AE,ar-BH,ar-DZ,ar-EG,ar-IQ,ar-JO,ar-KW,ar-LB,ar-LY,ar-MA,ar-OM,ar-QA,ar-SA,ar-SD,ar-SY,ar-TN,ar-YE,as,as-IN,asa,asa-TZ,az,az-Cyrl,az-Cyrl-AZ,az-Latn,az-Latn-AZ,be,be-BY,bem,bem-ZM,bez,bez-TZ,bg,bg-BG,bm,bm-ML,bn,bn-BD,bn-IN,bo,bo-CN,bo-IN,ca,ca-ES,cgg,cgg-UG,chr,chr-US,cs,cs-CZ,cy,cy-GB,da,da-DK,dav,dav-KE,de,de-AT,de-BE,de-CH,de-DE,de-LI,de-LU,ebu,ebu-KE,ee,ee-GH,ee-TG,el,el-CY,el-GR,en,en-AU,en-BE,en-BW,en-BZ,en-CA,en-GB,en-HK,en-IE,en-IN,en-JM,en-MH,en-MT,en-MU,en-NA,en-NZ,en-PH,en-PK,en-SG,en-TT,en-US,en-US-posix,en-VI,en-ZA,en-ZW,eo,es,es-AR,es-BO,es-CL,es-CO,es-CR,es-DO,es-EC,es-ES,es-GQ,es-GT,es-HN,es-MX,es-NI,es-PA,es-PE,es-PR,es-PY,es-SV,es-US,es-UY,es-VE,et,et-EE,eu,eu-ES,fa,fa-AF,fa-IR,ff,ff-SN,fi,fi-FI,fil,fil-PH,fo,fo-FO,fr,fr-BE,fr-BL,fr-CA,fr-CF,fr-CH,fr-CI,fr-CM,fr-FR,fr-GN,fr-GP,fr-LU,fr-MC,fr-MF,fr-MG,fr-ML,fr-MQ,fr-NE,fr-RE,fr-SN,ga,ga-IE,gl,gl-ES,gsw,gsw-CH,gu,gu-IN,guz,guz-KE,gv,gv-GB,ha,ha-Latn,ha-Latn-GH,ha-Latn-NE,ha-Latn-NG,haw,haw-US,he,he-IL,hi,hi-IN,hr,hr-HR,hu,hu-HU,hy,hy-AM,id,id-ID,ig,ig-NG,ii,ii-CN,is,is-IS,it,it-CH,it-IT,ja,ja-JP,jmc,jmc-TZ,ka,ka-GE,kab,kab-DZ,kam,kam-KE,kde,kde-TZ,kea,kea-CV,khq,khq-ML,ki,ki-KE,kk,kk-Cyrl,kk-Cyrl-KZ,kl,kl-GL,kln,kln-KE,km,km-KH,kn,kn-IN,ko,ko-KR,kok,kok-IN,kw,kw-GB,lag,lag-TZ,lg,lg-UG,lt,lt-LT,luo,luo-KE,luy,luy-KE,lv,lv-LV,mas,mas-KE,mas-TZ,mer,mer-KE,mfe,mfe-MU,mg,mg-MG,mk,mk-MK,ml,ml-IN,mr,mr-IN,ms,ms-BN,ms-MY,mt,mt-MT,naq,naq-NA,nb,nb-NO,nd,nd-ZW,ne,ne-IN,ne-NP,nl,nl-BE,nl-NL,nn,nn-NO,nyn,nyn-UG,om,om-ET,om-KE,or,or-IN,pa,pa-Arab,pa-Arab-PK,pa-Guru,pa-Guru-IN,pl,pl-PL,ps,ps-AF,pt,pt-BR,pt-GW,pt-MZ,pt-PT,rm,rm-CH,ro,ro-MD,ro-RO,rof,rof-TZ,ru,ru-MD,ru-RU,ru-UA,rw,rw-RW,rwk,rwk-TZ,saq,saq-KE,seh,seh-MZ,ses,ses-ML,sg,sg-CF,shi,shi-Latn,shi-Latn-MA,shi-Tfng,shi-Tfng-MA,si,si-LK,sk,sk-SK,sl,sl-SI,sn,sn-ZW,so,so-DJ,so-ET,so-KE,so-SO,sq,sq-AL,sr,sr-Cyrl,sr-Cyrl-BA,sr-Cyrl-ME,sr-Cyrl-RS,sr-Latn,sr-Latn-BA,sr-Latn-ME,sr-Latn-RS,sv,sv-FI,sv-SE,sw,sw-KE,sw-TZ,ta,ta-IN,ta-LK,te,te-IN,teo,teo-KE,teo-UG,th,th-TH,ti,ti-ER,ti-ET,to,to-TO,tr,tr-TR,tzm,tzm-Latn,tzm-Latn-MA,uk,uk-UA,ur,ur-IN,ur-PK,uz,uz-Arab,uz-Arab-AF,uz-Cyrl,uz-Cyrl-UZ,uz-Latn,uz-Latn-UZ,vi,vi-VN,vun,vun-TZ,xog,xog-UG,yo,yo-NG,zh,zh-Hans,zh-Hans-CN,zh-Hans-HK,zh-Hans-MO,zh-Hans-SG,zh-Hant,zh-Hant-HK,zh-Hant-MO,zh-Hant-TW,zu,zu-ZA,\";\n      Assert.assertEquals(st.toString(), re);\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Transactional\n   public String edit()\n   {\n      if (!identityStore.isNewUser())\n      {\n         HPerson person = personDAO.findById(authenticatedAccount.getPerson().getId(), true);\n         person.setName(this.name);\n         person.setEmail(this.email);\n         personDAO.makePersistent(person);\n         personDAO.flush();\n         authenticatedAccount.getPerson().setName(this.name);\n         authenticatedAccount.getPerson().setEmail(this.email);\n         log.debug(\"updated successfully\");\n         return \"updated\";\n      }\n      else\n      {\n         if (username != null)\n         {\n            createNewUser(username, null, email, name);\n            log.debug(\"create a new user:\" + name + \" \" + email);\n            if (Events.exists())\n               Events.instance().raiseEvent(Identity.EVENT_LOGIN_SUCCESSFUL);\n         }\n      }\n      return \"home\";\n   }","id":101858,"modified_method":"@Transactional\n   public String edit()\n   {\n      if (!identityStore.isNewUser(username))\n      {\n         HPerson person = personDAO.findById(authenticatedAccount.getPerson().getId(), true);\n         person.setName(this.name);\n         personDAO.makePersistent(person);\n         personDAO.flush();\n         authenticatedAccount.getPerson().setName(this.name);\n         log.debug(\"updated successfully\");\n         if (!authenticatedAccount.getPerson().getEmail().equals(this.email))\n         {\n            emailValidate(authenticatedAccount.getPerson().getId().toString(), this.email);\n         }\n\n         return \"updated\";\n      }\n      else\n      {\n         final String user = this.username;\n         String key = registerServiceImpl.register(user, \"\", this.name, this.email);\n         setActivationKey(key);\n         renderer.render(\"/WEB-INF/facelets/email/email_activation.xhtml\");\n         FacesMessages.instance().add(\"You will soon receive an email with a link to activate your account.\");\n\n         return \"/home.xhtml\";\n      }\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"public String cancel(){\n      if (identityStore.isNewUser())\n      {\n         if (identityStore.isNewUser())\n         {\n            identity.unAuthenticate();\n         }\n         return \"home\";\n      }\n      return \"view\";\n   }","id":101859,"modified_method":"public String cancel(){\n      if (identityStore.isNewUser(username))\n      {\n         return \"home\";\n      }\n      return \"view\";\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Create\n   public void onCreate()\n   {\n      username = identity.getCredentials().getUsername();\n      name = !identityStore.isNewUser() ? authenticatedAccount.getPerson().getName() : identity.getCredentials().getUsername();\n      if (identityStore.isNewUser())\n      {\n         String domain = \"example.com\";\n         HApplicationConfiguration ha = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_DOMAIN);\n         if (ha != null && ha.getValue() != null && !ha.getValue().isEmpty())\n         {\n            domain = ha.getValue();\n         }\n         email = identity.getCredentials().getUsername() + \"@\" + domain;\n      }else{\n         email=authenticatedAccount.getPerson().getEmail();\n      }\n   }","id":101860,"modified_method":"@Create\n   public void onCreate()\n   {\n      username = identity.getCredentials().getUsername();\n      if (identityStore.isNewUser(username))\n      {\n         name = identity.getCredentials().getUsername();\n         String domain = applicationConfiguration.getDomainName();\n         email = identity.getCredentials().getUsername() + \"@\" + domain;\n         identity.unAuthenticate();\n      }else{\n         HPerson person = personDAO.findById(authenticatedAccount.getPerson().getId(), true);\n         name = person.getName();\n         email = person.getEmail();\n         authenticatedAccount.getPerson().setName(this.name);\n         authenticatedAccount.getPerson().setEmail(this.email);\n      }\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@End\n   public String register()\n   {\n      valid = true;\n      validateUsername(getUsername());\n      validatePasswords(getPassword(), getPasswordConfirm());\n      validateTermsOfUse();\n\n      if (!isValid())\n      {\n         return null;\n      }\n\n      new RunAsOperation()\n      {\n         public void execute()\n         {\n            identityManager.createUser(getUsername(), getPassword());\n            identityManager.disableUser(getUsername());\n         }\n      }.addRole(\"admin\").run();\n\n      HAccount account = accountDAO.getByUsername(getUsername());\n\n      person.setAccount(account);\n      entityManager.persist(person);\n\n      HAccountActivationKey key = new HAccountActivationKey();\n      key.setAccount(account);\n      key.setKeyHash(HashUtil.generateHash(getUsername() + getPassword() + getPerson().getEmail() + getPerson().getName() + System.currentTimeMillis()));\n      entityManager.persist(key);\n\n      setActivationKey(key.getKeyHash());\n\n      renderer.render(\"/WEB-INF/facelets/email/activation.xhtml\");\n\n      FacesMessages.instance().add(\"You will soon receive an email with a link to activate your account.\");\n\n      return \"/home.xhtml\";\n   }","id":101861,"modified_method":"@End\n   public String register()\n   {\n      valid = true;\n      validateUsername(getUsername());\n      validatePasswords(getPassword(), getPasswordConfirm());\n      validateTermsOfUse();\n\n      if (!isValid())\n      {\n         return null;\n      }\n      final String user = getUsername();\n      final String pass = getPassword();\n      String key = registerServiceImpl.register(user, pass, getPerson().getName(), getPerson().getEmail());\n      setActivationKey(key);\n      log.info(\"get register key:\" + key);\n\n      renderer.render(\"/WEB-INF/facelets/email/activation.xhtml\");\n\n      FacesMessages.instance().add(\"You will soon receive an email with a link to activate your account.\");\n\n      return \"/home.xhtml\";\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Transactional\n   public void update()\n   {\n      HApplicationConfiguration helpUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HELP);\n      if (helpUrlValue != null)\n      {\n         if (helpUrl == null || helpUrl.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(helpUrlValue);\n         }\n         else\n         {\n            helpUrlValue.setValue(helpUrl);\n         }\n      }\n      else if (helpUrl != null && !helpUrl.isEmpty())\n      {\n         helpUrlValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_HELP, helpUrl);\n         applicationConfigurationDAO.makePersistent(helpUrlValue);\n      }\n\n      HApplicationConfiguration registerUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_REGISTER);\n      if (registerUrlValue != null)\n      {\n         if (registerUrl == null || registerUrl.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(registerUrlValue);\n         }\n         else\n         {\n            registerUrlValue.setValue(registerUrl);\n         }\n      }\n      else if (registerUrl != null && !registerUrl.isEmpty())\n      {\n         registerUrlValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_REGISTER, registerUrl);\n         applicationConfigurationDAO.makePersistent(registerUrlValue);\n      }\n\n      HApplicationConfiguration serverUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HOST);\n      if (serverUrlValue != null)\n      {\n         if (serverUrl == null || serverUrl.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(serverUrlValue);\n         }\n         else\n         {\n            serverUrlValue.setValue(serverUrl);\n         }\n      }\n      else if (serverUrl != null && !serverUrl.isEmpty())\n      {\n         serverUrlValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_HOST, serverUrl);\n         applicationConfigurationDAO.makePersistent(serverUrlValue);\n      }\n\n      HApplicationConfiguration emailDomainValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_DOMAIN);\n      if (emailDomainValue != null)\n      {\n         if (emailDomain == null || emailDomain.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(emailDomainValue);\n         }\n         else\n         {\n            emailDomainValue.setValue(emailDomain);\n         }\n      }\n      else if (emailDomain != null && !emailDomain.isEmpty())\n      {\n         emailDomainValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_DOMAIN, emailDomain);\n         applicationConfigurationDAO.makePersistent(emailDomainValue);\n      }\n\n      applicationConfigurationDAO.flush();\n      FacesMessages.instance().add(\"Configuration was successfully updated.\");\n      if (Events.exists())\n      {\n         Events.instance().raiseTransactionSuccessEvent(ApplicationConfiguration.EVENT_CONFIGURATION_CHANGED);\n      }\n   }","id":101862,"modified_method":"@Transactional\n   public void update()\n   {\n      HApplicationConfiguration helpUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HELP);\n      if (helpUrlValue != null)\n      {\n         if (helpUrl == null || helpUrl.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(helpUrlValue);\n         }\n         else\n         {\n            helpUrlValue.setValue(helpUrl);\n         }\n      }\n      else if (helpUrl != null && !helpUrl.isEmpty())\n      {\n         helpUrlValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_HELP, helpUrl);\n         applicationConfigurationDAO.makePersistent(helpUrlValue);\n      }\n\n      HApplicationConfiguration registerUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_REGISTER);\n      if (registerUrlValue != null)\n      {\n         if (registerUrl == null || registerUrl.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(registerUrlValue);\n         }\n         else\n         {\n            registerUrlValue.setValue(registerUrl);\n         }\n      }\n      else if (registerUrl != null && !registerUrl.isEmpty())\n      {\n         registerUrlValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_REGISTER, registerUrl);\n         applicationConfigurationDAO.makePersistent(registerUrlValue);\n      }\n\n      HApplicationConfiguration serverUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HOST);\n      if (serverUrlValue != null)\n      {\n         if (serverUrl == null || serverUrl.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(serverUrlValue);\n         }\n         else\n         {\n            serverUrlValue.setValue(serverUrl);\n         }\n      }\n      else if (serverUrl != null && !serverUrl.isEmpty())\n      {\n         serverUrlValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_HOST, serverUrl);\n         applicationConfigurationDAO.makePersistent(serverUrlValue);\n      }\n\n      HApplicationConfiguration emailDomainValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_DOMAIN);\n      if (emailDomainValue != null)\n      {\n         if (emailDomain == null || emailDomain.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(emailDomainValue);\n         }\n         else\n         {\n            emailDomainValue.setValue(emailDomain);\n         }\n      }\n\n      HApplicationConfiguration adminEmailValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_ADMIN_EMAIL);\n      if (adminEmailValue != null)\n      {\n         if (adminEmail == null || adminEmail.isEmpty())\n         {\n            applicationConfigurationDAO.makeTransient(adminEmailValue);\n         }\n         else\n         {\n            adminEmailValue.setValue(adminEmail);\n         }\n      }\n      else if (adminEmail != null && !adminEmail.isEmpty())\n      {\n         adminEmailValue = new HApplicationConfiguration(HApplicationConfiguration.KEY_ADMIN_EMAIL, adminEmail);\n         applicationConfigurationDAO.makePersistent(adminEmailValue);\n      }\n\n      applicationConfigurationDAO.flush();\n      FacesMessages.instance().add(\"Configuration was successfully updated.\");\n      if (Events.exists())\n      {\n         Events.instance().raiseTransactionSuccessEvent(ApplicationConfiguration.EVENT_CONFIGURATION_CHANGED);\n      }\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Create\n   public void onCreate()\n   {\n      HApplicationConfiguration helpUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HELP);\n      if (helpUrlValue != null)\n      {\n         this.helpUrl = helpUrlValue.getValue();\n      }\n      HApplicationConfiguration registerUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_REGISTER);\n      if (registerUrlValue != null)\n      {\n         this.registerUrl = registerUrlValue.getValue();\n      }\n      HApplicationConfiguration serverUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HOST);\n      if (serverUrlValue != null)\n      {\n         this.serverUrl = serverUrlValue.getValue();\n      }\n      HApplicationConfiguration emailDomainValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_DOMAIN);\n      if (emailDomainValue != null)\n      {\n         this.emailDomain = emailDomainValue.getValue();\n      }\n   }","id":101863,"modified_method":"@Create\n   public void onCreate()\n   {\n      HApplicationConfiguration helpUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HELP);\n      if (helpUrlValue != null)\n      {\n         this.helpUrl = helpUrlValue.getValue();\n      }\n      HApplicationConfiguration registerUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_REGISTER);\n      if (registerUrlValue != null)\n      {\n         this.registerUrl = registerUrlValue.getValue();\n      }\n      HApplicationConfiguration serverUrlValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_HOST);\n      if (serverUrlValue != null)\n      {\n         this.serverUrl = serverUrlValue.getValue();\n      }\n      HApplicationConfiguration emailDomainValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_DOMAIN);\n      if (emailDomainValue != null)\n      {\n         this.emailDomain = emailDomainValue.getValue();\n      }\n      HApplicationConfiguration adminEmailValue = applicationConfigurationDAO.findByKey(HApplicationConfiguration.KEY_ADMIN_EMAIL);\n      if (adminEmailValue != null)\n      {\n         this.adminEmail = adminEmailValue.getValue();\n      }\n   }","commit_id":"12d03093094e08c558e415e3fa3b7fc3581e502d","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void update(IColumn oldColumn, IColumn column)\n        {\n            if (column.isMarkedForDelete())\n                return;\n\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n            ((PerColumnSecondaryIndex) index).insert(key.key, column);\n        }","id":101864,"modified_method":"public void update(IColumn oldColumn, IColumn column)\n        {\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n            if (!column.isMarkedForDelete())\n                ((PerColumnSecondaryIndex) index).insert(key.key, column);\n        }","commit_id":"0ab3d60fb78194ab2d7dd04ae590f871a9286c31","url":"https://github.com/apache/cassandra"},{"original_method":"public void update(IColumn oldColumn, IColumn column)\n        {\n            if (column.isMarkedForDelete())\n                return;\n\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            if (index instanceof  PerColumnSecondaryIndex)\n            {\n                ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n                ((PerColumnSecondaryIndex) index).insert(key.key, column);\n            }\n            else\n            {\n                if (appliedRowLevelIndexes.add(index.getClass()))\n                    ((PerRowSecondaryIndex) index).index(key.key);\n            }\n        }","id":101865,"modified_method":"public void update(IColumn oldColumn, IColumn column)\n        {\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            if (index instanceof  PerColumnSecondaryIndex)\n            {\n                ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n                if (!column.isMarkedForDelete())\n                    ((PerColumnSecondaryIndex) index).insert(key.key, column);\n            }\n            else\n            {\n                if (appliedRowLevelIndexes.add(index.getClass()))\n                    ((PerRowSecondaryIndex) index).index(key.key);\n            }\n        }","commit_id":"0ab3d60fb78194ab2d7dd04ae590f871a9286c31","url":"https://github.com/apache/cassandra"},{"original_method":"public void update(Column oldColumn, Column column)\n        {\n            if (column.isMarkedForDelete())\n                return;\n\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            if (index instanceof  PerColumnSecondaryIndex)\n            {\n                ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n                ((PerColumnSecondaryIndex) index).insert(key.key, column);\n            }\n            else\n            {\n                if (appliedRowLevelIndexes.add(index.getClass()))\n                    ((PerRowSecondaryIndex) index).index(key.key);\n            }\n        }","id":101866,"modified_method":"public void update(Column oldColumn, Column column)\n        {\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            if (index instanceof  PerColumnSecondaryIndex)\n            {\n                ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n                if (!column.isMarkedForDelete())\n                    ((PerColumnSecondaryIndex) index).insert(key.key, column);\n            }\n            else\n            {\n                if (appliedRowLevelIndexes.add(index.getClass()))\n                    ((PerRowSecondaryIndex) index).index(key.key);\n            }\n        }","commit_id":"8ba462a08b782690119b3090d64ca88a24ba746f","url":"https://github.com/apache/cassandra"},{"original_method":"public void update(Column oldColumn, Column column)\n        {\n            if (column.isMarkedForDelete())\n                return;\n\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n            ((PerColumnSecondaryIndex) index).insert(key.key, column);\n        }","id":101867,"modified_method":"public void update(Column oldColumn, Column column)\n        {\n            SecondaryIndex index = indexFor(column.name());\n            if (index == null)\n                return;\n\n            ((PerColumnSecondaryIndex) index).delete(key.key, oldColumn);\n            if (!column.isMarkedForDelete())\n                ((PerColumnSecondaryIndex) index).insert(key.key, column);\n        }","commit_id":"8ba462a08b782690119b3090d64ca88a24ba746f","url":"https://github.com/apache/cassandra"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\n        \n        // return variable that accumulates replacements\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\n        serverObjects prop = new serverObjects();\n        String langPath = env.getConfigPath(\"locale.work\", \"DATA/LOCALE/locales\").getAbsolutePath();\n        String lang = env.getConfig(\"locale.language\", \"default\");\n        \n        int authentication = sb.adminAuthenticated(header);\n        if (authentication < 2) {\n            // must authenticate\n            prop.put(\"AUTHENTICATE\", \"admin log-in\"); \n            return prop;\n        }\n        \n        // starting a peer ping\n        \n        //boolean doPeerPing = false;\n        if ((sb.webIndex.seedDB.mySeed().isVirgin()) || (sb.webIndex.seedDB.mySeed().isJunior())) {\n            serverInstantBusyThread.oneTimeJob(sb.yc, \"peerPing\", null, 0);\n            //doPeerPing = true;\n        }\n        \n        // language settings\n        if ((post != null) && (!(post.get(\"language\", \"default\").equals(lang)))) {\n            translator.changeLang(env, langPath, post.get(\"language\", \"default\") + \".lng\");\n        }\n        \n        // peer name settings\n        String peerName = (post == null) ? env.getConfig(\"peerName\",\"\") : (String) post.get(\"peername\", \"\");\n        \n        // port settings\n        String port = env.getConfig(\"port\", \"8080\"); //this allows a low port, but it will only get one, if the user edits the config himself.\n\t\tif (post != null && Integer.parseInt(post.get(\"port\")) > 1023) {\n\t\t\tport = post.get(\"port\", \"8080\");\n\t\t}\n\n        // check if peer name already exists\n        yacySeed oldSeed = sb.webIndex.seedDB.lookupByName(peerName);\n        if ((oldSeed == null) && (!(env.getConfig(\"peerName\", \"\").equals(peerName)))) {\n            // the name is new\n        \tboolean nameOK = Pattern.compile(\"[A-Za-z0-9\\\\-_]{3,80}\").matcher(peerName).matches();\n            if (nameOK) env.setConfig(\"peerName\", peerName);\n        }\n \n        // check port\n        boolean reconnect = false;\n        if (!env.getConfig(\"port\", port).equals(port)) {\n            // validate port\n            serverCore theServerCore = (serverCore) env.getThread(\"10_httpd\");\n            env.setConfig(\"port\", port);\n            \n            // redirect the browser to the new port\n            reconnect = true;\n            \n            String host = null;\n            if (header.containsKey(httpHeader.HOST)) {\n                host = header.get(httpHeader.HOST);\n                int idx = host.indexOf(\":\");\n                if (idx != -1) host = host.substring(0,idx);\n            } else {\n                host = serverDomains.myPublicLocalIP().getHostAddress();\n            }\n            \n            prop.put(\"reconnect\", \"1\");\n            prop.put(\"reconnect_host\", host);\n            prop.put(\"nextStep_host\", host);\n            prop.put(\"reconnect_port\", port);\n            prop.put(\"nextStep_port\", port);\n            prop.put(\"reconnect_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n            prop.put(\"nextStep_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n            \n            // generate new shortcut (used for Windows)\n            //yacyAccessible.setNewPortBat(Integer.parseInt(port));\n            //yacyAccessible.setNewPortLink(Integer.parseInt(port));\n            \n            // force reconnection in 7 seconds\n            theServerCore.reconnect(7000);\n        } else {\n            prop.put(\"reconnect\", \"0\");\n        }\n\n        // set a use case\n        String networkName = sb.getConfig(\"network.unit.name\", \"\");\n        if (post != null && post.containsKey(\"usecase\")) {\n            if (post.get(\"usecase\", \"\").equals(\"freeworld\")) {\n                if (!networkName.equals(\"freeworld\")) {\n                    // switch to freeworld network\n                    sb.switchNetwork(\"defaults/yacy.network.freeworld.unit\");\n                }\n                // switch to p2p mode\n                sb.setConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, true);\n                sb.setConfig(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, true);\n            }\n            if (post.get(\"usecase\", \"\").equals(\"portal\")) {\n                if (!networkName.equals(\"webportal\")) {\n                    // switch to webportal network\n                    sb.switchNetwork(\"defaults/yacy.network.webportal.unit\");\n                }\n                // switch to robinson mode\n                sb.setConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, false);\n                sb.setConfig(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false);\n            }\n            if (post.get(\"usecase\", \"\").equals(\"intranet\")) {\n                if (!networkName.equals(\"intranet\")) {\n                    // switch to intranet network\n                    sb.switchNetwork(\"defaults/yacy.network.intranet.unit\");\n                }\n                // switch to p2p mode: enable ad-hoc networks between intranet users\n                sb.setConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, true);\n                sb.setConfig(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, true);\n            }\n        }\n        \n        networkName = sb.getConfig(\"network.unit.name\", \"\");\n        if (networkName.equals(\"freeworld\")) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_freeworldChecked\", 1);\n        } else if (networkName.equals(\"webportal\")) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_portalChecked\", 1);\n        } else if (networkName.equals(\"intranet\")) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_intranetChecked\", 1);\n        } else {\n            prop.put(\"setUseCase\", 0);\n        }\n        prop.put(\"setUseCase_port\", port);\n        \n        // check if values are proper\n        boolean properPassword = (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0) || sb.getConfigBool(\"adminAccountForLocalhost\", false);\n        boolean properName = (env.getConfig(\"peerName\",\"\").length() >= 3) && (!(yacySeed.isDefaultPeerName(env.getConfig(\"peerName\",\"\"))));\n        boolean properPort = (sb.webIndex.seedDB.mySeed().isSenior()) || (sb.webIndex.seedDB.mySeed().isPrincipal());\n        \n        if ((env.getConfig(\"defaultFiles\", \"\").startsWith(\"ConfigBasic.html,\"))) {\n        \tenv.setConfig(\"defaultFiles\", env.getConfig(\"defaultFiles\", \"\").substring(17));\n        \tenv.setConfig(\"browserPopUpPage\", \"Status.html\");\n            httpdFileHandler.initDefaultPath();\n        }\n        \n        prop.put(\"statusName\", properName ? \"1\" : \"0\");\n        prop.put(\"statusPort\", properPort ? \"1\" : \"0\");\n        if (reconnect) {\n            prop.put(\"nextStep\", NEXTSTEP_RECONNECT);\n        } else if (!properName) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERNAME);\n        } else if (!properPassword) {\n            prop.put(\"nextStep\", NEXTSTEP_PWD);\n        } else if (!properPort) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERPORT);\n        } else {\n            prop.put(\"nextStep\", NEXTSTEP_FINISHED);\n        }\n        \n        \n        // set default values       \n        prop.put(\"defaultName\", env.getConfig(\"peerName\", \"\"));\n        prop.put(\"defaultPort\", env.getConfig(\"port\", \"8080\"));\n        lang = env.getConfig(\"locale.language\", \"default\"); // re-assign lang, may have changed\n        if (lang.equals(\"default\")) {\n            prop.put(\"langDeutsch\", \"0\");\n            prop.put(\"langEnglish\", \"1\");\n        } else if (lang.equals(\"de\")) {\n            prop.put(\"langDeutsch\", \"1\");\n            prop.put(\"langEnglish\", \"0\");\n        } else {\n            prop.put(\"langDeutsch\", \"0\");\n            prop.put(\"langEnglish\", \"0\");\n        }\n        return prop;\n    }","id":101868,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\n        \n        // return variable that accumulates replacements\n        plasmaSwitchboard sb = (plasmaSwitchboard) env;\n        serverObjects prop = new serverObjects();\n        String langPath = env.getConfigPath(\"locale.work\", \"DATA/LOCALE/locales\").getAbsolutePath();\n        String lang = env.getConfig(\"locale.language\", \"default\");\n        \n        int authentication = sb.adminAuthenticated(header);\n        if (authentication < 2) {\n            // must authenticate\n            prop.put(\"AUTHENTICATE\", \"admin log-in\"); \n            return prop;\n        }\n        \n        // starting a peer ping\n        \n        //boolean doPeerPing = false;\n        if ((sb.webIndex.seedDB.mySeed().isVirgin()) || (sb.webIndex.seedDB.mySeed().isJunior())) {\n            serverInstantBusyThread.oneTimeJob(sb.yc, \"peerPing\", null, 0);\n            //doPeerPing = true;\n        }\n        \n        // language settings\n        if ((post != null) && (!(post.get(\"language\", \"default\").equals(lang)))) {\n            translator.changeLang(env, langPath, post.get(\"language\", \"default\") + \".lng\");\n        }\n        \n        // peer name settings\n        String peerName = (post == null) ? env.getConfig(\"peerName\",\"\") : (String) post.get(\"peername\", \"\");\n        \n        // port settings\n        String port = env.getConfig(\"port\", \"8080\"); //this allows a low port, but it will only get one, if the user edits the config himself.\n\t\tif (post != null && Integer.parseInt(post.get(\"port\")) > 1023) {\n\t\t\tport = post.get(\"port\", \"8080\");\n\t\t}\n\n        // check if peer name already exists\n        yacySeed oldSeed = sb.webIndex.seedDB.lookupByName(peerName);\n        if ((oldSeed == null) && (!(env.getConfig(\"peerName\", \"\").equals(peerName)))) {\n            // the name is new\n        \tboolean nameOK = Pattern.compile(\"[A-Za-z0-9\\\\-_]{3,80}\").matcher(peerName).matches();\n            if (nameOK) env.setConfig(\"peerName\", peerName);\n        }\n \n        // check port\n        boolean reconnect = false;\n        if (!env.getConfig(\"port\", port).equals(port)) {\n            // validate port\n            serverCore theServerCore = (serverCore) env.getThread(\"10_httpd\");\n            env.setConfig(\"port\", port);\n            \n            // redirect the browser to the new port\n            reconnect = true;\n            \n            String host = null;\n            if (header.containsKey(httpHeader.HOST)) {\n                host = header.get(httpHeader.HOST);\n                int idx = host.indexOf(\":\");\n                if (idx != -1) host = host.substring(0,idx);\n            } else {\n                host = serverDomains.myPublicLocalIP().getHostAddress();\n            }\n            \n            prop.put(\"reconnect\", \"1\");\n            prop.put(\"reconnect_host\", host);\n            prop.put(\"nextStep_host\", host);\n            prop.put(\"reconnect_port\", port);\n            prop.put(\"nextStep_port\", port);\n            prop.put(\"reconnect_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n            prop.put(\"nextStep_sslSupport\", theServerCore.withSSL() ? \"1\" : \"0\");\n            \n            // generate new shortcut (used for Windows)\n            //yacyAccessible.setNewPortBat(Integer.parseInt(port));\n            //yacyAccessible.setNewPortLink(Integer.parseInt(port));\n            \n            // force reconnection in 7 seconds\n            theServerCore.reconnect(7000);\n        } else {\n            prop.put(\"reconnect\", \"0\");\n        }\n\n        // set a use case\n        String networkName = sb.getConfig(\"network.unit.name\", \"\");\n        if (post != null && post.containsKey(\"usecase\")) {\n            if (post.get(\"usecase\", \"\").equals(\"freeworld\") && !networkName.equals(\"freeworld\")) {\n                // switch to freeworld network\n                sb.switchNetwork(\"defaults/yacy.network.freeworld.unit\");\n                // switch to p2p mode\n                sb.setConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, true);\n                sb.setConfig(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, true);\n            }\n            if (post.get(\"usecase\", \"\").equals(\"portal\") && !networkName.equals(\"webportal\")) {\n                // switch to webportal network\n                sb.switchNetwork(\"defaults/yacy.network.webportal.unit\");\n                // switch to robinson mode\n                sb.setConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, false);\n                sb.setConfig(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false);\n            }\n            if (post.get(\"usecase\", \"\").equals(\"intranet\") && !networkName.equals(\"intranet\")) {\n                // switch to intranet network\n                sb.switchNetwork(\"defaults/yacy.network.intranet.unit\");\n                // switch to p2p mode: enable ad-hoc networks between intranet users\n                sb.setConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, true);\n                sb.setConfig(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, true);\n            }\n        }\n        \n        networkName = sb.getConfig(\"network.unit.name\", \"\");\n        if (networkName.equals(\"freeworld\")) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_freeworldChecked\", 1);\n        } else if (networkName.equals(\"webportal\")) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_portalChecked\", 1);\n        } else if (networkName.equals(\"intranet\")) {\n            prop.put(\"setUseCase\", 1);\n            prop.put(\"setUseCase_intranetChecked\", 1);\n        } else {\n            prop.put(\"setUseCase\", 0);\n        }\n        prop.put(\"setUseCase_port\", port);\n        \n        // check if values are proper\n        boolean properPassword = (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0) || sb.getConfigBool(\"adminAccountForLocalhost\", false);\n        boolean properName = (env.getConfig(\"peerName\",\"\").length() >= 3) && (!(yacySeed.isDefaultPeerName(env.getConfig(\"peerName\",\"\"))));\n        boolean properPort = (sb.webIndex.seedDB.mySeed().isSenior()) || (sb.webIndex.seedDB.mySeed().isPrincipal());\n        \n        if ((env.getConfig(\"defaultFiles\", \"\").startsWith(\"ConfigBasic.html,\"))) {\n        \tenv.setConfig(\"defaultFiles\", env.getConfig(\"defaultFiles\", \"\").substring(17));\n        \tenv.setConfig(\"browserPopUpPage\", \"Status.html\");\n            httpdFileHandler.initDefaultPath();\n        }\n        \n        prop.put(\"statusName\", properName ? \"1\" : \"0\");\n        prop.put(\"statusPort\", properPort ? \"1\" : \"0\");\n        if (reconnect) {\n            prop.put(\"nextStep\", NEXTSTEP_RECONNECT);\n        } else if (!properName) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERNAME);\n        } else if (!properPassword) {\n            prop.put(\"nextStep\", NEXTSTEP_PWD);\n        } else if (!properPort) {\n            prop.put(\"nextStep\", NEXTSTEP_PEERPORT);\n        } else {\n            prop.put(\"nextStep\", NEXTSTEP_FINISHED);\n        }\n        \n        \n        // set default values       \n        prop.put(\"defaultName\", env.getConfig(\"peerName\", \"\"));\n        prop.put(\"defaultPort\", env.getConfig(\"port\", \"8080\"));\n        lang = env.getConfig(\"locale.language\", \"default\"); // re-assign lang, may have changed\n        if (lang.equals(\"default\")) {\n            prop.put(\"langDeutsch\", \"0\");\n            prop.put(\"langEnglish\", \"1\");\n        } else if (lang.equals(\"de\")) {\n            prop.put(\"langDeutsch\", \"1\");\n            prop.put(\"langEnglish\", \"0\");\n        } else {\n            prop.put(\"langDeutsch\", \"0\");\n            prop.put(\"langEnglish\", \"0\");\n        }\n        return prop;\n    }","commit_id":"5f41913043211eed62b54083381bf030aa604085","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean isRebuilding() {\n        FutureTask<Boolean> task = new FutureTask<>(dbPopulationService::isRunning);\n        Platform.runLater(task);\n        try {\n            return task.get();\n        } catch (InterruptedException interruptedException) {\n        } catch (ExecutionException executionException) {\n        }\n        return false;\n    }","id":101869,"modified_method":"public boolean isRebuilding() {\n        FutureTask<Boolean> task = new FutureTask<>(dbPopulationService::isRunning);\n        Platform.runLater(task);\n        try {\n            return task.get();\n        } catch (InterruptedException | ExecutionException exception) {\n            LOGGER.log(Level.SEVERE, \"There was an error determining the state of the db population service.\", exception);\n        }\n        return false;\n    }","commit_id":"cda31217ef4f6277e5984d7543ab6545cd17e79f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        @NbBundle.Messages({\"progressWindow.msg.refreshingFileTags=refreshing file tags\",\n            \"progressWindow.msg.refreshingResultTags=refreshing result tags\",\n            \"progressWindow.msg.commitingTags=committing tag changes\"})\n        protected Void call() throws Exception {\n            progressHandle.start();\n            EventDB.EventTransaction trans = eventDB.beginTransaction();\n            LOGGER.log(Level.INFO, \"dropping old tags\"); // NON-NLS\n            eventDB.reInitializeTags();\n\n            LOGGER.log(Level.INFO, \"updating content tags\"); // NON-NLS\n            List<ContentTag> contentTags = tagsManager.getAllContentTags();\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_refreshingFileTags(), this::cancel);\n            int currentWorkTotal = contentTags.size();\n            progressHandle.start(currentWorkTotal);\n\n            for (int i = 0; i < currentWorkTotal; i++) {\n                if (isCancelled()) {\n                    break;\n                }\n                update(new ProgressUpdate(i, currentWorkTotal, Bundle.progressWindow_msg_refreshingFileTags()));\n                ContentTag contentTag = contentTags.get(i);\n                eventDB.addTag(contentTag.getContent().getId(), null, contentTag);\n            }\n\n            LOGGER.log(Level.INFO, \"updating artifact tags\"); // NON-NLS\n            List<BlackboardArtifactTag> artifactTags = tagsManager.getAllBlackboardArtifactTags();\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_refreshingResultTags(), this::cancel);\n            currentWorkTotal = artifactTags.size();\n            progressHandle.start(currentWorkTotal);\n\n            for (int i = 0; i < currentWorkTotal; i++) {\n                if (isCancelled()) {\n                    break;\n                }\n                update(new ProgressUpdate(i, currentWorkTotal, Bundle.progressWindow_msg_refreshingResultTags()));\n                BlackboardArtifactTag artifactTag = artifactTags.get(i);\n                eventDB.addTag(artifactTag.getContent().getId(), artifactTag.getArtifact().getArtifactID(), artifactTag);\n            }\n\n            LOGGER.log(Level.INFO, \"committing tags\"); // NON-NLS\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_commitingTags());\n            progressHandle.start();\n            update(new ProgressUpdate(0, -1, Bundle.progressWindow_msg_commitingTags()));\n\n            if (isCancelled()) {\n                eventDB.rollBackTransaction(trans);\n            } else {\n                eventDB.commitTransaction(trans);\n            }\n            eventDB.analyze();\n            populateFilterData(skCase);\n            invalidateCaches();\n\n            progressHandle.finish();\n            return null;\n        }","id":101870,"modified_method":"@Override\n        @NbBundle.Messages({\"progressWindow.msg.refreshingFileTags=refreshing file tags\",\n            \"progressWindow.msg.refreshingResultTags=refreshing result tags\",\n            \"progressWindow.msg.commitingTags=committing tag changes\"})\n        protected Void call() throws Exception {\n            progressHandle.start();\n            EventDB.EventTransaction trans = eventDB.beginTransaction();\n            LOGGER.log(Level.INFO, \"dropping old tags\"); // NON-NLS\n            eventDB.reInitializeTags();\n\n            LOGGER.log(Level.INFO, \"updating content tags\"); // NON-NLS\n            List<ContentTag> contentTags = tagsManager.getAllContentTags();\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_refreshingFileTags(), this::cancel);\n            updateTitle(Bundle.progressWindow_msg_refreshingFileTags());\n            int currentWorkTotal = contentTags.size();\n            progressHandle.start(currentWorkTotal);\n\n            for (int i = 0; i < currentWorkTotal; i++) {\n                if (isCancelled()) {\n                    break;\n                }\n                updateProgress(i, currentWorkTotal);\n                ContentTag contentTag = contentTags.get(i);\n                eventDB.addTag(contentTag.getContent().getId(), null, contentTag);\n            }\n\n            LOGGER.log(Level.INFO, \"updating artifact tags\"); // NON-NLS\n            List<BlackboardArtifactTag> artifactTags = tagsManager.getAllBlackboardArtifactTags();\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_refreshingResultTags(), this::cancel);\n            updateTitle(Bundle.progressWindow_msg_refreshingResultTags());\n            currentWorkTotal = artifactTags.size();\n            progressHandle.start(currentWorkTotal);\n            for (int i = 0; i < currentWorkTotal; i++) {\n                if (isCancelled()) {\n                    break;\n                }\n                updateProgress(i, currentWorkTotal);\n                BlackboardArtifactTag artifactTag = artifactTags.get(i);\n                eventDB.addTag(artifactTag.getContent().getId(), artifactTag.getArtifact().getArtifactID(), artifactTag);\n            }\n\n            LOGGER.log(Level.INFO, \"committing tags\"); // NON-NLS\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_commitingTags());\n            progressHandle.start();\n            updateTitle(Bundle.progressWindow_msg_commitingTags());\n            updateProgress(-.5, 1);\n\n            if (isCancelled()) {\n                eventDB.rollBackTransaction(trans);\n            } else {\n                eventDB.commitTransaction(trans);\n            }\n            eventDB.analyze();\n            populateFilterData(skCase);\n            invalidateCaches();\n\n            progressHandle.finish();\n            return null;\n        }","commit_id":"cda31217ef4f6277e5984d7543ab6545cd17e79f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * populate all the events of one subtype\n         *\n         * @param subType the subtype to populate\n         * @param trans   the db transaction to use\n         * @param skCase  a reference to the sleuthkit case\n         */\n        @NbBundle.Messages({\"# {0} - event type \", \"progressWindow.populatingXevents=Populating {0} events\"})\n        private void populateEventType(final ArtifactEventType type, EventDB.EventTransaction trans) {\n            try {\n                //get all the blackboard artifacts corresponding to the given event sub_type\n                final ArrayList<BlackboardArtifact> blackboardArtifacts = skCase.getBlackboardArtifacts(type.getArtifactType());\n                final int numArtifacts = blackboardArtifacts.size();\n                progressHandle.finish();\n                progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_populatingXevents(type.getDisplayName()), () -> cancel(true));\n                progressHandle.start(numArtifacts);\n                for (int i = 0; i < numArtifacts; i++) {\n                    try {\n                        //for each artifact, extract the relevant information for the descriptions\n                        insertEventForArtifact(type, blackboardArtifacts.get(i), trans);\n                        update(new ProgressUpdate(i, numArtifacts,\n                                Bundle.progressWindow_populatingXevents(type.getDisplayName())));\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"There was a problem inserting event for artifact: \" + blackboardArtifacts.get(i).getArtifactID(), ex); // NON-NLS\n                    }\n                }\n            } catch (TskCoreException ex) {\n                LOGGER.log(Level.SEVERE, \"There was a problem getting events with sub type \" + type.toString() + \".\", ex); // NON-NLS\n            }\n        }","id":101871,"modified_method":"/**\n         * populate all the events of one subtype\n         *\n         * @param subType the subtype to populate\n         * @param trans   the db transaction to use\n         * @param skCase  a reference to the sleuthkit case\n         */\n        @NbBundle.Messages({\"# {0} - event type \", \"progressWindow.populatingXevents=Populating {0} events\"})\n        private void populateEventType(final ArtifactEventType type, EventDB.EventTransaction trans) {\n            try {\n                //get all the blackboard artifacts corresponding to the given event sub_type\n                final ArrayList<BlackboardArtifact> blackboardArtifacts = skCase.getBlackboardArtifacts(type.getArtifactType());\n                final int numArtifacts = blackboardArtifacts.size();\n                progressHandle.finish();\n                progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_populatingXevents(type.getDisplayName()), () -> cancel(true));\n                progressHandle.start(numArtifacts);\n                updateTitle(Bundle.progressWindow_populatingXevents(type.getDisplayName()));\n                for (int i = 0; i < numArtifacts; i++) {\n                    try {\n                        //for each artifact, extract the relevant information for the descriptions\n                        insertEventForArtifact(type, blackboardArtifacts.get(i), trans);\n                        updateProgress(i, numArtifacts);\n                    } catch (TskCoreException ex) {\n                        LOGGER.log(Level.SEVERE, \"There was a problem inserting event for artifact: \" + blackboardArtifacts.get(i).getArtifactID(), ex); // NON-NLS\n                    }\n                }\n            } catch (TskCoreException ex) {\n                LOGGER.log(Level.SEVERE, \"There was a problem getting events with sub type \" + type.toString() + \".\", ex); // NON-NLS\n            }\n        }","commit_id":"cda31217ef4f6277e5984d7543ab6545cd17e79f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * update progress UIs\n         *\n         * @param chunk\n         */\n        final protected void update(ProgressUpdate chunk) {\n            updateProgress(chunk.getProgress(), chunk.getTotal());\n            updateMessage(chunk.getDetailMessage());\n            updateTitle(chunk.getHeaderMessage());\n\n            if (chunk.getTotal() >= 0) {\n                progressHandle.progress(chunk.getProgress());\n            }\n            progressHandle.setDisplayName(chunk.getHeaderMessage());\n            progressHandle.progress(chunk.getDetailMessage());\n        }","id":101872,"modified_method":"@Override\n        protected void updateProgress(double workDone, double max) {\n            super.updateProgress(workDone, max);\n            if (workDone >= 0) {\n                progressHandle.progress((int) workDone);\n            }\n        }","commit_id":"cda31217ef4f6277e5984d7543ab6545cd17e79f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        @NbBundle.Messages({\"progressWindow.msg.populateMacEventsFiles=Populating MAC time events for files\",\n            \"progressWindow.msg.reinit_db=(Re)Initializing events database\",\n            \"progressWindow.msg.gatheringData=Gather event data\",\n            \"progressWindow.msg.commitingDb=committing events db\"})\n        protected Void call() throws Exception {\n            LOGGER.log(Level.INFO, \"Beginning population of timeline db.\"); // NON-NLS\n            progressHandle.start();\n            update(new ProgressUpdate(0, -1, Bundle.progressWindow_msg_reinit_db()));\n            //reset database //TODO: can we do more incremental updates? -jm\n            eventDB.reInitializeDB();\n\n            update(new ProgressUpdate(0, -1, Bundle.progressWindow_msg_gatheringData()));\n            long lastObjId = skCase.getLastObjectId();\n            long lastArtfID = TimeLineController.getCaseLastArtifactID(skCase);\n            boolean injestRunning = IngestManager.getInstance().isIngestRunning();\n\n            //grab ids of all files\n            List<Long> fileIDs = skCase.findAllFileIdsWhere(\"name != '.' AND name != '..'\");\n            final int numFiles = fileIDs.size();\n            progressHandle.switchToDeterminate(numFiles);\n            update(new ProgressUpdate(0, numFiles, Bundle.progressWindow_msg_populateMacEventsFiles()));\n\n            //insert file events into db\n            EventDB.EventTransaction trans = eventDB.beginTransaction();\n            for (int i = 0; i < numFiles; i++) {\n                if (isCancelled()) {\n                    break;\n                } else {\n                    long fID = fileIDs.get(i);\n                    try {\n                        AbstractFile f = skCase.getAbstractFileById(fID);\n\n                        if (isNull(f)) {\n                            LOGGER.log(Level.WARNING, \"Failed to get data for file : {0}\", fID); // NON-NLS\n                        } else {\n                            insertEventsForFile(f, trans);\n                            update(new ProgressUpdate(i, numFiles,\n                                    Bundle.progressWindow_msg_populateMacEventsFiles(), f.getName()));\n                        }\n                    } catch (TskCoreException tskCoreException) {\n                        LOGGER.log(Level.SEVERE, \"Failed to insert MAC time events for file : \" + fID, tskCoreException); // NON-NLS\n                    }\n                }\n            }\n\n            //insert artifact based events\n            //TODO: use (not-yet existing api) to grab all artifacts with timestamps, rather than the hardcoded lists in EventType -jm\n            for (EventType type : RootEventType.allTypes) {\n                if (isCancelled()) {\n                    break;\n                }\n                //skip file_system events, they are already handled above.\n                if (type instanceof ArtifactEventType) {\n                    populateEventType((ArtifactEventType) type, trans);\n                }\n            }\n\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_commitingDb());\n            progressHandle.start();\n            update(new ProgressUpdate(0, -1, Bundle.progressWindow_msg_commitingDb()));\n\n            if (isCancelled()) {\n                eventDB.rollBackTransaction(trans);\n            } else {\n                eventDB.commitTransaction(trans);\n            }\n            eventDB.analyze();\n            populateFilterData(skCase);\n            invalidateCaches();\n\n            recordDBPopulationState(lastObjId, lastArtfID, injestRunning);\n            progressHandle.finish();\n            return null;\n        }","id":101873,"modified_method":"@Override\n        @NbBundle.Messages({\"progressWindow.msg.populateMacEventsFiles=Populating MAC time events for files\",\n            \"progressWindow.msg.reinit_db=(Re)Initializing events database\",\n            \"progressWindow.msg.gatheringData=Gather event data\",\n            \"progressWindow.msg.commitingDb=committing events db\"})\n        protected Void call() throws Exception {\n            LOGGER.log(Level.INFO, \"Beginning population of timeline db.\"); // NON-NLS\n            progressHandle.start();\n            updateProgress(-.5, 1);\n            updateTitle(Bundle.progressWindow_msg_reinit_db());\n            //reset database //TODO: can we do more incremental updates? -jm\n            eventDB.reInitializeDB();\n\n            updateTitle(Bundle.progressWindow_msg_gatheringData());\n            long lastObjId = skCase.getLastObjectId();\n            long lastArtfID = TimeLineController.getCaseLastArtifactID(skCase);\n            boolean injestRunning = IngestManager.getInstance().isIngestRunning();\n\n            //grab ids of all files\n            List<Long> fileIDs = skCase.findAllFileIdsWhere(\"name != '.' AND name != '..'\");\n            final int numFiles = fileIDs.size();\n            progressHandle.switchToDeterminate(numFiles);\n            updateTitle(Bundle.progressWindow_msg_populateMacEventsFiles());\n\n            //insert file events into db\n            EventDB.EventTransaction trans = eventDB.beginTransaction();\n            for (int i = 0; i < numFiles; i++) {\n                if (isCancelled()) {\n                    break;\n                } else {\n                    long fID = fileIDs.get(i);\n                    try {\n                        AbstractFile f = skCase.getAbstractFileById(fID);\n\n                        if (isNull(f)) {\n                            LOGGER.log(Level.WARNING, \"Failed to get data for file : {0}\", fID); // NON-NLS\n                        } else {\n                            insertEventsForFile(f, trans);\n                            updateProgress(i, numFiles);\n                            updateMessage(f.getName());\n                        }\n                    } catch (TskCoreException tskCoreException) {\n                        LOGGER.log(Level.SEVERE, \"Failed to insert MAC time events for file : \" + fID, tskCoreException); // NON-NLS\n                    }\n                }\n            }\n\n            //insert artifact based events\n            //TODO: use (not-yet existing api) to grab all artifacts with timestamps, rather than the hardcoded lists in EventType -jm\n            for (EventType type : RootEventType.allTypes) {\n                if (isCancelled()) {\n                    break;\n                }\n                //skip file_system events, they are already handled above.\n                if (type instanceof ArtifactEventType) {\n                    populateEventType((ArtifactEventType) type, trans);\n                }\n            }\n\n            progressHandle.finish();\n            progressHandle = ProgressHandleFactory.createHandle(Bundle.progressWindow_msg_commitingDb());\n            progressHandle.start();\n            updateProgress(-0.5, 1);\n            updateTitle(Bundle.progressWindow_msg_commitingDb());\n\n            if (isCancelled()) {\n                eventDB.rollBackTransaction(trans);\n            } else {\n                eventDB.commitTransaction(trans);\n            }\n            eventDB.analyze();\n            populateFilterData(skCase);\n            invalidateCaches();\n\n            recordDBPopulationState(lastObjId, lastArtfID, injestRunning);\n            progressHandle.finish();\n            return null;\n        }","commit_id":"cda31217ef4f6277e5984d7543ab6545cd17e79f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"protected void testCase(String inputURL, String xslURL, String outputURL) throws Exception {\n//\t\tString input = loadFile(XSLTS_folder+\"TestInputs/\"+inputURL, false);\n//\t\tString stylesheet = loadFile(XSLTS_folder+\"TestInputs/\"+xslURL, true);\n\n\t\tString expectedError = \"\";\n\n        String query = \"xquery version \\\"1.0\\\";\\n\" +\n                \"declare namespace transform=\\\"http://exist-db.org/xquery/transform\\\";\\n\" +\n                \"declare variable $xml external;\\n\" +\n                \"declare variable $xslt external;\\n\" +\n                \"transform:transform($xml, $xslt, ())\\n\";\n        \n\t\ttry {\n\t\t\tXQueryContext context;\n\t\t\tXQuery xquery;\n\t\t\t\n\t\t\tDBBroker broker = null;\n\t\t\ttry {\t\n\t\t\t\tbroker = pool.get(pool.getSecurityManager().getSystemSubject());\n\t\t\t\txquery = broker.getXQueryService();\n\n\t\t\t\tbroker.getConfiguration().setProperty( XQueryContext.PROPERTY_XQUERY_RAISE_ERROR_ON_FAILED_RETRIEVAL, true);\n\t\t\t\t\n\t\t\t\tcontext = xquery.newContext(AccessContext.TEST);\n\t\t        \n\t\t\t} catch (Exception e) {\n\t\t\t\tAssert.fail(e.getMessage());\n\t\t\t\treturn;\n\t\t\t} finally {\n\t\t\t\tpool.release(broker);\n\t\t\t}\n\n\t\t\t//workaround\n\t        Document doc = new DocumentImpl(context, false);\n\t        Element outputFile = doc.createElement(\"outputFile\");\n\t        outputFile.setTextContent(outputURL);\n\n\t\t\t//declare variable\n\t\t\tcontext.declareVariable(\"xml\", loadVarFromURI(context, testLocation+XSLTS_folder+\"/TestInputs/\"+inputURL));\n\t\t\tcontext.declareVariable(\"xslt\", loadVarFromURI(context, testLocation+XSLTS_folder+\"/TestInputs/\"+xslURL));\n\t\t\t\n\t\t\t//compile\n\t\t\tCompiledXQuery compiled = xquery.compile(context, query);\n\t\t\t\n\t\t\t//execute\n\t\t\tSequence result = xquery.execute(compiled, null);\n\t\t\t\n\t\t\t//compare result with one provided by test case\n\t\t\tboolean ok = false;\n\t\t\tif (compareResult(\"\", XSLTS_folder+\"/ExpectedTestResults/\", outputFile, result)) {\n\t\t\t\tok = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (!ok)\n\t\t\t\tAssert.fail(\"expected \\n\" +\n\t\t\t\t\t\t\"[\"+readFileAsString(new File(testLocation+XSLTS_folder+\"/ExpectedTestResults/\", outputFile.getNodeValue()))+\"]\\n\" +\n\t\t\t\t\t\t\", get \\n[\"+sequenceToString(result)+\"]\");\n\t\t} catch (XPathException e) {\n\t\t\tString error = e.getMessage();\n\n\t\t\tif (!expectedError.isEmpty())\n\t\t\t\t;\n\t\t\telse Assert.fail(\"expected error is \"+expectedError+\", get \"+error+\" [\"+e.getMessage()+\"]\");\n\t\t}\n\n//        StringBuilder content = new StringBuilder();\n//    \tfor (int i = 0; i < result.getSize(); i++)\n//    \t\tcontent.append((String) result.getResource(i).getContent());\n//\n//        assertTrue(checkResult(outputURL, content.toString()));\n\t}","id":101874,"modified_method":"protected void testCase(String inputURL, String xslURL, String outputURL) throws Exception {\n//\t\tString input = loadFile(XSLTS_folder+\"TestInputs/\"+inputURL, false);\n//\t\tString stylesheet = loadFile(XSLTS_folder+\"TestInputs/\"+xslURL, true);\n\n\t\tString expectedError = \"\";\n\n        String query = \"xquery version \\\"1.0\\\";\\n\" +\n                \"declare namespace transform=\\\"http://exist-db.org/xquery/transform\\\";\\n\" +\n                \"declare variable $xml external;\\n\" +\n                \"declare variable $xslt external;\\n\" +\n                \"transform:transform($xml, $xslt, ())\\n\";\n        \n\t\ttry {\n\t\t\tXQueryContext context;\n\t\t\tXQuery xquery;\n\t\t\t\n\t\t\tDBBroker broker = null;\n\t\t\ttry {\t\n\t\t\t\tbroker = pool.get(pool.getSecurityManager().getSystemSubject());\n\t\t\t\txquery = broker.getXQueryService();\n\n\t\t\t\tbroker.getConfiguration().setProperty( XQueryContext.PROPERTY_XQUERY_RAISE_ERROR_ON_FAILED_RETRIEVAL, true);\n\t\t\t\t\n\t\t\t\tcontext = xquery.newContext(AccessContext.TEST);\n\t\t        \n\t\t\t} catch (Exception e) {\n\t\t\t\tAssert.fail(e.getMessage());\n\t\t\t\treturn;\n\t\t\t} finally {\n\t\t\t\tpool.release(broker);\n\t\t\t}\n\n\t\t\t//workaround\n\t        Document doc = new DocumentImpl(context, false);\n\t        Element outputFile = doc.createElement(\"outputFile\");\n\t        outputFile.setTextContent(outputURL);\n\n\t\t\t//declare variable\n\t        if (inputURL !=  null && inputURL != \"\")\n\t        \tcontext.declareVariable(\"xml\", loadVarFromURI(context, testLocation+XSLTS_folder+\"/TestInputs/\"+inputURL));\n\t        else\n\t        \tcontext.declareVariable(\"xml\", loadVarFromString(context, \"<empty/>\"));\n\t        \t\n\t\t\tcontext.declareVariable(\"xslt\", loadVarFromURI(context, testLocation+XSLTS_folder+\"/TestInputs/\"+xslURL));\n\t\t\t\n\t\t\t//compile\n\t\t\tCompiledXQuery compiled = xquery.compile(context, query);\n\t\t\t\n\t\t\t//execute\n\t\t\tSequence result = xquery.execute(compiled, null);\n\t\t\t\n\t\t\t//compare result with one provided by test case\n\t\t\tboolean ok = false;\n\t\t\tif (compareResult(\"\", XSLTS_folder+\"/ExpectedTestResults/\", outputFile, result)) {\n\t\t\t\tok = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (!ok)\n\t\t\t\tAssert.fail(\"expected \\n\" +\n\t\t\t\t\t\t\"[\"+readFileAsString(new File(testLocation+XSLTS_folder+\"/ExpectedTestResults/\", outputFile.getNodeValue()))+\"]\\n\" +\n\t\t\t\t\t\t\", get \\n[\"+sequenceToString(result)+\"]\");\n\t\t} catch (XPathException e) {\n\t\t\tString error = e.getMessage();\n\n\t\t\tif (!expectedError.isEmpty())\n\t\t\t\t;\n\t\t\telse Assert.fail(\"expected error is \"+expectedError+\", get \"+error+\" [\"+e.getMessage()+\"]\");\n\t\t}\n\n//        StringBuilder content = new StringBuilder();\n//    \tfor (int i = 0; i < result.getSize(); i++)\n//    \t\tcontent.append((String) result.getResource(i).getContent());\n//\n//        assertTrue(checkResult(outputURL, content.toString()));\n\t}","commit_id":"5da87332d35cde505deff98e55ec276b62f198a0","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Read to optional static-context fragment to initialize\n\t * the context.\n\t * \n\t * @param root\n\t * @param innerContext\n\t * @throws XPathException\n\t */\n\tprivate void initContext(Node root, XQueryContext innerContext) throws XPathException {\n\t\tNodeList cl = root.getChildNodes();\n\t\tfor (int i = 0; i < cl.getLength(); i++) {\n\t\t\tNode child = cl.item(i);\n\t\t\t//TODO : more check on attributes existence and on their values\n\t\t\tif (child.getNodeType() == Node.ELEMENT_NODE &&\t\"variable\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\tString qname = elem.getAttribute(\"name\");\n\t\t\t\tNodeValue value = (NodeValue) elem.getFirstChild();\n\t\t\t\tif (value instanceof ReferenceNode)\n\t\t\t\t\tvalue = ((ReferenceNode) value).getReference();\n\t\t\t\tinnerContext.declareVariable(qname, value);\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"output-size-limit\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tinnerContext.getWatchDog().setMaxNodes(Integer.valueOf(elem.getAttribute(\"value\")).intValue());\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"current-dateTime\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tDateTimeValue dtv = new DateTimeValue(elem.getAttribute(\"value\"));\n\t        \tinnerContext.setCalendar(dtv.calendar);\t        \t\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"implicit-timezone\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tDuration duration = TimeUtils.getInstance().newDuration(elem.getAttribute(\"value\")); \t        \n\t        \tinnerContext.setTimeZone(new SimpleTimeZone((int)duration.getTimeInMillis(new Date()), \"XQuery context\"));      \t\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"unbind-namespace\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tif (elem.getAttribute(\"uri\") != null) {\t\t\n\t\t\t\t\tinnerContext.removeNamespace(elem.getAttribute(\"uri\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":101875,"modified_method":"/**\n\t * Read to optional static-context fragment to initialize\n\t * the context.\n\t * \n\t * @param root\n\t * @param innerContext\n\t * @throws XPathException\n\t */\n\tprivate void initContext(Node root, XQueryContext innerContext) throws XPathException {\n\t\tNodeList cl = root.getChildNodes();\n\t\tfor (int i = 0; i < cl.getLength(); i++) {\n\t\t\tNode child = cl.item(i);\n\t\t\t//TODO : more check on attributes existence and on their values\n\t\t\tif (child.getNodeType() == Node.ELEMENT_NODE &&\t\"variable\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\tString qname = elem.getAttribute(\"name\");\n\t\t\t\tNodeValue value = (NodeValue) elem.getFirstChild();\n\t\t\t\tif (value instanceof ReferenceNode)\n\t\t\t\t\tvalue = ((ReferenceNode) value).getReference();\n\t\t\t\tString type = elem.getAttribute(\"type\");\n\t\t\t\tif (type != null && Type.subTypeOf(Type.getType(type), Type.ATOMIC)) {\n\t\t\t\t\tinnerContext.declareVariable(qname, value.atomize().convertTo(Type.getType(type)));\n\t\t\t\t} else {\n\t\t\t\t\tinnerContext.declareVariable(qname, value);\n\t\t\t\t}\t\t\t\t\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"output-size-limit\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tinnerContext.getWatchDog().setMaxNodes(Integer.valueOf(elem.getAttribute(\"value\")).intValue());\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"current-dateTime\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tDateTimeValue dtv = new DateTimeValue(elem.getAttribute(\"value\"));\n\t        \tinnerContext.setCalendar(dtv.calendar);\t        \t\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"implicit-timezone\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tDuration duration = TimeUtils.getInstance().newDuration(elem.getAttribute(\"value\")); \t        \n\t        \tinnerContext.setTimeZone(new SimpleTimeZone((int)duration.getTimeInMillis(new Date()), \"XQuery context\"));      \t\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"unbind-namespace\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : error check\n\t\t\t\tif (elem.getAttribute(\"uri\") != null) {\t\t\n\t\t\t\t\tinnerContext.removeNamespace(elem.getAttribute(\"uri\"));\n\t\t\t\t}\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE &&\t\"staticallyKnownDocuments\".equals(child.getLocalName())) {\n\t\t\t\tElement elem = (Element) child;\n\t\t\t\t//TODO : iterate over the children\n\t\t\t\tNodeValue value = (NodeValue) elem.getFirstChild();\n\t\t\t\tif (value instanceof ReferenceNode)\n\t\t\t\t\tvalue = ((ReferenceNode) value).getReference();\t\n\t\t\t\tXmldbURI[] pathes = new XmldbURI[1];\n\t\t\t\t//TODO : aggregate !\n\t\t\t\t//TODO : cleanly seperate the statically know docollection and documents\n\t\t\t\tpathes[0] = XmldbURI.create(value.getStringValue());\n\t\t\t\tinnerContext.setStaticallyKnownDocuments(pathes);\n\t\t\t}\n\t\t}\n\t}","commit_id":"6026b1f7c25dabf9b80bf1d158d7c2299133f37d","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t *  Remove the specified document from the collection.\n\t *\n\t *@param  name\n\t */\n\tpublic void removeDocument(Txn transaction, DBBroker broker, String docname)\n\t\t\tthrows PermissionDeniedException, TriggerException, LockException {\n        try {\n            getLock().acquire(Lock.READ_LOCK);\n    \t    DocumentTrigger trigger = null;\n    \t    if (!docname.endsWith(CollectionConfiguration.COLLECTION_CONFIG_SUFFIX)) {\n    \t        if (triggersEnabled) {\n    \t            CollectionConfiguration config = getConfiguration(broker);\n    \t            if (config != null)\n    \t                trigger = (DocumentTrigger) \n    \t                config.getTrigger(Trigger.REMOVE_DOCUMENT_EVENT);\n    \t        }\n    \t    } else {\n    \t        // we remove a collection.xconf configuration file: tell the configuration manager to\n    \t        // reload the configuration.\n    \t        CollectionConfigurationManager confMgr = broker.getBrokerPool().getConfigurationManager();\n    \t        confMgr.invalidateAll(getName());\n    \t    }\n    \t    DocumentImpl doc = getDocument(broker, docname);\n    \t    if (doc == null)\n    \t        return;\n    \t    if(doc.isLockedForWrite())\n    \t        throw new PermissionDeniedException(\"Document \" + doc.getFileName() + \n    \t        \" is locked for write\");\n    \t    if (!getPermissions().validate(broker.getUser(), Permission.WRITE))\n    \t        throw new PermissionDeniedException(\n    \t                \"Write access to collection denied; user=\" + broker.getUser().getName());\n    \t    if (!doc.getPermissions().validate(broker.getUser(), Permission.WRITE))\n    \t        throw new PermissionDeniedException(\"Permission to remove document denied\");\n    \t    if (trigger != null && triggersEnabled) {\n    \t        trigger.prepare(Trigger.REMOVE_DOCUMENT_EVENT, broker, transaction, \n    \t        \t\tgetName() + \"/\" + docname, doc);\n    \t    }\n    \t    \n    \t    broker.removeDocument(transaction, doc);\n    \t    documents.remove(docname);\n    \t    if (trigger != null && triggersEnabled) {\n    \t        trigger.finish(Trigger.REMOVE_DOCUMENT_EVENT, broker, transaction, null);\n    \t    }\n    \t    broker.getBrokerPool().getNotificationService().notifyUpdate(doc, UpdateListener.REMOVE);\n        } finally {\n            getLock().release();\n        }\n\t}","id":101876,"modified_method":"/**\n\t *  Remove the specified document from the collection.\n\t *\n\t *@param  name\n\t */\n\tpublic void removeDocument(Txn transaction, DBBroker broker, String docname)\n\t\t\tthrows PermissionDeniedException, TriggerException, LockException {\n        try {\n            getLock().acquire(Lock.READ_LOCK);\n    \t    DocumentTrigger trigger = null;\n    \t    if (!docname.endsWith(CollectionConfiguration.COLLECTION_CONFIG_SUFFIX)) {\n    \t        if (triggersEnabled) {\n    \t            CollectionConfiguration config = getConfiguration(broker);\n    \t            if (config != null)\n    \t                trigger = (DocumentTrigger) \n    \t                config.getTrigger(Trigger.REMOVE_DOCUMENT_EVENT);\n    \t        }\n    \t    } else {\n    \t        // we remove a collection.xconf configuration file: tell the configuration manager to\n    \t        // reload the configuration.\n    \t        CollectionConfigurationManager confMgr = broker.getBrokerPool().getConfigurationManager();\n    \t        confMgr.invalidateAll(getName());\n    \t    }\n    \t    DocumentImpl doc = getDocument(broker, docname);\n    \t    if (doc == null)\n    \t        return;\n    \t    if(doc.isLockedForWrite())\n    \t        throw new PermissionDeniedException(\"Document \" + doc.getFileName() + \n    \t        \" is locked for write\");\n    \t    if (!getPermissions().validate(broker.getUser(), Permission.WRITE))\n    \t        throw new PermissionDeniedException(\n    \t                \"Write access to collection denied; user=\" + broker.getUser().getName());\n    \t    if (!doc.getPermissions().validate(broker.getUser(), Permission.WRITE))\n    \t        throw new PermissionDeniedException(\"Permission to remove document denied\");\n    \t    if (trigger != null && triggersEnabled) {\n    \t        trigger.prepare(Trigger.REMOVE_DOCUMENT_EVENT, broker, transaction, \n    \t        \t\tgetName() + \"/\" + docname, doc);\n    \t    }\n    \t    \n    \t    broker.removeDocument(transaction, doc);\n    \t    documents.remove(docname);\n    \t    if (trigger != null && triggersEnabled) {\n    \t        trigger.finish(Trigger.REMOVE_DOCUMENT_EVENT, broker, transaction, doc);\n    \t    }\n    \t    broker.getBrokerPool().getNotificationService().notifyUpdate(doc, UpdateListener.REMOVE);\n        } finally {\n            getLock().release();\n        }\n\t}","commit_id":"bbdd0bb497041f884bc3e183f4c8bd8a1291cf9d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void finish(int event, DBBroker broker, Txn transaction, DocumentImpl document) {\n    \t\n\t\t//TODO : think\n    \tif (document == null) return;\n    \tif (document instanceof BinaryDocument) return;\n    \t\n    \tLOG.debug(\"Finishing \" + eventToString(event) + \"XQuery trigger for document : '\" + document.getName() + \"'\");\n\n\t\tif (query == null)\n\t\t\treturn;\n\t\t\n        XQueryContext context = service.newContext();\n        CompiledXQuery compiledQuery = null;\n        try {\n        \t\n        \tcompiledQuery = service.compile(context, new StringSource(query));\n        \t\n        \t/*\n        \tVariable globalVar;\n\n        \tglobalVar = new Variable(new QName(\"collectionName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(collection.getName()));\t    \n\t        context.declareGlobalVariable(globalVar);\n\t        \n\t        globalVar = new Variable(new QName(\"documentName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(documentName));\n\t        context.declareGlobalVariable(globalVar);\n\n\t        globalVar = new Variable(new QName(\"triggerEvent\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(eventToString(event)));\n\t        context.declareGlobalVariable(globalVar);\t  \n\n\t        globalVar = new Variable(new QName(\"document\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new NodeProxy((DocumentImpl)document));\n\t        context.declareGlobalVariable(globalVar);\n\t        */\n        \t      \t\n        \tcontext.declareVariable(bindingPrefix + \"collectionName\", new StringValue(collection.getName()));\n        \tcontext.declareVariable(bindingPrefix + \"documentName\", new StringValue(document.getName()));\n        \tcontext.declareVariable(bindingPrefix + \"triggerEvent\", new StringValue(eventToString(event)));\n        \tcontext.declareVariable(bindingPrefix + \"document\", (DocumentImpl)document);\n\t        \t        \n        } catch (XPathException e) {\n        \t//Should never be reached\n\t    } catch (IOException e) {\n\t    \t//Should never be reached\n\t    }\n\n        try {\n        \t//TODO : should we provide another contextSet ?\n\t        NodeSet contextSet = NodeSet.EMPTY_SET;\t        \n\t\t\tservice.execute(compiledQuery, contextSet);\n\t\t\t//TODO : should we have a special processing ?\n\t\t\tLOG.debug(\"done.\");\n\t\t\t\n        } catch (XPathException e) {\n        \t//Should never be reached\n\t\t}\t   \n    }","id":101877,"modified_method":"public void finish(int event, DBBroker broker, Txn transaction, DocumentImpl document) {\t\t\n    \t\n    \tLOG.debug(\"Finishing \" + eventToString(event) + \"XQuery trigger for document : '\" + document.getName() + \"'\");\n\n\t\tif (query == null)\n\t\t\treturn;\n\t\t\n        XQueryContext context = service.newContext();\n        CompiledXQuery compiledQuery = null;\n        try {\n        \t\n        \tcompiledQuery = service.compile(context, new StringSource(query));\n        \t\n        \t/*\n        \tVariable globalVar;\n\n        \tglobalVar = new Variable(new QName(\"collectionName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(collection.getName()));\t    \n\t        context.declareGlobalVariable(globalVar);\n\t        \n\t        globalVar = new Variable(new QName(\"documentName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(documentName));\n\t        context.declareGlobalVariable(globalVar);\n\n\t        globalVar = new Variable(new QName(\"triggerEvent\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(eventToString(event)));\n\t        context.declareGlobalVariable(globalVar);\t  \n\n\t        globalVar = new Variable(new QName(\"document\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new NodeProxy((DocumentImpl)document));\n\t        context.declareGlobalVariable(globalVar);\n\t        */\n        \t      \t\n        \tcontext.declareVariable(bindingPrefix + \"collectionName\", new StringValue(collection.getName()));\n        \tcontext.declareVariable(bindingPrefix + \"documentName\", new StringValue(document.getName()));\n        \tcontext.declareVariable(bindingPrefix + \"triggerEvent\", new StringValue(eventToString(event)));\n        \tif (event == REMOVE_DOCUMENT_EVENT)\n//        \t\tDocument does not exist any more -> Sequence.EMPTY_SEQUENCE\n        \t\tcontext.declareVariable(bindingPrefix + \"document\", Sequence.EMPTY_SEQUENCE);\n        \telse if (document instanceof BinaryDocument)\n//        \t\tTODO : encode in Base64 ?\n        \t\tcontext.declareVariable(bindingPrefix + \"document\", Sequence.EMPTY_SEQUENCE);\n        \telse         \t\n        \t\tcontext.declareVariable(bindingPrefix + \"document\", (DocumentImpl)document);     \n\t        \t        \n        } catch (XPathException e) {\n        \t//Should never be reached\n\t    } catch (IOException e) {\n\t    \t//Should never be reached\n\t    }\n\n        try {\n        \t//TODO : should we provide another contextSet ?\n\t        NodeSet contextSet = NodeSet.EMPTY_SET;\t        \n\t\t\tservice.execute(compiledQuery, contextSet);\n\t\t\t//TODO : should we have a special processing ?\n\t\t\tLOG.debug(\"done.\");\n\t\t\t\n        } catch (XPathException e) {\n        \t//Should never be reached\n\t\t}\t   \n    }","commit_id":"bbdd0bb497041f884bc3e183f4c8bd8a1291cf9d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void prepare(int event, DBBroker broker, Txn transaction, String documentName, DocumentImpl existingDocument)\n\t\tthrows TriggerException {\n\t\t\n\t\t//TODO : think\n\t\tif (existingDocument == null) return;\n\t\tif (existingDocument instanceof BinaryDocument) return;\n\t\t\n\t\tLOG.debug(\"Preparing \" + eventToString(event) + \"XQuery trigger for document : '\" + documentName + \"'\");\n\t\t\n\t\tif (query == null)\n\t\t\treturn;        \n                        \n        XQueryContext context = service.newContext();\n        //TODO : futher initializations ?\n        CompiledXQuery compiledQuery;\n        try {       \t\n        \t\n        \tcompiledQuery = service.compile(context, new StringSource(query));\n\n        \t/*\n        \tVariable globalVar;\n        \t\n        \tglobalVar = new Variable(new QName(\"collectionName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(collection.getName()));\t        \n\t        context.declareGlobalVariable(globalVar);\t        \n\n\t        globalVar = new Variable(new QName(\"documentName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(documentName));\n\t        context.declareGlobalVariable(globalVar);\t        \n        \n\t        globalVar = new Variable(new QName(\"triggerEvent\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(eventToString(event)));\n\t        context.declareGlobalVariable(globalVar);\n\n\t        globalVar = new Variable(new QName(\"document\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new NodeProxy((DocumentImpl)existingDocument));\n\t        context.declareGlobalVariable(globalVar);\n\t        */\n        \t\n        \tcontext.declareVariable(bindingPrefix + \"collectionName\", new StringValue(collection.getName()));\n        \tcontext.declareVariable(bindingPrefix + \"documentName\", new StringValue(documentName));\n        \tcontext.declareVariable(bindingPrefix + \"triggerEvent\", new StringValue(eventToString(event))); \n        \tif (existingDocument == null)\n        \t\tcontext.declareVariable(bindingPrefix + \"document\", Sequence.EMPTY_SEQUENCE);\n        \telse\n        \t\tcontext.declareVariable(bindingPrefix + \"document\", (DocumentImpl)existingDocument);\n\t        \t        \n        } catch (XPathException e) {\n        \tquery = null; //prevents future use\n        \tthrow new TriggerException(\"Error during trigger prepare\", e);\n\t    } catch (IOException e) {\n        \tquery = null; //prevents future use\n        \tthrow new TriggerException(\"Error during trigger prepare\", e);\n\t    }\n\n        try {\n        \t//TODO : should we provide another contextSet ?\n\t        NodeSet contextSet = NodeSet.EMPTY_SET;\n\t\t\tservice.execute(compiledQuery, contextSet);\n\t\t\t//TODO : should we have a special processing ?\n\t\t\tLOG.debug(\"done.\");\n\t\t\t\n        } catch (XPathException e) {\n        \tquery = null; //prevents future use\n        \tthrow new TriggerException(\"Error during trigger prepare\", e);\n\t\t}\t   \n\t\t\n\t}","id":101878,"modified_method":"public void prepare(int event, DBBroker broker, Txn transaction, String documentName, DocumentImpl existingDocument)\n\t\tthrows TriggerException {\t\t\t\t\n\t\t\n\t\tLOG.debug(\"Preparing \" + eventToString(event) + \"XQuery trigger for document : '\" + documentName + \"'\");\n\t\t\n\t\tif (query == null)\n\t\t\treturn;        \n                        \n        XQueryContext context = service.newContext();\n        //TODO : futher initializations ?\n        CompiledXQuery compiledQuery;\n        try {       \t\n        \t\n        \tcompiledQuery = service.compile(context, new StringSource(query));\n\n        \t/*\n        \tVariable globalVar;\n        \t\n        \tglobalVar = new Variable(new QName(\"collectionName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(collection.getName()));\t        \n\t        context.declareGlobalVariable(globalVar);\t        \n\n\t        globalVar = new Variable(new QName(\"documentName\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(documentName));\n\t        context.declareGlobalVariable(globalVar);\t        \n        \n\t        globalVar = new Variable(new QName(\"triggerEvent\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new StringValue(eventToString(event)));\n\t        context.declareGlobalVariable(globalVar);\n\n\t        globalVar = new Variable(new QName(\"document\", XQueryContext.EXIST_NS, \"exist\"));\n\t        globalVar.setValue(new NodeProxy((DocumentImpl)existingDocument));\n\t        context.declareGlobalVariable(globalVar);\n\t        */\n        \t\n        \tcontext.declareVariable(bindingPrefix + \"collectionName\", new StringValue(collection.getName()));\n        \tcontext.declareVariable(bindingPrefix + \"documentName\", new StringValue(documentName));\n        \tcontext.declareVariable(bindingPrefix + \"triggerEvent\", new StringValue(eventToString(event))); \n        \t//if (existingDocument == null)\n        \tif (existingDocument instanceof BinaryDocument)\n//        \t\tTODO : encode in Base64 ?        \t\t\n        \t\tcontext.declareVariable(bindingPrefix + \"document\", Sequence.EMPTY_SEQUENCE);\n        \telse\n        \t\tcontext.declareVariable(bindingPrefix + \"document\", (DocumentImpl)existingDocument);\n\t        \t        \n        } catch (XPathException e) {\n        \tquery = null; //prevents future use\n        \tthrow new TriggerException(\"Error during trigger prepare\", e);\n\t    } catch (IOException e) {\n        \tquery = null; //prevents future use\n        \tthrow new TriggerException(\"Error during trigger prepare\", e);\n\t    }\n\n        try {\n        \t//TODO : should we provide another contextSet ?\n\t        NodeSet contextSet = NodeSet.EMPTY_SET;\n\t\t\tservice.execute(compiledQuery, contextSet);\n\t\t\t//TODO : should we have a special processing ?\n\t\t\tLOG.debug(\"done.\");\n\t\t\t\n        } catch (XPathException e) {\n        \tquery = null; //prevents future use\n        \tthrow new TriggerException(\"Error during trigger prepare\", e);\n\t\t}\t   \n\t\t\n\t}","commit_id":"bbdd0bb497041f884bc3e183f4c8bd8a1291cf9d","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean shouldChangeModificationCount(PsiElement place) {\n    PsiElement pparent = getParent();\n    return !(pparent instanceof PsiMethod || pparent instanceof PsiClassInitializer);\n  }","id":101879,"modified_method":"public boolean shouldChangeModificationCount(PsiElement place) {\n    PsiElement parent = getParent();\n    return !(parent instanceof PsiMethod || parent instanceof PsiClassInitializer);\n  }","commit_id":"905542379b299a72eaad8327bacc289fee339e37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getFirstBodyElement() {\n    final PsiElement nextSibling = getLBrace().getNextSibling();\n    return nextSibling == getRBrace() ? null : nextSibling;\n  }","id":101880,"modified_method":"public PsiElement getFirstBodyElement() {\n    final PsiJavaToken lBrace = getLBrace();\n    if (lBrace == null) return null;\n    final PsiElement nextSibling = lBrace.getNextSibling();\n    return nextSibling == getRBrace() ? null : nextSibling;\n  }","commit_id":"905542379b299a72eaad8327bacc289fee339e37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void positionCaret(Editor editor, GrMethod result) {\n    final GrOpenBlock body = result.getBlock();\n    if (body == null) return;\n\n    PsiElement l = body.getLBrace().getNextSibling();\n    while (l instanceof PsiWhiteSpace) l = l.getNextSibling();\n    if (l == null) l = body;\n    PsiElement r = body.getRBrace().getPrevSibling();\n    while (r instanceof PsiWhiteSpace) r = r.getPrevSibling();\n    if (r == null) r = body;\n\n    int start = l.getTextRange().getStartOffset();\n    int end = r.getTextRange().getEndOffset();\n\n    editor.getCaretModel().moveToOffset(Math.min(start, end));\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    if (start < end) {\n      //Not an empty body\n      editor.getSelectionModel().setSelection(start, end);\n    }\n  }","id":101881,"modified_method":"private static void positionCaret(Editor editor, GrMethod result) {\n    final GrOpenBlock body = result.getBlock();\n    if (body == null) return;\n\n    final PsiElement lBrace = body.getLBrace();\n    if (lBrace == null) return;\n\n    PsiElement l = lBrace.getNextSibling();\n    while (l instanceof PsiWhiteSpace) l = l.getNextSibling();\n    if (l == null) l = body;\n    final PsiElement rBrace = body.getRBrace();\n    if (rBrace == null) return;\n\n    PsiElement r = rBrace.getPrevSibling();\n    while (r instanceof PsiWhiteSpace) r = r.getPrevSibling();\n    if (r == null) r = body;\n\n    int start = l.getTextRange().getStartOffset();\n    int end = r.getTextRange().getEndOffset();\n\n    editor.getCaretModel().moveToOffset(Math.min(start, end));\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    if (start < end) {\n      //Not an empty body\n      editor.getSelectionModel().setSelection(start, end);\n    }\n  }","commit_id":"4d3c506188cb42b801593a322b06ee7f609fa59f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement getDefaultAnchor(PsiClass aClass, PsiMember member) {\n    CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(aClass.getProject());\n\n    int order = getMemberOrderWeight(member, settings);\n    if (order < 0) return null;\n\n    PsiElement lastMember = null;\n    for (PsiElement child = aClass.getFirstChild(); child != null; child = child.getNextSibling()) {\n      int order1 = getMemberOrderWeight(child, settings);\n      if (order1 < 0) continue;\n      if (order1 > order) {\n        if (lastMember != null) {\n          PsiElement nextSibling = lastMember.getNextSibling();\n          while (nextSibling instanceof PsiJavaToken && (nextSibling.getText().equals(\",\") || nextSibling.getText().equals(\";\"))) {\n            nextSibling = nextSibling.getNextSibling();\n          }\n          return nextSibling == null ? aClass.getLBrace().getNextSibling() : nextSibling;\n        }\n        else {\n          // The main idea is to avoid to anchor to 'white space' element because that causes reformatting algorithm\n          // to perform incorrectly. The algorithm is encapsulated at PostprocessReformattingAspect.doPostponedFormattingInner().\n          PsiElement result = aClass.getLBrace().getNextSibling();\n          while (result instanceof PsiWhiteSpace) {\n            result = result.getNextSibling();\n          }\n          return result;\n        }\n      }\n      lastMember = child;\n    }\n    return aClass.getRBrace();\n  }","id":101882,"modified_method":"public static PsiElement getDefaultAnchor(PsiClass aClass, PsiMember member) {\n    CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(aClass.getProject());\n\n    int order = getMemberOrderWeight(member, settings);\n    if (order < 0) return null;\n\n    PsiElement lastMember = null;\n    for (PsiElement child = aClass.getFirstChild(); child != null; child = child.getNextSibling()) {\n      int order1 = getMemberOrderWeight(child, settings);\n      if (order1 < 0) continue;\n      if (order1 > order) {\n        if (lastMember != null) {\n          PsiElement nextSibling = lastMember.getNextSibling();\n          while (nextSibling instanceof PsiJavaToken && (nextSibling.getText().equals(\",\") || nextSibling.getText().equals(\";\"))) {\n            nextSibling = nextSibling.getNextSibling();\n          }\n          return nextSibling == null ? aClass.getLBrace().getNextSibling() : nextSibling;\n        }\n        else {\n          // The main idea is to avoid to anchor to 'white space' element because that causes reformatting algorithm\n          // to perform incorrectly. The algorithm is encapsulated at PostprocessReformattingAspect.doPostponedFormattingInner().\n          final PsiElement lBrace = aClass.getLBrace();\n          if (lBrace != null) {\n            PsiElement result = lBrace.getNextSibling();\n            while (result instanceof PsiWhiteSpace) {\n              result = result.getNextSibling();\n            }\n            return result;\n          }\n        }\n      }\n      lastMember = child;\n    }\n    return aClass.getRBrace();\n  }","commit_id":"241fc2c3d77d9b27f6884c82b91fe5a1377bb465","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Set<Class<?>> getClassesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jarToScan == null) {\n            throw MESSAGES.nullVar(\"jarToScan\");\n        }\n        JPA_LOGGER.tracef(\"getClassesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n        PersistenceUnitMetadata pu = PERSISTENCE_UNIT_METADATA_TLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n        if (pu.getAnnotationIndex() != null) {\n            Index index = getJarFileIndex(jarToScan, pu);\n            if (index == null) {\n                JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                    jarToScan, pu.getAnnotationIndex().keySet());\n                return new HashSet<Class<?>>();\n            }\n            if (annotationsToLookFor == null) {\n                throw MESSAGES.nullVar(\"annotationsToLookFor\");\n            }\n            if (annotationsToLookFor.size() == 0) {\n                throw MESSAGES.emptyParameter(\"annotationsToLookFor\");\n            }\n\n            Set<Class<?>> result = new HashSet<Class<?>>();\n\n            for (Class<? extends Annotation> annClass : annotationsToLookFor) {\n                DotName annotation = DotName.createSimple(annClass.getName());\n                List<AnnotationInstance> classesWithAnnotation = index.getAnnotations(annotation);\n                Set<Class<?>> classesForAnnotation = new HashSet<Class<?>>();\n                for (AnnotationInstance annotationInstance : classesWithAnnotation) {\n                    // verify that the annotation target is actually a class, since some frameworks\n                    // may generate bytecode with annotations placed on methods (see AS7-2559)\n                    if (annotationInstance.target() instanceof ClassInfo) {\n                        String className = annotationInstance.target().toString();\n                        try {\n                            JPA_LOGGER.tracef(\"getClassesInJar found class %s with annotation %s\", className, annClass.getName());\n                            Class<?> clazz = pu.getNewTempClassLoader().loadClass(className);\n                            result.add(clazz);\n                            classesForAnnotation.add(clazz);\n                        } catch (ClassNotFoundException e) {\n                            throw MESSAGES.cannotLoadEntityClass(e, className);\n                        }\n                    }\n                }\n                cacheClasses(pu, jarToScan, annClass, classesForAnnotation);\n            }\n            return result;\n        } else {\n            return getCachedClasses(pu, jarToScan, annotationsToLookFor);\n        }\n    }","id":101883,"modified_method":"@Override\n    public Set<Class<?>> getClassesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jarToScan == null) {\n            throw MESSAGES.nullVar(\"jarToScan\");\n        }\n        JPA_LOGGER.tracef(\"getClassesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n        PersistenceUnitMetadata pu = PERSISTENCE_UNIT_METADATA_TLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n        if (pu.getAnnotationIndex() != null) {\n            Index index = getJarFileIndex(jarToScan, pu);\n            if (index == null) {\n                JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                    jarToScan, pu.getAnnotationIndex().keySet());\n                return new HashSet<Class<?>>();\n            }\n            if (annotationsToLookFor == null) {\n                throw MESSAGES.nullVar(\"annotationsToLookFor\");\n            }\n            if (annotationsToLookFor.size() == 0) {\n                throw MESSAGES.emptyParameter(\"annotationsToLookFor\");\n            }\n\n            Set<Class<?>> result = new HashSet<Class<?>>();\n\n            for (Class<? extends Annotation> annClass : annotationsToLookFor) {\n                DotName annotation = DotName.createSimple(annClass.getName());\n                List<AnnotationInstance> classesWithAnnotation = index.getAnnotations(annotation);\n                Set<Class<?>> classesForAnnotation = new HashSet<Class<?>>();\n                for (AnnotationInstance annotationInstance : classesWithAnnotation) {\n                    // verify that the annotation target is actually a class, since some frameworks\n                    // may generate bytecode with annotations placed on methods (see AS7-2559)\n                    if (annotationInstance.target() instanceof ClassInfo) {\n                        String className = annotationInstance.target().toString();\n                        try {\n                            JPA_LOGGER.tracef(\"getClassesInJar found class %s with annotation %s\", className, annClass.getName());\n                            Class<?> clazz = pu.getNewTempClassLoader().loadClass(className);\n                            result.add(clazz);\n                            classesForAnnotation.add(clazz);\n                        } catch (ClassNotFoundException e) {\n                            JPA_LOGGER.cannotLoadEntityClass(e, className);\n                        } catch (NoClassDefFoundError e) {\n                            JPA_LOGGER.cannotLoadEntityClass(e, className);\n                        }\n                    }\n                }\n                cacheClasses(pu, jarToScan, annClass, classesForAnnotation);\n            }\n            return result;\n        } else {\n            return getCachedClasses(pu, jarToScan, annotationsToLookFor);\n        }\n    }","commit_id":"632165b015e6a559d9e7ed83eb8fbe891c8e8f88","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Set<Package> getPackagesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jarToScan == null) {\n            throw MESSAGES.nullVar(\"jarToScan\");\n        }\n        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n        Set<Class<?>> resultClasses = new HashSet<Class<?>>();\n\n        PersistenceUnitMetadata pu = PERSISTENCE_UNIT_METADATA_TLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n\n        if (annotationsToLookFor.size() > 0) {  // Hibernate doesn't pass any annotations currently\n            resultClasses = getClassesInJar(jarToScan, annotationsToLookFor);\n        } else {\n            if (pu.getAnnotationIndex() != null) {\n                Index index = getJarFileIndex(jarToScan, pu);\n                if (index == null) {\n                    JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                        jarToScan, pu.getAnnotationIndex().keySet());\n                    return new HashSet<Package>();\n                }\n                Collection<ClassInfo> allClasses = index.getKnownClasses();\n                for (ClassInfo classInfo : allClasses) {\n                    String className = classInfo.name().toString();\n                    try {\n                        resultClasses.add(pu.getNewTempClassLoader().loadClass(className));\n                    } catch (ClassNotFoundException e) {\n                        throw MESSAGES.cannotLoadEntityClass(e, className);\n                    }\n                }\n            }\n        }\n\n        if (pu.getAnnotationIndex() != null || annotationsToLookFor.size() > 0) {\n            Map<String, Package> uniquePackages = new HashMap<String, Package>();\n            for (Class<?> classWithAnnotation : resultClasses) {\n                Package classPackage = classWithAnnotation.getPackage();\n                if (classPackage != null) {\n                    JPA_LOGGER.tracef(\"getPackagesInJar found package %s\", classPackage);\n                    uniquePackages.put(classPackage.getName(), classPackage);\n                }\n            }\n            Set<Package> packages = new HashSet<Package>(uniquePackages.values());\n            cachePackages(pu, jarToScan, packages);\n            return new HashSet<Package>(packages);\n        } else {\n            return getCachedPackages(pu, jarToScan);\n        }\n    }","id":101884,"modified_method":"@Override\n    public Set<Package> getPackagesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jarToScan == null) {\n            throw MESSAGES.nullVar(\"jarToScan\");\n        }\n        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n        Set<Class<?>> resultClasses = new HashSet<Class<?>>();\n\n        PersistenceUnitMetadata pu = PERSISTENCE_UNIT_METADATA_TLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n\n        if (annotationsToLookFor.size() > 0) {  // Hibernate doesn't pass any annotations currently\n            resultClasses = getClassesInJar(jarToScan, annotationsToLookFor);\n        } else {\n            if (pu.getAnnotationIndex() != null) {\n                Index index = getJarFileIndex(jarToScan, pu);\n                if (index == null) {\n                    JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                        jarToScan, pu.getAnnotationIndex().keySet());\n                    return new HashSet<Package>();\n                }\n                Collection<ClassInfo> allClasses = index.getKnownClasses();\n                for (ClassInfo classInfo : allClasses) {\n                    String className = classInfo.name().toString();\n                    try {\n                        resultClasses.add(pu.getNewTempClassLoader().loadClass(className));\n                    } catch (ClassNotFoundException e) {\n                        JPA_LOGGER.cannotLoadEntityClass(e, className);\n                    } catch (NoClassDefFoundError e) {\n                        JPA_LOGGER.cannotLoadEntityClass(e, className);\n                    }\n\n                }\n            }\n        }\n\n        if (pu.getAnnotationIndex() != null || annotationsToLookFor.size() > 0) {\n            Map<String, Package> uniquePackages = new HashMap<String, Package>();\n            for (Class<?> classWithAnnotation : resultClasses) {\n                Package classPackage = classWithAnnotation.getPackage();\n                if (classPackage != null) {\n                    JPA_LOGGER.tracef(\"getPackagesInJar found package %s\", classPackage);\n                    uniquePackages.put(classPackage.getName(), classPackage);\n                }\n            }\n            Set<Package> packages = new HashSet<Package>(uniquePackages.values());\n            cachePackages(pu, jarToScan, packages);\n            return new HashSet<Package>(packages);\n        } else {\n            return getCachedPackages(pu, jarToScan);\n        }\n    }","commit_id":"632165b015e6a559d9e7ed83eb8fbe891c8e8f88","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Set<Class<?>> getClassesInJar(URL jartoScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jartoScan == null) {\n            throw MESSAGES.nullVar(\"jartoScan\");\n        }\n        JPA_LOGGER.tracef(\"getClassesInJar url=%s annotations=%s\", jartoScan.getPath(), annotationsToLookFor);\n        PersistenceUnitMetadata pu = persistenceUnitMetadataTLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n        if (pu.getAnnotationIndex() != null) {\n            Index index = getJarFileIndex(jartoScan, pu);\n            if (index == null) {\n                JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                    jartoScan, pu.getAnnotationIndex().keySet());\n                return new HashSet<Class<?>>();\n            }\n            if (annotationsToLookFor == null) {\n                throw MESSAGES.nullVar(\"annotationsToLookFor\");\n            }\n            if (annotationsToLookFor.size() == 0) {\n                throw MESSAGES.emptyParameter(\"annotationsToLookFor\");\n            }\n\n            Set<Class<?>> result = new HashSet<Class<?>>();\n\n            for (Class<? extends Annotation> annClass : annotationsToLookFor) {\n                DotName annotation = DotName.createSimple(annClass.getName());\n                List<AnnotationInstance> classesWithAnnotation = index.getAnnotations(annotation);\n                Set<Class<?>> classesForAnnotation = new HashSet<Class<?>>();\n                for (AnnotationInstance annotationInstance : classesWithAnnotation) {\n                    // verify that the annotation target is actually a class, since some frameworks\n                    // may generate bytecode with annotations placed on methods (see AS7-2559)\n                    if (annotationInstance.target() instanceof ClassInfo) {\n                        String className = annotationInstance.target().toString();\n                        try {\n                            JPA_LOGGER.tracef(\"getClassesInJar found class %s with annotation %s\", className, annClass.getName());\n                            Class<?> clazz = pu.getClassLoader().loadClass(className);\n                            result.add(clazz);\n                            classesForAnnotation.add(clazz);\n                            // TODO:  fix temp classloader (get CFNE on entity class)\n                            //result.add(pu.getNewTempClassLoader().loadClass(className));\n                        } catch (ClassNotFoundException e) {\n                            throw MESSAGES.cannotLoadEntityClass(e, className);\n                        }\n                    }\n                }\n                cacheClasses(pu, jartoScan, annClass, classesForAnnotation);\n            }\n            return result;\n        } else {\n            return getCachedClasses(pu, jartoScan, annotationsToLookFor);\n        }\n    }","id":101885,"modified_method":"@Override\n    public Set<Class<?>> getClassesInJar(URL jartoScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jartoScan == null) {\n            throw MESSAGES.nullVar(\"jartoScan\");\n        }\n        JPA_LOGGER.tracef(\"getClassesInJar url=%s annotations=%s\", jartoScan.getPath(), annotationsToLookFor);\n        PersistenceUnitMetadata pu = persistenceUnitMetadataTLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n        if (pu.getAnnotationIndex() != null) {\n            Index index = getJarFileIndex(jartoScan, pu);\n            if (index == null) {\n                JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                    jartoScan, pu.getAnnotationIndex().keySet());\n                return new HashSet<Class<?>>();\n            }\n            if (annotationsToLookFor == null) {\n                throw MESSAGES.nullVar(\"annotationsToLookFor\");\n            }\n            if (annotationsToLookFor.size() == 0) {\n                throw MESSAGES.emptyParameter(\"annotationsToLookFor\");\n            }\n\n            Set<Class<?>> result = new HashSet<Class<?>>();\n\n            for (Class<? extends Annotation> annClass : annotationsToLookFor) {\n                DotName annotation = DotName.createSimple(annClass.getName());\n                List<AnnotationInstance> classesWithAnnotation = index.getAnnotations(annotation);\n                Set<Class<?>> classesForAnnotation = new HashSet<Class<?>>();\n                for (AnnotationInstance annotationInstance : classesWithAnnotation) {\n                    // verify that the annotation target is actually a class, since some frameworks\n                    // may generate bytecode with annotations placed on methods (see AS7-2559)\n                    if (annotationInstance.target() instanceof ClassInfo) {\n                        String className = annotationInstance.target().toString();\n                        try {\n                            JPA_LOGGER.tracef(\"getClassesInJar found class %s with annotation %s\", className, annClass.getName());\n                            Class<?> clazz = pu.getClassLoader().loadClass(className);\n                            result.add(clazz);\n                            classesForAnnotation.add(clazz);\n                            // TODO:  fix temp classloader (get CFNE on entity class)\n                            //result.add(pu.getNewTempClassLoader().loadClass(className));\n                        } catch (ClassNotFoundException e) {\n                            JPA_LOGGER.tracef(\"Could not load entity class '%s' with PersistenceUnitInfo.getClassLoader()\", className);\n                        } catch (NoClassDefFoundError e) {\n                            JPA_LOGGER.tracef(\"Could not load entity class '%s' with PersistenceUnitInfo.getClassLoader()\", className);\n                        }\n                    }\n                }\n                cacheClasses(pu, jartoScan, annClass, classesForAnnotation);\n            }\n            return result;\n        } else {\n            return getCachedClasses(pu, jartoScan, annotationsToLookFor);\n        }\n    }","commit_id":"632165b015e6a559d9e7ed83eb8fbe891c8e8f88","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Set<Package> getPackagesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jarToScan == null) {\n            throw MESSAGES.nullVar(\"jarToScan\");\n        }\n        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n        Set<Class<?>> resultClasses = new HashSet<Class<?>>();\n\n        PersistenceUnitMetadata pu = persistenceUnitMetadataTLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n\n        if (annotationsToLookFor.size() > 0) {  // Hibernate doesn't pass any annotations currently\n            resultClasses = getClassesInJar(jarToScan, annotationsToLookFor);\n        } else {\n            if (pu.getAnnotationIndex() != null) {\n                Index index = getJarFileIndex(jarToScan, pu);\n                if (index == null) {\n                    JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                        jarToScan, pu.getAnnotationIndex().keySet());\n                    return new HashSet<Package>();\n                }\n                Collection<ClassInfo> allClasses = index.getKnownClasses();\n                for (ClassInfo classInfo : allClasses) {\n                    String className = classInfo.name().toString();\n                    try {\n                        resultClasses.add(pu.getClassLoader().loadClass(className));\n                        // TODO:  fix temp classloader (get CFNE on entity class)\n                        //result.add(pu.getNewTempClassLoader().loadClass(className));\n                    } catch (ClassNotFoundException e) {\n                        throw MESSAGES.cannotLoadEntityClass(e, className);\n                    }\n                }\n            }\n        }\n\n        if (pu.getAnnotationIndex() != null || annotationsToLookFor.size() > 0) {\n            Map<String, Package> uniquePackages = new HashMap<String, Package>();\n            for (Class<?> classWithAnnotation : resultClasses) {\n                Package classPackage = classWithAnnotation.getPackage();\n                if (classPackage != null) {\n                    JPA_LOGGER.tracef(\"getPackagesInJar found package %s\", classPackage);\n                    uniquePackages.put(classPackage.getName(), classPackage);\n                }\n            }\n            Set<Package> packages = new HashSet<Package>(uniquePackages.values());\n            cachePackages(pu, jarToScan, packages);\n            return new HashSet<Package>(packages);\n        } else {\n            return getCachedPackages(pu, jarToScan);\n        }\n    }","id":101886,"modified_method":"@Override\n    public Set<Package> getPackagesInJar(URL jarToScan, Set<Class<? extends Annotation>> annotationsToLookFor) {\n        if (jarToScan == null) {\n            throw MESSAGES.nullVar(\"jarToScan\");\n        }\n        JPA_LOGGER.tracef(\"getPackagesInJar url=%s annotations=%s\", jarToScan.getPath(), annotationsToLookFor);\n        Set<Class<?>> resultClasses = new HashSet<Class<?>>();\n\n        PersistenceUnitMetadata pu = persistenceUnitMetadataTLS.get();\n        if (pu == null) {\n            throw MESSAGES.missingPersistenceUnitMetadata();\n        }\n\n        if (annotationsToLookFor.size() > 0) {  // Hibernate doesn't pass any annotations currently\n            resultClasses = getClassesInJar(jarToScan, annotationsToLookFor);\n        } else {\n            if (pu.getAnnotationIndex() != null) {\n                Index index = getJarFileIndex(jarToScan, pu);\n                if (index == null) {\n                    JPA_LOGGER.tracef(\"No classes to scan for annotations in jar '%s' (jars with classes '%s')\",\n                        jarToScan, pu.getAnnotationIndex().keySet());\n                    return new HashSet<Package>();\n                }\n                Collection<ClassInfo> allClasses = index.getKnownClasses();\n                for (ClassInfo classInfo : allClasses) {\n                    String className = classInfo.name().toString();\n                    try {\n                        resultClasses.add(pu.getClassLoader().loadClass(className));\n                        // TODO:  fix temp classloader (get CFNE on entity class)\n                        //result.add(pu.getNewTempClassLoader().loadClass(className));\n                    } catch (ClassNotFoundException e) {\n                        JPA_LOGGER.cannotLoadEntityClass(e, className);\n                    } catch (NoClassDefFoundError e) {\n                        JPA_LOGGER.cannotLoadEntityClass(e, className);\n                    }\n                }\n            }\n        }\n\n        if (pu.getAnnotationIndex() != null || annotationsToLookFor.size() > 0) {\n            Map<String, Package> uniquePackages = new HashMap<String, Package>();\n            for (Class<?> classWithAnnotation : resultClasses) {\n                Package classPackage = classWithAnnotation.getPackage();\n                if (classPackage != null) {\n                    JPA_LOGGER.tracef(\"getPackagesInJar found package %s\", classPackage);\n                    uniquePackages.put(classPackage.getName(), classPackage);\n                }\n            }\n            Set<Package> packages = new HashSet<Package>(uniquePackages.values());\n            cachePackages(pu, jarToScan, packages);\n            return new HashSet<Package>(packages);\n        } else {\n            return getCachedPackages(pu, jarToScan);\n        }\n    }","commit_id":"632165b015e6a559d9e7ed83eb8fbe891c8e8f88","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerResources(String alias, String name, HttpContext context) throws NamespaceException\n    {\n        if (!isNameValid(name))\n        {\n            throw new IllegalArgumentException(\"Malformed resource name [\" + name + \"]\");\n        }\n\n        try\n        {\n            Servlet servlet = new ResourceServlet(name);\n            registerServlet(alias, servlet, null, context);\n        }\n        catch (ServletException e)\n        {\n            SystemLogger.error(\"Failed to register resources\", e);\n        }\n    }","id":101887,"modified_method":"/**\n     * No need to sync this method, syncing is done via {@link #registerServlet(String, Servlet, Dictionary, HttpContext)}\n     * @see org.osgi.service.http.HttpService#registerResources(java.lang.String, java.lang.String, org.osgi.service.http.HttpContext)\n     */\n    @Override\n    public void registerResources(final String alias, final String name, final HttpContext context) throws NamespaceException\n    {\n        if (!isNameValid(name))\n        {\n            throw new IllegalArgumentException(\"Malformed resource name [\" + name + \"]\");\n        }\n\n        // TODO - check validity of alias\n        try\n        {\n            Servlet servlet = new ResourceServlet(name);\n            registerServlet(alias, servlet, null, context);\n        }\n        catch (ServletException e)\n        {\n            SystemLogger.error(\"Failed to register resources\", e);\n        }\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"private void unregisterServlet(final Servlet servlet, final boolean destroy)\n    {\n        if ( servlet != null )\n        {\n            this.handlerRegistry.removeServlet(servlet, destroy);\n            this.localServlets.remove(servlet);\n        }\n    }","id":101888,"modified_method":"private void unregisterServlet(final Servlet servlet, final boolean destroy)\n    {\n        if ( servlet != null )\n        {\n            this.handlerRegistry.removeServlet(servlet, destroy);\n            synchronized ( this.aliasMap )\n            {\n            \tfinal Iterator<Map.Entry<String, ServletHandler>> i = this.aliasMap.entrySet().iterator();\n            \twhile ( i.hasNext() )\n            \t{\n            \t\tfinal Map.Entry<String, ServletHandler> entry = i.next();\n            \t\tif ( entry.getValue().getServlet() == servlet )\n            \t\t{\n            \t\t\ti.remove();\n            \t\t\tbreak;\n            \t\t}\n            \t\t\n            \t}\n            \tthis.localServlets.remove(servlet);\n            }\n        }\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"public HttpServiceImpl(Bundle bundle, ServletContext context, PerContextHandlerRegistry handlerRegistry, ServletContextAttributeListener servletAttributeListener, boolean sharedContextAttributes)\n    {\n        this.bundle = bundle;\n        this.handlerRegistry = handlerRegistry;\n        this.localServlets = new HashSet<Servlet>();\n        this.localFilters = new HashSet<Filter>();\n        this.contextManager = new ServletContextManager(this.bundle, context, servletAttributeListener, sharedContextAttributes);\n    }","id":101889,"modified_method":"public HttpServiceImpl(Bundle bundle, ServletContext context, PerContextHandlerRegistry handlerRegistry, ServletContextAttributeListener servletAttributeListener, boolean sharedContextAttributes)\n    {\n        this.bundle = bundle;\n        this.handlerRegistry = handlerRegistry;\n        this.contextManager = new ServletContextManager(this.bundle, context, servletAttributeListener, sharedContextAttributes);\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"public void unregisterAll()\n    {\n        HashSet<Servlet> servlets = new HashSet<Servlet>(this.localServlets);\n        for (Servlet servlet : servlets)\n        {\n            unregisterServlet(servlet, false);\n        }\n\n        HashSet<Filter> filters = new HashSet<Filter>(this.localFilters);\n        for (Filter fiter : filters)\n        {\n            unregisterFilter(fiter, false);\n        }\n    }","id":101890,"modified_method":"public void unregisterAll()\n    {\n        final Set<Servlet> servlets = new HashSet<Servlet>(this.localServlets);\n        for (final Servlet servlet : servlets)\n        {\n            unregisterServlet(servlet, false);\n        }\n\n        final Set<Filter> filters = new HashSet<Filter>(this.localFilters);\n        for (final Filter fiter : filters)\n        {\n            unregisterFilter(fiter, false);\n        }\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.osgi.service.http.HttpService#registerServlet(java.lang.String, javax.servlet.Servlet, java.util.Dictionary, org.osgi.service.http.HttpContext)\n     */\n    @Override\n    public void registerServlet(String alias, Servlet servlet, Dictionary initParams, HttpContext context)\n    throws ServletException, NamespaceException\n    {\n        if (servlet == null)\n        {\n            throw new IllegalArgumentException(\"Servlet must not be null\");\n        }\n        if (!isAliasValid(alias))\n        {\n            throw new IllegalArgumentException(\"Malformed servlet alias [\" + alias + \"]\");\n        }\n\n        final Map<String, String> paramMap = new HashMap<String, String>();\n        if ( initParams != null && initParams.size() > 0 )\n        {\n            Enumeration e = initParams.keys();\n            while (e.hasMoreElements())\n            {\n                Object key = e.nextElement();\n                Object value = initParams.get(key);\n\n                if ((key instanceof String) && (value instanceof String))\n                {\n                    paramMap.put((String) key, (String) value);\n                }\n            }\n        }\n\n        final ServletInfo servletInfo = new ServletInfo(null, alias, 0, paramMap);\n\n        final ExtServletContext httpContext = getServletContext(context);\n\n        final ServletHandler handler = new ServletHandler(null,\n                httpContext,\n                servletInfo,\n                servlet);\n        try {\n            this.handlerRegistry.addServlet(null, handler);\n        } catch (ServletException e) {\n            // TODO create failure DTO\n        } catch (NamespaceException e) {\n            // TODO create failure DTO\n        }\n\n        this.localServlets.add(servlet);\n    }","id":101891,"modified_method":"/**\n     * @see org.osgi.service.http.HttpService#registerServlet(java.lang.String, javax.servlet.Servlet, java.util.Dictionary, org.osgi.service.http.HttpContext)\n     */\n    @Override\n    public void registerServlet(String alias, Servlet servlet, Dictionary initParams, HttpContext context)\n    throws ServletException, NamespaceException\n    {\n        if (servlet == null)\n        {\n            throw new IllegalArgumentException(\"Servlet must not be null\");\n        }\n        if (!isAliasValid(alias))\n        {\n            throw new IllegalArgumentException(\"Malformed servlet alias [\" + alias + \"]\");\n        }\n\n        final Map<String, String> paramMap = new HashMap<String, String>();\n        if ( initParams != null && initParams.size() > 0 )\n        {\n            Enumeration e = initParams.keys();\n            while (e.hasMoreElements())\n            {\n                Object key = e.nextElement();\n                Object value = initParams.get(key);\n\n                if ((key instanceof String) && (value instanceof String))\n                {\n                    paramMap.put((String) key, (String) value);\n                }\n            }\n        }\n\n        final ServletInfo servletInfo = new ServletInfo(null, alias, 0, paramMap);\n        final ExtServletContext httpContext = getServletContext(context);\n\n        final ServletHandler handler = new ServletHandler(null,\n                httpContext,\n                servletInfo,\n                servlet);\n\n        synchronized ( this.aliasMap ) \n        {\n        \tif ( this.aliasMap.containsKey(alias) ) \n        \t{\n        \t    throw new NamespaceException(\"Alias \" + alias + \" is already in use.\");\t\n        \t}\n        \tif ( this.localServlets.contains(servlet) )\n        \t{\n                throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");        \t\t\n        \t}\n            \n            this.handlerRegistry.addServlet(handler);\n\n            this.aliasMap.put(alias, handler);\n            this.localServlets.add(servlet);\n        }\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.osgi.service.http.HttpService#unregister(java.lang.String)\n     */\n    @Override\n    public void unregister(String alias)\n    {\n        final Servlet servlet = this.handlerRegistry.getServletByAlias(alias);\n        if (servlet == null)\n        {\n            // FELIX-4561 - don't bother throwing an exception if we're stopping anyway...\n            if ((bundle.getState() & Bundle.STOPPING) != 0)\n            {\n                throw new IllegalArgumentException(\"Nothing registered at \" + alias);\n            }\n            else\n            {\n                SystemLogger.debug(\"Nothing registered at \" + alias + \"; ignoring this because the bundle is stopping!\", null);\n            }\n        }\n        unregisterServlet(servlet);\n    }","id":101892,"modified_method":"/**\n     * @see org.osgi.service.http.HttpService#unregister(java.lang.String)\n     */\n    @Override\n    public void unregister(final String alias)\n    {\n        synchronized ( this.aliasMap ) \n        {\n\t\t    final ServletHandler handler = this.aliasMap.remove(alias);\t\n\t        if ( handler == null )\n\t        {\n\t        \tthrow new IllegalArgumentException(\"Nothing registered at \" + alias);        \t\n\t        }\n\t        final Servlet servlet = this.handlerRegistry.removeServlet(handler.getServletInfo(), true);\n\t        if (servlet != null)\n\t        {\n\t        \tthis.localServlets.remove(servlet);\n\t        }\n\t\t}\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"public synchronized Servlet removeServlet(final ServletContextHelperInfo contextInfo, ServletInfo servletInfo, final boolean destroy)\n    {\n        for(final ServletHandler handler : this.servletMap.values())\n        {\n            if ( handler.getServletInfo().compareTo(servletInfo) == 0 )\n            {\n                this.servletMap.remove(handler.getServlet());\n                updateServletMapping();\n\n                // Can be null in case of error-handling servlets...\n                String[] patterns = handler.getServletInfo().getPatterns();\n                int length = patterns == null ? 0 : patterns.length;\n\n                for (int i = 0; i < length; i++)\n                {\n                    this.servletPatternMap.remove(patterns[i]);\n                }\n\n                this.errorsMapping.removeServlet(handler.getServlet());\n\n                if (destroy)\n                {\n                    handler.destroy();\n                }\n                return handler.getServlet();\n            }\n        }\n        return null;\n    }","id":101893,"modified_method":"public synchronized Servlet removeServlet(ServletInfo servletInfo, final boolean destroy)\n    {\n        for(final ServletHandler handler : this.servletMap.values())\n        {\n            if ( handler.getServletInfo().compareTo(servletInfo) == 0 )\n            {\n                this.servletMap.remove(handler.getServlet());\n                updateServletMapping();\n\n                // Can be null in case of error-handling servlets...\n                String[] patterns = handler.getServletInfo().getPatterns();\n                int length = patterns == null ? 0 : patterns.length;\n\n                for (int i = 0; i < length; i++)\n                {\n                    this.servletPatternMap.remove(patterns[i]);\n                }\n\n                this.errorsMapping.removeServlet(handler.getServlet());\n\n                if (destroy)\n                {\n                    handler.destroy();\n                }\n                return handler.getServlet();\n            }\n        }\n        return null;\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Add a new servlet.\n     */\n    public synchronized void addServlet(ServletContextHelperInfo contextInfo, ServletHandler handler) throws ServletException, NamespaceException\n    {\n        if (this.servletMap.containsKey(handler.getServlet()))\n        {\n            // Do not destroy the servlet as the same instance was already registered\n            throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");\n        }\n\n        // Can be null in case of error-handling servlets...\n        String[] patterns = handler.getServletInfo().getPatterns();\n        int length = patterns == null ? 0 : patterns.length;\n\n        for (int i = 0; i < length; i++)\n        {\n            final String pattern = patterns[i];\n            if (this.servletPatternMap.containsKey(pattern))\n            {\n                throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");\n            }\n            this.servletPatternMap.put(pattern, handler.getServlet());\n        }\n\n        patterns = handler.getServletInfo().getErrorPage();\n        if ( patterns != null )\n        {\n            for(final String errorPage : patterns)\n            {\n                this.errorsMapping.addErrorServlet(errorPage, handler);\n            }\n        }\n        handler.init();\n        this.servletMap.put(handler.getServlet(), handler);\n\n        updateServletMapping();\n    }","id":101894,"modified_method":"/**\n     * Add a new servlet.\n     */\n    public synchronized void addServlet(final ServletHandler handler) throws ServletException\n    {\n        // Can be null in case of error-handling servlets...\n        String[] patterns = handler.getServletInfo().getPatterns();\n        int length = patterns == null ? 0 : patterns.length;\n\n        for (int i = 0; i < length; i++)\n        {\n            final String pattern = patterns[i];\n            if (this.servletPatternMap.containsKey(pattern))\n            {\n                throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");\n            }\n            this.servletPatternMap.put(pattern, handler.getServlet());\n        }\n\n        patterns = handler.getServletInfo().getErrorPage();\n        if ( patterns != null )\n        {\n            for(final String errorPage : patterns)\n            {\n                this.errorsMapping.addErrorServlet(errorPage, handler);\n            }\n        }\n        handler.init();\n        this.servletMap.put(handler.getServlet(), handler);\n\n        updateServletMapping();\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Constructor for Http Service\n     */\n    public ServletInfo(final String name,\n            final String pattern,\n            final int serviceRanking,\n            final Map<String, String> initParams)\n    {\n        super(serviceRanking);\n        this.name = name;\n        this.patterns = new String[] {pattern};\n        this.initParams = initParams;\n        this.asyncSupported = false;\n        this.errorPage = null;\n    }","id":101895,"modified_method":"/**\n     * Constructor for Http Service\n     */\n    public ServletInfo(final String name,\n            final String pattern,\n            final int serviceRanking,\n            final Map<String, String> initParams)\n    {\n        super(serviceRanking);\n        this.name = name;\n        this.patterns = new String[] {pattern, pattern + \"/*\"};\n        this.initParams = initParams;\n        this.asyncSupported = false;\n        this.errorPage = null;\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Register a resource.\n     * @param contextInfo The servlet context helper info\n     * @param resourceInfo The resource info\n     */\n    public void registerResource(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ResourceInfo resourceInfo)\n    {\n        final ServletInfo servletInfo = new ServletInfo(resourceInfo);\n\n        final Servlet servlet = new ResourceServlet(resourceInfo.getPrefix());\n        final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                servletInfo,\n                servlet);\n        try {\n            this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).addServlet(contextHandler.getContextInfo(), handler);\n        } catch (ServletException e) {\n            // TODO create failure DTO\n        } catch (NamespaceException e) {\n            // TODO create failure DTO\n        }\n    }","id":101896,"modified_method":"/**\n     * Register a resource.\n     * @param contextInfo The servlet context helper info\n     * @param resourceInfo The resource info\n     */\n    public void registerResource(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ResourceInfo resourceInfo)\n    {\n        final ServletInfo servletInfo = new ServletInfo(resourceInfo);\n\n        final Servlet servlet = new ResourceServlet(resourceInfo.getPrefix());\n        final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                servletInfo,\n                servlet);\n        try {\n            this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).addServlet(handler);\n        } catch (ServletException e) {\n            // TODO create failure DTO\n        }\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Register a servlet.\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void registerServlet(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ServletInfo servletInfo)\n    {\n        final Servlet servlet = this.bundleContext.getServiceObjects(servletInfo.getServiceReference()).getService();\n        // TODO create failure DTO if null\n        if ( servlet != null )\n        {\n            final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                    contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                    servletInfo,\n                    servlet);\n            try {\n                this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).addServlet(contextHandler.getContextInfo(), handler);\n            } catch (ServletException e) {\n                // TODO create failure DTO\n            } catch (NamespaceException e) {\n                // TODO create failure DTO\n            }\n        }\n    }","id":101897,"modified_method":"/**\n     * Register a servlet.\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void registerServlet(@Nonnull final ContextHandler contextHandler,\n            @Nonnull final ServletInfo servletInfo)\n    {\n        final ServiceObjects<Servlet> so = this.bundleContext.getServiceObjects(servletInfo.getServiceReference());\n        if ( so != null )\n        {\n            final Servlet servlet = so.getService();\n            // TODO create failure DTO if null\n            if ( servlet != null )\n            {\n                final ServletHandler handler = new ServletHandler(contextHandler.getContextInfo(),\n                        contextHandler.getServletContext(servletInfo.getServiceReference().getBundle()),\n                        servletInfo,\n                        servlet);\n                try {\n                    this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).addServlet(handler);\n                } catch (final ServletException e) {\n                    so.ungetService(servlet);\n                    // TODO create failure DTO\n                }\n            }\n        }\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Unregister a servlet\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void unregisterServlet(@Nonnull final ContextHandler contextHandler, @Nonnull final ServletInfo servletInfo)\n    {\n        final Servlet instance = this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).removeServlet(contextHandler.getContextInfo(), servletInfo, true);\n        if ( instance != null )\n        {\n            this.bundleContext.getServiceObjects(servletInfo.getServiceReference()).ungetService(instance);\n            contextHandler.ungetServletContext(servletInfo.getServiceReference().getBundle());\n        }\n    }","id":101898,"modified_method":"/**\n     * Unregister a servlet\n     * @param contextInfo The servlet context helper info\n     * @param servletInfo The servlet info\n     */\n    public void unregisterServlet(@Nonnull final ContextHandler contextHandler, @Nonnull final ServletInfo servletInfo)\n    {\n        final Servlet instance = this.handlerRegistry.getRegistry(contextHandler.getContextInfo()).removeServlet(servletInfo, true);\n        if ( instance != null )\n        {\n            this.bundleContext.getServiceObjects(servletInfo.getServiceReference()).ungetService(instance);\n            contextHandler.ungetServletContext(servletInfo.getServiceReference().getBundle());\n        }\n    }","commit_id":"c655127f3246cc03ce5f57396be3977650536786","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public void createAsync(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {\n        CreateContext<CreateCmdResult> context = new CreateContext<CreateCmdResult>(callback, data);\n        AsyncCallbackDispatcher<CloudStackImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher\n                .create(this);\n        caller.setContext(context);\n        caller.setCallback(caller.getTarget().createAsyncCallback(null, null));\n\n        if (data.getType() == DataObjectType.TEMPLATE) {\n            _downloadMonitor.downloadTemplateToStorage(data, caller);\n        } else if (data.getType() == DataObjectType.VOLUME) {\n            _downloadMonitor.downloadVolumeToStorage(data, caller);\n        }\n    }","id":101899,"modified_method":"@Override\n    public void createAsync(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {\n        CreateContext<CreateCmdResult> context = new CreateContext<CreateCmdResult>(callback, data);\n        AsyncCallbackDispatcher<CloudStackImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher\n                .create(this);\n        caller.setContext(context);\n        if (data.getType() == DataObjectType.TEMPLATE) {\n            caller.setCallback(caller.getTarget().createTemplateAsyncCallback(null, null));\n            _downloadMonitor.downloadTemplateToStorage(data, caller);\n        } else if (data.getType() == DataObjectType.VOLUME) {\n            caller.setCallback(caller.getTarget().createVolumeAsyncCallback(null, null));\n            _downloadMonitor.downloadVolumeToStorage(data, caller);\n        }\n    }","commit_id":"2473ceb111804a2c9d5394919dac73e73669eb0c","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Void createAsyncCallback(\n            AsyncCallbackDispatcher<CloudStackImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(), obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n            // update size in vm_template table\n            VMTemplateVO tmlptUpdater = templateDao.createForUpdate();\n            tmlptUpdater.setSize(answer.getTemplateSize());\n            templateDao.update(obj.getId(), tmlptUpdater);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSuccess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n            CreateCmdResult result = new CreateCmdResult(null, answer);\n            caller.complete(result);\n        }\n        return null;\n    }","id":101900,"modified_method":"protected Void createTemplateAsyncCallback(AsyncCallbackDispatcher<CloudStackImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(), obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n            // update size in vm_template table\n            VMTemplateVO tmlptUpdater = templateDao.createForUpdate();\n            tmlptUpdater.setSize(answer.getTemplateSize());\n            templateDao.update(obj.getId(), tmlptUpdater);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSuccess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","commit_id":"2473ceb111804a2c9d5394919dac73e73669eb0c","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<S3ImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(), obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n            // update size in vm_template table\n            VMTemplateVO tmlptUpdater = templateDao.createForUpdate();\n            tmlptUpdater.setSize(answer.getTemplateSize());\n            templateDao.update(obj.getId(), tmlptUpdater);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSuccess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","id":101901,"modified_method":"protected Void createTemplateAsyncCallback(AsyncCallbackDispatcher<S3ImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(), obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n            // update size in vm_template table\n            VMTemplateVO tmlptUpdater = templateDao.createForUpdate();\n            tmlptUpdater.setSize(answer.getTemplateSize());\n            templateDao.update(obj.getId(), tmlptUpdater);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSuccess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","commit_id":"2473ceb111804a2c9d5394919dac73e73669eb0c","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void createAsync(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {\n\n        CreateContext<CreateCmdResult> context = new CreateContext<CreateCmdResult>(callback, data);\n        AsyncCallbackDispatcher<S3ImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher.create(this);\n        caller.setContext(context);\n        caller.setCallback(caller.getTarget().createAsyncCallback(null, null));\n\n        if (data.getType() == DataObjectType.TEMPLATE) {\n            _downloadMonitor.downloadTemplateToStorage(data, caller);\n        } else if (data.getType() == DataObjectType.VOLUME) {\n            _downloadMonitor.downloadVolumeToStorage(data, caller);\n        }\n    }","id":101902,"modified_method":"@Override\n    public void createAsync(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {\n\n        CreateContext<CreateCmdResult> context = new CreateContext<CreateCmdResult>(callback, data);\n        AsyncCallbackDispatcher<S3ImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher.create(this);\n        caller.setContext(context);\n        if (data.getType() == DataObjectType.TEMPLATE) {\n            caller.setCallback(caller.getTarget().createTemplateAsyncCallback(null, null));\n            _downloadMonitor.downloadTemplateToStorage(data, caller);\n        } else if (data.getType() == DataObjectType.VOLUME) {\n            caller.setCallback(caller.getTarget().createVolumeAsyncCallback(null, null));\n            _downloadMonitor.downloadVolumeToStorage(data, caller);\n        }\n    }","commit_id":"2473ceb111804a2c9d5394919dac73e73669eb0c","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void createAsync(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {\n        CreateContext<CreateCmdResult> context = new CreateContext<CreateCmdResult>(callback, data);\n        AsyncCallbackDispatcher<SwiftImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher\n                .create(this);\n        caller.setContext(context);\n        caller.setCallback(caller.getTarget().createAsyncCallback(null, null));\n\n        if (data.getType() == DataObjectType.TEMPLATE) {\n            _downloadMonitor.downloadTemplateToStorage(data, caller);\n        } else if (data.getType() == DataObjectType.VOLUME) {\n            _downloadMonitor.downloadVolumeToStorage(data, caller);\n        }\n    }","id":101903,"modified_method":"@Override\n    public void createAsync(DataObject data, AsyncCompletionCallback<CreateCmdResult> callback) {\n        CreateContext<CreateCmdResult> context = new CreateContext<CreateCmdResult>(callback, data);\n        AsyncCallbackDispatcher<SwiftImageStoreDriverImpl, DownloadAnswer> caller = AsyncCallbackDispatcher\n                .create(this);\n        caller.setContext(context);\n        if (data.getType() == DataObjectType.TEMPLATE) {\n            caller.setCallback(caller.getTarget().createTemplateAsyncCallback(null, null));\n            _downloadMonitor.downloadTemplateToStorage(data, caller);\n        } else if (data.getType() == DataObjectType.VOLUME) {\n            caller.setCallback(caller.getTarget().createVolumeAsyncCallback(null, null));\n            _downloadMonitor.downloadVolumeToStorage(data, caller);\n        }\n    }","commit_id":"2473ceb111804a2c9d5394919dac73e73669eb0c","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<SwiftImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(), obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n            // update size in vm_template table\n            VMTemplateVO tmlptUpdater = templateDao.createForUpdate();\n            tmlptUpdater.setSize(answer.getTemplateSize());\n            templateDao.update(obj.getId(), tmlptUpdater);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            // result.setSucess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","id":101904,"modified_method":"protected Void createTemplateAsyncCallback(AsyncCallbackDispatcher<SwiftImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(), obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n            // update size in vm_template table\n            VMTemplateVO tmlptUpdater = templateDao.createForUpdate();\n            tmlptUpdater.setSize(answer.getTemplateSize());\n            templateDao.update(obj.getId(), tmlptUpdater);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED\n                || answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSuccess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","commit_id":"2473ceb111804a2c9d5394919dac73e73669eb0c","url":"https://github.com/apache/cloudstack"},{"original_method":"private boolean removeProcessorFromPotentialIdleStep( StageExecution execution )\n    {\n        Pair<Step<?>,Float> fastest = execution.stepsOrderedBy( Keys.avg_processing_time, true ).iterator().next();\n        float threshold = 1f - (1f/fastest.first().numberOfProcessors());\n        if ( fastest.other().floatValue() < threshold )\n        {\n            Step<?> fastestStep = fastest.first();\n            long doneBatches = batches( fastestStep );\n            if ( batchesPassedSinceLastChange( fastestStep, doneBatches ) >= config.movingAverageSize() )\n            {\n                if ( fastestStep.decrementNumberOfProcessors() )\n                {\n                    lastChangedProcessors.put( fastestStep, doneBatches );\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":101905,"modified_method":"private boolean removeProcessorFromPotentialIdleStep( StageExecution execution )\n    {\n        Pair<Step<?>,Float> fastest = execution.stepsOrderedBy( Keys.avg_processing_time, true ).iterator().next();\n        float threshold = 1f - (1f/fastest.first().numberOfProcessors());\n        if ( fastest.other() < threshold )\n        {\n            Step<?> fastestStep = fastest.first();\n            long doneBatches = batches( fastestStep );\n            if ( batchesPassedSinceLastChange( fastestStep, doneBatches ) >= config.movingAverageSize() )\n            {\n                if ( fastestStep.decrementNumberOfProcessors() )\n                {\n                    lastChangedProcessors.put( fastestStep, doneBatches );\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int assignProcessorsToPotentialBottleNeck( StageExecution execution, int permits )\n    {\n        Pair<Step<?>,Float> bottleNeck = execution.stepsOrderedBy( Keys.avg_processing_time, false ).iterator().next();\n        Step<?> bottleNeckStep = bottleNeck.first();\n        long doneBatches = batches( bottleNeckStep );\n        int usedPermits = 0;\n        if ( bottleNeck.other().floatValue() > 1.0f &&\n             batchesPassedSinceLastChange( bottleNeckStep, doneBatches ) >= config.movingAverageSize() )\n        {\n            int optimalProcessorIncrement = min( max( 1, (int) bottleNeck.other().floatValue() - 1 ), permits );\n            for ( int i = 0; i < optimalProcessorIncrement; i++ )\n            {\n                if ( bottleNeckStep.incrementNumberOfProcessors() )\n                {\n                    lastChangedProcessors.put( bottleNeckStep, doneBatches );\n                    usedPermits++;\n                }\n            }\n        }\n        return usedPermits;\n    }","id":101906,"modified_method":"private int assignProcessorsToPotentialBottleNeck( StageExecution execution, int permits )\n    {\n        Pair<Step<?>,Float> bottleNeck = execution.stepsOrderedBy( Keys.avg_processing_time, false ).iterator().next();\n        Step<?> bottleNeckStep = bottleNeck.first();\n        long doneBatches = batches( bottleNeckStep );\n        int usedPermits = 0;\n        if ( bottleNeck.other() > 1.0f &&\n             batchesPassedSinceLastChange( bottleNeckStep, doneBatches ) >= config.movingAverageSize() )\n        {\n            int optimalProcessorIncrement = min( max( 1, (int) bottleNeck.other().floatValue() - 1 ), permits );\n            for ( int i = 0; i < optimalProcessorIncrement; i++ )\n            {\n                if ( bottleNeckStep.incrementNumberOfProcessors() )\n                {\n                    lastChangedProcessors.put( bottleNeckStep, doneBatches );\n                    usedPermits++;\n                }\n            }\n        }\n        return usedPermits;\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void done()\n    {\n        // Stop the I/O monitor, since the stats in there is based on time passed since the start\n        // and bytes written. NodeStage and CalculateDenseNodesStage can be run in parallel so if\n        // NodeStage completes before CalculateDenseNodesStage then we want to stop the time in the I/O monitor.\n        monitor.stop();\n    }","id":101907,"modified_method":"@Override\n    protected void done()\n    {\n        super.done();\n        // Stop the I/O monitor, since the stats in there is based on time passed since the start\n        // and bytes written. NodeStage and CalculateDenseNodesStage can be run in parallel so if\n        // NodeStage completes before CalculateDenseNodesStage then we want to stop the time in the I/O monitor.\n        monitor.stop();\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"public NodeCountsStage( Configuration config, NodeLabelsCache cache, NodeStore nodeStore,\n            int highLabelId, CountsAccessor.Updater countsUpdater )\n    {\n        super( \"Node counts\", config, false );\n        add( new ReadNodeRecordsStep( control(), config.batchSize(), config.movingAverageSize(), nodeStore ) );\n        add( new ProcessNodeCountsDataStep( control(), cache, config.workAheadSize(),\n                config.movingAverageSize(), nodeStore, highLabelId, countsUpdater ) );\n    }","id":101908,"modified_method":"public NodeCountsStage( Configuration config, NodeLabelsCache cache, NodeStore nodeStore,\n            int highLabelId, CountsAccessor.Updater countsUpdater )\n    {\n        super( \"Node counts\", config, false );\n        add( new ReadNodeRecordsStep( control(), config.batchSize(), config.movingAverageSize(), nodeStore ) );\n        add( new RecordProcessorStep<>( control(), \"COUNT\", config.workAheadSize(), config.movingAverageSize(),\n                new NodeCountsProcessor( nodeStore, cache, highLabelId, countsUpdater ), true ) );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void done()\n    {\n        // We're done adding ids to the IdMapper, prepare for other stages querying it.\n        // We pass in allIds because they may be needed to sort out colliding values in case of String->long\n        // encoding.\n        idMapper.prepare( allIds );\n        super.done();\n    }","id":101909,"modified_method":"@Override\n    protected void done()\n    {\n        super.done();\n        // We're done adding ids to the IdMapper, prepare for other stages querying it.\n        // We pass in allIds because they may be needed to sort out colliding values in case of String->long\n        // encoding.\n        idMapper.prepare( allIds );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"public NodeFirstRelationshipStage( Configuration config, NodeStore nodeStore,\n            RelationshipGroupStore relationshipGroupStore, NodeRelationshipLink cache )\n    {\n        super( \"Node --> Relationship\", config, false );\n        add( new ReadNodeRecordsStep( control(), config.batchSize(), config.movingAverageSize(), nodeStore ) );\n        add( new NodeFirstRelationshipStep( control(), config.workAheadSize(), config.movingAverageSize(),\n                nodeStore, relationshipGroupStore, cache ) );\n        add( new UpdateRecordsStep<>( control(), config.workAheadSize(), config.movingAverageSize(), nodeStore ) );\n    }","id":101910,"modified_method":"public NodeFirstRelationshipStage( Configuration config, NodeStore nodeStore,\n            RelationshipGroupStore relationshipGroupStore, NodeRelationshipLink cache )\n    {\n        super( \"Node --> Relationship\", config, false );\n        add( new ReadNodeRecordsStep( control(), config.batchSize(), config.movingAverageSize(), nodeStore ) );\n        add( new RecordProcessorStep<>( control(), \"LINK\", config.workAheadSize(), config.movingAverageSize(),\n                new NodeFirstRelationshipProcessor( relationshipGroupStore, cache ), false ) );\n        add( new UpdateRecordsStep<>( control(), config.workAheadSize(), config.movingAverageSize(), nodeStore ) );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"public NodeFirstRelationshipStep( StageControl control, int workAheadSize, int movingAverageSize,\n            NodeStore nodeStore, RelationshipGroupStore relationshipGroupStore, NodeRelationshipLink cache )\n    {\n        super( control, \"Node --> Relationship\", workAheadSize, movingAverageSize, 1 );\n        this.processor = new NodeFirstRelationshipProcessor( relationshipGroupStore, cache );\n    }","id":101911,"modified_method":"public NodeFirstRelationshipStep( StageControl control, int workAheadSize, int movingAverageSize,\n            RelationshipGroupStore relationshipGroupStore, NodeRelationshipLink cache )\n    {\n        super( control, \"Node --> Relationship\", workAheadSize, movingAverageSize, 1 );\n        this.processor = new NodeFirstRelationshipProcessor( relationshipGroupStore, cache );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void doImport( Input input ) throws IOException\n    {\n        logger.info( \"Import starting\" );\n\n        // Things that we need to close later. The reason they're not in the try-with-resource statement\n        // is that we need to close, and set to null, at specific points preferably. So use good ol' finally block.\n        NodeRelationshipLink nodeRelationshipLink = null;\n        NodeLabelsCache nodeLabelsCache = null;\n        long startTime = currentTimeMillis();\n        File badRelationshipsFile = new File( config.badFileName() );\n        boolean hasBadRelationships = false;\n        try ( BatchingNeoStore neoStore = new BatchingNeoStore( fileSystem, storeDir, config,\n                writeMonitor, logging, monitors, writerFactory, additionalInitialIds );\n              OutputStream badRelationshipsOutput = new BufferedOutputStream(\n                      fileSystem.openAsOutputStream( badRelationshipsFile, false ) );\n              Collector<InputRelationship> badRelationships =\n                      input.badRelationshipsCollector( badRelationshipsOutput );\n              CountsAccessor.Updater countsUpdater = neoStore.getCountsStore().reset() )\n        {\n            // Some temporary caches and indexes in the import\n            IdMapper idMapper = input.idMapper();\n            IdGenerator idGenerator = input.idGenerator();\n            nodeRelationshipLink = new NodeRelationshipLinkImpl( AUTO, config.denseNodeThreshold() );\n            final InputIterable<InputNode> nodes = input.nodes();\n            final InputIterable<InputRelationship> relationships = input.relationships();\n\n            // Stage 1 -- nodes, properties, labels\n            final NodeStage nodeStage = new NodeStage( nodes, idMapper, idGenerator, neoStore );\n\n            // Stage 2 -- calculate dense node threshold\n            final CalculateDenseNodesStage calculateDenseNodesStage = new CalculateDenseNodesStage( relationships,\n                    nodeRelationshipLink, idMapper, badRelationships );\n\n            // Execute stages 1 and 2 in parallel or sequentially?\n            if ( idMapper.needsPreparation() )\n            {   // The id mapper of choice needs preparation in order to get ids from it,\n                // So we need to execute the node stage first as it fills the id mapper and prepares it in the end,\n                // before executing any stage that needs ids from the id mapper, for example calc dense node stage.\n                executeStages( nodeStage );\n                executeStages( calculateDenseNodesStage );\n            }\n            else\n            {   // The id mapper of choice doesn't need any preparation, so we can go ahead and execute\n                // the node and calc dense node stages in parallel.\n                executeStages( nodeStage, calculateDenseNodesStage );\n            }\n\n            // Stage 3 -- relationships, properties\n            final RelationshipStage relationshipStage = new RelationshipStage( relationships, idMapper,\n                    neoStore, nodeRelationshipLink, input.specificRelationshipIds() );\n            executeStages( relationshipStage );\n\n            // Switch to reverse updating mode and release references that are no longer used so they can be collected\n            writerFactory.awaitEverythingWritten();\n            neoStore.flush();\n\n            // Remaining node processors\n            nodeLabelsCache = new NodeLabelsCache( AUTO, neoStore.getLabelRepository().getHighId() );\n            StoreProcessor<NodeRecord> nodeFirstRelationshipProcessor = new NodeFirstRelationshipProcessor(\n                    neoStore.getRelationshipGroupStore(), nodeRelationshipLink );\n            StoreProcessor<NodeRecord> nodeCountsProcessor = new NodeCountsProcessor( neoStore.getNodeStore(),\n                    nodeLabelsCache, neoStore.getLabelRepository().getHighId(), countsUpdater );\n\n            // Remaining relationship processors\n            StoreProcessor<RelationshipRecord> relationshipLinkerProcessor =\n                    new RelationshipLinkbackProcessor( nodeRelationshipLink );\n            RelationshipCountsProcessor relationshipCountsProcessor = new RelationshipCountsProcessor(\n                    nodeLabelsCache, neoStore.getLabelRepository().getHighId(),\n                    neoStore.getRelationshipTypeRepository().getHighId(), countsUpdater );\n\n            // Determine if we have enough available memory to be able to execute all remaining processors\n            // in parallel.\n            if ( disableParallelizationSinceItCausesWrongCountsComputations() &&\n                 enoughAvailableMemoryForRemainingProcessors( nodeRelationshipLink ) )\n            {\n                // Stages 4, 5, 6 and 7\n                executeStages( new NodeStoreProcessorStage( \"Node --> Relationship + Node counts\", config,\n                        neoStore.getNodeStore(), new StoreProcessor.Multiple<>(\n                        nodeFirstRelationshipProcessor, nodeCountsProcessor ) ) );\n                nodeRelationshipLink.clearRelationships();\n                executeStages( new RelationshipStoreProcessorStage(\n                        \"Relationship --> Relationship + Relationship counts\", config,\n                        neoStore.getRelationshipStore(), new StoreProcessor.Multiple<>(\n                        relationshipLinkerProcessor, relationshipCountsProcessor ) ) );\n            }\n            else\n            {\n                // Stage 4 -- set node nextRel fields\n                executeStages( new NodeFirstRelationshipStage( config, neoStore.getNodeStore(),\n                        neoStore.getRelationshipGroupStore(), nodeRelationshipLink ) );\n                // Stage 5 -- link relationship chains together\n                nodeRelationshipLink.clearRelationships();\n                executeStages( new RelationshipLinkbackStage( config, neoStore.getRelationshipStore(),\n                        nodeRelationshipLink ) );\n\n                // Release this potentially really big piece of cached data\n                nodeRelationshipLink.close();\n                nodeRelationshipLink = null;\n\n                // Stage 6 -- count nodes per label and labels per node\n                executeStages( new NodeCountsStage( config, nodeLabelsCache, neoStore.getNodeStore(),\n                        neoStore.getLabelRepository().getHighId(), countsUpdater ) );\n                // Stage 7 -- count label-[type]->label\n                executeStages( new RelationshipCountsStage( config, nodeLabelsCache, neoStore.getRelationshipStore(),\n                        neoStore.getLabelRepository().getHighId(),\n                        neoStore.getRelationshipTypeRepository().getHighId(), countsUpdater ) );\n            }\n\n            // We're done, do some final logging about it\n            long totalTimeMillis = currentTimeMillis() - startTime;\n            executionMonitor.done( totalTimeMillis );\n            logger.info( \"Import completed, took \" + Format.duration( totalTimeMillis ) );\n            hasBadRelationships = badRelationships.badEntries() > 0;\n            if ( hasBadRelationships )\n            {\n                logger.warn( \"There were \" + badRelationships.badEntries() + \" bad relationships which were skipped \" +\n                             \"and logged into \" + badRelationshipsFile.getAbsolutePath() );\n            }\n        }\n        catch ( Throwable t )\n        {\n            logger.error( \"Error during import\", t );\n            throw Exceptions.launderedException( IOException.class, t );\n        }\n        finally\n        {\n            writerFactory.shutdown();\n            if ( nodeRelationshipLink != null )\n            {\n                nodeRelationshipLink.close();\n            }\n            if ( nodeLabelsCache != null )\n            {\n                nodeLabelsCache.close();\n            }\n            if ( !hasBadRelationships )\n            {\n                fileSystem.deleteFile( badRelationshipsFile );\n            }\n        }\n    }","id":101912,"modified_method":"@Override\n    public void doImport( Input input ) throws IOException\n    {\n        logger.info( \"Import starting\" );\n\n        // Things that we need to close later. The reason they're not in the try-with-resource statement\n        // is that we need to close, and set to null, at specific points preferably. So use good ol' finally block.\n        NodeRelationshipLink nodeRelationshipLink = null;\n        NodeLabelsCache nodeLabelsCache = null;\n        long startTime = currentTimeMillis();\n        File badRelationshipsFile = new File( config.badFileName() );\n        boolean hasBadRelationships = false;\n        try ( BatchingNeoStore neoStore = new BatchingNeoStore( fileSystem, storeDir, config,\n                writeMonitor, logging, monitors, writerFactory, additionalInitialIds );\n              OutputStream badRelationshipsOutput = new BufferedOutputStream(\n                      fileSystem.openAsOutputStream( badRelationshipsFile, false ) );\n              Collector<InputRelationship> badRelationships =\n                      input.badRelationshipsCollector( badRelationshipsOutput );\n              CountsAccessor.Updater countsUpdater = neoStore.getCountsStore().reset() )\n        {\n            // Some temporary caches and indexes in the import\n            IdMapper idMapper = input.idMapper();\n            IdGenerator idGenerator = input.idGenerator();\n            nodeRelationshipLink = new NodeRelationshipLinkImpl( AUTO, config.denseNodeThreshold() );\n            final InputIterable<InputNode> nodes = input.nodes();\n            final InputIterable<InputRelationship> relationships = input.relationships();\n\n            // Stage 1 -- nodes, properties, labels\n            final NodeStage nodeStage = new NodeStage( nodes, idMapper, idGenerator, neoStore );\n\n            // Stage 2 -- calculate dense node threshold\n            final CalculateDenseNodesStage calculateDenseNodesStage = new CalculateDenseNodesStage( relationships,\n                    nodeRelationshipLink, idMapper, badRelationships );\n\n            // Execute stages 1 and 2 in parallel or sequentially?\n            if ( idMapper.needsPreparation() )\n            {   // The id mapper of choice needs preparation in order to get ids from it,\n                // So we need to execute the node stage first as it fills the id mapper and prepares it in the end,\n                // before executing any stage that needs ids from the id mapper, for example calc dense node stage.\n                executeStages( nodeStage );\n                executeStages( calculateDenseNodesStage );\n            }\n            else\n            {   // The id mapper of choice doesn't need any preparation, so we can go ahead and execute\n                // the node and calc dense node stages in parallel.\n                executeStages( nodeStage, calculateDenseNodesStage );\n            }\n\n            // Stage 3 -- relationships, properties\n            final RelationshipStage relationshipStage = new RelationshipStage( relationships, idMapper,\n                    neoStore, nodeRelationshipLink, input.specificRelationshipIds() );\n            executeStages( relationshipStage );\n\n            // Prepare for updating\n            neoStore.flush();\n            writerFactory.awaitEverythingWritten();\n            nodeLabelsCache = new NodeLabelsCache( AUTO, neoStore.getLabelRepository().getHighId() );\n\n            // Stage 4 -- set node nextRel fields\n            executeStages( new NodeFirstRelationshipStage( config, neoStore.getNodeStore(),\n                    neoStore.getRelationshipGroupStore(), nodeRelationshipLink ) );\n            // Stage 5 -- link relationship chains together\n            nodeRelationshipLink.clearRelationships();\n            executeStages( new RelationshipLinkbackStage( config, neoStore.getRelationshipStore(),\n                    nodeRelationshipLink ) );\n\n            // Release this potentially really big piece of cached data\n            nodeRelationshipLink.close();\n            nodeRelationshipLink = null;\n\n            // Stage 6 -- count nodes per label and labels per node\n            executeStages( new NodeCountsStage( config, nodeLabelsCache, neoStore.getNodeStore(),\n                    neoStore.getLabelRepository().getHighId(), countsUpdater ) );\n            // Stage 7 -- count label-[type]->label\n            executeStages( new RelationshipCountsStage( config, nodeLabelsCache, neoStore.getRelationshipStore(),\n                    neoStore.getLabelRepository().getHighId(),\n                    neoStore.getRelationshipTypeRepository().getHighId(), countsUpdater ) );\n\n            // We're done, do some final logging about it\n            long totalTimeMillis = currentTimeMillis() - startTime;\n            executionMonitor.done( totalTimeMillis );\n            logger.info( \"Import completed, took \" + Format.duration( totalTimeMillis ) );\n            hasBadRelationships = badRelationships.badEntries() > 0;\n            if ( hasBadRelationships )\n            {\n                logger.warn( \"There were \" + badRelationships.badEntries() + \" bad relationships which were skipped \" +\n                             \"and logged into \" + badRelationshipsFile.getAbsolutePath() );\n            }\n        }\n        catch ( Throwable t )\n        {\n            logger.error( \"Error during import\", t );\n            throw Exceptions.launderedException( IOException.class, t );\n        }\n        finally\n        {\n            writerFactory.shutdown();\n            if ( nodeRelationshipLink != null )\n            {\n                nodeRelationshipLink.close();\n            }\n            if ( nodeLabelsCache != null )\n            {\n                nodeLabelsCache.close();\n            }\n            if ( !hasBadRelationships )\n            {\n                fileSystem.deleteFile( badRelationshipsFile );\n            }\n        }\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ParallelBatchImporter( String storeDir, Configuration config, Logging logging,\n            ExecutionMonitor executionMonitor )\n    {\n        this( storeDir, new DefaultFileSystemAbstraction(), config, logging, executionMonitor, parallel(), EMPTY,\n                AvailableMemoryCalculator.RUNTIME );\n    }","id":101913,"modified_method":"public ParallelBatchImporter( String storeDir, Configuration config, Logging logging,\n            ExecutionMonitor executionMonitor )\n    {\n        this( storeDir, new DefaultFileSystemAbstraction(), config, logging, executionMonitor, parallel(), EMPTY );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Advanced usage of the parallel batch importer, for special and very specific cases. Please use\n     * a constructor with fewer arguments instead.\n     */\n    public ParallelBatchImporter( String storeDir, FileSystemAbstraction fileSystem, Configuration config,\n            Logging logging, ExecutionMonitor executionMonitor, Function<Configuration,WriterFactory> writerFactory,\n            AdditionalInitialIds additionalInitialIds, AvailableMemoryCalculator memoryCalculator )\n    {\n        this.storeDir = storeDir;\n        this.fileSystem = fileSystem;\n        this.config = config;\n        this.logging = logging;\n        this.executionMonitor = executionMonitor;\n        this.additionalInitialIds = additionalInitialIds;\n        this.memoryCalculator = memoryCalculator;\n        this.logger = logging.getMessagesLog( getClass() );\n        this.monitors = new Monitors();\n        this.writeMonitor = new IoMonitor();\n        this.writerFactory = writerFactory.apply( config );\n    }","id":101914,"modified_method":"/**\n     * Advanced usage of the parallel batch importer, for special and very specific cases. Please use\n     * a constructor with fewer arguments instead.\n     */\n    public ParallelBatchImporter( String storeDir, FileSystemAbstraction fileSystem, Configuration config,\n            Logging logging, ExecutionMonitor executionMonitor, Function<Configuration,WriterFactory> writerFactory,\n            AdditionalInitialIds additionalInitialIds )\n    {\n        this.storeDir = storeDir;\n        this.fileSystem = fileSystem;\n        this.config = config;\n        this.logging = logging;\n        this.executionMonitor = executionMonitor;\n        this.additionalInitialIds = additionalInitialIds;\n        this.logger = logging.getMessagesLog( getClass() );\n        this.monitors = new Monitors();\n        this.writeMonitor = new IoMonitor();\n        this.writerFactory = writerFactory.apply( config );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Parameterized.Parameters(name = \"{0},{1},{2},{4}\")\n    public static Collection<Object[]> data()\n    {\n        return Arrays.<Object[]>asList(\n                // synchronous I/O, actual node id input\n                new Object[]{SYNCHRONOUS, new LongInputIdGenerator(), actual(), fromInput(),\n                        AvailableMemoryCalculator.RUNTIME},\n                // synchronous I/O, string id input\n                new Object[]{SYNCHRONOUS, new StringInputIdGenerator(), strings( AUTO ), startingFromTheBeginning(),\n                        AvailableMemoryCalculator.RUNTIME },\n                // synchronous I/O, string id input, low memory\n                new Object[]{SYNCHRONOUS, new StringInputIdGenerator(), strings( AUTO ), startingFromTheBeginning(),\n                        LOW_MEMORY },\n\n                // FIXME: we've seen this fail before with inconsistencies due to some kind of race in IoQueue\n                //        enabled here to try and trigger the error so that we can fix it.\n                // extra slow parallel I/O, actual node id input\n                new Object[]{new IoQueue( 4, 4, 30, synchronousSlowWriterFactory ),\n                        new LongInputIdGenerator(), actual(), fromInput(), AvailableMemoryCalculator.RUNTIME}\n        );\n    }","id":101915,"modified_method":"@Parameterized.Parameters(name = \"{0},{1},{2},{4}\")\n    public static Collection<Object[]> data()\n    {\n        return Arrays.<Object[]>asList(\n                // synchronous I/O, actual node id input\n                new Object[]{SYNCHRONOUS, new LongInputIdGenerator(), actual(), fromInput()},\n                // synchronous I/O, string id input\n                new Object[]{SYNCHRONOUS, new StringInputIdGenerator(), strings( AUTO ), startingFromTheBeginning()},\n                // extra slow parallel I/O, actual node id input\n                new Object[]{new IoQueue( 4, 4, 30, synchronousSlowWriterFactory ),\n                        new LongInputIdGenerator(), actual(), fromInput()}\n        );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ParallelBatchImporterTest( WriterFactory writerFactory, InputIdGenerator inputIdGenerator,\n            IdMapper idMapper, IdGenerator idGenerator, AvailableMemoryCalculator memoryCalculator )\n    {\n        this.writerFactory = constant( writerFactory );\n        this.inputIdGenerator = inputIdGenerator;\n        this.idMapper = idMapper;\n        this.idGenerator = idGenerator;\n        // Used only to control some aspects of parallelism\n        this.memoryCalculator = memoryCalculator;\n    }","id":101916,"modified_method":"public ParallelBatchImporterTest( WriterFactory writerFactory, InputIdGenerator inputIdGenerator,\n            IdMapper idMapper, IdGenerator idGenerator )\n    {\n        this.writerFactory = constant( writerFactory );\n        this.inputIdGenerator = inputIdGenerator;\n        this.idMapper = idMapper;\n        this.idGenerator = idGenerator;\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldImportCsvData() throws Exception\n    {\n        // GIVEN\n        final BatchImporter inserter = new ParallelBatchImporter( directory.absolutePath(),\n                new DefaultFileSystemAbstraction(), config, new DevNullLoggingService(),\n                invisible(), writerFactory, EMPTY, memoryCalculator );\n\n        boolean successful = false;\n        int relationshipCount = NODE_COUNT * 3;\n        try\n        {\n            // WHEN\n            inserter.doImport( Inputs.input( nodes( NODE_COUNT, inputIdGenerator ),\n                    relationships( relationshipCount, inputIdGenerator ), idMapper, idGenerator, false ) );\n            // THEN\n            GraphDatabaseService db = new TestGraphDatabaseFactory().newEmbeddedDatabase( directory.absolutePath() );\n            try ( Transaction tx = db.beginTx() )\n            {\n                verifyData( NODE_COUNT, db );\n                tx.success();\n            }\n            finally\n            {\n                db.shutdown();\n            }\n            assertConsistent( directory.absolutePath() );\n            successful = true;\n        }\n        finally\n        {\n            if ( !successful )\n            {\n                File failureFile = directory.file( \"input\" );\n                try ( PrintStream out = new PrintStream( failureFile ) )\n                {\n                    out.println( \"Seed used in this failing run: \" + random.seed() );\n                    out.println( inputIdGenerator );\n                    for ( InputRelationship relationship : relationships( relationshipCount, inputIdGenerator ) )\n                    {\n                        out.println( (relationship.hasSpecificId() ? relationship.specificId() + \" \" : \"\") +\n                                relationship.startNode() + \"-[:\" + relationship.type() + \"]->\" + relationship.endNode() );\n                    }\n                }\n                System.err.println( \"Additional debug information stored in \" + failureFile );\n            }\n        }\n    }","id":101917,"modified_method":"@Test\n    public void shouldImportCsvData() throws Exception\n    {\n        // GIVEN\n        final BatchImporter inserter = new ParallelBatchImporter( directory.absolutePath(),\n                new DefaultFileSystemAbstraction(), config, new DevNullLoggingService(),\n                invisible(), writerFactory, EMPTY );\n\n        boolean successful = false;\n        int relationshipCount = NODE_COUNT * 3;\n        try\n        {\n            // WHEN\n            inserter.doImport( Inputs.input( nodes( NODE_COUNT, inputIdGenerator ),\n                    relationships( relationshipCount, inputIdGenerator ), idMapper, idGenerator, false ) );\n            // THEN\n            GraphDatabaseService db = new TestGraphDatabaseFactory().newEmbeddedDatabase( directory.absolutePath() );\n            try ( Transaction tx = db.beginTx() )\n            {\n                verifyData( NODE_COUNT, db );\n                tx.success();\n            }\n            finally\n            {\n                db.shutdown();\n            }\n            assertConsistent( directory.absolutePath() );\n            successful = true;\n        }\n        finally\n        {\n            if ( !successful )\n            {\n                File failureFile = directory.file( \"input\" );\n                try ( PrintStream out = new PrintStream( failureFile ) )\n                {\n                    out.println( \"Seed used in this failing run: \" + random.seed() );\n                    out.println( inputIdGenerator );\n                    for ( InputRelationship relationship : relationships( relationshipCount, inputIdGenerator ) )\n                    {\n                        out.println( (relationship.hasSpecificId() ? relationship.specificId() + \" \" : \"\") +\n                                relationship.startNode() + \"-[:\" + relationship.type() + \"]->\" + relationship.endNode() );\n                    }\n                }\n                System.err.println( \"Additional debug information stored in \" + failureFile );\n            }\n        }\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void done()\n    {\n        for ( RelationshipCountsProcessor processor : processors.values() )\n        {\n            processor.done();\n        }\n    }","id":101918,"modified_method":"@Override\n    protected void done()\n    {\n        super.done();\n        for ( RelationshipCountsProcessor processor : processors.values() )\n        {\n            processor.done();\n        }\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"public RelationshipLinkbackStage( Configuration config, RelationshipStore store, NodeRelationshipLink cache )\n    {\n        super( \"Relationship --> Relationship\", config, false );\n        add( new ReadRelationshipRecordsBackwardsStep(\n                control(), config.batchSize(), config.movingAverageSize(), store ) );\n        add( new RelationshipLinkbackStep(\n                control(), config.workAheadSize(), config.movingAverageSize(), cache ) );\n        add( new UpdateRecordsStep<>( control(), config.workAheadSize(), config.movingAverageSize(), store ) );\n    }","id":101919,"modified_method":"public RelationshipLinkbackStage( Configuration config, RelationshipStore store, NodeRelationshipLink cache )\n    {\n        super( \"Relationship --> Relationship\", config, false );\n        add( new ReadRelationshipRecordsBackwardsStep(\n                control(), config.batchSize(), config.movingAverageSize(), store ) );\n        add( new RecordProcessorStep<>( control(), \"LINK\", config.workAheadSize(),\n                config.movingAverageSize(), new RelationshipLinkbackProcessor( cache ), false ) );\n        add( new UpdateRecordsStep<>( control(), config.workAheadSize(), config.movingAverageSize(), store ) );\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void migrateWithBatchImporter( File storeDir, File migrationDir, long lastTxId, long lastTxChecksum,\n            PageCache pageCache ) throws IOException\n    {\n        prepareBatchImportMigration( storeDir, migrationDir );\n\n        LegacyStore legacyStore;\n        switch ( versionToUpgradeFrom( storeDir ) )\n        {\n            case Legacy19Store.LEGACY_VERSION:\n                legacyStore = new Legacy19Store( fileSystem, new File( storeDir, NeoStore.DEFAULT_NAME ) );\n                break;\n            case Legacy20Store.LEGACY_VERSION:\n                legacyStore = new Legacy20Store( fileSystem, new File( storeDir, NeoStore.DEFAULT_NAME ) );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown version to upgrade from: \" + versionToUpgradeFrom( storeDir ) );\n        }\n\n        BatchImporter importer = new ParallelBatchImporter( migrationDir.getAbsolutePath(), fileSystem,\n                new Configuration.OverrideFromConfig( config ), logging,\n                migrationBatchImporterMonitor( legacyStore, progressMonitor ),\n                parallel(), readAdditionalIds( storeDir, lastTxId, lastTxChecksum ), AvailableMemoryCalculator.RUNTIME );\n        InputIterable<InputNode> nodes = legacyNodesAsInput( legacyStore );\n        InputIterable<InputRelationship> relationships = legacyRelationshipsAsInput( legacyStore );\n        importer.doImport( Inputs.input( nodes, relationships, IdMappers.actual(), IdGenerators.fromInput(), true ) );\n\n        // During migration the batch importer only writes node, relationship, relationship group and counts stores.\n        // Delete the property store files from the batch import migration so that even if we won't\n        // migrate property stores as part of deduplicating property key tokens or properties then\n        // we won't move these empty property store files to the store directory, overwriting the old ones.\n        StoreFile.fileOperation( DELETE, fileSystem, migrationDir, null, Iterables.<StoreFile,StoreFile>iterable(\n                StoreFile.PROPERTY_STORE,\n                StoreFile.PROPERTY_STRING_STORE,\n                StoreFile.PROPERTY_ARRAY_STORE,\n                StoreFile.PROPERTY_KEY_TOKEN_STORE,\n                StoreFile.PROPERTY_KEY_TOKEN_NAMES_STORE ), true, false, StoreFileType.values() );\n\n        // Finish the import of nodes and relationships\n        if ( legacyStore instanceof Legacy19Store )\n        {\n            // we may need to upgrade the property tokens\n            migratePropertyKeys( (Legacy19Store) legacyStore, pageCache, migrationDir );\n        }\n        // Close\n        legacyStore.close();\n    }","id":101920,"modified_method":"private void migrateWithBatchImporter( File storeDir, File migrationDir, long lastTxId, long lastTxChecksum,\n            PageCache pageCache ) throws IOException\n    {\n        prepareBatchImportMigration( storeDir, migrationDir );\n\n        LegacyStore legacyStore;\n        switch ( versionToUpgradeFrom( storeDir ) )\n        {\n            case Legacy19Store.LEGACY_VERSION:\n                legacyStore = new Legacy19Store( fileSystem, new File( storeDir, NeoStore.DEFAULT_NAME ) );\n                break;\n            case Legacy20Store.LEGACY_VERSION:\n                legacyStore = new Legacy20Store( fileSystem, new File( storeDir, NeoStore.DEFAULT_NAME ) );\n                break;\n            default:\n                throw new IllegalStateException( \"Unknown version to upgrade from: \" + versionToUpgradeFrom( storeDir ) );\n        }\n\n        BatchImporter importer = new ParallelBatchImporter( migrationDir.getAbsolutePath(), fileSystem,\n                new Configuration.OverrideFromConfig( config ), logging,\n                migrationBatchImporterMonitor( legacyStore, progressMonitor ),\n                parallel(), readAdditionalIds( storeDir, lastTxId, lastTxChecksum ) );\n        InputIterable<InputNode> nodes = legacyNodesAsInput( legacyStore );\n        InputIterable<InputRelationship> relationships = legacyRelationshipsAsInput( legacyStore );\n        importer.doImport( Inputs.input( nodes, relationships, IdMappers.actual(), IdGenerators.fromInput(), true ) );\n\n        // During migration the batch importer only writes node, relationship, relationship group and counts stores.\n        // Delete the property store files from the batch import migration so that even if we won't\n        // migrate property stores as part of deduplicating property key tokens or properties then\n        // we won't move these empty property store files to the store directory, overwriting the old ones.\n        StoreFile.fileOperation( DELETE, fileSystem, migrationDir, null, Iterables.<StoreFile,StoreFile>iterable(\n                StoreFile.PROPERTY_STORE,\n                StoreFile.PROPERTY_STRING_STORE,\n                StoreFile.PROPERTY_ARRAY_STORE,\n                StoreFile.PROPERTY_KEY_TOKEN_STORE,\n                StoreFile.PROPERTY_KEY_TOKEN_NAMES_STORE ), true, false, StoreFileType.values() );\n\n        // Finish the import of nodes and relationships\n        if ( legacyStore instanceof Legacy19Store )\n        {\n            // we may need to upgrade the property tokens\n            migratePropertyKeys( (Legacy19Store) legacyStore, pageCache, migrationDir );\n        }\n        // Close\n        legacyStore.close();\n    }","commit_id":"72308471b619d951702cb68d6b5580d8988a52dd","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void doTest() throws Exception {\n    doTest(\"canBeFinal/\" + getTestName(false), getManager().getCurrentProfile().getInspectionTool(CanBeFinalInspection.SHORT_NAME));\n  }","id":101921,"modified_method":"private void doTest() throws Exception {\n    final CanBeFinalInspection tool = new CanBeFinalInspection();\n    tool.initialize(getManager());\n    tool.REPORT_CLASSES = true;\n    tool.REPORT_FIELDS = true;\n    tool.REPORT_METHODS = true;\n    doTest(\"canBeFinal/\" + getTestName(false), tool);\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void setUp() throws Exception {\n    super.setUp();\n    CanBeFinalInspection tool = (CanBeFinalInspection)getManager().getCurrentProfile().getInspectionTool(CanBeFinalInspection.SHORT_NAME);\n    tool.REPORT_CLASSES = true;\n    tool.REPORT_FIELDS = true;\n    tool.REPORT_METHODS = true;\n  }","id":101922,"modified_method":"protected void setUp() throws Exception {\n    super.setUp();\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSCR7737() throws Exception {\n    CanBeFinalInspection tool = (CanBeFinalInspection)getManager().getCurrentProfile().getInspectionTool(CanBeFinalInspection.SHORT_NAME);\n    tool.REPORT_CLASSES = false;\n    tool.REPORT_FIELDS = false;\n    tool.REPORT_METHODS = true;\n\n    doTest();\n  }","id":101923,"modified_method":"public void testSCR7737() throws Exception {\n    CanBeFinalInspection tool = new CanBeFinalInspection();\n    tool.initialize(getManager());\n    tool.REPORT_CLASSES = false;\n    tool.REPORT_FIELDS = false;\n    tool.REPORT_METHODS = true;\n\n    doTest();\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest15() throws Exception {\n    doTest(\"dataFlow/\" + getTestName(false),\n           getManager().getCurrentProfile().getInspectionTool(DataFlowInspection.SHORT_NAME), \"java 1.5\");\n  }","id":101924,"modified_method":"private void doTest15() throws Exception {\n    final LocalInspectionToolWrapper tool = new LocalInspectionToolWrapper(new DataFlowInspection());\n    tool.initialize(getManager());\n    doTest(\"dataFlow/\" + getTestName(false),\n           tool, \"java 1.5\");\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest() throws Exception {\n    doTest(\"dataFlow/\" + getTestName(false),\n           getManager().getCurrentProfile().getInspectionTool(DataFlowInspection.SHORT_NAME));\n  }","id":101925,"modified_method":"private void doTest() throws Exception {\n    final LocalInspectionToolWrapper tool = new LocalInspectionToolWrapper(new DataFlowInspection());\n    tool.initialize(getManager());\n    doTest(\"dataFlow/\" + getTestName(false),\n           tool);\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest() throws Exception {\n    doTest(\"defUse/\" + getTestName(false), getTool());\n  }","id":101926,"modified_method":"private void doTest() throws Exception {\n    final InspectionTool tool = new LocalInspectionToolWrapper(new DefUseInspection());\n    tool.initialize(getManager());\n    doTest(\"defUse/\" + getTestName(false), tool);\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest() throws Exception {\n    doTest(\"emptyMethod/\" + getTestName(false), getManager().getCurrentProfile().getInspectionTool(EmptyMethodInspection.SHORT_NAME));\n  }","id":101927,"modified_method":"private void doTest() throws Exception {\n    final EmptyMethodInspection tool = new EmptyMethodInspection();\n    tool.initialize(getManager());\n    doTest(\"emptyMethod/\" + getTestName(false), tool);\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void setUp() throws Exception {\n    super.setUp();\n    myWrapper = (LocalInspectionToolWrapper)getManager().getCurrentProfile().getInspectionTool(FieldCanBeLocalInspection.SHORT_NAME);\n    myTool = myWrapper.getTool();\n  }","id":101928,"modified_method":"protected void setUp() throws Exception {\n    super.setUp();\n    myWrapper = new LocalInspectionToolWrapper( new FieldCanBeLocalInspection());\n    myTool = myWrapper.getTool();\n    myWrapper.initialize(getManager());\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void setUp() throws Exception {\n    super.setUp();\n    myWrapper = (LocalInspectionToolWrapper)getManager().getCurrentProfile().getInspectionTool(LocalCanBeFinal.SHORT_NAME);\n    myTool = (LocalCanBeFinal)myWrapper.getTool();\n  }","id":101929,"modified_method":"protected void setUp() throws Exception {\n    super.setUp();\n    myWrapper = new LocalInspectionToolWrapper(new LocalCanBeFinal());\n    myTool = (LocalCanBeFinal)myWrapper.getTool();\n    myWrapper.initialize(getManager());\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest() throws Exception {\n    doTest(\"redundantThrow/\" + getTestName(false), getManager().getCurrentProfile().getInspectionTool(UnneededThrows.SHORT_NAME));\n  }","id":101930,"modified_method":"private void doTest() throws Exception {\n    final UnneededThrows tool = new UnneededThrows();\n    tool.initialize(getManager());\n    doTest(\"redundantThrow/\" + getTestName(false), tool);\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSCR5008() throws Exception {\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    getTool().SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","id":101931,"modified_method":"public void testSCR5008() throws Exception {\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    myTool.SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSCR6856() throws Exception {\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    getTool().SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","id":101932,"modified_method":"public void testSCR6856() throws Exception {\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    myTool.SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSCR11792() throws Exception {\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    getTool().SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","id":101933,"modified_method":"public void testSCR11792() throws Exception {\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    myTool.SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest() throws Exception {\n    doTest(\"visibility/\" + getTestName(false), getTool());\n  }","id":101934,"modified_method":"private void doTest() throws Exception {\n    myTool.initialize(getManager());\n    doTest(\"visibility/\" + getTestName(false), myTool);\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testpackageLevelTops() throws Exception {\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = false;\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    getTool().SUGGEST_PRIVATE_FOR_INNERS = false;\n\n    doTest();\n  }","id":101935,"modified_method":"public void testpackageLevelTops() throws Exception {\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = false;\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = true;\n    myTool.SUGGEST_PRIVATE_FOR_INNERS = false;\n\n    doTest();\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testinnerConstructor() throws Exception {\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    getTool().SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = false;\n    getTool().SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","id":101936,"modified_method":"public void testinnerConstructor() throws Exception {\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_MEMBERS = true;\n    myTool.SUGGEST_PACKAGE_LOCAL_FOR_TOP_CLASSES = false;\n    myTool.SUGGEST_PRIVATE_FOR_INNERS = true;\n\n    doTest();\n  }","commit_id":"6bc271b60c90c25002f85cd0495cd9e1feea3460","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void buildExtensionsAssembled( ModelBuildingEvent event )\n    {\n        Model model = event.getModel();\n\n        try\n        {\n            remoteRepositories =\n                projectBuildingHelper.createArtifactRepositories( model.getRepositories(), remoteRepositories );\n        }\n        catch ( Exception e )\n        {\n            event.getProblems().addError( \"Invalid artifact repository: \" + e.getMessage(), e );\n        }\n\n        try\n        {\n            pluginRepositories =\n                projectBuildingHelper.createArtifactRepositories( model.getPluginRepositories(), pluginRepositories );\n        }\n        catch ( Exception e )\n        {\n            event.getProblems().addError( \"Invalid plugin repository: \" + e.getMessage(), e );\n        }\n\n        if ( event.getRequest().isProcessPlugins() )\n        {\n            try\n            {\n                projectRealm =\n                    projectBuildingHelper.createProjectRealm( model, projectBuildingRequest.getLocalRepository(),\n                                                              pluginRepositories );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                event.getProblems().addError( \"Unresolveable build extensions: \" + e.getMessage(), e );\n            }\n\n            if ( projectRealm != null )\n            {\n                /*\n                 * Update the context class loader such that the container will search the project realm when the model\n                 * builder injects the lifecycle bindings from the packaging in the next step. The context class loader\n                 * will be reset by the project builder when the project is fully assembled.\n                 */\n                Thread.currentThread().setContextClassLoader( projectRealm );\n            }\n        }\n    }","id":101937,"modified_method":"@Override\n    public void buildExtensionsAssembled( ModelBuildingEvent event )\n    {\n        Model model = event.getModel();\n\n        try\n        {\n            remoteRepositories =\n                projectBuildingHelper.createArtifactRepositories( model.getRepositories(), remoteRepositories );\n        }\n        catch ( Exception e )\n        {\n            event.getProblems().addError( \"Invalid artifact repository: \" + e.getMessage(), e );\n        }\n\n        try\n        {\n            pluginRepositories =\n                projectBuildingHelper.createArtifactRepositories( model.getPluginRepositories(), pluginRepositories );\n        }\n        catch ( Exception e )\n        {\n            event.getProblems().addError( \"Invalid plugin repository: \" + e.getMessage(), e );\n        }\n\n        if ( event.getRequest().isProcessPlugins() )\n        {\n            try\n            {\n                RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();\n                repositoryRequest.setCache( projectBuildingRequest.getRepositoryCache() );\n                repositoryRequest.setLocalRepository( projectBuildingRequest.getLocalRepository() );\n                repositoryRequest.setRemoteRepositories( pluginRepositories );\n                repositoryRequest.setOffline( projectBuildingRequest.isOffline() );\n\n                projectRealm = projectBuildingHelper.createProjectRealm( model, repositoryRequest );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                event.getProblems().addError( \"Unresolveable build extensions: \" + e.getMessage(), e );\n            }\n\n            if ( projectRealm != null )\n            {\n                /*\n                 * Update the context class loader such that the container will search the project realm when the model\n                 * builder injects the lifecycle bindings from the packaging in the next step. The context class loader\n                 * will be reset by the project builder when the project is fully assembled.\n                 */\n                Thread.currentThread().setContextClassLoader( projectRealm );\n            }\n        }\n    }","commit_id":"91d459309fc88fa67136bc468c28edaa457fbc37","url":"https://github.com/apache/maven"},{"original_method":"public ClassRealm createProjectRealm( Model model, ArtifactRepository localRepository,\n                                          List<ArtifactRepository> remoteRepositories )\n        throws ArtifactResolutionException\n    {\n        ClassRealm projectRealm = null;\n\n        Build build = model.getBuild();\n\n        if ( build == null )\n        {\n            return projectRealm;\n        }\n\n        List<Plugin> extensionPlugins = new ArrayList<Plugin>();\n\n        for ( Plugin plugin : build.getPlugins() )\n        {\n            if ( plugin.isExtensions() )\n            {\n                extensionPlugins.add( plugin );\n            }\n        }\n\n        if ( build.getExtensions().isEmpty() && extensionPlugins.isEmpty() )\n        {\n            return projectRealm;\n        }\n\n        projectRealm = classRealmManager.createProjectRealm( model );\n\n        for ( Extension extension : build.getExtensions() )\n        {\n            Artifact artifact =\n                repositorySystem.createArtifact( extension.getGroupId(), extension.getArtifactId(),\n                                                 extension.getVersion(), \"jar\" );\n\n            populateRealm( projectRealm, artifact, null, localRepository, remoteRepositories );\n        }\n\n        for ( Plugin plugin : extensionPlugins )\n        {\n            Artifact artifact = repositorySystem.createPluginArtifact( plugin );\n\n            Set<Artifact> dependencies = new LinkedHashSet<Artifact>();\n            for ( Dependency dependency : plugin.getDependencies() )\n            {\n                dependencies.add( repositorySystem.createDependencyArtifact( dependency ) );\n            }\n\n            populateRealm( projectRealm, artifact, dependencies, localRepository, remoteRepositories );\n        }\n\n        try\n        {\n            container.discoverComponents( projectRealm );\n        }\n        catch ( Exception e )\n        {\n            throw new IllegalStateException( \"Failed to discover components in project realm \" + projectRealm.getId(),\n                                             e );\n        }\n\n        return projectRealm;\n    }","id":101938,"modified_method":"public ClassRealm createProjectRealm( Model model, RepositoryRequest repositoryRequest )\n        throws ArtifactResolutionException\n    {\n        ClassRealm projectRealm = null;\n\n        Build build = model.getBuild();\n\n        if ( build == null )\n        {\n            return projectRealm;\n        }\n\n        List<Plugin> extensionPlugins = new ArrayList<Plugin>();\n\n        for ( Plugin plugin : build.getPlugins() )\n        {\n            if ( plugin.isExtensions() )\n            {\n                extensionPlugins.add( plugin );\n            }\n        }\n\n        if ( build.getExtensions().isEmpty() && extensionPlugins.isEmpty() )\n        {\n            return projectRealm;\n        }\n\n        projectRealm = classRealmManager.createProjectRealm( model );\n\n        for ( Extension extension : build.getExtensions() )\n        {\n            Artifact artifact =\n                repositorySystem.createArtifact( extension.getGroupId(), extension.getArtifactId(),\n                                                 extension.getVersion(), \"jar\" );\n\n            populateRealm( projectRealm, artifact, null, repositoryRequest );\n        }\n\n        for ( Plugin plugin : extensionPlugins )\n        {\n            Artifact artifact = repositorySystem.createPluginArtifact( plugin );\n\n            Set<Artifact> dependencies = new LinkedHashSet<Artifact>();\n            for ( Dependency dependency : plugin.getDependencies() )\n            {\n                dependencies.add( repositorySystem.createDependencyArtifact( dependency ) );\n            }\n\n            populateRealm( projectRealm, artifact, dependencies, repositoryRequest );\n        }\n\n        try\n        {\n            container.discoverComponents( projectRealm );\n        }\n        catch ( Exception e )\n        {\n            throw new IllegalStateException( \"Failed to discover components in project realm \" + projectRealm.getId(),\n                                             e );\n        }\n\n        return projectRealm;\n    }","commit_id":"91d459309fc88fa67136bc468c28edaa457fbc37","url":"https://github.com/apache/maven"},{"original_method":"private void populateRealm( ClassRealm realm, Artifact artifact, Set<Artifact> dependencies,\n                                ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )\n        throws ArtifactResolutionException\n    {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest();\n        request.setArtifact( artifact );\n        request.setArtifactDependencies( dependencies );\n        request.setResolveTransitively( true );\n        request.setLocalRepository( localRepository );\n        request.setRemoteRepositories( remoteRepositories );\n        // FIXME setTransferListener\n\n        ArtifactResolutionResult result = repositorySystem.resolve( request );\n\n        resolutionErrorHandler.throwErrors( request, result );\n\n        ArtifactFilter filter = artifactFilterManager.getCoreArtifactFilter();\n\n        for ( Artifact resultArtifact : result.getArtifacts() )\n        {\n            if ( filter.include( resultArtifact ) )\n            {\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( \"  Included: \" + resultArtifact.getId() );\n                }\n\n                try\n                {\n                    realm.addURL( resultArtifact.getFile().toURI().toURL() );\n                }\n                catch ( MalformedURLException e )\n                {\n                    throw new IllegalStateException( \"Failed to populate project realm \" + realm.getId() + \" with \"\n                        + artifact.getFile(), e );\n                }\n            }\n            else\n            {\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( \"  Excluded: \" + resultArtifact.getId() );\n                }\n            }\n        }\n    }","id":101939,"modified_method":"private void populateRealm( ClassRealm realm, Artifact artifact, Set<Artifact> dependencies,\n                                RepositoryRequest repositoryRequest )\n        throws ArtifactResolutionException\n    {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest( repositoryRequest );\n        request.setArtifact( artifact );\n        request.setArtifactDependencies( dependencies );\n        request.setResolveTransitively( true );\n        // FIXME setTransferListener\n\n        ArtifactResolutionResult result = repositorySystem.resolve( request );\n\n        resolutionErrorHandler.throwErrors( request, result );\n\n        ArtifactFilter filter = artifactFilterManager.getCoreArtifactFilter();\n\n        for ( Artifact resultArtifact : result.getArtifacts() )\n        {\n            if ( filter.include( resultArtifact ) )\n            {\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( \"  Included: \" + resultArtifact.getId() );\n                }\n\n                try\n                {\n                    realm.addURL( resultArtifact.getFile().toURI().toURL() );\n                }\n                catch ( MalformedURLException e )\n                {\n                    throw new IllegalStateException( \"Failed to populate project realm \" + realm.getId() + \" with \"\n                        + artifact.getFile(), e );\n                }\n            }\n            else\n            {\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.debug( \"  Excluded: \" + resultArtifact.getId() );\n                }\n            }\n        }\n    }","commit_id":"91d459309fc88fa67136bc468c28edaa457fbc37","url":"https://github.com/apache/maven"},{"original_method":"public ClassRealm createProjectRealm( Model model, ArtifactRepository localRepository,\n                                       List<ArtifactRepository> remoteRepositories )\n        throws ArtifactResolutionException\n    {\n        return null;\n    }","id":101940,"modified_method":"public ClassRealm createProjectRealm( Model model, RepositoryRequest repositoryRequest )\n        throws ArtifactResolutionException\n    {\n        return null;\n    }","commit_id":"91d459309fc88fa67136bc468c28edaa457fbc37","url":"https://github.com/apache/maven"},{"original_method":"protected DefaultDependencyResolver( final ArtifactResolver resolver, final ArtifactMetadataSource metadataSource,\n                                         final ArtifactFactory factory, final Logger logger )\n    {\n        this.resolver = resolver;\n        this.metadataSource = metadataSource;\n        this.factory = factory;\n        enableLogging( logger );\n    }","id":101941,"modified_method":"protected DefaultDependencyResolver( final ArtifactResolver resolver, final ArtifactFactory factory,\n                                         final Logger logger )\n    {\n        this.resolver = resolver;\n        this.factory = factory;\n        enableLogging( logger );\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"Set<Artifact> resolveNonTransitively( final Assembly assembly, final Set<Artifact> dependencyArtifacts,\n                                          final AssemblerConfigurationSource configSource,\n                                          final List<ArtifactRepository> repos )\n        throws DependencyResolutionException\n    {\n\n        final List<Artifact> missing = new ArrayList<Artifact>();\n        final Set<Artifact> resolved = new LinkedHashSet<Artifact>();\n        for ( final Artifact depArtifact : dependencyArtifacts )\n        {\n            try\n            {\n                resolver.resolve( depArtifact, repos, configSource.getLocalRepository() );\n                resolved.add( depArtifact );\n            }\n            catch ( final ArtifactResolutionException e )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug(\n                        \"Failed to resolve: \" + depArtifact.getId() + \" for assembly: \" + assembly.getId() );\n                }\n                missing.add( depArtifact );\n            }\n            catch ( final ArtifactNotFoundException e )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug(\n                        \"Failed to resolve: \" + depArtifact.getId() + \" for assembly: \" + assembly.getId() );\n                }\n                missing.add( depArtifact );\n            }\n        }\n\n        if ( !missing.isEmpty() )\n        {\n            final MavenProject project = configSource.getProject();\n            final Artifact rootArtifact = project.getArtifact();\n\n            final Throwable error =\n                new MultipleArtifactsNotFoundException( rootArtifact, new ArrayList<Artifact>( resolved ), missing,\n                                                        repos );\n\n            throw new DependencyResolutionException( \"Failed to resolve dependencies for: \" + assembly.getId(), error );\n        }\n\n        return resolved;\n    }","id":101942,"modified_method":"Set<Artifact> resolveNonTransitively( final Assembly assembly, final Set<Artifact> dependencyArtifacts,\n                                          final AssemblerConfigurationSource configSource,\n                                          final List<ArtifactRepository> repos )\n        throws DependencyResolutionException\n    {\n\n        final List<Artifact> missing = new ArrayList<Artifact>();\n        final Set<Artifact> resolved = new LinkedHashSet<Artifact>();\n        for ( final Artifact depArtifact : dependencyArtifacts )\n        {\n            ArtifactResolutionRequest req = new ArtifactResolutionRequest();\n            req.setLocalRepository( configSource.getLocalRepository() );\n            req.setRemoteRepositories( repos );\n            req.setArtifact( depArtifact );\n\n            ArtifactResolutionResult resolve = resolver.resolve( req );\n            if ( resolve.hasExceptions() )\n            {\n                if ( getLogger().isDebugEnabled() )\n                {\n                    getLogger().debug(\n                        \"Failed to resolve: \" + depArtifact.getId() + \" for assembly: \" + assembly.getId() );\n                }\n                missing.add( depArtifact );\n            }\n            else\n            {\n                resolved.add( depArtifact );\n            }\n        }\n\n        if ( !missing.isEmpty() )\n\n        {\n            final MavenProject project = configSource.getProject();\n            final Artifact rootArtifact = project.getArtifact();\n\n            final Throwable error =\n                new MultipleArtifactsNotFoundException( rootArtifact, new ArrayList<Artifact>( resolved ), missing,\n                                                        repos );\n\n            throw new DependencyResolutionException( \"Failed to resolve dependencies for: \" + assembly.getId(), error );\n        }\n\n        return resolved;\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    private Set<Artifact> resolveTransitively( final Set<Artifact> dependencyArtifacts,\n                                               final List<ArtifactRepository> repos,\n                                               final ResolutionManagementInfo info,\n                                               final AssemblerConfigurationSource configSource )\n        throws DependencyResolutionException\n    {\n        final MavenProject project = configSource.getProject();\n\n        final ArtifactFilter filter = info.getScopeFilter();\n        final ArtifactRepository localRepository = configSource.getLocalRepository();\n\n        ArtifactResolutionResult result;\n        try\n        {\n            result = resolver.resolveTransitively( dependencyArtifacts, project.getArtifact(),\n                                                   project.getManagedVersionMap(), localRepository, repos,\n                                                   metadataSource, filter );\n        }\n        catch ( final ArtifactResolutionException e )\n        {\n            throw new DependencyResolutionException( \"Failed to resolve dependencies for assembly: \", e );\n        }\n        catch ( final ArtifactNotFoundException e )\n        {\n            throw new DependencyResolutionException( \"Failed to resolve dependencies for assembly: \", e );\n        }\n\n        getLogger().debug( \"While resolving dependencies of \" + project.getId() + \":\" );\n\n        FilterUtils.reportFilteringStatistics( Collections.singleton( filter ), getLogger() );\n\n        return result.getArtifacts();\n    }","id":101943,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    private Set<Artifact> resolveTransitively( final Set<Artifact> dependencyArtifacts,\n                                               final List<ArtifactRepository> repos,\n                                               final ResolutionManagementInfo info,\n                                               final AssemblerConfigurationSource configSource )\n        throws DependencyResolutionException\n    {\n        final MavenProject project = configSource.getProject();\n\n        final ArtifactFilter filter = info.getScopeFilter();\n\n        ArtifactResolutionRequest req = new ArtifactResolutionRequest();\n        req.setLocalRepository( configSource.getLocalRepository() );\n        req.setResolveRoot( false );\n        req.setRemoteRepositories( repos );\n        req.setResolveTransitively( true );\n        req.setArtifact( project.getArtifact() );\n        req.setArtifactDependencies( dependencyArtifacts );\n        req.setManagedVersionMap( project.getManagedVersionMap() );\n        req.setCollectionFilter( filter );\n        req.setOffline( configSource.getMavenSession().isOffline() );\n        req.setForceUpdate( configSource.getMavenSession().getRequest().isUpdateSnapshots() );\n        req.setServers( configSource.getMavenSession().getRequest().getServers() );\n        req.setMirrors( configSource.getMavenSession().getRequest().getMirrors() );\n        req.setProxies( configSource.getMavenSession().getRequest().getProxies() );\n\n\n\n        ArtifactResolutionResult result;\n\n        result = resolver.resolve( req );\n        if ( result.hasExceptions() )\n        {\n            throw new DependencyResolutionException( \"Failed to resolve dependencies for assembly: \",\n                                                     result.getExceptions().get( 0 ) );\n        }\n\n        getLogger().debug( \"While resolving dependencies of \" + project.getId() + \":\" );\n\n        FilterUtils.reportFilteringStatistics( Collections.singleton( filter ), getLogger() );\n\n        return result.getArtifacts();\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void test_aggregateRemoteArtifactRepositories()\n    {\n        final List<ArtifactRepository> externalRepos = new ArrayList<ArtifactRepository>();\n\n        final ArtifactRepository er1 =\n            repoFactory.createArtifactRepository( \"test.1\", \"http://test.com/path\", layout, null, null );\n        externalRepos.add( er1 );\n\n        final ArtifactRepository er2 =\n            repoFactory.createArtifactRepository( \"test.2\", \"http://test2.com/path\", layout, null, null );\n        externalRepos.add( er2 );\n\n        final List<ArtifactRepository> projectRepos = new ArrayList<ArtifactRepository>();\n\n        final ArtifactRepository pr1 =\n            repoFactory.createArtifactRepository( \"project.1\", \"http://test.com/project\", layout, null, null );\n        projectRepos.add( pr1 );\n\n        final ArtifactRepository pr2 =\n            repoFactory.createArtifactRepository( \"project.2\", \"http://test2.com/path\", layout, null, null );\n        projectRepos.add( pr2 );\n\n        final MavenProject project = createMavenProject( \"group\", \"artifact\", \"1\", new File( \"base\" ) );\n        project.setRemoteArtifactRepositories( projectRepos );\n\n        final List<ArtifactRepository> aggregated =\n            new DefaultDependencyResolver( resolver, metadataSource, factory, logger ).aggregateRemoteArtifactRepositories( externalRepos,\n                                                                                                                                       Collections.singleton( project ) );\n\n        assertRepositoryWithId( er1.getId(), aggregated, true );\n        assertRepositoryWithId( er2.getId(), aggregated, true );\n        assertRepositoryWithId( pr1.getId(), aggregated, true );\n        assertRepositoryWithId( pr2.getId(), aggregated, false );\n    }","id":101944,"modified_method":"public void test_aggregateRemoteArtifactRepositories()\n    {\n        final List<ArtifactRepository> externalRepos = new ArrayList<ArtifactRepository>();\n\n        final ArtifactRepository er1 =\n            repoFactory.createArtifactRepository( \"test.1\", \"http://test.com/path\", layout, null, null );\n        externalRepos.add( er1 );\n\n        final ArtifactRepository er2 =\n            repoFactory.createArtifactRepository( \"test.2\", \"http://test2.com/path\", layout, null, null );\n        externalRepos.add( er2 );\n\n        final List<ArtifactRepository> projectRepos = new ArrayList<ArtifactRepository>();\n\n        final ArtifactRepository pr1 =\n            repoFactory.createArtifactRepository( \"project.1\", \"http://test.com/project\", layout, null, null );\n        projectRepos.add( pr1 );\n\n        final ArtifactRepository pr2 =\n            repoFactory.createArtifactRepository( \"project.2\", \"http://test2.com/path\", layout, null, null );\n        projectRepos.add( pr2 );\n\n        final MavenProject project = createMavenProject( \"group\", \"artifact\", \"1\", new File( \"base\" ) );\n        project.setRemoteArtifactRepositories( projectRepos );\n\n        final List<ArtifactRepository> aggregated =\n            new DefaultDependencyResolver( resolver, factory, logger ).aggregateRemoteArtifactRepositories(\n                externalRepos, Collections.singleton( project ) );\n\n        assertRepositoryWithId( er1.getId(), aggregated, true );\n        assertRepositoryWithId( er2.getId(), aggregated, true );\n        assertRepositoryWithId( pr1.getId(), aggregated, true );\n        assertRepositoryWithId( pr2.getId(), aggregated, false );\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void test_getRepositoryResolutionRequirements()\n    {\n        final List<Repository> repositories = new ArrayList<Repository>();\n\n        {\n            final Repository r = new Repository();\n            r.setScope( Artifact.SCOPE_COMPILE );\n            repositories.add( r );\n        }\n\n        {\n            final Repository r = new Repository();\n            r.setScope( Artifact.SCOPE_SYSTEM );\n            repositories.add( r );\n        }\n\n        final MavenProject project = createMavenProject( \"group\", \"artifact\", \"1.0\", null );\n        final Assembly assembly = new Assembly();\n        assembly.setRepositories( repositories );\n\n        final ResolutionManagementInfo info = new ResolutionManagementInfo( project );\n        new DefaultDependencyResolver( resolver, metadataSource, factory, logger ).updateRepositoryResolutionRequirements(assembly,\n                info\n        );\n\n        assertTrue( info.isResolutionRequired() );\n\n        assertTrue( info.getScopeFilter().isIncludeCompileScope() );\n        assertTrue( info.getScopeFilter().isIncludeSystemScope() );\n\n        assertTrue( info.getScopeFilter().isIncludeProvidedScope() );\n\n        assertFalse( info.getScopeFilter().isIncludeRuntimeScope() );\n        assertFalse( info.getScopeFilter().isIncludeTestScope() );\n    }","id":101945,"modified_method":"public void test_getRepositoryResolutionRequirements()\n    {\n        final List<Repository> repositories = new ArrayList<Repository>();\n\n        {\n            final Repository r = new Repository();\n            r.setScope( Artifact.SCOPE_COMPILE );\n            repositories.add( r );\n        }\n\n        {\n            final Repository r = new Repository();\n            r.setScope( Artifact.SCOPE_SYSTEM );\n            repositories.add( r );\n        }\n\n        final MavenProject project = createMavenProject( \"group\", \"artifact\", \"1.0\", null );\n        final Assembly assembly = new Assembly();\n        assembly.setRepositories( repositories );\n\n        final ResolutionManagementInfo info = new ResolutionManagementInfo( project );\n        new DefaultDependencyResolver( resolver, factory, logger ).updateRepositoryResolutionRequirements( assembly,\n                                                                                                           info );\n\n        assertTrue( info.isResolutionRequired() );\n\n        assertTrue( info.getScopeFilter().isIncludeCompileScope() );\n        assertTrue( info.getScopeFilter().isIncludeSystemScope() );\n\n        assertTrue( info.getScopeFilter().isIncludeProvidedScope() );\n\n        assertFalse( info.getScopeFilter().isIncludeRuntimeScope() );\n        assertFalse( info.getScopeFilter().isIncludeTestScope() );\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void test_getModuleSetResolutionRequirements()\n        throws DependencyResolutionException\n    {\n        final EasyMockSupport mm = new EasyMockSupport();\n\n        final AssemblerConfigurationSource cs = mm.createMock( AssemblerConfigurationSource.class );\n\n        final File rootDir = new File( \"root\" );\n        final MavenProject project = createMavenProject( \"main-group\", \"main-artifact\", \"1\", rootDir );\n\n        final File module1Dir = new File( rootDir, \"module-1\" );\n        final MavenProject module1 = createMavenProject( \"main-group\", \"module-1\", \"1\", module1Dir );\n        final MavenProject module1a =\n            createMavenProject( \"group1\", \"module-1a\", \"1\", new File( module1Dir, \"module-1a\" ) );\n        final MavenProject module1b =\n            createMavenProject( \"group1.b\", \"module-1b\", \"1\", new File( module1Dir, \"module-1b\" ) );\n\n        module1.getModel().addModule( module1a.getArtifactId() );\n        module1.getModel().addModule( module1b.getArtifactId() );\n\n        final File module2Dir = new File( rootDir, \"module-2\" );\n        final MavenProject module2 = createMavenProject( \"main-group\", \"module-2\", \"1\", module2Dir );\n        final MavenProject module2a =\n            createMavenProject( \"main-group\", \"module-2a\", \"1\", new File( module2Dir, \"module-2a\" ) );\n\n        module2.getModel().addModule( module2a.getArtifactId() );\n\n        project.getModel().addModule( module1.getArtifactId() );\n        project.getModel().addModule( module2.getArtifactId() );\n\n        final List<MavenProject> allProjects = new ArrayList<MavenProject>();\n        allProjects.add( project );\n        allProjects.add( module1 );\n        allProjects.add( module1a );\n        allProjects.add( module1b );\n        allProjects.add( module2 );\n        allProjects.add( module2a );\n\n        expect( cs.getReactorProjects()).andReturn( allProjects ).anyTimes();\n\n        expect( cs.getProject()).andReturn( project ).anyTimes();\n\n        final ResolutionManagementInfo info = new ResolutionManagementInfo( project );\n\n        final List<ModuleSet> moduleSets = new ArrayList<ModuleSet>();\n\n        final ModuleSet ms1 = new ModuleSet();\n        final DependencySet ds1 = new DependencySet();\n        {\n            ms1.addInclude( \"*module1*\" );\n            ms1.setIncludeSubModules( false );\n\n            final ModuleBinaries mb = new ModuleBinaries();\n\n            ds1.setScope( Artifact.SCOPE_COMPILE );\n\n            mb.addDependencySet( ds1 );\n            ms1.setBinaries( mb );\n            moduleSets.add( ms1 );\n        }\n\n        final ModuleSet ms2 = new ModuleSet();\n        final DependencySet ds2 = new DependencySet();\n        {\n            ms2.addInclude( \"main-group:*\" );\n            ms2.setIncludeSubModules( true );\n\n            final ModuleBinaries mb = new ModuleBinaries();\n\n            ds2.setScope( Artifact.SCOPE_TEST );\n\n            mb.addDependencySet( ds2 );\n            ms2.setBinaries( mb );\n            moduleSets.add( ms2 );\n        }\n\n        mm.replayAll();\n\n        final DefaultDependencyResolver resolver =\n            new DefaultDependencyResolver( this.resolver, metadataSource, factory, logger );\n        resolver.enableLogging( new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" ) );\n\n        final Assembly assembly = new Assembly();\n        assembly.setModuleSets( moduleSets );\n\n        resolver.updateModuleSetResolutionRequirements(AssemblyId.createAssemblyId( assembly), ms1, ds1, info, cs);\n        resolver.updateModuleSetResolutionRequirements(AssemblyId.createAssemblyId( assembly ), ms2, ds2, info, cs);\n\n        assertTrue( info.isResolutionRequired() );\n\n        final Set<MavenProject> enabledProjects = info.getEnabledProjects();\n        assertTrue( enabledProjects.contains( project ) );\n\n        assertTrue( enabledProjects.contains( module1 ) );\n\n        // these should be excluded since sub-modules are not traversable\n        assertFalse( enabledProjects.contains( module1a ) );\n        assertFalse( enabledProjects.contains( module1b ) );\n\n        assertTrue( enabledProjects.contains( module2 ) );\n        assertTrue( enabledProjects.contains( module2a ) );\n\n        // these are the two we directly set above.\n        assertTrue( info.getScopeFilter().isIncludeTestScope() );\n        assertTrue( info.getScopeFilter().isIncludeCompileScope() );\n\n        // this combination should be implied by the two direct scopes set above.\n        assertTrue( info.getScopeFilter().isIncludeRuntimeScope() );\n        assertTrue( info.getScopeFilter().isIncludeProvidedScope() );\n        assertTrue( info.getScopeFilter().isIncludeSystemScope() );\n\n        mm.verifyAll();\n    }","id":101946,"modified_method":"public void test_getModuleSetResolutionRequirements()\n        throws DependencyResolutionException\n    {\n        final EasyMockSupport mm = new EasyMockSupport();\n\n        final AssemblerConfigurationSource cs = mm.createMock( AssemblerConfigurationSource.class );\n\n        final File rootDir = new File( \"root\" );\n        final MavenProject project = createMavenProject( \"main-group\", \"main-artifact\", \"1\", rootDir );\n\n        final File module1Dir = new File( rootDir, \"module-1\" );\n        final MavenProject module1 = createMavenProject( \"main-group\", \"module-1\", \"1\", module1Dir );\n        final MavenProject module1a =\n            createMavenProject( \"group1\", \"module-1a\", \"1\", new File( module1Dir, \"module-1a\" ) );\n        final MavenProject module1b =\n            createMavenProject( \"group1.b\", \"module-1b\", \"1\", new File( module1Dir, \"module-1b\" ) );\n\n        module1.getModel().addModule( module1a.getArtifactId() );\n        module1.getModel().addModule( module1b.getArtifactId() );\n\n        final File module2Dir = new File( rootDir, \"module-2\" );\n        final MavenProject module2 = createMavenProject( \"main-group\", \"module-2\", \"1\", module2Dir );\n        final MavenProject module2a =\n            createMavenProject( \"main-group\", \"module-2a\", \"1\", new File( module2Dir, \"module-2a\" ) );\n\n        module2.getModel().addModule( module2a.getArtifactId() );\n\n        project.getModel().addModule( module1.getArtifactId() );\n        project.getModel().addModule( module2.getArtifactId() );\n\n        final List<MavenProject> allProjects = new ArrayList<MavenProject>();\n        allProjects.add( project );\n        allProjects.add( module1 );\n        allProjects.add( module1a );\n        allProjects.add( module1b );\n        allProjects.add( module2 );\n        allProjects.add( module2a );\n\n        expect( cs.getReactorProjects() ).andReturn( allProjects ).anyTimes();\n\n        expect( cs.getProject() ).andReturn( project ).anyTimes();\n\n        final ResolutionManagementInfo info = new ResolutionManagementInfo( project );\n\n        final List<ModuleSet> moduleSets = new ArrayList<ModuleSet>();\n\n        final ModuleSet ms1 = new ModuleSet();\n        final DependencySet ds1 = new DependencySet();\n        {\n            ms1.addInclude( \"*module1*\" );\n            ms1.setIncludeSubModules( false );\n\n            final ModuleBinaries mb = new ModuleBinaries();\n\n            ds1.setScope( Artifact.SCOPE_COMPILE );\n\n            mb.addDependencySet( ds1 );\n            ms1.setBinaries( mb );\n            moduleSets.add( ms1 );\n        }\n\n        final ModuleSet ms2 = new ModuleSet();\n        final DependencySet ds2 = new DependencySet();\n        {\n            ms2.addInclude( \"main-group:*\" );\n            ms2.setIncludeSubModules( true );\n\n            final ModuleBinaries mb = new ModuleBinaries();\n\n            ds2.setScope( Artifact.SCOPE_TEST );\n\n            mb.addDependencySet( ds2 );\n            ms2.setBinaries( mb );\n            moduleSets.add( ms2 );\n        }\n\n        mm.replayAll();\n\n        final DefaultDependencyResolver resolver = new DefaultDependencyResolver( this.resolver, factory, logger );\n        resolver.enableLogging( new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" ) );\n\n        final Assembly assembly = new Assembly();\n        assembly.setModuleSets( moduleSets );\n\n        resolver.updateModuleSetResolutionRequirements( AssemblyId.createAssemblyId( assembly ), ms1, ds1, info, cs );\n        resolver.updateModuleSetResolutionRequirements( AssemblyId.createAssemblyId( assembly ), ms2, ds2, info, cs );\n\n        assertTrue( info.isResolutionRequired() );\n\n        final Set<MavenProject> enabledProjects = info.getEnabledProjects();\n        assertTrue( enabledProjects.contains( project ) );\n\n        assertTrue( enabledProjects.contains( module1 ) );\n\n        // these should be excluded since sub-modules are not traversable\n        assertFalse( enabledProjects.contains( module1a ) );\n        assertFalse( enabledProjects.contains( module1b ) );\n\n        assertTrue( enabledProjects.contains( module2 ) );\n        assertTrue( enabledProjects.contains( module2a ) );\n\n        // these are the two we directly set above.\n        assertTrue( info.getScopeFilter().isIncludeTestScope() );\n        assertTrue( info.getScopeFilter().isIncludeCompileScope() );\n\n        // this combination should be implied by the two direct scopes set above.\n        assertTrue( info.getScopeFilter().isIncludeRuntimeScope() );\n        assertTrue( info.getScopeFilter().isIncludeProvidedScope() );\n        assertTrue( info.getScopeFilter().isIncludeSystemScope() );\n\n        mm.verifyAll();\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        resolver = (ArtifactResolver) lookup( ArtifactResolver.ROLE );\n        metadataSource = (ArtifactMetadataSource) lookup( ArtifactMetadataSource.class);\n        factory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );\n        repoFactory = (ArtifactRepositoryFactory) lookup( ArtifactRepositoryFactory.ROLE );\n        layout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE, \"default\" );\n        logger = new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" );\n    }","id":101947,"modified_method":"@Override\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n\n        resolver = (ArtifactResolver) lookup( ArtifactResolver.ROLE );\n        factory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );\n        repoFactory = (ArtifactRepositoryFactory) lookup( ArtifactRepositoryFactory.ROLE );\n        layout = (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE, \"default\" );\n        logger = new ConsoleLogger( Logger.LEVEL_DEBUG, \"test\" );\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void test_getDependencySetResolutionRequirements()\n        throws DependencyResolutionException\n    {\n        final DependencySet ds1 = new DependencySet();\n        ds1.setScope( Artifact.SCOPE_COMPILE );\n        ds1.setUseTransitiveDependencies( false );\n\n        final DependencySet ds2 = new DependencySet();\n        ds2.setScope( Artifact.SCOPE_SYSTEM );\n        ds2.setUseTransitiveDependencies( false );\n\n        final MavenProject project = createMavenProject( \"main-group\", \"main-artifact\", \"1\", null );\n\n        final ResolutionManagementInfo info = new ResolutionManagementInfo( project );\n\n        final Assembly assembly = new Assembly();\n        new DefaultDependencyResolver( resolver, metadataSource, factory, logger ).updateDependencySetResolutionRequirements(\n            ds1,\n                info, AssemblyId.createAssemblyId( assembly),\n                project);\n\n        assertTrue( info.isResolutionRequired() );\n        assertFalse( info.isResolvedTransitively() );\n\n        assertTrue( info.getScopeFilter().isIncludeCompileScope() );\n        assertTrue( info.getScopeFilter().isIncludeSystemScope() );\n\n        assertTrue( info.getScopeFilter().isIncludeProvidedScope() );\n\n        assertFalse( info.getScopeFilter().isIncludeRuntimeScope() );\n        assertFalse( info.getScopeFilter().isIncludeTestScope() );\n    }","id":101948,"modified_method":"public void test_getDependencySetResolutionRequirements()\n        throws DependencyResolutionException\n    {\n        final DependencySet ds1 = new DependencySet();\n        ds1.setScope( Artifact.SCOPE_COMPILE );\n        ds1.setUseTransitiveDependencies( false );\n\n        final DependencySet ds2 = new DependencySet();\n        ds2.setScope( Artifact.SCOPE_SYSTEM );\n        ds2.setUseTransitiveDependencies( false );\n\n        final MavenProject project = createMavenProject( \"main-group\", \"main-artifact\", \"1\", null );\n\n        final ResolutionManagementInfo info = new ResolutionManagementInfo( project );\n\n        final Assembly assembly = new Assembly();\n        new DefaultDependencyResolver( resolver, factory, logger ).updateDependencySetResolutionRequirements( ds1, info,\n                                                                                                              AssemblyId.createAssemblyId(\n                                                                                                                  assembly ),\n                                                                                                              project );\n\n        assertTrue( info.isResolutionRequired() );\n        assertFalse( info.isResolvedTransitively() );\n\n        assertTrue( info.getScopeFilter().isIncludeCompileScope() );\n        assertTrue( info.getScopeFilter().isIncludeSystemScope() );\n\n        assertTrue( info.getScopeFilter().isIncludeProvidedScope() );\n\n        assertFalse( info.getScopeFilter().isIncludeRuntimeScope() );\n        assertFalse( info.getScopeFilter().isIncludeTestScope() );\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"private DependencySetAssemblyPhase createPhase( final MockAndControlForAddDependencySetsTask macTask,\n                                                    final Logger logger, DependencyResolver dr )\n    {\n        ProjectBuilder projectBuilder = null;\n\n        if ( macTask != null )\n        {\n            projectBuilder = macTask.projectBuilder;\n        }\n\n        final DependencySetAssemblyPhase phase = new DependencySetAssemblyPhase( projectBuilder, dr, logger );\n\n        phase.enableLogging( logger );\n\n        return phase;\n    }","id":101949,"modified_method":"private DependencySetAssemblyPhase createPhase( final MockAndControlForAddDependencySetsTask macTask,\n                                                    final Logger logger, DependencyResolver dr )\n    {\n        ProjectBuilder projectBuilder = null;\n\n        if ( macTask != null )\n        {\n            projectBuilder = macTask.projectBuilder;\n        }\n\n        final DependencySetAssemblyPhase phase = new DependencySetAssemblyPhase( null, dr, null );\n        phase.enableLogging( logger );\n\n        return phase;\n    }","commit_id":"f46d1de40a7b0da507a52194e82c994865ef6534","url":"https://github.com/apache/maven-plugins"},{"original_method":"private static boolean setMethod(Method method, Map<Method, Object> methods, Object value) {\n        if (value != null) {\n            if (!isAcceptableType(method.getReturnType(), method.getGenericReturnType(), value) && value instanceof Adaptable) {\n                value = ((Adaptable) value).adaptTo(method.getReturnType());\n                if (value == null) {\n                    return false;\n                }\n            }\n            methods.put(method, value);\n            return true;\n        } else {\n            return false;\n        }\n    }","id":101950,"modified_method":"private static boolean setMethod(Method method, Map<Method, Object> methods, Object value) {\n        if (value != null) {\n            value = adaptIfNecessary(value, method.getReturnType(), method.getGenericReturnType());\n            // value may now be null due to the adaptation done above\n            if (value == null) {\n                return false;\n            }\n            methods.put(method, value);\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"0c2cee7000d7886ed3043a5f35b2e0da4dac9146","url":"https://github.com/apache/sling"},{"original_method":"private static boolean setConstructorParameter(ConstructorParameter constructorParameter, List<Object> parameterValues, Object value) {\n        if (value != null && constructorParameter.getType() instanceof Class<?>) {\n            Class<?> requestedType = (Class<?>)constructorParameter.getType();\n            if (!isAcceptableType(requestedType, constructorParameter.getGenericType(), value)) {\n                if (value instanceof Adaptable) {\n                    value = ((Adaptable) value).adaptTo(requestedType);\n                    if (value == null) {\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            parameterValues.set(constructorParameter.getParameterIndex(), value);\n            return true;\n        } else {\n            return false;\n        }\n    }","id":101951,"modified_method":"private static boolean setConstructorParameter(ConstructorParameter constructorParameter, List<Object> parameterValues, Object value) {\n        if (value != null && constructorParameter.getType() instanceof Class<?>) {\n            value = adaptIfNecessary(value, (Class<?>) constructorParameter.getType(), constructorParameter.getGenericType());\n            // value may now be null due to the adaptation done above\n            if (value == null) {\n                return false;\n            }\n            parameterValues.set(constructorParameter.getParameterIndex(), value);\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"0c2cee7000d7886ed3043a5f35b2e0da4dac9146","url":"https://github.com/apache/sling"},{"original_method":"private static boolean setField(Field field, Object createdObject, Object value) {\n        if (value != null) {\n            if (!isAcceptableType(field.getType(), field.getGenericType(), value)) {\n                Class<?> declaredType = field.getType();\n                Type genericType = field.getGenericType();\n                if (value instanceof Adaptable) {\n                    value = ((Adaptable) value).adaptTo(field.getType());\n                    if (value == null) {\n                        return false;\n                    }\n                } else if (genericType instanceof ParameterizedType) {\n                    ParameterizedType type = (ParameterizedType) genericType;\n                    Class<?> collectionType = (Class<?>) declaredType;\n                    if (value instanceof Collection &&\n                            (collectionType.equals(Collection.class) || collectionType.equals(List.class)) &&\n                            type.getActualTypeArguments().length == 1) {\n                        List<Object> result = new ArrayList<Object>();\n                        for (Object valueObject : (Collection<?>) value) {\n                            if (valueObject instanceof Adaptable) {\n                                Object adapted = ((Adaptable) valueObject).adaptTo((Class<?>) type.getActualTypeArguments()[0]);\n                                if (adapted != null) {\n                                    result.add(adapted);\n                                }\n                            }\n                        }\n                        value = result;\n                    }\n                }\n            }\n            boolean accessible = field.isAccessible();\n            try {\n                if (!accessible) {\n                    field.setAccessible(true);\n                }\n                field.set(createdObject, value);\n                return true;\n            } catch (Exception e) {\n                log.error(\"unable to inject field\", e);\n                return false;\n            } finally {\n                if (!accessible) {\n                    field.setAccessible(false);\n                }\n            }\n        } else {\n            return false;\n        }\n    }","id":101952,"modified_method":"private static boolean setField(Field field, Object createdObject, Object value) {\n        if (value != null) {\n            value = adaptIfNecessary(value, field.getType(), field.getGenericType());\n            // value may now be null due to the adaptation done above\n            if (value == null) {\n                return false;\n            }\n            boolean accessible = field.isAccessible();\n            try {\n                if (!accessible) {\n                    field.setAccessible(true);\n                }\n                field.set(createdObject, value);\n                return true;\n            } catch (Exception e) {\n                log.error(\"unable to inject field\", e);\n                return false;\n            } finally {\n                if (!accessible) {\n                    field.setAccessible(false);\n                }\n            }\n        } else {\n            return false;\n        }\n    }","commit_id":"0c2cee7000d7886ed3043a5f35b2e0da4dac9146","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testChildModel() {\n        Object firstValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap firstMap = new ValueMapDecorator(Collections.singletonMap(\"property\", firstValue));\n\n        final Resource firstChild = mock(Resource.class);\n        when(firstChild.adaptTo(ValueMap.class)).thenReturn(firstMap);\n        when(firstChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildMap());\n\n        Object firstGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap firstGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", firstGrandChildValue));\n        Object secondGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap secondGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", secondGrandChildValue));\n\n        final Resource firstGrandChild = mock(Resource.class);\n        when(firstGrandChild.adaptTo(ValueMap.class)).thenReturn(firstGrandChildMap);\n        when(firstGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildMap());\n\n        final Resource secondGrandChild = mock(Resource.class);\n        when(secondGrandChild.adaptTo(ValueMap.class)).thenReturn(secondGrandChildMap);\n        when(secondGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildMap());\n\n        Resource secondChild = mock(Resource.class);\n        when(secondChild.listChildren()).thenReturn(Arrays.asList(firstGrandChild, secondGrandChild).iterator());\n\n        Resource emptyChild = mock(Resource.class);\n        when(emptyChild.listChildren()).thenReturn(Collections.<Resource>emptySet().iterator());\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(firstChild);\n        when(res.getChild(\"secondChild\")).thenReturn(secondChild);\n        when(res.getChild(\"emptyChild\")).thenReturn(emptyChild);\n\n        ParentModel model = factory.getAdapter(res, ParentModel.class);\n        assertNotNull(model);\n\n        ChildModel childModel = model.getFirstChild();\n        assertNotNull(childModel);\n        assertEquals(firstValue, childModel.getProperty());\n        assertEquals(2, model.getGrandChildren().size());\n        assertEquals(firstGrandChildValue, model.getGrandChildren().get(0).getProperty());\n        assertEquals(secondGrandChildValue, model.getGrandChildren().get(1).getProperty());\n    }","id":101953,"modified_method":"@Test\n    public void testChildModel() {\n        Object firstValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap firstMap = new ValueMapDecorator(Collections.singletonMap(\"property\", firstValue));\n\n        final Resource firstChild = mock(Resource.class);\n        when(firstChild.adaptTo(ValueMap.class)).thenReturn(firstMap);\n        when(firstChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildModel());\n\n        Object firstGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap firstGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", firstGrandChildValue));\n        Object secondGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap secondGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", secondGrandChildValue));\n\n        final Resource firstGrandChild = mock(Resource.class);\n        when(firstGrandChild.adaptTo(ValueMap.class)).thenReturn(firstGrandChildMap);\n        when(firstGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildModel());\n\n        final Resource secondGrandChild = mock(Resource.class);\n        when(secondGrandChild.adaptTo(ValueMap.class)).thenReturn(secondGrandChildMap);\n        when(secondGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildModel());\n\n        Resource secondChild = mock(Resource.class);\n        when(secondChild.listChildren()).thenReturn(Arrays.asList(firstGrandChild, secondGrandChild).iterator());\n\n        Resource emptyChild = mock(Resource.class);\n        when(emptyChild.listChildren()).thenReturn(Collections.<Resource>emptySet().iterator());\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(firstChild);\n        when(res.getChild(\"secondChild\")).thenReturn(secondChild);\n        when(res.getChild(\"emptyChild\")).thenReturn(emptyChild);\n\n        ParentModel model = factory.getAdapter(res, ParentModel.class);\n        assertNotNull(model);\n\n        ChildModel childModel = model.getFirstChild();\n        assertNotNull(childModel);\n        assertEquals(firstValue, childModel.getProperty());\n        assertEquals(2, model.getGrandChildren().size());\n        assertEquals(firstGrandChildValue, model.getGrandChildren().get(0).getProperty());\n        assertEquals(secondGrandChildValue, model.getGrandChildren().get(1).getProperty());\n        assertEquals(0, model.getEmptyGrandChildren().size());\n    }","commit_id":"0c2cee7000d7886ed3043a5f35b2e0da4dac9146","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testChildModel() {\n        Object value = RandomStringUtils.randomAlphabetic(10);\n        Map<String, Object> props = Collections.singletonMap(\"property\", value);\n        ValueMap map = new ValueMapDecorator(props);\n\n        final Resource child = mock(Resource.class);\n        when(child.adaptTo(ValueMap.class)).thenReturn(map);\n        when(child.adaptTo(ChildModel.class)).thenAnswer(new Answer<ChildModel>() {\n\n            @Override\n            public ChildModel answer(InvocationOnMock invocation) throws Throwable {\n                return factory.getAdapter(child, ChildModel.class);\n            }\n\n        });\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(child);\n\n        ParentModel model = factory.getAdapter(res, ParentModel.class);\n        assertNotNull(model);\n\n        ChildModel childModel = model.getFirstChild();\n        assertNotNull(childModel);\n        assertEquals(value, childModel.getProperty());\n    }","id":101954,"modified_method":"@Test\n    public void testChildModel() {\n        Object value = RandomStringUtils.randomAlphabetic(10);\n        Map<String, Object> props = Collections.singletonMap(\"property\", value);\n        ValueMap map = new ValueMapDecorator(props);\n\n        final Resource firstChild = mock(Resource.class);\n        when(firstChild.adaptTo(ValueMap.class)).thenReturn(map);\n        when(firstChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildModel());\n\n        Object firstGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap firstGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", firstGrandChildValue));\n        Object secondGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap secondGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", secondGrandChildValue));\n\n        final Resource firstGrandChild = mock(Resource.class);\n        when(firstGrandChild.adaptTo(ValueMap.class)).thenReturn(firstGrandChildMap);\n        when(firstGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildModel());\n\n        final Resource secondGrandChild = mock(Resource.class);\n        when(secondGrandChild.adaptTo(ValueMap.class)).thenReturn(secondGrandChildMap);\n        when(secondGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildModel());\n\n        Resource secondChild = mock(Resource.class);\n        when(secondChild.listChildren()).thenReturn(Arrays.asList(firstGrandChild, secondGrandChild).iterator());\n\n        Resource emptyChild = mock(Resource.class);\n        when(emptyChild.listChildren()).thenReturn(Collections.<Resource>emptySet().iterator());\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(firstChild);\n        when(res.getChild(\"secondChild\")).thenReturn(secondChild);\n        when(res.getChild(\"emptyChild\")).thenReturn(emptyChild);\n\n        ParentModel model = factory.getAdapter(res, ParentModel.class);\n        assertNotNull(model);\n\n        ChildModel childModel = model.getFirstChild();\n        assertNotNull(childModel);\n        assertEquals(value, childModel.getProperty());\n        assertEquals(2, model.getGrandChildren().size());\n        assertEquals(firstGrandChildValue, model.getGrandChildren().get(0).getProperty());\n        assertEquals(secondGrandChildValue, model.getGrandChildren().get(1).getProperty());\n        assertEquals(0, model.getEmptyGrandChildren().size());\n    }","commit_id":"0c2cee7000d7886ed3043a5f35b2e0da4dac9146","url":"https://github.com/apache/sling"},{"original_method":"private static void outputStartDocument(ContentHandler output, String contentType, Long lastModified, QName type, String documentElement) {\n        try {\n            // Create attributes for root element: xsi:type, and optional content-type\n            final AttributesImpl attributes = new AttributesImpl();\n            attributes.addAttribute(XMLConstants.XSI_URI, \"type\", \"xsi:type\", \"CDATA\", type.getQualifiedName());\n            if (contentType != null)\n                attributes.addAttribute(\"\", \"content-type\", \"content-type\", \"CDATA\", contentType);\n            if (lastModified != null)\n                attributes.addAttribute(\"\", \"last-modified\", \"last-modified\", \"CDATA\", ISODateUtils.getRFC1123Date(lastModified.longValue()));\n\n            // Write document\n            output.startDocument();\n            output.startPrefixMapping(XMLConstants.XSI_PREFIX, XMLConstants.XSI_URI);\n            output.startPrefixMapping(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n            output.startElement(\"\", documentElement, documentElement, attributes);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":101955,"modified_method":"private static void outputStartDocument(ContentHandler output, String contentType, Long lastModified, QName type, String documentElement) {\n        try {\n            // Create attributes for root element: xsi:type, and optional content-type\n            final AttributesImpl attributes = new AttributesImpl();\n            attributes.addAttribute(XMLConstants.XSI_URI, \"type\", \"xsi:type\", \"CDATA\", type.getQualifiedName());\n            if (contentType != null)\n                attributes.addAttribute(\"\", \"content-type\", \"content-type\", \"CDATA\", contentType);\n            if (lastModified != null)\n                attributes.addAttribute(\"\", \"last-modified\", \"last-modified\", \"CDATA\", ISODateUtils.getRFC1123Date(lastModified));\n\n            // Write document\n            output.startDocument();\n            output.startPrefixMapping(XMLConstants.XSI_PREFIX, XMLConstants.XSI_URI);\n            output.startPrefixMapping(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n            output.startElement(\"\", documentElement, documentElement, attributes);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"4ea9486f91c1cf445e8b1404c4455efbbd41a171","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Generate a \"standard\" Orbeon binary document.\n     *\n     * @param is            InputStream to read from\n     * @param output        output ContentHandler to write binary document to\n     * @param contentType   optional content type to set as attribute on the root element\n     */\n    public static void readBinary(InputStream is, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            outputStartDocument(output, contentType, lastModified, XMLConstants.XS_BASE64BINARY_QNAME, DEFAULT_BINARY_DOCUMENT_ELEMENT);\n            XMLUtils.inputStreamToBase64Characters(new BufferedInputStream(is), output);\n            outputEndDocument(output, DEFAULT_BINARY_DOCUMENT_ELEMENT);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":101956,"modified_method":"/**\n     * Generate a \"standard\" Orbeon binary document.\n     *\n     * @param is            InputStream to read from\n     * @param output        output ContentHandler to write binary document to\n     * @param contentType   optional content type to set as attribute on the root element\n     * @param lastModified  optional last modified timestamp\n     */\n    public static void readBinary(InputStream is, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            outputStartDocument(output, contentType, lastModified, XMLConstants.XS_BASE64BINARY_QNAME, DEFAULT_BINARY_DOCUMENT_ELEMENT);\n            XMLUtils.inputStreamToBase64Characters(new BufferedInputStream(is), output);\n            outputEndDocument(output, DEFAULT_BINARY_DOCUMENT_ELEMENT);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"4ea9486f91c1cf445e8b1404c4455efbbd41a171","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Generate a \"standard\" Orbeon text document.\n     *\n     * @param text                  String to read from\n     * @param output                output ContentHandler to write text document to\n     * @param contentType           optional content type to set as attribute on the root element\n     */\n    public static void readText(String text, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            outputStartDocument(output, contentType, lastModified, XMLConstants.XS_STRING_QNAME, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n            output.characters(text.toCharArray(), 0, text.length());\n            outputEndDocument(output, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":101957,"modified_method":"/**\n     * Generate a \"standard\" Orbeon text document.\n     *\n     * @param text                  String to read from\n     * @param output                output ContentHandler to write text document to\n     * @param contentType           optional content type to set as attribute on the root element\n     * @param lastModified          optional last modified timestamp\n     */\n    public static void readText(String text, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            outputStartDocument(output, contentType, lastModified, XMLConstants.XS_STRING_QNAME, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n            output.characters(text.toCharArray(), 0, text.length());\n            outputEndDocument(output, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"4ea9486f91c1cf445e8b1404c4455efbbd41a171","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Generate a \"standard\" Orbeon text document.\n     *\n     * @param is                    InputStream to read from\n     * @param encoding              character encoding to use, or null for default\n     * @param output                output ContentHandler to write text document to\n     * @param contentType           optional content type to set as attribute on the root element\n     */\n    public static void readText(InputStream is, String encoding, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            if (encoding == null)\n                encoding = DEFAULT_TEXT_READING_ENCODING;\n            outputStartDocument(output, contentType, lastModified, XMLConstants.XS_STRING_QNAME, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n            XMLUtils.readerToCharacters(new InputStreamReader(is, encoding), output);\n            outputEndDocument(output, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":101958,"modified_method":"/**\n     * Generate a \"standard\" Orbeon text document.\n     *\n     * @param is                    InputStream to read from\n     * @param encoding              character encoding to use, or null for default\n     * @param output                output ContentHandler to write text document to\n     * @param contentType           optional content type to set as attribute on the root element\n     * @param lastModified          optional last modified timestamp\n     */\n    public static void readText(InputStream is, String encoding, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            if (encoding == null)\n                encoding = DEFAULT_TEXT_READING_ENCODING;\n            outputStartDocument(output, contentType, lastModified, XMLConstants.XS_STRING_QNAME, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n            XMLUtils.readerToCharacters(new InputStreamReader(is, encoding), output);\n            outputEndDocument(output, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"4ea9486f91c1cf445e8b1404c4455efbbd41a171","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private static void addNeededNamespaceDeclarations(Element originalElement, Element copyElement, Set<String> alreadyDeclaredPrefixes) {\n        Set<String> newAlreadyDeclaredPrefixes = new HashSet<String>(alreadyDeclaredPrefixes);\n\n        // Add namespaces declared on this element\n        for (Iterator i = copyElement.declaredNamespaces().iterator(); i.hasNext();) {\n            Namespace namespace = (Namespace) i.next();\n            newAlreadyDeclaredPrefixes.add(namespace.getPrefix());\n        }\n\n        // Add element prefix if needed\n        String elementPrefix = copyElement.getNamespace().getPrefix();\n        if (elementPrefix != null && !newAlreadyDeclaredPrefixes.contains(elementPrefix)) {\n            copyElement.addNamespace(elementPrefix, originalElement.getNamespaceForPrefix(elementPrefix).getURI());;\n            newAlreadyDeclaredPrefixes.add(elementPrefix);\n        }\n\n        // Add attribute prefixes if needed\n        for (Iterator i = copyElement.attributes().iterator(); i.hasNext();) {\n            Attribute attribute = (Attribute) i.next();\n            String attributePrefix = attribute.getNamespace().getPrefix();\n            if (attributePrefix != null && !newAlreadyDeclaredPrefixes.contains(attribute.getNamespace().getPrefix())) {\n                copyElement.addNamespace(attributePrefix, originalElement.getNamespaceForPrefix(attributePrefix).getURI());\n                newAlreadyDeclaredPrefixes.add(attributePrefix);\n            }\n        }\n\n        // Get needed namespace declarations for children\n        for (Iterator i = copyElement.elements().iterator(); i.hasNext();) {\n            Element child = (Element) i.next();\n            addNeededNamespaceDeclarations(originalElement, child, newAlreadyDeclaredPrefixes);\n        }\n    }","id":101959,"modified_method":"private static void addNeededNamespaceDeclarations(Element originalElement, Element copyElement, Set<String> alreadyDeclaredPrefixes) {\n        Set<String> newAlreadyDeclaredPrefixes = new HashSet<String>(alreadyDeclaredPrefixes);\n\n        // Add namespaces declared on this element\n        for (Object o: copyElement.declaredNamespaces()) {\n            Namespace namespace = (Namespace) o;\n            newAlreadyDeclaredPrefixes.add(namespace.getPrefix());\n        }\n\n        // Add element prefix if needed\n        String elementPrefix = copyElement.getNamespace().getPrefix();\n        if (elementPrefix != null && !newAlreadyDeclaredPrefixes.contains(elementPrefix)) {\n            copyElement.addNamespace(elementPrefix, originalElement.getNamespaceForPrefix(elementPrefix).getURI());\n            newAlreadyDeclaredPrefixes.add(elementPrefix);\n        }\n\n        // Add attribute prefixes if needed\n        for (Object o: copyElement.attributes()) {\n            Attribute attribute = (Attribute) o;\n            String attributePrefix = attribute.getNamespace().getPrefix();\n            if (attributePrefix != null && !newAlreadyDeclaredPrefixes.contains(attribute.getNamespace().getPrefix())) {\n                copyElement.addNamespace(attributePrefix, originalElement.getNamespaceForPrefix(attributePrefix).getURI());\n                newAlreadyDeclaredPrefixes.add(attributePrefix);\n            }\n        }\n\n        // Get needed namespace declarations for children\n        for (Object o: copyElement.elements()) {\n            Element child = (Element) o;\n            addNeededNamespaceDeclarations(originalElement, child, newAlreadyDeclaredPrefixes);\n        }\n    }","commit_id":"4ea9486f91c1cf445e8b1404c4455efbbd41a171","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static int selectIntValue(Node node, String expr, int defaultValue) {\n        Integer result = XPathUtils.selectIntegerValue(node, expr);\n        return (result == null) ? defaultValue : result.intValue();\n    }","id":101960,"modified_method":"public static int selectIntValue(Node node, String expr, int defaultValue) {\n        Integer result = XPathUtils.selectIntegerValue(node, expr);\n        return (result == null) ? defaultValue : result;\n    }","commit_id":"4ea9486f91c1cf445e8b1404c4455efbbd41a171","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n\tpublic void handleException(Exception e) {\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tif (e instanceof FileNotFoundException) {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tif (syncFile.getVersion() == null) {\n\t\t\t\tSyncFileService.deleteSyncFile(syncFile);\n\t\t\t}\n\t\t}\n\t\telse if ((e instanceof HttpHostConnectException) ||\n\t\t\t\t (e instanceof NoHttpResponseException) ||\n\t\t\t\t (e instanceof SocketException)) {\n\n\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\tretryServerConnection();\n\t\t}\n\t\telse if (e instanceof HttpResponseException) {\n\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\n\t\t\tHttpResponseException hre = (HttpResponseException)e;\n\n\t\t\tint statusCode = hre.getStatusCode();\n\n\t\t\tif (statusCode == HttpStatus.SC_UNAUTHORIZED) {\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_AUTHENTICATION_EXCEPTION);\n\n\t\t\t\tSyncAccountService.update(syncAccount);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\n\t\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\t\tretryServerConnection();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_logger.error(e.getMessage(), e);\n\t\t}\n\t}","id":101961,"modified_method":"@Override\n\tpublic void handleException(Exception e) {\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tif (!RetryUtil.retryInProgress(getSyncAccountId()) &&\n\t\t\t_logger.isDebugEnabled()) {\n\n\t\t\t_logger.debug(\"Handling exception {}\", e.toString());\n\t\t}\n\n\t\tif (e instanceof FileNotFoundException) {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tif (syncFile.getVersion() == null) {\n\t\t\t\tSyncFileService.deleteSyncFile(syncFile);\n\t\t\t}\n\t\t}\n\t\telse if ((e instanceof HttpHostConnectException) ||\n\t\t\t\t (e instanceof NoHttpResponseException) ||\n\t\t\t\t (e instanceof SocketException) ||\n\t\t\t\t (e instanceof UnknownHostException)) {\n\n\t\t\tretryServerConnection(SyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t}\n\t\telse if (e instanceof HttpResponseException) {\n\t\t\tHttpResponseException hre = (HttpResponseException)e;\n\n\t\t\tint statusCode = hre.getStatusCode();\n\n\t\t\tif (statusCode == HttpStatus.SC_UNAUTHORIZED) {\n\t\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\t\t\t\tsyncAccount.setUiEvent(\n\t\t\t\t\tSyncAccount.UI_EVENT_AUTHENTICATION_EXCEPTION);\n\n\t\t\t\tSyncAccountService.update(syncAccount);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tretryServerConnection(\n\t\t\t\t\tSyncAccount.UI_EVENT_CONNECTION_EXCEPTION);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_logger.error(e.getMessage(), e);\n\t\t}\n\t}","commit_id":"419858e78ca070498e84508b18fa0f2df04fc221","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void retryServerConnection() {\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tSyncAccountService.synchronizeSyncAccount(\n\t\t\tgetSyncAccountId(),\n\t\t\tRetryUtil.incrementRetryDelay(getSyncAccountId()));\n\n\t\tif (_logger.isDebugEnabled()) {\n\t\t\t_logger.debug(\n\t\t\t\t\"Attempting to reconnect to {}. Retry #{}.\",\n\t\t\t\tsyncAccount.getUrl(),\n\t\t\t\tRetryUtil.getRetryCount(getSyncAccountId()));\n\t\t}\n\t}","id":101962,"modified_method":"protected void retryServerConnection(int uiEvent) {\n\t\tif (!(_event instanceof GetSyncContextEvent) &&\n\t\t\tRetryUtil.retryInProgress(getSyncAccountId())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\t\tsyncAccount.setUiEvent(uiEvent);\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tSyncAccountService.synchronizeSyncAccount(\n\t\t\tgetSyncAccountId(),\n\t\t\tRetryUtil.incrementRetryDelay(getSyncAccountId()));\n\n\t\tif (_logger.isDebugEnabled()) {\n\t\t\t_logger.debug(\n\t\t\t\t\"Attempting to reconnect to {}. Retry #{}.\",\n\t\t\t\tsyncAccount.getUrl(),\n\t\t\t\tRetryUtil.getRetryCount(getSyncAccountId()));\n\t\t}\n\t}","commit_id":"419858e78ca070498e84508b18fa0f2df04fc221","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean handlePortalException(String exception) throws Exception {\n\t\tif (exception.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (_logger.isDebugEnabled()) {\n\t\t\t_logger.debug(\"Handling exception {}\", exception);\n\t\t}\n\n\t\tif (exception.equals(\"com.liferay.portal.DuplicateLockException\")) {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DUPLICATE_LOCK);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portal.kernel.upload.UploadException\") ||\n\t\t\t\t exception.contains(\"SizeLimitExceededException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_EXCEEDED_SIZE_LIMIT);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portal.security.auth.PrincipalException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_INVALID_PERMISSIONS);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portlet.documentlibrary.FileNameException\") ||\n\t\t\t\t exception.equals(\n\t\t\t\t\t\"com.liferay.portlet.documentlibrary.\" +\n\t\t\t\t\t\t\"FolderNameException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_INVALID_FILE_NAME);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portlet.documentlibrary.\" +\n\t\t\t\t\t\t\"NoSuchFileEntryException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\t\tFiles.deleteIfExists(filePath);\n\n\t\t\tSyncFileService.deleteSyncFile(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.sync.SyncServicesUnavailableException\")) {\n\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\tgetSyncAccountId());\n\n\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\t\t\tsyncAccount.setUiEvent(\n\t\t\t\tSyncAccount.UI_EVENT_SYNC_SERVICES_NOT_ACTIVE);\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\tretryServerConnection();\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portal.kernel.jsonwebservice.\" +\n\t\t\t\t\t\t\"NoSuchJSONWebServiceException\") ||\n\t\t\t\t exception.equals(\"java.lang.RuntimeException\")) {\n\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\tgetSyncAccountId());\n\n\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_SYNC_WEB_MISSING);\n\n\t\t\tSyncAccountService.update(syncAccount);\n\n\t\t\tretryServerConnection();\n\t\t}\n\t\telse if (exception.equals(\"Authenticated access required\") ||\n\t\t\t\t exception.equals(\"java.lang.SecurityException\")) {\n\n\t\t\tthrow new HttpResponseException(\n\t\t\t\tHttpStatus.SC_UNAUTHORIZED, \"Authenticated access required\");\n\t\t}\n\t\telse {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DEFAULT);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\n\t\treturn true;\n\t}","id":101963,"modified_method":"protected boolean handlePortalException(String exception) throws Exception {\n\t\tif (exception.equals(\"\")) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!RetryUtil.retryInProgress(getSyncAccountId()) &&\n\t\t\t_logger.isDebugEnabled()) {\n\n\t\t\t_logger.debug(\"Handling exception {}\", exception);\n\t\t}\n\n\t\tif (exception.equals(\"com.liferay.portal.DuplicateLockException\")) {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DUPLICATE_LOCK);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portal.kernel.upload.UploadException\") ||\n\t\t\t\t exception.contains(\"SizeLimitExceededException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_EXCEEDED_SIZE_LIMIT);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portal.security.auth.PrincipalException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_INVALID_PERMISSIONS);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portlet.documentlibrary.FileNameException\") ||\n\t\t\t\t exception.equals(\n\t\t\t\t\t\"com.liferay.portlet.documentlibrary.\" +\n\t\t\t\t\t\t\"FolderNameException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_INVALID_FILE_NAME);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portlet.documentlibrary.\" +\n\t\t\t\t\t\t\"NoSuchFileEntryException\")) {\n\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\t\tFiles.deleteIfExists(filePath);\n\n\t\t\tSyncFileService.deleteSyncFile(syncFile);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.sync.SyncServicesUnavailableException\")) {\n\n\t\t\tretryServerConnection(\n\t\t\t\tSyncAccount.UI_EVENT_SYNC_SERVICES_NOT_ACTIVE);\n\t\t}\n\t\telse if (exception.equals(\n\t\t\t\t\t\"com.liferay.portal.kernel.jsonwebservice.\" +\n\t\t\t\t\t\t\"NoSuchJSONWebServiceException\") ||\n\t\t\t\t exception.equals(\"java.lang.RuntimeException\")) {\n\n\t\t\tretryServerConnection(SyncAccount.UI_EVENT_SYNC_WEB_MISSING);\n\t\t}\n\t\telse if (exception.equals(\"Authenticated access required\") ||\n\t\t\t\t exception.equals(\"java.lang.SecurityException\")) {\n\n\t\t\tthrow new HttpResponseException(\n\t\t\t\tHttpStatus.SC_UNAUTHORIZED, \"Authenticated access required\");\n\t\t}\n\t\telse {\n\t\t\tSyncFile syncFile = (SyncFile)getParameterValue(\"syncFile\");\n\n\t\t\tsyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DEFAULT);\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"419858e78ca070498e84508b18fa0f2df04fc221","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void processResponse(String response) throws Exception {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\n\t\tSyncContext syncContext = objectMapper.readValue(\n\t\t\tresponse, new TypeReference<SyncContext>() {});\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tMap<String, String> portletPreferencesMap =\n\t\t\tsyncContext.getPortletPreferencesMap();\n\n\t\tint maxConnections = Integer.parseInt(\n\t\t\tportletPreferencesMap.get(\n\t\t\t\tSyncContext.PREFERENCE_KEY_MAX_CONNECTIONS));\n\n\t\tsyncAccount.setMaxConnections(maxConnections);\n\n\t\tint pollInterval = Integer.parseInt(\n\t\t\tportletPreferencesMap.get(\n\t\t\t\tSyncContext.PREFERENCE_KEY_POLL_INTERVAL));\n\n\t\tsyncAccount.setPollInterval(pollInterval);\n\n\t\tsyncAccount.setSocialOfficeInstalled(\n\t\t\tsyncContext.isSocialOfficeInstalled());\n\n\t\tif (ReleaseInfo.isServerCompatible(syncContext)) {\n\t\t\tsyncAccount.setState(SyncAccount.STATE_CONNECTED);\n\n\t\t\tFileEventUtil.retryFileTransfers(getSyncAccountId());\n\n\t\t\tRetryUtil.resetRetryDelay(getSyncAccountId());\n\t\t}\n\t\telse {\n\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_SYNC_WEB_OUT_OF_DATE);\n\t\t}\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tSyncUser remoteSyncUser = syncContext.getSyncUser();\n\n\t\tSyncUser localSyncUser = SyncUserService.fetchSyncUser(\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tremoteSyncUser.setSyncAccountId(localSyncUser.getSyncAccountId());\n\t\tremoteSyncUser.setSyncUserId(localSyncUser.getSyncUserId());\n\n\t\tSyncUserService.update(remoteSyncUser);\n\t}","id":101964,"modified_method":"@Override\n\tprotected void processResponse(String response) throws Exception {\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\n\t\tSyncContext syncContext = objectMapper.readValue(\n\t\t\tresponse, new TypeReference<SyncContext>() {});\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tgetSyncAccountId());\n\n\t\tMap<String, String> portletPreferencesMap =\n\t\t\tsyncContext.getPortletPreferencesMap();\n\n\t\tint maxConnections = Integer.parseInt(\n\t\t\tportletPreferencesMap.get(\n\t\t\t\tSyncContext.PREFERENCE_KEY_MAX_CONNECTIONS));\n\n\t\tsyncAccount.setMaxConnections(maxConnections);\n\n\t\tint pollInterval = Integer.parseInt(\n\t\t\tportletPreferencesMap.get(\n\t\t\t\tSyncContext.PREFERENCE_KEY_POLL_INTERVAL));\n\n\t\tsyncAccount.setPollInterval(pollInterval);\n\n\t\tsyncAccount.setSocialOfficeInstalled(\n\t\t\tsyncContext.isSocialOfficeInstalled());\n\n\t\tif (ReleaseInfo.isServerCompatible(syncContext)) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\"Connected to {}\", syncAccount.getUrl());\n\t\t\t}\n\n\t\t\tsyncAccount.setState(SyncAccount.STATE_CONNECTED);\n\n\t\t\tFileEventUtil.retryFileTransfers(getSyncAccountId());\n\n\t\t\tRetryUtil.resetRetryDelay(getSyncAccountId());\n\t\t}\n\t\telse {\n\t\t\tsyncAccount.setState(SyncAccount.STATE_DISCONNECTED);\n\t\t\tsyncAccount.setUiEvent(SyncAccount.UI_EVENT_SYNC_WEB_OUT_OF_DATE);\n\t\t}\n\n\t\tSyncAccountService.update(syncAccount);\n\n\t\tSyncUser remoteSyncUser = syncContext.getSyncUser();\n\n\t\tSyncUser localSyncUser = SyncUserService.fetchSyncUser(\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tremoteSyncUser.setSyncAccountId(localSyncUser.getSyncAccountId());\n\t\tremoteSyncUser.setSyncUserId(localSyncUser.getSyncUserId());\n\n\t\tSyncUserService.update(remoteSyncUser);\n\t}","commit_id":"419858e78ca070498e84508b18fa0f2df04fc221","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static int getRetryCount(long syncAccountId) {\n\t\treturn _counts.get(syncAccountId);\n\t}","id":101965,"modified_method":"public static int getRetryCount(long syncAccountId) {\n\t\tif (_counts.containsKey(syncAccountId)) {\n\t\t\treturn _counts.get(syncAccountId);\n\t\t}\n\n\t\treturn 0;\n\t}","commit_id":"419858e78ca070498e84508b18fa0f2df04fc221","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static long incrementRetryDelay(long syncAccountId) {\n\t\tint count = 0;\n\n\t\tif (_counts.containsKey(syncAccountId)) {\n\t\t\tcount = _counts.get(syncAccountId);\n\t\t}\n\n\t\tcount++;\n\n\t\t_counts.put(syncAccountId, count);\n\n\t\tLong delay = _delays.get(syncAccountId);\n\n\t\tif (delay == null) {\n\t\t\t_delays.put(syncAccountId, _INITIAL_INTERVAL);\n\n\t\t\treturn _INITIAL_INTERVAL;\n\t\t}\n\t\telse if (delay == _MAX_INTERVAL) {\n\t\t\treturn delay;\n\t\t}\n\n\t\tdelay = (long)(delay * _MULTIPLIER);\n\n\t\tif (delay > _MAX_INTERVAL) {\n\t\t\tdelay = _MAX_INTERVAL;\n\t\t}\n\n\t\t_delays.put(syncAccountId, delay);\n\n\t\treturn delay;\n\t}","id":101966,"modified_method":"public static long incrementRetryDelay(long syncAccountId) {\n\t\tint count = getRetryCount(syncAccountId);\n\n\t\tcount++;\n\n\t\t_counts.put(syncAccountId, count);\n\n\t\tLong delay = _delays.get(syncAccountId);\n\n\t\tif (delay == null) {\n\t\t\t_delays.put(syncAccountId, _INITIAL_INTERVAL);\n\n\t\t\treturn _INITIAL_INTERVAL;\n\t\t}\n\t\telse if (delay == _MAX_INTERVAL) {\n\t\t\treturn delay;\n\t\t}\n\n\t\tdelay = (long)(delay * _MULTIPLIER);\n\n\t\tif (delay > _MAX_INTERVAL) {\n\t\t\tdelay = _MAX_INTERVAL;\n\t\t}\n\n\t\t_delays.put(syncAccountId, delay);\n\n\t\treturn delay;\n\t}","commit_id":"419858e78ca070498e84508b18fa0f2df04fc221","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void doScheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tif (!_running) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncWatchEventService.deleteSyncWatchEvents(syncAccountId);\n\n\t\tSyncAccount syncAccount = SyncAccountService.synchronizeSyncAccount(\n\t\t\tsyncAccountId, 0);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncSiteService.synchronizeSyncSites(syncAccountId);\n\t\t}\n\n\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tSyncWatchEventProcessor syncWatchEventProcessor =\n\t\t\tnew SyncWatchEventProcessor(syncAccountId);\n\n\t\t_syncWatchEventProcessorExecutorService.scheduleAtFixedRate(\n\t\t\tsyncWatchEventProcessor, 0, 3, TimeUnit.SECONDS);\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccountId);\n\n\t\tsynchronizeSyncFiles(filePath, syncAccountId, watchEventListener);\n\n\t\tWatcher watcher = new Watcher(filePath, true, watchEventListener);\n\n\t\t_executorService.execute(watcher);\n\n\t\tscheduleGetSyncDLObjectUpdateEvent(\n\t\t\tsyncAccount, syncWatchEventProcessor, watcher);\n\t}","id":101967,"modified_method":"protected static void doScheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tif (!_running) {\n\t\t\treturn;\n\t\t}\n\n\t\tSyncWatchEventService.deleteSyncWatchEvents(syncAccountId);\n\n\t\tSyncAccount syncAccount = SyncAccountService.synchronizeSyncAccount(\n\t\t\tsyncAccountId, 0);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncSiteService.synchronizeSyncSites(syncAccountId);\n\t\t}\n\n\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tSyncWatchEventProcessor syncWatchEventProcessor =\n\t\t\tnew SyncWatchEventProcessor(syncAccountId);\n\n\t\t_syncWatchEventProcessorExecutorService.scheduleAtFixedRate(\n\t\t\tsyncWatchEventProcessor, 0, 3, TimeUnit.SECONDS);\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccountId);\n\n\t\tfireDeleteEvents(filePath, watchEventListener);\n\n\t\tWatcher watcher = new Watcher(filePath, true, watchEventListener);\n\n\t\t_executorService.execute(watcher);\n\n\t\tscheduleGetSyncDLObjectUpdateEvent(\n\t\t\tsyncAccount, syncWatchEventProcessor, watcher);\n\t}","commit_id":"419858e78ca070498e84508b18fa0f2df04fc221","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void transformIfToWhen(@NotNull JetIfExpression ifExpression) {\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder();\n\n        JetIfExpression currIfExpression = ifExpression;\n        do {\n            JetExpression condition = currIfExpression.getCondition();\n            JetExpression thenBranch = currIfExpression.getThen();\n            JetExpression elseBranch = currIfExpression.getElse();\n\n            assertNotNull(thenBranch);\n            assertNotNull(elseBranch);\n\n            List<JetExpression> orBranches = splitExpressionToOrBranches(condition);\n\n            if (orBranches.isEmpty()) {\n                builder.condition(\"\");\n            } else {\n                for (JetExpression orBranch : orBranches) {\n                    builder.condition(orBranch);\n                }\n            }\n\n            //noinspection ConstantConditions\n            builder.branchExpression(thenBranch);\n\n            if (elseBranch instanceof JetIfExpression) {\n                currIfExpression = (JetIfExpression) elseBranch;\n            }\n            else {\n                currIfExpression = null;\n                //noinspection ConstantConditions\n                builder.elseEntry(elseBranch);\n            }\n        } while (currIfExpression != null);\n\n        ifExpression.replace(builder.toExpression(ifExpression.getProject()));\n    }","id":101968,"modified_method":"public static void transformIfToWhen(@NotNull JetIfExpression ifExpression) {\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder();\n\n        JetIfExpression currIfExpression = ifExpression;\n        do {\n            JetExpression condition = currIfExpression.getCondition();\n            JetExpression thenBranch = currIfExpression.getThen();\n            JetExpression elseBranch = currIfExpression.getElse();\n\n            assertNotNull(thenBranch);\n            assertNotNull(elseBranch);\n\n            List<JetExpression> orBranches = splitExpressionToOrBranches(condition);\n\n            if (orBranches.isEmpty()) {\n                builder.condition(\"\");\n            } else {\n                for (JetExpression orBranch : orBranches) {\n                    builder.condition(orBranch);\n                }\n            }\n\n            //noinspection ConstantConditions\n            builder.branchExpression(thenBranch);\n\n            if (elseBranch instanceof JetIfExpression) {\n                currIfExpression = (JetIfExpression) elseBranch;\n            }\n            else {\n                currIfExpression = null;\n                //noinspection ConstantConditions\n                builder.elseEntry(elseBranch);\n            }\n        } while (currIfExpression != null);\n\n        JetWhenExpression whenExpression = builder.toExpression(ifExpression.getProject());\n        if (WhenUtils.checkIntroduceWhenSubject(whenExpression)) {\n            whenExpression = WhenUtils.introduceWhenSubject(whenExpression);\n        }\n\n        ifExpression.replace(whenExpression);\n    }","commit_id":"158c2753b8891b25ede0be4925ea456555f4944d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void flattenWhen(@NotNull JetWhenExpression whenExpression) {\n        JetExpression subjectExpression = whenExpression.getSubjectExpression();\n\n        JetExpression elseBranch = whenExpression.getElseExpression();\n        assert elseBranch instanceof JetWhenExpression : TRANSFORM_WITHOUT_CHECK;\n\n        JetWhenExpression nestedWhenExpression = (JetWhenExpression) elseBranch;\n\n        List<JetWhenEntry> outerEntries = whenExpression.getEntries();\n        List<JetWhenEntry> innerEntries = nestedWhenExpression.getEntries();\n\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder(subjectExpression);\n\n        for (JetWhenEntry entry : outerEntries) {\n            if (entry.isElse()) continue;\n\n            builder.entry(entry);\n        }\n\n        for (JetWhenEntry entry : innerEntries) {\n            builder.entry(entry);\n        }\n\n        whenExpression.replace(builder.toExpression(whenExpression.getProject()));\n    }","id":101969,"modified_method":"@NotNull\n    public static JetWhenExpression flattenWhen(@NotNull JetWhenExpression whenExpression) {\n        JetExpression subjectExpression = whenExpression.getSubjectExpression();\n\n        JetExpression elseBranch = whenExpression.getElseExpression();\n        assert elseBranch instanceof JetWhenExpression : TRANSFORM_WITHOUT_CHECK;\n\n        JetWhenExpression nestedWhenExpression = (JetWhenExpression) elseBranch;\n\n        List<JetWhenEntry> outerEntries = whenExpression.getEntries();\n        List<JetWhenEntry> innerEntries = nestedWhenExpression.getEntries();\n\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder(subjectExpression);\n\n        for (JetWhenEntry entry : outerEntries) {\n            if (entry.isElse()) continue;\n\n            builder.entry(entry);\n        }\n\n        for (JetWhenEntry entry : innerEntries) {\n            builder.entry(entry);\n        }\n\n        JetWhenExpression newWhenExpression = builder.toExpression(whenExpression.getProject());\n        whenExpression.replace(newWhenExpression);\n\n        return newWhenExpression;\n    }","commit_id":"158c2753b8891b25ede0be4925ea456555f4944d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void eliminateWhenSubject(@NotNull JetWhenExpression whenExpression) {\n        JetExpression subject = whenExpression.getSubjectExpression();\n        assertNotNull(subject);\n\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder();\n\n        for (JetWhenEntry entry : whenExpression.getEntries()) {\n            JetExpression branchExpression = entry.getExpression();\n\n            if (entry.isElse()) {\n                builder.elseEntry(branchExpression);\n\n                continue;\n            }\n\n            for (JetWhenCondition condition : entry.getConditions()) {\n                builder.condition(whenConditionToExpressionText(condition, subject));\n            }\n\n            builder.branchExpression(branchExpression);\n        }\n\n        whenExpression.replace(builder.toExpression(whenExpression.getProject()));\n    }","id":101970,"modified_method":"@NotNull\n    public static JetWhenExpression eliminateWhenSubject(@NotNull JetWhenExpression whenExpression) {\n        JetExpression subject = whenExpression.getSubjectExpression();\n        assertNotNull(subject);\n\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder();\n\n        for (JetWhenEntry entry : whenExpression.getEntries()) {\n            JetExpression branchExpression = entry.getExpression();\n\n            if (entry.isElse()) {\n                builder.elseEntry(branchExpression);\n\n                continue;\n            }\n\n            for (JetWhenCondition condition : entry.getConditions()) {\n                builder.condition(whenConditionToExpressionText(condition, subject));\n            }\n\n            builder.branchExpression(branchExpression);\n        }\n\n        JetWhenExpression newWhenExpression = builder.toExpression(whenExpression.getProject());\n        whenExpression.replace(newWhenExpression);\n\n        return newWhenExpression;\n    }","commit_id":"158c2753b8891b25ede0be4925ea456555f4944d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void introduceWhenSubject(@NotNull JetWhenExpression whenExpression) {\n        JetExpression subject = getWhenSubjectCandidate(whenExpression);\n        assertNotNull(subject);\n\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder(subject);\n\n        for (JetWhenEntry entry : whenExpression.getEntries()) {\n            JetExpression branchExpression = entry.getExpression();\n\n            if (entry.isElse()) {\n                builder.elseEntry(branchExpression);\n                continue;\n            }\n\n            for (JetWhenCondition condition : entry.getConditions()) {\n                assert condition instanceof JetWhenConditionWithExpression : TRANSFORM_WITHOUT_CHECK;\n\n                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();\n\n                if (conditionExpression instanceof JetIsExpression) {\n                    JetIsExpression isExpression = (JetIsExpression) conditionExpression;\n                    builder.pattern(isExpression.getTypeRef(), isExpression.isNegated());\n                }\n                else if (conditionExpression instanceof JetBinaryExpression) {\n                    JetBinaryExpression binaryExpression = (JetBinaryExpression) conditionExpression;\n\n                    JetExpression rhs = binaryExpression.getRight();\n\n                    IElementType op = binaryExpression.getOperationToken();\n                    if (op == JetTokens.IN_KEYWORD) {\n                        builder.range(rhs, false);\n                    }\n                    else if (op == JetTokens.NOT_IN) {\n                        builder.range(rhs, true);\n                    }\n                    else if (op == JetTokens.EQEQ) {\n                        builder.condition(rhs);\n                    }\n                    else assert false : TRANSFORM_WITHOUT_CHECK;\n                }\n                else assert false : TRANSFORM_WITHOUT_CHECK;\n            }\n\n            builder.branchExpression(branchExpression);\n        }\n\n        whenExpression.replace(builder.toExpression(whenExpression.getProject()));\n    }","id":101971,"modified_method":"@NotNull\n    public static JetWhenExpression introduceWhenSubject(@NotNull JetWhenExpression whenExpression) {\n        JetExpression subject = getWhenSubjectCandidate(whenExpression);\n        assertNotNull(subject);\n\n        JetPsiFactory.WhenBuilder builder = new JetPsiFactory.WhenBuilder(subject);\n\n        for (JetWhenEntry entry : whenExpression.getEntries()) {\n            JetExpression branchExpression = entry.getExpression();\n\n            if (entry.isElse()) {\n                builder.elseEntry(branchExpression);\n                continue;\n            }\n\n            for (JetWhenCondition condition : entry.getConditions()) {\n                assert condition instanceof JetWhenConditionWithExpression : TRANSFORM_WITHOUT_CHECK;\n\n                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();\n\n                if (conditionExpression instanceof JetIsExpression) {\n                    JetIsExpression isExpression = (JetIsExpression) conditionExpression;\n                    builder.pattern(isExpression.getTypeRef(), isExpression.isNegated());\n                }\n                else if (conditionExpression instanceof JetBinaryExpression) {\n                    JetBinaryExpression binaryExpression = (JetBinaryExpression) conditionExpression;\n\n                    JetExpression rhs = binaryExpression.getRight();\n\n                    IElementType op = binaryExpression.getOperationToken();\n                    if (op == JetTokens.IN_KEYWORD) {\n                        builder.range(rhs, false);\n                    }\n                    else if (op == JetTokens.NOT_IN) {\n                        builder.range(rhs, true);\n                    }\n                    else if (op == JetTokens.EQEQ) {\n                        builder.condition(rhs);\n                    }\n                    else assert false : TRANSFORM_WITHOUT_CHECK;\n                }\n                else assert false : TRANSFORM_WITHOUT_CHECK;\n            }\n\n            builder.branchExpression(branchExpression);\n        }\n\n        JetWhenExpression newWhenExpression = builder.toExpression(whenExpression.getProject());\n        whenExpression.replace(newWhenExpression);\n\n        return newWhenExpression;\n    }","commit_id":"158c2753b8891b25ede0be4925ea456555f4944d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Date parseISO8601(final String s) throws ParseException {\n        if(s == null)\n        \tthrow new ParseException(\"parseISO8601 - NPE\", 0);\n    \tStringBuilder date = new StringBuilder(s);\n    \tSimpleDateFormat dateformat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssz\"); \n        if(date.charAt(date.length()) == 'Z') {\n        \tdate.deleteCharAt(date.length());\n        \tdate.append(\"GMT-00:00\");\n        } else {\n            date.insert(date.length()-6, \"GMT\");\n        }\n        Log.logInfo(YMarkTables.BOOKMARKS_LOG, \"ISO8601: \"+s+\" =? \"+dateformat.toString());\n        return dateformat.parse(date.toString());\n    }","id":101972,"modified_method":"public static Date parseISO8601(final String s) throws ParseException {\n    \tStringBuilder date = new StringBuilder(s);\n    \tSimpleDateFormat dateformat;\n    \tif(s == null || s.isEmpty()) { \n    \t\tthrow new ParseException(\"parseISO8601 - empty string, nothing to parse\", 0);\n    \t}\n    \tif(s.length()==10)\n    \t\tdateformat = new SimpleDateFormat(\"yyyy-MM-dd\");\n    \telse {\n    \t\tdateformat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssz\"); \n\t        if(date.charAt(date.length()-1) == 'Z') {\n\t        \tdate.deleteCharAt(date.length()-1);\n\t        \tdate.append(\"GMT-00:00\");\n\t        } else {\n\t            date.insert(date.length()-6, \"GMT\");\n\t        }\n    \t}\n        return dateformat.parse(date.toString());\n    }","commit_id":"25339f93c77c9c14fd37272afc5db873e80e4770","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void run() {\n        try {\n            this.saxParser.parse(this.input, this);\n        } catch (SAXParseException e) {\n            Log.logException(e);\n        } catch (SAXException e) {\n            Log.logException(e);\n        } catch (IOException e) {\n            Log.logException(e);\n        } finally {\n        \ttry {\n\t\t\t\tthis.bookmarks.put(YMarkTables.POISON);\n\t\t\t} catch (InterruptedException e1) {\n\t\t\t    Log.logException(e1);\n\t\t\t}\n\t\t\ttry {\n        \t\tthis.input.close();\n\t\t\t} catch (IOException e) {\n\t\t\t    Log.logException(e);\n\t\t\t}\n        }\n    }","id":101973,"modified_method":"public void run() {\n    \ttry {\n        \tthis.xmlReader.parse(this.input);\n        } catch (SAXParseException e) {\n            Log.logException(e);\t\n        } catch (SAXException e) {\n            Log.logException(e);\n        } catch (IOException e) {\n            Log.logException(e);\n        } finally {\n        \ttry {\n\t\t\t\tthis.bookmarks.put(YMarkTables.POISON);\n\t\t\t} catch (InterruptedException e1) {\n\t\t\t    Log.logException(e1);\n\t\t\t}\n        }\n    }","commit_id":"25339f93c77c9c14fd37272afc5db873e80e4770","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public YMarksXBELImporter (final InputStream input, int queueSize) throws SAXException {\n        this.bmk = null;\n    \tthis.buffer = new StringBuilder();\n        this.folder = new StringBuilder(YMarkTables.FOLDER_BUFFER_SIZE);\n        this.folder.append(YMarkTables.FOLDERS_IMPORTED);\n        this.bookmarks = new ArrayBlockingQueue<HashMap<String,String>>(queueSize);\n        this.input = input;\n        final SAXParserFactory factory = SAXParserFactory.newInstance();\n        try {\n            this.saxParser = factory.newSAXParser();\n        } catch (ParserConfigurationException e) {\n            Log.logException(e);\n            throw new SAXException (e.getMessage());\n        }\n    }","id":101974,"modified_method":"public YMarksXBELImporter (final InputStream input, int queueSize) throws SAXException {\n        this.bmk = \t\t\t\tnull;\n    \tthis.buffer = \t\t\tnew StringBuilder();\n    \tthis.foldersString = \tnew StringBuilder(YMarkTables.FOLDER_BUFFER_SIZE);\n    \tthis.folder = \t\t\tnew StringBuilder(YMarkTables.FOLDER_BUFFER_SIZE);\n        this.folder.append(YMarkTables.FOLDERS_IMPORTED);\n    \tthis.bmkRef = \t\t\tnew HashMap<String,HashMap<String,String>>();\n    \tthis.aliasRef = \t\tnew HashSet<HashMap<String,String>>();\n        this.bookmarks = \t\tnew ArrayBlockingQueue<HashMap<String,String>>(queueSize);\n        this.input = \t\t\tnew InputSource(input);\n        this.xmlReader = \t\tXMLReaderFactory.createXMLReader();\n        this.xmlReader.setContentHandler(this);\n        this.xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n        this.xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n        this.xmlReader.setFeature(\"http://xml.org/sax/features/validation\", false);\n    }","commit_id":"25339f93c77c9c14fd37272afc5db873e80e4770","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void startElement(final String uri, final String name, String tag, final Attributes atts) throws SAXException {\n        String date;\n    \tif (tag == null) return;\n        tag = tag.toLowerCase();              \n        if (XBEL.BOOKMARK.tag().equals(tag)) {\n            this.bmk = new HashMap<String,String>();\n            this.bmk.put(YMarkTables.BOOKMARK.URL.key(), atts.getValue(uri, YMarkTables.BOOKMARK.URL.xbel_attrb()));\n            try {\n\t\t\t\tdate = String.valueOf(YMarkTables.parseISO8601(atts.getValue(uri, YMarkTables.BOOKMARK.DATE_ADDED.xbel_attrb())));\n\t\t\t} catch (ParseException e) {\n\t\t\t\tdate = String.valueOf(System.currentTimeMillis());\n\t\t\t}\n            this.bmk.put(YMarkTables.BOOKMARK.DATE_ADDED.key(), date);\n            try {\n\t\t\t\tdate = String.valueOf(YMarkTables.parseISO8601(atts.getValue(uri, YMarkTables.BOOKMARK.DATE_VISITED.xbel_attrb())));\n\t            this.bmk.put(YMarkTables.BOOKMARK.DATE_VISITED.key(), date);\n            } catch (ParseException e) {\n\t\t\t}\n            try {\n\t\t\t\tdate = String.valueOf(YMarkTables.parseISO8601(atts.getValue(uri, YMarkTables.BOOKMARK.DATE_MODIFIED.xbel_attrb())));\n\t\t\t} catch (ParseException e) {\n\t\t\t\tdate = String.valueOf(System.currentTimeMillis());\n\t\t\t}\n            this.bmk.put(YMarkTables.BOOKMARK.DATE_MODIFIED.key(), date);\n            outer_state = XBEL.BOOKMARK;\n            inner_state = XBEL.NOTHING;\n            this.parse_value = false;            \n        } else if(XBEL.FOLDER.tag().equals(tag)) {\n        \tthis.outer_state = XBEL.FOLDER;\n        \tthis.inner_state = XBEL.NOTHING;\n        } else if (XBEL.DESC.tag().equals(tag)) {\n            this.inner_state = XBEL.DESC;\n        \tthis.parse_value = true;\n        } else if (XBEL.TITLE.tag().equals(tag)) {\n        \tthis.inner_state = XBEL.TITLE;\n        \tthis.parse_value = true;\n        } else if (XBEL.INFO.tag().equals(tag)) {\n        \tthis.inner_state = XBEL.INFO;\n        \tthis.parse_value = false;\n        } else if (XBEL.METADATA.tag().equals(tag)) {\n        \t/*\n        \tthis.meta_owner = atts.getValue(uri, \"owner\");\n        \tthis.inner_state = XBEL.METADATA;\n        \tthis.parse_value = true;\n        \t*/\n        } else if (XBEL.ALIAS.tag().equals(tag)) {\n        \t// TODO: handle xbel aliases\n        \t/*\n        \tthis.alias_ref = atts.getValue(uri, \"ref\");\n        \tthis.inner_state = XBEL.ALIAS;\n        \tthis.parse_value = false;\n        \t*/\n        }\n        else {\n        \tthis.outer_state = XBEL.NOTHING;\n        \tthis.inner_state = XBEL.NOTHING;\n        \tthis.parse_value = false;\n        }\n        \n    }","id":101975,"modified_method":"public void startElement(final String uri, final String name, String tag, final Attributes atts) throws SAXException {\n        String date;\n        if (tag == null) return;\n        tag = tag.toLowerCase();              \n        if (XBEL.BOOKMARK.tag().equals(tag)) {\n            this.bmk = new HashMap<String,String>();            \n            this.bmk.put(YMarkTables.BOOKMARK.URL.key(), atts.getValue(uri, YMarkTables.BOOKMARK.URL.xbel_attrb()));\n            try {\n\t\t\t\tdate = String.valueOf(YMarkTables.parseISO8601(atts.getValue(uri, YMarkTables.BOOKMARK.DATE_ADDED.xbel_attrb())).getTime());\n\t\t\t} catch (ParseException e) {\n\t\t\t\tdate = String.valueOf(System.currentTimeMillis());\n\t\t\t}\n            this.bmk.put(YMarkTables.BOOKMARK.DATE_ADDED.key(), date);\n            try {\n\t\t\t\tdate = String.valueOf(YMarkTables.parseISO8601(atts.getValue(uri, YMarkTables.BOOKMARK.DATE_VISITED.xbel_attrb())).getTime());\n            } catch (ParseException e) {\n            \tdate = YMarkTables.BOOKMARK.DATE_VISITED.deflt();\n            }\n            this.bmk.put(YMarkTables.BOOKMARK.DATE_VISITED.key(), date);\n            try {\n\t\t\t\tdate = String.valueOf(YMarkTables.parseISO8601(atts.getValue(uri, YMarkTables.BOOKMARK.DATE_MODIFIED.xbel_attrb())).getTime());\n\t\t\t} catch (ParseException e) {\n\t\t\t\tdate = String.valueOf(System.currentTimeMillis());\n\t\t\t}\n            this.bmk.put(YMarkTables.BOOKMARK.DATE_MODIFIED.key(), date);\n            \n            UpdateBmkRef(atts.getValue(uri, \"id\"), true);\n            outer_state = XBEL.BOOKMARK;\n            inner_state = XBEL.NOTHING;\n            this.parse_value = false;            \n        } else if(XBEL.FOLDER.tag().equals(tag)) {\n        \tthis.outer_state = XBEL.FOLDER;\n        \tthis.inner_state = XBEL.NOTHING;\n        } else if (XBEL.DESC.tag().equals(tag)) {\n            this.inner_state = XBEL.DESC;\n        \tthis.parse_value = true;\n        } else if (XBEL.TITLE.tag().equals(tag)) {\n        \tthis.inner_state = XBEL.TITLE;\n        \tthis.parse_value = true;\n        } else if (XBEL.INFO.tag().equals(tag)) {\n        \tthis.inner_state = XBEL.INFO;\n        \tthis.parse_value = false;\n        } else if (XBEL.METADATA.tag().equals(tag)) {\n        \t/*\n        \tatts.getValue(uri, \"owner\");\n        \t*/\n        } else if (XBEL.ALIAS.tag().equals(tag)) {\n        \tLog.logInfo(YMarkTables.BOOKMARKS_LOG, \"ALIAS: \"+this.ref.get(YMarkTables.BOOKMARK.URL.key()));\n        \tfinal String r = atts.getValue(uri, \"ref\");\n        \tUpdateBmkRef(r, false);\n        \tthis.aliasRef.add(this.bmkRef.get(r));\n        }\n        else {\n        \tthis.outer_state = XBEL.NOTHING;\n        \tthis.inner_state = XBEL.NOTHING;\n        \tthis.parse_value = false;\n        }\n    }","commit_id":"25339f93c77c9c14fd37272afc5db873e80e4770","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\t\tfinal Switchboard sb = (Switchboard) env;\n\t\tprop = new serverObjects();        \n        final userDB.Entry user = sb.userDB.getUser(header); \n        final boolean isAdmin = (sb.verifyAuthentication(header, true));\n        final boolean isAuthUser = user!= null && user.hasRight(userDB.Entry.BOOKMARK_RIGHT);\n        \n        if(isAdmin || isAuthUser) {\n        \tfinal String bmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);\n\n        \t\n        \tString root = YMarkTables.FOLDERS_ROOT;  \t\n        \tString[] foldername = null;\n        \tboolean isFolder = true;\n\n        \tif (post != null){\n        \t\tif (post.containsKey(ROOT)) {\n            \t\tif (post.get(ROOT).equals(SOURCE) || post.get(ROOT).equals(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = \"\";\n            \t\t} else if (post.get(ROOT).startsWith(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = post.get(ROOT);\n            \t\t} else {\n            \t\t\t// root = YMarkTables.FOLDERS_ROOT + post.get(ROOT);\n            \t\t\tisFolder = false;\n            \t\t}\n        \t\t}\n        \t}\n        \t\n        \tIterator<String> it = null;\n        \tTables.Row bmk_row = null;\n        \tint count = 0;\n        \t\n        \tif(isFolder) {\n\t        \t// loop through folderList  \t\n\t        \ttry {\n\t\t\t\t\tit = sb.tables.bookmarks.folders.getFolders(bmk_user, root);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t}\n\t        \tint n = root.split(YMarkTables.FOLDERS_SEPARATOR).length;\n\t        \tif (n == 0) n = 1;\n\t        \twhile (it.hasNext()) {    \t\t   \t\t\n\t        \t\tString folder = it.next();\n\t        \t\tfoldername = folder.split(YMarkTables.FOLDERS_SEPARATOR);\n\t        \t\tif (foldername.length == n+1) {\n\t        \t\t\tprop.put(\"folders_\"+count+\"_foldername\", foldername[n]);\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_expanded\", \"false\");\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_type\", \"folder\");\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_hash\", folder);\t\t\t\t//TODO: switch from pathString to folderHash\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_url\", \"\");\t\t\t\t\t//TODO: insert folder url\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_hasChildren\", \"true\");\t\t//TODO: determine if folder has children\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_comma\", \",\");\n\t    \t    \t\tcount++;\n\t        \t\t}\n\t        \t}\n\t        \t// loop through bookmarkList\n\t        \ttry {\n\t\t\t\t\tit = sb.tables.bookmarks.folders.getBookmarks(bmk_user, root).iterator();\n\t\t        \twhile (it.hasNext()) {\n\t\t        \t\tfinal String urlHash = new String(it.next());\n\t\t        \t\tbmk_row = sb.tables.select(YMarkTables.TABLES.BOOKMARKS.tablename(bmk_user), urlHash.getBytes());\n\t\t\t        \tif(bmk_row != null) {\n\t\t\t        \t\tfinal String url = new String(bmk_row.get(YMarkTables.BOOKMARK.URL.key()));\n\t\t\t        \t\tfinal String title = new String(bmk_row.get(YMarkTables.BOOKMARK.TITLE.key(), YMarkTables.BOOKMARK.TITLE.deflt()));\n\t\t\t        \t\t\t\n\t\t\t        \t\t// TODO: get_treeview - get rid of bmtype\n\t\t\t        \t\tif (post.containsKey(\"bmtype\")) {    \t\t\t \n\t\t\t        \t\t\tif (post.get(\"bmtype\").equals(\"title\")) {\n\t\t\t        \t\t\t\tprop.put(\"folders_\"+count+\"_foldername\", title);\n\t\t\t        \t\t\t} else if (post.get(\"bmtype\").equals(\"href\")) {\n\t\t\t        \t\t\t\tprop.put(\"folders_\"+count+\"_foldername\", \n\t\t\t        \t\t\t\t\t\t\"<a href='\"+url+\" 'target='_blank'>\"+title+\"<\/a>\");\n\t\t\t        \t\t\t} \n\t\t\t        \t\t} else {\n\t\t\t        \t\t\t\tprop.put(\"folders_\"+count+\"_foldername\", url);\n\t\t        \t\t\t}\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_expanded\", \"false\");\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_url\", url);\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_type\", \"file\");\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_hash\", urlHash);\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_hasChildren\", \"true\");\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_comma\", \",\");\n\t\t\t        \t\tcount++;   \n\t\t\t        \t}\n\t\t        \t} \n\t\t        \tcount--;\n\t\t        \tprop.put(\"folders_\"+count+\"_comma\", \"\");\n\t\t        \tcount++;\n\t\t        \tprop.put(\"folders\", count);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t}\n\t        } else {\n\t        \ttry {\n\t\t\t\t\tbmk_row = sb.tables.select(YMarkTables.TABLES.BOOKMARKS.tablename(bmk_user), post.get(ROOT).getBytes());\n\t\t\t\t\tif(bmk_row != null) {\n\t\t\t            it = bmk_row.keySet().iterator();\n\t\t\t            while(it.hasNext()) {\n\t\t\t            \tfinal String key = it.next();\n\t\t\t            \tif(key.startsWith(\"date\")) {\n\t\t\t\t            \tfinal String date = DateFormatter.formatISO8601(new Date(Long.parseLong(new String(bmk_row.get(key)))));\n\t\t\t\t            \tprop.put(\"folders_\"+count+\"_foldername\",\"<small><b>\"+key+\":<\/b> \" + date + \"<\/small>\");\n\t\t    \t\t\t\t\tputProp(count, \"date\");\n\t\t    \t\t\t\t\tcount++;\n\t\t\t            \t} else {\n\t\t\t\t\t\t\t\tfinal String value = new String(bmk_row.get(key));\n\t\t\t\t\t\t\t\tprop.put(\"folders_\"+count+\"_foldername\",\"<small><b>\"+key+\":<\/b> \" + value + \"<\/small>\");\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(YMarkTables.BOOKMARK.contains(key))\n\t\t\t\t\t\t\t\t\tputProp(count, YMarkTables.BOOKMARK.get(key).type());\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tputProp(count, \"meta\");\n\t\t\t\t\t\t\t\tcount++;\t\n\t\t\t            \t}\n\t\t\t            }\n\t\t\t            count--;\n    \t\t        \tprop.put(\"folders_\"+count+\"_comma\", \"\");\n    \t\t        \tcount++;\t\n\t\t        \t\tprop.put(\"folders\", count);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t}\n\t        }\n        } else {\n        \tprop.put(YMarkTables.USER_AUTHENTICATE,YMarkTables.USER_AUTHENTICATE_MSG);\n        }  \n        // return rewrite properties\n        return prop;\n\t}","id":101976,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\t\tfinal Switchboard sb = (Switchboard) env;\n\t\tprop = new serverObjects();        \n        final userDB.Entry user = sb.userDB.getUser(header); \n        final boolean isAdmin = (sb.verifyAuthentication(header, true));\n        final boolean isAuthUser = user!= null && user.hasRight(userDB.Entry.BOOKMARK_RIGHT);\n        \n        if(isAdmin || isAuthUser) {\n        \tfinal String bmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);\n\n        \t\n        \tString root = YMarkTables.FOLDERS_ROOT;  \t\n        \tString[] foldername = null;\n        \tboolean isFolder = true;\n\n        \tif (post != null){\n        \t\tif (post.containsKey(ROOT)) {\n            \t\tif (post.get(ROOT).equals(SOURCE) || post.get(ROOT).equals(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = \"\";\n            \t\t} else if (post.get(ROOT).startsWith(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = post.get(ROOT);\n            \t\t} else {\n            \t\t\t// root = YMarkTables.FOLDERS_ROOT + post.get(ROOT);\n            \t\t\tisFolder = false;\n            \t\t}\n        \t\t}\n        \t}\n        \t\n        \tIterator<String> it = null;\n        \tTables.Row bmk_row = null;\n        \tint count = 0;\n        \t\n        \tif(isFolder) {\n\t        \t// loop through folderList  \t\n\t        \ttry {\n\t\t\t\t\tit = sb.tables.bookmarks.folders.getFolders(bmk_user, root);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t}\n\t        \tint n = root.split(YMarkTables.FOLDERS_SEPARATOR).length;\n\t        \tif (n == 0) n = 1;\n\t        \twhile (it.hasNext()) {    \t\t   \t\t\n\t        \t\tString folder = it.next();\n\t        \t\tfoldername = folder.split(YMarkTables.FOLDERS_SEPARATOR);\n\t        \t\tif (foldername.length == n+1) {\n\t        \t\t\tprop.put(\"folders_\"+count+\"_foldername\", foldername[n]);\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_expanded\", \"false\");\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_type\", \"folder\");\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_hash\", folder);\t\t\t\t//TODO: switch from pathString to folderHash\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_url\", \"\");\t\t\t\t\t//TODO: insert folder url\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_hasChildren\", \"true\");\t\t//TODO: determine if folder has children\n\t    \t    \t\tprop.put(\"folders_\"+count+\"_comma\", \",\");\n\t    \t    \t\tcount++;\n\t        \t\t}\n\t        \t}\n\t        \t// loop through bookmarkList\n\t        \ttry {\n\t\t\t\t\tit = sb.tables.bookmarks.folders.getBookmarks(bmk_user, root).iterator();\n\t\t        \twhile (it.hasNext()) {\n\t\t        \t\tfinal String urlHash = new String(it.next());\n\t\t        \t\tbmk_row = sb.tables.select(YMarkTables.TABLES.BOOKMARKS.tablename(bmk_user), urlHash.getBytes());\n\t\t\t        \tif(bmk_row != null) {\n\t\t\t        \t\tfinal String url = new String(bmk_row.get(YMarkTables.BOOKMARK.URL.key()));\n\t\t\t        \t\tfinal String title = new String(bmk_row.get(YMarkTables.BOOKMARK.TITLE.key(), YMarkTables.BOOKMARK.TITLE.deflt()));\n\t\t\t        \t\t\t\n\t\t\t        \t\t// TODO: get_treeview - get rid of bmtype\n\t\t\t        \t\tif (post.containsKey(\"bmtype\")) {    \t\t\t \n\t\t\t        \t\t\tif (post.get(\"bmtype\").equals(\"title\")) {\n\t\t\t        \t\t\t\tprop.put(\"folders_\"+count+\"_foldername\", title);\n\t\t\t        \t\t\t} else if (post.get(\"bmtype\").equals(\"href\")) {\n\t\t\t        \t\t\t\tprop.put(\"folders_\"+count+\"_foldername\", \n\t\t\t        \t\t\t\t\t\t\"<a href='\"+url+\" 'target='_blank'>\"+title+\"<\/a>\");\n\t\t\t        \t\t\t} \n\t\t\t        \t\t} else {\n\t\t\t        \t\t\t\tprop.put(\"folders_\"+count+\"_foldername\", url);\n\t\t        \t\t\t}\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_expanded\", \"false\");\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_url\", url);\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_type\", \"file\");\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_hash\", urlHash);\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_hasChildren\", \"true\");\n\t\t\t        \t\tprop.put(\"folders_\"+count+\"_comma\", \",\");\n\t\t\t        \t\tcount++;   \n\t\t\t        \t}\n\t\t        \t} \n\t\t        \tcount--;\n\t\t        \tprop.put(\"folders_\"+count+\"_comma\", \"\");\n\t\t        \tcount++;\n\t\t        \tprop.put(\"folders\", count);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t}\n\t        } else {\n\t        \ttry {\n\t\t\t\t\tbmk_row = sb.tables.select(YMarkTables.TABLES.BOOKMARKS.tablename(bmk_user), post.get(ROOT).getBytes());\n\t\t\t\t\tif(bmk_row != null) {\n\t\t\t            it = bmk_row.keySet().iterator();\n\t\t\t            while(it.hasNext()) {\n\t\t\t            \tfinal String key = it.next();\n\t\t\t            \tif(key.startsWith(\"date\")) {\n\t\t\t\t            \tfinal String d = new String(bmk_row.get(key));\n\t\t\t\t            \tif(!d.isEmpty()) {\n\t\t\t\t            \t\tfinal String date = DateFormatter.formatISO8601(new Date(Long.parseLong(d)));\n\t\t\t\t\t            \tprop.put(\"folders_\"+count+\"_foldername\",\"<small><b>\"+key+\":<\/b> \" + date + \"<\/small>\");\n\t\t\t    \t\t\t\t\tputProp(count, \"date\");\n\t\t\t    \t\t\t\t\tcount++;\n\t\t\t\t            \t}\n\t\t\t            \t} else {\n\t\t\t\t\t\t\t\tfinal String value = new String(bmk_row.get(key));\n\t\t\t\t\t\t\t\tprop.put(\"folders_\"+count+\"_foldername\",\"<small><b>\"+key+\":<\/b> \" + value + \"<\/small>\");\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(YMarkTables.BOOKMARK.contains(key))\n\t\t\t\t\t\t\t\t\tputProp(count, YMarkTables.BOOKMARK.get(key).type());\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tputProp(count, \"meta\");\n\t\t\t\t\t\t\t\tcount++;\t\n\t\t\t            \t}\n\t\t\t            }\n\t\t\t            count--;\n    \t\t        \tprop.put(\"folders_\"+count+\"_comma\", \"\");\n    \t\t        \tcount++;\t\n\t\t        \t\tprop.put(\"folders\", count);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t}\n\t        }\n        } else {\n        \tprop.put(YMarkTables.USER_AUTHENTICATE,YMarkTables.USER_AUTHENTICATE_MSG);\n        }  \n        // return rewrite properties\n        return prop;\n\t}","commit_id":"25339f93c77c9c14fd37272afc5db873e80e4770","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\t\tsb = (Switchboard) env;\n\t\tprop = new serverObjects();        \n        final userDB.Entry user = sb.userDB.getUser(header); \n        final boolean isAdmin = (sb.verifyAuthentication(header, true));\n        final boolean isAuthUser = user!= null && user.hasRight(userDB.Entry.BOOKMARK_RIGHT);\n        \n        if(isAdmin || isAuthUser) {\n        \tbmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);\n        \t\n        \tString root = YMarkTables.FOLDERS_ROOT;  \t\n        \tString[] foldername = null;\n\n        \tif (post != null){\n        \t\tif (post.containsKey(ROOT)) {\n            \t\tif (post.get(ROOT).equals(SOURCE) || post.get(ROOT).equals(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = \"\";\n            \t\t} else if (post.get(ROOT).startsWith(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = post.get(ROOT);\n            \t\t} else {\n            \t\t\troot = \"\";\n            \t\t\t// root = YMarkTables.FOLDERS_ROOT + post.get(ROOT);\n            \t\t}\n        \t\t}\n        \t}\n        \t\n        \tIterator<String> it = null;\n        \tint count = 0;\n\t\t\tint n = YMarkIndex.getFolderDepth(root);\n        \t\n        \ttry {\n\t\t\t\tit = sb.tables.bookmarks.folders.getFolders(bmk_user, root);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.logException(e);\n\t\t\t}\n\n\t\t\twhile (it.hasNext()) {    \t\t   \t\t\n        \t\tString folder = it.next();\n        \t\tfoldername = folder.split(YMarkTables.FOLDERS_SEPARATOR);\n        \t\tLog.logInfo(YMarkTables.BOOKMARKS_LOG, \"folder: \"+folder+\" getFolderDepth(folder): \"+YMarkIndex.getFolderDepth(folder)+\" n: \"+n);\n        \t\tif (count > 0 && YMarkIndex.getFolderDepth(folder) <= n) {\n\t\t\t\t\tprop.put(\"xbel_\"+count+\"_elements\", \"<\/folder>\");\n            \t\tcount++;\n        \t\t} \n        \t\tif (YMarkIndex.getFolderDepth(folder) >= n) {\n        \t\t\tn = YMarkIndex.getFolderDepth(folder);\n            \t\tprop.put(\"xbel_\"+count+\"_elements\", \"<folder id=\\\"f:\"+new String(YMarkTables.getKeyId(foldername[n]))+\"\\\">\");\n            \t\tcount++;\n            \t\tprop.put(\"xbel_\"+count+\"_elements\", \"<title>\" + CharacterCoding.unicode2xml(foldername[n], true) + \"<\/title>\");   \t\t\n            \t\tcount++;\n            \t\ttry {\n\t\t\t\t\t\tcount = putBookmarks(folder, count);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n        \t\t}\n        \t}\n\t\t\twhile(n >= YMarkIndex.getFolderDepth(root)) {\n\t\t\t\tprop.put(\"xbel_\"+count+\"_elements\", \"<\/folder>\");\n\t    \t\tcount++;\n\t    \t\tn--;\n\t\t\t}\n    \t\tprop.put(\"xbel\", count);\n        }  else {\n        \tprop.put(YMarkTables.USER_AUTHENTICATE,YMarkTables.USER_AUTHENTICATE_MSG);\n        }  \n        // return rewrite properties\n        return prop;\n\t}","id":101977,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\t\tfinal Switchboard sb = (Switchboard) env;\n\t\tfinal serverObjects prop = new serverObjects();        \n\t\tfinal HashSet<String> alias = new HashSet<String>();\n\t\tfinal StringBuilder buffer = new StringBuilder(250);\n\t\tfinal userDB.Entry user = sb.userDB.getUser(header); \n        final boolean isAdmin = (sb.verifyAuthentication(header, true));\n        final boolean isAuthUser = user!= null && user.hasRight(userDB.Entry.BOOKMARK_RIGHT);\n\t\tfinal String bmk_user;\n        \n        if(isAdmin || isAuthUser) {\n        \tbmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);\n        \t\n        \tString root = YMarkTables.FOLDERS_ROOT;  \t\n        \tString[] foldername = null;\n        \t\n        \t// TODO: better handling of query\n        \tif (post != null){\n        \t\tif (post.containsKey(ROOT)) {\n            \t\tif (post.get(ROOT).equals(SOURCE) || post.get(ROOT).equals(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = \"\";\n            \t\t} else if (post.get(ROOT).startsWith(YMarkTables.FOLDERS_ROOT)) {\n            \t\t\troot = post.get(ROOT);\n            \t\t} else {\n            \t\t\troot = \"\";            \t\t\t\n            \t\t}\n        \t\t}\n        \t} else {\n        \t\troot = \"\";\n        \t}\n        \t\n        \tfinal int root_depth = root.split(YMarkTables.FOLDERS_SEPARATOR).length;\n    \t\tIterator<String> fit = null;\n        \tIterator<String> bit = null;\n        \tint count = 0;    \t\t\n        \tint n = root_depth;\n        \t\n        \ttry {\n\t\t\t\tfit = sb.tables.bookmarks.folders.getFolders(bmk_user, root);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.logException(e);\n\t\t\t}\n\n\t\t\tLog.logInfo(YMarkTables.BOOKMARKS_LOG, \"root: \"+root+\" root_deph: \"+root_depth);\n\t\t\t\n\t\t\twhile (fit.hasNext()) {    \t\t   \t\t\n        \t\tString folder = fit.next();\n        \t\tfoldername = folder.split(YMarkTables.FOLDERS_SEPARATOR);        \t\t\n    \t\t\tLog.logInfo(YMarkTables.BOOKMARKS_LOG, \"folder: \"+folder+\" n: \"+n+\" folder_length: \"+foldername.length);\n        \t\tif (n != root_depth && foldername.length <= n) {\n\t\t\t\t\tprop.put(\"xbel_\"+count+\"_elements\", \"<\/folder>\");\n            \t\tcount++;\n        \t\t}\n        \t\tif (foldername.length >= n) {\n        \t\t\tn = foldername.length;\n        \t\t\tif(n != root_depth) {\n                \t\tprop.put(\"xbel_\"+count+\"_elements\", \"<folder id=\\\"f:\"+new String(YMarkTables.getKeyId(foldername[n-1]))+\"\\\">\");\n                \t\tcount++;\n                \t\tprop.put(\"xbel_\"+count+\"_elements\", \"<title>\" + CharacterCoding.unicode2xml(foldername[n-1], true) + \"<\/title>\");   \t\t\n                \t\tcount++;\t\n        \t\t\t}\n            \t\ttry {\n            \t\t\tbit = sb.tables.bookmarks.folders.getBookmarks(bmk_user, folder).iterator();\n            \t    \tTables.Row bmk_row = null;\n            \t    \tString urlHash;\n            \t\t\twhile(bit.hasNext()){ \n            \t\t\t\turlHash = new String(bit.next());\n            \t    \t\tif(alias.contains(urlHash)) {\n            \t    \t\t\tbuffer.setLength(0);\n            \t    \t\t\tbuffer.append(YMarksXBELImporter.XBEL.ALIAS.startTag(true));\n            \t    \t\t\tbuffer.append(\" ref=\\\"b:\");\n            \t    \t\t\tbuffer.append(urlHash);\n            \t    \t\t\tbuffer.append(\"\\\"/>\");            \t    \t\t\t\n            \t    \t\t\tprop.put(\"xbel_\"+count+\"_elements\", buffer.toString()); \t\t\n            \t\t    \t\tcount++;  \t\n            \t    \t\t} else {\n            \t\t\t\t\talias.add(urlHash);\n            \t    \t\t\tbmk_row = sb.tables.select(YMarkTables.TABLES.BOOKMARKS.tablename(bmk_user), urlHash.getBytes());\n            \t\t        \tif(bmk_row != null) {\n            \t\t        \t\tbuffer.setLength(0);\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarksXBELImporter.XBEL.BOOKMARK.startTag(true));\n            \t\t        \t\tbuffer.append(\" id=\\\"b:\");\n            \t\t        \t\tbuffer.append(urlHash);\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarkTables.BOOKMARK.URL.xbel());\n            \t\t        \t\tbuffer.append(CharacterCoding.unicode2xml(bmk_row.get(YMarkTables.BOOKMARK.URL.key(), YMarkTables.BOOKMARK.URL.deflt()), true));\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarkTables.BOOKMARK.DATE_ADDED.xbel());\n            \t\t        \t\tbuffer.append(CharacterCoding.unicode2xml(YMarkTables.getISO8601(bmk_row.get(YMarkTables.BOOKMARK.DATE_ADDED.key())), true));\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarkTables.BOOKMARK.DATE_MODIFIED.xbel());\n            \t\t        \t\tbuffer.append(CharacterCoding.unicode2xml(YMarkTables.getISO8601(bmk_row.get(YMarkTables.BOOKMARK.DATE_MODIFIED.key())), true));\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarkTables.BOOKMARK.DATE_VISITED.xbel());\n            \t\t        \t\tbuffer.append(CharacterCoding.unicode2xml(YMarkTables.getISO8601(bmk_row.get(YMarkTables.BOOKMARK.DATE_VISITED.key())), true));\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarkTables.BOOKMARK.TAGS.xbel());\n            \t\t        \t\tbuffer.append(bmk_row.get(YMarkTables.BOOKMARK.TAGS.key(), YMarkTables.BOOKMARK.TAGS.deflt()));\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarkTables.BOOKMARK.PUBLIC.xbel());\n            \t\t        \t\tbuffer.append(bmk_row.get(YMarkTables.BOOKMARK.PUBLIC.key(), YMarkTables.BOOKMARK.PUBLIC.deflt()));\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(YMarkTables.BOOKMARK.VISITS.xbel());\n            \t\t        \t\tbuffer.append(bmk_row.get(YMarkTables.BOOKMARK.VISITS.key(), YMarkTables.BOOKMARK.VISITS.deflt()));\n            \t\t        \t\t\n            \t\t        \t\tbuffer.append(\"\\\"\\n>\");\n            \t\t        \t\tprop.put(\"xbel_\"+count+\"_elements\", buffer.toString());\n            \t\t\t    \t\tcount++; \n            \t\t\t    \t\t\n            \t\t        \t\tbuffer.setLength(0);\n            \t\t        \t\tbuffer.append(YMarksXBELImporter.XBEL.TITLE.startTag(false));\n            \t\t\t    \t\tbuffer.append(CharacterCoding.unicode2xml(bmk_row.get(YMarkTables.BOOKMARK.TITLE.key(), YMarkTables.BOOKMARK.TITLE.deflt()), true));\n            \t\t\t    \t\tbuffer.append(YMarksXBELImporter.XBEL.TITLE.endTag(false));\n            \t\t\t    \t\tprop.put(\"xbel_\"+count+\"_elements\", buffer.toString());\n            \t\t\t    \t\tcount++;\n\n            \t\t\t    \t\tbuffer.setLength(0);\n            \t\t        \t\tbuffer.append(YMarksXBELImporter.XBEL.DESC.startTag(false));\n            \t\t\t    \t\tbuffer.append(CharacterCoding.unicode2xml(bmk_row.get(YMarkTables.BOOKMARK.DESC.key(), YMarkTables.BOOKMARK.DESC.deflt()), true));\n            \t\t\t    \t\tbuffer.append(YMarksXBELImporter.XBEL.DESC.endTag(false));\n            \t\t\t    \t\tprop.put(\"xbel_\"+count+\"_elements\", buffer.toString());\n            \t\t\t    \t\tcount++;\n            \t\t\t    \t\t\n            \t\t\t    \t\tprop.put(\"xbel_\"+count+\"_elements\", YMarksXBELImporter.XBEL.BOOKMARK.endTag(false));   \t\t\n            \t\t\t    \t\tcount++;    \n            \t\t        \t}\n            \t\t\t\t}\n            \t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n        \t\t}\n        \t}\n\t\t\twhile(n > root_depth) {\n\t\t\t\tprop.put(\"xbel_\"+count+\"_elements\", YMarksXBELImporter.XBEL.FOLDER.endTag(false));\n\t    \t\tcount++;\n\t    \t\tn--;\n\t\t\t}\n    \t\tprop.put(\"user\", bmk_user.substring(0,1).toUpperCase() + bmk_user.substring(1));\n    \t\tprop.put(\"xbel\", count);\n    \t\t\n        }  else {\n        \tprop.put(YMarkTables.USER_AUTHENTICATE,YMarkTables.USER_AUTHENTICATE_MSG);\n        }  \n        // return rewrite properties\n        return prop;\n\t}","commit_id":"25339f93c77c9c14fd37272afc5db873e80e4770","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        final userDB.Entry user = sb.userDB.getUser(header); \n        final boolean isAdmin = (sb.verifyAuthentication(header, true));\n        final boolean isAuthUser = user!= null && user.hasRight(userDB.Entry.BOOKMARK_RIGHT);\n        Thread t;\n        HashMap<String,String> bmk;\n\t\tByteArrayInputStream byteIn = null;\n        \n        if(isAdmin || isAuthUser) {\n        \tfinal String bmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);        \t\n        \tif(post.containsKey(\"bmkfile\") && post.containsKey(\"importer\")){\n\t\t\t\ttry {\n\t\t\t\t\tbyteIn = new ByteArrayInputStream(post.get(\"bmkfile$file\").getBytes(\"UTF-8\"));\n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\treturn prop;\n\t\t\t\t}\n        \t\tif(post.get(\"importer\").equals(\"html\") && byteIn != null) {\n\t\t\t\t\tfinal YMarksHTMLImporter htmlImporter = new YMarksHTMLImporter(byteIn, 100);\n\t\t            t = new Thread(htmlImporter, \"YMarks - HTML Importer\");\n\t\t            t.start();\n\t\t            while ((bmk = htmlImporter.take()) != YMarkTables.POISON) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsb.tables.bookmarks.addBookmark(bmk_user, bmk, true);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tLog.logWarning(YMarkTables.BOOKMARKS_LOG.toString(), \"HTML Importer - IOException for URL: \"+bmk.get(YMarkTables.BOOKMARK.URL.key()));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\t\t\treturn prop;\n\t\t\t\t\t\t}\n\t\t            }\n            \t\tprop.put(\"result\", \"1\");        \t\t\t\n        \t\t} else if(post.get(\"importer\").equals(\"xbel\") && byteIn != null) {\n        \t\t\tfinal YMarksXBELImporter xbelImporter;\t\n    \t\t\t\ttry {\n\t\t\t\t\t\t xbelImporter = new YMarksXBELImporter(byteIn, 100);\n\t\t\t\t\t} catch (SAXException e) {\n\t\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t            t = new Thread(xbelImporter, \"YMarks - XBEL Importer\");\n\t\t            t.start();\n\t\t            while ((bmk = xbelImporter.take()) != YMarkTables.POISON) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsb.tables.bookmarks.addBookmark(bmk_user, bmk, true);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tLog.logWarning(YMarkTables.BOOKMARKS_LOG.toString(), \"XBEL Importer - IOException for URL: \"+bmk.get(YMarkTables.BOOKMARK.URL.key()));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\t\t\treturn prop;\n\t\t\t\t\t\t}\n\t\t            }\n    \t\t\t\tprop.put(\"result\", \"1\");\n            \t}        \t\t\t\n        \t}\n        }  else {\n        \tprop.put(YMarkTables.USER_AUTHENTICATE,YMarkTables.USER_AUTHENTICATE_MSG);\n        } \n        // return rewrite properties\n        return prop;\n\t}","id":101978,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        final userDB.Entry user = sb.userDB.getUser(header); \n        final boolean isAdmin = (sb.verifyAuthentication(header, true));\n        final boolean isAuthUser = user!= null && user.hasRight(userDB.Entry.BOOKMARK_RIGHT);\n        Thread t;\n        HashMap<String,String> bmk;\n\t\tByteArrayInputStream byteIn = null;\n        \n        if(isAdmin || isAuthUser) {\n        \tfinal String bmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);        \t\n        \tif(post.containsKey(\"bmkfile\") && post.containsKey(\"importer\")){\n\t\t\t\ttry {\n\t\t\t\t\tbyteIn = new ByteArrayInputStream(post.get(\"bmkfile$file\").getBytes(\"UTF-8\"));\n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\tLog.logException(e);\n\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\treturn prop;\n\t\t\t\t}\n        \t\tif(post.get(\"importer\").equals(\"html\") && byteIn != null) {\n\t\t\t\t\tfinal YMarksHTMLImporter htmlImporter = new YMarksHTMLImporter(byteIn, 100);\n\t\t            t = new Thread(htmlImporter, \"YMarks - HTML Importer\");\n\t\t            t.start();\n\t\t            while ((bmk = htmlImporter.take()) != YMarkTables.POISON) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsb.tables.bookmarks.addBookmark(bmk_user, bmk, true);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tLog.logWarning(YMarkTables.BOOKMARKS_LOG.toString(), \"HTML Importer - IOException for URL: \"+bmk.get(YMarkTables.BOOKMARK.URL.key()));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\t\t\treturn prop;\n\t\t\t\t\t\t}\n\t\t            }\n            \t\tprop.put(\"result\", \"1\");        \t\t\t\n        \t\t} else if(post.get(\"importer\").equals(\"xbel\") && byteIn != null) {\n        \t\t\tfinal YMarksXBELImporter xbelImporter;\t\n    \t\t\t\ttry {\n\t\t\t\t\t\t xbelImporter = new YMarksXBELImporter(byteIn, 100);\n\t\t\t\t\t} catch (SAXException e) {\n\t\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t            t = new Thread(xbelImporter, \"YMarks - XBEL Importer\");\n\t\t            t.start();\n\t\t            while ((bmk = xbelImporter.take()) != YMarkTables.POISON) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsb.tables.bookmarks.addBookmark(bmk_user, bmk, true);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tLog.logWarning(YMarkTables.BOOKMARKS_LOG.toString(), \"XBEL Importer - IOException for URL: \"+bmk.get(YMarkTables.BOOKMARK.URL.key()));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\t\t\treturn prop;\n\t\t\t\t\t\t}\n\t\t            }\n\t\t            // update bookmarks with aliases\n\t\t            final Iterator<HashMap<String,String>> it = xbelImporter.getAliases().iterator();\n\t\t            while (it.hasNext()) {\n\t\t            \ttry {\n\t\t\t\t\t\t\tsb.tables.bookmarks.addBookmark(bmk_user, it.next(), true);\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tLog.logWarning(YMarkTables.BOOKMARKS_LOG.toString(), \"XBEL Importer - IOException for URL: \"+bmk.get(YMarkTables.BOOKMARK.URL.key()));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} catch (RowSpaceExceededException e) {\n\t\t\t\t\t\t\t//TODO: display an error message\n\t\t\t\t\t\t\tLog.logException(e);\n\t\t\t\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t\t\t\t\treturn prop;\n\t\t\t\t\t\t}\n\t\t            }\n    \t\t\t\tprop.put(\"result\", \"1\");\n            \t}        \t\t\t\n        \t}\n        }  else {\n        \tprop.put(YMarkTables.USER_AUTHENTICATE,YMarkTables.USER_AUTHENTICATE_MSG);\n        } \n        // return rewrite properties\n        return prop;\n\t}","commit_id":"25339f93c77c9c14fd37272afc5db873e80e4770","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     *\r\n     * Attempts to adjust the size of this <tt>Frame<\/tt> as requested in the\r\n     * AWT event dispatching thread.\r\n     * <p>\r\n     * The method may be executed on the AWT event dispatching thread only\r\n     * because whoever is making the decision to request an adjustment of the\r\n     * Frame size in relation to a AWT Component should be analyzing that same\r\n     * Component in the AWT event dispatching thread only.\r\n     * <\/p>\r\n     */\r\n    public void ensureSize(\r\n            final Component component,\r\n            final int width, final int height)\r\n    {\r\n        CallManager.assertIsEventDispatchingThread();\r\n\r\n        Frame frame = CallPeerRendererUtils.getFrame(component);\r\n\r\n        if (frame == null)\r\n            return;\r\n        else if ((frame.getExtendedState() & Frame.MAXIMIZED_BOTH)\r\n                == Frame.MAXIMIZED_BOTH)\r\n        {\r\n            /*\r\n             * Forcing the size of a Component which is displayed in a maximized\r\n             * window does not sound like anything we want to do.\r\n             */\r\n            return;\r\n        }\r\n        else if (frame.equals(\r\n                frame.getGraphicsConfiguration().getDevice()\r\n                        .getFullScreenWindow()))\r\n        {\r\n            /*\r\n             * Forcing the size of a Component which is displayed in a\r\n             * full-screen window does not sound like anything we want to do.\r\n             */\r\n            return;\r\n        }\r\n        else if (!frame.equals(this))\r\n        {\r\n            /* This Frame will try to adjust only its own size. */\r\n            return;\r\n        }\r\n        else\r\n        {\r\n            Dimension frameSize = frame.getSize();\r\n            Dimension componentSize = component.getSize();\r\n            int newFrameWidth\r\n                = frameSize.width + width - componentSize.width;\r\n            int newFrameHeight\r\n                = frameSize.height + height - componentSize.height;\r\n\r\n            // Don't get bigger than the screen.\r\n            Rectangle screenBounds\r\n                = frame.getGraphicsConfiguration().getBounds();\r\n\r\n            if (newFrameWidth > screenBounds.width)\r\n                newFrameWidth = screenBounds.width;\r\n            if (newFrameHeight > screenBounds.height)\r\n                newFrameHeight = screenBounds.height;\r\n\r\n            // Don't go out of the screen.\r\n            Point frameLocation = frame.getLocation();\r\n            int newFrameX = frameLocation.x;\r\n            int newFrameY = frameLocation.y;\r\n            int xDelta\r\n                = (newFrameX + newFrameWidth)\r\n                    - (screenBounds.x + screenBounds.width);\r\n            int yDelta\r\n                = (newFrameY + newFrameHeight)\r\n                    - (screenBounds.y + screenBounds.height);\r\n\r\n            if (xDelta > 0)\r\n            {\r\n                newFrameX -= xDelta;\r\n                if (newFrameX < screenBounds.x)\r\n                    newFrameX = screenBounds.x;\r\n            }\r\n            if (yDelta > 0)\r\n            {\r\n                newFrameY -= yDelta;\r\n                if (newFrameY < screenBounds.y)\r\n                    newFrameY = screenBounds.y;\r\n            }\r\n\r\n            // Don't get smaller than the min size.\r\n            Dimension minSize = frame.getMinimumSize();\r\n\r\n            if (newFrameWidth < minSize.width)\r\n                newFrameWidth = minSize.width;\r\n            if (newFrameHeight < minSize.height)\r\n                newFrameHeight = minSize.height;\r\n\r\n            /*\r\n             * If we're going to make too small a change, don't even bother.\r\n             * Besides, we don't want some weird recursive resizing.\r\n             */\r\n            int frameWidthDelta = newFrameWidth - frameSize.width;\r\n            int frameHeightDelta = newFrameHeight - frameSize.height;\r\n\r\n            // Do not reduce the frame size.\r\n            if ((frameWidthDelta > 1) || (frameHeightDelta > 1))\r\n            {\r\n                if (!(frameWidthDelta > 1))\r\n                {\r\n                    newFrameX = frameLocation.x;\r\n                    newFrameWidth = frameSize.width;\r\n                }\r\n                else if (!(frameHeightDelta > 1))\r\n                {\r\n                    newFrameY = frameLocation.y;\r\n                    newFrameHeight = frameSize.height;\r\n                }\r\n\r\n                frame.setBounds(\r\n                        newFrameX, newFrameY,\r\n                        newFrameWidth, newFrameHeight);\r\n            }\r\n        }\r\n    }","id":101979,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     *\r\n     * Attempts to adjust the size of this <tt>Frame<\/tt> as requested in the\r\n     * AWT event dispatching thread.\r\n     * <p>\r\n     * The method may be executed on the AWT event dispatching thread only\r\n     * because whoever is making the decision to request an adjustment of the\r\n     * Frame size in relation to a AWT Component should be analyzing that same\r\n     * Component in the AWT event dispatching thread only.\r\n     * <\/p>\r\n     *\r\n     * @throws RuntimeException if the method is not called on the AWT event\r\n     * dispatching thread\r\n     */\r\n    public void ensureSize(\r\n            final Component component,\r\n            final int width, final int height)\r\n    {\r\n        CallManager.assertIsEventDispatchingThread();\r\n\r\n        Frame frame = CallPeerRendererUtils.getFrame(component);\r\n\r\n        if (frame == null)\r\n            return;\r\n        else if ((frame.getExtendedState() & Frame.MAXIMIZED_BOTH)\r\n                == Frame.MAXIMIZED_BOTH)\r\n        {\r\n            /*\r\n             * Forcing the size of a Component which is displayed in a maximized\r\n             * window does not sound like anything we want to do.\r\n             */\r\n            return;\r\n        }\r\n        else if (frame.equals(\r\n                frame.getGraphicsConfiguration().getDevice()\r\n                        .getFullScreenWindow()))\r\n        {\r\n            /*\r\n             * Forcing the size of a Component which is displayed in a\r\n             * full-screen window does not sound like anything we want to do.\r\n             */\r\n            return;\r\n        }\r\n        else if (!frame.equals(this))\r\n        {\r\n            /* This Frame will try to adjust only its own size. */\r\n            return;\r\n        }\r\n        else\r\n        {\r\n            Dimension frameSize = frame.getSize();\r\n            Dimension componentSize = component.getSize();\r\n            int newFrameWidth\r\n                = frameSize.width + width - componentSize.width;\r\n            int newFrameHeight\r\n                = frameSize.height + height - componentSize.height;\r\n\r\n            // Respect the minimum size.\r\n            Dimension minSize = frame.getMinimumSize();\r\n\r\n            if (newFrameWidth < minSize.width)\r\n                newFrameWidth = minSize.width;\r\n            if (newFrameHeight < minSize.height)\r\n                newFrameHeight = minSize.height;\r\n\r\n            // Don't get bigger than the screen.\r\n            Rectangle screenBounds\r\n                = frame.getGraphicsConfiguration().getBounds();\r\n\r\n            if (newFrameWidth > screenBounds.width)\r\n                newFrameWidth = screenBounds.width;\r\n            if (newFrameHeight > screenBounds.height)\r\n                newFrameHeight = screenBounds.height;\r\n\r\n            /*\r\n             * If we're going to make too small a change, don't even bother.\r\n             * Besides, we don't want some weird recursive resizing.\r\n             * Additionally, do not reduce the Frame size.\r\n             */\r\n            boolean changeWidth = ((newFrameWidth - frameSize.width) > 1);\r\n            boolean changeHeight = ((newFrameHeight - frameSize.height) > 1);\r\n\r\n            if (changeWidth || changeHeight)\r\n            {\r\n                if (!changeWidth)\r\n                    newFrameWidth = frameSize.width;\r\n                else if (!changeHeight)\r\n                    newFrameHeight = frameSize.height;\r\n\r\n                /*\r\n                 * The latest requirement with respect to the behavior upon\r\n                 * resizing is to center the Frame.\r\n                 */\r\n                int newFrameX\r\n                    = screenBounds.x\r\n                        + (screenBounds.width - newFrameWidth) / 2;\r\n                int newFrameY\r\n                    = screenBounds.y\r\n                        + (screenBounds.height - newFrameHeight) / 2;\r\n\r\n                // Do not let the top left go out of the screen.\r\n                if (newFrameX < screenBounds.x)\r\n                    newFrameX = screenBounds.x;\r\n                if (newFrameY < screenBounds.y)\r\n                    newFrameY = screenBounds.y;\r\n\r\n                frame.setBounds(\r\n                        newFrameX, newFrameY,\r\n                        newFrameWidth, newFrameHeight);\r\n            }\r\n        }\r\n    }","commit_id":"9d2858020d94b6f4051c18e4f01a38f6abaa5a4b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     *\r\n     * The delay implemented by <tt>CallDialog<\/tt> is 5 seconds.\r\n     */\r\n    public void close(CallPanel callPanel, boolean delay)\r\n    {\r\n        if (this.callPanel.equals(callPanel))\r\n        {\r\n            if (delay)\r\n            {\r\n                Timer timer = new Timer(5000, new DisposeCallDialogListener());\r\n\r\n                timer.setRepeats(false);\r\n                timer.start();\r\n            }\r\n            else\r\n            {\r\n                this.callPanel.disposeCallInfoFrame();\r\n                dispose();\r\n            }\r\n        }\r\n    }","id":101980,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     *\r\n     * The delay implemented by <tt>CallDialog<\/tt> is 5 seconds.\r\n     */\r\n    public void close(CallPanel callPanel, boolean delay)\r\n    {\r\n        if (this.callPanel.equals(callPanel))\r\n        {\r\n            if (delay)\r\n            {\r\n                Timer timer\r\n                    = new Timer(\r\n                            5000,\r\n                            new ActionListener()\r\n                            {\r\n                                public void actionPerformed(ActionEvent ev)\r\n                                {\r\n                                    dispose();\r\n                                }\r\n                            });\r\n\r\n                timer.setRepeats(false);\r\n                timer.start();\r\n            }\r\n            else\r\n            {\r\n                this.callPanel.disposeCallInfoFrame();\r\n                dispose();\r\n            }\r\n        }\r\n    }","commit_id":"9d2858020d94b6f4051c18e4f01a38f6abaa5a4b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Performs resizing of the DownloadDialog in order to enlarge or shrink the\n     * map.\n     */\n    public void resizeSlippyMap() {\n        Dimension iScreenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        // enlarge\n        if(iDownloadDialogDimension == null) {\n            iDownloadDialogDimension = iGui.getSize();\n            // make the each dimension 90% of the absolute display size and\n            // center the DownloadDialog\n            // retrieve the size of the display\n            int w = iScreenSize.width * 90 / 100;\n            int h = iScreenSize.height * 90 / 100;\n            iGui.setBounds((iScreenSize.width - w) / 2, (iScreenSize.height - h) / 2, w, h);\n        }\n        // shrink\n        else {\n            // set the size back to the initial dimensions and center the\n            // DownloadDialog\n            int w = iDownloadDialogDimension.width;\n            int h = iDownloadDialogDimension.height;\n            iGui.setBounds((iScreenSize.width - w) / 2, (iScreenSize.height - h) / 2, w, h);\n            iDownloadDialogDimension = null;\n        }\n\n        repaint();\n    }","id":101981,"modified_method":"/**\n     * Performs resizing of the DownloadDialog in order to enlarge or shrink the\n     * map.\n     */\n    public void resizeSlippyMap() {\n        int w, h;\n\n        // retrieve the size of the display\n        Dimension iScreenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\n        // enlarge\n        if(iDownloadDialogDimension == null) {\n            // make the each dimension 90% of the absolute display size\n            w = iScreenSize.width * 90 / 100;\n            h = iScreenSize.height * 90 / 100;\n            iDownloadDialogDimension = iGui.getSize();\n        }\n        // shrink\n        else {\n            // set the size back to the initial dimensions\n            w = iDownloadDialogDimension.width;\n            h = iDownloadDialogDimension.height;\n            iDownloadDialogDimension = null;\n        }\n\n        // resize and center the DownloadDialog\n        iGui.setBounds((iScreenSize.width - w) / 2, (iScreenSize.height - h) / 2, w, h);\n\n        repaint();\n    }","commit_id":"90ee3b7aef010bb4d1aba3d9a857dd5203caf4bc","url":"https://github.com/openstreetmap/josm"},{"original_method":"/** rebinds, and sets newApp */\n    protected T rebind() throws Exception {\n        if (newApp!=null || newManagementContext!=null) throw new IllegalStateException(\"already rebinded\");\n        newApp = rebind(true);\n        newManagementContext = newApp.getManagementContext();\n        return newApp;\n    }","id":101982,"modified_method":"/** rebinds, and sets newApp */\n    protected T rebind() throws Exception {\n        return rebind(true);\n    }","commit_id":"ab021c5099b6c18c335bcfb1b643f4446620e00b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected T rebind(boolean checkSerializable, boolean terminateOrigManagementContext) throws Exception {\n        RebindTestUtils.waitForPersisted(origApp);\n        if (checkSerializable) {\n            RebindTestUtils.checkCurrentMementoSerializable(origApp);\n        }\n        if (terminateOrigManagementContext) {\n            origManagementContext.terminate();\n        }\n        LocalManagementContext newManagementContext = createNewManagementContext();\n\n        return (T) RebindTestUtils.rebind(newManagementContext, classLoader);\n    }","id":101983,"modified_method":"@SuppressWarnings(\"unchecked\")\n    protected T rebind(boolean checkSerializable, boolean terminateOrigManagementContext) throws Exception {\n        if (newApp!=null || newManagementContext!=null) throw new IllegalStateException(\"already rebinded\");\n        \n        RebindTestUtils.waitForPersisted(origApp);\n        if (checkSerializable) {\n            RebindTestUtils.checkCurrentMementoSerializable(origApp);\n        }\n        if (terminateOrigManagementContext) {\n            origManagementContext.terminate();\n        }\n        \n        newManagementContext = createNewManagementContext();\n        newApp = (T) RebindTestUtils.rebind((LocalManagementContext)newManagementContext, classLoader);\n        return newApp;\n    }","commit_id":"ab021c5099b6c18c335bcfb1b643f4446620e00b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public NamingEnumeration<NameClassPair> list(final Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            return super.list(parsedName.remaining());\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        return namespaceContext.list(parsedName.remaining());\n    }","id":101984,"modified_method":"public NamingEnumeration<NameClassPair> list(final Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            return super.list(parsedName.remaining());\n        else\n            return namespaceContext.list(parsedName.remaining());\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void bind(Name name, Object object) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            super.bind(parsedName.remaining(), object);\n            return;\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        namespaceContext.bind(parsedName.remaining(), object);\n    }","id":101985,"modified_method":"public void bind(Name name, Object object) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            super.bind(parsedName.remaining(), object);\n        else\n            namespaceContext.bind(parsedName.remaining(), object);\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Object lookup(final Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null) {\n            //TODO: this is a bit of a hack, there should be a better way to handle this\n            if (!parsedName.remaining().isEmpty()) {\n                final String firstPart = parsedName.remaining().get(0);\n                int index = firstPart.indexOf(':');\n                if (index != -1) {\n                    final String scheme = firstPart.substring(0, index);\n                    ObjectFactory factory = urlContextFactories.get(scheme);\n                    if (factory != null) {\n                        try {\n                            return ((Context) factory.getObjectInstance(null, name, this, getEnvironment())).lookup(name);\n                        }catch(NamingException e) {\n                            throw e;\n                        } catch (Exception e) {\n                            NamingException n = new NamingException(e.getMessage());\n                            n.initCause(e);\n                            throw n;\n                        }\n                    }else{\n                        Context ctx = NamingManager.getURLContext(scheme, getEnvironment());\n                        if(ctx!=null){\n                            return ctx.lookup(name);\n                        }\n                    }\n                }\n            }\n        }\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            return super.lookup(parsedName.remaining());\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        return namespaceContext.lookup(parsedName.remaining());\n    }","id":101986,"modified_method":"public Object lookup(final Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null) {\n            //TODO: this is a bit of a hack, there should be a better way to handle this\n            if (!parsedName.remaining().isEmpty()) {\n                final String firstPart = parsedName.remaining().get(0);\n                int index = firstPart.indexOf(':');\n                if (index != -1) {\n                    final String scheme = firstPart.substring(0, index);\n                    ObjectFactory factory = urlContextFactories.get(scheme);\n                    if (factory != null) {\n                        try {\n                            return ((Context) factory.getObjectInstance(null, name, this, getEnvironment())).lookup(name);\n                        }catch(NamingException e) {\n                            throw e;\n                        } catch (Exception e) {\n                            NamingException n = new NamingException(e.getMessage());\n                            n.initCause(e);\n                            throw n;\n                        }\n                    }else{\n                        Context ctx = NamingManager.getURLContext(scheme, getEnvironment());\n                        if(ctx!=null){\n                            return ctx.lookup(name);\n                        }\n                    }\n                }\n            }\n        }\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            return super.lookup(parsedName.remaining());\n        else\n            return namespaceContext.lookup(parsedName.remaining());\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Context createSubcontext(Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            return super.createSubcontext(parsedName.remaining());\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        return namespaceContext.createSubcontext(parsedName.remaining());\n    }","id":101987,"modified_method":"public Context createSubcontext(Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            return super.createSubcontext(parsedName.remaining());\n        else\n            return namespaceContext.createSubcontext(parsedName.remaining());\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void destroySubcontext(Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            super.destroySubcontext(parsedName.remaining());\n            return;\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        namespaceContext.destroySubcontext(parsedName.remaining());\n    }","id":101988,"modified_method":"public void destroySubcontext(Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            super.destroySubcontext(parsedName.remaining());\n        else\n            namespaceContext.destroySubcontext(parsedName.remaining());\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public NamingEnumeration<Binding> listBindings(final Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            return super.listBindings(parsedName.remaining());\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        return namespaceContext.listBindings(parsedName.remaining());\n    }","id":101989,"modified_method":"public NamingEnumeration<Binding> listBindings(final Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            return super.listBindings(parsedName.remaining());\n        else\n            return namespaceContext.listBindings(parsedName.remaining());\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void rebind(Name name, Object object) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            super.rebind(parsedName.remaining(), object);\n            return;\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        namespaceContext.rebind(parsedName.remaining(), object);\n    }","id":101990,"modified_method":"public void rebind(Name name, Object object) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            super.rebind(parsedName.remaining(), object);\n        else\n            namespaceContext.rebind(parsedName.remaining(), object);\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void unbind(Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        if (parsedName.namespace() == null || parsedName.namespace().equals(\"\")) {\n            super.unbind(parsedName.remaining());\n            return;\n        }\n        final NamespaceContextSelector selector = NamespaceContextSelector.getCurrentSelector();\n        if (selector == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        final Context namespaceContext = selector.getContext(parsedName.namespace());\n        if (namespaceContext == null) {\n            throw new NameNotFoundException(name.toString());\n        }\n        namespaceContext.unbind(parsedName.remaining());\n    }","id":101991,"modified_method":"public void unbind(Name name) throws NamingException {\n        final ParsedName parsedName = parse(name);\n        final Context namespaceContext = findContext(name, parsedName);\n        if (namespaceContext == null)\n            super.unbind(parsedName.remaining());\n        else\n            namespaceContext.unbind(parsedName.remaining());\n    }","commit_id":"d243d8d0fe124295ca9ad605abb358ee501f015f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@NotNull\n  private static byte[] buildData(@NotNull String inputStr) {\n    // if length == 5, need 3 byte + 1 signal byte\n    int length = inputStr.length();\n    byte even = (byte)(length % 2);\n    byte[] data = new byte[length / 2 + 1 + even];\n    final int base = 16;\n    data[0] = even;\n    try {\n      for (int i = 0; i < length / 2; i++) {\n        int k = Character.digit(inputStr.charAt(2 * i), base) * base + Character.digit(inputStr.charAt(2 * i + 1), base);\n        data[i + 1] = (byte)(k - 128);\n      }\n      if (even == 1) {\n        int k = Character.digit(inputStr.charAt(length - 1), base);\n        data[length / 2 + 1] = (byte)(k - 128);\n      }\n    }\n    catch (NumberFormatException e) {\n      throw new IllegalArgumentException(\"bad hash string: \" + inputStr);\n    }\n    return data;\n  }","id":101992,"modified_method":"@NotNull\n  private static byte[] buildData(@NotNull String inputStr) {\n    // if length == 5, need 3 byte + 1 signal byte\n    int length = inputStr.length();\n    byte even = (byte)(length % 2);\n    byte[] data = new byte[length / 2 + 1 + even];\n    data[0] = even;\n    for (int i = 0; i < length / 2; i++) {\n      int k = parseChar(inputStr, 2 * i) * BASE + parseChar(inputStr, 2 * i + 1);\n      data[i + 1] = (byte)(k - 128);\n    }\n    if (even == 1) {\n      int k = parseChar(inputStr, length - 1);\n      data[length / 2 + 1] = (byte)(k - 128);\n    }\n    return data;\n  }","commit_id":"2c71bdf5c43ce0596dd282e17aaf20ee93528741","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiExpression getSelectedExpression(final Project project, final PsiFile file, final int startOffset, final int endOffset) {\n    PsiExpression tempExpr;\n    final PsiElement elementAt = PsiTreeUtil.findCommonParent(file.findElementAt(startOffset), file.findElementAt(endOffset - 1));\n    if (PsiTreeUtil.getParentOfType(elementAt, PsiExpression.class, false) == null) return null;\n    final PsiLiteralExpression literalExpression = PsiTreeUtil.getParentOfType(elementAt, PsiLiteralExpression.class);\n\n    final PsiLiteralExpression startLiteralExpression = PsiTreeUtil.getParentOfType(file.findElementAt(startOffset), PsiLiteralExpression.class);\n    final PsiLiteralExpression endLiteralExpression = PsiTreeUtil.getParentOfType(file.findElementAt(endOffset), PsiLiteralExpression.class);\n\n    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(project).getElementFactory();\n    try {\n      String text = file.getText().subSequence(startOffset, endOffset).toString();\n      String prefix = null;\n      String suffix = null;\n      String stripped = text;\n      if (startLiteralExpression != null) {\n        final int startExpressionOffset = startLiteralExpression.getTextOffset();\n        if (startOffset == startExpressionOffset) {\n          if (StringUtil.startsWithChar(text, '\\\"') || StringUtil.startsWithChar(text, '\\'')) {\n            stripped = text.substring(1);\n          }\n        } else if (startOffset == startExpressionOffset + 1) {\n          text = \"\\\"\" + text;\n        } else if (startOffset > startExpressionOffset + 1){\n          prefix = \"\\\" + \";\n          text = \"\\\"\" + text;\n        }\n      }\n\n      if (endLiteralExpression != null) {\n        final int endExpressionOffset = endLiteralExpression.getTextOffset() + endLiteralExpression.getTextLength();\n        if (endOffset == endExpressionOffset ) {\n          if (StringUtil.endsWithChar(stripped, '\\\"') || StringUtil.endsWithChar(stripped, '\\'')) {\n            stripped = stripped.substring(0, stripped.length() - 1);\n          }\n        } else if (endOffset == endExpressionOffset - 1) {\n          text += \"\\\"\";\n        } else if (endOffset < endExpressionOffset - 1) {\n          suffix = \" + \\\"\";\n          text += \"\\\"\";\n        }\n      }\n\n      boolean primitive = false;\n      if (stripped.equals(\"true\") || stripped.equals(\"false\")) {\n        primitive = true;\n      }\n      else {\n        try {\n          Integer.parseInt(stripped);\n          primitive = true;\n        }\n        catch (NumberFormatException e1) {\n          //then not primitive\n        }\n      }\n\n      if (primitive) {\n        text = stripped;\n      }\n\n      final PsiElement parent = literalExpression != null ? literalExpression : elementAt;\n      tempExpr = elementFactory.createExpressionFromText(text, parent);\n\n      final boolean [] hasErrors = new boolean[1];\n      final JavaRecursiveElementWalkingVisitor errorsVisitor = new JavaRecursiveElementWalkingVisitor() {\n        @Override\n        public void visitElement(final PsiElement element) {\n          if (hasErrors[0]) {\n            return;\n          }\n          super.visitElement(element);\n        }\n\n        @Override\n        public void visitErrorElement(final PsiErrorElement element) {\n          hasErrors[0] = true;\n        }\n      };\n      tempExpr.accept(errorsVisitor);\n      if (hasErrors[0]) return null;\n\n      tempExpr.putUserData(ElementToWorkOn.PREFIX, prefix);\n      tempExpr.putUserData(ElementToWorkOn.SUFFIX, suffix);\n\n      final RangeMarker rangeMarker =\n        FileDocumentManager.getInstance().getDocument(file.getVirtualFile()).createRangeMarker(startOffset, endOffset);\n      tempExpr.putUserData(ElementToWorkOn.TEXT_RANGE, rangeMarker);\n\n      tempExpr.putUserData(ElementToWorkOn.PARENT, parent);\n\n      final String fakeInitializer = \"intellijidearulezzz\";\n      final int[] refIdx = new int[1];\n      final PsiExpression toBeExpression = createReplacement(fakeInitializer, project, prefix, suffix, parent, rangeMarker, refIdx);\n      toBeExpression.accept(errorsVisitor);\n      if (hasErrors[0]) return null;\n\n      final PsiReferenceExpression refExpr = PsiTreeUtil.getParentOfType(toBeExpression.findElementAt(refIdx[0]), PsiReferenceExpression.class);\n      assert refExpr != null;\n      if (ReplaceExpressionUtil.isNeedParenthesis(refExpr.getNode(), tempExpr.getNode())) {\n        return null;\n      }\n    }\n    catch (IncorrectOperationException e) {\n      return null;\n    }\n\n    return tempExpr;\n  }","id":101993,"modified_method":"public static PsiExpression getSelectedExpression(final Project project, final PsiFile file, final int startOffset, final int endOffset) {\n\n    final PsiElement elementAtStart = file.findElementAt(startOffset);\n    if (elementAtStart == null) return null;\n    final PsiElement elementAtEnd = file.findElementAt(endOffset - 1);\n    if (elementAtEnd == null) return null;\n\n    PsiExpression tempExpr;\n    final PsiElement elementAt = PsiTreeUtil.findCommonParent(elementAtStart, elementAtEnd);\n    if (PsiTreeUtil.getParentOfType(elementAt, PsiExpression.class, false) == null) return null;\n    final PsiLiteralExpression literalExpression = PsiTreeUtil.getParentOfType(elementAt, PsiLiteralExpression.class);\n\n    final PsiLiteralExpression startLiteralExpression = PsiTreeUtil.getParentOfType(elementAtStart, PsiLiteralExpression.class);\n    final PsiLiteralExpression endLiteralExpression = PsiTreeUtil.getParentOfType(file.findElementAt(endOffset), PsiLiteralExpression.class);\n\n    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(project).getElementFactory();\n    try {\n      String text = file.getText().subSequence(startOffset, endOffset).toString();\n      String prefix = null;\n      String suffix = null;\n      String stripped = text;\n      if (startLiteralExpression != null) {\n        final int startExpressionOffset = startLiteralExpression.getTextOffset();\n        if (startOffset == startExpressionOffset) {\n          if (StringUtil.startsWithChar(text, '\\\"') || StringUtil.startsWithChar(text, '\\'')) {\n            stripped = text.substring(1);\n          }\n        } else if (startOffset == startExpressionOffset + 1) {\n          text = \"\\\"\" + text;\n        } else if (startOffset > startExpressionOffset + 1){\n          prefix = \"\\\" + \";\n          text = \"\\\"\" + text;\n        }\n      }\n\n      if (endLiteralExpression != null) {\n        final int endExpressionOffset = endLiteralExpression.getTextOffset() + endLiteralExpression.getTextLength();\n        if (endOffset == endExpressionOffset ) {\n          if (StringUtil.endsWithChar(stripped, '\\\"') || StringUtil.endsWithChar(stripped, '\\'')) {\n            stripped = stripped.substring(0, stripped.length() - 1);\n          }\n        } else if (endOffset == endExpressionOffset - 1) {\n          text += \"\\\"\";\n        } else if (endOffset < endExpressionOffset - 1) {\n          suffix = \" + \\\"\";\n          text += \"\\\"\";\n        }\n      }\n\n      boolean primitive = false;\n      if (stripped.equals(\"true\") || stripped.equals(\"false\")) {\n        primitive = true;\n      }\n      else {\n        try {\n          Integer.parseInt(stripped);\n          primitive = true;\n        }\n        catch (NumberFormatException e1) {\n          //then not primitive\n        }\n      }\n\n      if (primitive) {\n        text = stripped;\n      }\n\n      final PsiElement parent = literalExpression != null ? literalExpression : elementAt;\n      tempExpr = elementFactory.createExpressionFromText(text, parent);\n\n      final boolean [] hasErrors = new boolean[1];\n      final JavaRecursiveElementWalkingVisitor errorsVisitor = new JavaRecursiveElementWalkingVisitor() {\n        @Override\n        public void visitElement(final PsiElement element) {\n          if (hasErrors[0]) {\n            return;\n          }\n          super.visitElement(element);\n        }\n\n        @Override\n        public void visitErrorElement(final PsiErrorElement element) {\n          hasErrors[0] = true;\n        }\n      };\n      tempExpr.accept(errorsVisitor);\n      if (hasErrors[0]) return null;\n\n      tempExpr.putUserData(ElementToWorkOn.PREFIX, prefix);\n      tempExpr.putUserData(ElementToWorkOn.SUFFIX, suffix);\n\n      final RangeMarker rangeMarker =\n        FileDocumentManager.getInstance().getDocument(file.getVirtualFile()).createRangeMarker(startOffset, endOffset);\n      tempExpr.putUserData(ElementToWorkOn.TEXT_RANGE, rangeMarker);\n\n      tempExpr.putUserData(ElementToWorkOn.PARENT, parent);\n\n      final String fakeInitializer = \"intellijidearulezzz\";\n      final int[] refIdx = new int[1];\n      final PsiExpression toBeExpression = createReplacement(fakeInitializer, project, prefix, suffix, parent, rangeMarker, refIdx);\n      toBeExpression.accept(errorsVisitor);\n      if (hasErrors[0]) return null;\n\n      final PsiReferenceExpression refExpr = PsiTreeUtil.getParentOfType(toBeExpression.findElementAt(refIdx[0]), PsiReferenceExpression.class);\n      assert refExpr != null;\n      if (ReplaceExpressionUtil.isNeedParenthesis(refExpr.getNode(), tempExpr.getNode())) {\n        return null;\n      }\n    }\n    catch (IncorrectOperationException e) {\n      return null;\n    }\n\n    return tempExpr;\n  }","commit_id":"42c9fefb107846688700aac248fa050db9bf132b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public UsageGroup groupUsage(@NotNull Usage usage) {\n    if (!(usage instanceof PsiElementUsage)) {\n      return null;\n    }\n    PsiElement psiElement = ((PsiElementUsage)usage).getElement();\n\n    while (psiElement != null) {\n      if (psiElement instanceof DartComponent && psiElement.getParent() instanceof DartClassMembers) {\n        final DartComponent componentElement = (DartComponent)psiElement;\n        return new DartComponentUsageGroup(componentElement);\n      }\n      psiElement = psiElement.getParent();\n    }\n\n    return null;\n  }","id":101994,"modified_method":"@Override\n  public UsageGroup groupUsage(@NotNull Usage usage) {\n    PsiElement psiElement = usage instanceof PsiElementUsage ? ((PsiElementUsage)usage).getElement() : null;\n    if (psiElement == null || psiElement.getLanguage() != DartLanguage.INSTANCE) return null;\n\n    // todo Docs are not parsed perfectly and doc comment may be not a child of the corresponding function. Related to comment for DartDocUtil.getDocumentationText\n\n    while (psiElement != null) {\n      if (psiElement instanceof DartComponent && psiElement.getParent() instanceof DartClassMembers) {\n        final DartComponent componentElement = (DartComponent)psiElement;\n        return new DartComponentUsageGroup(componentElement);\n      }\n      psiElement = psiElement.getParent();\n    }\n\n    return null;\n  }","commit_id":"fb5c7e57233ec09c1d0e0907dff3749bf10c97f6","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private static PsiElement findPsiElement(PsiElement context, Location location) {\n    final String locationFilePath = location.getFile();\n    final PsiFile psiFile = findPsiFile(context, locationFilePath);\n    if (psiFile != null) {\n      final int offset = location.getOffset();\n      return psiFile.findElementAt(offset);\n    }\n    return null;\n  }","id":101995,"modified_method":"@Nullable\n  private static PsiElement findPsiElement(@NotNull final PsiElement context, @NotNull final Location location) {\n    final String locationFilePath = location.getFile();\n    final PsiFile psiFile = findPsiFile(context, locationFilePath);\n    if (psiFile != null) {\n      final TextRange locationRange = TextRange.create(location.getOffset(), location.getOffset() + location.getLength());\n      final int offset = location.getOffset();\n      PsiElement element = psiFile.findElementAt(offset);\n      if (element == null) return null;\n\n      boolean rangeOk = element.getTextRange().contains(locationRange);\n      if (rangeOk && element instanceof DartReference) return element;\n\n      TextRange previousRange = element.getTextRange();\n      PsiElement parent;\n      while ((parent = element.getParent()) != null) {\n        final TextRange parentRange = parent.getTextRange();\n        if (rangeOk) {\n          if (!parentRange.equals(previousRange)) {\n            return element; // range became bigger, return previous that matched better\n          }\n\n          if (parent instanceof DartReference) {\n            return parent;\n          }\n          else {\n            previousRange = parentRange;\n            element = parent;\n          }\n        }\n        else {\n          rangeOk = parent.getTextRange().contains(locationRange);\n          if (rangeOk && parent instanceof DartReference) {\n            return parent;\n          }\n          else {\n            previousRange = parentRange;\n            element = parent;\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"fb5c7e57233ec09c1d0e0907dff3749bf10c97f6","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private LineRange getRangeToMove(final Editor editor, final PsiFile file) {\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    final int startLine;\n    final int endLine;\n    LineRange result;\n    if (selectionModel.hasSelection()) {\n      startLine = editor.offsetToLogicalPosition(selectionModel.getSelectionStart()).line;\n      final LogicalPosition endPos = editor.offsetToLogicalPosition(selectionModel.getSelectionEnd());\n      endLine = endPos.column == 0 ? endPos.line - 1 : endPos.line;\n      result = new LineRange(startLine, endLine);\n    }\n    else {\n      startLine = editor.getCaretModel().getLogicalPosition().line;\n      endLine = startLine;\n      result = new LineRange(startLine, endLine);\n    }\n    if (file instanceof PsiJavaFile) {\n      result = expandLineRangeToStatement(result, editor,file);\n      if (result == null) return null;\n    }\n    final int maxLine = editor.offsetToLogicalPosition(editor.getDocument().getTextLength()).line;\n    if (result.startLine <= 1 && !isDown) return null;\n    if (result.endLine >= maxLine - 1 && isDown) return null;\n\n    final PsiElement guard =\n      PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), new Class[]{PsiMethod.class, PsiClassInitializer.class,\n                                      PsiClass.class});\n    // move operation should not go out of method\n    final int insertOffset = editor.logicalPositionToOffset(new LogicalPosition(isDown ? result.endLine + 2 : result.startLine - 1, 0));\n    if (guard != null && !guard.getTextRange().contains(insertOffset)) return null;\n    \n    return result;\n  }","id":101996,"modified_method":"private LineRange getRangeToMove(final Editor editor, final PsiFile file) {\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    final int startLine;\n    final int endLine;\n    LineRange result;\n    if (selectionModel.hasSelection()) {\n      startLine = editor.offsetToLogicalPosition(selectionModel.getSelectionStart()).line;\n      final LogicalPosition endPos = editor.offsetToLogicalPosition(selectionModel.getSelectionEnd());\n      endLine = endPos.column == 0 ? endPos.line - 1 : endPos.line;\n      result = new LineRange(startLine, endLine);\n    }\n    else {\n      startLine = editor.getCaretModel().getLogicalPosition().line;\n      endLine = startLine;\n      result = new LineRange(startLine, endLine);\n    }\n    if (file instanceof PsiJavaFile) {\n      result = expandLineRangeToStatement(result, editor,file);\n      if (result == null) return null;\n    }\n    final int maxLine = editor.offsetToLogicalPosition(editor.getDocument().getTextLength()).line;\n    if (result.startLine <= 1 && !isDown) return null;\n    if (result.endLine >= maxLine - 1 && isDown) return null;\n\n    final PsiElement elementAt = file.findElementAt(editor.getCaretModel().getOffset());\n    if (elementAt == null) return null;\n    final PsiElement guard = PsiTreeUtil.getParentOfType(elementAt, new Class[]{PsiMethod.class, PsiClassInitializer.class, PsiClass.class});\n    // move operation should not go out of method\n    final int insertOffset = editor.logicalPositionToOffset(new LogicalPosition(isDown ? result.endLine + 2 : result.startLine - 1, 0));\n    if (guard != null && !guard.getTextRange().contains(insertOffset)) return null;\n    \n    return result;\n  }","commit_id":"ed7e6588d0b290777ca19b577c7f671fef4b04e6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkEqualsComparison(\n\t\t\tLocation location,\n\t\t\tJavaClass jclass,\n\t\t\tMethod method,\n\t\t\tMethodGen methodGen, ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n\t\tInstructionHandle handle = location.getHandle();\n\t\tInstructionHandle next = handle.getNext();\n\t\tif (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n\t\t\tINVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n\t\t\tif (is.getMethodName(cpg).equals(\"assertFalse\")) {\n\t            return;\n            }\n\t\t}\n\t\tString sourceFile = jclass.getSourceFileName();\n\n\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\tif (frame.getStackDepth() < 2) {\n\t        throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n\t\tint numSlots = frame.getNumSlots();\n\t\tType lhsType_ = frame.getValue(numSlots - 2);\n\t\tType rhsType_ = frame.getValue(numSlots - 1);\n\n\n\t\t// Ignore top and bottom values\n\t\tif (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM\n\t\t\t\t|| rhsType_.getType() == T_TOP || rhsType_.getType() == T_BOTTOM) {\n\t        return;\n        }\n\n\t\tboolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n\t\tint priorityModifier = 0;\n\t\tif (looksLikeTestCase) {\n\t        priorityModifier = 2;\n        }\n\n\t\tif (rhsType_.getType() == T_NULL) {\n\t\t\t// A literal null value was passed directly to equals().\n\t\t\tif (!looksLikeTestCase) {\n\t\t\t\t\n                try {\n                \tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t                IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n\t                BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext,  method,  location);\n\t                int priority = NORMAL_PRIORITY;\n\t                if (a instanceof FieldAnnotation && ((FieldAnnotation)a).isStatic())\n\t                \tpriority = LOW_PRIORITY;\n\t                if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull()) \n\t                  bugAccumulator.accumulateBug(new BugInstance(this, \"EC_NULL_ARG\", priority)\n\t\t\t\t\t  .addClassAndMethod(methodGen, sourceFile),\n\t\t\t\t\t  SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n                } catch (CFGBuilderException e) {\n\t              AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\t\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (lhsType_.getType() == T_NULL) {\n\t\t\t// Hmm...in this case, equals() is being invoked on\n\t\t\t// a literal null value.  This is really the\n\t\t\t// purview of FindNullDeref.  So, we'll just do nothing.\n\t\t\treturn;\n\t\t} else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n\t\t\tbugReporter.logError(\"equals() used to compare non-object type(s) \" +\n\t\t\t\t\tlhsType_ + \" and \" + rhsType_ +\n\t\t\t\t\t\" in \" +\n\t\t\t\t\tSignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t\t\" at \" + location.getHandle());\n\t\t\treturn;\n\t\t}\n\t\tIncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\t\t\n\t\tif (result.getPriority() >= Priorities.LOW_PRIORITY) {\n\t\t\tcomparedForEqualityInThisMethod.add(lhsType_.getSignature());\n\t\t\tcomparedForEqualityInThisMethod.add(rhsType_.getSignature());\n\t\t}\n\t\tif (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_),\n\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t\t);\n\t\t\t} \n\t\tif (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t);\n\t\t} else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n\t\t\tString lhsSig = lhsType_.getSignature();\n\t\t\tString rhsSig = rhsType_.getSignature();\n\t\t\tboolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n\t\t\tif (core) {\n\t\t\t\tlooksLikeTestCase = false;\n\t\t\t\tpriorityModifier = 0;\n\t\t\t}\n\t\t\tif (!looksLikeTestCase) {\n\t\t\t\tClassDescriptor expectedClassDescriptor = DescriptorFactory.createClassDescriptorFromSignature(lhsSig);\n\t\t\t\tClassDescriptor actualClassDescriptor = DescriptorFactory.createClassDescriptorFromSignature(rhsSig);\n\t\t\t\tClassSummary classSummary = AnalysisContext.currentAnalysisContext().getClassSummary();\n\t\t\t\tSet<XMethod> targets = null;\n\t\t\t\ttry {\n\t\t\t\t\ttargets = Hierarchy2.resolveVirtualMethodCallTargets(expectedClassDescriptor, \"equals\", \"(Ljava/lang/Object;)Z\",\n\t\t\t\t\t\t\tfalse, false);\n\t\t\t\t\tboolean allOk = targets.size() > 0;\n\t\t\t\t\tfor(XMethod m2 : targets) \n\t\t\t\t\t\tif (!classSummary.mightBeEqualTo(m2.getClassDescriptor(), actualClassDescriptor))\n\t\t\t\t\t\t\tallOk = false;\n\t\t\t\t\tif (allOk) \n\t\t\t\t\t\tpriorityModifier+=2;\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t}\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t\t.addSomeSourceForTopTwoStackValues(classContext, method, location)\n\t\t\t\t.addEqualsMethodUsed(targets),\n\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n\t\t\t\t|| result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t.addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature())),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t);\n\t\t} else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t.addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature())),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t);\n\t\t} else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n\t\t}\n\n\t}","id":101997,"modified_method":"private void checkEqualsComparison(\n\t\t\tLocation location,\n\t\t\tJavaClass jclass,\n\t\t\tMethod method,\n\t\t\tMethodGen methodGen, ConstantPoolGen cpg, TypeDataflow typeDataflow) throws DataflowAnalysisException {\n\n\t\tInstructionHandle handle = location.getHandle();\n\t\tInstructionHandle next = handle.getNext();\n\t\tif (next != null && next.getInstruction() instanceof INVOKESTATIC) {\n\t\t\tINVOKESTATIC is = (INVOKESTATIC) next.getInstruction();\n\t\t\tif (is.getMethodName(cpg).equals(\"assertFalse\")) {\n\t            return;\n            }\n\t\t}\n\t\tString sourceFile = jclass.getSourceFileName();\n\n\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\tif (frame.getStackDepth() < 2) {\n\t        throw new DataflowAnalysisException(\"Stack underflow\", methodGen, handle);\n        }\n\n\t\tint numSlots = frame.getNumSlots();\n\t\tType lhsType_ = frame.getValue(numSlots - 2);\n\t\tType rhsType_ = frame.getValue(numSlots - 1);\n\n\n\t\t// Ignore top and bottom values\n\t\tif (lhsType_.getType() == T_TOP || lhsType_.getType() == T_BOTTOM\n\t\t\t\t|| rhsType_.getType() == T_TOP || rhsType_.getType() == T_BOTTOM) {\n\t        return;\n        }\n\n\t\tboolean looksLikeTestCase = TestCaseDetector.likelyTestCase(XFactory.createXMethod(methodGen));\n\t\tint priorityModifier = 0;\n\t\tif (looksLikeTestCase) {\n\t        priorityModifier = 2;\n        }\n\n\t\tif (rhsType_.getType() == T_NULL) {\n\t\t\t// A literal null value was passed directly to equals().\n\t\t\tif (!looksLikeTestCase) {\n\t\t\t\t\n                try {\n                \tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t                IsNullValueFrame isNullFrame = isNullDataflow.getFactAtLocation(location);\n\t                BugAnnotation a = BugInstance.getSourceForTopStackValue(classContext,  method,  location);\n\t                int priority = NORMAL_PRIORITY;\n\t                if (a instanceof FieldAnnotation && ((FieldAnnotation)a).isStatic())\n\t                \tpriority = LOW_PRIORITY;\n\t                if (isNullFrame.isValid() && isNullFrame.getTopValue().isDefinitelyNull()) \n\t                  bugAccumulator.accumulateBug(new BugInstance(this, \"EC_NULL_ARG\", priority)\n\t\t\t\t\t  .addClassAndMethod(methodGen, sourceFile),\n\t\t\t\t\t  SourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n                } catch (CFGBuilderException e) {\n\t              AnalysisContext.logError(\"Error getting null value analysis\", e);\n                }\n\t\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (lhsType_.getType() == T_NULL) {\n\t\t\t// Hmm...in this case, equals() is being invoked on\n\t\t\t// a literal null value.  This is really the\n\t\t\t// purview of FindNullDeref.  So, we'll just do nothing.\n\t\t\treturn;\n\t\t} else if (!(lhsType_ instanceof ReferenceType) || !(rhsType_ instanceof ReferenceType)) {\n\t\t\tbugReporter.logError(\"equals() used to compare non-object type(s) \" +\n\t\t\t\t\tlhsType_ + \" and \" + rhsType_ +\n\t\t\t\t\t\" in \" +\n\t\t\t\t\tSignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t\t\" at \" + location.getHandle());\n\t\t\treturn;\n\t\t}\n\t\tIncompatibleTypes result = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_);\n\t\t\n\t\tif (result.getPriority() >= Priorities.LOW_PRIORITY) {\n\t\t\tcomparedForEqualityInThisMethod.add(lhsType_.getSignature());\n\t\t\tcomparedForEqualityInThisMethod.add(rhsType_.getSignature());\n\t\t}\n\t\tif (lhsType_ instanceof ArrayType && rhsType_ instanceof ArrayType) {\n\t\t\t\tString pattern =  \"EC_BAD_ARRAY_COMPARE\";\n\t\t\t\tIncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);\n\t\t\t\tif (result2 != IncompatibleTypes.SEEMS_OK)\n\t\t\t\t\t pattern =  \"EC_INCOMPATIBLE_ARRAY_COMPARE\";\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t\t.addSomeSourceForTopTwoStackValues(classContext, method, location),\n\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t\t);\n\t\t\t} \n\t\tif (result == IncompatibleTypes.ARRAY_AND_NON_ARRAY || result == IncompatibleTypes.ARRAY_AND_OBJECT) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_ARRAY_AND_NONARRAY\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t.addSomeSourceForTopTwoStackValues(classContext, method, location),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t);\n\t\t} else if (result == IncompatibleTypes.INCOMPATIBLE_CLASSES) {\n\t\t\tString lhsSig = lhsType_.getSignature();\n\t\t\tString rhsSig = rhsType_.getSignature();\n\t\t\tboolean core = lhsSig.startsWith(\"Ljava\") && rhsSig.startsWith(\"Ljava\");\n\t\t\tif (core) {\n\t\t\t\tlooksLikeTestCase = false;\n\t\t\t\tpriorityModifier = 0;\n\t\t\t}\n\t\t\tif (!looksLikeTestCase) {\n\t\t\t\tClassDescriptor expectedClassDescriptor = DescriptorFactory.createClassDescriptorFromSignature(lhsSig);\n\t\t\t\tClassDescriptor actualClassDescriptor = DescriptorFactory.createClassDescriptorFromSignature(rhsSig);\n\t\t\t\tClassSummary classSummary = AnalysisContext.currentAnalysisContext().getClassSummary();\n\t\t\t\tSet<XMethod> targets = null;\n\t\t\t\ttry {\n\t\t\t\t\ttargets = Hierarchy2.resolveVirtualMethodCallTargets(expectedClassDescriptor, \"equals\", \"(Ljava/lang/Object;)Z\",\n\t\t\t\t\t\t\tfalse, false);\n\t\t\t\t\tboolean allOk = targets.size() > 0;\n\t\t\t\t\tfor(XMethod m2 : targets) \n\t\t\t\t\t\tif (!classSummary.mightBeEqualTo(m2.getClassDescriptor(), actualClassDescriptor))\n\t\t\t\t\t\t\tallOk = false;\n\t\t\t\t\tif (allOk) \n\t\t\t\t\t\tpriorityModifier+=2;\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t}\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t\t.addSomeSourceForTopTwoStackValues(classContext, method, location)\n\t\t\t\t.addEqualsMethodUsed(targets),\n\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse if (result == IncompatibleTypes.UNRELATED_CLASS_AND_INTERFACE\n\t\t\t\t|| result == IncompatibleTypes.UNRELATED_FINAL_CLASS_AND_INTERFACE) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_CLASS_AND_INTERFACE\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t.addSomeSourceForTopTwoStackValues(classContext, method, location)\n\t\t\t.addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature())),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t);\n\t\t} else if (result == IncompatibleTypes.UNRELATED_INTERFACES) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_INTERFACES\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t.addSomeSourceForTopTwoStackValues(classContext, method, location)\n\t\t\t.addEqualsMethodUsed(DescriptorFactory.createClassDescriptorFromSignature(lhsType_.getSignature())),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle())\n\t\t\t);\n\t\t} else if (result != IncompatibleTypes.UNCHECKED && result.getPriority() <= Priorities.LOW_PRIORITY) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"EC_UNRELATED_TYPES\", result.getPriority() + priorityModifier)\n\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t.addFoundAndExpectedType(rhsType_, lhsType_)\n\t\t\t.addSomeSourceForTopTwoStackValues(classContext, method, location),\n\t\t\tSourceLineAnnotation.fromVisitedInstruction(this.classContext, methodGen, sourceFile, location.getHandle()));\n\t\t}\n\n\t}","commit_id":"c77be45fc3512c26d48cd5baa12c8cbe80014c97","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/** Add a block to our estimate of the total. Don't notify clients. */\n\tpublic void addBlock(ObjectContainer container) {\n\t\tboolean wasFinalized;\n\t\tsynchronized (this) {\n\t\t\ttotalBlocks++;\n\t\t\twasFinalized = blockSetFinalized;\n\t\t}\n\n\t\tif (wasFinalized) {\n\t\t\tif (Logger.globalGetThreshold().ordinal() < LogLevel.MINOR.ordinal())\n\t\t\t\tLogger.error(this, \"addBlock() but set finalized! on \" + this);\n\t\t\telse\n\t\t\t\tLogger.error(this, \"addBlock() but set finalized! on \" + this, new Exception(\"error\"));\n\t\t}\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"addBlock(): total=\"+totalBlocks+\" successful=\"+successfulBlocks+\" failed=\"+failedBlocks+\" required=\"+minSuccessBlocks);\n\t\tif(persistent()) container.store(this);\n\t}","id":101998,"modified_method":"/** Add a block to our estimate of the total. Don't notify clients. */\n\tpublic void addBlock(ObjectContainer container) {\n\t\tboolean wasFinalized;\n\t\tsynchronized (this) {\n\t\t\ttotalBlocks++;\n\t\t\twasFinalized = blockSetFinalized;\n\t\t}\n\n\t\tif (wasFinalized) {\n\t\t\tif (LogLevel.MINOR.matchesThreshold(Logger.globalGetThreshold()))\n\t\t\t\tLogger.error(this, \"addBlock() but set finalized! on \" + this, new Exception(\"error\"));\n\t\t\telse\n\t\t\t\tLogger.error(this, \"addBlock() but set finalized! on \" + this);\n\t\t}\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"addBlock(): total=\"+totalBlocks+\" successful=\"+successfulBlocks+\" failed=\"+failedBlocks+\" required=\"+minSuccessBlocks);\n\t\tif(persistent()) container.store(this);\n\t}","commit_id":"d2b13f6928a73a43c66244426949bd04e31bff8f","url":"https://github.com/freenet/fred"},{"original_method":"/** Add several blocks to our estimate of the total. Don't notify clients. */\n\tpublic void addBlocks(int num, ObjectContainer container) {\n\t\tboolean wasFinalized;\n\t\tsynchronized (this) {\n\t\t\ttotalBlocks += num;\n\t\t\twasFinalized = blockSetFinalized;\n\t\t}\n\n\t\tif (wasFinalized) {\n\t\t\tif(Logger.globalGetThreshold().ordinal() < LogLevel.MINOR.ordinal())\n\t\t\t\tLogger.error(this, \"addBlocks() but set finalized! on \"+this);\n\t\t\telse\n\t\t\t\tLogger.error(this, \"addBlocks() but set finalized! on \"+this, new Exception(\"error\"));\n\t\t}\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"addBlocks(\"+num+\"): total=\"+totalBlocks+\" successful=\"+successfulBlocks+\" failed=\"+failedBlocks+\" required=\"+minSuccessBlocks); \n\t\tif(persistent()) container.store(this);\n\t}","id":101999,"modified_method":"/** Add several blocks to our estimate of the total. Don't notify clients. */\n\tpublic void addBlocks(int num, ObjectContainer container) {\n\t\tboolean wasFinalized;\n\t\tsynchronized (this) {\n\t\t\ttotalBlocks += num;\n\t\t\twasFinalized = blockSetFinalized;\n\t\t}\n\n\t\tif (wasFinalized) {\n\t\t\tif (LogLevel.MINOR.matchesThreshold(Logger.globalGetThreshold()))\n\t\t\t\tLogger.error(this, \"addBlocks() but set finalized! on \"+this, new Exception(\"error\"));\n\t\t\telse\n\t\t\t\tLogger.error(this, \"addBlocks() but set finalized! on \"+this);\n\t\t}\n\t\t\n\t\tif(logMINOR) Logger.minor(this, \"addBlocks(\"+num+\"): total=\"+totalBlocks+\" successful=\"+successfulBlocks+\" failed=\"+failedBlocks+\" required=\"+minSuccessBlocks); \n\t\tif(persistent()) container.store(this);\n\t}","commit_id":"d2b13f6928a73a43c66244426949bd04e31bff8f","url":"https://github.com/freenet/fred"}]