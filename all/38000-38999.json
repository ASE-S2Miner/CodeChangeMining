[{"original_method":"private void blackBoxScript(String filename) {\n        loadFile(filename);\n\n        ClassFileFactory factory = generateClassesInFile();\n\n        GeneratedClassLoader loader = createClassLoader(factory);\n\n        String scriptClassName = ScriptNameUtil.classNameForScript(myFiles.getPsiFile());\n\n        try {\n            Class<?> scriptClass = loader.loadClass(scriptClassName);\n\n            Constructor constructor = getConstructor(scriptClass);\n            scriptInstance = constructor.newInstance(myFiles.getScriptParameterValues().toArray());\n\n            assertFalse(\"expecting at least one expectation\", myFiles.getExpectedValues().isEmpty());\n\n            for (Pair<String, String> nameValue : myFiles.getExpectedValues()) {\n                String fieldName = nameValue.first;\n                String expectedValue = nameValue.second;\n\n                if (expectedValue.equals(\"<nofield>\")) {\n                    try {\n                        scriptClass.getDeclaredField(fieldName);\n                        fail(\"must have no field \" + fieldName);\n                    } catch (NoSuchFieldException e) {\n                        continue;\n                    }\n                }\n\n                Field field = scriptClass.getDeclaredField(fieldName);\n                field.setAccessible(true);\n                Object result = field.get(scriptInstance);\n                String resultString = result != null ? result.toString() : \"null\";\n                assertEquals(\"comparing field \" + fieldName, expectedValue, resultString);\n            }\n        }\n        catch (Throwable e) {\n            System.out.println(generateToText());\n            ExceptionUtils.rethrow(e);\n        }\n    }","id":38000,"modified_method":"private void blackBoxScript(String filename) {\n        loadFile(filename);\n\n        try {\n            Class<?> scriptClass = generateClass(ScriptNameUtil.classNameForScript(myFiles.getPsiFile()));\n\n            Constructor constructor = getConstructor(scriptClass);\n            scriptInstance = constructor.newInstance(myFiles.getScriptParameterValues().toArray());\n\n            assertFalse(\"expecting at least one expectation\", myFiles.getExpectedValues().isEmpty());\n\n            for (Pair<String, String> nameValue : myFiles.getExpectedValues()) {\n                String fieldName = nameValue.first;\n                String expectedValue = nameValue.second;\n\n                if (expectedValue.equals(\"<nofield>\")) {\n                    try {\n                        scriptClass.getDeclaredField(fieldName);\n                        fail(\"must have no field \" + fieldName);\n                    } catch (NoSuchFieldException e) {\n                        continue;\n                    }\n                }\n\n                Field field = scriptClass.getDeclaredField(fieldName);\n                field.setAccessible(true);\n                Object result = field.get(scriptInstance);\n                String resultString = result != null ? result.toString() : \"null\";\n                assertEquals(\"comparing field \" + fieldName, expectedValue, resultString);\n            }\n        }\n        catch (Throwable e) {\n            System.out.println(generateToText());\n            throw ExceptionUtils.rethrow(e);\n        }\n    }","commit_id":"5539a294398bd70472a3887c926355edf1913cf4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected Constructor getConstructor(@NotNull Class<?> clazz) {\n        Constructor [] constructors = clazz.getConstructors();\n        if (constructors == null || constructors.length != 1) {\n            throw new IllegalArgumentException(\"Script class should have one constructor: \" + clazz);\n        }\n        return constructors[0];\n    }","id":38001,"modified_method":"@NotNull\n    protected static Constructor getConstructor(@NotNull Class<?> clazz) {\n        Constructor[] constructors = clazz.getConstructors();\n        if (constructors.length != 1) {\n            throw new IllegalArgumentException(\"Script class should have one constructor: \" + clazz);\n        }\n        return constructors[0];\n    }","commit_id":"5539a294398bd70472a3887c926355edf1913cf4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public MapMergePolicy getMergePolicy(String mergePolicyName) {\n        MapMergePolicy mergePolicy = null;\n        mergePolicy = mergePolicyMap.get(mergePolicyName);\n        if (mergePolicy == null && mergePolicyName != null) {\n            try {\n                // check if user has entered custom class name instead of policy name\n                mergePolicy = ClassLoaderUtil.newInstance(mergePolicyName);\n                mergePolicyMap.put(mergePolicyName, mergePolicy);\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n                ExceptionUtil.rethrow(e);\n            }\n        }\n        if (mergePolicy == null) {\n            return mergePolicyMap.get(MapConfig.DEFAULT_MAP_MERGE_POLICY);\n        }\n        return mergePolicy;\n    }","id":38002,"modified_method":"public MapMergePolicy getMergePolicy(String mergePolicyName) {\n        MapMergePolicy mergePolicy = mergePolicyMap.get(mergePolicyName);\n        if (mergePolicy == null && mergePolicyName != null) {\n            try {\n                // check if user has entered custom class name instead of policy name\n                mergePolicy = ClassLoaderUtil.newInstance(mergePolicyName);\n                mergePolicyMap.put(mergePolicyName, mergePolicy);\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n                throw ExceptionUtil.rethrow(e);\n            }\n        }\n        if (mergePolicy == null) {\n            return mergePolicyMap.get(MapConfig.DEFAULT_MAP_MERGE_POLICY);\n        }\n        return mergePolicy;\n    }","commit_id":"34c8de0ed4dea9a3a19ded6ec71a2ebf064bc036","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public Object merge(String mapName, EntryView mergingEntry, EntryView existingEntry) {\n//        DataRecordEntry mergingDataEntry = (DataRecordEntry) mergingEntry;\n//        if (!mergingDataEntry.isValid()) {\n//            return REMOVE_EXISTING;\n//        } else {\n//            final Object existingObject = existingEntry != null ? existingEntry.getValue() : null;\n//            final Object mergingObject = mergingEntry.getValue();\n//            if (existingObject != null && existingObject instanceof CacheEntry\n//                    && mergingObject != null && mergingObject instanceof CacheEntry) {\n//                final CacheEntry existing = (CacheEntry) existingObject;\n//                final CacheEntry merging = (CacheEntry) mergingObject;\n//                final Object mergingVersionObject = merging.getVersion();\n//                final Object existingVersionObject = existing.getVersion();\n//                if (mergingVersionObject != null && existingVersionObject != null\n//                        && mergingVersionObject instanceof Comparable && existingVersionObject instanceof Comparable) {\n//                    final Comparable mergingVersion = (Comparable) mergingVersionObject;\n//                    final Comparable existingVersion = (Comparable) existingVersionObject;\n//                    if (mergingVersion.compareTo(existingVersion) > 0) {\n//                        return mergingDataEntry.getValueData();\n//                    } else {\n//                        return ((DataRecordEntry) existingEntry).getValueData();\n//                    }\n//                }\n//            }\n//            return mergingDataEntry.getValueData();\n//        }\n        return null;\n    }","id":38003,"modified_method":"public Object merge(String mapName, EntryView mergingEntry, EntryView existingEntry) {\n        final Object existingValue = existingEntry != null ? existingEntry.getValue() : null;\n        final Object mergingValue = mergingEntry.getValue();\n        if (existingValue != null && existingValue instanceof CacheEntry\n                && mergingValue != null && mergingValue instanceof CacheEntry) {\n\n            final CacheEntry existingCacheEntry = (CacheEntry) existingValue;\n            final CacheEntry mergingCacheEntry = (CacheEntry) mergingValue;\n            final Object mergingVersionObject = mergingCacheEntry.getVersion();\n            final Object existingVersionObject = existingCacheEntry.getVersion();\n            if (mergingVersionObject != null && existingVersionObject != null\n                    && mergingVersionObject instanceof Comparable && existingVersionObject instanceof Comparable) {\n\n                final Comparable mergingVersion = (Comparable) mergingVersionObject;\n                final Comparable existingVersion = (Comparable) existingVersionObject;\n\n                if (mergingVersion.compareTo(existingVersion) > 0) {\n                    return mergingValue;\n                } else {\n                    return existingValue;\n                }\n            }\n        }\n        return mergingValue;\n    }","commit_id":"34c8de0ed4dea9a3a19ded6ec71a2ebf064bc036","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Writes the supplied ColumnDef to the StringBuilder as a cli script.\n     * @param sb\n     * @param cfDef\n     * @param colDef\n     */\n    private void showColumnMeta(StringBuilder sb, CfDef cfDef, ColumnDef colDef)\n    {\n        sb.append(NEWLINE + TAB + TAB + \"{\");\n\n        final AbstractType comparator = getFormatType(cfDef.column_type.equals(\"Super\")\n                                                      ? cfDef.subcomparator_type\n                                                      : cfDef.comparator_type);\n        sb.append(\"column_name : '\" + CliUtils.escapeSQLString(comparator.getString(colDef.name)) + \"',\" + NEWLINE);\n        String validationClass = normaliseType(colDef.validation_class, \"org.apache.cassandra.db.marshal\");\n        sb.append(TAB + TAB + \"validation_class : \" + CliUtils.escapeSQLString(validationClass));\n        if (colDef.isSetIndex_name())\n        {\n            sb.append(\",\" + NEWLINE);\n            sb.append(TAB + TAB + \"index_name : '\" + CliUtils.escapeSQLString(colDef.index_name) + \"',\" + NEWLINE);\n            sb.append(TAB + TAB + \"index_type : \" + CliUtils.escapeSQLString(Integer.toString(colDef.index_type.getValue())));\n\n            if (colDef.index_options != null)\n            {\n                sb.append(\",\" + NEWLINE);\n                sb.append(TAB + TAB + \"index_options : {\" + NEWLINE);\n                int numOpts = colDef.index_options.size();\n                for (Map.Entry<String, String> entry : colDef.index_options.entrySet())\n                {\n                    sb.append(TAB + TAB + TAB + CliUtils.escapeSQLString(entry.getKey()) + \": '\" + CliUtils.escapeSQLString(entry.getValue()) + \"'\");\n                    if (--numOpts > 0)\n                        sb.append(\",\" + NEWLINE);\n                }\n                sb.append(\"}\");\n            }\n        }\n        sb.append(\"}\");\n    }","id":38004,"modified_method":"/**\n     * Writes the supplied ColumnDef to the StringBuilder as a cli script.\n     *\n     * @param output The File to write to.\n     * @param cfDef  The CfDef as a source for comparator/validator\n     * @param colDef The Column Definition to export\n     */\n    private void showColumnMeta(PrintStream output, CfDef cfDef, ColumnDef colDef)\n    {\n        output.append(NEWLINE + TAB + TAB + \"{\");\n\n        final AbstractType comparator = getFormatType(cfDef.column_type.equals(\"Super\")\n                                                      ? cfDef.subcomparator_type\n                                                      : cfDef.comparator_type);\n        output.append(\"column_name : '\" + CliUtils.escapeSQLString(comparator.getString(colDef.name)) + \"',\" + NEWLINE);\n        String validationClass = normaliseType(colDef.validation_class, \"org.apache.cassandra.db.marshal\");\n        output.append(TAB + TAB + \"validation_class : \" + CliUtils.escapeSQLString(validationClass));\n        if (colDef.isSetIndex_name())\n        {\n            output.append(\",\").append(NEWLINE)\n                  .append(TAB + TAB + \"index_name : '\" + CliUtils.escapeSQLString(colDef.index_name) + \"',\" + NEWLINE)\n                  .append(TAB + TAB + \"index_type : \" + CliUtils.escapeSQLString(Integer.toString(colDef.index_type.getValue())));\n\n            if (colDef.index_options != null)\n            {\n                output.append(\",\").append(NEWLINE);\n                output.append(TAB + TAB + \"index_options : {\" + NEWLINE);\n                int numOpts = colDef.index_options.size();\n                for (Map.Entry<String, String> entry : colDef.index_options.entrySet())\n                {\n                    String option = CliUtils.escapeSQLString(entry.getKey());\n                    String optionValue = CliUtils.escapeSQLString(entry.getValue());\n\n                    output.append(TAB + TAB + TAB)\n                          .append(\"'\" + option + \"' : '\")\n                          .append(optionValue)\n                          .append(\"'\");\n\n                    if (--numOpts > 0)\n                        output.append(\",\").append(NEWLINE);\n                }\n                output.append(\"}\");\n            }\n        }\n        output.append(\"}\");\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"private void writeAttr(StringBuilder sb, boolean first, String name, String value)\n    {\n        writeAttrRaw(sb, first, name, \"'\" + CliUtils.escapeSQLString(value) + \"'\");\n    }","id":38005,"modified_method":"private void writeAttr(PrintStream output, boolean first, String name, String value)\n    {\n        writeAttrRaw(output, first, name, \"'\" + CliUtils.escapeSQLString(value) + \"'\");\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"private void executeShowSchema(Tree statement) throws TException, InvalidRequestException\n    {\n        if (!CliMain.isConnected())\n            return;\n\n        final List<KsDef> keyspaces = thriftClient.describe_keyspaces();\n        Collections.sort(keyspaces, new KsDefNamesComparator());\n        final String keyspaceName = (statement.getChildCount() == 0)\n                                ? keySpace\n                                : CliCompiler.getKeySpace(statement, keyspaces);\n\n        Iterator<KsDef> ksIter;\n        if (keyspaceName != null)\n            ksIter = Collections2.filter(keyspaces, new Predicate<KsDef>()\n            {\n                public boolean apply(KsDef ksDef)\n                {\n                    return keyspaceName.equals(ksDef.name);\n                }\n            }).iterator();\n        else\n            ksIter = keyspaces.iterator();\n\n\n        final StringBuilder sb = new StringBuilder();\n        while (ksIter.hasNext())\n            showKeyspace(sb, ksIter.next());\n\n        sessionState.out.printf(sb.toString());\n    }","id":38006,"modified_method":"private void executeShowSchema(Tree statement) throws TException, InvalidRequestException\n    {\n        if (!CliMain.isConnected())\n            return;\n\n        final List<KsDef> keyspaces = thriftClient.describe_keyspaces();\n        Collections.sort(keyspaces, new KsDefNamesComparator());\n        final String keyspaceName = (statement.getChildCount() == 0)\n                                ? keySpace\n                                : CliCompiler.getKeySpace(statement, keyspaces);\n\n        Iterator<KsDef> ksIter;\n        if (keyspaceName != null)\n            ksIter = Collections2.filter(keyspaces, new Predicate<KsDef>()\n            {\n                public boolean apply(KsDef ksDef)\n                {\n                    return keyspaceName.equals(ksDef.name);\n                }\n            }).iterator();\n        else\n            ksIter = keyspaces.iterator();\n\n        while (ksIter.hasNext())\n            showKeyspace(sessionState.out, ksIter.next());\n\n        sessionState.out.flush();\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Creates a CLI script for the CfDef including meta data to the supplied StringBuilder.\n     * @param sb\n     * @param cfDef\n     */\n    private void showColumnFamily(StringBuilder sb, CfDef cfDef)\n    {\n        sb.append(\"create column family \" + CliUtils.escapeSQLString(cfDef.name));\n\n        writeAttr(sb, true, \"column_type\", cfDef.column_type);\n        writeAttr(sb, false, \"comparator\", normaliseType(cfDef.comparator_type, \"org.apache.cassandra.db.marshal\"));\n        if (cfDef.column_type.equals(\"Super\"))\n            writeAttr(sb, false, \"subcomparator\", normaliseType(cfDef.subcomparator_type, \"org.apache.cassandra.db.marshal\"));\n        if (!StringUtils.isEmpty(cfDef.default_validation_class))\n            writeAttr(sb, false, \"default_validation_class\",\n                        normaliseType(cfDef.default_validation_class, \"org.apache.cassandra.db.marshal\"));\n        writeAttr(sb, false, \"key_validation_class\",\n                    normaliseType(cfDef.key_validation_class, \"org.apache.cassandra.db.marshal\"));\n        writeAttr(sb, false, \"rows_cached\", cfDef.row_cache_size);\n        writeAttr(sb, false, \"row_cache_save_period\", cfDef.row_cache_save_period_in_seconds);\n        writeAttr(sb, false, \"row_cache_keys_to_save\", cfDef.row_cache_keys_to_save);\n        writeAttr(sb, false, \"keys_cached\", cfDef.key_cache_size);\n        writeAttr(sb, false, \"key_cache_save_period\", cfDef.key_cache_save_period_in_seconds);\n        writeAttr(sb, false, \"read_repair_chance\", cfDef.read_repair_chance);\n        writeAttr(sb, false, \"gc_grace\", cfDef.gc_grace_seconds);\n        writeAttr(sb, false, \"min_compaction_threshold\", cfDef.min_compaction_threshold);\n        writeAttr(sb, false, \"max_compaction_threshold\", cfDef.max_compaction_threshold);\n        writeAttr(sb, false, \"replicate_on_write\", cfDef.replicate_on_write);\n        writeAttr(sb, false, \"row_cache_provider\", normaliseType(cfDef.row_cache_provider, \"org.apache.cassandra.cache\"));\n        writeAttr(sb, false, \"compaction_strategy\", cfDef.compaction_strategy);\n        if (cfDef.isSetBloom_filter_fp_chance())\n            writeAttr(sb, false, \"bloom_filter_fp_chance\", cfDef.bloom_filter_fp_chance);\n\n        if (!cfDef.compaction_strategy_options.isEmpty())\n        {\n            StringBuilder cOptions = new StringBuilder();\n\n            cOptions.append(\"{\");\n\n            Map<String, String> options = cfDef.compaction_strategy_options;\n\n            int i = 0, size = options.size();\n\n            for (Map.Entry<String, String> entry : options.entrySet())\n            {\n                cOptions.append(CliUtils.quote(entry.getKey())).append(\" : \").append(CliUtils.quote(entry.getValue()));\n\n                if (i != size - 1)\n                    cOptions.append(\", \");\n\n                i++;\n            }\n\n            cOptions.append(\"}\");\n\n            writeAttrRaw(sb, false, \"compaction_strategy_options\", cOptions.toString());\n        }\n\n        if (!StringUtils.isEmpty(cfDef.comment))\n            writeAttr(sb, false, \"comment\", cfDef.comment);\n\n        if (!cfDef.column_metadata.isEmpty())\n        {\n            StringBuilder colSb = new StringBuilder();\n            colSb.append(\"[\");\n            boolean first = true;\n            for (ColumnDef colDef : cfDef.column_metadata)\n            {\n                if (!first)\n                    colSb.append(\",\");\n                first = false;\n                showColumnMeta(colSb, cfDef, colDef);\n            }\n            colSb.append(\"]\");\n            writeAttrRaw(sb, false, \"column_metadata\", colSb.toString());\n        }\n\n        if (cfDef.compression_options != null && !cfDef.compression_options.isEmpty())\n        {\n            StringBuilder compOptions = new StringBuilder();\n\n            compOptions.append(\"{\");\n\n            int i = 0, size = cfDef.compression_options.size();\n\n            for (Map.Entry<String, String> entry : cfDef.compression_options.entrySet())\n            {\n                compOptions.append(CliUtils.quote(entry.getKey())).append(\" : \").append(CliUtils.quote(entry.getValue()));\n\n                if (i != size - 1)\n                    compOptions.append(\", \");\n\n                i++;\n            }\n\n            compOptions.append(\"}\");\n\n            writeAttrRaw(sb, false, \"compression_options\", compOptions.toString());\n        }\n\n        sb.append(\";\");\n        sb.append(NEWLINE);\n        sb.append(NEWLINE);\n    }","id":38007,"modified_method":"/**\n     * Creates a CLI script for the CfDef including meta data to the supplied StringBuilder.\n     *\n     * @param output File to write to.\n     * @param cfDef  CfDef to export attributes from.\n     */\n    private void showColumnFamily(PrintStream output, CfDef cfDef)\n    {\n        output.append(\"create column family \").append(CliUtils.escapeSQLString(cfDef.name));\n\n        writeAttr(output, true, \"column_type\", cfDef.column_type);\n        writeAttr(output, false, \"comparator\", normaliseType(cfDef.comparator_type, \"org.apache.cassandra.db.marshal\"));\n        if (cfDef.column_type.equals(\"Super\"))\n            writeAttr(output, false, \"subcomparator\", normaliseType(cfDef.subcomparator_type, \"org.apache.cassandra.db.marshal\"));\n        if (!StringUtils.isEmpty(cfDef.default_validation_class))\n            writeAttr(output, false, \"default_validation_class\",\n                        normaliseType(cfDef.default_validation_class, \"org.apache.cassandra.db.marshal\"));\n        writeAttr(output, false, \"key_validation_class\",\n                    normaliseType(cfDef.key_validation_class, \"org.apache.cassandra.db.marshal\"));\n        writeAttr(output, false, \"rows_cached\", cfDef.row_cache_size);\n        writeAttr(output, false, \"row_cache_save_period\", cfDef.row_cache_save_period_in_seconds);\n        writeAttr(output, false, \"row_cache_keys_to_save\", cfDef.row_cache_keys_to_save);\n        writeAttr(output, false, \"keys_cached\", cfDef.key_cache_size);\n        writeAttr(output, false, \"key_cache_save_period\", cfDef.key_cache_save_period_in_seconds);\n        writeAttr(output, false, \"read_repair_chance\", cfDef.read_repair_chance);\n        writeAttr(output, false, \"gc_grace\", cfDef.gc_grace_seconds);\n        writeAttr(output, false, \"min_compaction_threshold\", cfDef.min_compaction_threshold);\n        writeAttr(output, false, \"max_compaction_threshold\", cfDef.max_compaction_threshold);\n        writeAttr(output, false, \"replicate_on_write\", cfDef.replicate_on_write);\n        writeAttr(output, false, \"row_cache_provider\", normaliseType(cfDef.row_cache_provider, \"org.apache.cassandra.cache\"));\n        writeAttr(output, false, \"compaction_strategy\", cfDef.compaction_strategy);\n        if (cfDef.isSetBloom_filter_fp_chance())\n            writeAttr(output, false, \"bloom_filter_fp_chance\", cfDef.bloom_filter_fp_chance);\n\n        if (!cfDef.compaction_strategy_options.isEmpty())\n        {\n            StringBuilder cOptions = new StringBuilder();\n\n            cOptions.append(\"{\");\n\n            Map<String, String> options = cfDef.compaction_strategy_options;\n\n            int i = 0, size = options.size();\n\n            for (Map.Entry<String, String> entry : options.entrySet())\n            {\n                cOptions.append(CliUtils.quote(entry.getKey())).append(\" : \").append(CliUtils.quote(entry.getValue()));\n\n                if (i != size - 1)\n                    cOptions.append(\", \");\n\n                i++;\n            }\n\n            cOptions.append(\"}\");\n\n            writeAttrRaw(output, false, \"compaction_strategy_options\", cOptions.toString());\n        }\n\n        if (!StringUtils.isEmpty(cfDef.comment))\n            writeAttr(output, false, \"comment\", cfDef.comment);\n\n        if (!cfDef.column_metadata.isEmpty())\n        {\n            output.append(NEWLINE)\n                  .append(TAB)\n                  .append(\"and column_metadata = [\");\n\n            boolean first = true;\n            for (ColumnDef colDef : cfDef.column_metadata)\n            {\n                if (!first)\n                    output.append(\",\");\n                first = false;\n                showColumnMeta(output, cfDef, colDef);\n            }\n\n            output.append(\"]\");\n        }\n\n        if (cfDef.compression_options != null && !cfDef.compression_options.isEmpty())\n        {\n            StringBuilder compOptions = new StringBuilder();\n\n            compOptions.append(\"{\");\n\n            int i = 0, size = cfDef.compression_options.size();\n\n            for (Map.Entry<String, String> entry : cfDef.compression_options.entrySet())\n            {\n                compOptions.append(CliUtils.quote(entry.getKey())).append(\" : \").append(CliUtils.quote(entry.getValue()));\n\n                if (i != size - 1)\n                    compOptions.append(\", \");\n\n                i++;\n            }\n\n            compOptions.append(\"}\");\n\n            writeAttrRaw(output, false, \"compression_options\", compOptions.toString());\n        }\n\n        output.append(\";\");\n        output.append(NEWLINE);\n        output.append(NEWLINE);\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"private void writeAttr(StringBuilder sb, boolean first, String name, Number value)\n    {\n        writeAttrRaw(sb, first, name, value.toString());\n    }","id":38008,"modified_method":"private void writeAttr(PrintStream output, boolean first, String name, Number value)\n    {\n        writeAttrRaw(output, first, name, value.toString());\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Creates a CLI script to create the Keyspace it's Column Families\n     * @param sb StringBuilder to write to.\n     * @param ksDef KsDef to create the cli script for.\n     */\n    private void showKeyspace(StringBuilder sb, KsDef ksDef)\n    {\n        sb.append(\"create keyspace \" + ksDef.name);\n\n        writeAttr(sb, true, \"placement_strategy\", normaliseType(ksDef.strategy_class, \"org.apache.cassandra.locator\"));\n\n        if (ksDef.strategy_options != null && !ksDef.strategy_options.isEmpty())\n        {\n            final StringBuilder opts = new StringBuilder();\n            opts.append(\"{\");\n            String prefix = \"\";\n            for (Map.Entry<String, String> opt : ksDef.strategy_options.entrySet())\n            {\n                opts.append(prefix + CliUtils.escapeSQLString(opt.getKey()) + \" : \" + CliUtils.escapeSQLString(opt.getValue()));\n                prefix = \", \";\n            }\n            opts.append(\"}\");\n            writeAttrRaw(sb, false, \"strategy_options\", opts.toString());\n        }\n\n        writeAttr(sb, false, \"durable_writes\", ksDef.durable_writes);\n\n        sb.append(\";\" + NEWLINE);\n        sb.append(NEWLINE);\n\n        sb.append(\"use \" + ksDef.name + \";\");\n        sb.append(NEWLINE);\n        sb.append(NEWLINE);\n\n        Collections.sort(ksDef.cf_defs, new CfDefNamesComparator());\n        for (CfDef cfDef : ksDef.cf_defs)\n            showColumnFamily(sb, cfDef);\n        sb.append(NEWLINE);\n        sb.append(NEWLINE);\n    }","id":38009,"modified_method":"/**\n     * Creates a CLI script to create the Keyspace it's Column Families\n     *\n     * @param output StringBuilder to write to.\n     * @param ksDef KsDef to create the cli script for.\n     */\n    private void showKeyspace(PrintStream output, KsDef ksDef)\n    {\n        output.append(\"create keyspace \").append(ksDef.name);\n\n        writeAttr(output, true, \"placement_strategy\", normaliseType(ksDef.strategy_class, \"org.apache.cassandra.locator\"));\n\n        if (ksDef.strategy_options != null && !ksDef.strategy_options.isEmpty())\n        {\n            final StringBuilder opts = new StringBuilder();\n            opts.append(\"{\");\n            String prefix = \"\";\n            for (Map.Entry<String, String> opt : ksDef.strategy_options.entrySet())\n            {\n                opts.append(prefix + CliUtils.escapeSQLString(opt.getKey()) + \" : \" + CliUtils.escapeSQLString(opt.getValue()));\n                prefix = \", \";\n            }\n            opts.append(\"}\");\n            writeAttrRaw(output, false, \"strategy_options\", opts.toString());\n        }\n\n        writeAttr(output, false, \"durable_writes\", ksDef.durable_writes);\n\n        output.append(\";\").append(NEWLINE);\n        output.append(NEWLINE);\n\n        output.append(\"use \" + ksDef.name + \";\");\n        output.append(NEWLINE);\n        output.append(NEWLINE);\n\n        Collections.sort(ksDef.cf_defs, new CfDefNamesComparator());\n        for (CfDef cfDef : ksDef.cf_defs)\n            showColumnFamily(output, cfDef);\n        output.append(NEWLINE);\n        output.append(NEWLINE);\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"private void writeAttrRaw(StringBuilder sb, boolean first, String name, String value)\n    {\n        sb.append(NEWLINE + TAB);\n        sb.append(first ? \"with \" : \"and \");\n        sb.append(name + \" = \");\n        sb.append(value);\n    }","id":38010,"modified_method":"private void writeAttrRaw(PrintStream output, boolean first, String name, String value)\n    {\n        output.append(NEWLINE).append(TAB);\n        output.append(first ? \"with \" : \"and \");\n        output.append(name).append(\" = \");\n        output.append(value);\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"private void writeAttr(StringBuilder sb, boolean first, String name, Boolean value)\n    {\n        writeAttrRaw(sb, first, name, value.toString());\n    }","id":38011,"modified_method":"private void writeAttr(PrintStream output, boolean first, String name, Boolean value)\n    {\n        writeAttrRaw(output, first, name, value.toString());\n    }","commit_id":"2216a3dce05e5b91c99b0aa98d2c1ce588f665df","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Get AbstractType by function name\n     * @param functionName - name of the function e.g. utf8, integer, long etc.\n     * @return AbstractType type corresponding to the function name\n     */\n    public static AbstractType<?> getTypeByFunction(String functionName)\n    {\n        Function function;\n\n        try\n        {\n            function = Function.valueOf(functionName.toUpperCase());\n        }\n        catch (IllegalArgumentException e)\n        {\n            StringBuilder errorMessage = new StringBuilder(\"Function '\" + functionName + \"' not found. \");\n            errorMessage.append(\"Available functions: \");\n            throw new RuntimeException(errorMessage.append(Function.getFunctionNames()).toString(), e);\n        }\n\n        return function.getValidator();\n    }","id":38012,"modified_method":"/**\n     * Get AbstractType by function name\n     * @param functionName - name of the function e.g. utf8, integer, long etc.\n     * @return AbstractType type corresponding to the function name\n     */\n    public static AbstractType<?> getTypeByFunction(String functionName)\n    {\n        Function function;\n\n        try\n        {\n            function = Function.valueOf(functionName.toUpperCase());\n        }\n        catch (IllegalArgumentException e)\n        {\n            String message = String.format(\"Function '%s' not found. Available functions: %\", functionName, Function.getFunctionNames());\n            throw new RuntimeException(message, e);\n        }\n\n        return function.getValidator();\n    }","commit_id":"8d9b5fdaedcd06462882212781fe8d86f34c4c44","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Creates a CLI script to create the Keyspace it's Column Families\n     *\n     * @param output StringBuilder to write to.\n     * @param ksDef KsDef to create the cli script for.\n     */\n    private void showKeyspace(PrintStream output, KsDef ksDef)\n    {\n        output.append(\"create keyspace \").append(CliUtils.maybeEscapeName(ksDef.name));\n\n        writeAttr(output, true, \"placement_strategy\", normaliseType(ksDef.strategy_class, \"org.apache.cassandra.locator\"));\n\n        if (ksDef.strategy_options != null && !ksDef.strategy_options.isEmpty())\n        {\n            final StringBuilder opts = new StringBuilder();\n            opts.append(\"{\");\n            String prefix = \"\";\n            for (Map.Entry<String, String> opt : ksDef.strategy_options.entrySet())\n            {\n                opts.append(prefix + CliUtils.escapeSQLString(opt.getKey()) + \" : \" + CliUtils.escapeSQLString(opt.getValue()));\n                prefix = \", \";\n            }\n            opts.append(\"}\");\n            writeAttrRaw(output, false, \"strategy_options\", opts.toString());\n        }\n\n        writeAttr(output, false, \"durable_writes\", ksDef.durable_writes);\n\n        output.append(\";\").append(NEWLINE);\n        output.append(NEWLINE);\n\n        output.append(\"use \" + CliUtils.maybeEscapeName(ksDef.name) + \";\");\n        output.append(NEWLINE);\n        output.append(NEWLINE);\n\n        Collections.sort(ksDef.cf_defs, new CfDefNamesComparator());\n        for (CfDef cfDef : ksDef.cf_defs)\n            showColumnFamily(output, cfDef);\n        output.append(NEWLINE);\n        output.append(NEWLINE);\n    }","id":38013,"modified_method":"/**\n     * Creates a CLI script to create the Keyspace it's Column Families\n     *\n     * @param output StringBuilder to write to.\n     * @param ksDef KsDef to create the cli script for.\n     */\n    private void showKeyspace(PrintStream output, KsDef ksDef)\n    {\n        output.append(\"create keyspace \").append(CliUtils.maybeEscapeName(ksDef.name));\n\n        writeAttr(output, true, \"placement_strategy\", normaliseType(ksDef.strategy_class, \"org.apache.cassandra.locator\"));\n\n        if (ksDef.strategy_options != null && !ksDef.strategy_options.isEmpty())\n        {\n            final StringBuilder opts = new StringBuilder();\n            opts.append(\"{\");\n            String prefix = \"\";\n            for (Map.Entry<String, String> opt : ksDef.strategy_options.entrySet())\n            {\n                opts.append(prefix).append(CliUtils.escapeSQLString(opt.getKey())).append(\" : \").append(CliUtils.escapeSQLString(opt.getValue()));\n                prefix = \", \";\n            }\n            opts.append(\"}\");\n            writeAttrRaw(output, false, \"strategy_options\", opts.toString());\n        }\n\n        writeAttr(output, false, \"durable_writes\", ksDef.durable_writes);\n\n        output.append(\";\").append(NEWLINE);\n        output.append(NEWLINE);\n\n        output.append(\"use \").append(CliUtils.maybeEscapeName(ksDef.name)).append(\";\");\n        output.append(NEWLINE);\n        output.append(NEWLINE);\n\n        Collections.sort(ksDef.cf_defs, new CfDefNamesComparator());\n        for (CfDef cfDef : ksDef.cf_defs)\n            showColumnFamily(output, cfDef);\n        output.append(NEWLINE);\n        output.append(NEWLINE);\n    }","commit_id":"8d9b5fdaedcd06462882212781fe8d86f34c4c44","url":"https://github.com/apache/cassandra"},{"original_method":"private AbstractType<?> getFormatType(String compareWith)\n    {\n        Function function;\n\n        try\n        {\n            function = Function.valueOf(compareWith.toUpperCase());\n        }\n        catch (IllegalArgumentException e)\n        {\n            try\n            {\n                return TypeParser.parse(compareWith);\n            }\n            catch (RequestValidationException ce)\n            {\n                StringBuilder errorMessage = new StringBuilder(\"Unknown comparator '\" + compareWith + \"'. \");\n                errorMessage.append(\"Available functions: \");\n                throw new RuntimeException(errorMessage.append(Function.getFunctionNames()).toString(), e);\n            }\n        }\n\n        return function.getValidator();\n    }","id":38014,"modified_method":"private AbstractType<?> getFormatType(String compareWith)\n    {\n        Function function;\n\n        try\n        {\n            function = Function.valueOf(compareWith.toUpperCase());\n        }\n        catch (IllegalArgumentException e)\n        {\n            try\n            {\n                return TypeParser.parse(compareWith);\n            }\n            catch (RequestValidationException ce)\n            {\n                String message = String.format(\"Unknown comparator '%s'. Available functions: %s\", compareWith, Function.getFunctionNames());\n                throw new RuntimeException(message, e);\n            }\n        }\n\n        return function.getValidator();\n    }","commit_id":"8d9b5fdaedcd06462882212781fe8d86f34c4c44","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * This function is called to validate all the arguments to the program.\n     * If a required Arg isn't found, we generate the help message, and\n     * exit the program\n     *\n     * @param args the command line arguments we recieved\n     */\n    public void processArgs(String[] args, boolean allowUnrecognized) throws ParseException {\n        OurPosixParser parser = new OurPosixParser();\n        Collection<Option> opts = m_options.getOptions();\n\n        try {\n            parser.parse(m_options, args, !allowUnrecognized);\n        }\n        catch (UnrecognizedOptionException e) {\n            // we don't care about unknown exceptions right now\n            logger.warn(e.getMessage());\n            if(!allowUnrecognized)\n                throw e;\n        }\n\n        // Apache CLI can ignore unrecognized arguments with a boolean flag, but\n        // you can't get to the unparsed args.  Override PosixParser with a class\n        // that can reach in and extract the protected command line.\n        // TODO: Holy crap this is wacky.  Find a cleaner way.\n        CommandLine cmd = parser.getCmd();\n\n        // logger.info(\"We have \" + opts.size() + \" options\");\n        for (Option opt : opts) {\n            if (cmd.hasOption(opt.getOpt())) {\n                if (opt.hasArg()) {\n                    //logger.info(\"looking at \" + m_storageLocations.get(opt.getLongOpt()));\n                    Object obj = m_storageLocations.get(opt.getLongOpt()).first;\n                    Field field = m_storageLocations.get(opt.getLongOpt()).second;\n\n                    try {\n                        field.set(obj, constructFromString(field, cmd.getOptionValue(opt.getOpt())));\n                    } catch (IllegalAccessException e) {\n                        logger.fatal(\"processArgs: cannot convert field \" + field.toString());\n                        throw new RuntimeException(\"processArgs: Failed conversion \" + e.getMessage());\n                    }\n                } else {\n                    Object obj = m_storageLocations.get(opt.getLongOpt()).first;\n                    Field field = m_storageLocations.get(opt.getLongOpt()).second;\n\n                    try {\n                        //logger.fatal(\"about to parse field \" + f.getName());\n                        field.set(obj, new Boolean(true));\n                    } catch (IllegalAccessException e) {\n                        logger.fatal(\"processArgs: cannot convert field \" + field.toString());\n                        throw new RuntimeException(\"processArgs: Failed conversion \" + e.getMessage());\n                    }\n                }\n            }\n        }\n    }","id":38015,"modified_method":"/**\n     * This function is called to validate all the arguments to the program.\n     * If a required Arg isn't found, we generate the help message, and\n     * exit the program\n     *\n     * @param args the command line arguments we recieved\n     */\n    public void processArgs(String[] args, boolean allowUnrecognized) throws ParseException {\n        OurPosixParser parser = new OurPosixParser();\n        Collection<Option> opts = m_options.getOptions();\n\n        try {\n            parser.parse(m_options, args, !allowUnrecognized);\n        }\n        catch (UnrecognizedOptionException e) {\n            // we don't care about unknown exceptions right now\n            if(!allowUnrecognized) {\n                logger.warn(e.getMessage());\n                throw e;\n            }\n        }\n\n        // Apache CLI can ignore unrecognized arguments with a boolean flag, but\n        // you can't get to the unparsed args.  Override PosixParser with a class\n        // that can reach in and extract the protected command line.\n        // TODO: Holy crap this is wacky.  Find a cleaner way.\n        CommandLine cmd = parser.getCmd();\n\n        // logger.info(\"We have \" + opts.size() + \" options\");\n        for (Option opt : opts) {\n            if (cmd.hasOption(opt.getOpt())) {\n                //logger.info(\"looking at \" + m_storageLocations.get(opt.getLongOpt()));\n                Object obj = m_storageLocations.get(opt.getLongOpt()).first;\n                Field field = m_storageLocations.get(opt.getLongOpt()).second;\n\n                try {\n                    if (opt.hasArg())\n                        field.set(obj, constructFromString(field, cmd.getOptionValues(opt.getOpt())));\n                    else\n                        field.set(obj, new Boolean(true));\n                } catch (IllegalAccessException e) {\n                    logger.fatal(\"processArgs: cannot convert field \" + field.toString());\n                    throw new RuntimeException(\"processArgs: Failed conversion \" + e.getMessage());\n                }\n            }\n        }\n    }","commit_id":"4b7bfb284adc01c987fa7bf11f4fdbd510be79cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Object constructFromString(Field f, String str) {\n        Type type = f.getType();\n        // lets go through the types we support\n        if (type == Boolean.TYPE) {\n            boolean b = false;\n            if (str.toLowerCase().equals(\"true\")) {\n                b = true;\n            }\n            Boolean bool = new Boolean(b);\n            return bool;\n        } else if (type == Integer.TYPE) {\n            Integer in = Integer.valueOf(str);\n            return in;\n        } else if (type == Float.TYPE) {\n            Float fl = Float.valueOf(str);\n            return fl;\n        } else {\n            Constructor ctor = null;\n            try {\n                ctor = f.getType().getConstructor(String.class);\n                return ctor.newInstance(str);\n            } catch (NoSuchMethodException e) {\n                logger.fatal(\"constructFromString:NoSuchMethodException: cannot convert field \" + f.toString());\n                throw new RuntimeException(\"constructFromString:NoSuchMethodException: Failed conversion \" + e.getMessage());\n            } catch (IllegalAccessException e) {\n                logger.fatal(\"constructFromString:IllegalAccessException: cannot convert field \" + f.toString());\n                throw new RuntimeException(\"constructFromString:IllegalAccessException: Failed conversion \" + e.getMessage());\n            } catch (InvocationTargetException e) {\n                logger.fatal(\"constructFromString:InvocationTargetException: cannot convert field \" + f.toString());\n                throw new RuntimeException(\"constructFromString:InvocationTargetException: Failed conversion \" + e.getMessage());\n            } catch (InstantiationException e) {\n                logger.fatal(\"constructFromString:InstantiationException: cannot convert field \" + f.toString());\n                throw new RuntimeException(\"constructFromString:InstantiationException: Failed conversion \" + e.getMessage());\n            }\n\n        }\n    }","id":38016,"modified_method":"private Object constructFromString(Field f, String[] strs) {\n        Class type = f.getType();\n\n        if( Collection.class.isAssignableFrom(type) ) {\n            Collection collection = null;\n            Class containedType = null;\n\n            // If this is a parameterized collection, find the contained type.  If blow up if only one type exists.\n            if( f.getGenericType() instanceof ParameterizedType ) {\n                ParameterizedType parameterizedType = (ParameterizedType)f.getGenericType();\n                if( parameterizedType.getActualTypeArguments().length > 1 )\n                    throw new IllegalArgumentException(\"Unable to determine collection type of field: \" + f.toString());\n                containedType = (Class)parameterizedType.getActualTypeArguments()[0];\n            }\n            else\n                containedType = String.class;\n\n            // If this is a generic interface, pick a concrete implementation to create and pass back.\n            // Because of type erasure, don't worry about creating one of exactly the correct type.\n            if( Modifier.isInterface(type.getModifiers()) || Modifier.isAbstract(type.getModifiers()) )\n            {\n                if( java.util.List.class.isAssignableFrom(type) ) type = ArrayList.class;\n                else if( java.util.Queue.class.isAssignableFrom(type) ) type = java.util.ArrayDeque.class;\n                else if( java.util.Set.class.isAssignableFrom(type) ) type = java.util.TreeSet.class;\n            }\n\n            try\n            {\n                collection = (Collection)type.newInstance();\n            }\n            catch( Exception ex ) {\n                // Runtime exceptions are definitely unexpected parsing simple collection classes.\n                throw new IllegalArgumentException(ex);\n            }\n\n            for( String str: strs )\n                collection.add( constructSingleElement(f,containedType,str) );\n\n            return collection;\n        }\n        else if( type.isArray() ) {\n            Class containedType = type.getComponentType();\n\n            Object arr = Array.newInstance(containedType,strs.length);\n            for( int i = 0; i < strs.length; i++ )\n                Array.set( arr,i,constructSingleElement(f,containedType,strs[i]) );\n            return arr;\n        }\n        else  {\n            if( strs.length != 1 )\n                throw new IllegalArgumentException(\"Passed multiple arguments to an object expecting a single value.\");\n            return constructSingleElement(f,type,strs[0]);\n        }\n    }","commit_id":"4b7bfb284adc01c987fa7bf11f4fdbd510be79cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Extract arguments stored in annotations from fields of a given class.\n     * @param source\n     */\n    public void addArgumentSource( Object source ) {\n        Field[] fields = source.getClass().getFields();\n        for(Field field: fields) {\n            Argument arg = field.getAnnotation(Argument.class);\n            if(arg == null)\n                continue;\n\n            String fullName = (arg.fullName().length() != 0) ? arg.fullName() : field.getName().trim().toLowerCase();\n            String shortName = (arg.shortName().length() != 0) ? arg.shortName() : fullName.substring(0,1);\n            if(shortName.length() != 1)\n                throw new IllegalArgumentException(\"Invalid short name: \" + shortName);\n            String description = arg.required() ? \"(Required Flag) \" + arg.doc() : arg.doc();\n\n            // TODO: Handle flags, handle lists\n            OptionBuilder ob = OptionBuilder.withLongOpt(fullName).withArgName(fullName).hasArg();\n            if( arg.required() ) ob = ob.isRequired();\n            if( description.length() != 0 ) ob = ob.withDescription( description );\n\n            Option option = ob.create( shortName );\n\n            AddToOptionStorage(fullName, shortName, new Pair<Object,Field>( source, field ), option );\n        }\n    }","id":38017,"modified_method":"/**\n     * Extract arguments stored in annotations from fields of a given class.\n     * @param source\n     */\n    public void addArgumentSource( Object source ) {\n        Field[] fields = source.getClass().getFields();\n        for(Field field: fields) {\n            Argument arg = field.getAnnotation(Argument.class);\n            if(arg == null)\n                continue;\n\n            String fullName = (arg.fullName().length() != 0) ? arg.fullName() : field.getName().trim().toLowerCase();\n            String shortName = (arg.shortName().length() != 0) ? arg.shortName() : fullName.substring(0,1);\n            if(shortName.length() != 1)\n                throw new IllegalArgumentException(\"Invalid short name: \" + shortName);\n            boolean isFlag = (field.getType() == Boolean.class) || (field.getType() == Boolean.TYPE);\n            boolean isCollection = field.getType().isArray() || Collection.class.isAssignableFrom(field.getType());\n\n            if( isFlag && isCollection )\n                throw new IllegalArgumentException(\"Can't have an array of flags.\");\n\n            String description = arg.doc();\n            if( arg.required() )\n                description = (isFlag ? \"(Required Flag) \" : \"(Required Option) \") + description;\n\n            OptionBuilder ob = OptionBuilder.withLongOpt(fullName);\n            if( !isFlag ) ob = ob.withArgName(fullName);\n            ob = isCollection ? ob.hasArgs() : ob.hasArg();\n            if( arg.required() ) ob = ob.isRequired();\n            if( description.length() != 0 ) ob = ob.withDescription( description );\n\n            Option option = ob.create( shortName );\n\n            AddToOptionStorage(fullName, shortName, new Pair<Object,Field>( source, field ), option );\n        }\n    }","commit_id":"4b7bfb284adc01c987fa7bf11f4fdbd510be79cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final void resolveFeatures() {\n        AddressingFeature addressing = getAddressingFeature();\n        if (addressing == null) {\n            return;\n        }\n        if (addressing.isEnabled()) {\n            WSAddressingFeature feature = getWSAddressingFeature();\n            if (feature == null) {\n                feature = new WSAddressingFeature();\n                addAddressingFeature(feature);\n            }\n            feature.setAddressingRequired(addressing.isRequired());\n            if (ProviderImpl.isJaxWs22()) {\n                try {\n                    Class<?> addrClass = ClassLoaderUtils.loadClass(\"javax.xml.ws.soap.AddressingFeature\",\n                                                                    ProviderImpl.class);\n                    Method responsesMethod = addrClass.getMethod(\"getResponses\", new Class[] {});\n                    Object responses = responsesMethod.invoke(addressing, new Object[] {});\n                    feature.setResponses(responses.toString());\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        } else {\n            removeAddressingFeature();\n            getEndpointInfo().setProperty(\"org.apache.cxf.ws.addressing.MAPAggregator.addressingDisabled\",\n                                          Boolean.TRUE);\n        }\n    }","id":38018,"modified_method":"public final void resolveFeatures() {\n        AddressingFeature addressing = getAddressingFeature();\n        if (addressing == null) {\n            return;\n        }\n        if (addressing.isEnabled()) {\n            WSAddressingFeature feature = getWSAddressingFeature();\n            if (feature == null) {\n                feature = new WSAddressingFeature();\n                addAddressingFeature(feature);\n            }\n            feature.setAddressingRequired(addressing.isRequired());\n            feature.setResponses(addressing.getResponses().toString());\n        } else {\n            removeAddressingFeature();\n            getEndpointInfo().setProperty(\"org.apache.cxf.ws.addressing.MAPAggregator.addressingDisabled\",\n                                          Boolean.TRUE);\n        }\n    }","commit_id":"bef3d8408feb07365e17ca6960db7b4b2f1436ec","url":"https://github.com/apache/cxf"},{"original_method":"private void loadWSFeatureAnnotation(Class<?> serviceClass, Class<?> implementorClass) {\n        List<WebServiceFeature> features = new ArrayList<WebServiceFeature>();\n        MTOM mtom = implInfo.getImplementorClass().getAnnotation(MTOM.class);\n        if (mtom == null && serviceClass != null) {\n            mtom = serviceClass.getAnnotation(MTOM.class);\n        }\n        if (mtom != null) {\n            features.add(new MTOMFeature(mtom.enabled(), mtom.threshold()));\n        } else {\n            //deprecated way to set mtom\n            BindingType bt = implInfo.getImplementorClass().getAnnotation(BindingType.class);\n            if (bt != null\n                && (SOAPBinding.SOAP11HTTP_MTOM_BINDING.equals(bt.value())\n                || SOAPBinding.SOAP12HTTP_MTOM_BINDING.equals(bt.value()))) {\n                features.add(new MTOMFeature(true));\n            }\n        }\n\n\n        Addressing addressing = null;\n        if (implementorClass != null) {\n            addressing = implementorClass.getAnnotation(Addressing.class);\n        }\n\n        if (addressing == null && serviceClass != null) {\n            addressing = serviceClass.getAnnotation(Addressing.class);\n        }\n\n        if (addressing != null) {\n            if (ProviderImpl.isJaxWs22()) {\n                try {\n                    Method method = Addressing.class.getMethod(\"responses\", new Class<?>[]{});\n                    Object responses = method.invoke(addressing, new Object[]{});\n                    java.lang.reflect.Constructor<?> constructor =\n                        AddressingFeature.class.getConstructor(new Class[] {\n                            boolean.class, boolean.class, responses.getClass()\n                        });\n                    Object obj = constructor.newInstance(addressing.enabled(), addressing.required(),\n                                                         responses);\n                    features.add((WebServiceFeature)obj);\n                } catch (Exception e) {\n                    features.add(new AddressingFeature(addressing.enabled(), addressing.required()));\n                }\n            } else {\n                features.add(new AddressingFeature(addressing.enabled(), addressing.required()));\n            }\n\n        }\n\n        RespectBinding respectBinding = implInfo.getImplementorClass().getAnnotation(\n            RespectBinding.class);\n        if (respectBinding == null && serviceClass != null) {\n            respectBinding = serviceClass.getAnnotation(RespectBinding.class);\n        }\n        if (respectBinding != null) {\n            features.add(new RespectBindingFeature(respectBinding.enabled()));\n        }\n\n        if (features.size() > 0) {\n            wsFeatures = features;\n            if (setWsFeatures != null) {\n                wsFeatures.addAll(setWsFeatures);\n            }\n        } else {\n            wsFeatures = setWsFeatures;\n        }\n    }","id":38019,"modified_method":"private void loadWSFeatureAnnotation(Class<?> serviceClass, Class<?> implementorClass) {\n        List<WebServiceFeature> features = new ArrayList<WebServiceFeature>();\n        MTOM mtom = implInfo.getImplementorClass().getAnnotation(MTOM.class);\n        if (mtom == null && serviceClass != null) {\n            mtom = serviceClass.getAnnotation(MTOM.class);\n        }\n        if (mtom != null) {\n            features.add(new MTOMFeature(mtom.enabled(), mtom.threshold()));\n        } else {\n            //deprecated way to set mtom\n            BindingType bt = implInfo.getImplementorClass().getAnnotation(BindingType.class);\n            if (bt != null\n                && (SOAPBinding.SOAP11HTTP_MTOM_BINDING.equals(bt.value())\n                || SOAPBinding.SOAP12HTTP_MTOM_BINDING.equals(bt.value()))) {\n                features.add(new MTOMFeature(true));\n            }\n        }\n\n\n        Addressing addressing = null;\n        if (implementorClass != null) {\n            addressing = implementorClass.getAnnotation(Addressing.class);\n        }\n\n        if (addressing == null && serviceClass != null) {\n            addressing = serviceClass.getAnnotation(Addressing.class);\n        }\n\n        if (addressing != null) {\n            features.add(new AddressingFeature(addressing.enabled(), \n                                               addressing.required(),\n                                               addressing.responses()));\n        }\n\n        RespectBinding respectBinding = implInfo.getImplementorClass().getAnnotation(\n            RespectBinding.class);\n        if (respectBinding == null && serviceClass != null) {\n            respectBinding = serviceClass.getAnnotation(RespectBinding.class);\n        }\n        if (respectBinding != null) {\n            features.add(new RespectBindingFeature(respectBinding.enabled()));\n        }\n\n        if (features.size() > 0) {\n            wsFeatures = features;\n            if (setWsFeatures != null) {\n                wsFeatures.addAll(setWsFeatures);\n            }\n        } else {\n            wsFeatures = setWsFeatures;\n        }\n    }","commit_id":"bef3d8408feb07365e17ca6960db7b4b2f1436ec","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Group mutually exclusive options together into sets.  Non-exclusive options\n     * will be alone a set.  Every option should appear in exactly one set.\n     * WARNING: Has no concept of nested dependencies.\n     * @param fields list of fields for which to check options.\n     * @return\n     */\n    private List<Set<Field>> groupExclusiveOptions( Field[] fields ) {\n        List<Set<Field>> optionGroups = new ArrayList<Set<Field>>();\n        for(Field field: fields) {\n            Argument argument = field.getAnnotation(Argument.class);\n            if(argument == null)\n                continue;\n\n            String[] exclusives = argument.exclusive().split(\",\");\n            if( exclusives.length != 0 ) {\n                HashSet<Field> matchingFields = new HashSet<Field>();\n\n                // Find the set of all options exclusive to this one.\n                matchingFields.add( field );\n                for( Field candidate: fields ) {\n                    for( String exclusive: exclusives ) {\n                        if( candidate.getName().equals( exclusive.trim() ) )\n                            matchingFields.add( candidate );\n                    }\n                }\n\n                // Perform a set intersection to see whether this set of fields intersects\n                // with any existing set.\n                //\n                // If so, add any additional elements to the list.\n                boolean setExists = false;\n                for( Set<Field> optionGroup: optionGroups ) {\n                    Set<Field> working = new HashSet<Field>(optionGroup);\n                    working.retainAll( matchingFields );\n                    if( working.size() > 0 ) {\n                        optionGroup.addAll( matchingFields );\n                        setExists = true;\n                    }\n                }\n\n                // Otherwise, add a new option group.\n                if( !setExists )\n                    optionGroups.add( matchingFields );\n            }\n        }\n\n        return optionGroups;\n    }","id":38020,"modified_method":"/**\n     * Group mutually exclusive options together into sets.  Non-exclusive options\n     * will be alone a set.  Every option should appear in exactly one set.\n     * WARNING: Has no concept of nested dependencies.\n     * @param fields list of fields for which to check options.\n     * @return groupings of mutually exclusive options.\n     */\n    private List<Set<Field>> groupExclusiveOptions( Field[] fields ) {\n        List<Set<Field>> optionGroups = new ArrayList<Set<Field>>();\n        for(Field field: fields) {\n            Argument argument = field.getAnnotation(Argument.class);\n            if(argument == null)\n                continue;\n\n            String[] exclusives = argument.exclusive().split(\",\");\n            if( exclusives.length != 0 ) {\n                HashSet<Field> matchingFields = new HashSet<Field>();\n\n                // Find the set of all options exclusive to this one.\n                matchingFields.add( field );\n                for( Field candidate: fields ) {\n                    for( String exclusive: exclusives ) {\n                        if( candidate.getName().equals( exclusive.trim() ) )\n                            matchingFields.add( candidate );\n                    }\n                }\n\n                // Perform a set intersection to see whether this set of fields intersects\n                // with any existing set.\n                //\n                // If so, add any additional elements to the list.\n                boolean setExists = false;\n                for( Set<Field> optionGroup: optionGroups ) {\n                    Set<Field> working = new HashSet<Field>(optionGroup);\n                    working.retainAll( matchingFields );\n                    if( working.size() > 0 ) {\n                        optionGroup.addAll( matchingFields );\n                        setExists = true;\n                    }\n                }\n\n                // Otherwise, add a new option group.\n                if( !setExists )\n                    optionGroups.add( matchingFields );\n            }\n        }\n\n        return optionGroups;\n    }","commit_id":"f7097c8ee71f79d91a81ab529e3e5f147952efcd","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Given a field with some annotations, create a command-line option.  If not enough data is\n     * available to create a command-line option, return null.\n     * @param sourceName Source class containing the field.\n     * @param field Field\n     * @return Option representing the field options.\n     */\n    private Option createOptionFromField( String sourceName, Field field, Argument argument ) {\n\n        String fullName = (argument.fullName().length() != 0) ? argument.fullName() : field.getName().trim().toLowerCase();\n        String shortName = (argument.shortName().length() != 0) ? argument.shortName() : fullName.substring(0,1);\n        if(shortName.length() != 1)\n            throw new IllegalArgumentException(\"Invalid short name: \" + shortName);\n        boolean isFlag = (field.getType() == Boolean.class) || (field.getType() == Boolean.TYPE);\n        boolean isCollection = field.getType().isArray() || Collection.class.isAssignableFrom(field.getType());\n\n        if( isFlag && isCollection )\n            throw new IllegalArgumentException(\"Can't have an array of flags.\");\n\n        String description = String.format(\"[%s] %s\", sourceName, argument.doc());\n\n        OptionBuilder ob = OptionBuilder.withLongOpt(fullName);\n        if( !isFlag ) {\n            ob = ob.withArgName(fullName);\n            ob = isCollection ? ob.hasArgs() : ob.hasArg();\n        }\n        if( argument.required() ) {\n            ob = ob.isRequired();\n            description = String.format(\"[%s] (Required Option) %s\", sourceName, argument.doc());\n        }\n        if( description.length() != 0 ) ob = ob.withDescription( description );\n\n        Option option = ob.create( shortName );\n\n        return option;\n    }","id":38021,"modified_method":"/**\n     * Given a field with some annotations, create a command-line option.  If not enough data is\n     * available to create a command-line option, return null.\n     * @param sourceName Source class containing the field.\n     * @param field Field\n     * @return Option representing the field options.\n     */\n    private Option createOptionFromField( String sourceName, Field field, Argument argument ) {\n\n        String fullName = (argument.fullName().length() != 0) ? argument.fullName() : field.getName().trim().toLowerCase();\n        String shortName = (argument.shortName().length() != 0) ? argument.shortName() : fullName.substring(0,1);\n        if(shortName.length() != 1)\n            throw new IllegalArgumentException(\"Invalid short name: \" + shortName);\n        String description = argument.doc();\n        boolean isRequired = argument.required();\n        boolean isFlag = (field.getType() == Boolean.class) || (field.getType() == Boolean.TYPE);\n        boolean isCollection = field.getType().isArray() || Collection.class.isAssignableFrom(field.getType());\n\n        if( isFlag && isCollection )\n            throw new IllegalArgumentException(\"Can't have an array of flags.\");\n\n        OptionBuilder.withLongOpt(fullName);\n        if( !isFlag ) {\n            OptionBuilder.withArgName(fullName);\n            if( isCollection )\n                OptionBuilder.hasArgs();\n            else\n                OptionBuilder.hasArg();\n        }\n        if( isRequired ) {\n            OptionBuilder.isRequired();\n            description = String.format(\"(Required Option) %s\", description);\n        }\n\n        sourceName = sourceName.trim();\n        if( sourceName.length() > 0 )\n            description = String.format(\"[%s] %s\", sourceName, description );\n\n        if( description.length() != 0 ) OptionBuilder.withDescription( description );\n\n        return OptionBuilder.create( shortName );\n    }","commit_id":"f7097c8ee71f79d91a81ab529e3e5f147952efcd","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Object constructFromString(Field f, String[] strs) {\n        Class type = f.getType();\n\n        if( Collection.class.isAssignableFrom(type) ) {\n            Collection collection = null;\n            Class containedType = null;\n\n            // If this is a parameterized collection, find the contained type.  If blow up if only one type exists.\n            if( f.getGenericType() instanceof ParameterizedType ) {\n                ParameterizedType parameterizedType = (ParameterizedType)f.getGenericType();\n                if( parameterizedType.getActualTypeArguments().length > 1 )\n                    throw new IllegalArgumentException(\"Unable to determine collection type of field: \" + f.toString());\n                containedType = (Class)parameterizedType.getActualTypeArguments()[0];\n            }\n            else\n                containedType = String.class;\n\n            // If this is a generic interface, pick a concrete implementation to create and pass back.\n            // Because of type erasure, don't worry about creating one of exactly the correct type.\n            if( Modifier.isInterface(type.getModifiers()) || Modifier.isAbstract(type.getModifiers()) )\n            {\n                if( java.util.List.class.isAssignableFrom(type) ) type = ArrayList.class;\n                else if( java.util.Queue.class.isAssignableFrom(type) ) type = java.util.ArrayDeque.class;\n                else if( java.util.Set.class.isAssignableFrom(type) ) type = java.util.TreeSet.class;\n            }\n\n            try\n            {\n                collection = (Collection)type.newInstance();\n            }\n            catch( Exception ex ) {\n                // Runtime exceptions are definitely unexpected parsing simple collection classes.\n                throw new IllegalArgumentException(ex);\n            }\n\n            for( String str: strs )\n                collection.add( constructSingleElement(f,containedType,str) );\n\n            return collection;\n        }\n        else if( type.isArray() ) {\n            Class containedType = type.getComponentType();\n\n            Object arr = Array.newInstance(containedType,strs.length);\n            for( int i = 0; i < strs.length; i++ )\n                Array.set( arr,i,constructSingleElement(f,containedType,strs[i]) );\n            return arr;\n        }\n        else  {\n            if( strs.length != 1 )\n                throw new IllegalArgumentException(\"Passed multiple arguments to an object expecting a single value.\");\n            return constructSingleElement(f,type,strs[0]);\n        }\n    }","id":38022,"modified_method":"/**\n     * Constructs a command-line argument given a string and field.\n     * @param f Field type from which to infer the type.\n     * @param strs Collection of parameter strings to parse.\n     * @return Parsed object of the inferred type.\n     */\n    private Object constructFromString(Field f, String[] strs) {\n        Class type = f.getType();\n\n        if( Collection.class.isAssignableFrom(type) ) {\n            Collection collection = null;\n            Class containedType = null;\n\n            // If this is a parameterized collection, find the contained type.  If blow up if only one type exists.\n            if( f.getGenericType() instanceof ParameterizedType ) {\n                ParameterizedType parameterizedType = (ParameterizedType)f.getGenericType();\n                if( parameterizedType.getActualTypeArguments().length > 1 )\n                    throw new IllegalArgumentException(\"Unable to determine collection type of field: \" + f.toString());\n                containedType = (Class)parameterizedType.getActualTypeArguments()[0];\n            }\n            else\n                containedType = String.class;\n\n            // If this is a generic interface, pick a concrete implementation to create and pass back.\n            // Because of type erasure, don't worry about creating one of exactly the correct type.\n            if( Modifier.isInterface(type.getModifiers()) || Modifier.isAbstract(type.getModifiers()) )\n            {\n                if( java.util.List.class.isAssignableFrom(type) ) type = ArrayList.class;\n                else if( java.util.Queue.class.isAssignableFrom(type) ) type = java.util.ArrayDeque.class;\n                else if( java.util.Set.class.isAssignableFrom(type) ) type = java.util.TreeSet.class;\n            }\n\n            try\n            {\n                collection = (Collection)type.newInstance();\n            }\n            catch( Exception ex ) {\n                // Runtime exceptions are definitely unexpected parsing simple collection classes.\n                throw new IllegalArgumentException(ex);\n            }\n\n            for( String str: strs )\n                collection.add( constructSingleElement(f,containedType,str) );\n\n            return collection;\n        }\n        else if( type.isArray() ) {\n            Class containedType = type.getComponentType();\n\n            Object arr = Array.newInstance(containedType,strs.length);\n            for( int i = 0; i < strs.length; i++ )\n                Array.set( arr,i,constructSingleElement(f,containedType,strs[i]) );\n            return arr;\n        }\n        else  {\n            if( strs.length != 1 )\n                throw new IllegalArgumentException(\"Passed multiple arguments to an object expecting a single value.\");\n            return constructSingleElement(f,type,strs[0]);\n        }\n    }","commit_id":"f7097c8ee71f79d91a81ab529e3e5f147952efcd","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected boolean isParentUnsynced(SyncFile syncFile) {\n\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (FileUtil.isUnsynced(filePath.getParent())) {\n\t\t\tif (syncFile.isFolder()) {\n\t\t\t\tsyncFile.setFilePathName(filePath.toString());\n\t\t\t\tsyncFile.setModifiedTime(0);\n\t\t\t\tsyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\t\t\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\n\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":38023,"modified_method":"protected boolean isParentUnsynced(SyncFile syncFile) {\n\t\tPath filePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (FileUtil.isUnsynced(filePath.getParent())) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void moveFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString targetFilePathName)\n\t\tthrows Exception {\n\n\t\tif (isParentUnsynced(targetSyncFile)) {\n\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\t\tPath targetFilePath = Paths.get(targetFilePathName);\n\n\t\tsourceSyncFile = SyncFileService.updateSyncFile(\n\t\t\ttargetFilePath, targetSyncFile.getParentFolderId(), sourceSyncFile);\n\n\t\tif (sourceSyncFile.isUnsynced()) {\n\t\t\tList<SyncFile> syncFiles = new ArrayList<>();\n\n\t\t\tsyncFiles.add(sourceSyncFile);\n\n\t\t\tSyncFileService.resyncFolders(syncFiles);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\tFileUtil.moveFile(sourceFilePath, targetFilePath);\n\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t}\n\t\telse if (targetSyncFile.isFolder()) {\n\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\ttargetFilePath, String.valueOf(sourceSyncFile.getSyncFileId()),\n\t\t\t\tfalse);\n\t\t}\n\t\telse {\n\t\t\tdownloadFile(sourceSyncFile, null, 0, false);\n\t\t}\n\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_MOVED_REMOTE);\n\n\t\tSyncFileService.update(sourceSyncFile);\n\t}","id":38024,"modified_method":"protected void moveFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString targetFilePathName)\n\t\tthrows Exception {\n\n\t\tPath targetFilePath = Paths.get(targetFilePathName);\n\n\t\tif (isParentUnsynced(targetSyncFile)) {\n\t\t\tif (sourceSyncFile.isFolder()) {\n\t\t\t\tList<SyncFile> syncFiles = new ArrayList<>();\n\n\t\t\t\tsyncFiles.add(sourceSyncFile);\n\n\t\t\t\tList<SyncFile> childSyncFiles = SyncFileService.findSyncFiles(\n\t\t\t\t\tsourceSyncFile.getFilePathName());\n\n\t\t\t\tsyncFiles.addAll(childSyncFiles);\n\n\t\t\t\tSyncFileService.unsyncFolders(getSyncAccountId(), syncFiles);\n\n\t\t\t\tsourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\tsourceSyncFile.getSyncFileId());\n\n\t\t\t\tSyncFileService.updateSyncFile(\n\t\t\t\t\ttargetFilePath, targetSyncFile.getParentFolderId(),\n\t\t\t\t\tsourceSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (sourceSyncFile.isUnsynced()) {\n\t\t\tif (!isParentUnsynced(sourceSyncFile)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tList<SyncFile> syncFiles = new ArrayList<>();\n\n\t\t\tsyncFiles.add(sourceSyncFile);\n\n\t\t\tList<SyncFile> childSyncFiles = SyncFileService.findSyncFiles(\n\t\t\t\tsourceSyncFile.getFilePathName());\n\n\t\t\tsyncFiles.addAll(childSyncFiles);\n\n\t\t\tSyncFileService.resyncFolders(getSyncAccountId(), syncFiles);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tsourceSyncFile = SyncFileService.updateSyncFile(\n\t\t\ttargetFilePath, targetSyncFile.getParentFolderId(), sourceSyncFile);\n\n\t\tif (Files.exists(sourceFilePath)) {\n\t\t\tFileUtil.moveFile(sourceFilePath, targetFilePath);\n\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t}\n\t\telse if (targetSyncFile.isFolder()) {\n\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\ttargetFilePath, String.valueOf(sourceSyncFile.getSyncFileId()),\n\t\t\t\tfalse);\n\t\t}\n\t\telse {\n\t\t\tdownloadFile(sourceSyncFile, null, 0, false);\n\t\t}\n\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_MOVED_REMOTE);\n\n\t\tSyncFileService.update(sourceSyncFile);\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processSyncFile(SyncFile targetSyncFile) {\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getParentFolderId());\n\n\t\tif (parentSyncFile == null) {\n\t\t\tqueueSyncFile(targetSyncFile.getParentFolderId(), targetSyncFile);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString filePathName = \"\";\n\n\t\ttry {\n\t\t\tfilePathName = FileUtil.getFilePathName(\n\t\t\t\tparentSyncFile.getFilePathName(),\n\t\t\t\tFileUtil.getSanitizedFileName(\n\t\t\t\t\ttargetSyncFile.getName(), targetSyncFile.getExtension()));\n\n\t\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\ttargetSyncFile.getTypePK());\n\n\t\t\tif (isIgnoredFilePath(sourceSyncFile, filePathName) ||\n\t\t\t\t((sourceSyncFile != null) &&\n\t\t\t\t (sourceSyncFile.getModifiedTime() ==\n\t\t\t\t\t targetSyncFile.getModifiedTime()))) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (sourceSyncFile != null) {\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t}\n\n\t\t\ttargetSyncFile.setFilePathName(filePathName);\n\t\t\ttargetSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\t\tString event = targetSyncFile.getEvent();\n\n\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_GET)) {\n\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_DELETE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (sourceSyncFile.getParentFolderId() ==\n\t\t\t\t\t\t\ttargetSyncFile.getParentFolderId()) {\n\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmoveFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_RESTORE)) {\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (isParentUnsynced(targetSyncFile)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetSyncFile.setLocalExtraSetting(\"restoreEvent\", true);\n\n\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_TRASH)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprocessDependentSyncFiles(targetSyncFile);\n\n\t\t\tif (getParameterValue(\"parentFolderId\") != null) {\n\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId(),\n\t\t\t\t\t(Long)getParameterValue(\"parentFolderId\"));\n\n\t\t\t\tif (syncFile != null) {\n\t\t\t\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_RESYNCING);\n\n\t\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (FileSystemException fse) {\n\t\t\tString message = fse.getMessage();\n\n\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(e.getMessage(), e);\n\t\t}\n\t}","id":38025,"modified_method":"protected void processSyncFile(SyncFile targetSyncFile) {\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getParentFolderId());\n\n\t\tif (parentSyncFile == null) {\n\t\t\tqueueSyncFile(targetSyncFile.getParentFolderId(), targetSyncFile);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString filePathName = \"\";\n\n\t\ttry {\n\t\t\tfilePathName = FileUtil.getFilePathName(\n\t\t\t\tparentSyncFile.getFilePathName(),\n\t\t\t\tFileUtil.getSanitizedFileName(\n\t\t\t\t\ttargetSyncFile.getName(), targetSyncFile.getExtension()));\n\n\t\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\t\ttargetSyncFile.getTypePK());\n\n\t\t\tif (isIgnoredFilePath(sourceSyncFile, filePathName) ||\n\t\t\t\t((sourceSyncFile != null) &&\n\t\t\t\t (sourceSyncFile.getModifiedTime() ==\n\t\t\t\t\t targetSyncFile.getModifiedTime()))) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((sourceSyncFile != null) && !sourceSyncFile.isUnsynced()) {\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t}\n\n\t\t\ttargetSyncFile.setFilePathName(filePathName);\n\t\t\ttargetSyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\n\t\t\tString event = targetSyncFile.getEvent();\n\n\t\t\tif (event.equals(SyncFile.EVENT_ADD) ||\n\t\t\t\tevent.equals(SyncFile.EVENT_GET)) {\n\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_DELETE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_MOVE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (sourceSyncFile.getParentFolderId() ==\n\t\t\t\t\t\t\ttargetSyncFile.getParentFolderId()) {\n\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmoveFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_RESTORE)) {\n\t\t\t\tif (sourceSyncFile != null) {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse if (isParentUnsynced(targetSyncFile)) {\n\t\t\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\t\t\ttargetSyncFile.setModifiedTime(0);\n\t\t\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\t\t\t\ttargetSyncFile.setSyncAccountId(getSyncAccountId());\n\t\t\t\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttargetSyncFile.setLocalExtraSetting(\"restoreEvent\", true);\n\n\t\t\t\t\tSyncFileService.update(targetSyncFile);\n\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_TRASH)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdeleteFile(sourceSyncFile, targetSyncFile);\n\t\t\t}\n\t\t\telse if (event.equals(SyncFile.EVENT_UPDATE)) {\n\t\t\t\tif (sourceSyncFile == null) {\n\t\t\t\t\taddFile(targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tupdateFile(sourceSyncFile, targetSyncFile, filePathName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprocessDependentSyncFiles(targetSyncFile);\n\n\t\t\tif (getParameterValue(\"parentFolderId\") != null) {\n\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\t(Long)getParameterValue(\"repositoryId\"), getSyncAccountId(),\n\t\t\t\t\t(Long)getParameterValue(\"parentFolderId\"));\n\n\t\t\t\tif (syncFile != null) {\n\t\t\t\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_RESYNCING);\n\n\t\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (FileSystemException fse) {\n\t\t\tString message = fse.getMessage();\n\n\t\t\tif (message.contains(\"File name too long\")) {\n\t\t\t\ttargetSyncFile.setState(SyncFile.STATE_ERROR);\n\t\t\t\ttargetSyncFile.setUiEvent(SyncFile.UI_EVENT_FILE_NAME_TOO_LONG);\n\n\t\t\t\tSyncFileService.update(targetSyncFile);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(e.getMessage(), e);\n\t\t}\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addFile(SyncFile syncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tif (isParentUnsynced(syncFile) ||\n\t\t\t(Files.exists(filePath) &&\n\t\t\t (syncFile.isFolder() ||\n\t\t\t  !FileUtil.isModified(syncFile, filePath)))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\n\t\tif (syncFile.isFolder()) {\n\t\t\tFiles.createDirectories(filePath);\n\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_ADDED_REMOTE);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\tfilePath, String.valueOf(syncFile.getSyncFileId()), false);\n\t\t}\n\t\telse {\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tdownloadFile(syncFile, null, 0, false);\n\t\t}\n\t}","id":38026,"modified_method":"protected void addFile(SyncFile syncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tif (isParentUnsynced(syncFile)) {\n\t\t\tif (syncFile.isFolder()) {\n\t\t\t\tsyncFile.setFilePathName(filePath.toString());\n\t\t\t\tsyncFile.setModifiedTime(0);\n\t\t\t\tsyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\t\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\t\tSyncFileService.update(syncFile);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (Files.exists(filePath) &&\n\t\t\t(syncFile.isFolder() || !FileUtil.isModified(syncFile, filePath))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\n\t\tif (syncFile.isFolder()) {\n\t\t\tFiles.createDirectories(filePath);\n\n\t\t\tsyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_ADDED_REMOTE);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\tfilePath, String.valueOf(syncFile.getSyncFileId()), false);\n\t\t}\n\t\telse {\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_DOWNLOADING);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tdownloadFile(syncFile, null, 0, false);\n\t\t}\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString filePathName)\n\t\tthrows Exception {\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\t\tlong sourceVersionId = sourceSyncFile.getVersionId();\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUserId(targetSyncFile.getUserId());\n\t\tsourceSyncFile.setUserName(targetSyncFile.getUserName());\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\t\tsourceSyncFile.setVersionId(targetSyncFile.getVersionId());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (isParentUnsynced(sourceSyncFile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPath filePath = Paths.get(targetSyncFile.getFilePathName());\n\n\t\tif (!Files.exists(filePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\t\ttargetFilePath,\n\t\t\t\t\tString.valueOf(sourceSyncFile.getSyncFileId()), false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, 0, false);\n\t\t\t}\n\t\t}\n\t\telse if (targetSyncFile.isFile() &&\n\t\t\t\t FileUtil.isModified(targetSyncFile, filePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion, sourceVersionId,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t\telse {\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tif (filePathChanged) {\n\t\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_RENAMED_REMOTE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\t\t\t}\n\n\t\t\tSyncFileService.update(sourceSyncFile);\n\t\t}\n\t}","id":38027,"modified_method":"protected void updateFile(\n\t\t\tSyncFile sourceSyncFile, SyncFile targetSyncFile,\n\t\t\tString filePathName)\n\t\tthrows Exception {\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\t\tlong sourceVersionId = sourceSyncFile.getVersionId();\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUserId(targetSyncFile.getUserId());\n\t\tsourceSyncFile.setUserName(targetSyncFile.getUserName());\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\t\tsourceSyncFile.setVersionId(targetSyncFile.getVersionId());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (isParentUnsynced(sourceSyncFile) || sourceSyncFile.isUnsynced()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPath filePath = Paths.get(targetSyncFile.getFilePathName());\n\n\t\tif (!Files.exists(filePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\t\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tFileKeyUtil.writeFileKey(\n\t\t\t\t\ttargetFilePath,\n\t\t\t\t\tString.valueOf(sourceSyncFile.getSyncFileId()), false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, 0, false);\n\t\t\t}\n\t\t}\n\t\telse if (targetSyncFile.isFile() &&\n\t\t\t\t FileUtil.isModified(targetSyncFile, filePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion, sourceVersionId,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t\telse {\n\t\t\tsourceSyncFile.setState(SyncFile.STATE_SYNCED);\n\n\t\t\tif (filePathChanged) {\n\t\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_RENAMED_REMOTE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\t\t\t}\n\n\t\t\tSyncFileService.update(sourceSyncFile);\n\t\t}\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deleteFile(SyncFile sourceSyncFile, SyncFile targetSyncFile)\n\t\tthrows Exception {\n\n\t\tif (sourceSyncFile.getUiEvent() == SyncFile.UI_EVENT_DELETED_LOCAL) {\n\t\t\treturn;\n\t\t}\n\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\n\t\tif (targetSyncFile.getEvent() == SyncFile.EVENT_TRASH) {\n\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_TRASHED_REMOTE);\n\t\t}\n\t\telse {\n\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_REMOTE);\n\t\t}\n\n\t\tSyncFileService.deleteSyncFile(sourceSyncFile);\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tif (Files.notExists(sourceFilePath)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Watcher watcher = WatcherManager.getWatcher(getSyncAccountId());\n\n\t\tif (sourceSyncFile.isFile()) {\n\t\t\twatcher.addDeletedFilePathName(sourceSyncFile.getFilePathName());\n\n\t\t\tFileUtil.deleteFile(sourceFilePath);\n\n\t\t\treturn;\n\t\t}\n\n\t\tFiles.walkFileTree(\n\t\t\tsourceFilePath,\n\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult postVisitDirectory(\n\t\t\t\t\t\tPath filePath, IOException ioe)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\tif (ioe != null) {\n\t\t\t\t\t\treturn super.postVisitDirectory(filePath, ioe);\n\t\t\t\t\t}\n\n\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult preVisitDirectory(\n\t\t\t\t\t\tPath filePath, BasicFileAttributes basicFileAttributes)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\twatcher.unregisterFilePath(filePath);\n\n\t\t\t\t\treturn super.preVisitDirectory(\n\t\t\t\t\t\tfilePath, basicFileAttributes);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile(\n\t\t\t\t\t\tPath filePath, BasicFileAttributes basicFileAttributes)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t});\n\t}","id":38028,"modified_method":"protected void deleteFile(SyncFile sourceSyncFile, SyncFile targetSyncFile)\n\t\tthrows Exception {\n\n\t\tif (sourceSyncFile.getUiEvent() == SyncFile.UI_EVENT_DELETED_LOCAL) {\n\t\t\treturn;\n\t\t}\n\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\n\t\tif (targetSyncFile.getEvent() == SyncFile.EVENT_TRASH) {\n\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_TRASHED_REMOTE);\n\t\t}\n\t\telse {\n\t\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_DELETED_REMOTE);\n\t\t}\n\n\t\tif (!sourceSyncFile.isUnsynced()) {\n\t\t\tSyncFileService.deleteSyncFile(sourceSyncFile);\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tif (Files.notExists(sourceFilePath)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Watcher watcher = WatcherManager.getWatcher(getSyncAccountId());\n\n\t\tif (sourceSyncFile.isFile()) {\n\t\t\twatcher.addDeletedFilePathName(sourceSyncFile.getFilePathName());\n\n\t\t\tFileUtil.deleteFile(sourceFilePath);\n\n\t\t\treturn;\n\t\t}\n\n\t\tFiles.walkFileTree(\n\t\t\tsourceFilePath,\n\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult postVisitDirectory(\n\t\t\t\t\t\tPath filePath, IOException ioe)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\tif (ioe != null) {\n\t\t\t\t\t\treturn super.postVisitDirectory(filePath, ioe);\n\t\t\t\t\t}\n\n\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult preVisitDirectory(\n\t\t\t\t\t\tPath filePath, BasicFileAttributes basicFileAttributes)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\twatcher.unregisterFilePath(filePath);\n\n\t\t\t\t\treturn super.preVisitDirectory(\n\t\t\t\t\t\tfilePath, basicFileAttributes);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile(\n\t\t\t\t\t\tPath filePath, BasicFileAttributes basicFileAttributes)\n\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void unsyncFolders(List<SyncFile> syncFiles)\n\t\tthrows Exception {\n\n\t\tSet<Long> unsyncedSyncFileIds = new HashSet<>();\n\n\t\tsyncFiles.sort(_syncFileFilePathNameComparator);\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tSyncFile localSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\tif (localSyncFile != null) {\n\t\t\t\tif (localSyncFile.getState() == SyncFile.STATE_UNSYNCED) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsyncFile = localSyncFile;\n\t\t\t}\n\n\t\t\tsyncFile.setModifiedTime(0);\n\t\t\tsyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tif (isAncestorInList(syncFile, unsyncedSyncFileIds) ||\n\t\t\t\t!Files.exists(Paths.get(syncFile.getFilePathName()))) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal Watcher watcher = WatcherManager.getWatcher(\n\t\t\t\tsyncFile.getSyncAccountId());\n\n\t\t\tFiles.walkFileTree(\n\t\t\t\tPaths.get(syncFile.getFilePathName()),\n\t\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult postVisitDirectory(\n\t\t\t\t\t\t\tPath filePath, IOException ioe)\n\t\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\t\tif (ioe != null) {\n\t\t\t\t\t\t\treturn super.postVisitDirectory(filePath, ioe);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult visitFile(\n\t\t\t\t\t\t\tPath filePath,\n\t\t\t\t\t\t\tBasicFileAttributes basicFileAttributes)\n\t\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\t\tSyncFile childSyncFile = fetchSyncFile(\n\t\t\t\t\t\t\tfilePath.toString());\n\n\t\t\t\t\t\tif (childSyncFile != null) {\n\t\t\t\t\t\t\tdeleteSyncFile(childSyncFile, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\tunsyncedSyncFileIds.add(syncFile.getSyncFileId());\n\t\t}\n\t}","id":38029,"modified_method":"public static void unsyncFolders(\n\t\t\tlong syncAccountId, List<SyncFile> syncFiles)\n\t\tthrows Exception {\n\n\t\tSet<Long> unsyncedSyncFileIds = new HashSet<>();\n\n\t\tCollections.sort(syncFiles, _syncFileFilePathNameComparator);\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tSyncFile localSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\tif (localSyncFile != null) {\n\t\t\t\tif (localSyncFile.getState() == SyncFile.STATE_UNSYNCED) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsyncFile = localSyncFile;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncFile.setSyncAccountId(syncAccountId);\n\t\t\t}\n\n\t\t\tsyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_NONE);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tif (isAncestorInList(syncFile, unsyncedSyncFileIds) ||\n\t\t\t\t!Files.exists(Paths.get(syncFile.getFilePathName()))) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal Watcher watcher = WatcherManager.getWatcher(\n\t\t\t\tsyncFile.getSyncAccountId());\n\n\t\t\tFiles.walkFileTree(\n\t\t\t\tPaths.get(syncFile.getFilePathName()),\n\t\t\t\tnew SimpleFileVisitor<Path>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult postVisitDirectory(\n\t\t\t\t\t\t\tPath filePath, IOException ioe)\n\t\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\t\tif (ioe != null) {\n\t\t\t\t\t\t\treturn super.postVisitDirectory(filePath, ioe);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult visitFile(\n\t\t\t\t\t\t\tPath filePath,\n\t\t\t\t\t\t\tBasicFileAttributes basicFileAttributes)\n\t\t\t\t\t\tthrows IOException {\n\n\t\t\t\t\t\twatcher.addDeletedFilePathName(filePath.toString());\n\n\t\t\t\t\t\tFileUtil.deleteFile(filePath);\n\n\t\t\t\t\t\tSyncFile childSyncFile = fetchSyncFile(\n\t\t\t\t\t\t\tfilePath.toString());\n\n\t\t\t\t\t\tif (childSyncFile != null) {\n\t\t\t\t\t\t\tdeleteSyncFile(childSyncFile, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\tunsyncedSyncFileIds.add(syncFile.getSyncFileId());\n\t\t}\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncFile renameFolderSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tupdateSyncFile(filePath, syncFile.getParentFolderId(), syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t(syncFile.getState() != SyncFile.STATE_UNSYNCED)) {\n\n\t\t\tFileEventUtil.updateFolder(filePath, syncAccountId, syncFile);\n\t\t}\n\n\t\treturn syncFile;\n\t}","id":38030,"modified_method":"public static SyncFile renameFolderSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tupdateSyncFile(filePath, syncFile.getParentFolderId(), syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t!syncFile.isUnsynced()) {\n\n\t\t\tFileEventUtil.updateFolder(filePath, syncAccountId, syncFile);\n\t\t}\n\n\t\treturn syncFile;\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncFile updateFolderSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tupdateSyncFile(filePath, syncFile.getParentFolderId(), syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t(syncFile.getState() != SyncFile.STATE_UNSYNCED)) {\n\n\t\t\tFileEventUtil.updateFolder(filePath, syncAccountId, syncFile);\n\t\t}\n\n\t\treturn syncFile;\n\t}","id":38031,"modified_method":"public static SyncFile updateFolderSyncFile(\n\t\t\tPath filePath, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tupdateSyncFile(filePath, syncFile.getParentFolderId(), syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t!syncFile.isUnsynced()) {\n\n\t\t\tFileEventUtil.updateFolder(filePath, syncAccountId, syncFile);\n\t\t}\n\n\t\treturn syncFile;\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncFile moveFileSyncFile(\n\t\t\tPath filePath, long folderId, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tSyncFile targetSyncFile = fetchSyncFile(filePath.toString());\n\n\t\tif (targetSyncFile != null) {\n\t\t\tdeleteSyncFile(targetSyncFile, false);\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePath.toString());\n\t\tsyncFile.setParentFolderId(folderId);\n\n\t\tupdate(syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t(syncFile.getState() != SyncFile.STATE_UNSYNCED)) {\n\n\t\t\tFileEventUtil.moveFile(folderId, syncAccountId, syncFile);\n\t\t}\n\n\t\treturn syncFile;\n\t}","id":38032,"modified_method":"public static SyncFile moveFileSyncFile(\n\t\t\tPath filePath, long folderId, long syncAccountId, SyncFile syncFile)\n\t\tthrows Exception {\n\n\t\t// Local sync file\n\n\t\tSyncFile targetSyncFile = fetchSyncFile(filePath.toString());\n\n\t\tif (targetSyncFile != null) {\n\t\t\tdeleteSyncFile(targetSyncFile, false);\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePath.toString());\n\t\tsyncFile.setParentFolderId(folderId);\n\n\t\tupdate(syncFile);\n\n\t\t// Remote sync file\n\n\t\tif ((syncFile.getState() != SyncFile.STATE_ERROR) &&\n\t\t\t!syncFile.isUnsynced()) {\n\n\t\t\tFileEventUtil.moveFile(folderId, syncAccountId, syncFile);\n\t\t}\n\n\t\treturn syncFile;\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteSyncFiles(\n\t\tfinal SyncFile syncFile, final boolean notify) {\n\n\t\ttry {\n\t\t\tif (!syncFile.isFolder()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCallable<Object> callable = new Callable<Object>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tList<SyncFile> childSyncFiles =\n\t\t\t\t\t\t_syncFilePersistence.findByParentFilePathName(\n\t\t\t\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\t\t\tfor (SyncFile childSyncFile : childSyncFiles) {\n\t\t\t\t\t\tif (childSyncFile.isSystem()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchildSyncFile.setModifiedTime(\n\t\t\t\t\t\t\tsyncFile.getModifiedTime());\n\t\t\t\t\t\tchildSyncFile.setUiEvent(syncFile.getUiEvent());\n\n\t\t\t\t\t\tdoDeleteSyncFile(childSyncFile, notify);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_syncFilePersistence.callBatchTasks(callable);\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(sqle.getMessage(), sqle);\n\t\t\t}\n\t\t}\n\t}","id":38033,"modified_method":"public static void deleteSyncFiles(\n\t\tfinal SyncFile syncFile, final boolean notify) {\n\n\t\ttry {\n\t\t\tif (!syncFile.isFolder()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCallable<Object> callable = new Callable<Object>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tList<SyncFile> childSyncFiles = findSyncFiles(\n\t\t\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\t\t\tfor (SyncFile childSyncFile : childSyncFiles) {\n\t\t\t\t\t\tif (childSyncFile.isSystem()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchildSyncFile.setModifiedTime(\n\t\t\t\t\t\t\tsyncFile.getModifiedTime());\n\t\t\t\t\t\tchildSyncFile.setUiEvent(syncFile.getUiEvent());\n\n\t\t\t\t\t\tdoDeleteSyncFile(childSyncFile, notify);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_syncFilePersistence.callBatchTasks(callable);\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(sqle.getMessage(), sqle);\n\t\t\t}\n\t\t}\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void resyncFolders(List<SyncFile> syncFiles)\n\t\tthrows Exception {\n\n\t\tMap<Long, SyncFile> resyncedSyncFileMap = new HashMap<>();\n\n\t\tSet<Long> resyncedSyncFileIds = resyncedSyncFileMap.keySet();\n\n\t\tsyncFiles.sort(_syncFileFilePathNameComparator);\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tSyncFile localSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\tif (localSyncFile != null) {\n\t\t\t\tif (localSyncFile.getState() != SyncFile.STATE_UNSYNCED) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsyncFile = localSyncFile;\n\t\t\t}\n\n\t\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_RESYNCING);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tif (isAncestorInList(syncFile, resyncedSyncFileIds)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresyncedSyncFileMap.put(syncFile.getTypePK(), syncFile);\n\t\t}\n\n\t\t// Remote\n\n\t\tfor (SyncFile syncFile : resyncedSyncFileMap.values()) {\n\t\t\tFileEventUtil.resyncFolder(syncFile.getSyncAccountId(), syncFile);\n\t\t}\n\t}","id":38034,"modified_method":"public static void resyncFolders(\n\t\t\tlong syncAccountId, List<SyncFile> syncFiles)\n\t\tthrows Exception {\n\n\t\tMap<Long, SyncFile> resyncedSyncFileMap = new HashMap<>();\n\n\t\tSet<Long> resyncedSyncFileIds = resyncedSyncFileMap.keySet();\n\n\t\tCollections.sort(syncFiles, _syncFileFilePathNameComparator);\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tSyncFile localSyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tsyncFile.getFilePathName());\n\n\t\t\tif (localSyncFile != null) {\n\t\t\t\tif (localSyncFile.getState() != SyncFile.STATE_UNSYNCED) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsyncFile = localSyncFile;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncFile.setSyncAccountId(syncAccountId);\n\t\t\t}\n\n\t\t\tsyncFile.setModifiedTime(0);\n\t\t\tsyncFile.setState(SyncFile.STATE_IN_PROGRESS);\n\t\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_RESYNCING);\n\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tif (isAncestorInList(syncFile, resyncedSyncFileIds)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresyncedSyncFileMap.put(syncFile.getTypePK(), syncFile);\n\t\t}\n\n\t\t// Remote\n\n\t\tfor (SyncFile syncFile : resyncedSyncFileMap.values()) {\n\t\t\tFileEventUtil.resyncFolder(syncFile.getSyncAccountId(), syncFile);\n\t\t}\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void testResyncFolders(\n\t\t\tint[] syncFileStates, int expectedExecutionCount,\n\t\t\tint expectedModifiedCount)\n\t\tthrows Exception {\n\n\t\tList<SyncFile> syncFiles = new ArrayList<>();\n\n\t\tSyncFile folderSyncFileA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\"), syncFileStates[0],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileA);\n\n\t\tSyncFile folderSyncFileAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncFileStates[1],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAA);\n\n\t\tSyncFile folderSyncFileAB = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"b\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncFileStates[2],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAB);\n\n\t\tSyncFile folderSyncFileAAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\", \"a\"),\n\t\t\tfolderSyncFileAA.getTypePK(), syncFileStates[3],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAAA);\n\n\t\tSyncFilePersistence syncFilePersistence =\n\t\t\tSyncFileService.getSyncFilePersistence();\n\n\t\tPowerMockito.mockStatic(FileEventUtil.class);\n\n\t\tSyncFileService.resyncFolders(syncFiles);\n\n\t\tPowerMockito.verifyStatic(Mockito.times(expectedExecutionCount));\n\n\t\tFileEventUtil.resyncFolder(\n\t\t\tMockito.anyLong(), Mockito.any(SyncFile.class));\n\n\t\tList<SyncFile> resyncingSyncFiles = syncFilePersistence.queryForEq(\n\t\t\t\"uiEvent\", SyncFile.UI_EVENT_RESYNCING);\n\n\t\tAssert.assertEquals(expectedModifiedCount, resyncingSyncFiles.size());\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tsyncFilePersistence.delete(syncFile);\n\t\t}\n\n\t\tFileUtils.deleteDirectory(new File(folderSyncFileA.getFilePathName()));\n\t}","id":38035,"modified_method":"protected void testResyncFolders(\n\t\t\tint[] syncFileStates, int expectedExecutionCount,\n\t\t\tint expectedModifiedCount)\n\t\tthrows Exception {\n\n\t\tList<SyncFile> syncFiles = new ArrayList<>();\n\n\t\tSyncFile folderSyncFileA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\"), syncFileStates[0],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileA);\n\n\t\tSyncFile folderSyncFileAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncFileStates[1],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAA);\n\n\t\tSyncFile folderSyncFileAB = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"b\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncFileStates[2],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAB);\n\n\t\tSyncFile folderSyncFileAAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\", \"a\"),\n\t\t\tfolderSyncFileAA.getTypePK(), syncFileStates[3],\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAAA);\n\n\t\tSyncFilePersistence syncFilePersistence =\n\t\t\tSyncFileService.getSyncFilePersistence();\n\n\t\tPowerMockito.mockStatic(FileEventUtil.class);\n\n\t\tSyncFileService.resyncFolders(\n\t\t\tsyncAccount.getSyncAccountId(), syncFiles);\n\n\t\tPowerMockito.verifyStatic(Mockito.times(expectedExecutionCount));\n\n\t\tFileEventUtil.resyncFolder(\n\t\t\tMockito.anyLong(), Mockito.any(SyncFile.class));\n\n\t\tList<SyncFile> resyncingSyncFiles = syncFilePersistence.queryForEq(\n\t\t\t\"uiEvent\", SyncFile.UI_EVENT_RESYNCING);\n\n\t\tAssert.assertEquals(expectedModifiedCount, resyncingSyncFiles.size());\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tsyncFilePersistence.delete(syncFile);\n\t\t}\n\n\t\tFileUtils.deleteDirectory(new File(folderSyncFileA.getFilePathName()));\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUnsyncFolders() throws Exception {\n\t\tList<SyncFile> syncFiles = new ArrayList<>();\n\n\t\tSyncFile folderSyncFileA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\"),\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileA);\n\n\t\tSyncFile folderSyncFileAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAA);\n\n\t\tSyncFile folderSyncFileAB = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"b\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAB);\n\n\t\tSyncFile folderSyncFileAAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\", \"a\"),\n\t\t\tfolderSyncFileAA.getTypePK(), syncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAAA);\n\n\t\tSyncFilePersistence syncFilePersistence =\n\t\t\tSyncFileService.getSyncFilePersistence();\n\n\t\tList<SyncFile> syncedSyncFiles = syncFilePersistence.queryForEq(\n\t\t\t\"state\", SyncFile.STATE_SYNCED);\n\n\t\tint previousSyncedSyncFilesSize = syncedSyncFiles.size();\n\n\t\tSyncFileService.unsyncFolders(syncFiles);\n\n\t\tsyncedSyncFiles = syncFilePersistence.queryForEq(\n\t\t\t\"state\", SyncFile.STATE_SYNCED);\n\n\t\tAssert.assertEquals(\n\t\t\tpreviousSyncedSyncFilesSize - 4, syncedSyncFiles.size());\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tsyncFilePersistence.delete(syncFile);\n\t\t}\n\t}","id":38036,"modified_method":"@Test\n\tpublic void testUnsyncFolders() throws Exception {\n\t\tList<SyncFile> syncFiles = new ArrayList<>();\n\n\t\tSyncFile folderSyncFileA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\"),\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileA);\n\n\t\tSyncFile folderSyncFileAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAA);\n\n\t\tSyncFile folderSyncFileAB = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"b\"),\n\t\t\tfolderSyncFileA.getTypePK(), syncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAB);\n\n\t\tSyncFile folderSyncFileAAA = SyncFileTestUtil.addFolderSyncFile(\n\t\t\tFileUtil.getFilePathName(filePathName, \"a\", \"a\", \"a\"),\n\t\t\tfolderSyncFileAA.getTypePK(), syncAccount.getSyncAccountId());\n\n\t\tsyncFiles.add(folderSyncFileAAA);\n\n\t\tSyncFilePersistence syncFilePersistence =\n\t\t\tSyncFileService.getSyncFilePersistence();\n\n\t\tList<SyncFile> syncedSyncFiles = syncFilePersistence.queryForEq(\n\t\t\t\"state\", SyncFile.STATE_SYNCED);\n\n\t\tint previousSyncedSyncFilesSize = syncedSyncFiles.size();\n\n\t\tSyncFileService.unsyncFolders(\n\t\t\tsyncAccount.getSyncAccountId(), syncFiles);\n\n\t\tsyncedSyncFiles = syncFilePersistence.queryForEq(\n\t\t\t\"state\", SyncFile.STATE_SYNCED);\n\n\t\tAssert.assertEquals(\n\t\t\tpreviousSyncedSyncFilesSize - 4, syncedSyncFiles.size());\n\n\t\tfor (SyncFile syncFile : syncFiles) {\n\t\t\tsyncFilePersistence.delete(syncFile);\n\t\t}\n\t}","commit_id":"be52d3c5d59868b18870601bb0420f39f76f9d2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\r\n\t * Invoked when the editor was succesfully updated. Use this method e.g. to\r\n\t * persist the changed value. This implemention clears any window status\r\n\t * that might have been set in onError.\r\n\t * \r\n\t * @param target\r\n\t *            The ajax request target\r\n\t */\r\n\tprotected void onSubmit(AjaxRequestTarget target)\r\n\t{\r\n\t\ttarget.addJavascript(\"window.status='';\");\r\n\t}","id":38037,"modified_method":"/**\r\n\t * Invoked when the editor was succesfully updated. Use this method e.g. to\r\n\t * persist the changed value. This implemention displays the label and\r\n\t * clears any window status that might have been set in onError.\r\n\t * \r\n\t * @param target\r\n\t *            The ajax request target\r\n\t */\r\n\tprotected void onSubmit(AjaxRequestTarget target)\r\n\t{\r\n\t\tlabel.setVisible(true);\r\n\t\teditor.setVisible(false);\r\n\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\r\n\t\ttarget.addJavascript(\"window.status='';\");\r\n\t}","commit_id":"1be243c99441a5648befb4d87a354c949e202209","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * Invoked when the label is in edit mode, and received a cancel event.\r\n\t * Typically, nothing should be done here.\r\n\t * \r\n\t * @param target\r\n\t *            the ajax request target\r\n\t */\r\n\tprotected void onCancel(AjaxRequestTarget target)\r\n\t{\r\n\t}","id":38038,"modified_method":"/**\r\n\t * Invoked when the label is in edit mode, and received a cancel event.\r\n\t * Typically, nothing should be done here.\r\n\t * \r\n\t * @param target\r\n\t *            the ajax request target\r\n\t */\r\n\tprotected void onCancel(AjaxRequestTarget target)\r\n\t{\r\n\t\tlabel.setVisible(true);\r\n\t\teditor.setVisible(false);\r\n\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\t}","commit_id":"1be243c99441a5648befb4d87a354c949e202209","url":"https://github.com/apache/wicket"},{"original_method":"protected void respond(AjaxRequestTarget target)\r\n\t\t{\r\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\r\n\t\t\tboolean save = Boolean.valueOf(requestCycle.getRequest().getParameter(\"save\"))\r\n\t\t\t\t\t.booleanValue();\r\n\r\n\t\t\tif (save)\r\n\t\t\t{\r\n\t\t\t\teditor.processInput();\r\n\r\n\t\t\t\tif (editor.isValid())\r\n\t\t\t\t{\r\n\t\t\t\t\tlabel.setVisible(true);\r\n\t\t\t\t\teditor.setVisible(false);\r\n\t\t\t\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\r\n\t\t\t\t\tif (save)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tonSubmit(target);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tonError(target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlabel.setVisible(true);\r\n\t\t\t\teditor.setVisible(false);\r\n\t\t\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\r\n\t\t\t\tonCancel(target);\r\n\t\t\t}\r\n\t\t}","id":38039,"modified_method":"protected void respond(AjaxRequestTarget target)\r\n\t\t{\r\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\r\n\t\t\tboolean save = Boolean.valueOf(requestCycle.getRequest().getParameter(\"save\"))\r\n\t\t\t\t\t.booleanValue();\r\n\r\n\t\t\tif (save)\r\n\t\t\t{\r\n\t\t\t\teditor.processInput();\r\n\r\n\t\t\t\tif (editor.isValid())\r\n\t\t\t\t{\r\n\t\t\t\t\tonSubmit(target);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tonError(target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tonCancel(target);\r\n\t\t\t}\r\n\t\t}","commit_id":"1be243c99441a5648befb4d87a354c949e202209","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param title\n\t *            The title of this step\n\t * @param summary\n\t *            The summary of this step\n\t * @param content\n\t *            The content of the step panel\n\t * @param allowHtml\n\t *            If true, any html of the content will be rendered as is.\n\t *            Otherwise, it will be escaped.\n\t */\n\tpublic StaticContentStep(String title, String summary, IModel content, boolean allowHtml)\n\t{\n\t\tthis(new Model<String>(title), new Model<String>(summary), content, allowHtml);\n\t}","id":38040,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param title\n\t *            The title of this step\n\t * @param summary\n\t *            The summary of this step\n\t * @param content\n\t *            The content of the step panel\n\t * @param allowHtml\n\t *            If true, any html of the content will be rendered as is.\n\t *            Otherwise, it will be escaped.\n\t */\n\tpublic StaticContentStep(String title, String summary, IModel<String> content, boolean allowHtml)\n\t{\n\t\tthis(new Model<String>(title), new Model<String>(summary), content, allowHtml);\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param title\n\t *            The title of this step\n\t * @param summary\n\t *            The summary of this step\n\t * @param content\n\t *            The content of the step panel\n\t * @param allowHtml\n\t *            If true, any html of the content will be rendered as is.\n\t *            Otherwise, it will be escaped.\n\t */\n\tpublic StaticContentStep(IModel title, IModel summary, IModel content, boolean allowHtml)\n\t{\n\t\tsuper(title, summary);\n\t\tthis.content = content;\n\t\tthis.allowHtml = allowHtml;\n\t}","id":38041,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param title\n\t *            The title of this step\n\t * @param summary\n\t *            The summary of this step\n\t * @param content\n\t *            The content of the step panel\n\t * @param allowHtml\n\t *            If true, any html of the content will be rendered as is.\n\t *            Otherwise, it will be escaped.\n\t */\n\tpublic StaticContentStep(IModel<String> title, IModel<String> summary, IModel<String> content,\n\t\t\tboolean allowHtml)\n\t{\n\t\tsuper(title, summary);\n\t\tthis.content = content;\n\t\tthis.allowHtml = allowHtml;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param title\n\t *            The title of this step\n\t * @param summary\n\t *            The summary of this step\n\t * @param content\n\t *            The content of the step panel\n\t * @param allowHtml\n\t *            If true, any html of the content will be rendered as is.\n\t *            Otherwise, it will be escaped.\n\t */\n\tpublic StaticContentStep(IModel title, IModel summary, String content, boolean allowHtml)\n\t{\n\t\tthis(title, summary, new Model<String>(content), allowHtml);\n\t}","id":38042,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param title\n\t *            The title of this step\n\t * @param summary\n\t *            The summary of this step\n\t * @param content\n\t *            The content of the step panel\n\t * @param allowHtml\n\t *            If true, any html of the content will be rendered as is.\n\t *            Otherwise, it will be escaped.\n\t */\n\tpublic StaticContentStep(IModel<String> title, IModel<String> summary, String content,\n\t\t\tboolean allowHtml)\n\t{\n\t\tthis(title, summary, new Model<String>(content), allowHtml);\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the content model.\n\t * \n\t * @param content\n\t *            The content model\n\t */\n\tpublic final void setContentModel(IModel content)\n\t{\n\t\tthis.content = content;\n\t}","id":38043,"modified_method":"/**\n\t * Sets the content model.\n\t * \n\t * @param content\n\t *            The content model\n\t */\n\tpublic final void setContentModel(IModel<String> content)\n\t{\n\t\tthis.content = content;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Initialize this wizard with a transition model.\n\t * <p>\n\t * If you constructed this wizard using a constructor without the\n\t * transitions model argument, <strong>you must<\/strong> call this method\n\t * prior to actually using it.\n\t * <\/p>\n\t * \n\t * @param wizardModel\n\t */\n\tprotected void init(IWizardModel wizardModel)\n\t{\n\t\tif (wizardModel == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument wizardModel must be not null\");\n\t\t}\n\n\t\tthis.wizardModel = wizardModel;\n\n\t\tform = new Form(this, \"form\");\n\t\t// dummy view to be replaced\n\t\tnew WebMarkupContainer(form, HEADER_ID);\n\t\tnewFeedbackPanel(form, FEEDBACK_ID);\n\t\t// add dummy view; will be replaced on initialization\n\t\tnew WebMarkupContainer(form, VIEW_ID);\n\t\tnewButtonBar(form, BUTTONS_ID);\n\t\tnewOverviewBar(form, OVERVIEW_ID);\n\n\t\twizardModel.addListener(this);\n\n\t\tfor (Iterator iter = wizardModel.stepIterator(); iter.hasNext();)\n\t\t{\n\t\t\t((IWizardStep)iter.next()).init(wizardModel);\n\t\t}\n\n\t\t// reset model to prepare for action\n\t\twizardModel.reset();\n\t}","id":38044,"modified_method":"/**\n\t * Initialize this wizard with a transition model.\n\t * <p>\n\t * If you constructed this wizard using a constructor without the\n\t * transitions model argument, <strong>you must<\/strong> call this method\n\t * prior to actually using it.\n\t * <\/p>\n\t * \n\t * @param wizardModel\n\t */\n\tprotected void init(IWizardModel wizardModel)\n\t{\n\t\tif (wizardModel == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument wizardModel must be not null\");\n\t\t}\n\n\t\tthis.wizardModel = wizardModel;\n\n\t\tform = new Form(this, \"form\");\n\t\t// dummy view to be replaced\n\t\tnew WebMarkupContainer(form, HEADER_ID);\n\t\tnewFeedbackPanel(form, FEEDBACK_ID);\n\t\t// add dummy view; will be replaced on initialization\n\t\tnew WebMarkupContainer(form, VIEW_ID);\n\t\tnewButtonBar(form, BUTTONS_ID);\n\t\tnewOverviewBar(form, OVERVIEW_ID);\n\n\t\twizardModel.addListener(this);\n\n\t\tfor (Iterator<IWizardStep> iter = wizardModel.stepIterator(); iter.hasNext();)\n\t\t{\n\t\t\titer.next().init(wizardModel);\n\t\t}\n\n\t\t// reset model to prepare for action\n\t\twizardModel.reset();\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Notify listeners that the active step has changed.\n\t * \n\t * @param step\n\t *            The new step\n\t */\n\tprotected final void fireActiveStepChanged(IWizardStep step)\n\t{\n\t\tfor (Iterator i = wizardModelListeners.iterator(); i.hasNext();)\n\t\t{\n\t\t\tIWizardModelListener listener = (IWizardModelListener)i.next();\n\t\t\tlistener.onActiveStepChanged(step);\n\t\t}\n\t}","id":38045,"modified_method":"/**\n\t * Notify listeners that the active step has changed.\n\t * \n\t * @param step\n\t *            The new step\n\t */\n\tprotected final void fireActiveStepChanged(IWizardStep step)\n\t{\n\t\tfor (IWizardModelListener listener : wizardModelListeners)\n\t\t{\n\t\t\tlistener.onActiveStepChanged(step);\n\t\t}\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Finds the next visible step based on the active step.\n\t * \n\t * @return The next visible step based on the active step\n\t */\n\tprotected final IWizardStep findNextVisibleStep()\n\t{\n\t\tint startIndex = (activeStep == null) ? 0 : steps.indexOf(activeStep) + 1;\n\n\t\tfor (int i = startIndex; i < conditions.size(); i++)\n\t\t{\n\t\t\tICondition condition = (ICondition)conditions.get(i);\n\t\t\tif (condition.evaluate())\n\t\t\t{\n\t\t\t\treturn (IWizardStep)steps.get(i);\n\t\t\t}\n\t\t}\n\n\t\tthrow new IllegalStateException(\"Wizard contains no more visible steps\");\n\t}","id":38046,"modified_method":"/**\n\t * Finds the next visible step based on the active step.\n\t * \n\t * @return The next visible step based on the active step\n\t */\n\tprotected final IWizardStep findNextVisibleStep()\n\t{\n\t\tint startIndex = (activeStep == null) ? 0 : steps.indexOf(activeStep) + 1;\n\n\t\tfor (int i = startIndex; i < conditions.size(); i++)\n\t\t{\n\t\t\tICondition condition = conditions.get(i);\n\t\t\tif (condition.evaluate())\n\t\t\t{\n\t\t\t\treturn steps.get(i);\n\t\t\t}\n\t\t}\n\n\t\tthrow new IllegalStateException(\"Wizard contains no more visible steps\");\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Finds the last step in this model.\n\t * \n\t * @return The last step\n\t */\n\tprotected final IWizardStep findLastStep()\n\t{\n\t\tfor (int i = conditions.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tICondition condition = (ICondition)conditions.get(i);\n\t\t\tif (condition.evaluate())\n\t\t\t{\n\t\t\t\treturn (IWizardStep)steps.get(i);\n\t\t\t}\n\t\t}\n\n\t\tthrow new IllegalStateException(\"Wizard contains no visible steps\");\n\t}","id":38047,"modified_method":"/**\n\t * Finds the last step in this model.\n\t * \n\t * @return The last step\n\t */\n\tprotected final IWizardStep findLastStep()\n\t{\n\t\tfor (int i = conditions.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tICondition condition = conditions.get(i);\n\t\t\tif (condition.evaluate())\n\t\t\t{\n\t\t\t\treturn steps.get(i);\n\t\t\t}\n\t\t}\n\n\t\tthrow new IllegalStateException(\"Wizard contains no visible steps\");\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Notify listeners that the wizard is finished.\n\t */\n\tprotected final void fireWizardFinished()\n\t{\n\t\tfor (Iterator i = wizardModelListeners.iterator(); i.hasNext();)\n\t\t{\n\t\t\tIWizardModelListener listener = (IWizardModelListener)i.next();\n\t\t\tlistener.onFinish();\n\t\t}\n\t}","id":38048,"modified_method":"/**\n\t * Notify listeners that the wizard is finished.\n\t */\n\tprotected final void fireWizardFinished()\n\t{\n\t\tfor (IWizardModelListener listener : wizardModelListeners)\n\t\t{\n\t\t\tlistener.onFinish();\n\t\t}\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Returns true if all the steps in the wizard return <tt>true<\/tt> from\n\t * {@link IWizardStep#isComplete}. This is primarily used to determine if\n\t * the last button can be enabled.\n\t * \n\t * @return <tt>true<\/tt> if all the steps in the wizard are complete,\n\t *         <tt>false<\/tt> otherwise.\n\t */\n\tprotected final boolean allStepsComplete()\n\t{\n\t\tfor (Iterator iterator = stepIterator(); iterator.hasNext();)\n\t\t{\n\t\t\tif (!((IWizardStep)iterator.next()).isComplete())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","id":38049,"modified_method":"/**\n\t * Returns true if all the steps in the wizard return <tt>true<\/tt> from\n\t * {@link IWizardStep#isComplete}. This is primarily used to determine if\n\t * the last button can be enabled.\n\t * \n\t * @return <tt>true<\/tt> if all the steps in the wizard are complete,\n\t *         <tt>false<\/tt> otherwise.\n\t */\n\tprotected final boolean allStepsComplete()\n\t{\n\t\tfor (Iterator<IWizardStep> iterator = stepIterator(); iterator.hasNext();)\n\t\t{\n\t\t\tif (!iterator.next().isComplete())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Notify listeners that the wizard is finished.\n\t */\n\tprotected final void fireWizardCancelled()\n\t{\n\t\tfor (Iterator i = wizardModelListeners.iterator(); i.hasNext();)\n\t\t{\n\t\t\tIWizardModelListener listener = (IWizardModelListener)i.next();\n\t\t\tlistener.onCancel();\n\t\t}\n\t}","id":38050,"modified_method":"/**\n\t * Notify listeners that the wizard is finished.\n\t */\n\tprotected final void fireWizardCancelled()\n\t{\n\t\tfor (IWizardModelListener listener : wizardModelListeners)\n\t\t{\n\t\t\tlistener.onCancel();\n\t\t}\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a new step with the specified title and summary. The title and\n\t * summary are displayed in the wizard title block while this step is\n\t * active.\n\t * \n\t * @param title\n\t *            the title of this step.\n\t * @param summary\n\t *            a brief summary of this step or some usage guidelines.\n\t */\n\tpublic WizardStep(IModel title, IModel summary)\n\t{\n\t\tthis(title, summary, null);\n\t}","id":38051,"modified_method":"/**\n\t * Creates a new step with the specified title and summary. The title and\n\t * summary are displayed in the wizard title block while this step is\n\t * active.\n\t * \n\t * @param title\n\t *            the title of this step.\n\t * @param summary\n\t *            a brief summary of this step or some usage guidelines.\n\t * @param model\n\t *            Any model which is to be used for this step\n\t */\n\tpublic WizardStep(IModel<String> title, IModel<String> summary, IModel<T> model)\n\t{\n\t\tthis.title = title;\n\t\tthis.summary = summary;\n\t\tthis.model = model;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the summary of this step. This will be displayed in the title of the\n\t * wizard while this step is active. The summary is typically an overview of\n\t * the step or some usage guidelines for the user.\n\t * \n\t * @return the summary of this step.\n\t */\n\tpublic String getSummary()\n\t{\n\t\treturn (summary != null) ? (String)summary.getObject(null) : (String)null;\n\t}","id":38052,"modified_method":"/**\n\t * Gets the summary of this step. This will be displayed in the title of the\n\t * wizard while this step is active. The summary is typically an overview of\n\t * the step or some usage guidelines for the user.\n\t * \n\t * @return the summary of this step.\n\t */\n\tpublic String getSummary()\n\t{\n\t\treturn (summary != null) ? summary.getObject(null) : (String)null;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the title of this step.\n\t * \n\t * @return the title of this step.\n\t */\n\tpublic String getTitle()\n\t{\n\t\treturn (title != null) ? (String)title.getObject(null) : (String)null;\n\t}","id":38053,"modified_method":"/**\n\t * Gets the title of this step.\n\t * \n\t * @return the title of this step.\n\t */\n\tpublic String getTitle()\n\t{\n\t\treturn (title != null) ? title.getObject(null) : (String)null;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a new step with the specified title and summary. The title and\n\t * summary are displayed in the wizard title block while this step is\n\t * active.\n\t * \n\t * @param title\n\t *            the title of this step.\n\t * @param summary\n\t *            a brief summary of this step or some usage guidelines.\n\t * @param model\n\t *            Any model which is to be used for this step\n\t */\n\tpublic WizardStep(IModel title, IModel summary, IModel model)\n\t{\n\t\tthis.title = title;\n\t\tthis.summary = summary;\n\t\tthis.model = model;\n\t}","id":38054,"modified_method":"/**\n\t * Creates a new step with the specified title and summary. The title and\n\t * summary are displayed in the wizard title block while this step is\n\t * active.\n\t * \n\t * @param title\n\t *            the title of this step.\n\t * @param summary\n\t *            a brief summary of this step or some usage guidelines.\n\t */\n\tpublic WizardStep(IModel<String> title, IModel<String> summary)\n\t{\n\t\tthis(title, summary, null);\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets title.\n\t * \n\t * @param title\n\t *            title\n\t */\n\tpublic final void setTitleModel(IModel title)\n\t{\n\t\tthis.title = title;\n\t}","id":38055,"modified_method":"/**\n\t * Sets title.\n\t * \n\t * @param title\n\t *            title\n\t */\n\tpublic final void setTitleModel(IModel<String> title)\n\t{\n\t\tthis.title = title;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct without a title and a summary. Useful for when you provide a\n\t * custom header by overiding\n\t * {@link #getHeader(MarkupContainer, String, IWizard)}.\n\t */\n\tpublic WizardStep()\n\t{\n\t\tthis((IModel)null, (IModel)null);\n\t}","id":38056,"modified_method":"/**\n\t * Construct without a title and a summary. Useful for when you provide a\n\t * custom header by overiding\n\t * {@link #getHeader(MarkupContainer, String, IWizard)}.\n\t */\n\tpublic WizardStep()\n\t{\n\t\tthis((IModel<String>)null, (IModel<String>)null);\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets summary.\n\t * \n\t * @param summary\n\t *            summary\n\t */\n\tpublic final void setSummaryModel(IModel summary)\n\t{\n\t\tthis.summary = summary;\n\t}","id":38057,"modified_method":"/**\n\t * Sets summary.\n\t * \n\t * @param summary\n\t *            summary\n\t */\n\tpublic final void setSummaryModel(IModel<String> summary)\n\t{\n\t\tthis.summary = summary;\n\t}","commit_id":"0ae5e32ffcd8879093ffa5d2b03113099ccae9b8","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * Invoked when the editor was succesfully updated. Use this method e.g. to\r\n\t * persist the changed value. This implemention clears any window status\r\n\t * that might have been set in onError.\r\n\t * \r\n\t * @param target\r\n\t *            The ajax request target\r\n\t */\r\n\tprotected void onSubmit(AjaxRequestTarget target)\r\n\t{\r\n\t\ttarget.appendJavascript(\"window.status='';\");\r\n\t}","id":38058,"modified_method":"/**\r\n\t * Invoked when the editor was succesfully updated. Use this method e.g. to\r\n\t * persist the changed value. This implemention clears any window status\r\n\t * that might have been set in onError.\r\n\t * \r\n\t * @param target\r\n\t *            The ajax request target\r\n\t */\r\n\tprotected void onSubmit(AjaxRequestTarget target)\r\n\t{\r\n\t\tlabel.setVisible(true);\r\n\t\teditor.setVisible(false);\r\n\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\r\n\t\ttarget.appendJavascript(\"window.status='';\");\r\n\t}","commit_id":"17af61b4f38a95a5e854b4bda7ad4d62843a3676","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * Invoked when the label is in edit mode, and received a cancel event.\r\n\t * Typically, nothing should be done here.\r\n\t * \r\n\t * @param target\r\n\t *            the ajax request target\r\n\t */\r\n\tprotected void onCancel(AjaxRequestTarget target)\r\n\t{\r\n\t}","id":38059,"modified_method":"/**\r\n\t * Invoked when the label is in edit mode, and received a cancel event.\r\n\t * Typically, nothing should be done here.\r\n\t * \r\n\t * @param target\r\n\t *            the ajax request target\r\n\t */\r\n\tprotected void onCancel(AjaxRequestTarget target)\r\n\t{\r\n\t\tlabel.setVisible(true);\r\n\t\teditor.setVisible(false);\r\n\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\t}","commit_id":"17af61b4f38a95a5e854b4bda7ad4d62843a3676","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t\t * @see wicket.ajax.AbstractDefaultAjaxBehavior#respond(wicket.ajax.AjaxRequestTarget)\r\n\t\t */\r\n\t\t@Override\r\n\t\tprotected void respond(AjaxRequestTarget target)\r\n\t\t{\r\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\r\n\t\t\tboolean save = Boolean.valueOf(requestCycle.getRequest().getParameter(\"save\"))\r\n\t\t\t\t\t.booleanValue();\r\n\r\n\t\t\tif (save)\r\n\t\t\t{\r\n\t\t\t\teditor.processInput();\r\n\r\n\t\t\t\tif (editor.isValid())\r\n\t\t\t\t{\r\n\t\t\t\t\tlabel.setVisible(true);\r\n\t\t\t\t\teditor.setVisible(false);\r\n\t\t\t\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\r\n\t\t\t\t\tif (save)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tonSubmit(target);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tonError(target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlabel.setVisible(true);\r\n\t\t\t\teditor.setVisible(false);\r\n\t\t\t\ttarget.addComponent(AjaxEditableLabel.this);\r\n\r\n\t\t\t\tonCancel(target);\r\n\t\t\t}\r\n\t\t}","id":38060,"modified_method":"/**\r\n\t\t * @see wicket.ajax.AbstractDefaultAjaxBehavior#respond(wicket.ajax.AjaxRequestTarget)\r\n\t\t */\r\n\t\t@Override\r\n\t\tprotected void respond(AjaxRequestTarget target)\r\n\t\t{\r\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\r\n\t\t\tboolean save = Boolean.valueOf(requestCycle.getRequest().getParameter(\"save\"))\r\n\t\t\t\t\t.booleanValue();\r\n\r\n\t\t\tif (save)\r\n\t\t\t{\r\n\t\t\t\teditor.processInput();\r\n\r\n\t\t\t\tif (editor.isValid())\r\n\t\t\t\t{\r\n\t\t\t\t\tonSubmit(target);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tonError(target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tonCancel(target);\r\n\t\t\t}\r\n\t\t}","commit_id":"17af61b4f38a95a5e854b4bda7ad4d62843a3676","url":"https://github.com/apache/wicket"},{"original_method":"public JwtAuthentication(SignedJWT token, User user, Collection<AmbariGrantedAuthority> userAuthorities) {\n    this.token = token;\n    this.user = user;\n    this.userAuthorities = userAuthorities;\n  }","id":38061,"modified_method":"public JwtAuthentication(String token, User user, Collection<AmbariGrantedAuthority> userAuthorities) {\n    this.serializedToken = token;\n    this.user = user;\n    this.userAuthorities = userAuthorities;\n  }","commit_id":"4ab6afc2ff187ab5ff597d20dd51d1e46c982080","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public SignedJWT getCredentials() {\n    return token;\n  }","id":38062,"modified_method":"@Override\n  public String getCredentials() {\n    return serializedToken;\n  }","commit_id":"4ab6afc2ff187ab5ff597d20dd51d1e46c982080","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Create the URL to be used for authentication of the user in the absence of\n   * a JWT token within the incoming request.\n   *\n   * @param request for getting the original request URL\n   * @return url to use as login url for redirect\n   */\n  protected String constructLoginURL(HttpServletRequest request) {\n    String delimiter = \"?\";\n    if (authenticationProviderUrl.contains(\"?\")) {\n      delimiter = \"&\";\n    }\n    String loginURL = authenticationProviderUrl + delimiter\n        + originalUrlQueryParam + \"=\"\n        + request.getRequestURL().toString();\n    return loginURL;\n  }","id":38063,"modified_method":"/**\n   * Do not try to validate JWT if user already authenticated via other provider\n   * @return true, if JWT validation required\n   */\n  private boolean isAuthenticationRequired(String token) {\n    Authentication existingAuth = SecurityContextHolder.getContext().getAuthentication();\n\n    //authenticate if no auth\n    if(existingAuth == null || !existingAuth.isAuthenticated() ){\n      return true;\n    }\n\n    //revalidate if token was changed\n    if(existingAuth instanceof JwtAuthentication && !StringUtils.equals(token, (String) existingAuth.getCredentials())){\n      return true;\n    }\n\n    //always try to authenticate in case of anonymous user\n    if (existingAuth instanceof AnonymousAuthenticationToken) {\n      return true;\n    }\n\n    return false;\n  }","commit_id":"4ab6afc2ff187ab5ff597d20dd51d1e46c982080","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Encapsulate the acquisition of the JWT token from HTTP cookies within the\n   * request.\n   *\n   * @param req servlet request to get the JWT token from\n   * @return serialized JWT token\n   */\n  protected String getJWTFromCookie(HttpServletRequest req) {\n    String serializedJWT = null;\n    Cookie[] cookies = req.getCookies();\n    String userName = null;\n    if (cookies != null) {\n      for (Cookie cookie : cookies) {\n        if (cookieName.equals(cookie.getName())) {\n          LOG.info(cookieName\n              + \" cookie has been found and is being processed\");\n          serializedJWT = cookie.getValue();\n          break;\n        }\n      }\n    }\n    return serializedJWT;\n  }","id":38064,"modified_method":"/**\n   * Encapsulate the acquisition of the JWT token from HTTP cookies within the\n   * request.\n   *\n   * @param req servlet request to get the JWT token from\n   * @return serialized JWT token\n   */\n  protected String getJWTFromCookie(HttpServletRequest req) {\n    String serializedJWT = null;\n    Cookie[] cookies = req.getCookies();\n    if (cookies != null) {\n      for (Cookie cookie : cookies) {\n        if (cookieName.equals(cookie.getName())) {\n          LOG.info(cookieName\n              + \" cookie has been found and is being processed\");\n          serializedJWT = cookie.getValue();\n          break;\n        }\n      }\n    }\n    return serializedJWT;\n  }","commit_id":"4ab6afc2ff187ab5ff597d20dd51d1e46c982080","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n\n    if (jwtProperties != null && isAuthenticationRequired()) {\n      HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;\n      HttpServletResponse httpServletResponse = (HttpServletResponse) servletResponse;\n\n      String serializedJWT = getJWTFromCookie(httpServletRequest);\n      if (serializedJWT != null) {\n        SignedJWT jwtToken = null;\n        try {\n          jwtToken = SignedJWT.parse(serializedJWT);\n          boolean valid = validateToken(jwtToken);\n\n          if (valid) {\n            String userName = jwtToken.getJWTClaimsSet().getSubject();\n            User user = users.getUser(userName, UserType.JWT);\n            if (user == null) {\n              // create user in local database on first login, usually we cannot fetch all users\n              // from external authentication provider (as we do during ldap-sync process)\n              users.createUser(userName, null, UserType.JWT, true, false);\n              user = users.getUser(userName, UserType.JWT);\n            }\n\n            Collection<AmbariGrantedAuthority> userAuthorities =\n                users.getUserAuthorities(user.getUserName(), user.getUserType());\n\n            JwtAuthentication token = new JwtAuthentication(jwtToken, user, userAuthorities);\n            token.setAuthenticated(true);\n\n            SecurityContextHolder.getContext().setAuthentication(token);\n\n\n          } else {\n            LOG.warn(\"JWT authentication failed\");\n            if (ignoreFailure) {\n              filterChain.doFilter(servletRequest, servletResponse);\n            } else {\n              //used to indicate authentication failure, not used here as we have more than one filter\n              entryPoint.commence(httpServletRequest, httpServletResponse, new BadCredentialsException(\"Invalid JWT \" +\n                  \"token\"));\n            }\n          }\n\n\n\n        } catch (ParseException e) {\n          LOG.warn(\"Unable to parse the JWT token\", e);\n        }\n      }\n    }\n\n    filterChain.doFilter(servletRequest, servletResponse);\n  }","id":38065,"modified_method":"@Override\n  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n\n    if(jwtProperties == null){\n      //disable filter if not configured\n      filterChain.doFilter(servletRequest, servletResponse);\n      return;\n    }\n\n    HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;\n    HttpServletResponse httpServletResponse = (HttpServletResponse) servletResponse;\n\n    String serializedJWT = getJWTFromCookie(httpServletRequest);\n    if (serializedJWT != null && isAuthenticationRequired(serializedJWT)) {\n      SignedJWT jwtToken;\n      try {\n        jwtToken = SignedJWT.parse(serializedJWT);\n\n        boolean valid = validateToken(jwtToken);\n\n        if (valid) {\n          String userName = jwtToken.getJWTClaimsSet().getSubject();\n          User user = users.getUser(userName, UserType.JWT);\n          if (user == null) {\n\n            //TODO this is temporary check for conflicts, until /users API will change to use user_id instead of name as PK\n            User existingUser = users.getAnyUser(userName);\n            if (existingUser != null && existingUser.getUserType() != UserType.JWT) {\n\n              LOG.error(\"Access for JWT user [{}] restricted. Detected conflict with local user \", userName);\n\n              // directly send HTTP status 500 to avoid redirect loop, as jwt token is already confirmed to be valid\n              httpServletResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n                \"Cannot create JWT user: conflict detected\");\n\n              //interrupt filter chain\n              return;\n            }\n\n            // create user in local database on first login, usually we cannot fetch all users\n            // from external authentication provider (as we do during ldap-sync process)\n            users.createUser(userName, null, UserType.JWT, true, false);\n            user = users.getUser(userName, UserType.JWT);\n          }\n\n          Collection<AmbariGrantedAuthority> userAuthorities =\n                  users.getUserAuthorities(user.getUserName(), user.getUserType());\n\n          JwtAuthentication authentication = new JwtAuthentication(serializedJWT, user, userAuthorities);\n          authentication.setAuthenticated(true);\n\n          SecurityContextHolder.getContext().setAuthentication(authentication);\n\n\n        } else {\n          //clear security context if authentication was required, but failed\n          SecurityContextHolder.clearContext();\n\n          LOG.warn(\"JWT authentication failed\");\n          if (ignoreFailure) {\n            filterChain.doFilter(servletRequest, servletResponse);\n          } else {\n            //used to indicate authentication failure, not used here as we have more than one filter\n            entryPoint.commence(httpServletRequest, httpServletResponse, new BadCredentialsException(\"Invalid JWT \" +\n                    \"token\"));\n          }\n        }\n\n\n      } catch (ParseException e) {\n        LOG.warn(\"Unable to parse the JWT token\", e);\n      }\n    } else {\n      LOG.trace(\"No JWT cookie found, do nothing\");\n    }\n\n    filterChain.doFilter(servletRequest, servletResponse);\n  }","commit_id":"4ab6afc2ff187ab5ff597d20dd51d1e46c982080","url":"https://github.com/apache/ambari"},{"original_method":"@RequiresSession\n  public UserEntity findUserByName(String userName) {\n    TypedQuery<UserEntity> query = entityManagerProvider.get().createNamedQuery(\"userByName\", UserEntity.class);\n    query.setParameter(\"username\", userName.toLowerCase());\n    try {\n      return query.getSingleResult();\n    } catch (NoResultException e) {\n      return null;\n    }\n  }","id":38066,"modified_method":"/**\n   * Results in Exception if two users with same name but different types present in DB\n   * As such situation is valid, use {@link #findUserByNameAndType(String, UserType)} instead\n   */\n  @RequiresSession\n  @Deprecated\n  public UserEntity findUserByName(String userName) {\n    TypedQuery<UserEntity> query = entityManagerProvider.get().createNamedQuery(\"userByName\", UserEntity.class);\n    query.setParameter(\"username\", userName.toLowerCase());\n    try {\n      return query.getSingleResult();\n    } catch (NoResultException e) {\n      return null;\n    }\n  }","commit_id":"4ab6afc2ff187ab5ff597d20dd51d1e46c982080","url":"https://github.com/apache/ambari"},{"original_method":"public User getAnyUser(String userName) {\n    UserEntity userEntity = userDAO.findUserByName(userName);\n    return (null == userEntity) ? null : new User(userEntity);\n  }","id":38067,"modified_method":"/**\n   * This method works incorrectly, userName is not unique if users have different types\n   * @return One user. Priority is LOCAL -> LDAP -> JWT\n   */\n  @Deprecated\n  public User getAnyUser(String userName) {\n    UserEntity userEntity = userDAO.findUserByNameAndType(userName, UserType.LOCAL);\n    if (userEntity == null) {\n      userEntity = userDAO.findUserByNameAndType(userName, UserType.LDAP);\n    }\n    if (userEntity == null) {\n      userEntity = userDAO.findUserByNameAndType(userName, UserType.JWT);\n    }\n    return (null == userEntity) ? null : new User(userEntity);\n  }","commit_id":"4ab6afc2ff187ab5ff597d20dd51d1e46c982080","url":"https://github.com/apache/ambari"},{"original_method":"/**\n     * Sets an authentication token for the user on the session. Always returns true.\n     */\n    protected boolean allow(HttpSession session, String user) {\n        LOG.debug(\"Web console {} authenticated user {}\", getClass().getSimpleName(), user);\n        session.setAttribute(getAuthenticationKey(), user);\n        return true;\n    }","id":38068,"modified_method":"/**\n     * Sets an authentication token for the user on the session. Always returns true.\n     */\n    protected boolean allow(HttpSession session, String user) {\n        LOG.debug(\"REST {} authenticated user {}\", getClass().getSimpleName(), user);\n        session.setAttribute(getAuthenticationKey(), user);\n        return true;\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected boolean handleLogout(HttpServletRequest request) {\n        if (\"/logout\".equals(request.getRequestURI()) || \"/v1/logout\".equals(request.getRequestURI())) {\n            log.info(\"Web API logging out \"+request.getSession()+\" for user \"+\n                    request.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE));\n            provider.logout(request.getSession());\n            request.getSession().removeAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE);\n            request.getSession().removeAttribute(REMOTE_ADDRESS_SESSION_ATTRIBUTE);\n            request.getSession().invalidate();\n            return true;\n        }\n        return false;\n    }","id":38069,"modified_method":"protected boolean handleLogout(HttpServletRequest request) {\n        if (\"/logout\".equals(request.getRequestURI()) || \"/v1/logout\".equals(request.getRequestURI())) {\n            log.info(\"Web API logging {} out of session {}\",\n                    request.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE), request.getSession().getId());\n            provider.logout(request.getSession());\n            request.getSession().removeAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE);\n            request.getSession().removeAttribute(REMOTE_ADDRESS_SESSION_ATTRIBUTE);\n            request.getSession().invalidate();\n            return true;\n        }\n        return false;\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        if (provider == null) {\n            log.warn(\"No security provider available: disallowing web access to brooklyn\");\n            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        if (authenticate(httpRequest)) {\n            String user = Strings.toString(httpRequest.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE));\n            if (handleLogout(httpRequest)) {\n                log.debug(\"REST logging out \" + user + \" of session \" + httpRequest.getSession());\n                // do nothing here, fall through to below\n            } else {\n                WebEntitlementContext entitlementContext = null;\n                String uri = httpRequest.getRequestURI();\n                try {\n                    String uid = Identifiers.makeRandomId(6);\n                    entitlementContext = new WebEntitlementContext(user, httpRequest.getRemoteAddr(), uri, uid);\n                    if (originalRequest.get() == null) {\n                        // initial filter application\n                        originalRequest.set(uri);\n                    } else {\n                        // this filter is being applied *again*, probably due to forwarding (e.g. from '/' to '/index.html')\n                        log.debug(\"REST request {} being forwarded from {} to {}\", new Object[]{uid, originalRequest.get(), uri});\n                        // clear the entitlement context before setting to avoid warnings\n                        Entitlements.clearEntitlementContext();\n                    }\n                    Entitlements.setEntitlementContext(entitlementContext);\n\n                    log.debug(\"REST req {} starting processing request {} with {}\", new Object[]{uid, uri, entitlementContext});\n                    chain.doFilter(request, response);\n\n                    // This logging must NOT happen before chain.doFilter, or FormMapProvider will not work as expected.\n                    // Getting the parameter map consumes the request body and only resource methods using @FormParam\n                    // will work as expected.\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"REST req {} complete, responding {} for request {} with {}\",\n                                new Object[]{uid, ((HttpServletResponse) response).getStatus(), uri, entitlementContext});\n                        log.debug(\"  source: \" + httpRequest.getRemoteAddr());\n                        if (!httpRequest.getParameterMap().isEmpty()) {\n                            log.debug(\"  parameters were: {}\", httpRequest.getParameterMap());\n                        }\n                        if (httpRequest.getContentLength() > 0) {\n                            int len = httpRequest.getContentLength();\n                            log.debug(\"  upload content type was {}, length={}\", httpRequest.getContentType(), len);\n                        }\n                        if (log.isTraceEnabled()) {\n                            Enumeration<String> headerNames = httpRequest.getHeaderNames();\n                            if (headerNames.hasMoreElements()) {\n                                log.trace(\"  headers:\");\n                                while (headerNames.hasMoreElements()) {\n                                    String headerName = headerNames.nextElement();\n                                    log.trace(\"    {}: {}\", headerName, httpRequest.getHeader(headerName));\n                                }\n                            }\n                        }\n                    }\n                    return;\n                } catch (Throwable e) {\n                    // errors are typically already caught at this point, except for serialization errors\n                    log.warn(\"REST failed processing request \" + uri + \" with \" + entitlementContext + \": \" + e, e);\n                    ((HttpServletResponse) response).sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                    return;\n                } finally {\n                    originalRequest.remove();\n                    Entitlements.clearEntitlementContext();\n                }\n            }\n        }\n        ((HttpServletResponse) response).setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"brooklyn\\\"\");\n        ((HttpServletResponse) response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n    }","id":38070,"modified_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n\n        if (provider == null) {\n            log.warn(\"No security provider available: disallowing web access to brooklyn\");\n            httpResponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        if (handleLogout(httpRequest) || !authenticate(httpRequest)) {\n            httpResponse.setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"brooklyn\\\"\");\n            httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        WebEntitlementContext entitlementContext = null;\n        String uri = httpRequest.getRequestURI();\n        String uid = Identifiers.makeRandomId(6);\n        String user = Strings.toString(httpRequest.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE));\n        try {\n            entitlementContext = new WebEntitlementContext(user, httpRequest.getRemoteAddr(), uri, uid);\n            if (originalRequest.get() == null) {\n                // initial filter application\n                originalRequest.set(uri);\n            } else {\n                // this filter is being applied *again*, probably due to forwarding (e.g. from '/' to '/index.html')\n                log.debug(\"REST {} being forwarded from {} to {}\", new Object[]{uid, originalRequest.get(), uri});\n                // clear the entitlement context before setting to avoid warnings\n                Entitlements.clearEntitlementContext();\n            }\n            Entitlements.setEntitlementContext(entitlementContext);\n\n            log.debug(\"REST {} starting processing request {} with {}\", new Object[]{uid, uri, entitlementContext});\n            chain.doFilter(request, response);\n\n            // This logging must NOT happen before chain.doFilter, or FormMapProvider will not work as expected.\n            // Getting the parameter map consumes the request body and only resource methods using @FormParam\n            // will work as expected.\n            if (log.isDebugEnabled()) {\n                log.debug(\"REST {} complete, responding {} for `request {} with {}\",\n                        new Object[]{uid, httpResponse.getStatus(), uri, entitlementContext});\n                log.debug(\"  source: \" + httpRequest.getRemoteAddr());\n                if (!httpRequest.getParameterMap().isEmpty()) {\n                    log.debug(\"  parameters were: {}\", httpRequest.getParameterMap());\n                }\n                if (httpRequest.getContentLength() > 0) {\n                    int len = httpRequest.getContentLength();\n                    log.debug(\"  upload content type was {}, length={}\", httpRequest.getContentType(), len);\n                }\n                if (log.isTraceEnabled()) {\n                    Enumeration<String> headerNames = httpRequest.getHeaderNames();\n                    if (headerNames.hasMoreElements()) {\n                        log.trace(\"  headers:\");\n                        while (headerNames.hasMoreElements()) {\n                            String headerName = headerNames.nextElement();\n                            log.trace(\"    {}: {}\", headerName, httpRequest.getHeader(headerName));\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            // errors are typically already caught at this point, except for serialization errors\n            log.warn(\"REST \" + uid + \" failed processing request \" + uri + \" with \" + entitlementContext + \": \" + e, e);\n            httpResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        } finally {\n            originalRequest.remove();\n            Entitlements.clearEntitlementContext();\n        }\n\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected boolean authenticate(HttpServletRequest request) {\n        HttpSession session = request.getSession();\n        if (provider.isAuthenticated(session)) {\n            return true;\n        }\n        session.setAttribute(REMOTE_ADDRESS_SESSION_ATTRIBUTE, request.getRemoteAddr());\n        String user = null, pass = null;\n        String authorization=request.getHeader(\"Authorization\");\n        if (authorization!=null) {\n            String userpass=Base64.base64Decode(authorization.substring(6));\n            user=userpass.substring(0,userpass.indexOf(\":\"));\n            pass=userpass.substring(userpass.indexOf(\":\")+1);\n        }\n        if (provider.authenticate(session, user, pass)) {\n            log.debug(\"Web API authenticated \"+session+\" for user \"+user);\n            if (user!=null) {\n                session.setAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE, user);\n            }\n            return true;\n        }\n        \n        return false;\n    }","id":38071,"modified_method":"protected boolean authenticate(HttpServletRequest request) {\n        HttpSession session = request.getSession();\n        if (provider.isAuthenticated(session)) {\n            return true;\n        }\n        session.setAttribute(REMOTE_ADDRESS_SESSION_ATTRIBUTE, request.getRemoteAddr());\n        String user = null, pass = null;\n        String authorization=request.getHeader(\"Authorization\");\n        if (authorization != null) {\n            String userpass = Base64.base64Decode(authorization.substring(6));\n            user = userpass.substring(0, userpass.indexOf(\":\"));\n            pass = userpass.substring(userpass.indexOf(\":\") + 1);\n        }\n        if (provider.authenticate(session, user, pass)) {\n            log.debug(\"REST authenticated {} for user {}\", session.getId(), user);\n            if (user != null) {\n                session.setAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE, user);\n            }\n            return true;\n        }\n        \n        return false;\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean authenticate(HttpSession session, String user, String password) {\n        return getTargetProvider().authenticate(session, user, password);\n    }","id":38072,"modified_method":"@Override\n    public boolean authenticate(HttpSession session, String user, String password) {\n        return getDelegate().authenticate(session, user, password);\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean isAuthenticated(HttpSession session) {\n        return getTargetProvider().isAuthenticated(session);\n    }","id":38073,"modified_method":"@Override\n    public boolean isAuthenticated(HttpSession session) {\n        Object modCountWhenFirstAuthenticated = session.getAttribute(getModificationCountKey());\n        boolean authenticated = getDelegate().isAuthenticated(session) &&\n                modCountWhenFirstAuthenticated != null && ((Long) modCount.get()).equals(modCountWhenFirstAuthenticated);\n        if (authenticated) {\n            session.setAttribute(getModificationCountKey(), modCount.get());\n        }\n        return authenticated;\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public DelegatingSecurityProvider(ManagementContext mgmt) {\n        this.mgmt = mgmt;\n    }","id":38074,"modified_method":"public DelegatingSecurityProvider(ManagementContext mgmt) {\n        this.mgmt = mgmt;\n        mgmt.addPropertiesReloadListener(new PropertiesListener());\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean logout(HttpSession session) { \n        return getTargetProvider().logout(session);\n    }","id":38075,"modified_method":"@Override\n    public boolean logout(HttpSession session) { \n        return getDelegate().logout(session);\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private synchronized void initialize() {\n        if (allowedUsers!=null) return;\n\n        StringConfigMap properties = mgmt.getConfig();\n\n        allowedUsers = new LinkedHashSet<String>();\n        String users = properties.getConfig(BrooklynWebConfig.USERS);\n        if (users==null) {\n            LOG.warn(\"Web console has no users configured; no one will be able to log in!\");\n        } else if (\"*\".equals(users)) {\n            LOG.info(\"Web console allowing any user (so long as valid password is set)\");\n            allowAnyUserWithValidPass = true;\n        } else {\n            StringTokenizer t = new StringTokenizer(users, \",\");\n            while (t.hasMoreElements()) {\n                allowedUsers.add((\"\"+t.nextElement()).trim());\n            }\n            LOG.info(\"Web console allowing users: \"+allowedUsers);\n        }       \n    }","id":38076,"modified_method":"private synchronized void initialize() {\n        if (allowedUsers != null) return;\n\n        StringConfigMap properties = mgmt.getConfig();\n\n        allowedUsers = new LinkedHashSet<String>();\n        String users = properties.getConfig(BrooklynWebConfig.USERS);\n        if (users == null) {\n            LOG.warn(\"REST has no users configured; no one will be able to log in!\");\n        } else if (\"*\".equals(users)) {\n            LOG.info(\"REST allowing any user (so long as valid password is set)\");\n            allowAnyUserWithValidPass = true;\n        } else {\n            StringTokenizer t = new StringTokenizer(users, \",\");\n            while (t.hasMoreElements()) {\n                allowedUsers.add((\"\" + t.nextElement()).trim());\n            }\n            LOG.info(\"REST allowing users: \" + allowedUsers);\n        }\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public boolean authenticate(HttpSession session, String user, String password) {\n        if (session==null || user==null) return false;\n        \n        initialize();\n        \n        if (!allowAnyUserWithValidPass) {\n            if (!allowedUsers.contains(user)) {\n                LOG.info(\"Web console rejecting unknown user \"+user);\n                return false;                \n            }\n        }\n\n        BrooklynProperties properties = (BrooklynProperties) mgmt.getConfig();\n        String expectedP = properties.getConfig(BrooklynWebConfig.PASSWORD_FOR_USER(user));\n        String salt = properties.getConfig(BrooklynWebConfig.SALT_FOR_USER(user));\n        String expectedSha256 = properties.getConfig(BrooklynWebConfig.SHA256_FOR_USER(user));\n        \n        if (expectedP != null) {\n            if (expectedP.equals(password)) {\n                // password is good\n                return allow(session, user);\n            } else {\n                LOG.info(\"Web console rejecting bad password for user \"+user);\n                return false;\n            }\n        }\n        if (expectedSha256 != null) {\n            String hashedPassword = PasswordHasher.sha256(salt, password);\n            if (expectedSha256.equals(hashedPassword)) {\n                // hashed password is good\n                return allow(session, user);\n            } else {\n                LOG.info(\"Web console rejecting bad password for user \"+user);\n                return false;\n            }                \n        }\n        LOG.warn(\"Web console rejecting passwordless user \" + user);\n        return false;\n    }","id":38077,"modified_method":"@Override\n    public boolean authenticate(HttpSession session, String user, String password) {\n        if (session==null || user==null) return false;\n        \n        initialize();\n        \n        if (!allowAnyUserWithValidPass) {\n            if (!allowedUsers.contains(user)) {\n                LOG.debug(\"REST rejecting unknown user \"+user);\n                return false;                \n            }\n        }\n\n        BrooklynProperties properties = (BrooklynProperties) mgmt.getConfig();\n        String expectedP = properties.getConfig(BrooklynWebConfig.PASSWORD_FOR_USER(user));\n        String salt = properties.getConfig(BrooklynWebConfig.SALT_FOR_USER(user));\n        String expectedSha256 = properties.getConfig(BrooklynWebConfig.SHA256_FOR_USER(user));\n        \n        if (expectedP != null) {\n            if (expectedP.equals(password)) {\n                // password is good\n                return allow(session, user);\n            } else {\n                LOG.debug(\"REST rejecting bad password for user \"+user);\n                return false;\n            }\n        }\n        if (expectedSha256 != null) {\n            String hashedPassword = PasswordHasher.sha256(salt, password);\n            if (expectedSha256.equals(hashedPassword)) {\n                // hashed password is good\n                return allow(session, user);\n            } else {\n                LOG.debug(\"REST rejecting bad password for user \"+user);\n                return false;\n            }                \n        }\n        LOG.debug(\"REST rejecting passwordless user \" + user);\n        return false;\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private String getServerUser(Server server) throws Exception {\n        HttpClient client = HttpTool.httpClientBuilder()\n                .uri(getBaseUri(server))\n                .credentials(new UsernamePasswordCredentials(TestSecurityProvider.USER, TestSecurityProvider.PASSWORD))\n                .build();\n        HttpToolResponse response = HttpTool.httpGet(client, URI.create(getBaseUri() + \"/v1/server/user\"),\n                ImmutableMap.<String, String>of());\n        HttpTestUtils.assertHealthyStatusCode(response.getResponseCode());\n        return response.getContentAsString();\n    }","id":38078,"modified_method":"private String getServerUser(Server server) throws Exception {\n        HttpClient client = HttpTool.httpClientBuilder()\n                .uri(getBaseUri(server))\n                .credentials(TestSecurityProvider.CREDENTIAL)\n                .build();\n        HttpToolResponse response = HttpTool.httpGet(client, URI.create(getBaseUri() + \"/v1/server/user\"),\n                ImmutableMap.<String, String>of());\n        HttpTestUtils.assertHealthyStatusCode(response.getResponseCode());\n        return response.getContentAsString();\n    }","commit_id":"27ff1172ea3586a9b97b1e793443af6f14174c26","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * @see javax.security.auth.spi.LoginModule#login()\n     * @return true if is authenticated, false otherwise\n     * @throws LoginException\n     */\n    public boolean login() throws LoginException\n    {\n        try\n        {\n            if (callbackHandler == null)\n                throw new LoginException (\"No callback handler\");\n\n            Callback[] callbacks = configureCallbacks();\n            callbackHandler.handle(callbacks);\n\n            String webUserName = ((NameCallback)callbacks[0]).getName();\n            Object webCredential = null;\n\n            webCredential = ((ObjectCallback)callbacks[1]).getObject(); //first check if ObjectCallback has the credential\n            if (webCredential == null)\n                webCredential = ((PasswordCallback)callbacks[2]).getPassword(); //use standard PasswordCallback\n\n            if ((webUserName == null) || (webCredential == null))\n            {\n                setAuthenticated(false);\n                return isAuthenticated();\n            }\n\n            UserInfo userInfo = getUserInfo(webUserName);\n\n            if (userInfo == null)\n            {\n                setAuthenticated(false);\n                return isAuthenticated();\n            }\n\n            currentUser = new JAASUserInfo(userInfo);\n            setAuthenticated(currentUser.checkCredential(webCredential));\n            return isAuthenticated();\n        }\n        catch (IOException e)\n        {\n            throw new LoginException (e.toString());\n        }\n        catch (UnsupportedCallbackException e)\n        {\n            throw new LoginException (e.toString());\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            throw new LoginException (e.toString());\n        }\n    }","id":38079,"modified_method":"/**\n     * @see javax.security.auth.spi.LoginModule#login()\n     * @return true if is authenticated, false otherwise\n     * @throws LoginException\n     */\n    public boolean login() throws LoginException\n    {\n        try\n        {  \n            if (isIgnored())\n                return false;\n            \n            if (callbackHandler == null)\n                throw new LoginException (\"No callback handler\");\n\n            Callback[] callbacks = configureCallbacks();\n            callbackHandler.handle(callbacks);\n\n            String webUserName = ((NameCallback)callbacks[0]).getName();\n            Object webCredential = null;\n\n            webCredential = ((ObjectCallback)callbacks[1]).getObject(); //first check if ObjectCallback has the credential\n            if (webCredential == null)\n                webCredential = ((PasswordCallback)callbacks[2]).getPassword(); //use standard PasswordCallback\n\n            if ((webUserName == null) || (webCredential == null))\n            {\n                setAuthenticated(false);\n                throw new FailedLoginException();\n            }\n\n            UserInfo userInfo = getUserInfo(webUserName);\n\n            if (userInfo == null)\n            {\n                setAuthenticated(false);\n                throw new FailedLoginException();\n            }\n\n            currentUser = new JAASUserInfo(userInfo);\n            setAuthenticated(currentUser.checkCredential(webCredential));\n          \n            if (isAuthenticated())\n                return true;\n            else\n                throw new FailedLoginException();\n        }\n        catch (IOException e)\n        {\n            throw new LoginException (e.toString());\n        }\n        catch (UnsupportedCallbackException e)\n        {\n            throw new LoginException (e.toString());\n        }\n        catch (Exception e)\n        {\n            if (e instanceof LoginException)\n                throw (LoginException)e;\n            throw new LoginException (e.toString());\n        }\n    }","commit_id":"b6a306a6b8f443b001f477390c33f07e1ad7e6fc","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Don't implement this as we want to pre-fetch all of the users.\n     *\n     * @param userName\n     * @throws Exception\n     */\n    public UserInfo getUserInfo(String userName) throws Exception\n    {\n        PropertyUserStore propertyUserStore = _propertyUserStores.get(_filename);\n        if (propertyUserStore == null)\n            throw new IllegalStateException(\"PropertyUserStore should never be null here!\");\n\n        UserIdentity userIdentity = propertyUserStore.getUserIdentity(userName);\n        if(userIdentity==null)\n            return null;\n\n        Set<Principal> principals = userIdentity.getSubject().getPrincipals();\n\n        List<String> roles = new ArrayList<String>();\n\n        for ( Principal principal : principals )\n        {\n            roles.add( principal.getName() );\n        }\n\n        Credential credential = (Credential)userIdentity.getSubject().getPrivateCredentials().iterator().next();\n        LOG.debug(\"Found: \" + userName + \" in PropertyUserStore\");\n        return new UserInfo(userName, credential, roles);\n    }","id":38080,"modified_method":"/**\n     * Don't implement this as we want to pre-fetch all of the users.\n     *\n     * @param userName\n     * @throws Exception\n     */\n    public UserInfo getUserInfo(String userName) throws Exception\n    {\n        PropertyUserStore propertyUserStore = _propertyUserStores.get(_filename);\n        if (propertyUserStore == null)\n            throw new IllegalStateException(\"PropertyUserStore should never be null here!\");\n        \n        LOG.debug(\"Checking PropertyUserStore \"+_filename+\" for \"+userName);\n        UserIdentity userIdentity = propertyUserStore.getUserIdentity(userName);\n        if (userIdentity==null)\n            return null;\n\n        Set<Principal> principals = userIdentity.getSubject().getPrincipals();\n\n        List<String> roles = new ArrayList<String>();\n\n        for ( Principal principal : principals )\n        {\n            roles.add( principal.getName() );\n        }\n\n        Credential credential = (Credential)userIdentity.getSubject().getPrivateCredentials().iterator().next();\n        LOG.debug(\"Found: \" + userName + \" in PropertyUserStore \"+_filename);\n        return new UserInfo(userName, credential, roles);\n    }","commit_id":"b6a306a6b8f443b001f477390c33f07e1ad7e6fc","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public boolean insertBefore(Component child, Component insertBefore) {\n\t\tif (!(child instanceof Tab))\n\t\t\tthrow new UiException(\"Unsupported child for tabs: \"+child);\n\n\t\t//Note: since we have to ensure one of the tabs is selected,\n\t\t//we always make the first tab selected (unless we have better algorithm)\n\t\t//In other words, to select a tab other than the first one,\n\t\t//you have to set the parent first, and then call setSelected!\n\t\tfinal boolean empty = getChildren().isEmpty();\n\t\tfinal Tab newtab = (Tab)child;\n\t\tif (!empty && newtab.isSelected()) newtab.setSelectedDirectly(false);\n\n\t\tif (super.insertBefore(child, insertBefore)) {\n\t\t\tfinal Tabbox tabbox = getTabbox();\n\n\t\t\tif (empty)\n\t\t\t\tif (tabbox != null)\n\t\t\t\t\ttabbox.setSelectedTab(newtab);\n\t\t\t\telse\n\t\t\t\t\tnewtab.setSelectedDirectly(true);\n\n\t\t\tinvalidateIfAccordion(tabbox);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":38081,"modified_method":"public boolean insertBefore(Component child, Component insertBefore) {\n\t\tif (!(child instanceof Tab))\n\t\t\tthrow new UiException(\"Unsupported child for tabs: \"+child);\n\n\t\tboolean sel = getChildren().isEmpty(), desel = false;\n\t\tfinal Tab newtab = (Tab)child;\n\t\tif (!sel && newtab.isSelected()) {\n\t\t\tnewtab.setSelectedDirectly(false);\t//turn off first\n\t\t\tsel = desel = true;\t\t\t\t\t//trun on later\n\t\t}\n\n\t\tif (super.insertBefore(child, insertBefore)) {\n\t\t\tfinal Tabbox tabbox = getTabbox();\n\n\t\t\tif (sel)\n\t\t\t\tif (tabbox != null) {\n\t\t\t\t\ttabbox.setSelectedTab(newtab);\n\t\t\t\t} else {\n\t\t\t\t\tnewtab.setSelectedDirectly(true);\n\t\t\t\t\tif (desel)\n\t\t\t\t\t\tfor (Iterator it = getChildren().iterator(); it.hasNext();) {\n\t\t\t\t\t\t\tfinal Tab tab = (Tab)it.next();\n\t\t\t\t\t\t\tif (tab != newtab && tab.isSelected()) {\n\t\t\t\t\t\t\t\ttab.setSelectedDirectly(false);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tinvalidateIfAccordion(tabbox);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"cae1e96e6c49c9c74f376042d68d6a1c8c7baca2","url":"https://github.com/zkoss/zk"},{"original_method":"public boolean insertBefore(Component child, Component refChild) {\n\t\tboolean sel = getChildren().isEmpty(), desel = false;\n\t\tfinal Tab newtab = (Tab)child;\n\t\tif (!sel && newtab.isSelected()) {\n\t\t\tnewtab.setSelectedDirectly(false);\t//turn off first\n\t\t\tsel = desel = true;\t\t\t\t\t//trun on later\n\t\t}\n\n\t\tif (super.insertBefore(child, refChild)) {\n\t\t\tfinal Tabbox tabbox = getTabbox();\n\n\t\t\tif (sel)\n\t\t\t\tif (tabbox != null) {\n\t\t\t\t\ttabbox.setSelectedTab(newtab);\n\t\t\t\t} else {\n\t\t\t\t\tnewtab.setSelectedDirectly(true);\n\t\t\t\t\tif (desel)\n\t\t\t\t\t\tfor (Iterator it = getChildren().iterator(); it.hasNext();) {\n\t\t\t\t\t\t\tfinal Tab tab = (Tab)it.next();\n\t\t\t\t\t\t\tif (tab != newtab && tab.isSelected()) {\n\t\t\t\t\t\t\t\ttab.setSelectedDirectly(false);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":38082,"modified_method":"public boolean insertBefore(Component child, Component refChild) {\n\t\tboolean sel = getChildren().isEmpty(), desel = false;\n\t\tfinal Tab newtab = (Tab)child;\n\t\tif (!sel && newtab.isSelected()) {\n\t\t\tif (newtab.getTabbox() != null) // B65-ZK-1597\n\t\t\t\tnewtab.setSelected(false); //reset it\n\t\t\telse\n\t\t\t\tnewtab.setSelectedDirectly(false);\t//turn off first\n\t\t\tsel = desel = true;\t\t\t\t\t//trun on later\n\t\t}\n\n\t\tif (super.insertBefore(child, refChild)) {\n\t\t\tfinal Tabbox tabbox = getTabbox();\n\n\t\t\tif (sel)\n\t\t\t\tif (tabbox != null) {\n\t\t\t\t\ttabbox.setSelectedTab(newtab);\n\t\t\t\t} else {\n\t\t\t\t\tnewtab.setSelectedDirectly(true);\n\t\t\t\t\tif (desel)\n\t\t\t\t\t\tfor (Iterator it = getChildren().iterator(); it.hasNext();) {\n\t\t\t\t\t\t\tfinal Tab tab = (Tab)it.next();\n\t\t\t\t\t\t\tif (tab != newtab && tab.isSelected()) {\n\t\t\t\t\t\t\t\ttab.setSelectedDirectly(false);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"f3f71c0aa89bce071035b58e64847e08c71623d4","url":"https://github.com/zkoss/zk"},{"original_method":"protected String getBody(\n\t\t\tlong classPK, int type, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tif (type == _ACTIVITY_KEY_ADD_ENTRY) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tMicroblogsEntry microblogsEntry =\n\t\t\tMicroblogsEntryLocalServiceUtil.fetchMicroblogsEntry(classPK);\n\n\t\tif (microblogsEntry == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tString userDisplayURL = StringPool.BLANK;\n\t\tString userFullName = StringPool.BLANK;\n\t\tString userPortraitURL = StringPool.BLANK;\n\n\t\tUser user = UserLocalServiceUtil.fetchUser(microblogsEntry.getUserId());\n\n\t\tif (user != null) {\n\t\t\tuserDisplayURL = user.getDisplayURL(\n\t\t\t\tserviceContext.getThemeDisplay());\n\t\t\tuserFullName = user.getFullName();\n\t\t\tuserPortraitURL = user.getPortraitURL(\n\t\t\t\tserviceContext.getThemeDisplay());\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(12);\n\n\t\tsb.append(\"<div class=\\\"activity-body-container\\\">\");\n\t\tsb.append(\"<div class=\\\"activity-body\\\">\");\n\t\tsb.append(\"<div class=\\\"user-portrait\\\"><span class=\\\"avatar\\\">\");\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(userDisplayURL);\n\t\tsb.append(\"\\\"><img alt=\\\"\");\n\t\tsb.append(userFullName);\n\t\tsb.append(\"\\\" src=\");\n\t\tsb.append(userPortraitURL);\n\t\tsb.append(\"\\\"/><\/a><\/span><\/div>\");\n\t\tsb.append(\n\t\t\tMicroblogsUtil.getTaggedContent(microblogsEntry, serviceContext));\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":38083,"modified_method":"protected String getBody(\n\t\t\tlong classPK, int type, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tif (type == _ACTIVITY_KEY_ADD_ENTRY) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tMicroblogsEntry microblogsEntry =\n\t\t\tMicroblogsEntryLocalServiceUtil.fetchMicroblogsEntry(classPK);\n\n\t\tif (microblogsEntry == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(12);\n\n\t\tsb.append(\"<div class=\\\"activity-body-container\\\">\");\n\t\tsb.append(\"<div class=\\\"activity-body\\\">\");\n\t\tsb.append(\"<div class=\\\"user-portrait\\\"><span class=\\\"avatar\\\">\");\n\t\tsb.append(\"<a href=\\\"\");\n\n\t\tUser user = UserLocalServiceUtil.fetchUser(microblogsEntry.getUserId());\n\n\t\tif (user != null) {\n\t\t\tsb.append(user.getDisplayURL(serviceContext.getThemeDisplay()));\n\t\t}\n\n\t\tsb.append(\"\\\"><img alt=\\\"\");\n\n\t\tif (user != null) {\n\t\t\tsb.append(user.getFullName());\n\t\t}\n\n\t\tsb.append(\"\\\" src=\");\n\n\t\tif (user != null) {\n\t\t\tsb.append(user.getPortraitURL(serviceContext.getThemeDisplay()));\n\t\t}\n\n\t\tsb.append(\"\\\"/><\/a><\/span><\/div>\");\n\t\tsb.append(\n\t\t\tMicroblogsUtil.getTaggedContent(microblogsEntry, serviceContext));\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"067a6bdc7ad70efdb76b00bd14acb9264881cc32","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getTitle(\n\t\t\tlong activitySetId, long groupId, long userId, long displayDate,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(\"<div class=\\\"activity-header\\\">\");\n\t\tsb.append(\"<div class=\\\"activity-time\\\" title=\\\"\");\n\n\t\tFormat dateFormatDate = getFormatDateTime(\n\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\tDate activityDate = new Date(displayDate);\n\n\t\tsb.append(dateFormatDate.format(activityDate));\n\n\t\tsb.append(\"\\\">\");\n\n\t\tString relativeTimeDescription = Time.getRelativeTimeDescription(\n\t\t\tdisplayDate, serviceContext.getLocale(),\n\t\t\tserviceContext.getTimeZone());\n\n\t\tsb.append(relativeTimeDescription);\n\n\t\tsb.append(\"<\/div><div class=\\\"activity-user-name\\\">\");\n\n\t\tString userName = getUserName(userId, serviceContext);\n\n\t\tint otherUsersCount = 0;\n\n\t\tif (activitySetId > 0) {\n\t\t\tList<Long> userIds = getActivitySetUserIds(activitySetId);\n\n\t\t\totherUsersCount = userIds.size() - 1;\n\t\t}\n\n\t\tif ((groupId != serviceContext.getScopeGroupId()) && (groupId > 0)) {\n\t\t\tString groupName = getGroupName(groupId, serviceContext);\n\n\t\t\tif (otherUsersCount > 0) {\n\t\t\t\tObject[] userArguments =\n\t\t\t\t\tnew Object[] {userName, otherUsersCount, groupName};\n\n\t\t\t\tsb.append(\n\t\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\t\"x-and-x-others-in-x\", userArguments));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject[] userArguments = new Object[] {userName, groupName};\n\n\t\t\t\tsb.append(serviceContext.translate(\"x-in-x\", userArguments));\n\t\t\t}\n\t\t}\n\t\telse if (otherUsersCount > 0) {\n\t\t\tObject userArguments = new Object[] {userName, otherUsersCount};\n\n\t\t\tsb.append(\n\t\t\t\tserviceContext.translate(\"x-and-x-others\", userArguments));\n\t\t}\n\t\telse {\n\t\t\tsb.append(userName);\n\t\t}\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":38084,"modified_method":"protected String getTitle(\n\t\t\tlong activitySetId, long groupId, long userId, long displayDate,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(8);\n\n\t\tsb.append(\"<div class=\\\"activity-header\\\">\");\n\t\tsb.append(\"<div class=\\\"activity-time\\\" title=\\\"\");\n\n\t\tFormat dateFormatDate = getFormatDateTime(\n\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\tDate activityDate = new Date(displayDate);\n\n\t\tsb.append(dateFormatDate.format(activityDate));\n\n\t\tsb.append(\"\\\">\");\n\n\t\tString relativeTimeDescription = Time.getRelativeTimeDescription(\n\t\t\tdisplayDate, serviceContext.getLocale(),\n\t\t\tserviceContext.getTimeZone());\n\n\t\tsb.append(relativeTimeDescription);\n\n\t\tsb.append(\"<\/div><div class=\\\"activity-user-name\\\">\");\n\n\t\tString userName = getUserName(userId, serviceContext);\n\n\t\tint otherUsersCount = 0;\n\n\t\tif (activitySetId > 0) {\n\t\t\tList<Long> userIds = getActivitySetUserIds(activitySetId);\n\n\t\t\totherUsersCount = userIds.size() - 1;\n\t\t}\n\n\t\tif ((groupId != serviceContext.getScopeGroupId()) && (groupId > 0)) {\n\t\t\tString groupName = getGroupName(groupId, serviceContext);\n\n\t\t\tif (otherUsersCount > 0) {\n\t\t\t\tsb.append(\n\t\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\t\"x-and-x-others-in-x\",\n\t\t\t\t\t\tnew Object[] {userName, otherUsersCount, groupName}));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\n\t\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\t\"x-in-x\", new Object[] {userName, groupName}));\n\t\t\t}\n\t\t}\n\t\telse if (otherUsersCount > 0) {\n\t\t\tsb.append(\n\t\t\t\tserviceContext.translate(\n\t\t\t\t\t\"x-and-x-others\",\n\t\t\t\t\tnew Object[] {userName, otherUsersCount}));\n\t\t}\n\t\telse {\n\t\t\tsb.append(userName);\n\t\t}\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"067a6bdc7ad70efdb76b00bd14acb9264881cc32","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(14);\n\n\t\tsb.append(\"<div class=\\\"activity-body-container \");\n\n\t\tTasksEntry tasksEntry = TasksEntryLocalServiceUtil.getTasksEntry(\n\t\t\tclassPK);\n\n\t\tsb.append(tasksEntry.getPriorityLabel());\n\n\t\tsb.append(\"\\\"><div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"tasks-entry-content\\\">\");\n\t\tsb.append(\"<span class=\\\"tasks-entry-status\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"assigned-to\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tUser assigneeUser = UserLocalServiceUtil.fetchUser(\n\t\t\ttasksEntry.getAssigneeUserId());\n\n\t\tString assigneeDisplayURL = assigneeUser.getDisplayURL(\n\t\t\tserviceContext.getThemeDisplay());\n\n\t\tString assigneeUserLink = wrapLink(\n\t\t\tassigneeDisplayURL,\n\t\t\tHtmlUtil.escape(tasksEntry.getAssigneeFullName()));\n\n\t\tsb.append(assigneeUserLink);\n\t\tsb.append(\"<\/span><span class=\\\"tasks-entry-due-date\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"due-date\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tif (tasksEntry.getDueDate() != null) {\n\t\t\tFormat dateFormatDateTime = FastDateFormatFactoryUtil.getDateTime(\n\t\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\t\tsb.append(dateFormatDateTime.format(tasksEntry.getDueDate()));\n\t\t}\n\t\telse {\n\t\t\tsb.append(serviceContext.translate(\"none\"));\n\t\t}\n\n\t\tsb.append(\"<\/span><\/div><\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":38085,"modified_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(14);\n\n\t\tsb.append(\"<div class=\\\"activity-body-container \");\n\n\t\tTasksEntry tasksEntry = TasksEntryLocalServiceUtil.getTasksEntry(\n\t\t\tclassPK);\n\n\t\tsb.append(tasksEntry.getPriorityLabel());\n\n\t\tsb.append(\"\\\"><div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"tasks-entry-content\\\">\");\n\t\tsb.append(\"<span class=\\\"tasks-entry-status\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"assigned-to\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tif (tasksEntry.getAssigneeUserId() > 0) {\n\t\t\tString assigneeDisplayURL = null;\n\n\t\t\tUser assigneeUser = UserLocalServiceUtil.fetchUser(\n\t\t\t\ttasksEntry.getAssigneeUserId());\n\n\t\t\tif (assigneeUser != null) {\n\t\t\t\tassigneeDisplayURL = assigneeUser.getDisplayURL(\n\t\t\t\t\tserviceContext.getThemeDisplay());\n\t\t\t}\n\n\t\t\tString assigneeUserLink = wrapLink(\n\t\t\t\tassigneeDisplayURL,\n\t\t\t\tHtmlUtil.escape(tasksEntry.getAssigneeFullName()));\n\n\t\t\tsb.append(assigneeUserLink);\n\t\t}\n\t\telse {\n\t\t\tsb.append(serviceContext.translate(\"unassigned\"));\n\t\t}\n\n\t\tsb.append(\"<\/span><span class=\\\"tasks-entry-due-date\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"due-date\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tif (tasksEntry.getDueDate() != null) {\n\t\t\tFormat dateFormatDateTime = FastDateFormatFactoryUtil.getDateTime(\n\t\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\t\tsb.append(dateFormatDateTime.format(tasksEntry.getDueDate()));\n\t\t}\n\t\telse {\n\t\t\tsb.append(serviceContext.translate(\"none\"));\n\t\t}\n\n\t\tsb.append(\"<\/span><\/div><\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"f107fb39ea438c7c936ed01a688642c0f04b6db2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public String getQuickNavigateInfo(PsiElement element) {\n    if (element instanceof PsiClass) {\n      return generateClassInfo((PsiClass) element);\n    } else if (element instanceof PsiMethod) {\n      return generateMethodInfo((PsiMethod) element);\n    } else if (element instanceof PsiField) {\n      return generateFieldInfo((PsiField) element);\n    } else if (element instanceof PsiVariable) {\n      return generateVariableInfo((PsiVariable) element);\n    } else if (element instanceof PsiPackage) {\n      return generatePackageInfo((PsiPackage) element);\n    }\n    return null;\n  }","id":38086,"modified_method":"public String getQuickNavigateInfo(PsiElement element) {\n    if (element instanceof PsiClass) {\n      return generateClassInfo((PsiClass) element);\n    } else if (element instanceof PsiMethod) {\n      return generateMethodInfo((PsiMethod) element);\n    } else if (element instanceof PsiField) {\n      return generateFieldInfo((PsiField) element);\n    } else if (element instanceof PsiVariable) {\n      return generateVariableInfo((PsiVariable) element);\n    } else if (element instanceof PsiPackage) {\n      return generatePackageInfo((PsiPackage) element);\n    }\n    return super.getQuickNavigateInfo(element);\n  }","commit_id":"1c95d116909a0333eb1df9ec6a1f72b0eaef0306","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getDocumentationElementForLink(final PsiManager psiManager, String link, PsiElement context) {\n    return null;\n  }","id":38087,"modified_method":"public PsiElement getDocumentationElementForLink(final PsiManager psiManager, String link, PsiElement context) {\n    return super.getDocumentationElementForLink(psiManager, link, context);\n  }","commit_id":"1c95d116909a0333eb1df9ec6a1f72b0eaef0306","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getUrlFor(PsiElement element, PsiElement originalElement) {\n    if (element instanceof XmlTag) {\n      XmlTag tag = (XmlTag)element;\n\n      MyPsiElementProcessor processor = new MyPsiElementProcessor();\n      XmlUtil.processXmlElements(tag,processor, true);\n\n      if (processor.url == null) {\n        XmlTag declaration = getComplexTypeDefinition(element, originalElement);\n\n        if (declaration != null) {\n          XmlUtil.processXmlElements(declaration,processor, true);\n        }\n      }\n\n      return processor.url;\n    }\n\n    return null;\n  }","id":38088,"modified_method":"public String getUrlFor(PsiElement element, PsiElement originalElement) {\n    if (element instanceof XmlTag) {\n      XmlTag tag = (XmlTag)element;\n\n      MyPsiElementProcessor processor = new MyPsiElementProcessor();\n      XmlUtil.processXmlElements(tag,processor, true);\n\n      if (processor.url == null) {\n        XmlTag declaration = getComplexTypeDefinition(element, originalElement);\n\n        if (declaration != null) {\n          XmlUtil.processXmlElements(declaration,processor, true);\n        }\n      }\n\n      return processor.url;\n    }\n    return super.getUrlFor(element, originalElement);\n  }","commit_id":"1c95d116909a0333eb1df9ec6a1f72b0eaef0306","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getQuickNavigateInfo(PsiElement element) {\n    return myDocumentationProvider.getQuickNavigateInfo(element);\n  }","id":38089,"modified_method":"@Nullable\n  public String getQuickNavigateInfo(PsiElement element) {\n    final String navigateInfo = myDocumentationProvider.getQuickNavigateInfo(element);\n    return navigateInfo != null? navigateInfo : super.getQuickNavigateInfo(element);\n  }","commit_id":"1c95d116909a0333eb1df9ec6a1f72b0eaef0306","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getDocumentationElementForLookupItem(final PsiManager psiManager, Object object, PsiElement element) {\n    final PsiElement originalElement = element;\n    boolean isAttrCompletion = element instanceof XmlAttribute;\n\n    if (!isAttrCompletion && element instanceof XmlToken) {\n      final IElementType tokenType = ((XmlToken)element).getTokenType();\n\n      if (tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END || tokenType == XmlTokenType.XML_TAG_END) {\n        isAttrCompletion = true;\n      } else if (element.getParent() instanceof XmlAttribute) {\n        isAttrCompletion = true;\n      }\n    }\n\n    element = PsiTreeUtil.getParentOfType(element, XmlTag.class, false);\n\n    if (element instanceof XmlTag) {\n      XmlTag xmlTag = (XmlTag)element;\n      XmlElementDescriptor elementDescriptor;\n\n      if (isAttrCompletion && object instanceof String) {\n        elementDescriptor = xmlTag.getDescriptor();\n\n        if (elementDescriptor != null) {\n          final XmlAttributeDescriptor attributeDescriptor = elementDescriptor.getAttributeDescriptor((String)object, xmlTag);\n          if (attributeDescriptor != null) {\n            final PsiElement declaration = attributeDescriptor.getDeclaration();\n            if (declaration != null) return declaration;\n          }\n        }\n      }\n\n      try {\n        @NonNls StringBuffer tagText = new StringBuffer(object.toString());\n        String namespacePrefix = XmlUtil.findPrefixByQualifiedName(object.toString());\n        String namespace = xmlTag.getNamespaceByPrefix(namespacePrefix);\n\n        if (namespace!=null && namespace.length() > 0) {\n          tagText.append(\" xmlns\");\n          if (namespacePrefix.length() > 0) tagText.append(\":\").append(namespacePrefix);\n          tagText.append(\"=\\\"\").append(namespace).append(\"\\\"\");\n        }\n\n        XmlTag tagFromText = xmlTag.getManager().getElementFactory().createTagFromText(\"<\" + tagText +\"/>\");\n        XmlElementDescriptor parentDescriptor = xmlTag.getDescriptor();\n        elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText):null;\n\n        if (elementDescriptor==null) {\n          PsiElement parent = xmlTag.getParent();\n          if (parent instanceof XmlTag) {\n            parentDescriptor = ((XmlTag)parent).getDescriptor();\n            elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText):null;\n          }\n        }\n\n        if (elementDescriptor instanceof AnyXmlElementDescriptor) {\n          final XmlNSDescriptor nsDescriptor = xmlTag.getNSDescriptor(xmlTag.getNamespaceByPrefix(namespacePrefix), true);\n          elementDescriptor = (nsDescriptor != null)?nsDescriptor.getElementDescriptor(tagFromText):null;\n        }\n\n        // The very special case of xml file \n        final PsiFile containingFile = xmlTag.getContainingFile();\n        if (PsiUtil.isInJspFile(containingFile)) {\n          final XmlTag rootTag = ((XmlFile)containingFile).getDocument().getRootTag();\n          if (rootTag != null) {\n            final XmlNSDescriptor nsDescriptor = rootTag.getNSDescriptor(rootTag.getNamespaceByPrefix(namespacePrefix), true);\n            elementDescriptor = (nsDescriptor != null) ? nsDescriptor.getElementDescriptor(tagFromText) : null;\n          }\n        }\n\n        if (elementDescriptor != null) {\n          PsiElement declaration = elementDescriptor.getDeclaration();\n          if (declaration!=null) declaration.putUserData(DESCRIPTOR_KEY,elementDescriptor);\n          return declaration;\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n\n    if (object instanceof String && element != null) {\n      return findEntityDeclWithName((String)object, element);\n    }\n    return null;\n  }","id":38090,"modified_method":"public PsiElement getDocumentationElementForLookupItem(final PsiManager psiManager, Object object, PsiElement element) {\n    final PsiElement originalElement = element;\n    boolean isAttrCompletion = element instanceof XmlAttribute;\n\n    if (!isAttrCompletion && element instanceof XmlToken) {\n      final IElementType tokenType = ((XmlToken)element).getTokenType();\n\n      if (tokenType == XmlTokenType.XML_EMPTY_ELEMENT_END || tokenType == XmlTokenType.XML_TAG_END) {\n        isAttrCompletion = true;\n      } else if (element.getParent() instanceof XmlAttribute) {\n        isAttrCompletion = true;\n      }\n    }\n\n    element = PsiTreeUtil.getParentOfType(element, XmlTag.class, false);\n\n    if (element instanceof XmlTag) {\n      XmlTag xmlTag = (XmlTag)element;\n      XmlElementDescriptor elementDescriptor;\n\n      if (isAttrCompletion && object instanceof String) {\n        elementDescriptor = xmlTag.getDescriptor();\n\n        if (elementDescriptor != null) {\n          final XmlAttributeDescriptor attributeDescriptor = elementDescriptor.getAttributeDescriptor((String)object, xmlTag);\n          if (attributeDescriptor != null) {\n            final PsiElement declaration = attributeDescriptor.getDeclaration();\n            if (declaration != null) return declaration;\n          }\n        }\n      }\n\n      try {\n        @NonNls StringBuffer tagText = new StringBuffer(object.toString());\n        String namespacePrefix = XmlUtil.findPrefixByQualifiedName(object.toString());\n        String namespace = xmlTag.getNamespaceByPrefix(namespacePrefix);\n\n        if (namespace!=null && namespace.length() > 0) {\n          tagText.append(\" xmlns\");\n          if (namespacePrefix.length() > 0) tagText.append(\":\").append(namespacePrefix);\n          tagText.append(\"=\\\"\").append(namespace).append(\"\\\"\");\n        }\n\n        XmlTag tagFromText = xmlTag.getManager().getElementFactory().createTagFromText(\"<\" + tagText +\"/>\");\n        XmlElementDescriptor parentDescriptor = xmlTag.getDescriptor();\n        elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText):null;\n\n        if (elementDescriptor==null) {\n          PsiElement parent = xmlTag.getParent();\n          if (parent instanceof XmlTag) {\n            parentDescriptor = ((XmlTag)parent).getDescriptor();\n            elementDescriptor = (parentDescriptor!=null)?parentDescriptor.getElementDescriptor(tagFromText):null;\n          }\n        }\n\n        if (elementDescriptor instanceof AnyXmlElementDescriptor) {\n          final XmlNSDescriptor nsDescriptor = xmlTag.getNSDescriptor(xmlTag.getNamespaceByPrefix(namespacePrefix), true);\n          elementDescriptor = (nsDescriptor != null)?nsDescriptor.getElementDescriptor(tagFromText):null;\n        }\n\n        // The very special case of xml file \n        final PsiFile containingFile = xmlTag.getContainingFile();\n        if (PsiUtil.isInJspFile(containingFile)) {\n          final XmlTag rootTag = ((XmlFile)containingFile).getDocument().getRootTag();\n          if (rootTag != null) {\n            final XmlNSDescriptor nsDescriptor = rootTag.getNSDescriptor(rootTag.getNamespaceByPrefix(namespacePrefix), true);\n            elementDescriptor = (nsDescriptor != null) ? nsDescriptor.getElementDescriptor(tagFromText) : null;\n          }\n        }\n\n        if (elementDescriptor != null) {\n          PsiElement declaration = elementDescriptor.getDeclaration();\n          if (declaration!=null) declaration.putUserData(DESCRIPTOR_KEY,elementDescriptor);\n          return declaration;\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }\n\n    if (object instanceof String && element != null) {\n      return findEntityDeclWithName((String)object, element);\n    }\n    return super.getDocumentationElementForLookupItem(psiManager, object, element);\n  }","commit_id":"1c95d116909a0333eb1df9ec6a1f72b0eaef0306","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String generateDoc(PsiElement element, PsiElement originalElement) {\n    if (element instanceof XmlElementDecl) {\n      PsiElement curElement = findPreviousComment(element);\n\n      if (curElement!=null) {\n        return formatDocFromComment(curElement, ((XmlElementDecl)element).getNameElement().getText());\n      }\n    } else if (element instanceof XmlTag) {\n      XmlTag tag = (XmlTag)element;\n\n      MyPsiElementProcessor processor = new MyPsiElementProcessor();\n      XmlUtil.processXmlElements(tag,processor, true);\n      String name = tag.getAttributeValue(NAME_ATTR_NAME);\n      String typeName = null;\n\n      if (processor.result == null) {\n        XmlTag declaration = getComplexTypeDefinition(element, originalElement);\n\n        if (declaration != null) {\n          XmlUtil.processXmlElements(declaration,processor, true);\n          name = declaration.getAttributeValue(NAME_ATTR_NAME);\n          typeName = declaration.getName();\n        }\n      }\n\n      return generateDoc(processor.result, name, typeName);\n    } else if (element instanceof XmlAttributeDecl) {\n      // Check for comment before attlist, it should not be right after previous declaration\n      final PsiElement parent = element.getParent();\n      final PsiElement previousComment = findPreviousComment(parent);\n      final String referenceName = ((XmlAttributeDecl)element).getNameElement().getText();\n\n      if (previousComment instanceof PsiComment) {\n        final PsiElement prevSibling = previousComment.getPrevSibling();\n\n        if (prevSibling == null ||\n            ( prevSibling instanceof PsiWhiteSpace &&\n              prevSibling.getText().indexOf('\\n') >= 0\n            )\n           ) {\n          return formatDocFromComment(previousComment, referenceName);\n        }\n      }\n\n      return findDocRightAfterElement(parent, referenceName);\n    } else if (element instanceof XmlEntityDecl) {\n      final XmlEntityDecl entityDecl = (XmlEntityDecl)element;\n\n      return findDocRightAfterElement(element, entityDecl.getName());\n    }\n\n    return null;\n  }","id":38091,"modified_method":"public String generateDoc(PsiElement element, PsiElement originalElement) {\n    if (element instanceof XmlElementDecl) {\n      PsiElement curElement = findPreviousComment(element);\n\n      if (curElement!=null) {\n        return formatDocFromComment(curElement, ((XmlElementDecl)element).getNameElement().getText());\n      }\n    } else if (element instanceof XmlTag) {\n      XmlTag tag = (XmlTag)element;\n\n      MyPsiElementProcessor processor = new MyPsiElementProcessor();\n      XmlUtil.processXmlElements(tag,processor, true);\n      String name = tag.getAttributeValue(NAME_ATTR_NAME);\n      String typeName = null;\n\n      if (processor.result == null) {\n        XmlTag declaration = getComplexTypeDefinition(element, originalElement);\n\n        if (declaration != null) {\n          XmlUtil.processXmlElements(declaration,processor, true);\n          name = declaration.getAttributeValue(NAME_ATTR_NAME);\n          typeName = declaration.getName();\n        }\n      }\n\n      return generateDoc(processor.result, name, typeName);\n    } else if (element instanceof XmlAttributeDecl) {\n      // Check for comment before attlist, it should not be right after previous declaration\n      final PsiElement parent = element.getParent();\n      final PsiElement previousComment = findPreviousComment(parent);\n      final String referenceName = ((XmlAttributeDecl)element).getNameElement().getText();\n\n      if (previousComment instanceof PsiComment) {\n        final PsiElement prevSibling = previousComment.getPrevSibling();\n\n        if (prevSibling == null ||\n            ( prevSibling instanceof PsiWhiteSpace &&\n              prevSibling.getText().indexOf('\\n') >= 0\n            )\n           ) {\n          return formatDocFromComment(previousComment, referenceName);\n        }\n      }\n\n      return findDocRightAfterElement(parent, referenceName);\n    } else if (element instanceof XmlEntityDecl) {\n      final XmlEntityDecl entityDecl = (XmlEntityDecl)element;\n\n      return findDocRightAfterElement(element, entityDecl.getName());\n    }\n\n    return super.generateDoc(element, originalElement);\n  }","commit_id":"1c95d116909a0333eb1df9ec6a1f72b0eaef0306","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static String generateInfo(PsiElement element, PsiElement atPointer) {\n    final DocumentationProvider documentationProvider = DocumentationManager.getProviderFromElement(element, atPointer);\n\n    String info = documentationProvider.getQuickNavigateInfo(element, atPointer);\n\n    if (info != null) {\n      return info;\n    }\n\n    if (element instanceof PsiFile) {\n      final VirtualFile virtualFile = ((PsiFile)element).getVirtualFile();\n      if (virtualFile != null) {\n        return virtualFile.getPresentableUrl();\n      }\n    }\n\n    if (element instanceof NavigationItem) {\n      final ItemPresentation presentation = ((NavigationItem)element).getPresentation();\n      if (presentation != null) {\n        return presentation.getPresentableText();\n      }\n    }\n\n    return getQuickNavigateInfo(element);\n  }","id":38092,"modified_method":"@Nullable\n  private static String generateInfo(PsiElement element, PsiElement atPointer) {\n    final DocumentationProvider documentationProvider = DocumentationManager.getProviderFromElement(element, atPointer);\n\n    String info = documentationProvider.getQuickNavigateInfo(element, atPointer);\n    if (info == null) {\n      info = getQuickNavigateInfo(element);\n    }\n    if (info != null) {\n      return info;\n    }\n\n    if (element instanceof PsiFile) {\n      final VirtualFile virtualFile = ((PsiFile)element).getVirtualFile();\n      if (virtualFile != null) {\n        return virtualFile.getPresentableUrl();\n      }\n    }\n\n    if (element instanceof NavigationItem) {\n      final ItemPresentation presentation = ((NavigationItem)element).getPresentation();\n      if (presentation != null) {\n        return presentation.getPresentableText();\n      }\n    }\n\n    return null;\n  }","commit_id":"6988a8b69925f28354ee20f11337f63259667556","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isKotlinDeclaration(DeclarationDescriptor descriptor, BindingContext bindingContext) {\n        PsiElement declaration = BindingContextUtils.descriptorToDeclaration(bindingContext, descriptor);\n        if (declaration == null) return false;\n        if (JetLanguage.INSTANCE == declaration.getLanguage()) return true;\n        ClsClassImpl clsClass = PsiTreeUtil.getParentOfType(declaration, ClsClassImpl.class);\n        if (clsClass == null) return false;\n        return JetDecompiledData.isKotlinFile((ClsFileImpl) clsClass.getContainingFile());\n    }","id":38093,"modified_method":"private static boolean isKotlinDeclaration(DeclarationDescriptor descriptor, BindingContext bindingContext, Project project) {\n        PsiElement declaration = BindingContextUtils.descriptorToDeclaration(bindingContext, descriptor);\n        if (declaration == null) {\n            StandardLibraryReferenceResolver libraryReferenceResolver = project\n                    .getComponent(StandardLibraryReferenceResolver.class);\n            final Collection<PsiElement> elements = libraryReferenceResolver.resolveStandardLibrarySymbol(descriptor);\n            if (elements.isEmpty()) return false;\n            declaration = elements.iterator().next();\n        }\n        if (declaration == null) return false;\n        if (JetLanguage.INSTANCE == declaration.getLanguage()) return true;\n        ClsClassImpl clsClass = PsiTreeUtil.getParentOfType(declaration, ClsClassImpl.class);\n        if (clsClass == null) return false;\n        return JetDecompiledData.isKotlinFile((ClsFileImpl) clsClass.getContainingFile());\n    }","commit_id":"a930ae1b4f8ffceb98ed03c131defd4f2831a32c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static String render(@NotNull DeclarationDescriptor declarationDescriptor, @NotNull BindingContext bindingContext,\n            PsiElement element, PsiElement originalElement, boolean mergeKotlinAndJava) {\n        String renderedDecl = DescriptorRenderer.HTML.render(declarationDescriptor);\n        if (isKotlinDeclaration(declarationDescriptor, bindingContext)) {\n            return renderedDecl;\n        } else {\n            if (mergeKotlinAndJava) {\n                return renderedDecl + \"\\nOriginal: \" + new JavaDocumentationProvider().getQuickNavigateInfo(element, originalElement);\n            } else {\n                return null;\n            }\n        }\n    }","id":38094,"modified_method":"private static String render(@NotNull DeclarationDescriptor declarationDescriptor, @NotNull BindingContext bindingContext,\n            PsiElement element, PsiElement originalElement, boolean mergeKotlinAndJava) {\n        String renderedDecl = DescriptorRenderer.HTML.render(declarationDescriptor);\n        if (isKotlinDeclaration(declarationDescriptor, bindingContext, originalElement.getProject())) {\n            return renderedDecl;\n        }\n        else if (mergeKotlinAndJava) {\n            final String originalInfo = new JavaDocumentationProvider().getQuickNavigateInfo(element, originalElement);\n            if (originalInfo != null) {\n                return renderedDecl + \"\\nOriginal: \" + originalInfo;\n            }\n            return renderedDecl;\n        }\n        return null;\n    }","commit_id":"a930ae1b4f8ffceb98ed03c131defd4f2831a32c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  @Transactional\n  public Set<Resource> getResources(Request request, Predicate predicate)\n          throws SystemException, UnsupportedPropertyException, NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> resources = new HashSet<Resource>();\n\n    final Set<ServiceComponentHostRequest> requests = new HashSet<ServiceComponentHostRequest>();\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      requests.add(getRequest(propertyMap));\n    }\n\n    Set<ServiceComponentHostResponse> responses = null;\n    try {\n      responses = getResources(new Command<Set<ServiceComponentHostResponse>>() {\n        @Override\n        public Set<ServiceComponentHostResponse> invoke() throws AmbariException {\n          return getManagementController().getHostComponents(requests);\n        }\n      });\n    } catch (Exception e) {\n      throw new SystemException(\"Failed to get components \", e);\n    }\n\n    Configuration configs = new Configuration();\n    String TMP_PATH = configs.getProperty(Configuration.SERVER_TMP_DIR_KEY);\n    String pythonCmd = configs.getProperty(Configuration.AMBARI_PYTHON_WRAP_KEY);\n    AmbariManagementController managementController = getManagementController();\n    ConfigHelper configHelper = managementController.getConfigHelper();\n    Cluster cluster = null;\n    Clusters clusters = managementController.getClusters();\n    try {\n      cluster = clusters.getCluster(responses.iterator().next().getClusterName());\n\n      StackId stackId = cluster.getCurrentStackVersion();\n      String serviceName = responses.iterator().next().getServiceName();\n      String componentName = responses.iterator().next().getComponentName();\n      String hostName = responses.iterator().next().getHostname();\n      ComponentInfo componentInfo = null;\n      String packageFolder = null;\n\n      componentInfo = managementController.getAmbariMetaInfo().\n              getComponent(stackId.getStackName(), stackId.getStackVersion(), serviceName, componentName);\n      packageFolder = managementController.getAmbariMetaInfo().\n              getService(stackId.getStackName(), stackId.getStackVersion(), serviceName).getServicePackageFolder();\n\n      String commandScript = componentInfo.getCommandScript().getScript();\n      List<ClientConfigFileDefinition> clientConfigFiles = componentInfo.getClientConfigFiles();\n\n      if (clientConfigFiles == null) {\n        throw new SystemException(\"No configuration files defined for the component \" + componentInfo.getName());\n      }\n\n      String stackRoot = managementController.getAmbariMetaInfo().getStackRoot().getAbsolutePath();\n\n      String packageFolderAbsolute = stackRoot + File.separator + packageFolder;\n      String commandScriptAbsolute = packageFolderAbsolute + File.separator + commandScript;\n\n\n      Map<String, Map<String, String>> configurations = new TreeMap<String, Map<String, String>>();\n      Map<String, Map<String, Map<String, String>>> configurationAttributes = new TreeMap<String, Map<String, Map<String, String>>>();\n\n      Map<String, DesiredConfig> desiredClusterConfigs = cluster.getDesiredConfigs();\n\n      //Get configurations and configuration attributes\n      for (Map.Entry<String, DesiredConfig> desiredConfigEntry : desiredClusterConfigs.entrySet()) {\n\n        String configType = desiredConfigEntry.getKey();\n        DesiredConfig desiredConfig = desiredConfigEntry.getValue();\n        Config clusterConfig = cluster.getConfig(configType, desiredConfig.getTag());\n\n        if (clusterConfig != null) {\n          Map<String, String> props = new HashMap<String, String>(clusterConfig.getProperties());\n\n          // Apply global properties for this host from all config groups\n          Map<String, Map<String, String>> allConfigTags = null;\n          allConfigTags = configHelper\n                  .getEffectiveDesiredTags(cluster, hostName);\n\n          Map<String, Map<String, String>> configTags = new HashMap<String,\n                  Map<String, String>>();\n\n          for (Map.Entry<String, Map<String, String>> entry : allConfigTags.entrySet()) {\n            if (entry.getKey().equals(clusterConfig.getType())) {\n              configTags.put(clusterConfig.getType(), entry.getValue());\n            }\n          }\n\n          Map<String, Map<String, String>> properties = configHelper\n                  .getEffectiveConfigProperties(cluster, configTags);\n\n          if (!properties.isEmpty()) {\n            for (Map<String, String> propertyMap : properties.values()) {\n              props.putAll(propertyMap);\n            }\n          }\n\n          configurations.put(clusterConfig.getType(), props);\n\n          Map<String, Map<String, String>> attrs = new TreeMap<String, Map<String, String>>();\n          configHelper.cloneAttributesMap(clusterConfig.getPropertiesAttributes(), attrs);\n\n          Map<String, Map<String, Map<String, String>>> attributes = configHelper\n                  .getEffectiveConfigAttributes(cluster, configTags);\n          for (Map<String, Map<String, String>> attributesMap : attributes.values()) {\n            configHelper.cloneAttributesMap(attributesMap, attrs);\n          }\n          configurationAttributes.put(clusterConfig.getType(), attrs);\n        }\n      }\n\n      // Hack - Remove passwords from configs\n      if (configurations.get(Configuration.HIVE_CONFIG_TAG)!=null) {\n        configurations.get(Configuration.HIVE_CONFIG_TAG).remove(Configuration.HIVE_METASTORE_PASSWORD_PROPERTY);\n      }\n\n      Map<String, Set<String>> clusterHostInfo = null;\n      ServiceInfo serviceInfo = null;\n      String osFamily = null;\n      clusterHostInfo = StageUtils.getClusterHostInfo(managementController.getClusters().getHostsForCluster(cluster.getClusterName()), cluster);\n      serviceInfo = managementController.getAmbariMetaInfo().getService(stackId.getStackName(),\n              stackId.getStackVersion(), serviceName);\n      clusterHostInfo = substituteHostIndexes(clusterHostInfo);\n      osFamily = clusters.getHost(hostName).getOsFamily();\n\n      TreeMap<String, String> hostLevelParams = new TreeMap<String, String>();\n      hostLevelParams.put(JDK_LOCATION, managementController.getJdkResourceUrl());\n      hostLevelParams.put(JAVA_HOME, managementController.getJavaHome());\n      hostLevelParams.put(JDK_NAME, managementController.getJDKName());\n      hostLevelParams.put(JCE_NAME, managementController.getJCEName());\n      hostLevelParams.put(STACK_NAME, stackId.getStackName());\n      hostLevelParams.put(STACK_VERSION, stackId.getStackVersion());\n      hostLevelParams.put(DB_NAME, managementController.getServerDB());\n      hostLevelParams.put(MYSQL_JDBC_URL, managementController.getMysqljdbcUrl());\n      hostLevelParams.put(ORACLE_JDBC_URL, managementController.getOjdbcUrl());\n      hostLevelParams.putAll(managementController.getRcaParameters());\n      hostLevelParams.putAll(managementController.getRcaParameters());\n\n      // Write down os specific info for the service\n      ServiceOsSpecific anyOs = null;\n      if (serviceInfo.getOsSpecifics().containsKey(AmbariMetaInfo.ANY_OS)) {\n        anyOs = serviceInfo.getOsSpecifics().get(AmbariMetaInfo.ANY_OS);\n      }\n\n      ServiceOsSpecific hostOs = populateServicePackagesInfo(serviceInfo, hostLevelParams, osFamily);\n\n      // Build package list that is relevant for host\n      List<ServiceOsSpecific.Package> packages =\n              new ArrayList<ServiceOsSpecific.Package>();\n      if (anyOs != null) {\n        packages.addAll(anyOs.getPackages());\n      }\n\n      if (hostOs != null) {\n        packages.addAll(hostOs.getPackages());\n      }\n      String packageList = gson.toJson(packages);\n      hostLevelParams.put(PACKAGE_LIST, packageList);\n\n      Set<String> userSet = configHelper.getPropertyValuesWithPropertyType(stackId, PropertyType.USER, cluster);\n      String userList = gson.toJson(userSet);\n      hostLevelParams.put(USER_LIST, userList);\n\n      Set<String> groupSet = configHelper.getPropertyValuesWithPropertyType(stackId, PropertyType.GROUP, cluster);\n      String groupList = gson.toJson(groupSet);\n      hostLevelParams.put(GROUP_LIST, groupList);\n\n      String jsonConfigurations = null;\n      Map<String, Object> commandParams = new HashMap<String, Object>();\n      List<Map<String, String>> xmlConfigs = new LinkedList<Map<String, String>>();\n      List<Map<String, String>> envConfigs = new LinkedList<Map<String, String>>();\n      List<Map<String, String>> propertiesConfigs = new LinkedList<Map<String, String>>();\n\n      //Fill file-dictionary configs from metainfo\n      for (ClientConfigFileDefinition clientConfigFile : clientConfigFiles) {\n        Map<String, String> fileDict = new HashMap<String, String>();\n        fileDict.put(clientConfigFile.getFileName(), clientConfigFile.getDictionaryName());\n        if (clientConfigFile.getType().equals(\"xml\")) {\n          xmlConfigs.add(fileDict);\n        } else if (clientConfigFile.getType().equals(\"env\")) {\n          envConfigs.add(fileDict);\n        } else if (clientConfigFile.getType().equals(\"properties\")) {\n          propertiesConfigs.add(fileDict);\n        }\n      }\n\n      commandParams.put(\"xml_configs_list\", xmlConfigs);\n      commandParams.put(\"env_configs_list\", envConfigs);\n      commandParams.put(\"properties_configs_list\", propertiesConfigs);\n      commandParams.put(\"output_file\", componentName + \"-configs\" + Configuration.DEF_ARCHIVE_EXTENSION);\n\n      Map<String, Object> jsonContent = new TreeMap<String, Object>();\n      jsonContent.put(\"configurations\", configurations);\n      jsonContent.put(\"configuration_attributes\", configurationAttributes);\n      jsonContent.put(\"commandParams\", commandParams);\n      jsonContent.put(\"clusterHostInfo\", clusterHostInfo);\n      jsonContent.put(\"hostLevelParams\", hostLevelParams);\n      jsonContent.put(\"hostname\", hostName);\n      jsonConfigurations = gson.toJson(jsonContent);\n\n      File jsonFileName = new File(TMP_PATH + File.separator + componentName + \"-configuration.json\");\n      File tmpDirectory = new File(jsonFileName.getParent());\n      if (!tmpDirectory.exists()) {\n        try {\n          tmpDirectory.mkdirs();\n          tmpDirectory.setWritable(true, true);\n          tmpDirectory.setReadable(true, true);\n        } catch (SecurityException se) {\n          throw new SystemException(\"Failed to get temporary directory to store configurations\", se);\n        }\n      }\n      PrintWriter printWriter = null;\n      try {\n        printWriter = new PrintWriter(jsonFileName.getAbsolutePath());\n        printWriter.print(jsonConfigurations);\n        printWriter.close();\n      } catch (FileNotFoundException e) {\n        throw new SystemException(\"Failed to write configurations to json file \", e);\n      }\n\n      String cmd = pythonCmd + \" \" + commandScriptAbsolute + \" generate_configs \" + jsonFileName.getAbsolutePath() + \" \" +\n              packageFolderAbsolute + \" \" + TMP_PATH + File.separator + \"structured-out.json\" + \" INFO \" + TMP_PATH;\n\n      try {\n        executeCommand(cmd, configs.getExternalScriptTimeout());\n      } catch (TimeoutException e) {\n        LOG.error(\"Generate client configs script was killed due to timeout \", e);\n        throw new SystemException(\"Generate client configs script was killed due to timeout \", e);\n      } catch (InterruptedException e) {\n        LOG.error(\"Failed to run generate client configs script for a component \" + componentName, e);\n        throw new SystemException(\"Failed to run generate client configs script for a component \" + componentName, e);\n      } catch (ExecutionException e) {\n        LOG.error(e.getMessage(),e);\n        throw new SystemException(e.getMessage() + \" \" + e.getCause());\n      } catch (IOException e) {\n        LOG.error(\"Failed to run generate client configs script for a component \" + componentName, e);\n        throw new SystemException(\"Failed to run generate client configs script for a component \" + componentName, e);\n      }\n\n    } catch (AmbariException e) {\n      throw new SystemException(\"Controller error \", e);\n    }\n\n    Resource resource = new ResourceImpl(Resource.Type.ClientConfig);\n    resources.add(resource);\n    return resources;\n  }","id":38095,"modified_method":"@Override\n  @Transactional\n  public Set<Resource> getResources(Request request, Predicate predicate)\n          throws SystemException, UnsupportedPropertyException, NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> resources = new HashSet<Resource>();\n\n    final Set<ServiceComponentHostRequest> requests = new HashSet<ServiceComponentHostRequest>();\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      requests.add(getRequest(propertyMap));\n    }\n\n    Set<ServiceComponentHostResponse> responses = null;\n    try {\n      responses = getResources(new Command<Set<ServiceComponentHostResponse>>() {\n        @Override\n        public Set<ServiceComponentHostResponse> invoke() throws AmbariException {\n          return getManagementController().getHostComponents(requests);\n        }\n      });\n    } catch (Exception e) {\n      throw new SystemException(\"Failed to get components \", e);\n    }\n\n    Configuration configs = new Configuration();\n    Map<String, String> configMap = configs.getConfigsMap();\n    String TMP_PATH = configMap.get(Configuration.SERVER_TMP_DIR_KEY);\n    String pythonCmd = configMap.get(Configuration.AMBARI_PYTHON_WRAP_KEY);\n    AmbariManagementController managementController = getManagementController();\n    ConfigHelper configHelper = managementController.getConfigHelper();\n    Cluster cluster = null;\n    Clusters clusters = managementController.getClusters();\n    try {\n      cluster = clusters.getCluster(responses.iterator().next().getClusterName());\n\n      StackId stackId = cluster.getCurrentStackVersion();\n      String serviceName = responses.iterator().next().getServiceName();\n      String componentName = responses.iterator().next().getComponentName();\n      String hostName = responses.iterator().next().getHostname();\n      ComponentInfo componentInfo = null;\n      String packageFolder = null;\n\n      componentInfo = managementController.getAmbariMetaInfo().\n              getComponent(stackId.getStackName(), stackId.getStackVersion(), serviceName, componentName);\n      packageFolder = managementController.getAmbariMetaInfo().\n              getService(stackId.getStackName(), stackId.getStackVersion(), serviceName).getServicePackageFolder();\n                   \n      String commandScript = componentInfo.getCommandScript().getScript();\n      List<ClientConfigFileDefinition> clientConfigFiles = componentInfo.getClientConfigFiles();\n\n      if (clientConfigFiles == null) {\n        throw new SystemException(\"No configuration files defined for the component \" + componentInfo.getName());\n      }\n\n      String stackRoot = managementController.getAmbariMetaInfo().getStackRoot().getAbsolutePath();\n      String packageFolderAbsolute = null;\n      if (packageFolder.contains(StackManager.COMMON_SERVICES)){\n        packageFolderAbsolute = configs.getCommonServicesPath().replace(StackManager.COMMON_SERVICES, packageFolder);\n      } else {\n        packageFolderAbsolute = stackRoot + File.separator + packageFolder;\n      }\n      \n      String commandScriptAbsolute = packageFolderAbsolute + File.separator + commandScript;\n\n\n      Map<String, Map<String, String>> configurations = new TreeMap<String, Map<String, String>>();\n      Map<String, Map<String, Map<String, String>>> configurationAttributes = new TreeMap<String, Map<String, Map<String, String>>>();\n\n      Map<String, DesiredConfig> desiredClusterConfigs = cluster.getDesiredConfigs();\n\n      //Get configurations and configuration attributes\n      for (Map.Entry<String, DesiredConfig> desiredConfigEntry : desiredClusterConfigs.entrySet()) {\n\n        String configType = desiredConfigEntry.getKey();\n        DesiredConfig desiredConfig = desiredConfigEntry.getValue();\n        Config clusterConfig = cluster.getConfig(configType, desiredConfig.getTag());\n\n        if (clusterConfig != null) {\n          Map<String, String> props = new HashMap<String, String>(clusterConfig.getProperties());\n\n          // Apply global properties for this host from all config groups\n          Map<String, Map<String, String>> allConfigTags = null;\n          allConfigTags = configHelper\n                  .getEffectiveDesiredTags(cluster, hostName);\n\n          Map<String, Map<String, String>> configTags = new HashMap<String,\n                  Map<String, String>>();\n\n          for (Map.Entry<String, Map<String, String>> entry : allConfigTags.entrySet()) {\n            if (entry.getKey().equals(clusterConfig.getType())) {\n              configTags.put(clusterConfig.getType(), entry.getValue());\n            }\n          }\n\n          Map<String, Map<String, String>> properties = configHelper\n                  .getEffectiveConfigProperties(cluster, configTags);\n\n          if (!properties.isEmpty()) {\n            for (Map<String, String> propertyMap : properties.values()) {\n              props.putAll(propertyMap);\n            }\n          }\n\n          configurations.put(clusterConfig.getType(), props);\n\n          Map<String, Map<String, String>> attrs = new TreeMap<String, Map<String, String>>();\n          configHelper.cloneAttributesMap(clusterConfig.getPropertiesAttributes(), attrs);\n\n          Map<String, Map<String, Map<String, String>>> attributes = configHelper\n                  .getEffectiveConfigAttributes(cluster, configTags);\n          for (Map<String, Map<String, String>> attributesMap : attributes.values()) {\n            configHelper.cloneAttributesMap(attributesMap, attrs);\n          }\n          configurationAttributes.put(clusterConfig.getType(), attrs);\n        }\n      }\n\n      // Hack - Remove passwords from configs\n      if (configurations.get(Configuration.HIVE_CONFIG_TAG)!=null) {\n        configurations.get(Configuration.HIVE_CONFIG_TAG).remove(Configuration.HIVE_METASTORE_PASSWORD_PROPERTY);\n      }\n\n      Map<String, Set<String>> clusterHostInfo = null;\n      ServiceInfo serviceInfo = null;\n      String osFamily = null;\n      clusterHostInfo = StageUtils.getClusterHostInfo(managementController.getClusters().getHostsForCluster(cluster.getClusterName()), cluster);\n      serviceInfo = managementController.getAmbariMetaInfo().getService(stackId.getStackName(),\n              stackId.getStackVersion(), serviceName);\n      clusterHostInfo = substituteHostIndexes(clusterHostInfo);\n      osFamily = clusters.getHost(hostName).getOsFamily();\n\n      TreeMap<String, String> hostLevelParams = new TreeMap<String, String>();\n      hostLevelParams.put(JDK_LOCATION, managementController.getJdkResourceUrl());\n      hostLevelParams.put(JAVA_HOME, managementController.getJavaHome());\n      hostLevelParams.put(JDK_NAME, managementController.getJDKName());\n      hostLevelParams.put(JCE_NAME, managementController.getJCEName());\n      hostLevelParams.put(STACK_NAME, stackId.getStackName());\n      hostLevelParams.put(STACK_VERSION, stackId.getStackVersion());\n      hostLevelParams.put(DB_NAME, managementController.getServerDB());\n      hostLevelParams.put(MYSQL_JDBC_URL, managementController.getMysqljdbcUrl());\n      hostLevelParams.put(ORACLE_JDBC_URL, managementController.getOjdbcUrl());\n      hostLevelParams.putAll(managementController.getRcaParameters());\n      hostLevelParams.putAll(managementController.getRcaParameters());\n\n      // Write down os specific info for the service\n      ServiceOsSpecific anyOs = null;\n      if (serviceInfo.getOsSpecifics().containsKey(AmbariMetaInfo.ANY_OS)) {\n        anyOs = serviceInfo.getOsSpecifics().get(AmbariMetaInfo.ANY_OS);\n      }\n\n      ServiceOsSpecific hostOs = populateServicePackagesInfo(serviceInfo, hostLevelParams, osFamily);\n\n      // Build package list that is relevant for host\n      List<ServiceOsSpecific.Package> packages =\n              new ArrayList<ServiceOsSpecific.Package>();\n      if (anyOs != null) {\n        packages.addAll(anyOs.getPackages());\n      }\n\n      if (hostOs != null) {\n        packages.addAll(hostOs.getPackages());\n      }\n      String packageList = gson.toJson(packages);\n      hostLevelParams.put(PACKAGE_LIST, packageList);\n\n      Set<String> userSet = configHelper.getPropertyValuesWithPropertyType(stackId, PropertyType.USER, cluster);\n      String userList = gson.toJson(userSet);\n      hostLevelParams.put(USER_LIST, userList);\n\n      Set<String> groupSet = configHelper.getPropertyValuesWithPropertyType(stackId, PropertyType.GROUP, cluster);\n      String groupList = gson.toJson(groupSet);\n      hostLevelParams.put(GROUP_LIST, groupList);\n\n      String jsonConfigurations = null;\n      Map<String, Object> commandParams = new HashMap<String, Object>();\n      List<Map<String, String>> xmlConfigs = new LinkedList<Map<String, String>>();\n      List<Map<String, String>> envConfigs = new LinkedList<Map<String, String>>();\n      List<Map<String, String>> propertiesConfigs = new LinkedList<Map<String, String>>();\n\n      //Fill file-dictionary configs from metainfo\n      for (ClientConfigFileDefinition clientConfigFile : clientConfigFiles) {\n        Map<String, String> fileDict = new HashMap<String, String>();\n        fileDict.put(clientConfigFile.getFileName(), clientConfigFile.getDictionaryName());\n        if (clientConfigFile.getType().equals(\"xml\")) {\n          xmlConfigs.add(fileDict);\n        } else if (clientConfigFile.getType().equals(\"env\")) {\n          envConfigs.add(fileDict);\n        } else if (clientConfigFile.getType().equals(\"properties\")) {\n          propertiesConfigs.add(fileDict);\n        }\n      }\n\n      commandParams.put(\"xml_configs_list\", xmlConfigs);\n      commandParams.put(\"env_configs_list\", envConfigs);\n      commandParams.put(\"properties_configs_list\", propertiesConfigs);\n      commandParams.put(\"output_file\", componentName + \"-configs\" + Configuration.DEF_ARCHIVE_EXTENSION);\n\n      Map<String, Object> jsonContent = new TreeMap<String, Object>();\n      jsonContent.put(\"configurations\", configurations);\n      jsonContent.put(\"configuration_attributes\", configurationAttributes);\n      jsonContent.put(\"commandParams\", commandParams);\n      jsonContent.put(\"clusterHostInfo\", clusterHostInfo);\n      jsonContent.put(\"hostLevelParams\", hostLevelParams);\n      jsonContent.put(\"hostname\", hostName);\n      jsonConfigurations = gson.toJson(jsonContent);\n\n      File jsonFileName = new File(TMP_PATH + File.separator + componentName + \"-configuration.json\");\n      File tmpDirectory = new File(jsonFileName.getParent());\n      if (!tmpDirectory.exists()) {\n        try {\n          tmpDirectory.mkdirs();\n          tmpDirectory.setWritable(true, true);\n          tmpDirectory.setReadable(true, true);\n        } catch (SecurityException se) {\n          throw new SystemException(\"Failed to get temporary directory to store configurations\", se);\n        }\n      }\n      PrintWriter printWriter = null;\n      try {\n        printWriter = new PrintWriter(jsonFileName.getAbsolutePath());\n        printWriter.print(jsonConfigurations);\n        printWriter.close();\n      } catch (FileNotFoundException e) {\n        throw new SystemException(\"Failed to write configurations to json file \", e);\n      }\n\n      String cmd = pythonCmd + \" \" + commandScriptAbsolute + \" generate_configs \" + jsonFileName.getAbsolutePath() + \" \" +\n              packageFolderAbsolute + \" \" + TMP_PATH + File.separator + \"structured-out.json\" + \" INFO \" + TMP_PATH;\n\n      try {\n        executeCommand(cmd, configs.getExternalScriptTimeout());\n      } catch (TimeoutException e) {\n        LOG.error(\"Generate client configs script was killed due to timeout \", e);\n        throw new SystemException(\"Generate client configs script was killed due to timeout \", e);\n      } catch (InterruptedException e) {\n        LOG.error(\"Failed to run generate client configs script for a component \" + componentName, e);\n        throw new SystemException(\"Failed to run generate client configs script for a component \" + componentName, e);\n      } catch (ExecutionException e) {\n        LOG.error(e.getMessage(),e);\n        throw new SystemException(e.getMessage() + \" \" + e.getCause());\n      } catch (IOException e) {\n        LOG.error(\"Failed to run generate client configs script for a component \" + componentName, e);\n        throw new SystemException(\"Failed to run generate client configs script for a component \" + componentName, e);\n      }\n\n    } catch (AmbariException e) {\n      throw new SystemException(\"Controller error \", e);\n    }\n\n    Resource resource = new ResourceImpl(Resource.Type.ClientConfig);\n    resources.add(resource);\n    return resources;\n  }","commit_id":"c73b74f6764a8bdaa0b2f420c387ce2ca2a98192","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResources() throws Exception {\n    Resource.Type type = Resource.Type.ClientConfig;\n\n    AmbariManagementController managementController = createNiceMock(AmbariManagementController.class);\n    Clusters clusters = createNiceMock(Clusters.class);\n\n    Cluster cluster = createNiceMock(Cluster.class);\n    AmbariMetaInfo ambariMetaInfo = createNiceMock(AmbariMetaInfo.class);\n    StackId stackId = createNiceMock(StackId.class);\n    ComponentInfo componentInfo = createNiceMock(ComponentInfo.class);\n    ServiceInfo serviceInfo = createNiceMock(ServiceInfo.class);\n    CommandScriptDefinition commandScriptDefinition = createNiceMock(CommandScriptDefinition.class);\n    Config clusterConfig = createNiceMock(Config.class);\n    DesiredConfig desiredConfig = createNiceMock(DesiredConfig.class);\n    Host host = createNiceMock(Host.class);\n    Service service = createNiceMock(Service.class);\n    ServiceComponent serviceComponent = createNiceMock(ServiceComponent.class);\n    ServiceComponentHost serviceComponentHost = createNiceMock(ServiceComponentHost.class);\n    ServiceOsSpecific serviceOsSpecific = createNiceMock(ServiceOsSpecific.class);\n    ConfigHelper configHelper = createNiceMock(ConfigHelper.class);\n    Configuration configuration = PowerMock.createStrictMockAndExpectNew(Configuration.class);\n\n    File mockFile = PowerMock.createNiceMock(File.class);\n    Runtime runtime = createMock(Runtime.class);\n    Process process = createNiceMock(Process.class);\n\n    Map<String, DesiredConfig> desiredConfigMap = new HashMap<String, DesiredConfig>();\n    desiredConfigMap.put(\"hive-site\", desiredConfig);\n    Map<String, Map<String, String>> allConfigTags = new HashMap<String, Map<String, String>>();\n    Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>();\n    Map<String, Map<String, String>> configTags = new HashMap<String,\n            Map<String, String>>();\n    Map<String, Map<String, Map<String, String>>> attributes = new HashMap<String,\n            Map<String, Map<String, String>>>();\n\n    ClientConfigFileDefinition clientConfigFileDefinition = new ClientConfigFileDefinition();\n    clientConfigFileDefinition.setDictionaryName(\"pig-env\");\n    clientConfigFileDefinition.setFileName(\"pig-env.sh\");\n    clientConfigFileDefinition.setType(\"env\");\n    List <ClientConfigFileDefinition> clientConfigFileDefinitionList = new LinkedList<ClientConfigFileDefinition>();\n    clientConfigFileDefinitionList.add(clientConfigFileDefinition);\n\n    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(ClientConfigResourceProvider.COMPONENT_CLUSTER_NAME_PROPERTY_ID, \"c1\",\n            ClientConfigResourceProvider.COMPONENT_COMPONENT_NAME_PROPERTY_ID,\n            ClientConfigResourceProvider.COMPONENT_SERVICE_NAME_PROPERTY_ID);\n\n    Predicate predicate = new PredicateBuilder().property(ClientConfigResourceProvider.COMPONENT_CLUSTER_NAME_PROPERTY_ID).equals(\"c1\").\n        toPredicate();\n\n    String clusterName = \"C1\";\n    String serviceName = \"PIG\";\n    String componentName = \"PIG\";\n    String hostName = \"Host100\";\n    String desiredState = \"INSTALLED\";\n\n    String stackName = \"S1\";\n    String stackVersion = \"V1\";\n\n    String stackRoot=\"/tmp/stacks/S1/V1\";\n    String packageFolder=\"PIG/package\";\n\n    if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n      stackRoot = \"\\\\tmp\\\\stacks\\\\S1\\\\V1\";\n      packageFolder = \"PIG\\\\package\";\n    }\n\n    File stackRootFile = new File(stackRoot);\n    HashMap<String, Host> hosts = new HashMap<String, Host>();\n    hosts.put(hostName, host);\n    HashMap<String, Service> services = new HashMap<String, Service>();\n    services.put(serviceName,service);\n    HashMap<String, ServiceComponent> serviceComponentMap = new HashMap<String, ServiceComponent>();\n    serviceComponentMap.put(componentName,serviceComponent);\n    HashMap<String, ServiceComponentHost> serviceComponentHosts = new HashMap<String, ServiceComponentHost>();\n    serviceComponentHosts.put(componentName, serviceComponentHost);\n    HashMap<String, ServiceOsSpecific> serviceOsSpecificHashMap = new HashMap<String, ServiceOsSpecific>();\n    serviceOsSpecificHashMap.put(\"key\",serviceOsSpecific);\n\n    ServiceComponentHostResponse shr1 = new ServiceComponentHostResponse(clusterName, serviceName, componentName, hostName, desiredState, \"\", null, null, null);\n\n    Set<ServiceComponentHostResponse> responses = new LinkedHashSet<ServiceComponentHostResponse>();\n    responses.add(shr1);\n\n    // set expectations\n    expect(managementController.getConfigHelper()).andReturn(configHelper);\n    expect(managementController.getAmbariMetaInfo()).andReturn(ambariMetaInfo).anyTimes();\n    expect(managementController.getClusters()).andReturn(clusters).anyTimes();\n    expect(clusters.getCluster(clusterName)).andReturn(cluster).anyTimes();\n    expect(configHelper.getEffectiveConfigProperties(cluster, configTags)).andReturn(properties);\n    expect(clusterConfig.getType()).andReturn(Configuration.HIVE_CONFIG_TAG).anyTimes();\n    expect(configHelper.getEffectiveConfigAttributes(cluster, configTags)).andReturn(attributes);\n    expect(configuration.getProperty(Configuration.SERVER_TMP_DIR_KEY)).andReturn(Configuration.SERVER_TMP_DIR_DEFAULT);\n    expect(configuration.getProperty(Configuration.AMBARI_PYTHON_WRAP_KEY)).andReturn(Configuration.AMBARI_PYTHON_WRAP_DEFAULT);\n    expect(configuration.getExternalScriptTimeout()).andReturn(Integer.parseInt(Configuration.EXTERNAL_SCRIPT_TIMEOUT_DEFAULT));\n    Map<String,String> props = new HashMap<String, String>();\n    props.put(Configuration.HIVE_METASTORE_PASSWORD_PROPERTY, \"pass\");\n    props.put(\"key\",\"value\");\n    expect(clusterConfig.getProperties()).andReturn(props);\n    expect(configHelper.getEffectiveDesiredTags(cluster, hostName)).andReturn(allConfigTags);\n    expect(cluster.getClusterName()).andReturn(clusterName);\n    expect(managementController.getHostComponents((Set<ServiceComponentHostRequest>) anyObject())).andReturn(responses).anyTimes();\n    expect(cluster.getCurrentStackVersion()).andReturn(stackId);\n\n    PowerMock.mockStaticPartial(StageUtils.class, \"getClusterHostInfo\");\n    Map<String, Set<String>> clusterHostInfo = new HashMap<String, Set<String>>();\n    Set<String> all_hosts = new HashSet<String>(Arrays.asList(\"Host100\",\"Host101\",\"Host102\"));\n    Set<String> some_hosts = new HashSet<String>(Arrays.asList(\"0-1\",\"2\"));\n    Set<String> ohter_hosts = new HashSet<String>(Arrays.asList(\"0,1\"));\n    Set<String> clusterHostTypes = new HashSet<String>(Arrays.asList(\"nm_hosts\", \"hs_host\",\n            \"namenode_host\", \"rm_host\", \"snamenode_host\", \"slave_hosts\", \"zookeeper_hosts\"));\n    for (String hostTypes: clusterHostTypes) {\n      if (hostTypes.equals(\"slave_hosts\")) {\n        clusterHostInfo.put(hostTypes, ohter_hosts);\n      } else {\n        clusterHostInfo.put(hostTypes, some_hosts);\n      }\n    }\n    Map<String, Host> stringHostMap = new HashMap<String, Host>();\n    stringHostMap.put(hostName, host);\n    clusterHostInfo.put(\"all_hosts\",all_hosts);\n    expect(StageUtils.getClusterHostInfo(stringHostMap,cluster)).andReturn(clusterHostInfo);\n\n    expect(stackId.getStackName()).andReturn(stackName).anyTimes();\n    expect(stackId.getStackVersion()).andReturn(stackVersion).anyTimes();\n\n    expect(ambariMetaInfo.getComponent(stackName, stackVersion, serviceName, componentName)).andReturn(componentInfo);\n    expect(ambariMetaInfo.getService(stackName, stackVersion, serviceName)).andReturn(serviceInfo);\n    expect(serviceInfo.getServicePackageFolder()).andReturn(packageFolder);\n    expect(ambariMetaInfo.getComponent((String) anyObject(), (String) anyObject(),\n            (String) anyObject(), (String) anyObject())).andReturn(componentInfo).anyTimes();\n    expect(componentInfo.getCommandScript()).andReturn(commandScriptDefinition);\n    expect(componentInfo.getClientConfigFiles()).andReturn(clientConfigFileDefinitionList);\n    expect(ambariMetaInfo.getStackRoot()).andReturn(stackRootFile);\n    expect(cluster.getConfig(\"hive-site\", null)).andReturn(clusterConfig);\n    expect(cluster.getDesiredConfigs()).andReturn(desiredConfigMap);\n    expect(clusters.getHostsForCluster(clusterName)).andReturn(hosts);\n    expect(clusters.getHost(hostName)).andReturn(host);\n\n    HashMap<String, String> rcaParams = new HashMap<String, String>();\n    rcaParams.put(\"key\",\"value\");\n    expect(managementController.getRcaParameters()).andReturn(rcaParams).anyTimes();\n    expect(ambariMetaInfo.getService(stackName, stackVersion, serviceName)).andReturn(serviceInfo);\n    expect(serviceInfo.getOsSpecifics()).andReturn(new HashMap<String, ServiceOsSpecific>()).anyTimes();\n    Set<String> userSet = new HashSet<String>();\n    userSet.add(\"hdfs\");\n    expect(configHelper.getPropertyValuesWithPropertyType(stackId, PropertyInfo.PropertyType.USER, cluster)).andReturn(userSet);\n    PowerMock.expectNew(File.class, new Class<?>[]{String.class}, anyObject(String.class)).andReturn(mockFile).anyTimes();\n    PowerMock.createNiceMockAndExpectNew(PrintWriter.class, anyObject());\n    expect(mockFile.getParent()).andReturn(\"\");\n    PowerMock.mockStatic(Runtime.class);\n    expect(mockFile.exists()).andReturn(true);\n    String commandLine = \"ambari-python-wrap /tmp/stacks/S1/V1/PIG/package/null generate_configs null \" +\n            \"/tmp/stacks/S1/V1/PIG/package /var/lib/ambari-server/tmp/structured-out.json \" +\n            \"INFO /var/lib/ambari-server/tmp\";\n\n    if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n      String absoluteStackRoot = stackRootFile.getAbsolutePath();\n      commandLine = \"ambari-python-wrap \" + absoluteStackRoot +\n              \"\\\\PIG\\\\package\\\\null generate_configs null \" +\n              absoluteStackRoot + \"\\\\PIG\\\\package /var/lib/ambari-server/tmp\\\\structured-out.json \" +\n              \"INFO /var/lib/ambari-server/tmp\";\n    }\n\n    ProcessBuilder processBuilder = PowerMock.createNiceMock(ProcessBuilder.class);\n    PowerMock.expectNew(ProcessBuilder.class,Arrays.asList(commandLine.split(\"\\\\s+\"))).andReturn(processBuilder).once();\n    expect(processBuilder.start()).andReturn(process).once();\n    InputStream inputStream = new ByteArrayInputStream(\"some logging info\".getBytes());\n    expect(process.getInputStream()).andReturn(inputStream);\n\n    // replay\n    replay(managementController, clusters, cluster, ambariMetaInfo, stackId, componentInfo, commandScriptDefinition,\n            clusterConfig, host, service, serviceComponent, serviceComponentHost, serviceInfo, configHelper,\n            runtime, process);\n    PowerMock.replayAll();\n\n    Set<Resource> resources = provider.getResources(request, predicate);\n    assertFalse(resources.isEmpty());\n\n    // verify\n    verify(managementController, clusters, cluster, ambariMetaInfo, stackId, componentInfo,commandScriptDefinition,\n            clusterConfig, host, service, serviceComponent, serviceComponentHost, serviceInfo, configHelper,\n            runtime, process);\n    PowerMock.verifyAll();\n  }","id":38096,"modified_method":"@Test\n  public void testGetResources() throws Exception {\n    Resource.Type type = Resource.Type.ClientConfig;\n\n    AmbariManagementController managementController = createNiceMock(AmbariManagementController.class);\n    Clusters clusters = createNiceMock(Clusters.class);\n\n    Cluster cluster = createNiceMock(Cluster.class);\n    AmbariMetaInfo ambariMetaInfo = createNiceMock(AmbariMetaInfo.class);\n    StackId stackId = createNiceMock(StackId.class);\n    ComponentInfo componentInfo = createNiceMock(ComponentInfo.class);\n    ServiceInfo serviceInfo = createNiceMock(ServiceInfo.class);\n    CommandScriptDefinition commandScriptDefinition = createNiceMock(CommandScriptDefinition.class);\n    Config clusterConfig = createNiceMock(Config.class);\n    DesiredConfig desiredConfig = createNiceMock(DesiredConfig.class);\n    Host host = createNiceMock(Host.class);\n    Service service = createNiceMock(Service.class);\n    ServiceComponent serviceComponent = createNiceMock(ServiceComponent.class);\n    ServiceComponentHost serviceComponentHost = createNiceMock(ServiceComponentHost.class);\n    ServiceOsSpecific serviceOsSpecific = createNiceMock(ServiceOsSpecific.class);\n    ConfigHelper configHelper = createNiceMock(ConfigHelper.class);\n    Configuration configuration = PowerMock.createStrictMockAndExpectNew(Configuration.class);\n    Map<String, String> configMap = createNiceMock(Map.class);\n\n    File mockFile = PowerMock.createNiceMock(File.class);\n    Runtime runtime = createMock(Runtime.class);\n    Process process = createNiceMock(Process.class);\n\n    Map<String, DesiredConfig> desiredConfigMap = new HashMap<String, DesiredConfig>();\n    desiredConfigMap.put(\"hive-site\", desiredConfig);\n    Map<String, Map<String, String>> allConfigTags = new HashMap<String, Map<String, String>>();\n    Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>();\n    Map<String, Map<String, String>> configTags = new HashMap<String,\n            Map<String, String>>();\n    Map<String, Map<String, Map<String, String>>> attributes = new HashMap<String,\n            Map<String, Map<String, String>>>();\n\n    ClientConfigFileDefinition clientConfigFileDefinition = new ClientConfigFileDefinition();\n    clientConfigFileDefinition.setDictionaryName(\"pig-env\");\n    clientConfigFileDefinition.setFileName(\"pig-env.sh\");\n    clientConfigFileDefinition.setType(\"env\");\n    List <ClientConfigFileDefinition> clientConfigFileDefinitionList = new LinkedList<ClientConfigFileDefinition>();\n    clientConfigFileDefinitionList.add(clientConfigFileDefinition);\n\n    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(\n        type,\n        PropertyHelper.getPropertyIds(type),\n        PropertyHelper.getKeyPropertyIds(type),\n        managementController);\n\n    // create the request\n    Request request = PropertyHelper.getReadRequest(ClientConfigResourceProvider.COMPONENT_CLUSTER_NAME_PROPERTY_ID, \"c1\",\n            ClientConfigResourceProvider.COMPONENT_COMPONENT_NAME_PROPERTY_ID,\n            ClientConfigResourceProvider.COMPONENT_SERVICE_NAME_PROPERTY_ID);\n\n    Predicate predicate = new PredicateBuilder().property(ClientConfigResourceProvider.COMPONENT_CLUSTER_NAME_PROPERTY_ID).equals(\"c1\").\n        toPredicate();\n\n    String clusterName = \"C1\";\n    String serviceName = \"PIG\";\n    String componentName = \"PIG\";\n    String hostName = \"Host100\";\n    String desiredState = \"INSTALLED\";\n\n    String stackName = \"S1\";\n    String stackVersion = \"V1\";\n\n    String stackRoot=\"/tmp/stacks/S1/V1\";\n    String packageFolder=\"PIG/package\";\n\n    if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n      stackRoot = \"\\\\tmp\\\\stacks\\\\S1\\\\V1\";\n      packageFolder = \"PIG\\\\package\";\n    }\n\n    File stackRootFile = new File(stackRoot);\n    HashMap<String, Host> hosts = new HashMap<String, Host>();\n    hosts.put(hostName, host);\n    HashMap<String, Service> services = new HashMap<String, Service>();\n    services.put(serviceName,service);\n    HashMap<String, ServiceComponent> serviceComponentMap = new HashMap<String, ServiceComponent>();\n    serviceComponentMap.put(componentName,serviceComponent);\n    HashMap<String, ServiceComponentHost> serviceComponentHosts = new HashMap<String, ServiceComponentHost>();\n    serviceComponentHosts.put(componentName, serviceComponentHost);\n    HashMap<String, ServiceOsSpecific> serviceOsSpecificHashMap = new HashMap<String, ServiceOsSpecific>();\n    serviceOsSpecificHashMap.put(\"key\",serviceOsSpecific);\n\n    ServiceComponentHostResponse shr1 = new ServiceComponentHostResponse(clusterName, serviceName, componentName, hostName, desiredState, \"\", null, null, null);\n\n    Set<ServiceComponentHostResponse> responses = new LinkedHashSet<ServiceComponentHostResponse>();\n    responses.add(shr1);\n    \n    Map<String, String> returnConfigMap = new HashMap<String, String>();\n    returnConfigMap.put(Configuration.SERVER_TMP_DIR_KEY, Configuration.SERVER_TMP_DIR_DEFAULT);\n    returnConfigMap.put(Configuration.AMBARI_PYTHON_WRAP_KEY, Configuration.AMBARI_PYTHON_WRAP_DEFAULT);\n    \n    // set expectations\n    expect(managementController.getConfigHelper()).andReturn(configHelper);\n    expect(managementController.getAmbariMetaInfo()).andReturn(ambariMetaInfo).anyTimes();\n    expect(managementController.getClusters()).andReturn(clusters).anyTimes();\n    expect(clusters.getCluster(clusterName)).andReturn(cluster).anyTimes();\n    expect(configHelper.getEffectiveConfigProperties(cluster, configTags)).andReturn(properties);\n    expect(clusterConfig.getType()).andReturn(Configuration.HIVE_CONFIG_TAG).anyTimes();\n    expect(configHelper.getEffectiveConfigAttributes(cluster, configTags)).andReturn(attributes);\n    expect(configMap.get(Configuration.SERVER_TMP_DIR_KEY)).andReturn(Configuration.SERVER_TMP_DIR_DEFAULT);\n    expect(configMap.get(Configuration.AMBARI_PYTHON_WRAP_KEY)).andReturn(Configuration.AMBARI_PYTHON_WRAP_DEFAULT);\n    expect(configuration.getConfigsMap()).andReturn(returnConfigMap);\n    expect(configuration.getExternalScriptTimeout()).andReturn(Integer.parseInt(Configuration.EXTERNAL_SCRIPT_TIMEOUT_DEFAULT));\n    Map<String,String> props = new HashMap<String, String>();\n    props.put(Configuration.HIVE_METASTORE_PASSWORD_PROPERTY, \"pass\");\n    props.put(\"key\",\"value\");\n    expect(clusterConfig.getProperties()).andReturn(props);\n    expect(configHelper.getEffectiveDesiredTags(cluster, hostName)).andReturn(allConfigTags);\n    expect(cluster.getClusterName()).andReturn(clusterName);\n    expect(managementController.getHostComponents((Set<ServiceComponentHostRequest>) anyObject())).andReturn(responses).anyTimes();\n    expect(cluster.getCurrentStackVersion()).andReturn(stackId);\n\n    PowerMock.mockStaticPartial(StageUtils.class, \"getClusterHostInfo\");\n    Map<String, Set<String>> clusterHostInfo = new HashMap<String, Set<String>>();\n    Set<String> all_hosts = new HashSet<String>(Arrays.asList(\"Host100\",\"Host101\",\"Host102\"));\n    Set<String> some_hosts = new HashSet<String>(Arrays.asList(\"0-1\",\"2\"));\n    Set<String> ohter_hosts = new HashSet<String>(Arrays.asList(\"0,1\"));\n    Set<String> clusterHostTypes = new HashSet<String>(Arrays.asList(\"nm_hosts\", \"hs_host\",\n            \"namenode_host\", \"rm_host\", \"snamenode_host\", \"slave_hosts\", \"zookeeper_hosts\"));\n    for (String hostTypes: clusterHostTypes) {\n      if (hostTypes.equals(\"slave_hosts\")) {\n        clusterHostInfo.put(hostTypes, ohter_hosts);\n      } else {\n        clusterHostInfo.put(hostTypes, some_hosts);\n      }\n    }\n    Map<String, Host> stringHostMap = new HashMap<String, Host>();\n    stringHostMap.put(hostName, host);\n    clusterHostInfo.put(\"all_hosts\",all_hosts);\n    expect(StageUtils.getClusterHostInfo(stringHostMap,cluster)).andReturn(clusterHostInfo);\n\n    expect(stackId.getStackName()).andReturn(stackName).anyTimes();\n    expect(stackId.getStackVersion()).andReturn(stackVersion).anyTimes();\n\n    expect(ambariMetaInfo.getComponent(stackName, stackVersion, serviceName, componentName)).andReturn(componentInfo);\n    expect(ambariMetaInfo.getService(stackName, stackVersion, serviceName)).andReturn(serviceInfo);\n    expect(serviceInfo.getServicePackageFolder()).andReturn(packageFolder);\n    expect(ambariMetaInfo.getComponent((String) anyObject(), (String) anyObject(),\n            (String) anyObject(), (String) anyObject())).andReturn(componentInfo).anyTimes();\n    expect(componentInfo.getCommandScript()).andReturn(commandScriptDefinition);\n    expect(componentInfo.getClientConfigFiles()).andReturn(clientConfigFileDefinitionList);\n    expect(ambariMetaInfo.getStackRoot()).andReturn(stackRootFile);\n    expect(cluster.getConfig(\"hive-site\", null)).andReturn(clusterConfig);\n    expect(cluster.getDesiredConfigs()).andReturn(desiredConfigMap);\n    expect(clusters.getHostsForCluster(clusterName)).andReturn(hosts);\n    expect(clusters.getHost(hostName)).andReturn(host);\n\n    HashMap<String, String> rcaParams = new HashMap<String, String>();\n    rcaParams.put(\"key\",\"value\");\n    expect(managementController.getRcaParameters()).andReturn(rcaParams).anyTimes();\n    expect(ambariMetaInfo.getService(stackName, stackVersion, serviceName)).andReturn(serviceInfo);\n    expect(serviceInfo.getOsSpecifics()).andReturn(new HashMap<String, ServiceOsSpecific>()).anyTimes();\n    Set<String> userSet = new HashSet<String>();\n    userSet.add(\"hdfs\");\n    expect(configHelper.getPropertyValuesWithPropertyType(stackId, PropertyInfo.PropertyType.USER, cluster)).andReturn(userSet);\n    PowerMock.expectNew(File.class, new Class<?>[]{String.class}, anyObject(String.class)).andReturn(mockFile).anyTimes();\n    PowerMock.createNiceMockAndExpectNew(PrintWriter.class, anyObject());\n    expect(mockFile.getParent()).andReturn(\"\");\n    PowerMock.mockStatic(Runtime.class);\n    expect(mockFile.exists()).andReturn(true);\n    String commandLine = \"ambari-python-wrap /tmp/stacks/S1/V1/PIG/package/null generate_configs null \" +\n            \"/tmp/stacks/S1/V1/PIG/package /var/lib/ambari-server/tmp/structured-out.json \" +\n            \"INFO /var/lib/ambari-server/tmp\";\n\n    if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n      String absoluteStackRoot = stackRootFile.getAbsolutePath();\n      commandLine = \"ambari-python-wrap \" + absoluteStackRoot +\n              \"\\\\PIG\\\\package\\\\null generate_configs null \" +\n              absoluteStackRoot + \"\\\\PIG\\\\package /var/lib/ambari-server/tmp\\\\structured-out.json \" +\n              \"INFO /var/lib/ambari-server/tmp\";\n    }\n\n    ProcessBuilder processBuilder = PowerMock.createNiceMock(ProcessBuilder.class);\n    PowerMock.expectNew(ProcessBuilder.class,Arrays.asList(commandLine.split(\"\\\\s+\"))).andReturn(processBuilder).once();\n    expect(processBuilder.start()).andReturn(process).once();\n    InputStream inputStream = new ByteArrayInputStream(\"some logging info\".getBytes());\n    expect(process.getInputStream()).andReturn(inputStream);\n\n    // replay\n    replay(managementController, clusters, cluster, ambariMetaInfo, stackId, componentInfo, commandScriptDefinition,\n            clusterConfig, host, service, serviceComponent, serviceComponentHost, serviceInfo, configHelper,\n            runtime, process, configMap);\n    PowerMock.replayAll();\n\n    Set<Resource> resources = provider.getResources(request, predicate);\n    assertFalse(resources.isEmpty());\n\n    // verify\n    verify(managementController, clusters, cluster, ambariMetaInfo, stackId, componentInfo,commandScriptDefinition,\n            clusterConfig, host, service, serviceComponent, serviceComponentHost, serviceInfo, configHelper,\n            runtime, process);\n    PowerMock.verifyAll();\n  }","commit_id":"c73b74f6764a8bdaa0b2f420c387ce2ca2a98192","url":"https://github.com/apache/ambari"},{"original_method":"private void activate(final StartupHandler handler) {\n        final SlingSettingsService settingsService = new SlingSettingsServiceImpl(bundleContext, handler);\n\n        final Dictionary<String, String> props = new Hashtable<String, String>();\n        props.put(Constants.SERVICE_PID, settingsService.getClass().getName());\n        props.put(Constants.SERVICE_DESCRIPTION,\n            \"Apache Sling Settings Service\");\n        props.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        this.settingsReg = bundleContext.registerService(new String[] {\n                                               SlingSettingsService.class.getName()},\n                                               settingsService, props);\n        SlingPropertiesPrinter.initPlugin(bundleContext);\n        SlingSettingsPrinter.initPlugin(bundleContext, settingsService);\n        try {\n            RunModeCommand.initPlugin(bundleContext, settingsService.getRunModes());\n        } catch (Throwable ignore) {\n            // we just ignore this\n        }\n    }","id":38097,"modified_method":"private void activate(final StartupHandler handler) {\n        final SlingSettingsServiceImpl settingsService = new SlingSettingsServiceImpl(bundleContext, handler);\n\n        final Dictionary<String, String> props = new Hashtable<String, String>();\n        props.put(Constants.SERVICE_DESCRIPTION,\n            \"Apache Sling Settings Service\");\n        props.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        this.settingsReg = bundleContext.registerService(new String[] {\n                                               SlingSettingsService.class.getName()},\n                                               settingsService, props);\n        SlingPropertiesPrinter.initPlugin(bundleContext);\n        SlingSettingsPrinter.initPlugin(bundleContext, settingsService);\n        try {\n            RunModeCommand.initPlugin(bundleContext, settingsService.getRunModes());\n        } catch (final Throwable ignore) {\n            // we just ignore this\n        }\n        // setup manager service for configuration handling\n        final Dictionary<String, String> msProps = new Hashtable<String, String>();\n        msProps.put(Constants.SERVICE_PID, settingsService.getClass().getName());\n        msProps.put(Constants.SERVICE_DESCRIPTION,\n            \"Apache Sling Managed Service for the Settings Service\");\n        msProps.put(Constants.SERVICE_VENDOR, \"The Apache Software Foundation\");\n        managedServiceReg = this.bundleContext.registerService(ManagedService.class.getName(), new ServiceFactory() {\n\n            public void ungetService(final Bundle bundle, final ServiceRegistration registration,\n                    final Object service) {\n                // nothing to do\n            }\n\n            public Object getService(final Bundle bundle, final ServiceRegistration registration) {\n                return new SettingsServiceConfigurator(settingsService);\n            }\n        }, msProps);\n    }","commit_id":"614191c949b3f2f8d33458e89c5b8da6c5e527d0","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Deactivate this listener.\n     */\n    public void deactivate() {\n        this.startupListener.deactivate();\n        if ( this.settingsReg != null ) {\n            this.settingsReg.unregister();\n            this.settingsReg = null;\n        }\n        try {\n            RunModeCommand.destroyPlugin();\n        } catch (Throwable ignore) {\n            // we just ignore this\n        }\n        SlingSettingsPrinter.destroyPlugin();\n        SlingPropertiesPrinter.destroyPlugin();\n    }","id":38098,"modified_method":"/**\n     * Deactivate this listener.\n     */\n    public void deactivate() {\n        if ( this.managedServiceReg != null ) {\n            this.managedServiceReg.unregister();\n            this.managedServiceReg = null;\n        }\n        this.startupListener.deactivate();\n        if ( this.settingsReg != null ) {\n            this.settingsReg.unregister();\n            this.settingsReg = null;\n        }\n        try {\n            RunModeCommand.destroyPlugin();\n        } catch (Throwable ignore) {\n            // we just ignore this\n        }\n        SlingSettingsPrinter.destroyPlugin();\n        SlingPropertiesPrinter.destroyPlugin();\n    }","commit_id":"614191c949b3f2f8d33458e89c5b8da6c5e527d0","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.settings.SlingSettingsService#getSlingName()\n     */\n    public String getSlingName() {\n        String name = this.slingProps.getProperty(SLING_NAME);\n        if ( name == null ) {\n            name = \"Instance \" + this.slingId; // default\n        }\n        return name;\n    }","id":38099,"modified_method":"/**\n     * @see org.apache.sling.settings.SlingSettingsService#getSlingName()\n     */\n    public String getSlingName() {\n        synchronized ( this.slingProps ) {\n            String name = this.slingProps.get(SLING_NAME);\n            if ( name == null ) {\n                name = \"Instance \" + this.slingId; // default\n            }\n            return name;\n        }\n    }","commit_id":"614191c949b3f2f8d33458e89c5b8da6c5e527d0","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.settings.SlingSettingsService#getSlingDescription()\n     */\n    public String getSlingDescription() {\n        String desc = this.slingProps.getProperty(SLING_DESCRIPTION);\n        if ( desc == null ) {\n            desc = \"Instance with id \" + this.slingId + \" and run modes \" + this.getRunModes(); // default\n        }\n        return desc;\n    }","id":38100,"modified_method":"/**\n     * @see org.apache.sling.settings.SlingSettingsService#getSlingDescription()\n     */\n    public String getSlingDescription() {\n        synchronized ( this.slingProps ) {\n            String desc = this.slingProps.get(SLING_DESCRIPTION);\n            if ( desc == null ) {\n                desc = \"Instance with id \" + this.slingId + \" and run modes \" + this.getRunModes(); // default\n            }\n            return desc;\n        }\n    }","commit_id":"614191c949b3f2f8d33458e89c5b8da6c5e527d0","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Get / create sling id\n     */\n    private void setupSlingProps(final BundleContext context) {\n        // try to read the props from the file\n        this.slingPropsFile = context.getDataFile(PROPS_FILE);\n        if ( this.slingPropsFile == null ) {\n            // the OSGi framework does not support storing something in the file system\n            throw new RuntimeException(\"Unable to read from bundle data file.\");\n        }\n        this.slingProps = new Properties();\n        if ( this.slingPropsFile.exists() ) {\n            InputStream reader = null;\n            try {\n                reader = new FileInputStream(this.slingPropsFile);\n                this.slingProps.load(reader);\n\n            } catch ( final IOException ioe ) {\n                logger.error(\"Unable to read properties file \" + this.slingPropsFile + \" : \" + ioe.getMessage(), ioe);\n            } finally {\n                if ( reader != null ) {\n                    try {\n                        reader.close();\n                    } catch (final IOException ignore) {}\n                }\n            }\n        }\n        if ( this.slingProps.getProperty(SLING_NAME) == null && context.getProperty(SLING_NAME) != null ) {\n            this.slingProps.setProperty(SLING_NAME, context.getProperty(SLING_NAME));\n        }\n        if ( this.slingProps.getProperty(SLING_DESCRIPTION) == null && context.getProperty(SLING_DESCRIPTION) != null ) {\n            this.slingProps.setProperty(SLING_DESCRIPTION, context.getProperty(SLING_DESCRIPTION));\n        }\n    }","id":38101,"modified_method":"/**\n     * Get / create sling id\n     */\n    private void setupSlingProps(final BundleContext context) {\n        synchronized ( this.slingProps ) {\n            if ( this.slingProps.get(SLING_NAME) == null && context.getProperty(SLING_NAME) != null ) {\n                this.slingProps.put(SLING_NAME, context.getProperty(SLING_NAME));\n            }\n            if ( this.slingProps.get(SLING_DESCRIPTION) == null && context.getProperty(SLING_DESCRIPTION) != null ) {\n                this.slingProps.put(SLING_DESCRIPTION, context.getProperty(SLING_DESCRIPTION));\n            }\n        }\n    }","commit_id":"614191c949b3f2f8d33458e89c5b8da6c5e527d0","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void makeSureUpdatePullerGetsGoingAfterMasterSwitch() throws Throwable\n    {\n        File root = testDirectory.directory( testName.getMethodName() );\n        ClusterManager clusterManager = new ClusterManager.Builder( root )\n                .withSharedConfig( MapUtil.stringMap(\n                HaSettings.pull_interval.name(), PULL_INTERVAL+\"ms\",\n                ClusterSettings.heartbeat_interval.name(), \"2s\",\n                ClusterSettings.heartbeat_timeout.name(), \"30s\") ).build();\n        clusterManager.start();\n        cluster = clusterManager.getDefaultCluster();\n        cluster.await( allSeesAllAsAvailable() );\n\n        cluster.info( \"### Creating initial dataset\" );\n        long commonNodeId = createNodeOnMaster();\n\n        HighlyAvailableGraphDatabase master = cluster.getMaster();\n        setProperty( master, commonNodeId, 1 );\n        cluster.info( \"### Initial dataset created\" );\n        awaitPropagation( 1, commonNodeId, cluster );\n\n        cluster.info( \"### Shutting down master\" );\n        ClusterManager.RepairKit masterShutdownRK = cluster.shutdown( master );\n\n        cluster.info( \"### Awaiting new master\" );\n        cluster.await( masterAvailable( master ) );\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n\n        cluster.info( \"### Doing a write to master\" );\n        setProperty( cluster.getMaster(), commonNodeId, 2 );\n        awaitPropagation( 2, commonNodeId, cluster, master );\n\n        cluster.info( \"### Repairing cluster\" );\n        masterShutdownRK.repair();\n        cluster.await( masterAvailable() );\n        cluster.await( masterSeesSlavesAsAvailable( 2 ) );\n        cluster.await( allSeesAllAsAvailable() );\n\n        cluster.info( \"### Awaiting change propagation\" );\n        awaitPropagation( 2, commonNodeId, cluster );\n    }","id":38102,"modified_method":"@Test\n    public void makeSureUpdatePullerGetsGoingAfterMasterSwitch() throws Throwable\n    {\n        ClusterManager.ManagedCluster cluster = clusterRule.\n                withSharedSetting( HaSettings.pull_interval, PULL_INTERVAL + \"ms\" ).\n                withSharedSetting( ClusterSettings.heartbeat_interval, \"2s\" ).\n                withSharedSetting( ClusterSettings.heartbeat_timeout, \"30s\" ).\n                startCluster();\n\n        cluster.info( \"### Creating initial dataset\" );\n        long commonNodeId = createNodeOnMaster( cluster );\n\n        HighlyAvailableGraphDatabase master = cluster.getMaster();\n        setProperty( master, commonNodeId, 1 );\n        cluster.info( \"### Initial dataset created\" );\n        awaitPropagation( 1, commonNodeId, cluster );\n\n        cluster.info( \"### Shutting down master\" );\n        ClusterManager.RepairKit masterShutdownRK = cluster.shutdown( master );\n\n        cluster.info( \"### Awaiting new master\" );\n        cluster.await( masterAvailable( master ) );\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n\n        cluster.info( \"### Doing a write to master\" );\n        setProperty( cluster.getMaster(), commonNodeId, 2 );\n        awaitPropagation( 2, commonNodeId, cluster, master );\n\n        cluster.info( \"### Repairing cluster\" );\n        masterShutdownRK.repair();\n        cluster.await( masterAvailable() );\n        cluster.await( masterSeesSlavesAsAvailable( 2 ) );\n        cluster.await( allSeesAllAsAvailable() );\n\n        cluster.info( \"### Awaiting change propagation\" );\n        awaitPropagation( 2, commonNodeId, cluster );\n    }","commit_id":"da30edd87a2d1c70135f9f38be71b12adbb5f3b9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPullUpdatesOnStartupNoMatterWhat() throws Exception\n    {\n        GraphDatabaseService slave = null;\n        GraphDatabaseService master = null;\n        try\n        {\n            File testRootDir = testDirectory.directory( testName.getMethodName() );\n            File masterDir = new File( testRootDir, \"master\" );\n            master = new TestHighlyAvailableGraphDatabaseFactory().\n                    newHighlyAvailableDatabaseBuilder( masterDir.getAbsolutePath() )\n                    .setConfig( ClusterSettings.server_id, \"1\" )\n                    .setConfig( ClusterSettings.initial_hosts, \"localhost:5001\" )\n                    .newGraphDatabase();\n\n            // Copy the store, then shutdown, so update pulling later makes sense\n            File slaveDir = new File( testRootDir, \"slave\" );\n            slave = new TestHighlyAvailableGraphDatabaseFactory().\n                    newHighlyAvailableDatabaseBuilder( slaveDir.getAbsolutePath() )\n                    .setConfig( ClusterSettings.server_id, \"2\" )\n                    .setConfig( ClusterSettings.initial_hosts, \"localhost:5001\" )\n                    .newGraphDatabase();\n\n            // Required to block until the slave has left for sure\n            final CountDownLatch slaveLeftLatch = new CountDownLatch( 1 );\n\n            final ClusterClient masterClusterClient = ( (HighlyAvailableGraphDatabase) master ).getDependencyResolver()\n                    .resolveDependency( ClusterClient.class );\n\n            masterClusterClient.addClusterListener( new ClusterListener.Adapter()\n            {\n                @Override\n                public void leftCluster( InstanceId instanceId, URI member )\n                {\n                    slaveLeftLatch.countDown();\n                    masterClusterClient.removeClusterListener( this );\n                }\n            } );\n\n            ((GraphDatabaseAPI)master).getDependencyResolver().resolveDependency( LogService.class ).getInternalLog( getClass() ).info( \"SHUTTING DOWN SLAVE\" );\n            slave.shutdown();\n\n            // Make sure that the slave has left, because shutdown() may return before the master knows\n            assertTrue( \"Timeout waiting for slave to leave\", slaveLeftLatch.await( 60, TimeUnit.SECONDS ) );\n\n            long nodeId;\n            try ( Transaction tx = master.beginTx() )\n            {\n                Node node = master.createNode();\n                node.setProperty( \"from\", \"master\" );\n                nodeId = node.getId();\n                tx.success();\n            }\n\n            // Store is already in place, should pull updates\n            slave = new TestHighlyAvailableGraphDatabaseFactory().\n                    newHighlyAvailableDatabaseBuilder( slaveDir.getAbsolutePath() )\n                    .setConfig( ClusterSettings.server_id, \"2\" )\n                    .setConfig( ClusterSettings.initial_hosts, \"localhost:5001\" )\n                    .setConfig( HaSettings.pull_interval, \"0\" ) // no pull updates, should pull on startup\n                    .newGraphDatabase();\n\n            slave.beginTx().close(); // Make sure switch to slave completes and so does the update pulling on startup\n\n            try ( Transaction tx = slave.beginTx() )\n            {\n                assertEquals( \"master\", slave.getNodeById( nodeId ).getProperty( \"from\" ) );\n                tx.success();\n            }\n        }\n        finally\n        {\n            if ( slave != null)\n            {\n                slave.shutdown();\n            }\n            if ( master != null )\n            {\n                master.shutdown();\n            }\n        }\n    }","id":38103,"modified_method":"@Test\n    public void shouldPullUpdatesOnStartupNoMatterWhat() throws Exception\n    {\n        HighlyAvailableGraphDatabase slave = null;\n        HighlyAvailableGraphDatabase master = null;\n        try\n        {\n            File testRootDir = clusterRule.cleanDirectory( \"shouldPullUpdatesOnStartupNoMatterWhat\" );\n            File masterDir = new File( testRootDir, \"master\" );\n            master = (HighlyAvailableGraphDatabase) new TestHighlyAvailableGraphDatabaseFactory().\n                    newEmbeddedDatabaseBuilder( masterDir )\n                    .setConfig( ClusterSettings.server_id, \"1\" )\n                    .setConfig( ClusterSettings.initial_hosts, \"localhost:5001\" )\n                    .newGraphDatabase();\n\n            // Copy the store, then shutdown, so update pulling later makes sense\n            File slaveDir = new File( testRootDir, \"slave\" );\n            slave =  (HighlyAvailableGraphDatabase) new TestHighlyAvailableGraphDatabaseFactory().\n                    newEmbeddedDatabaseBuilder( slaveDir )\n                    .setConfig( ClusterSettings.server_id, \"2\" )\n                    .setConfig( ClusterSettings.initial_hosts, \"localhost:5001\" )\n                    .newGraphDatabase();\n\n            // Required to block until the slave has left for sure\n            final CountDownLatch slaveLeftLatch = new CountDownLatch( 1 );\n            final ClusterClient masterClusterClient =\n                    master.getDependencyResolver().resolveDependency( ClusterClient.class );\n            masterClusterClient.addClusterListener( new ClusterListener.Adapter()\n            {\n                @Override\n                public void leftCluster( InstanceId instanceId, URI member )\n                {\n                    slaveLeftLatch.countDown();\n                    masterClusterClient.removeClusterListener( this );\n                }\n            } );\n\n            master.getDependencyResolver().resolveDependency( LogService.class )\n                    .getInternalLog( getClass() ).info( \"SHUTTING DOWN SLAVE\" );\n            slave.shutdown();\n            slave = null;\n\n            // Make sure that the slave has left, because shutdown() may return before the master knows\n            assertTrue( \"Timeout waiting for slave to leave\", slaveLeftLatch.await( 60, TimeUnit.SECONDS ) );\n\n            long nodeId;\n            try ( Transaction tx = master.beginTx() )\n            {\n                Node node = master.createNode();\n                node.setProperty( \"from\", \"master\" );\n                nodeId = node.getId();\n                tx.success();\n            }\n\n            // Store is already in place, should pull updates\n            slave = (HighlyAvailableGraphDatabase) new TestHighlyAvailableGraphDatabaseFactory().\n                    newEmbeddedDatabaseBuilder( slaveDir )\n                    .setConfig( ClusterSettings.server_id, \"2\" )\n                    .setConfig( ClusterSettings.initial_hosts, \"localhost:5001\" )\n                    .setConfig( HaSettings.pull_interval, \"0\" ) // no pull updates, should pull on startup\n                    .newGraphDatabase();\n\n            slave.beginTx().close(); // Make sure switch to slave completes and so does the update pulling on startup\n\n            try ( Transaction tx = slave.beginTx() )\n            {\n                assertEquals( \"master\", slave.getNodeById( nodeId ).getProperty( \"from\" ) );\n                tx.success();\n            }\n        }\n        finally\n        {\n            if ( slave != null)\n            {\n                slave.shutdown();\n            }\n            if ( master != null )\n            {\n                master.shutdown();\n            }\n        }\n    }","commit_id":"da30edd87a2d1c70135f9f38be71b12adbb5f3b9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void pullUpdatesShellAppPullsUpdates() throws Throwable\n    {\n        File root = testDirectory.directory( testName.getMethodName() );\n        ClusterManager clusterManager = new ClusterManager.Builder( root )\n                .withProvider( clusterOfSize( 2 ) )\n                .withSharedConfig( MapUtil.stringMap(\n                    HaSettings.pull_interval.name(), \"0\",\n                    HaSettings.tx_push_factor.name(), \"0\" ,\n                    ShellSettings.remote_shell_enabled.name(), \"true\" ) )\n                .withInstanceConfig( MapUtil.<String,IntFunction<String>>genericMap(\n                    ShellSettings.remote_shell_port.name(), new IntFunction<String>()\n                    {\n                        @Override\n                        public String apply( int oneBasedServerId )\n                        {\n                            return oneBasedServerId >= 1 && oneBasedServerId <= 2 ?\n                                    \"\" + (SHELL_PORT + oneBasedServerId) : null;\n                        }\n                    } ) ).build();\n        clusterManager.start();\n        cluster = clusterManager.getDefaultCluster();\n\n        long commonNodeId = createNodeOnMaster();\n\n        setProperty( cluster.getMaster(), commonNodeId, 1 );\n        callPullUpdatesViaShell( 2 );\n        HighlyAvailableGraphDatabase slave = cluster.getAnySlave();\n        try ( Transaction tx = slave.beginTx() )\n        {\n            assertEquals( 1, slave.getNodeById( commonNodeId ).getProperty( \"i\" ) );\n        }\n    }","id":38104,"modified_method":"@Test\n    public void pullUpdatesShellAppPullsUpdates() throws Throwable\n    {\n        ClusterManager.ManagedCluster cluster = clusterRule.withProvider( clusterOfSize( 2 ) ).\n                withSharedSetting( HaSettings.pull_interval, \"0\" ).\n                withSharedSetting( HaSettings.tx_push_factor, \"0\" ).\n                withSharedSetting( ShellSettings.remote_shell_enabled, Settings.TRUE ).\n                withInstanceSetting( ShellSettings.remote_shell_port, new IntFunction<String>()\n                {\n                    @Override\n                    public String apply( int oneBasedServerId )\n                    {\n                        return oneBasedServerId >= 1 && oneBasedServerId <= 2 ?\n                               \"\" + (SHELL_PORT + oneBasedServerId) : null;\n                    }\n                } ).\n                startCluster();\n\n        long commonNodeId = createNodeOnMaster( cluster );\n\n        setProperty( cluster.getMaster(), commonNodeId, 1 );\n        callPullUpdatesViaShell( 2 );\n        HighlyAvailableGraphDatabase slave = cluster.getAnySlave();\n        try ( Transaction tx = slave.beginTx() )\n        {\n            assertEquals( 1, slave.getNodeById( commonNodeId ).getProperty( \"i\" ) );\n            tx.success();\n        }\n    }","commit_id":"da30edd87a2d1c70135f9f38be71b12adbb5f3b9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void terminatedTransactionDoesNotForceUpdatePullingWithTxTerminationAwareLocks() throws Throwable\n    {\n        int testTxsOnMaster = 42;\n        File root = testDirectory.directory( testName.getMethodName() );\n        ClusterManager clusterManager = new ClusterManager.Builder( root )\n                .withSharedConfig( MapUtil.stringMap(\n                        HaSettings.pull_interval.name(), \"0s\",\n                        HaSettings.tx_push_factor.name(), \"0\",\n                        KernelTransactions.tx_termination_aware_locks.name(), Settings.TRUE ) ).build();\n        clusterManager.start();\n        cluster = clusterManager.getDefaultCluster();\n\n        HighlyAvailableGraphDatabase master = cluster.getMaster();\n        final HighlyAvailableGraphDatabase slave = cluster.getAnySlave();\n\n        createNodeOn( master );\n        cluster.sync();\n\n        long lastClosedTxIdOnMaster = lastClosedTxIdOn( master );\n        long lastClosedTxIdOnSlave = lastClosedTxIdOn( slave );\n\n        final CountDownLatch slaveTxStarted = new CountDownLatch( 1 );\n        final CountDownLatch slaveShouldCommit = new CountDownLatch( 1 );\n        final AtomicReference<Transaction> slaveTx = new AtomicReference<>();\n        Future<?> slaveCommit = Executors.newSingleThreadExecutor().submit( new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try ( Transaction tx = slave.beginTx() )\n                {\n                    slaveTx.set( tx );\n                    slaveTxStarted.countDown();\n                    await( slaveShouldCommit );\n                    tx.success();\n                }\n            }\n        } );\n\n        await( slaveTxStarted );\n        createNodesOn( master, testTxsOnMaster );\n\n        assertNotNull( slaveTx.get() );\n        slaveTx.get().terminate();\n        slaveShouldCommit.countDown();\n\n        try\n        {\n            slaveCommit.get();\n            fail( \"Exception expected\" );\n        }\n        catch ( Exception e )\n        {\n            assertThat( e, instanceOf( ExecutionException.class ) );\n            assertThat( e.getCause(), instanceOf( TransientTransactionFailureException.class ) );\n        }\n\n        assertEquals( lastClosedTxIdOnMaster + testTxsOnMaster, lastClosedTxIdOn( master ) );\n        assertEquals( lastClosedTxIdOnSlave, lastClosedTxIdOn( slave ) );\n    }","id":38105,"modified_method":"@Test\n    public void terminatedTransactionDoesNotForceUpdatePullingWithTxTerminationAwareLocks() throws Throwable\n    {\n        int testTxsOnMaster = 42;\n\n        ClusterManager.ManagedCluster cluster = clusterRule.\n                withSharedSetting( HaSettings.pull_interval, \"0s\" ).\n                withSharedSetting( HaSettings.tx_push_factor, \"0\" ).\n                withSharedSetting( KernelTransactions.tx_termination_aware_locks, Settings.TRUE ).\n                startCluster();\n\n        HighlyAvailableGraphDatabase master = cluster.getMaster();\n        final HighlyAvailableGraphDatabase slave = cluster.getAnySlave();\n\n        createNodeOn( master );\n        cluster.sync();\n\n        long lastClosedTxIdOnMaster = lastClosedTxIdOn( master );\n        long lastClosedTxIdOnSlave = lastClosedTxIdOn( slave );\n\n        final CountDownLatch slaveTxStarted = new CountDownLatch( 1 );\n        final CountDownLatch slaveShouldCommit = new CountDownLatch( 1 );\n        final AtomicReference<Transaction> slaveTx = new AtomicReference<>();\n        Future<?> slaveCommit = Executors.newSingleThreadExecutor().submit( new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try ( Transaction tx = slave.beginTx() )\n                {\n                    slaveTx.set( tx );\n                    slaveTxStarted.countDown();\n                    await( slaveShouldCommit );\n                    tx.success();\n                }\n            }\n        } );\n\n        await( slaveTxStarted );\n        createNodesOn( master, testTxsOnMaster );\n\n        assertNotNull( slaveTx.get() );\n        slaveTx.get().terminate();\n        slaveShouldCommit.countDown();\n\n        try\n        {\n            slaveCommit.get();\n            fail( \"Exception expected\" );\n        }\n        catch ( Exception e )\n        {\n            assertThat( e, instanceOf( ExecutionException.class ) );\n            assertThat( e.getCause(), instanceOf( TransientTransactionFailureException.class ) );\n        }\n\n        assertEquals( lastClosedTxIdOnMaster + testTxsOnMaster, lastClosedTxIdOn( master ) );\n        assertEquals( lastClosedTxIdOnSlave, lastClosedTxIdOn( slave ) );\n    }","commit_id":"da30edd87a2d1c70135f9f38be71b12adbb5f3b9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean build() {\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(myToMake.keySet())).toListSequence();\n    ISequence<SModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, SModule>() {\n      @Override\n      public SModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new JpsRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputTmpRoot = getTmpOutputRoot(mpsModule.getModule(), myContext.getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getProjectDescriptor().dataManager);\n      boolean useTransientOutputFolder = mpsModule.getConfiguration().isUseTransientOutputFolder();\n      myRedirects.addRedirects(outputPaths, outputTmpRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), useTransientOutputFolder);\n\n      File generatorOutputRoot = new File(mpsModule.getConfiguration().getGeneratorOutputPath());\n      File outputRoot = useTransientOutputFolder ? outputTmpRoot : generatorOutputRoot;\n      myOutputRootsPerTarget.put(target, outputRoot);\n\n      if (useTransientOutputFolder || !isGenOutputUnderSourceRoot(target, mpsModule)) {\n        BuildRootIndex buildRootIndex = myContext.getProjectDescriptor().getBuildRootIndex();\n        buildRootIndex.associateTempRoot(myContext, target, new JavaSourceRootDescriptor(outputRoot, target, true, true, \"\", Collections.<File>emptySet()));\n      }\n    }\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      @Override\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      @Override\n      public String belongsToForeignPath(IFile path) {\n        return myForeignRootPaths != null ? myForeignRootPaths.findForeignPrefix(path.getPath()) : null;\n      }\n    });\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = new MakeSession(myProject, myMessageHandler, true) {\n      @Override\n      public IScript toScript(ScriptBuilder scriptBuilder) {\n        scriptBuilder.withFacetNames(\n          new IFacet.Name(\"jetbrains.mps.make.reduced.ReportFiles\"),\n          new IFacet.Name(\"jetbrains.mps.make.reduced.CollectHashes\"));\n        return scriptBuilder.toScript();\n      }\n    };\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !JavaBuilderUtil.isCompileJavaIncrementally(myContext), new Stub(), new IJobMonitor.Stub() {\n      @Override\n      public void reportFeedback(IFeedback fdbk) {\n        myMessageFeedbackStrategy.reportFeedback(fdbk);\n      }\n    });\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets(ms);\n    boolean success;\n\n    try {\n      Future<IResult> res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n      success = processFiles(success, makeFacetConfiguration);\n    } catch (InterruptedException e) {\n      reportError(e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(e);\n      success = false;\n    }\n\n    return success;\n  }","id":38106,"modified_method":"public boolean build() {\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(myToMake.keySet())).toListSequence();\n    ISequence<SModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, SModule>() {\n      @Override\n      public SModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new JpsRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputTmpRoot = getTmpOutputRoot(mpsModule.getModule(), myContext.getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getProjectDescriptor().dataManager);\n      boolean useTransientOutputFolder = mpsModule.getConfiguration().isUseTransientOutputFolder();\n      myRedirects.addRedirects(outputPaths, outputTmpRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), useTransientOutputFolder);\n\n      File generatorOutputRoot = new File(mpsModule.getConfiguration().getGeneratorOutputPath());\n      File outputRoot = useTransientOutputFolder ? outputTmpRoot : generatorOutputRoot;\n      myOutputRootsPerTarget.put(target, outputRoot);\n\n      if (useTransientOutputFolder || !isGenOutputUnderSourceRoot(target, mpsModule)) {\n        BuildRootIndex buildRootIndex = myContext.getProjectDescriptor().getBuildRootIndex();\n        buildRootIndex.associateTempRoot(myContext, target, new JavaSourceRootDescriptor(outputRoot, target, true, true, \"\", Collections.<File>emptySet()));\n      }\n    }\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      @Override\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      @Override\n      public String belongsToForeignPath(IFile path) {\n        return myForeignRootPaths != null ? myForeignRootPaths.findForeignPrefix(path.getPath()) : null;\n      }\n    });\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = createCleanMakeSession();\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !JavaBuilderUtil.isCompileJavaIncrementally(myContext), new Stub(), new IJobMonitor.Stub() {\n      @Override\n      public void reportFeedback(IFeedback fdbk) {\n        myMessageFeedbackStrategy.reportFeedback(fdbk);\n      }\n    });\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets(ms);\n    boolean success;\n\n    try {\n      Future<IResult> res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n      success = processFiles(success, makeFacetConfiguration);\n    } catch (InterruptedException e) {\n      reportError(\"Error while make\", e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(\"Error while make\", e);\n      success = false;\n    }\n\n    return success;\n  }","commit_id":"b11fd9bef87a31ac10fed3fda32e6b6fd1c21752","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void reportError(Throwable e) {\n    myContext.processMessage(\n      new CompilerMessage(MPSMakeConstants.BUILDER_ID,\n        Kind.ERROR, e.getMessage()));\n  }","id":38107,"modified_method":"private void reportError(String msg, Throwable e) {\n    myContext.processMessage(\n      new CompilerMessage(msg,\n        Kind.ERROR, e.getMessage()));\n  }","commit_id":"b11fd9bef87a31ac10fed3fda32e6b6fd1c21752","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MyForeignRootPaths(Iterable<String> foreignRoots) {\n      this.rootPaths = Sequence.fromIterable(foreignRoots).select(new ISelector<String, String>() {\n        private String myDir;\n\n        @Override\n        public String select(String dir) {\n          myDir = dir;\n          return DirUtil.normalizeAsDir(dir);\n        }\n      }).sort(new ISelector<String, String>() {\n        @Override\n        public String select(String dir) {\n          return dir;\n        }\n      }, true).toGenericArray(String.class);\n    }","id":38108,"modified_method":"public MyForeignRootPaths(Iterable<String> foreignRoots) {\n      this.rootPaths = Sequence.fromIterable(foreignRoots).select(new ISelector<String, String>() {\n        @Override\n        public String select(String dir) {\n          return DirUtil.normalizeAsDir(dir);\n        }\n      }).sort(new ISelector<String, String>() {\n        @Override\n        public String select(String dir) {\n          return dir;\n        }\n      }, true).toGenericArray(String.class);\n    }","commit_id":"b11fd9bef87a31ac10fed3fda32e6b6fd1c21752","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean processFiles(boolean success, ReducedMakeFacetConfiguration makeFacetConfiguration) {\n    ProjectBuilderLogger logger = myContext.getLoggingManager().getProjectBuilderLogger();\n    if (logger.isEnabled()) {\n      try {\n        logger.logCompiledPaths(makeFacetConfiguration.getWrittenFiles(), MPSMakeConstants.BUILDER_ID, \"Written files:\");\n      } catch (IOException ignore) {\n      }\n    }\n\n    for (String writtenFile : makeFacetConfiguration.getWrittenFiles()) {\n      SModel source = makeFacetConfiguration.getSource(writtenFile);\n      ModuleBuildTarget target = myToMake.get(source);\n      File file = new File(writtenFile);\n\n      if (JavaBuilder.JAVA_SOURCES_FILTER.accept(file)) {\n        // all written java files need to be marked as dirty to get compiled by the JavaBuilder\n        try {\n          FSOperations.markDirty(myContext, new File(writtenFile));\n        } catch (IOException e) {\n          reportError(e);\n          success = false;\n        }\n      } else {\n        // all non-java files got to be copied (which are not in the caches folder)\n        if (!myRedirects.isInCacheOutput(writtenFile)) {\n          try {\n            copyResource(target, file);\n          } catch (IOException e) {\n            myContext.processMessage(new CompilerMessage(\"MPS resources\", Kind.ERROR, e.getMessage(), FileUtil.toSystemIndependentName(file.getParent())));\n            success = false;\n          }\n        }\n      }\n\n      myRefreshComponent.refresh(writtenFile);\n    }\n    for (String keptFile : makeFacetConfiguration.getKeptFiles()) {\n      try {\n        FSOperations.markDirty(myContext, new File(keptFile));\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n    }\n\n    if (logger.isEnabled()) {\n      logger.logDeletedFiles(makeFacetConfiguration.getDeletedFiles());\n    }\n\n    for (String deletedFile : makeFacetConfiguration.getDeletedFiles()) {\n      try {\n        FSOperations.markDeleted(myContext, new File(deletedFile));\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n    }\n    myRefreshComponent.removed(makeFacetConfiguration.getDeletedFiles());\n    return success;\n  }","id":38109,"modified_method":"private boolean processFiles(boolean success, ReducedMakeFacetConfiguration makeFacetConfiguration) {\n    ProjectBuilderLogger logger = myContext.getLoggingManager().getProjectBuilderLogger();\n    if (logger.isEnabled()) {\n      try {\n        logger.logCompiledPaths(makeFacetConfiguration.getWrittenFiles(), MPSMakeConstants.BUILDER_ID, \"Written files:\");\n      } catch (IOException ignored) {\n      }\n    }\n\n    for (String writtenFile : makeFacetConfiguration.getWrittenFiles()) {\n      SModel source = makeFacetConfiguration.getSource(writtenFile);\n      ModuleBuildTarget target = myToMake.get(source);\n      File file = new File(writtenFile);\n\n      if (source != null) {\n        DataSource dataSource = source.getSource();\n        // FIXME: FileSystemBasedDataSource needs to have method declared which returns the description of its contents (e.g. file or set of files)\n        if (!(dataSource instanceof FileDataSource || dataSource instanceof FilePerRootDataSource)) {\n          throw new IllegalArgumentException(\"MPS Idea plugin does not support the data source root formats other than FileDataSource and FilePerRootDataSource\");\n        }\n        // all written java files need to be registered as output for the model files to get recompiled in the case of models' change\n        if (isJava(file)) {\n          String location = dataSource.getLocation();\n          try {\n            myOutputConsumer.registerOutputFile(target, file, Arrays.asList(location));\n          } catch (IOException e) {\n            reportError(\"IO problem while registering output for source\", e);\n            success = false;\n          }\n        }\n      }\n\n      if (isJava(file)) {\n        // all written java files need to be marked as dirty to get compiled by the JavaBuilder\n        try {\n          FSOperations.markDirty(myContext, CompilationRound.CURRENT, new File(writtenFile));\n        } catch (IOException e) {\n          reportError(\"IO problem while marking java sources dirty\", e);\n          success = false;\n        }\n      } else {\n        // all non-java files got to be copied (which are not in the caches folder)\n        if (!myRedirects.isInCacheOutput(writtenFile)) {\n          try {\n            copyResource(target, file);\n          } catch (IOException e) {\n            reportError(\"IO problem during resources copying\", e);\n            success = false;\n          }\n        }\n      }\n\n      myRefreshComponent.refresh(writtenFile);\n    }\n\n    for (String keptFile : makeFacetConfiguration.getKeptFiles()) {\n      File file = new File(keptFile);\n      // all kept java files need to be marked as dirty to get compiled by the JavaBuilder\n      // (e.g. scenario: removed output folder, src_gen persists)\n      if (isJava(file)) {\n        try {\n          FSOperations.markDirty(myContext, CompilationRound.CURRENT, file);\n        } catch (IOException e) {\n          reportError(\"IO problem during marking kept java sources dirty\", e);\n          success = false;\n        }\n      }\n    }\n\n    List<String> deletedFiles = makeFacetConfiguration.getDeletedFiles();\n    if (logger.isEnabled()) {\n      logger.logDeletedFiles(deletedFiles);\n    }\n\n    for (String deletedFile : deletedFiles) {\n      try {\n        FSOperations.markDeleted(myContext, new File(deletedFile));\n      } catch (IOException e) {\n        reportError(\"IO problem while deleting files with FS\", e);\n        success = false;\n      }\n    }\n    myRefreshComponent.removed(deletedFiles);\n    return success;\n  }","commit_id":"b11fd9bef87a31ac10fed3fda32e6b6fd1c21752","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public ExitCode build(final CompileContext compileContext,\n                        ModuleChunk moduleChunk,\n                        DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                        final OutputConsumer outputConsumer) throws ProjectBuildException, IOException {\n    ExitCode status = ExitCode.NOTHING_DONE;\n    try {\n      final Set<ModuleBuildTarget> targets = new HashSet<ModuleBuildTarget>();\n      dirtyFilesHolder.processDirtyFiles(new FileProcessor<JavaSourceRootDescriptor, ModuleBuildTarget>() {\n        @Override\n        public boolean apply(ModuleBuildTarget target, File file, JavaSourceRootDescriptor javaSourceRootDescriptor) throws IOException {\n          LOG.debug(\"Dirty file \" + file + \" in the target \" + target);\n          targets.add(target);\n          return true;\n        }\n      });\n\n      boolean isMPSChunk = false;\n      // MPS-20569 different description: Compile files/package action doesn't compile generated java sources\n      boolean sourceGenNotInScope = false;\n      for (JpsModule jpsModule : moduleChunk.getModules()) {\n        JpsMPSModuleExtension extension = JpsMPSExtensionService.getInstance().getExtension(jpsModule);\n        if (extension == null) {\n          continue;\n        }\n        isMPSChunk = true;\n        boolean inScope = false;\n        for (ModuleBuildTarget target : targets) {\n          if (compileContext.getScope().isAffected(target, new File(extension.getConfiguration().getGeneratorOutputPath()))) {\n            // at least one build target has it in scope\n            inScope = true;\n            break;\n          }\n          if (!inScope) {\n            sourceGenNotInScope = true;\n            break;\n          }\n        }\n      }\n\n      if (!isMPSChunk) {\n        return status;\n      }\n      if (sourceGenNotInScope) {\n        compileContext.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.ERROR, \"Compile scope is too narrow. MPS generated sources would be out of scope\" ));\n        return ExitCode.ABORT;\n      }\n\n      JpsMPSRepositoryFacade.getInstance().init(compileContext);\n\n      final Map<SModel, ModuleBuildTarget> toMake = collectChangedModels(compileContext, dirtyFilesHolder);\n      if (toMake.isEmpty()) {\n        LOG.debug(\"Nothing to do\");\n        return status;\n      }\n\n      MPSMakeMediator makeMediator = new MPSMakeMediator(JpsMPSRepositoryFacade.getInstance().getProject(), toMake, compileContext, refreshComponent, outputConsumer);\n      boolean success = makeMediator.build();\n      if (success) {\n        status = ExitCode.OK;\n      }\n    } catch (Exception ex) {\n      throw new ProjectBuildException(ex);\n    }\n\n    if (MPSCompilerUtil.isTracingMode()) {\n      compileContext.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.WARNING, \"<simple warning to show Messages tool>\"));\n    }\n    return status;\n  }","id":38110,"modified_method":"@Override\n  public ExitCode build(final CompileContext compileContext,\n                        ModuleChunk moduleChunk,\n                        DirtyFilesHolder<JavaSourceRootDescriptor, ModuleBuildTarget> dirtyFilesHolder,\n                        final OutputConsumer outputConsumer) throws ProjectBuildException, IOException {\n    ExitCode status = ExitCode.NOTHING_DONE;\n    try {\n      final Set<ModuleBuildTarget> targets = new HashSet<ModuleBuildTarget>();\n      dirtyFilesHolder.processDirtyFiles(new FileProcessor<JavaSourceRootDescriptor, ModuleBuildTarget>() {\n        @Override\n        public boolean apply(ModuleBuildTarget target, File file, JavaSourceRootDescriptor javaSourceRootDescriptor) throws IOException {\n          LOG.debug(\"Dirty file \" + file + \" in the target \" + target);\n          targets.add(target);\n          return true;\n        }\n      });\n\n      boolean isMPSChunk = false;\n      // MPS-20569 different description: Compile files/package action doesn't compile generated java sources\n      boolean sourceGenNotInScope = false;\n      for (JpsModule jpsModule : moduleChunk.getModules()) {\n        JpsMPSModuleExtension extension = JpsMPSExtensionService.getInstance().getExtension(jpsModule);\n        if (extension == null) {\n          continue;\n        }\n        isMPSChunk = true;\n        boolean inScope = false;\n        for (ModuleBuildTarget target : targets) {\n          if (compileContext.getScope().isAffected(target, new File(extension.getConfiguration().getGeneratorOutputPath()))) {\n            // at least one build target has it in scope\n            inScope = true;\n            break;\n          }\n        }\n        if (!inScope) {\n          sourceGenNotInScope = true;\n          break;\n        }\n      }\n\n      if (!isMPSChunk) {\n        return status;\n      }\n      if (sourceGenNotInScope) {\n        compileContext.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.ERROR, \"Compile scope is too narrow. MPS generated sources would be out of scope\" ));\n        return ExitCode.ABORT;\n      }\n\n      JpsMPSRepositoryFacade.getInstance().init(compileContext);\n\n      final Map<SModel, ModuleBuildTarget> toMake = collectChangedModels(compileContext, dirtyFilesHolder);\n      if (toMake.isEmpty()) {\n        LOG.debug(\"Nothing to do\");\n        return status;\n      }\n\n      MPSMakeMediator makeMediator = new MPSMakeMediator(JpsMPSRepositoryFacade.getInstance().getProject(), toMake, compileContext, refreshComponent, outputConsumer);\n      boolean success = makeMediator.build();\n      if (success) {\n        status = ExitCode.OK;\n      }\n    } catch (Exception ex) {\n      throw new ProjectBuildException(ex);\n    }\n\n    if (MPSCompilerUtil.isTracingMode()) {\n      compileContext.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.WARNING, \"<simple warning to show Messages tool>\"));\n    }\n    return status;\n  }","commit_id":"b11fd9bef87a31ac10fed3fda32e6b6fd1c21752","url":"https://github.com/JetBrains/MPS"},{"original_method":"static CCExecution newInstance(WebApp wapp) {\n\t\tfinal ServletContext ctx = (ServletContext)wapp.getNativeContext();\n\t\tfinal String updateURI = WebManager.getWebManager(ctx).getUpdateURI();\n\t\treturn new CCExecution(ctx,\n\t\t\tnew DesktopImpl(wapp, updateURI, \"/\", null, null));\n\t}","id":38111,"modified_method":"static CCExecution newInstance(WebApp wapp) {\n\t\tfinal ServletContext ctx = wapp.getServletContext();\n\t\tfinal String updateURI = WebManager.getWebManager(ctx).getUpdateURI();\n\t\treturn new CCExecution(ctx,\n\t\t\tnew DesktopImpl(wapp, updateURI, \"/\", null, null));\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Process a portlet request.\n\t * @return false if the page is not found.\n\t * @since 3.0.0\n\t */\n\tprotected boolean process(Session sess, RenderRequest request,\n\tRenderResponse response, String path, boolean bRichlet)\n\tthrows PortletException, IOException {\n//\t\tif (log.debugable()) log.debug(\"Creates from \"+path);\n\t\tfinal WebManager webman = getWebManager();\n\t\tfinal WebApp wapp = webman.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal HttpServletRequest httpreq = RenderHttpServletRequest.getInstance(request);\n\t\tfinal HttpServletResponse httpres = RenderHttpServletResponse.getInstance(response);\n\t\tfinal ServletContext svlctx = (ServletContext)wapp.getNativeContext();\n\n\t\tfinal DesktopRecycle dtrc = wapp.getConfiguration().getDesktopRecycle();\n\t\tDesktop desktop = dtrc != null ?\n\t\t\tDesktopRecycles.beforeService(dtrc, svlctx, sess, httpreq, httpres, path): null;\n\n\t\ttry {\n\t\t\tif (desktop != null) { //recycle\n\t\t\t\tfinal Page page = Utils.getMainPage(desktop);\n\t\t\t\tif (page != null) {\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine()\n\t\t\t\t\t\t.recycleDesktop(exec, page, response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\tdesktop = null; //something wrong (not possible; just in case)\n\t\t\t}\n\n\t\t\tif (desktop == null) {\n\t\t\t\tdesktop = webman.getDesktop(sess, httpreq, httpres, path, true);\n\t\t\t\tif (desktop == null) //forward or redirect\n\t\t\t\t\treturn true;\n\n\t\t\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\t\t\twapp, sess, desktop, httpreq,\n\t\t\t\t\tPageDefinitions.getLocator(wapp, path));\n\t\t\t\t((SessionCtrl)sess).notifyClientRequest(true);\n\n\t\t\t\tfinal Page page;\n\t\t\t\tfinal PageRenderPatch patch = getRenderPatch();\n\t\t\t\tfinal Writer out = patch.beforeRender(ri);\n\t\t\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\t\t\tif (uf.isRichlet(ri, bRichlet)) {\n\t\t\t\t\tfinal Richlet richlet = uf.getRichlet(ri, path);\n\t\t\t\t\tif (richlet == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, richlet, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, richlet, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else if (path != null) {\n\t\t\t\t\tfinal PageDefinition pagedef = uf.getPageDefinition(ri, path);\n\t\t\t\t\tif (pagedef == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, pagedef, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\treturn true; //nothing to do\n\n\t\t\t\tif (out != null)\n\t\t\t\t\tpatch.patchRender(ri, page, out, response.getWriter());\n\t\t\t}\n\t\t} finally {\n\t\t\tif (dtrc != null)\n\t\t\t\tDesktopRecycles.afterService(dtrc, desktop);\n\t\t}\n\t\treturn true; //success\n\t}","id":38112,"modified_method":"/** Process a portlet request.\n\t * @return false if the page is not found.\n\t * @since 3.0.0\n\t */\n\tprotected boolean process(Session sess, RenderRequest request,\n\tRenderResponse response, String path, boolean bRichlet)\n\tthrows PortletException, IOException {\n//\t\tif (log.debugable()) log.debug(\"Creates from \"+path);\n\t\tfinal WebManager webman = getWebManager();\n\t\tfinal WebApp wapp = webman.getWebApp();\n\t\tfinal WebAppCtrl wappc = (WebAppCtrl)wapp;\n\n\t\tfinal HttpServletRequest httpreq = RenderHttpServletRequest.getInstance(request);\n\t\tfinal HttpServletResponse httpres = RenderHttpServletResponse.getInstance(response);\n\t\tfinal ServletContext svlctx = wapp.getServletContext();\n\n\t\tfinal DesktopRecycle dtrc = wapp.getConfiguration().getDesktopRecycle();\n\t\tDesktop desktop = dtrc != null ?\n\t\t\tDesktopRecycles.beforeService(dtrc, svlctx, sess, httpreq, httpres, path): null;\n\n\t\ttry {\n\t\t\tif (desktop != null) { //recycle\n\t\t\t\tfinal Page page = Utils.getMainPage(desktop);\n\t\t\t\tif (page != null) {\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine()\n\t\t\t\t\t\t.recycleDesktop(exec, page, response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\tdesktop = null; //something wrong (not possible; just in case)\n\t\t\t}\n\n\t\t\tif (desktop == null) {\n\t\t\t\tdesktop = webman.getDesktop(sess, httpreq, httpres, path, true);\n\t\t\t\tif (desktop == null) //forward or redirect\n\t\t\t\t\treturn true;\n\n\t\t\t\tfinal RequestInfo ri = new RequestInfoImpl(\n\t\t\t\t\twapp, sess, desktop, httpreq,\n\t\t\t\t\tPageDefinitions.getLocator(wapp, path));\n\t\t\t\t((SessionCtrl)sess).notifyClientRequest(true);\n\n\t\t\t\tfinal Page page;\n\t\t\t\tfinal PageRenderPatch patch = getRenderPatch();\n\t\t\t\tfinal Writer out = patch.beforeRender(ri);\n\t\t\t\tfinal UiFactory uf = wappc.getUiFactory();\n\t\t\t\tif (uf.isRichlet(ri, bRichlet)) {\n\t\t\t\t\tfinal Richlet richlet = uf.getRichlet(ri, path);\n\t\t\t\t\tif (richlet == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, richlet, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, richlet, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else if (path != null) {\n\t\t\t\t\tfinal PageDefinition pagedef = uf.getPageDefinition(ri, path);\n\t\t\t\t\tif (pagedef == null)\n\t\t\t\t\t\treturn false; //not found\n\n\t\t\t\t\tpage = WebManager.newPage(uf, ri, pagedef, httpres, path);\n\t\t\t\t\tfinal Execution exec =\n\t\t\t\t\t\tnew ExecutionImpl(svlctx, httpreq, httpres, desktop, page);\n\t\t\t\t\tfixContentType(response);\n\t\t\t\t\twappc.getUiEngine().execNewPage(exec, pagedef, page,\n\t\t\t\t\t\tout != null ? out: response.getWriter());\n\t\t\t\t} else\n\t\t\t\t\treturn true; //nothing to do\n\n\t\t\t\tif (out != null)\n\t\t\t\t\tpatch.patchRender(ri, page, out, response.getWriter());\n\t\t\t}\n\t\t} finally {\n\t\t\tif (dtrc != null)\n\t\t\t\tDesktopRecycles.afterService(dtrc, desktop);\n\t\t}\n\t\treturn true; //success\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the update servlet of the specified application, or\n\t * null if not loaded yet.\n\t * Note: if the update servlet is not loaded, it returns null.\n\t * @since 3.0.2\n\t */\n\tpublic static DHtmlUpdateServlet getUpdateServlet(WebApp wapp) {\n\t\treturn (DHtmlUpdateServlet)\n\t\t\t((ServletContext)wapp.getNativeContext())\n\t\t\t\t.getAttribute(ATTR_UPDATE_SERVLET);\n\t}","id":38113,"modified_method":"/** Returns the update servlet of the specified application, or\n\t * null if not loaded yet.\n\t * Note: if the update servlet is not loaded, it returns null.\n\t * @since 3.0.2\n\t */\n\tpublic static DHtmlUpdateServlet getUpdateServlet(WebApp wapp) {\n\t\treturn (DHtmlUpdateServlet)\n\t\t\t(wapp.getServletContext()).getAttribute(ATTR_UPDATE_SERVLET);\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"public void init(WebApp wapp) throws Exception {\r\n\t\tloadProperites((ServletContext)wapp.getNativeContext());\r\n\t}","id":38114,"modified_method":"public void init(WebApp wapp) throws Exception {\r\n\t\tloadProperites(wapp.getServletContext());\r\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the locator for the specified context.\n\t *\n\t * @param path the original path, or null if not available.\n\t * The original path is used to resolve a relative path.\n\t * If not specified, {@link org.zkoss.zk.ui.Desktop#getCurrentDirectory}\n\t * is used.\n\t */\n\tpublic static final Locator getLocator(WebApp wapp, String path) {\n\t\tif (wapp == null) throw new IllegalArgumentException(\"null\");\n\t\n\t\tif (path != null && path.length() > 0 && path.charAt(0) == '/') {\n\t\t\tfinal int j = path.lastIndexOf('/');\n\t\t\tpath = j > 0 ? path.substring(0, j + 1): \"/\";\n\t\t} else {\n\t\t\tfinal Execution exec = Executions.getCurrent();\n\t\t\tif (exec != null) path = exec.getDesktop().getCurrentDirectory();\n\t\t}\n\t\tfinal Object ctx = wapp.getNativeContext();\n\t\tif (ctx instanceof ServletContext)\n\t\t\treturn new ServletContextLocator((ServletContext)ctx, path);\n\t\tthrow new UnsupportedOperationException(\"Unknown context: \"+ctx);\n\t}","id":38115,"modified_method":"/** Returns the locator for the specified context.\n\t *\n\t * @param path the original path, or null if not available.\n\t * The original path is used to resolve a relative path.\n\t * If not specified, {@link org.zkoss.zk.ui.Desktop#getCurrentDirectory}\n\t * is used.\n\t */\n\tpublic static final Locator getLocator(WebApp wapp, String path) {\n\t\tif (wapp == null) throw new IllegalArgumentException(\"null\");\n\t\n\t\tif (path != null && path.length() > 0 && path.charAt(0) == '/') {\n\t\t\tfinal int j = path.lastIndexOf('/');\n\t\t\tpath = j > 0 ? path.substring(0, j + 1): \"/\";\n\t\t} else {\n\t\t\tfinal Execution exec = Executions.getCurrent();\n\t\t\tif (exec != null) path = exec.getDesktop().getCurrentDirectory();\n\t\t}\n\t\treturn new ServletContextLocator(wapp.getServletContext(), path);\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the page definition of the specified path, or null if not\n\t * found or failed to parse.\n\t *\n\t * <p>This is the lowest method that other getPageDefinition depends.\n\t *\n\t * <p>Dependency: Execution.createComponents -&amp; Execution.getPageDefinition\n\t * -&amp; UiFactory.getPageDefiition -&amp; PageDefintions.getPageDefinition\n\t *\n\t * @param locator the locator used to locate taglib and other resources.\n\t * If null, wapp is assumed ({@link WebApp} is also assumed).\n\t */\n\tpublic static final\n\tPageDefinition getPageDefinition(WebApp wapp, Locator locator, String path) {\n\t\twapp.getConfiguration().invokeURIInterceptors(path);\n\t\t\t//give the security a chance to reject\n\n\t\tfinal Object ctx = wapp.getNativeContext();\n\t\tif (ctx instanceof ServletContext)\n\t\t\treturn ResourceCaches.get(\n\t\t\t\tgetCache(wapp), (ServletContext)ctx, path, locator);\n\t\tthrow new UnsupportedOperationException(\"Unknown context: \"+ctx);\n\t}","id":38116,"modified_method":"/** Returns the page definition of the specified path, or null if not\n\t * found or failed to parse.\n\t *\n\t * <p>This is the lowest method that other getPageDefinition depends.\n\t *\n\t * <p>Dependency: Execution.createComponents -&amp; Execution.getPageDefinition\n\t * -&amp; UiFactory.getPageDefiition -&amp; PageDefintions.getPageDefinition\n\t *\n\t * @param locator the locator used to locate taglib and other resources.\n\t * If null, wapp is assumed ({@link WebApp} is also assumed).\n\t */\n\tpublic static final\n\tPageDefinition getPageDefinition(WebApp wapp, Locator locator, String path) {\n\t\twapp.getConfiguration().invokeURIInterceptors(path);\n\t\t\t//give the security a chance to reject\n\n\t\treturn ResourceCaches.get(\n\t\t\tgetCache(wapp), wapp.getServletContext(), path, locator);\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"public Object getNativeContext() {\n\t\treturn _ctx;\n\t}","id":38117,"modified_method":"/** @deprecated As of release 6.0.0, replaced with {@link #getServletContext}.\n\t */\n\tpublic Object getNativeContext() {\n\t\treturn _ctx;\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/**\r\n\t * Get the spring application context.\r\n\t */\r\n\tpublic static ApplicationContext getApplicationContext() {\r\n\t\tExecution exec = Executions.getCurrent();\r\n\t\tif (exec == null) {\r\n\t\t\tthrow new UiException(\"SpringUtil can be called only under ZK environment!\");\r\n\t\t}\r\n\t\t\r\n\t\treturn WebApplicationContextUtils.getRequiredWebApplicationContext(\r\n\t\t\t\t(ServletContext)exec.getDesktop().getWebApp().getNativeContext());\r\n\t}","id":38118,"modified_method":"/**\r\n\t * Get the spring application context.\r\n\t */\r\n\tpublic static ApplicationContext getApplicationContext() {\r\n\t\tExecution exec = Executions.getCurrent();\r\n\t\tif (exec == null) {\r\n\t\t\tthrow new UiException(\"SpringUtil can be called only under ZK environment!\");\r\n\t\t}\r\n\t\t\r\n\t\treturn WebApplicationContextUtils.getRequiredWebApplicationContext(\r\n\t\t\t\texec.getDesktop().getWebApp().getServletContext());\r\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the Web manager of the specified {@link WebApp},\n\t * or null if not found.\n\t * @since 5.0.5\n\t */\n\tpublic static final WebManager getWebManagerIfAny(WebApp wapp) {\n\t\treturn getWebManagerIfAny((ServletContext)wapp.getNativeContext());\n\t}","id":38119,"modified_method":"/** Returns the Web manager of the specified {@link WebApp},\n\t * or null if not found.\n\t * @since 5.0.5\n\t */\n\tpublic static final WebManager getWebManagerIfAny(WebApp wapp) {\n\t\treturn getWebManagerIfAny(wapp.getServletContext());\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Creates a page.\n\t * It invokes {@link UiFactory#newPage}. However, it prepares\n\t * {@link ExecutionsCtrl#getCurrent} for {@link org.zkoss.zk.ui.sys.IdGenerator#nextPageUuid}\n\t *\n\t * <p>Note: Use this method to create a page, rather than invoking\n\t * {@link UiFactory#newPage} directly.\n\t * @since 3.6.0\n\t */\n\tpublic static\n\tPage newPage(UiFactory uf, RequestInfo ri, PageDefinition pagedef,\n\tServletResponse response, String path) {\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)ri.getDesktop();\n\t\tfinal Execution exec = ExecutionsCtrl.getCurrent();\n\t\tTemporaryExecution de = new TemporaryExecution(\n\t\t\t(ServletContext)ri.getWebApp().getNativeContext(),\n\t\t\t(HttpServletRequest)ri.getNativeRequest(),\n\t\t\t(HttpServletResponse)response, ri.getDesktop());\n\t\tdesktopCtrl.setExecution(de);\n\t\tExecutionsCtrl.setCurrent(de);\n\t\ttry {\n\t\t\treturn uf.newPage(ri, pagedef, path);\n\t\t\t\t//de won't be voided since no DesktopInit-like plugin\n\t\t} finally {\n\t\t\tExecutionsCtrl.setCurrent(exec);\n\t\t\tdesktopCtrl.setExecution(exec);\n\t\t}\n\t}","id":38120,"modified_method":"/** Creates a page.\n\t * It invokes {@link UiFactory#newPage}. However, it prepares\n\t * {@link ExecutionsCtrl#getCurrent} for {@link org.zkoss.zk.ui.sys.IdGenerator#nextPageUuid}\n\t *\n\t * <p>Note: Use this method to create a page, rather than invoking\n\t * {@link UiFactory#newPage} directly.\n\t * @since 3.6.0\n\t */\n\tpublic static\n\tPage newPage(UiFactory uf, RequestInfo ri, PageDefinition pagedef,\n\tServletResponse response, String path) {\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)ri.getDesktop();\n\t\tfinal Execution exec = ExecutionsCtrl.getCurrent();\n\t\tTemporaryExecution de = new TemporaryExecution(\n\t\t\tri.getWebApp().getServletContext(),\n\t\t\t(HttpServletRequest)ri.getNativeRequest(),\n\t\t\t(HttpServletResponse)response, ri.getDesktop());\n\t\tdesktopCtrl.setExecution(de);\n\t\tExecutionsCtrl.setCurrent(de);\n\t\ttry {\n\t\t\treturn uf.newPage(ri, pagedef, path);\n\t\t\t\t//de won't be voided since no DesktopInit-like plugin\n\t\t} finally {\n\t\t\tExecutionsCtrl.setCurrent(exec);\n\t\t\tdesktopCtrl.setExecution(exec);\n\t\t}\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the Web manager of the specified {@link WebApp}.\n\t * @since 3.0.4\n\t */\n\tpublic static final WebManager getWebManager(WebApp wapp) {\n\t\treturn getWebManager((ServletContext)wapp.getNativeContext());\n\t}","id":38121,"modified_method":"/** Returns the Web manager of the specified {@link WebApp}.\n\t * @since 3.0.4\n\t */\n\tpublic static final WebManager getWebManager(WebApp wapp) {\n\t\treturn getWebManager(wapp.getServletContext());\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"/** Creates a page.\n\t * It invokes {@link UiFactory#newPage}. However, it prepares\n\t * {@link ExecutionsCtrl#getCurrent} for {@link org.zkoss.zk.ui.sys.IdGenerator#nextPageUuid}\n\t *\n\t * <p>Note: Use this method to create a page, rather than invoking\n\t * {@link UiFactory#newPage} directly.\n\t * @since 3.6.0\n\t */\n\tpublic static\n\tPage newPage(UiFactory uf, RequestInfo ri, Richlet richlet,\n\tServletResponse response, String path) {\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)ri.getDesktop();\n\t\tfinal Execution exec = ExecutionsCtrl.getCurrent();\n\t\tTemporaryExecution de = new TemporaryExecution(\n\t\t\t(ServletContext)ri.getWebApp().getNativeContext(),\n\t\t\t(HttpServletRequest)ri.getNativeRequest(),\n\t\t\t(HttpServletResponse)response, ri.getDesktop());\n\t\tdesktopCtrl.setExecution(de);\n\t\tExecutionsCtrl.setCurrent(de);\n\t\ttry {\n\t\t\treturn uf.newPage(ri, richlet, path);\n\t\t\t\t//de won't be voided since no DesktopInit-like plugin\n\t\t} finally {\n\t\t\tExecutionsCtrl.setCurrent(exec);\n\t\t\tdesktopCtrl.setExecution(exec);\n\t\t}\n\t}","id":38122,"modified_method":"/** Creates a page.\n\t * It invokes {@link UiFactory#newPage}. However, it prepares\n\t * {@link ExecutionsCtrl#getCurrent} for {@link org.zkoss.zk.ui.sys.IdGenerator#nextPageUuid}\n\t *\n\t * <p>Note: Use this method to create a page, rather than invoking\n\t * {@link UiFactory#newPage} directly.\n\t * @since 3.6.0\n\t */\n\tpublic static\n\tPage newPage(UiFactory uf, RequestInfo ri, Richlet richlet,\n\tServletResponse response, String path) {\n\t\tfinal DesktopCtrl desktopCtrl = (DesktopCtrl)ri.getDesktop();\n\t\tfinal Execution exec = ExecutionsCtrl.getCurrent();\n\t\tTemporaryExecution de = new TemporaryExecution(\n\t\t\tri.getWebApp().getServletContext(),\n\t\t\t(HttpServletRequest)ri.getNativeRequest(),\n\t\t\t(HttpServletResponse)response, ri.getDesktop());\n\t\tdesktopCtrl.setExecution(de);\n\t\tExecutionsCtrl.setCurrent(de);\n\t\ttry {\n\t\t\treturn uf.newPage(ri, richlet, path);\n\t\t\t\t//de won't be voided since no DesktopInit-like plugin\n\t\t} finally {\n\t\t\tExecutionsCtrl.setCurrent(exec);\n\t\t\tdesktopCtrl.setExecution(exec);\n\t\t}\n\t}","commit_id":"ca516ff4cd62a19de38772f4cbc78a2d3bff72cb","url":"https://github.com/zkoss/zk"},{"original_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertCount(1)\r\n\t\t\t.append(\"spielplatz \").assertCount(1)\r\n\t\t\t.append(\"1 \").assertCount(3)\r\n\t\t\t.append(\"\\\"JUNIT\\\" \").assertCount(1)\r\n\t\t\t.append(\"{ \").assertCount(5)\r\n\t\t\t.append(\"kind \").assertCount(1)\r\n\t\t\t.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").assertCount(2)\r\n\t\t\t.append(\"e1 \").assertCount(2)\r\n\t\t\t.append(\"e2\").assertCount(2);\r\n\t}","id":38123,"modified_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertCount(1)\r\n\t\t\t.append(\"spielplatz \").assertCount(1)\r\n\t\t\t.append(\"1 \").assertCount(2)\r\n\t\t\t.append(\"\\\"JUNIT\\\" \").assertCount(1)\r\n\t\t\t.append(\"{ \").assertCount(5)\r\n\t\t\t.append(\"kind \").assertCount(1)\r\n\t\t\t.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").assertCount(2)\r\n\t\t\t.append(\"e1 \").assertCount(2)\r\n\t\t\t.append(\"e2\").assertCount(2);\r\n\t}","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\r\n\t *\r\n\t * <p>\r\n\t * Tests proposals sample domain language.\r\n\t * <\/p>\r\n\t *\r\n\t * <a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=260688\">Bug 260688 <\/a>\r\n\t *\r\n//\t */\r\n//\tpublic void testDomainLanguage() throws Exception {\r\n//\t\tnewBuilder(DomainModel)\r\n//\t\t.assertCount(4)\r\n//\t\t.append(\"d\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"e\").assertCount(1)\r\n//\t\t.append(\"n\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.append(\"m\").assertCount(1)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"o\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"c\").assertCount(1)\r\n//\t\t.append(\"k\").assertCount(1);\r\n//\t}\r\n\r\n\r\n\tpublic void testCompleteRuleCall() throws Exception {\r\n\t\tnewBuilder(setup.getXtextGrammarTestSetup())\r\n\t\t\t.appendNl(\"grammar foo\")\r\n\t\t\t.appendNl(\"generate foo \\\"foo\\\"\")\r\n\t\t\t.appendNl(\"R1 : (attr+=R2)*;\")\r\n\t\t\t.appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n\t\t\t.append(\"R3: attr+=\").assertText(\r\n\t\t\t\t\t\"R1\",\r\n\t\t\t\t\t\"R2\",\r\n\t\t\t\t\t\"R3\",\r\n\t\t\t\t\t\"\\\"Value\\\"\",\r\n\t\t\t\t\t\"'Value'\",\r\n\t\t\t\t\t\"(\",\r\n\t\t\t\t\t\"[\",\r\n\t\t\t\t\t\"+=\" // current node is always a suggestion\r\n\t\t\t);\r\n\t}","id":38124,"modified_method":"/**\r\n\t *\r\n\t * <p>\r\n\t * Tests proposals sample domain language.\r\n\t * <\/p>\r\n\t *\r\n\t * <a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=260688\">Bug 260688 <\/a>\r\n\t *\r\n//\t */\r\n//\tpublic void testDomainLanguage() throws Exception {\r\n//\t\tnewBuilder(DomainModel)\r\n//\t\t.assertCount(4)\r\n//\t\t.append(\"d\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"e\").assertCount(1)\r\n//\t\t.append(\"n\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.append(\"m\").assertCount(1)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"o\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"c\").assertCount(1)\r\n//\t\t.append(\"k\").assertCount(1);\r\n//\t}\r\n\r\n\r\n\tpublic void testCompleteRuleCall() throws Exception {\r\n\t\tnewBuilder(setup.getXtextGrammarTestSetup())\r\n\t\t\t.appendNl(\"grammar foo\")\r\n\t\t\t.appendNl(\"generate foo \\\"foo\\\"\")\r\n\t\t\t.appendNl(\"R1 : (attr+=R2)*;\")\r\n\t\t\t.appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n\t\t\t.append(\"R3: attr+=\").assertText(\r\n\t\t\t\t\t\"R1\",\r\n\t\t\t\t\t\"R2\",\r\n\t\t\t\t\t\"R3\",\r\n\t\t\t\t\t\"\\\"Value\\\"\",\r\n\t\t\t\t\t\"(\",\r\n\t\t\t\t\t\"[\",\r\n\t\t\t\t\t\"+=\" // current node is always a suggestion\r\n\t\t\t);\r\n\t}","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\r\n     * regression test for:\r\n     *\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=260825\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=262313\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=267582\r\n     */\r\n    public void testCompleteAssignmentWithBacktracking() throws Exception {\r\n    \tnewBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo with org.eclipse.xtext.common.Terminals\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .append(\"MyRule : 'foo' name\").assertText(\r\n        \t\t\"\\\"Value\\\"\",\r\n        \t\t\"'Value'\",\r\n        \t\t\"(\",\r\n        \t\t\"*\",\r\n        \t\t\"+\",\r\n        \t\t\"+=\",\r\n        \t\t\";\",\r\n        \t\t\"=\",\r\n        \t\t\"?\",\r\n        \t\t\"?=\",\r\n        \t\t\"Feature\",\r\n        \t\t\"MyRule\",\r\n        \t\t\"{\")\r\n        .appendNl(\";\")\r\n        .append(\"terminal Other_Id\").assertText(\":\",\"returns\");\r\n\r\n    }","id":38125,"modified_method":"/**\r\n     * regression test for:\r\n     *\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=260825\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=262313\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=267582\r\n     */\r\n    public void testCompleteAssignmentWithBacktracking() throws Exception {\r\n    \tnewBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo with org.eclipse.xtext.common.Terminals\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .append(\"MyRule : 'foo' name\").assertText(\r\n        \t\t\"\\\"Value\\\"\",\r\n        \t\t\"(\",\r\n        \t\t\"*\",\r\n        \t\t\"+\",\r\n        \t\t\"+=\",\r\n        \t\t\";\",\r\n        \t\t\"=\",\r\n        \t\t\"?\",\r\n        \t\t\"?=\",\r\n        \t\t\"Feature\",\r\n        \t\t\"MyRule\",\r\n        \t\t\"{\")\r\n        .appendNl(\";\")\r\n        .append(\"terminal Other_Id\").assertText(\":\",\"returns\");\r\n\r\n    }","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertText(\"spielplatz\")\r\n\t\t\t.applyText().assertText(\"1 - Groesse\")\r\n\t\t\t.applyText().assertText(\"\\\"Beschreibung\\\"\", \"'Beschreibung'\", \"{\")\r\n\t\t\t.applyText().assertText(\"{\")\r\n\t\t\t.applyText().assertText(\"erwachsener\", \"familie\", \"spielzeug\", \"kind\", \"}\")\r\n\t\t\t.append(\"erwachsener \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"e1 \").assertText(\"1 - Age\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"erwachsener (e2 0) kind \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"k1 \").assertText(\"1 - Age\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"kind (k2 0) familie \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"keyword\", \"'Name'\", \"\\\"Name\\\"\", \"Name\")\r\n\t\t\t.append(\"keyword \").assertText(\"e1\",\"e2\")\r\n\t\t\t.applyText().assertText(\"e1\",\"e2\")\r\n\t\t\t.append(\"e2 \").assertText(\"k1\",\"k2\")\r\n\t\t\t.append(\"k\").assertText(\"k1\",\"k2\",\",\",\")\")\r\n\t\t\t.append(\"1 \").assertText(\",\",\")\")\r\n\t\t\t.append(\"k2 \").assertText(\",\",\")\")\r\n\t\t;\r\n\t}","id":38126,"modified_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertText(\"spielplatz\")\r\n\t\t\t.applyText().assertText(\"1\")\r\n\t\t\t.applyText().assertText(\"\\\"Beschreibung\\\"\", \"{\")\r\n\t\t\t.applyText().assertText(\"{\")\r\n\t\t\t.applyText().assertText(\"erwachsener\", \"familie\", \"spielzeug\", \"kind\", \"}\")\r\n\t\t\t.append(\"erwachsener \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"e1 \").assertText(\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"erwachsener (e2 0) kind \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"k1 \").assertText(\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"kind (k2 0) familie \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"keyword\", \"\\\"Name\\\"\", \"Name\")\r\n\t\t\t.append(\"keyword \").assertText(\"e1\",\"e2\")\r\n\t\t\t.applyText().assertText(\"e1\",\"e2\")\r\n\t\t\t.append(\"e2 \").assertText(\"k1\",\"k2\")\r\n\t\t\t.append(\"k\").assertText(\"k1\",\"k2\",\",\",\")\")\r\n\t\t\t.append(\"1 \").assertText(\",\",\")\")\r\n\t\t\t.append(\"k2 \").assertText(\",\",\")\")\r\n\t\t;\r\n\t}","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=269593\r\n     */\r\n    public void testCompleteRuleCallWithSpace() throws Exception {\r\n        newBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .appendNl(\"R1 : (attr+=R2)*;\")\r\n        .appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n        .append(\"R3: attr+= \").assertText(\r\n                        \"R1\",\r\n                        \"R2\",\r\n                        \"R3\",\r\n                        \"\\\"Value\\\"\",\r\n                        \"'Value'\",\r\n                        \"(\",\r\n                        \"[\"\r\n        );\r\n    }","id":38127,"modified_method":"/**\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=269593\r\n     */\r\n    public void testCompleteRuleCallWithSpace() throws Exception {\r\n        newBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .appendNl(\"R1 : (attr+=R2)*;\")\r\n        .appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n        .append(\"R3: attr+= \").assertText(\r\n                        \"R1\",\r\n                        \"R2\",\r\n                        \"R3\",\r\n                        \"\\\"Value\\\"\",\r\n                        \"(\",\r\n                        \"[\"\r\n        );\r\n    }","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(EObject element, String name, String prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(name, name, getImage(element), prefix, contentAssistContext);\n\t}","id":38128,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(EObject element, String name, String displayName, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(name, displayName, getImage(element), contentAssistContext);\n\t}","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(IScopedElement element, String prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(element.element(), element.name(), prefix, contentAssistContext);\n\t}","id":38129,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(IScopedElement element, String prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(element.element(), element.name(), element.name(), prefix, contentAssistContext);\n\t}","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"public ContentAssistProcessorTestBuilder assertTextAtCursorPosition(int cursorPosition, String... expectedText)\n\t\t\tthrows Exception {\n\n\t\tString currentModelToParse = getModel();\n\n\t\tICompletionProposal[] computeCompletionProposals = computeCompletionProposals(currentModelToParse,\n\t\t\t\tcursorPosition);\n\n\t\tif (computeCompletionProposals == null)\n\t\t\tcomputeCompletionProposals = new ICompletionProposal[0];\n\n\t\tString expectation = Strings.concat(\", \", Arrays.asList(expectedText));\n\t\tAssert.assertEquals(\"expect \" + expectedText.length + \" CompletionProposal item for model '\"\n\t\t\t\t+ currentModelToParse + \"': expectation was:\\n\" + expectation\n\t\t\t\t+ \"\\nbut actual was:\\n\" + Strings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\texpectedText.length, computeCompletionProposals.length);\n\n\t\t\n\t\tfor (int i = 0; i < computeCompletionProposals.length; i++) {\n\t\t\tICompletionProposal completionProposal = computeCompletionProposals[i];\n\t\t\tAssert.assertTrue(\"expect completionProposal text '\" + expectation + \"', but got \" +\n\t\t\t\t\tStrings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\t\tArrays.asList(expectedText).contains(completionProposal.getDisplayString()));\n\t\t}\n\n\t\treturn this;\n\t}","id":38130,"modified_method":"public ContentAssistProcessorTestBuilder assertTextAtCursorPosition(int cursorPosition, String... expectedText)\n\t\t\tthrows Exception {\n\n\t\tString currentModelToParse = getModel();\n\n\t\tICompletionProposal[] computeCompletionProposals = computeCompletionProposals(currentModelToParse,\n\t\t\t\tcursorPosition);\n\n\t\tif (computeCompletionProposals == null)\n\t\t\tcomputeCompletionProposals = new ICompletionProposal[0];\n\n\t\tString expectation = Strings.concat(\", \", Arrays.asList(expectedText));\n\t\tAssert.assertEquals(\"expect \" + expectedText.length + \" CompletionProposal item for model '\"\n\t\t\t\t+ currentModelToParse + \"': expectation was:\\n\" + expectation\n\t\t\t\t+ \"\\nbut actual was:\\n\" + Strings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\texpectedText.length, computeCompletionProposals.length);\n\n\t\t\n\t\tfor (int i = 0; i < computeCompletionProposals.length; i++) {\n\t\t\tICompletionProposal completionProposal = computeCompletionProposals[i];\n\t\t\tString proposedText = completionProposal.getDisplayString();\n\t\t\tif (completionProposal instanceof ConfigurableCompletionProposal)\n\t\t\t\tproposedText = ((ConfigurableCompletionProposal) completionProposal).getReplacementString();\n\t\t\tAssert.assertTrue(\"expect completionProposal text '\" + expectation + \"', but got \" +\n\t\t\t\t\tStrings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\t\tArrays.asList(expectedText).contains(proposedText));\n\t\t}\n\n\t\treturn this;\n\t}","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"private List<String> toString(ICompletionProposal[] proposals) {\n\t\tif (proposals == null)\n\t\t\treturn Collections.emptyList();\n\t\tList<String> res = new ArrayList<String>(proposals.length);\n\t\tfor (ICompletionProposal proposal : proposals) {\n\t\t\tres.add(proposal.getDisplayString());\n\t\t}\n\t\treturn res;\n\t}","id":38131,"modified_method":"private List<String> toString(ICompletionProposal[] proposals) {\n\t\tif (proposals == null)\n\t\t\treturn Collections.emptyList();\n\t\tList<String> res = new ArrayList<String>(proposals.length);\n\t\tfor (ICompletionProposal proposal : proposals) {\n\t\t\tString proposedText = proposal.getDisplayString();\n\t\t\tif (proposal instanceof ConfigurableCompletionProposal)\n\t\t\t\tproposedText = ((ConfigurableCompletionProposal) proposal).getReplacementString();\n\t\t\tres.add(proposedText);\n\t\t}\n\t\treturn res;\n\t}","commit_id":"f5fbb1afcf727c852402eb33254e1f712bdb7866","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertText(\"spielplatz\")\r\n\t\t\t.applyText().assertText(\"1 - Groesse\")\r\n\t\t\t.applyText().assertText(\"\\\"Beschreibung\\\"\", \"'Beschreibung'\", \"{\")\r\n\t\t\t.applyText().assertText(\"{\")\r\n\t\t\t.applyText().assertText(\"erwachsener\", \"familie\", \"spielzeug\", \"kind\", \"}\")\r\n\t\t\t.append(\"erwachsener \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"e1 \").assertText(\"1 - Age\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"erwachsener (e2 0) kind \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"k1 \").assertText(\"1 - Age\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"kind (k2 0) familie \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"keyword\", \"'Name'\", \"\\\"Name\\\"\", \"Name\")\r\n\t\t\t.append(\"keyword \").assertText(\"e1\",\"e2\")\r\n\t\t\t.applyText().assertText(\"e1\",\"e2\")\r\n\t\t\t.append(\"e2 \").assertText(\"k1\",\"k2\")\r\n\t\t\t.append(\"k\").assertText(\"k1\",\"k2\",\",\",\")\")\r\n\t\t\t.append(\"1 \").assertText(\",\",\")\")\r\n\t\t\t.append(\"k2 \").assertText(\",\",\")\")\r\n\t\t;\r\n\t}","id":38132,"modified_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertText(\"spielplatz\")\r\n\t\t\t.applyText().assertText(\"1\")\r\n\t\t\t.applyText().assertText(\"\\\"Beschreibung\\\"\", \"{\")\r\n\t\t\t.applyText().assertText(\"{\")\r\n\t\t\t.applyText().assertText(\"erwachsener\", \"familie\", \"spielzeug\", \"kind\", \"}\")\r\n\t\t\t.append(\"erwachsener \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"e1 \").assertText(\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"erwachsener (e2 0) kind \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"Name\")\r\n\t\t\t.append(\"k1 \").assertText(\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"kind (k2 0) familie \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"keyword\", \"\\\"Name\\\"\", \"Name\")\r\n\t\t\t.append(\"keyword \").assertText(\"e1\",\"e2\")\r\n\t\t\t.applyText().assertText(\"e1\",\"e2\")\r\n\t\t\t.append(\"e2 \").assertText(\"k1\",\"k2\")\r\n\t\t\t.append(\"k\").assertText(\"k1\",\"k2\",\",\",\")\")\r\n\t\t\t.append(\"1 \").assertText(\",\",\")\")\r\n\t\t\t.append(\"k2 \").assertText(\",\",\")\")\r\n\t\t;\r\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=269593\r\n     */\r\n    public void testCompleteRuleCallWithSpace() throws Exception {\r\n        newBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .appendNl(\"R1 : (attr+=R2)*;\")\r\n        .appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n        .append(\"R3: attr+= \").assertText(\r\n                        \"R1\",\r\n                        \"R2\",\r\n                        \"R3\",\r\n                        \"\\\"Value\\\"\",\r\n                        \"'Value'\",\r\n                        \"(\",\r\n                        \"[\"\r\n        );\r\n    }","id":38133,"modified_method":"/**\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=269593\r\n     */\r\n    public void testCompleteRuleCallWithSpace() throws Exception {\r\n        newBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .appendNl(\"R1 : (attr+=R2)*;\")\r\n        .appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n        .append(\"R3: attr+= \").assertText(\r\n                        \"R1\",\r\n                        \"R2\",\r\n                        \"R3\",\r\n                        \"\\\"Value\\\"\",\r\n                        \"(\",\r\n                        \"[\"\r\n        );\r\n    }","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\r\n\t *\r\n\t * <p>\r\n\t * Tests proposals sample domain language.\r\n\t * <\/p>\r\n\t *\r\n\t * <a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=260688\">Bug 260688 <\/a>\r\n\t *\r\n//\t */\r\n//\tpublic void testDomainLanguage() throws Exception {\r\n//\t\tnewBuilder(DomainModel)\r\n//\t\t.assertCount(4)\r\n//\t\t.append(\"d\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"e\").assertCount(1)\r\n//\t\t.append(\"n\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.append(\"m\").assertCount(1)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"o\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"c\").assertCount(1)\r\n//\t\t.append(\"k\").assertCount(1);\r\n//\t}\r\n\r\n\r\n\tpublic void testCompleteRuleCall() throws Exception {\r\n\t\tnewBuilder(setup.getXtextGrammarTestSetup())\r\n\t\t\t.appendNl(\"grammar foo\")\r\n\t\t\t.appendNl(\"generate foo \\\"foo\\\"\")\r\n\t\t\t.appendNl(\"R1 : (attr+=R2)*;\")\r\n\t\t\t.appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n\t\t\t.append(\"R3: attr+=\").assertText(\r\n\t\t\t\t\t\"R1\",\r\n\t\t\t\t\t\"R2\",\r\n\t\t\t\t\t\"R3\",\r\n\t\t\t\t\t\"\\\"Value\\\"\",\r\n\t\t\t\t\t\"'Value'\",\r\n\t\t\t\t\t\"(\",\r\n\t\t\t\t\t\"[\",\r\n\t\t\t\t\t\"+=\" // current node is always a suggestion\r\n\t\t\t);\r\n\t}","id":38134,"modified_method":"/**\r\n\t *\r\n\t * <p>\r\n\t * Tests proposals sample domain language.\r\n\t * <\/p>\r\n\t *\r\n\t * <a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=260688\">Bug 260688 <\/a>\r\n\t *\r\n//\t */\r\n//\tpublic void testDomainLanguage() throws Exception {\r\n//\t\tnewBuilder(DomainModel)\r\n//\t\t.assertCount(4)\r\n//\t\t.append(\"d\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"e\").assertCount(1)\r\n//\t\t.append(\"n\").assertCount(1)\r\n//\t\t.append(\"t\").assertCount(1)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"i\").assertCount(1)\r\n//\t\t.append(\"m\").assertCount(1)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"o\").assertCount(1)\r\n//\t\t.reset().assertCount(4)\r\n//\t\t.append(\"p\").assertCount(1)\r\n//\t\t.append(\"a\").assertCount(1)\r\n//\t\t.append(\"c\").assertCount(1)\r\n//\t\t.append(\"k\").assertCount(1);\r\n//\t}\r\n\r\n\r\n\tpublic void testCompleteRuleCall() throws Exception {\r\n\t\tnewBuilder(setup.getXtextGrammarTestSetup())\r\n\t\t\t.appendNl(\"grammar foo\")\r\n\t\t\t.appendNl(\"generate foo \\\"foo\\\"\")\r\n\t\t\t.appendNl(\"R1 : (attr+=R2)*;\")\r\n\t\t\t.appendNl(\"R2 : (attr=INT)? prop=R3;\")\r\n\t\t\t.append(\"R3: attr+=\").assertText(\r\n\t\t\t\t\t\"R1\",\r\n\t\t\t\t\t\"R2\",\r\n\t\t\t\t\t\"R3\",\r\n\t\t\t\t\t\"\\\"Value\\\"\",\r\n\t\t\t\t\t\"(\",\r\n\t\t\t\t\t\"[\",\r\n\t\t\t\t\t\"+=\" // current node is always a suggestion\r\n\t\t\t);\r\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\r\n     * regression test for:\r\n     *\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=260825\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=262313\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=267582\r\n     */\r\n    public void testCompleteAssignmentWithBacktracking() throws Exception {\r\n    \tnewBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo with org.eclipse.xtext.common.Terminals\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .append(\"MyRule : 'foo' name\").assertText(\r\n        \t\t\"\\\"Value\\\"\",\r\n        \t\t\"'Value'\",\r\n        \t\t\"(\",\r\n        \t\t\"*\",\r\n        \t\t\"+\",\r\n        \t\t\"+=\",\r\n        \t\t\";\",\r\n        \t\t\"=\",\r\n        \t\t\"?\",\r\n        \t\t\"?=\",\r\n        \t\t\"Feature\",\r\n        \t\t\"MyRule\",\r\n        \t\t\"{\")\r\n        .appendNl(\";\")\r\n        .append(\"terminal Other_Id\").assertText(\":\",\"returns\");\r\n\r\n    }","id":38135,"modified_method":"/**\r\n     * regression test for:\r\n     *\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=260825\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=262313\r\n     * https://bugs.eclipse.org/bugs/show_bug.cgi?id=267582\r\n     */\r\n    public void testCompleteAssignmentWithBacktracking() throws Exception {\r\n    \tnewBuilder(setup.getXtextGrammarTestSetup())\r\n        .appendNl(\"grammar foo with org.eclipse.xtext.common.Terminals\")\r\n        .appendNl(\"generate foo \\\"foo\\\"\")\r\n        .append(\"MyRule : 'foo' name\").assertText(\r\n        \t\t\"\\\"Value\\\"\",\r\n        \t\t\"(\",\r\n        \t\t\"*\",\r\n        \t\t\"+\",\r\n        \t\t\"+=\",\r\n        \t\t\";\",\r\n        \t\t\"=\",\r\n        \t\t\"?\",\r\n        \t\t\"?=\",\r\n        \t\t\"Feature\",\r\n        \t\t\"MyRule\",\r\n        \t\t\"{\")\r\n        .appendNl(\";\")\r\n        .append(\"terminal Other_Id\").assertText(\":\",\"returns\");\r\n\r\n    }","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertCount(1)\r\n\t\t\t.append(\"spielplatz \").assertCount(1)\r\n\t\t\t.append(\"1 \").assertCount(3)\r\n\t\t\t.append(\"\\\"JUNIT\\\" \").assertCount(1)\r\n\t\t\t.append(\"{ \").assertCount(5)\r\n\t\t\t.append(\"kind \").assertCount(1)\r\n\t\t\t.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").assertCount(2)\r\n\t\t\t.append(\"e1 \").assertCount(2)\r\n\t\t\t.append(\"e2\").assertCount(2);\r\n\t}","id":38136,"modified_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\tnewBuilder(setup.getRefGrammarSetup()).assertCount(1)\r\n\t\t\t.append(\"spielplatz \").assertCount(1)\r\n\t\t\t.append(\"1 \").assertCount(2)\r\n\t\t\t.append(\"\\\"JUNIT\\\" \").assertCount(1)\r\n\t\t\t.append(\"{ \").assertCount(5)\r\n\t\t\t.append(\"kind \").assertCount(1)\r\n\t\t\t.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").assertCount(2)\r\n\t\t\t.append(\"e1 \").assertCount(2)\r\n\t\t\t.append(\"e2\").assertCount(2);\r\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(EObject element, String name, String prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(name, name, getImage(element), prefix, contentAssistContext);\n\t}","id":38137,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(EObject element, String name, String displayName, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(name, displayName, getImage(element), contentAssistContext);\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(IScopedElement element, String prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(element.element(), element.name(), prefix, contentAssistContext);\n\t}","id":38138,"modified_method":"/**\n\t * @see #createCompletionProposal(AbstractElement, String, IContentAssistContext, Image)\n\t */\n\tprotected ICompletionProposal createCompletionProposal(IScopedElement element, String prefix, ContentAssistContext contentAssistContext) {\n\t\treturn createCompletionProposal(element.element(), element.name(), element.name(), prefix, contentAssistContext);\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"public ContentAssistProcessorTestBuilder assertTextAtCursorPosition(int cursorPosition, String... expectedText)\n\t\t\tthrows Exception {\n\n\t\tString currentModelToParse = getModel();\n\n\t\tICompletionProposal[] computeCompletionProposals = computeCompletionProposals(currentModelToParse,\n\t\t\t\tcursorPosition);\n\n\t\tif (computeCompletionProposals == null)\n\t\t\tcomputeCompletionProposals = new ICompletionProposal[0];\n\n\t\tString expectation = Strings.concat(\", \", Arrays.asList(expectedText));\n\t\tAssert.assertEquals(\"expect \" + expectedText.length + \" CompletionProposal item for model '\"\n\t\t\t\t+ currentModelToParse + \"': expectation was:\\n\" + expectation\n\t\t\t\t+ \"\\nbut actual was:\\n\" + Strings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\texpectedText.length, computeCompletionProposals.length);\n\n\t\t\n\t\tfor (int i = 0; i < computeCompletionProposals.length; i++) {\n\t\t\tICompletionProposal completionProposal = computeCompletionProposals[i];\n\t\t\tAssert.assertTrue(\"expect completionProposal text '\" + expectation + \"', but got \" +\n\t\t\t\t\tStrings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\t\tArrays.asList(expectedText).contains(completionProposal.getDisplayString()));\n\t\t}\n\n\t\treturn this;\n\t}","id":38139,"modified_method":"public ContentAssistProcessorTestBuilder assertTextAtCursorPosition(int cursorPosition, String... expectedText)\n\t\t\tthrows Exception {\n\n\t\tString currentModelToParse = getModel();\n\n\t\tICompletionProposal[] computeCompletionProposals = computeCompletionProposals(currentModelToParse,\n\t\t\t\tcursorPosition);\n\n\t\tif (computeCompletionProposals == null)\n\t\t\tcomputeCompletionProposals = new ICompletionProposal[0];\n\n\t\tString expectation = Strings.concat(\", \", Arrays.asList(expectedText));\n\t\tAssert.assertEquals(\"expect \" + expectedText.length + \" CompletionProposal item for model '\"\n\t\t\t\t+ currentModelToParse + \"': expectation was:\\n\" + expectation\n\t\t\t\t+ \"\\nbut actual was:\\n\" + Strings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\texpectedText.length, computeCompletionProposals.length);\n\n\t\t\n\t\tfor (int i = 0; i < computeCompletionProposals.length; i++) {\n\t\t\tICompletionProposal completionProposal = computeCompletionProposals[i];\n\t\t\tString proposedText = completionProposal.getDisplayString();\n\t\t\tif (completionProposal instanceof ConfigurableCompletionProposal)\n\t\t\t\tproposedText = ((ConfigurableCompletionProposal) completionProposal).getReplacementString();\n\t\t\tAssert.assertTrue(\"expect completionProposal text '\" + expectation + \"', but got \" +\n\t\t\t\t\tStrings.concat(\", \", toString(computeCompletionProposals)),\n\t\t\t\t\tArrays.asList(expectedText).contains(proposedText));\n\t\t}\n\n\t\treturn this;\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"private List<String> toString(ICompletionProposal[] proposals) {\n\t\tif (proposals == null)\n\t\t\treturn Collections.emptyList();\n\t\tList<String> res = new ArrayList<String>(proposals.length);\n\t\tfor (ICompletionProposal proposal : proposals) {\n\t\t\tres.add(proposal.getDisplayString());\n\t\t}\n\t\treturn res;\n\t}","id":38140,"modified_method":"private List<String> toString(ICompletionProposal[] proposals) {\n\t\tif (proposals == null)\n\t\t\treturn Collections.emptyList();\n\t\tList<String> res = new ArrayList<String>(proposals.length);\n\t\tfor (ICompletionProposal proposal : proposals) {\n\t\t\tString proposedText = proposal.getDisplayString();\n\t\t\tif (proposal instanceof ConfigurableCompletionProposal)\n\t\t\t\tproposedText = ((ConfigurableCompletionProposal) proposal).getReplacementString();\n\t\t\tres.add(proposedText);\n\t\t}\n\t\treturn res;\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"private void createStringProposal(ContentAssistContext context, ICompletionProposalAcceptor acceptor,\n\t\t\tString feature, char delim) {\n\t\tICompletionProposal proposal = createCompletionProposal(delim + feature + delim, context);\n\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n\t\t\tConfigurableCompletionProposal configurable = (ConfigurableCompletionProposal) proposal;\n\t\t\tconfigurable.setSelectionStart(configurable.getReplacementOffset() + 1);\n\t\t\tconfigurable.setSelectionLength(feature.length());\n\t\t\tconfigurable.setAutoInsertable(false);\n\t\t\tconfigurable.setSimpleLinkedMode(context.getViewer(), delim, '\\t');\n\t\t}\n\t\tacceptor.accept(proposal);\n\t}","id":38141,"modified_method":"private void createStringProposal(ContentAssistContext context, ICompletionProposalAcceptor acceptor,\n\t\t\tString feature, RuleCall ruleCall) {\n\t\tString proposalText = feature != null ? feature : Strings.toFirstUpper(ruleCall.getRule().getName().toLowerCase());\n\t\tproposalText = valueConverter.toString(proposalText, ruleCall.getRule().getName());\n\t\tString displayText = proposalText;\n\t\tif (feature != null)\n\t\t\tdisplayText = displayText + \" - \" + ruleCall.getRule().getName();\n\t\tICompletionProposal proposal = createCompletionProposal(proposalText, displayText, null, context);\n\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n\t\t\tConfigurableCompletionProposal configurable = (ConfigurableCompletionProposal) proposal;\n\t\t\tconfigurable.setSelectionStart(configurable.getReplacementOffset() + 1);\n\t\t\tconfigurable.setSelectionLength(proposalText.length() - 2);\n\t\t\tconfigurable.setAutoInsertable(false);\n\t\t\tconfigurable.setSimpleLinkedMode(context.getViewer(), proposalText.charAt(0), '\\t');\n\t\t\t\n\t\t}\n\t\tacceptor.accept(proposal);\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void complete_ID(EObject model, RuleCall ruleCall, ContentAssistContext context,\n\t\t\tICompletionProposalAcceptor acceptor) {\n\t\tif (doCreateIdProposals()) {\n\t\t\tString feature = getAssignedFeature(ruleCall);\n\t\t\tICompletionProposal proposal = createCompletionProposal(feature, context);\n\t\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n\t\t\t\tConfigurableCompletionProposal configurable = (ConfigurableCompletionProposal) proposal;\n\t\t\t\tconfigurable.setSelectionStart(configurable.getReplacementOffset());\n\t\t\t\tconfigurable.setSelectionLength(feature.length());\n\t\t\t\tconfigurable.setAutoInsertable(false);\n\t\t\t\tconfigurable.setSimpleLinkedMode(context.getViewer(), '\\t', ' ');\n\t\t\t}\n\t\t\tacceptor.accept(proposal);\n\t\t}\n\t}","id":38142,"modified_method":"@Override\n\tpublic void complete_ID(EObject model, RuleCall ruleCall, ContentAssistContext context,\n\t\t\tICompletionProposalAcceptor acceptor) {\n\t\tif (doCreateIdProposals()) {\n\t\t\tString feature = getAssignedFeature(ruleCall);\n\t\t\tString proposalText = feature != null ? feature : Strings.toFirstUpper(ruleCall.getRule().getName().toLowerCase());\n\t\t\tString displayText = proposalText;\n\t\t\tif (feature != null)\n\t\t\t\tdisplayText = proposalText + \" - \" + ruleCall.getRule().getName();\n\t\t\tproposalText = valueConverter.toString(proposalText, ruleCall.getRule().getName());\n\t\t\tICompletionProposal proposal = createCompletionProposal(proposalText, displayText, null, context);\n\t\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n\t\t\t\tConfigurableCompletionProposal configurable = (ConfigurableCompletionProposal) proposal;\n\t\t\t\tconfigurable.setSelectionStart(configurable.getReplacementOffset());\n\t\t\t\tconfigurable.setSelectionLength(proposalText.length());\n\t\t\t\tconfigurable.setAutoInsertable(false);\n\t\t\t\tconfigurable.setSimpleLinkedMode(context.getViewer(), '\\t', ' ');\n\t\t\t}\n\t\t\tacceptor.accept(proposal);\n\t\t}\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void complete_STRING(EObject model, RuleCall ruleCall, ContentAssistContext context,\n\t\t\tICompletionProposalAcceptor acceptor) {\n\t\tif (doCreateStringProposals()) {\n\t\t\tString feature = getAssignedFeature(ruleCall);\n\t\t\tcreateStringProposal(context, acceptor, feature, '\"');\n\t\t\tcreateStringProposal(context, acceptor, feature, '\\'');\n\t\t}\n\t}","id":38143,"modified_method":"@Override\n\tpublic void complete_STRING(EObject model, RuleCall ruleCall, ContentAssistContext context,\n\t\t\tICompletionProposalAcceptor acceptor) {\n\t\tif (doCreateStringProposals()) {\n\t\t\tString feature = getAssignedFeature(ruleCall);\n\t\t\tcreateStringProposal(context, acceptor, feature, ruleCall);\n\t\t}\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"private String getAssignedFeature(RuleCall call) {\n\t\tAssignment ass = GrammarUtil.containingAssignment(call);\n\t\tif (ass != null) {\n\t\t\tString result = ass.getFeature();\n\t\t\tif (result.equals(result.toLowerCase()))\n\t\t\t\tresult = Strings.toFirstUpper(result);\n\t\t\treturn result;\n\t\t}\n\t\treturn Strings.toFirstUpper(call.getRule().getName().toLowerCase());\n\t}","id":38144,"modified_method":"private String getAssignedFeature(RuleCall call) {\n\t\tAssignment ass = GrammarUtil.containingAssignment(call);\n\t\tif (ass != null) {\n\t\t\tString result = ass.getFeature();\n\t\t\tif (result.equals(result.toLowerCase()))\n\t\t\t\tresult = Strings.toFirstUpper(result);\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void complete_INT(EObject model, RuleCall ruleCall, ContentAssistContext context,\n\t\t\tICompletionProposalAcceptor acceptor) {\n\t\tString feature = getAssignedFeature(ruleCall);\n\t\tif (doCreateIntProposals()) {\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"0\");\n\t\t\tcreateIntProposal(context, acceptor, feature, \"1\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"2\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"5\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"10\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"50\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"100\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"1000\");\n\t\t}\n\t}","id":38145,"modified_method":"@Override\n\tpublic void complete_INT(EObject model, RuleCall ruleCall, ContentAssistContext context,\n\t\t\tICompletionProposalAcceptor acceptor) {\n\t\tString feature = getAssignedFeature(ruleCall);\n\t\tif (doCreateIntProposals()) {\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"0\");\n\t\t\tcreateIntProposal(context, acceptor, ruleCall, feature, 1);\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"2\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"5\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"10\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"50\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"100\");\n//\t\t\tcreateIntProposal(context, acceptor, feature, \"1000\");\n\t\t}\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"private void createIntProposal(ContentAssistContext context, ICompletionProposalAcceptor acceptor, String feature,\n\t\t\tString i) {\n\t\tICompletionProposal proposal = createCompletionProposal(i, i + \" - \" + feature, null, context);\n\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n\t\t\tConfigurableCompletionProposal configurable = (ConfigurableCompletionProposal) proposal;\n\t\t\tconfigurable.setSelectionStart(configurable.getReplacementOffset());\n\t\t\tconfigurable.setSelectionLength(i.length());\n\t\t\tconfigurable.setAutoInsertable(false);\n\t\t\tconfigurable.setSimpleLinkedMode(context.getViewer(), '\\t', ' ');\n\t\t}\n\t\tacceptor.accept(proposal);\n\t}","id":38146,"modified_method":"private void createIntProposal(ContentAssistContext context, ICompletionProposalAcceptor acceptor,\n\t\t\tRuleCall ruleCall, String feature,\tint i) {\n\t\tString proposalText = valueConverter.toString(i, ruleCall.getRule().getName());\n\t\tString displayText = proposalText + \" - \" + ruleCall.getRule().getName();\n\t\tif (feature != null)\n\t\t\tdisplayText = proposalText + \" - \" + feature;\n\t\tICompletionProposal proposal = createCompletionProposal(proposalText, displayText, null, context);\n\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n\t\t\tConfigurableCompletionProposal configurable = (ConfigurableCompletionProposal) proposal;\n\t\t\tconfigurable.setSelectionStart(configurable.getReplacementOffset());\n\t\t\tconfigurable.setSelectionLength(proposalText.length());\n\t\t\tconfigurable.setAutoInsertable(false);\n\t\t\tconfigurable.setSimpleLinkedMode(context.getViewer(), '\\t', ' ');\n\t\t}\n\t\tacceptor.accept(proposal);\n\t}","commit_id":"1b15909e7e769919ab259b376817e14a5ad53ff2","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public void indexArtifact(BlackboardArtifact artifact) throws TskCoreException {\n        if (artifact == null)\n            return;\n        \n        Case currentCase = Case.getCurrentCase();\n        if (currentCase == null)\n            return;\n        \n        SleuthkitCase sleuthkitCase = currentCase.getSleuthkitCase();\n        if (sleuthkitCase == null)\n            return;\n        \n        AbstractFile abstractFile = sleuthkitCase.getAbstractFileById(artifact.getObjectID());\n        if (abstractFile == null)\n            return;\n        \n        Content dataSource = abstractFile.getDataSource();\n        if (dataSource == null)\n            return;\n        \n        // Concatenate the string values of all attributes into a single \n        // \"content\" string to be indexed.\n        String artifactContents = \"\";\n        \n        for (BlackboardAttribute attribute : artifact.getAttributes()) {\n            artifactContents += attribute.getDisplayString();\n            artifactContents += \" \";\n        }\n        \n        if (artifactContents.isEmpty())\n            return;\n        \n        // To play by the rules of the existing text markup implementations,\n        // we need to (a) index the artifact contents in a \"chunk\" and \n        // (b) create a separate index entry for the base artifact.\n        // We distinguish artifact content from file content by applying a \n        // mask to the artifact id to make its value > 0x8000000000000000 (i.e. negative).\n\n        // First, create an index entry for the base artifact.\n        HashMap<String, String> solrFields = new HashMap<>();\n        String documentId = Long.toString(0x8000000000000000L + artifact.getArtifactID());\n\n        solrFields.put(Server.Schema.ID.toString(), documentId);\n        \n        // Set the IMAGE_ID field.\n        solrFields.put(Server.Schema.IMAGE_ID.toString(), Long.toString(dataSource.getId()));\n\n        try {\n            Ingester.getDefault().ingest(new StringStream(\"\"), solrFields, 0);\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n\n        // Next create the index entry for the document content.\n        // The content gets added to a single chunk. We may need to add chunking\n        // support later.\n        long chunkId = 1;\n\n        documentId += \"_\" + Long.toString(chunkId);\n        solrFields.replace(Server.Schema.ID.toString(), documentId);\n        \n        StringStream contentStream = new StringStream(artifactContents);\n        \n        try {\n            Ingester.getDefault().ingest(contentStream, solrFields, contentStream.getSize());\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n    }","id":38147,"modified_method":"@Override\n    public void indexArtifact(BlackboardArtifact artifact) throws TskCoreException {\n        if (artifact == null)\n            return;\n        \n        Case currentCase = Case.getCurrentCase();\n        if (currentCase == null)\n            return;\n        \n        SleuthkitCase sleuthkitCase = currentCase.getSleuthkitCase();\n        if (sleuthkitCase == null)\n            return;\n        \n        AbstractFile abstractFile = sleuthkitCase.getAbstractFileById(artifact.getObjectID());\n        if (abstractFile == null)\n            return;\n        \n        Content dataSource = abstractFile.getDataSource();\n        if (dataSource == null)\n            return;\n        \n        // Concatenate the string values of all attributes into a single \n        // \"content\" string to be indexed.\n        StringBuilder artifactContents = new StringBuilder();\n        \n        for (BlackboardAttribute attribute : artifact.getAttributes()) {\n            artifactContents.append(attribute.getAttributeTypeDisplayName());\n            artifactContents.append(\" : \");\n\n            // This is ugly since it will need to updated any time a new\n            // TSK_DATETIME_* attribute is added. A slightly less ugly \n            // alternative would be to assume that all date time attributes\n            // will have a name of the form \"TSK_DATETIME*\" and check\n            // attribute.getAttributeTypeName().startsWith(\"TSK_DATETIME*\".\n            // The major problem with that approach is that it would require\n            // a round trip to the database to get the type name string.\n            // We have also discussed modifying BlackboardAttribute.getDisplayString()\n            // to magically format datetime attributes but that is complicated by\n            // the fact that BlackboardAttribute exists in Sleuthkit data model\n            // while the utility to determine the timezone to use is in ContentUtils\n            // in the Autopsy datamodel.\n            if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_MODIFIED.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_RCVD.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_SENT.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID()\n                    || attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID()) {\n                artifactContents.append(ContentUtils.getStringTime(attribute.getValueLong(), abstractFile));\n            }\n            else\n                artifactContents.append(attribute.getDisplayString());\n            artifactContents.append(System.lineSeparator());\n        }\n        \n        if (artifactContents.length() == 0)\n            return;\n        \n        // To play by the rules of the existing text markup implementations,\n        // we need to (a) index the artifact contents in a \"chunk\" and \n        // (b) create a separate index entry for the base artifact.\n        // We distinguish artifact content from file content by applying a \n        // mask to the artifact id to make its value > 0x8000000000000000 (i.e. negative).\n\n        // First, create an index entry for the base artifact.\n        HashMap<String, String> solrFields = new HashMap<>();\n        String documentId = Long.toString(0x8000000000000000L + artifact.getArtifactID());\n\n        solrFields.put(Server.Schema.ID.toString(), documentId);\n        \n        // Set the IMAGE_ID field.\n        solrFields.put(Server.Schema.IMAGE_ID.toString(), Long.toString(dataSource.getId()));\n\n        try {\n            Ingester.getDefault().ingest(new StringStream(\"\"), solrFields, 0);\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n\n        // Next create the index entry for the document content.\n        // The content gets added to a single chunk. We may need to add chunking\n        // support later.\n        long chunkId = 1;\n\n        documentId += \"_\" + Long.toString(chunkId);\n        solrFields.replace(Server.Schema.ID.toString(), documentId);\n        \n        StringStream contentStream = new StringStream(artifactContents.toString());\n        \n        try {\n            Ingester.getDefault().ingest(contentStream, solrFields, contentStream.getSize());\n        }\n        catch (Ingester.IngesterException ex) {\n        }\n    }","commit_id":"2aeab974404380606c7e63fb10af4c64ca2c9edb","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (MergeLayoutPrototypesThreadLocal.isInProgress()) {\n\t\t\treturn methodInvocation.proceed();\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tString methodName = method.getName();\n\n\t\tObject[] arguments = methodInvocation.getArguments();\n\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\tif (methodName.equals(\"getLayout\") &&\n\t\t\t(Arrays.equals(parameterTypes, _TYPES_L) ||\n\t\t\t Arrays.equals(parameterTypes, _TYPES_L_B_L))) {\n\n\t\t\tLayout layout = (Layout)methodInvocation.proceed();\n\n\t\t\tif (Validator.isNull(layout.getLayoutPrototypeUuid()) &&\n\t\t\t\tValidator.isNull(layout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\treturn layout;\n\t\t\t}\n\n\t\t\tGroup group = layout.getGroup();\n\t\t\tLayoutSet layoutSet = layout.getLayoutSet();\n\n\t\t\ttry {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(true);\n\t\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\t\tSitesUtil.mergeLayoutPrototypeLayout(group, layout);\n\n\t\t\t\tif (Validator.isNotNull(\n\t\t\t\t\t\tlayout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\t\tif (!SitesUtil.isLayoutModifiedSinceLastMerge(layout)) {\n\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(false);\n\t\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t\t}\n\t\t}\n\t\telse if (methodName.equals(\"getLayouts\") &&\n\t\t\t\t (Arrays.equals(parameterTypes, _TYPES_L_B_L) ||\n\t\t\t\t  Arrays.equals(parameterTypes, _TYPES_L_B_L_B_I_I))) {\n\n\t\t\tlong groupId = (Long)arguments[0];\n\t\t\tboolean privateLayout = (Boolean)arguments[1];\n\t\t\tlong parentLayoutId = (Long)arguments[2];\n\n\t\t\ttry {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\tgroupId, privateLayout);\n\n\t\t\t\ttry {\n\t\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(true);\n\t\t\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\t\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\tgroupId, privateLayout);\n\n\t\t\t\t\tif (layouts.isEmpty()) {\n\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tboolean modified = false;\n\n\t\t\t\t\t\tfor (Layout layout : layouts) {\n\t\t\t\t\t\t\tif (SitesUtil.isLayoutModifiedSinceLastMerge(\n\t\t\t\t\t\t\t\t\tlayout)) {\n\n\t\t\t\t\t\t\t\tmodified = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!modified) {\n\t\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(false);\n\t\t\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t\t\t}\n\n\t\t\t\tList<Layout> layouts = (List<Layout>)methodInvocation.proceed();\n\n\t\t\t\tif (PropsValues.\n\t\t\t\t\t\tUSER_GROUPS_COPY_LAYOUTS_TO_USER_PERSONAL_SITE) {\n\n\t\t\t\t\treturn layouts;\n\t\t\t\t}\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\t_virtualLayoutTargetGroupId.set(group.getGroupId());\n\n\t\t\t\t\tif (parentLayoutId ==\n\t\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\n\t\t\t\t\t\treturn addUserGroupLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet, layouts, parentLayoutId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn addChildUserGroupLayouts(group, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (group.isUserGroup() &&\n\t\t\t\t\t\t (parentLayoutId !=\n\t\t\t\t\t\t\t LayoutConstants.DEFAULT_PARENT_LAYOUT_ID)) {\n\n\t\t\t\t\tlong targetGroupId = _virtualLayoutTargetGroupId.get();\n\n\t\t\t\t\tif (targetGroupId != GroupConstants.DEFAULT_LIVE_GROUP_ID) {\n\t\t\t\t\t\tGroup targetGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\t\t\ttargetGroupId);\n\n\t\t\t\t\t\treturn addChildUserGroupLayouts(targetGroup, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn layouts;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\treturn methodInvocation.proceed();\n\t}","id":38148,"modified_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (MergeLayoutPrototypesThreadLocal.isInProgress() ||\n\t\t\tMergeLayoutPrototypesThreadLocal.isCompleted()) {\n\n\t\t\treturn methodInvocation.proceed();\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tString methodName = method.getName();\n\n\t\tObject[] arguments = methodInvocation.getArguments();\n\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\tif (methodName.equals(\"getLayout\") &&\n\t\t\t(Arrays.equals(parameterTypes, _TYPES_L) ||\n\t\t\t Arrays.equals(parameterTypes, _TYPES_L_B_L))) {\n\n\t\t\tLayout layout = (Layout)methodInvocation.proceed();\n\n\t\t\tif (Validator.isNull(layout.getLayoutPrototypeUuid()) &&\n\t\t\t\tValidator.isNull(layout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\treturn layout;\n\t\t\t}\n\n\t\t\tGroup group = layout.getGroup();\n\t\t\tLayoutSet layoutSet = layout.getLayoutSet();\n\n\t\t\ttry {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(true);\n\t\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\t\tSitesUtil.mergeLayoutPrototypeLayout(group, layout);\n\n\t\t\t\tif (Validator.isNotNull(\n\t\t\t\t\t\tlayout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\t\tif (!SitesUtil.isLayoutModifiedSinceLastMerge(layout)) {\n\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(false);\n\t\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t\t}\n\t\t}\n\t\telse if (methodName.equals(\"getLayouts\") &&\n\t\t\t\t (Arrays.equals(parameterTypes, _TYPES_L_B_L) ||\n\t\t\t\t  Arrays.equals(parameterTypes, _TYPES_L_B_L_B_I_I))) {\n\n\t\t\tlong groupId = (Long)arguments[0];\n\t\t\tboolean privateLayout = (Boolean)arguments[1];\n\t\t\tlong parentLayoutId = (Long)arguments[2];\n\n\t\t\ttry {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\tgroupId, privateLayout);\n\n\t\t\t\tdoMergeLayoutSetPrototypeLayouts(\n\t\t\t\t\tgroup, layoutSet, privateLayout, workflowEnabled);\n\n\t\t\t\tList<Layout> layouts = (List<Layout>)methodInvocation.proceed();\n\n\t\t\t\tif (PropsValues.\n\t\t\t\t\t\tUSER_GROUPS_COPY_LAYOUTS_TO_USER_PERSONAL_SITE) {\n\n\t\t\t\t\treturn layouts;\n\t\t\t\t}\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\t_virtualLayoutTargetGroupId.set(group.getGroupId());\n\n\t\t\t\t\tif (parentLayoutId ==\n\t\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\n\t\t\t\t\t\treturn addUserGroupLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet, layouts, parentLayoutId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn addChildUserGroupLayouts(group, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (group.isUserGroup() &&\n\t\t\t\t\t\t (parentLayoutId !=\n\t\t\t\t\t\t\t LayoutConstants.DEFAULT_PARENT_LAYOUT_ID)) {\n\n\t\t\t\t\tlong targetGroupId = _virtualLayoutTargetGroupId.get();\n\n\t\t\t\t\tif (targetGroupId != GroupConstants.DEFAULT_LIVE_GROUP_ID) {\n\t\t\t\t\t\tGroup targetGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\t\t\ttargetGroupId);\n\n\t\t\t\t\t\treturn addChildUserGroupLayouts(targetGroup, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn layouts;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\treturn methodInvocation.proceed();\n\t}","commit_id":"d2d43943a93ea21b5d4cb095b6208f72962d458a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setInProgress(boolean inProgress) {\n\t\t_inProgress.set(inProgress);\n\t}","id":38149,"modified_method":"public static void setInProgress(boolean inProgress) {\n\t\tif (_inProgress.get() && !inProgress) {\n\t\t\t_completed.set(true);\n\t\t}\n\n\t\t_inProgress.set(inProgress);\n\n\t}","commit_id":"d2d43943a93ea21b5d4cb095b6208f72962d458a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void mergeLayoutSetPrototypeLayouts(\n\t\t\tGroup group, LayoutSet layoutSet)\n\t\tthrows Exception {\n\n\t\tif (!layoutSet.isLayoutSetPrototypeLinkActive() ||\n\t\t\tgroup.isLayoutPrototype() || group.isLayoutSetPrototype()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tUnicodeProperties settingsProperties =\n\t\t\tlayoutSet.getSettingsProperties();\n\n\t\tlong lastMergeTime = GetterUtil.getLong(\n\t\t\tsettingsProperties.getProperty(LAST_MERGE_TIME));\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.\n\t\t\t\tgetLayoutSetPrototypeByUuidAndCompanyId(\n\t\t\t\t\tlayoutSet.getLayoutSetPrototypeUuid(),\n\t\t\t\t\tlayoutSet.getCompanyId());\n\n\t\tDate modifiedDate = layoutSetPrototype.getModifiedDate();\n\n\t\tif (lastMergeTime >= modifiedDate.getTime()) {\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSetPrototypeLayoutSet =\n\t\t\tlayoutSetPrototype.getLayoutSet();\n\n\t\tUnicodeProperties layoutSetPrototypeSettingsProperties =\n\t\t\tlayoutSetPrototypeLayoutSet.getSettingsProperties();\n\n\t\tint mergeFailCount = GetterUtil.getInteger(\n\t\t\tlayoutSetPrototypeSettingsProperties.getProperty(MERGE_FAIL_COUNT));\n\n\t\tif (mergeFailCount >\n\t\t\tPropsValues.LAYOUT_SET_PROTOTYPE_MERGE_FAIL_THRESHOLD) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"Merge not performed because the fail threshold \");\n\t\t\t\tsb.append(\"was reached for layoutSetPrototypeId \");\n\t\t\t\tsb.append(layoutSetPrototype.getLayoutSetPrototypeId());\n\t\t\t\tsb.append(\" and layoutId \");\n\t\t\t\tsb.append(layoutSetPrototypeLayoutSet.getLayoutSetId());\n\t\t\t\tsb.append(\". Update the count in the database to try again.\");\n\n\t\t\t\t_log.warn(sb.toString());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tString owner = PortalUUIDUtil.generate();\n\n\t\ttry {\n\t\t\tLock lock = LockLocalServiceUtil.lock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\n\t\t\t// Double deep check\n\n\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\tDate createDate = lock.getCreateDate();\n\n\t\t\t\tif ((System.currentTimeMillis() - createDate.getTime()) >=\n\t\t\t\t\tPropsValues.LAYOUT_SET_PROTOTYPE_MERGE_LOCK_MAX_TIME) {\n\n\t\t\t\t\t// Acquire lock if the lock is older than the lock max time\n\n\t\t\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()),\n\t\t\t\t\t\tlock.getOwner(), owner, false);\n\n\t\t\t\t\t// Check if acquiring the lock succeeded or if another\n\t\t\t\t\t// process has the lock\n\n\t\t\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tboolean importData = true;\n\n\t\t\tlong lastResetTime = GetterUtil.getLong(\n\t\t\t\tsettingsProperties.getProperty(LAST_RESET_TIME));\n\n\t\t\tif ((lastMergeTime > 0) || (lastResetTime > 0)) {\n\t\t\t\timportData = false;\n\t\t\t}\n\n\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\tgetLayoutSetPrototypesParameters(importData);\n\n\t\t\timportLayoutSetPrototype(\n\t\t\t\tlayoutSetPrototype, layoutSet.getGroupId(),\n\t\t\t\tlayoutSet.isPrivateLayout(), parameterMap, importData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tlayoutSetPrototypeSettingsProperties.setProperty(\n\t\t\t\tMERGE_FAIL_COUNT, String.valueOf(++mergeFailCount));\n\n\t\t\t// Invoke updateImpl so that we do not trigger the listeners\n\n\t\t\tLayoutSetUtil.updateImpl(layoutSetPrototypeLayoutSet);\n\t\t}\n\t\tfinally {\n\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\t\t}\n\t}","id":38150,"modified_method":"public static void mergeLayoutSetPrototypeLayouts(\n\t\t\tGroup group, LayoutSet layoutSet)\n\t\tthrows Exception {\n\n\t\tif (!isLayoutSetMergeable(group, layoutSet)) {\n\t\t\treturn;\n\t\t}\n\n\t\tUnicodeProperties settingsProperties =\n\t\t\tlayoutSet.getSettingsProperties();\n\n\t\tlong lastMergeTime = GetterUtil.getLong(\n\t\t\tsettingsProperties.getProperty(LAST_MERGE_TIME));\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.\n\t\t\t\tgetLayoutSetPrototypeByUuidAndCompanyId(\n\t\t\t\t\tlayoutSet.getLayoutSetPrototypeUuid(),\n\t\t\t\t\tlayoutSet.getCompanyId());\n\n\t\tLayoutSet layoutSetPrototypeLayoutSet =\n\t\t\tlayoutSetPrototype.getLayoutSet();\n\n\t\tUnicodeProperties layoutSetPrototypeSettingsProperties =\n\t\t\tlayoutSetPrototypeLayoutSet.getSettingsProperties();\n\n\t\tint mergeFailCount = GetterUtil.getInteger(\n\t\t\tlayoutSetPrototypeSettingsProperties.getProperty(MERGE_FAIL_COUNT));\n\n\t\tString owner = PortalUUIDUtil.generate();\n\n\t\ttry {\n\t\t\tLock lock = LockLocalServiceUtil.lock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\n\t\t\t// Double deep check\n\n\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\tDate createDate = lock.getCreateDate();\n\n\t\t\t\tif ((System.currentTimeMillis() - createDate.getTime()) >=\n\t\t\t\t\tPropsValues.LAYOUT_SET_PROTOTYPE_MERGE_LOCK_MAX_TIME) {\n\n\t\t\t\t\t// Acquire lock if the lock is older than the lock max time\n\n\t\t\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()),\n\t\t\t\t\t\tlock.getOwner(), owner, false);\n\n\t\t\t\t\t// Check if acquiring the lock succeeded or if another\n\t\t\t\t\t// process has the lock\n\n\t\t\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tboolean importData = true;\n\n\t\t\tlong lastResetTime = GetterUtil.getLong(\n\t\t\t\tsettingsProperties.getProperty(LAST_RESET_TIME));\n\n\t\t\tif ((lastMergeTime > 0) || (lastResetTime > 0)) {\n\t\t\t\timportData = false;\n\t\t\t}\n\n\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\tgetLayoutSetPrototypesParameters(importData);\n\n\t\t\timportLayoutSetPrototype(\n\t\t\t\tlayoutSetPrototype, layoutSet.getGroupId(),\n\t\t\t\tlayoutSet.isPrivateLayout(), parameterMap, importData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tlayoutSetPrototypeSettingsProperties.setProperty(\n\t\t\t\tMERGE_FAIL_COUNT, String.valueOf(++mergeFailCount));\n\n\t\t\t// Invoke updateImpl so that we do not trigger the listeners\n\n\t\t\tLayoutSetUtil.updateImpl(layoutSetPrototypeLayoutSet);\n\t\t}\n\t\tfinally {\n\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\t\t}\n\t}","commit_id":"d2d43943a93ea21b5d4cb095b6208f72962d458a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n    * Handles anything thrown while running the process.\n    * This callback will be executed and the process will stop afterwards.\n    *\n    * @param handle The failing process' handle.\n    * @param t The throwable that was detected\n    */\n   protected void handleThrowable( H handle, Throwable t )\n   {\n      handle.setError(t);\n   }","id":38151,"modified_method":"/**\n    * Handles anything thrown while running the process.\n    * This callback will be executed and the process will stop afterwards.\n    *\n    * @param handle The failing process' handle.\n    * @param t The throwable that was detected\n    */\n   protected void handleThrowable( H handle, Throwable t )\n   {\n      log.error(\"Exception with long running process[\" + t.getClass().getName() + \"]: \" + t.getMessage());\n      handle.setError(t);\n   }","commit_id":"36479a5892054727be753d50e387873f60a71fc4","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (MergeLayoutPrototypesThreadLocal.isInProgress() ||\n\t\t\tMergeLayoutPrototypesThreadLocal.isCompleted()) {\n\n\t\t\treturn methodInvocation.proceed();\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tString methodName = method.getName();\n\n\t\tObject[] arguments = methodInvocation.getArguments();\n\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\tif (methodName.equals(\"getLayout\") &&\n\t\t\t(Arrays.equals(parameterTypes, _TYPES_L) ||\n\t\t\t Arrays.equals(parameterTypes, _TYPES_L_B_L))) {\n\n\t\t\tLayout layout = (Layout)methodInvocation.proceed();\n\n\t\t\tif (Validator.isNull(layout.getLayoutPrototypeUuid()) &&\n\t\t\t\tValidator.isNull(layout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\treturn layout;\n\t\t\t}\n\n\t\t\tGroup group = layout.getGroup();\n\t\t\tLayoutSet layoutSet = layout.getLayoutSet();\n\n\t\t\ttry {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(true);\n\t\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\t\tSitesUtil.mergeLayoutPrototypeLayout(group, layout);\n\n\t\t\t\tif (Validator.isNotNull(\n\t\t\t\t\t\tlayout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\t\tif (!SitesUtil.isLayoutModifiedSinceLastMerge(layout)) {\n\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(false);\n\t\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t\t}\n\t\t}\n\t\telse if (methodName.equals(\"getLayouts\") &&\n\t\t\t\t (Arrays.equals(parameterTypes, _TYPES_L_B_L) ||\n\t\t\t\t  Arrays.equals(parameterTypes, _TYPES_L_B_L_B_I_I))) {\n\n\t\t\tlong groupId = (Long)arguments[0];\n\t\t\tboolean privateLayout = (Boolean)arguments[1];\n\t\t\tlong parentLayoutId = (Long)arguments[2];\n\n\t\t\ttry {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\tgroupId, privateLayout);\n\n\t\t\t\tdoMergeLayoutSetPrototypeLayouts(\n\t\t\t\t\tgroup, layoutSet, privateLayout, workflowEnabled);\n\n\t\t\t\tList<Layout> layouts = (List<Layout>)methodInvocation.proceed();\n\n\t\t\t\tif (PropsValues.\n\t\t\t\t\t\tUSER_GROUPS_COPY_LAYOUTS_TO_USER_PERSONAL_SITE) {\n\n\t\t\t\t\treturn layouts;\n\t\t\t\t}\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\t_virtualLayoutTargetGroupId.set(group.getGroupId());\n\n\t\t\t\t\tif (parentLayoutId ==\n\t\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\n\t\t\t\t\t\treturn addUserGroupLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet, layouts, parentLayoutId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn addChildUserGroupLayouts(group, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (group.isUserGroup() &&\n\t\t\t\t\t\t (parentLayoutId !=\n\t\t\t\t\t\t\t LayoutConstants.DEFAULT_PARENT_LAYOUT_ID)) {\n\n\t\t\t\t\tlong targetGroupId = _virtualLayoutTargetGroupId.get();\n\n\t\t\t\t\tif (targetGroupId != GroupConstants.DEFAULT_LIVE_GROUP_ID) {\n\t\t\t\t\t\tGroup targetGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\t\t\ttargetGroupId);\n\n\t\t\t\t\t\treturn addChildUserGroupLayouts(targetGroup, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn layouts;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\treturn methodInvocation.proceed();\n\t}","id":38152,"modified_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (MergeLayoutPrototypesThreadLocal.isInProgress()) {\n\t\t\treturn methodInvocation.proceed();\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tString methodName = method.getName();\n\n\t\tObject[] arguments = methodInvocation.getArguments();\n\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\tboolean workflowEnabled = WorkflowThreadLocal.isEnabled();\n\n\t\tif (methodName.equals(\"getLayout\") &&\n\t\t\t(Arrays.equals(parameterTypes, _TYPES_L) ||\n\t\t\t Arrays.equals(parameterTypes, _TYPES_L_B_L))) {\n\n\t\t\tLayout layout = (Layout)methodInvocation.proceed();\n\n\t\t\tif (Validator.isNull(layout.getLayoutPrototypeUuid()) &&\n\t\t\t\tValidator.isNull(layout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\treturn layout;\n\t\t\t}\n\n\t\t\tGroup group = layout.getGroup();\n\t\t\tLayoutSet layoutSet = layout.getLayoutSet();\n\n\t\t\ttry {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(true);\n\t\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\t\tSitesUtil.mergeLayoutPrototypeLayout(group, layout);\n\n\t\t\t\tif (Validator.isNotNull(\n\t\t\t\t\t\tlayout.getSourcePrototypeLayoutUuid())) {\n\n\t\t\t\t\tif (!SitesUtil.isLayoutModifiedSinceLastMerge(layout)) {\n\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(false);\n\t\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t\t}\n\t\t}\n\t\telse if (methodName.equals(\"getLayouts\") &&\n\t\t\t\t (Arrays.equals(parameterTypes, _TYPES_L_B_L) ||\n\t\t\t\t  Arrays.equals(parameterTypes, _TYPES_L_B_L_B_I_I))) {\n\n\t\t\tlong groupId = (Long)arguments[0];\n\t\t\tboolean privateLayout = (Boolean)arguments[1];\n\t\t\tlong parentLayoutId = (Long)arguments[2];\n\n\t\t\ttry {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\tgroupId, privateLayout);\n\n\t\t\t\ttry {\n\t\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(true);\n\t\t\t\t\tWorkflowThreadLocal.setEnabled(false);\n\n\t\t\t\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\tgroupId, privateLayout);\n\n\t\t\t\t\tif (layouts.isEmpty()) {\n\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tboolean modified = false;\n\n\t\t\t\t\t\tfor (Layout layout : layouts) {\n\t\t\t\t\t\t\tif (SitesUtil.isLayoutModifiedSinceLastMerge(\n\t\t\t\t\t\t\t\t\tlayout)) {\n\n\t\t\t\t\t\t\t\tmodified = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!modified) {\n\t\t\t\t\t\t\tSitesUtil.mergeLayoutSetPrototypeLayouts(\n\t\t\t\t\t\t\t\tgroup, layoutSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tMergeLayoutPrototypesThreadLocal.setInProgress(false);\n\t\t\t\t\tWorkflowThreadLocal.setEnabled(workflowEnabled);\n\t\t\t\t}\n\n\t\t\t\tList<Layout> layouts = (List<Layout>)methodInvocation.proceed();\n\n\t\t\t\tif (PropsValues.\n\t\t\t\t\t\tUSER_GROUPS_COPY_LAYOUTS_TO_USER_PERSONAL_SITE) {\n\n\t\t\t\t\treturn layouts;\n\t\t\t\t}\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\t_virtualLayoutTargetGroupId.set(group.getGroupId());\n\n\t\t\t\t\tif (parentLayoutId ==\n\t\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\n\t\t\t\t\t\treturn addUserGroupLayouts(\n\t\t\t\t\t\t\tgroup, layoutSet, layouts, parentLayoutId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn addChildUserGroupLayouts(group, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (group.isUserGroup() &&\n\t\t\t\t\t\t (parentLayoutId !=\n\t\t\t\t\t\t\t LayoutConstants.DEFAULT_PARENT_LAYOUT_ID)) {\n\n\t\t\t\t\tlong targetGroupId = _virtualLayoutTargetGroupId.get();\n\n\t\t\t\t\tif (targetGroupId != GroupConstants.DEFAULT_LIVE_GROUP_ID) {\n\t\t\t\t\t\tGroup targetGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\t\t\ttargetGroupId);\n\n\t\t\t\t\t\treturn addChildUserGroupLayouts(targetGroup, layouts);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn layouts;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\treturn methodInvocation.proceed();\n\t}","commit_id":"f01291dd0d5ebb92ecbdd8399b5a284515110adf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setInProgress(boolean inProgress) {\n\t\tif (_inProgress.get() && !inProgress) {\n\t\t\t_completed.set(true);\n\t\t}\n\n\t\t_inProgress.set(inProgress);\n\n\t}","id":38153,"modified_method":"public static void setInProgress(boolean inProgress) {\n\t\t_inProgress.set(inProgress);\n\t}","commit_id":"f01291dd0d5ebb92ecbdd8399b5a284515110adf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void mergeLayoutSetPrototypeLayouts(\n\t\t\tGroup group, LayoutSet layoutSet)\n\t\tthrows Exception {\n\n\t\tif (!isLayoutSetMergeable(group, layoutSet)) {\n\t\t\treturn;\n\t\t}\n\n\t\tUnicodeProperties settingsProperties =\n\t\t\tlayoutSet.getSettingsProperties();\n\n\t\tlong lastMergeTime = GetterUtil.getLong(\n\t\t\tsettingsProperties.getProperty(LAST_MERGE_TIME));\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.\n\t\t\t\tgetLayoutSetPrototypeByUuidAndCompanyId(\n\t\t\t\t\tlayoutSet.getLayoutSetPrototypeUuid(),\n\t\t\t\t\tlayoutSet.getCompanyId());\n\n\t\tLayoutSet layoutSetPrototypeLayoutSet =\n\t\t\tlayoutSetPrototype.getLayoutSet();\n\n\t\tUnicodeProperties layoutSetPrototypeSettingsProperties =\n\t\t\tlayoutSetPrototypeLayoutSet.getSettingsProperties();\n\n\t\tint mergeFailCount = GetterUtil.getInteger(\n\t\t\tlayoutSetPrototypeSettingsProperties.getProperty(MERGE_FAIL_COUNT));\n\n\t\tString owner = PortalUUIDUtil.generate();\n\n\t\ttry {\n\t\t\tLock lock = LockLocalServiceUtil.lock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\n\t\t\t// Double deep check\n\n\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\tDate createDate = lock.getCreateDate();\n\n\t\t\t\tif ((System.currentTimeMillis() - createDate.getTime()) >=\n\t\t\t\t\tPropsValues.LAYOUT_SET_PROTOTYPE_MERGE_LOCK_MAX_TIME) {\n\n\t\t\t\t\t// Acquire lock if the lock is older than the lock max time\n\n\t\t\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()),\n\t\t\t\t\t\tlock.getOwner(), owner, false);\n\n\t\t\t\t\t// Check if acquiring the lock succeeded or if another\n\t\t\t\t\t// process has the lock\n\n\t\t\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tboolean importData = true;\n\n\t\t\tlong lastResetTime = GetterUtil.getLong(\n\t\t\t\tsettingsProperties.getProperty(LAST_RESET_TIME));\n\n\t\t\tif ((lastMergeTime > 0) || (lastResetTime > 0)) {\n\t\t\t\timportData = false;\n\t\t\t}\n\n\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\tgetLayoutSetPrototypesParameters(importData);\n\n\t\t\timportLayoutSetPrototype(\n\t\t\t\tlayoutSetPrototype, layoutSet.getGroupId(),\n\t\t\t\tlayoutSet.isPrivateLayout(), parameterMap, importData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tlayoutSetPrototypeSettingsProperties.setProperty(\n\t\t\t\tMERGE_FAIL_COUNT, String.valueOf(++mergeFailCount));\n\n\t\t\t// Invoke updateImpl so that we do not trigger the listeners\n\n\t\t\tLayoutSetUtil.updateImpl(layoutSetPrototypeLayoutSet);\n\t\t}\n\t\tfinally {\n\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\t\t}\n\t}","id":38154,"modified_method":"public static void mergeLayoutSetPrototypeLayouts(\n\t\t\tGroup group, LayoutSet layoutSet)\n\t\tthrows Exception {\n\n\t\tif (!layoutSet.isLayoutSetPrototypeLinkActive() ||\n\t\t\tgroup.isLayoutPrototype() || group.isLayoutSetPrototype()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tUnicodeProperties settingsProperties =\n\t\t\tlayoutSet.getSettingsProperties();\n\n\t\tlong lastMergeTime = GetterUtil.getLong(\n\t\t\tsettingsProperties.getProperty(LAST_MERGE_TIME));\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.\n\t\t\t\tgetLayoutSetPrototypeByUuidAndCompanyId(\n\t\t\t\t\tlayoutSet.getLayoutSetPrototypeUuid(),\n\t\t\t\t\tlayoutSet.getCompanyId());\n\n\t\tDate modifiedDate = layoutSetPrototype.getModifiedDate();\n\n\t\tif (lastMergeTime >= modifiedDate.getTime()) {\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSetPrototypeLayoutSet =\n\t\t\tlayoutSetPrototype.getLayoutSet();\n\n\t\tUnicodeProperties layoutSetPrototypeSettingsProperties =\n\t\t\tlayoutSetPrototypeLayoutSet.getSettingsProperties();\n\n\t\tint mergeFailCount = GetterUtil.getInteger(\n\t\t\tlayoutSetPrototypeSettingsProperties.getProperty(MERGE_FAIL_COUNT));\n\n\t\tif (mergeFailCount >\n\t\t\tPropsValues.LAYOUT_SET_PROTOTYPE_MERGE_FAIL_THRESHOLD) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"Merge not performed because the fail threshold \");\n\t\t\t\tsb.append(\"was reached for layoutSetPrototypeId \");\n\t\t\t\tsb.append(layoutSetPrototype.getLayoutSetPrototypeId());\n\t\t\t\tsb.append(\" and layoutId \");\n\t\t\t\tsb.append(layoutSetPrototypeLayoutSet.getLayoutSetId());\n\t\t\t\tsb.append(\". Update the count in the database to try again.\");\n\n\t\t\t\t_log.warn(sb.toString());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tString owner = PortalUUIDUtil.generate();\n\n\t\ttry {\n\t\t\tLock lock = LockLocalServiceUtil.lock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\n\t\t\t// Double deep check\n\n\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\tDate createDate = lock.getCreateDate();\n\n\t\t\t\tif ((System.currentTimeMillis() - createDate.getTime()) >=\n\t\t\t\t\tPropsValues.LAYOUT_SET_PROTOTYPE_MERGE_LOCK_MAX_TIME) {\n\n\t\t\t\t\t// Acquire lock if the lock is older than the lock max time\n\n\t\t\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()),\n\t\t\t\t\t\tlock.getOwner(), owner, false);\n\n\t\t\t\t\t// Check if acquiring the lock succeeded or if another\n\t\t\t\t\t// process has the lock\n\n\t\t\t\t\tif (!owner.equals(lock.getOwner())) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tboolean importData = true;\n\n\t\t\tlong lastResetTime = GetterUtil.getLong(\n\t\t\t\tsettingsProperties.getProperty(LAST_RESET_TIME));\n\n\t\t\tif ((lastMergeTime > 0) || (lastResetTime > 0)) {\n\t\t\t\timportData = false;\n\t\t\t}\n\n\t\t\tMap<String, String[]> parameterMap =\n\t\t\t\tgetLayoutSetPrototypesParameters(importData);\n\n\t\t\timportLayoutSetPrototype(\n\t\t\t\tlayoutSetPrototype, layoutSet.getGroupId(),\n\t\t\t\tlayoutSet.isPrivateLayout(), parameterMap, importData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tlayoutSetPrototypeSettingsProperties.setProperty(\n\t\t\t\tMERGE_FAIL_COUNT, String.valueOf(++mergeFailCount));\n\n\t\t\t// Invoke updateImpl so that we do not trigger the listeners\n\n\t\t\tLayoutSetUtil.updateImpl(layoutSetPrototypeLayoutSet);\n\t\t}\n\t\tfinally {\n\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\tLayoutLocalServiceVirtualLayoutsAdvice.class.getName(),\n\t\t\t\tString.valueOf(layoutSet.getLayoutSetId()), owner, false);\n\t\t}\n\t}","commit_id":"f01291dd0d5ebb92ecbdd8399b5a284515110adf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void customizeCellRenderer(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;\n        if (node.getUserObject() instanceof TestNodeDescriptor) {\n            TestProxy proxy = ((TestNodeDescriptor) node.getUserObject()).getElement();\n            if (node == tree.getModel().getRoot()) {\n                TreeRootNode root = (TreeRootNode) proxy;\n                if (node.getChildCount() == 0) {\n                    if (root.isInProgress()) {\n                        setIcon(Animator.getCurrentFrame());\n                        append(\"Instantiating tests... \", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                    } else {\n                        setIcon(PoolOfTestIcons.PASSED_ICON);\n                        append(\"All Tests Passed.\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                    }\n                } else {\n                    setIcon(root.isInProgress() ? Animator.getCurrentFrame() : getIcon(proxy));\n                    append(root.isInProgress() ? \"Running tests...\" : \"Test Results\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                }\n\n                DebuggerSession debug = consoleProperties.getDebuggerSession();\n                if (debug != null && debug.isPaused()) {\n                    setIcon(Animator.PAUSED_ICON);\n                }\n            } else {\n                if (proxy.getResultMessage() != null) {\n                    TestResultMessage result = proxy.getResultMessage();\n                    append(node.getChildCount() == 0 ? result.toDisplayString() : result.getTestClass(),\n                           SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                } else {\n                    append(proxy.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                }\n                setIcon(proxy.isInProgress() ? Animator.getCurrentFrame() : getIcon(proxy));\n            }\n        } else {\n            setIcon(Animator.getCurrentFrame());\n            append(node.getUserObject() != null ? node.getUserObject().toString() : \"null\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n    }","id":38155,"modified_method":"@Override\n    public void customizeCellRenderer(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;\n        if (node.getUserObject() instanceof TestNodeDescriptor) {\n            TestProxy proxy = ((TestNodeDescriptor) node.getUserObject()).getElement();\n            if (node == tree.getModel().getRoot()) {\n                TreeRootNode root = (TreeRootNode) proxy;\n                if (node.getChildCount() == 0) {\n                    if ((root.isStarted() && root.isInProgress()) || (root.isInProgress() && !root.isStarted())) {\n                        setIcon(PoolOfTestIcons.NOT_RAN);\n                        append(\"Instantiating tests... \", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                    } else if (root.isStarted() && !root.isInProgress()) {\n                        setIcon(PoolOfTestIcons.PASSED_ICON);\n                        append(\"All Tests Passed.\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                    } else {\n                        setIcon(PoolOfTestIcons.NOT_RAN);\n                        append(\"No Test Results.\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                    }\n\n                } else {\n                    setIcon(root.isInProgress() ? Animator.getCurrentFrame() : getIcon(proxy));\n                    append(root.isInProgress() ? \"Running tests...\" : \"Test Results\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                }\n\n                DebuggerSession debug = consoleProperties.getDebuggerSession();\n                if (debug != null && debug.isPaused()) {\n                    setIcon(Animator.PAUSED_ICON);\n                }\n            } else {\n                if (proxy.getResultMessage() != null) {\n                    TestResultMessage result = proxy.getResultMessage();\n                    append(node.getChildCount() == 0 ? result.toDisplayString() : result.getTestClass(),\n                           SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                } else {\n                    append(proxy.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n                }\n                setIcon(proxy.isInProgress() ? Animator.getCurrentFrame() : getIcon(proxy));\n            }\n        } else {\n            setIcon(Animator.getCurrentFrame());\n            append(node.getUserObject() != null ? node.getUserObject().toString() : \"null\", SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n    }","commit_id":"b270165b3424fd44b26ff89a883fd9e54618364b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TestNGResults(final Project project, final TestNGConsoleView console) {\n        this.project = project;\n        model = new TestNGResultsTableModel();\n        this.consoleProperties = console.getConsoleProperties();\n        resultsTable = new TableView(model);\n        rootNode = new TreeRootNode();\n        final TestTreeStructure structure = new TestTreeStructure(project, rootNode);\n        tree.attachToModel(project, structure.getRootElement(), console.getConsoleProperties());\n        treeBuilder = new TestTreeBuilder(tree, structure);\n        toolbarPanel.setLayout(new BorderLayout());\n        toolbar = new ToolbarPanel(console.getConsoleProperties(), this);\n        toolbarPanel.add(toolbar);\n        animator = new Animator(treeBuilder);\n        openSourceListener = new OpenSourceSelectionListener(structure, console);\n        tree.getSelectionModel().addTreeSelectionListener(openSourceListener);\n        progress.setColor(ColorProgressBar.GREEN);\n        GuiUtils.replaceJSplitPaneWithIDEASplitter(splitPane);\n        splitPane.setDividerLocation(200);\n    }","id":38156,"modified_method":"public TestNGResults(final Project project, final TestNGConsoleView console) {\n        this.project = project;\n        model = new TestNGResultsTableModel();\n        this.consoleProperties = console.getConsoleProperties();\n        resultsTable = new TableView(model);\n        rootNode = new TreeRootNode();\n        final TestTreeStructure structure = new TestTreeStructure(project, rootNode);\n        tree.attachToModel(project, structure.getRootElement(), console.getConsoleProperties());\n        treeBuilder = new TestTreeBuilder(tree, structure);\n        toolbarPanel.setLayout(new BorderLayout());\n        toolbar = new ToolbarPanel(console.getConsoleProperties(), this);\n        toolbarPanel.add(toolbar);\n        animator = new Animator(treeBuilder);\n        openSourceListener = new OpenSourceSelectionListener(structure, console);\n        tree.getSelectionModel().addTreeSelectionListener(openSourceListener);\n        progress.setColor(ColorProgressBar.GREEN);\n        splitPane.setDividerLocation(0.2);\n        GuiUtils.replaceJSplitPaneWithIDEASplitter(splitPane);\n    }","commit_id":"b270165b3424fd44b26ff89a883fd9e54618364b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void start() {\n        this.start = System.currentTimeMillis();\n        tree.getSelectionModel().setSelectionPath(new TreePath(treeBuilder.getNodeForElement(rootNode)));\n        rootNode.setInProgress(true);\n    }","id":38157,"modified_method":"public void start() {\n        this.start = System.currentTimeMillis();\n        tree.getSelectionModel().setSelectionPath(new TreePath(treeBuilder.getNodeForElement(rootNode)));\n        rootNode.setInProgress(true);\n        rootNode.setStarted(true);\n    }","commit_id":"b270165b3424fd44b26ff89a883fd9e54618364b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeRootNode() {\n    }","id":38158,"modified_method":"public TreeRootNode() {\n        inProgress = false;\n        isStarted = false;\n    }","commit_id":"b270165b3424fd44b26ff89a883fd9e54618364b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processAction(\n\t\t\tPortletConfig config, ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tboolean onlyShowListed = ParamUtil.getBoolean(req, \"showListed\");\n\t\tint scope = ParamUtil.getInteger(req, \"scope\");\n\t\tString targetPortletId = ParamUtil.getString(req, \"targetPortletId\");\n\t\tString type = ParamUtil.getString(req, \"type\");\n\n\t\tString portletResource = ParamUtil.getString(req, \"portletResource\");\n\n\t\tPortletPreferences prefs =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\treq, portletResource, true, true);\n\n\t\tprefs.setValue(\"show-listed\", String.valueOf(onlyShowListed));\n\t\tprefs.setValue(\"scope\", String.valueOf(scope));\n\t\tprefs.setValue(\"target-portlet-id\", targetPortletId);\n\t\tprefs.setValue(\"type\", type);\n\n\t\tprefs.store();\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doConfigure\");\n\t}","id":38159,"modified_method":"public void processAction(\n\t\t\tPortletConfig config, ActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString type = ParamUtil.getString(req, \"type\");\n\n\t\tString portletResource = ParamUtil.getString(req, \"portletResource\");\n\n\t\tPortletPreferences prefs =\n\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\treq, portletResource, true, true);\n\n\t\tprefs.setValue(\"type\", type);\n\n\t\tprefs.store();\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doConfigure\");\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void recordHits(Hits hits, long groupId, boolean privateLayout)\n\t\tthrows Exception  {\n\n\t\tsetSearcher(((HitsImpl)hits).getSearcher());\n\n\t\t// This can later be optimized according to LEP-915.\n\n\t\tList docs = new ArrayList(hits.getLength());\n\t\tList scores = new ArrayList(hits.getLength());\n\n\t\tfor (int i = 0; i < hits.getLength(); i++) {\n\t\t\tDocument doc = hits.doc(i);\n\n\t\t\tString articleId = doc.get(\"articleId\");\n\t\t\tlong articleGroupId = GetterUtil.getLong(doc.get(\n\t\t\t\t\tLuceneFields.GROUP_ID));\n\n\t\t\tif (isShowListed()) {\n\t\t\t\tif (JournalContentSearchLocalServiceUtil.getLayoutIdsCount(\n\t\t\t\t\tgroupId, privateLayout, articleId) > 0) {\n\t\t\t\n\t\t\t\t\tdocs.add(hits.doc(i));\n\t\t\t\t\tscores.add(new Float(hits.score(i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (getScope() == ENTERPRISE_SCOPE) {\n\t\t\t\tdocs.add(hits.doc(i));\n\t\t\t\tscores.add(new Float(hits.score(i)));\n\t\t\t}\n\t\t\telse if (getScope() == COMMUNITY_SCOPE && \n\t\t\t\t\tarticleGroupId == groupId) {\n\t\t\t\tdocs.add(hits.doc(i));\n\t\t\t\tscores.add(new Float(hits.score(i)));\n\t\t\t}\n\t\t}\n\n\t\tsetLength(docs.size());\n\t\tsetDocs((Document[])docs.toArray(new Document[0]));\n\t\tsetScores((Float[])scores.toArray(new Float[0]));\n\n\t\tsetSearchTime(\n\t\t\t(float)(System.currentTimeMillis() - getStart()) / Time.SECOND);\n\t}","id":38160,"modified_method":"public void recordHits(Hits hits, long groupId, boolean privateLayout)\n\t\tthrows Exception  {\n\n\t\tsetSearcher(((HitsImpl)hits).getSearcher());\n\n\t\t// This can later be optimized according to LEP-915.\n\n\t\tList docs = new ArrayList(hits.getLength());\n\t\tList scores = new ArrayList(hits.getLength());\n\n\t\tfor (int i = 0; i < hits.getLength(); i++) {\n\t\t\tDocument doc = hits.doc(i);\n\n\t\t\tString articleId = doc.get(\"articleId\");\n\n\t\t\tif (JournalContentSearchLocalServiceUtil.getLayoutIdsCount(\n\t\t\t\t\tgroupId, privateLayout, articleId) > 0) {\n\n\t\t\t\tdocs.add(hits.doc(i));\n\t\t\t\tscores.add(new Float(hits.score(i)));\n\t\t\t}\n\t\t}\n\n\t\tsetLength(docs.size());\n\t\tsetDocs((Document[])docs.toArray(new Document[0]));\n\t\tsetScores((Float[])scores.toArray(new Float[0]));\n\n\t\tsetSearchTime(\n\t\t\t(float)(System.currentTimeMillis() - getStart()) / Time.SECOND);\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ContentHits() {\n\t\tsuper();\n\t\t\n\t\t_showListed = true;\n\t\t_scope = COMMUNITY_SCOPE;\n\t}","id":38161,"modified_method":"public ContentHits() {\n\t\tsuper();\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalArticle updateArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tboolean incrementVersion, String title, String description,\n\t\t\tString content, String type, String structureId, String templateId,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, boolean indexable, Map images,\n\t\t\tString articleURL, PortletPreferences prefs, String[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\t\tDate now = new Date();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tvalidate(groupId, title, content, type, structureId, templateId);\n\n\t\tJournalArticle oldArticle = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tJournalArticle article = null;\n\n\t\tif (incrementVersion) {\n\t\t\tdouble latestVersion = getLatestVersion(groupId, articleId);\n\n\t\t\tlong id = CounterLocalServiceUtil.increment();\n\n\t\t\tarticle = JournalArticleUtil.create(id);\n\n\t\t\tarticle.setResourcePrimKey(oldArticle.getResourcePrimKey());\n\t\t\tarticle.setGroupId(oldArticle.getGroupId());\n\t\t\tarticle.setCompanyId(user.getCompanyId());\n\t\t\tarticle.setUserId(user.getUserId());\n\t\t\tarticle.setUserName(user.getFullName());\n\t\t\tarticle.setCreateDate(now);\n\t\t\tarticle.setArticleId(articleId);\n\t\t\tarticle.setVersion(MathUtil.format(latestVersion + 0.1, 1, 1));\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t}\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, article.getVersion(), incrementVersion, content,\n\t\t\tstructureId, images);\n\n\t\tboolean approved = oldArticle.isApproved();\n\n\t\tif (incrementVersion) {\n\t\t\tapproved = false;\n\t\t}\n\n\t\tarticle.setModifiedDate(now);\n\t\tarticle.setTitle(title);\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\t\tarticle.setApproved(approved);\n\n\t\tif ((expirationDate == null) || expirationDate.after(now)) {\n\t\t\tarticle.setExpired(false);\n\t\t}\n\t\telse {\n\t\t\tarticle.setExpired(true);\n\t\t}\n\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\t\tarticle.setIndexable(indexable);\n\n\t\tJournalArticleUtil.update(article);\n\n\t\t// Tags\n\n\t\tupdateTagsAsset(userId, article, tagsEntries);\n\n\t\t// Email\n\n\t\tif (incrementVersion) {\n\t\t\tsendEmail(article, articleURL, prefs, \"requested\");\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isIndexable()) {\n\t\t\t\tif (article.isApproved()) {\n\t\t\t\t\tIndexer.updateArticle(\n\t\t\t\t\t\tarticle.getCompanyId(), article.getGroupId(),\n\t\t\t\t\t\tarticle.getArticleId(), article.getVersion(),\n\t\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\t\tarticle.getDisplayDate());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tIndexer.deleteArticle(\n\t\t\t\t\t\t\tarticle.getCompanyId(),\n\t\t\t\t\t\t\tarticle.getArticleId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + article.getPrimaryKey(), ioe);\n\t\t}\n\n\t\treturn article;\n\t}","id":38162,"modified_method":"public JournalArticle updateArticle(\n\t\t\tlong userId, long groupId, String articleId, double version,\n\t\t\tboolean incrementVersion, String title, String description,\n\t\t\tString content, String type, String structureId, String templateId,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, int expirationDateMonth,\n\t\t\tint expirationDateDay, int expirationDateYear,\n\t\t\tint expirationDateHour, int expirationDateMinute,\n\t\t\tboolean neverExpire, int reviewDateMonth, int reviewDateDay,\n\t\t\tint reviewDateYear, int reviewDateHour, int reviewDateMinute,\n\t\t\tboolean neverReview, boolean indexable, Map images,\n\t\t\tString articleURL, PortletPreferences prefs, String[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\t\tarticleId = articleId.trim().toUpperCase();\n\t\tDate now = new Date();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\tdisplayDateHour, displayDateMinute, user.getTimeZone(),\n\t\t\tnew ArticleDisplayDateException());\n\n\t\tDate expirationDate = null;\n\n\t\tif (!neverExpire) {\n\t\t\texpirationDate = PortalUtil.getDate(\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleExpirationDateException());\n\t\t}\n\n\t\tDate reviewDate = null;\n\n\t\tif (!neverReview) {\n\t\t\treviewDate = PortalUtil.getDate(\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, user.getTimeZone(),\n\t\t\t\tnew ArticleReviewDateException());\n\t\t}\n\n\t\tvalidate(groupId, title, content, type, structureId, templateId);\n\n\t\tJournalArticle oldArticle = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tJournalArticle article = null;\n\n\t\tif (incrementVersion) {\n\t\t\tdouble latestVersion = getLatestVersion(groupId, articleId);\n\n\t\t\tlong id = CounterLocalServiceUtil.increment();\n\n\t\t\tarticle = JournalArticleUtil.create(id);\n\n\t\t\tarticle.setResourcePrimKey(oldArticle.getResourcePrimKey());\n\t\t\tarticle.setGroupId(oldArticle.getGroupId());\n\t\t\tarticle.setCompanyId(user.getCompanyId());\n\t\t\tarticle.setUserId(user.getUserId());\n\t\t\tarticle.setUserName(user.getFullName());\n\t\t\tarticle.setCreateDate(now);\n\t\t\tarticle.setArticleId(articleId);\n\t\t\tarticle.setVersion(MathUtil.format(latestVersion + 0.1, 1, 1));\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t}\n\n\t\tcontent = format(\n\t\t\tgroupId, articleId, article.getVersion(), incrementVersion, content,\n\t\t\tstructureId, images);\n\n\t\tboolean approved = oldArticle.isApproved();\n\n\t\tif (incrementVersion) {\n\t\t\tapproved = false;\n\t\t}\n\n\t\tarticle.setModifiedDate(now);\n\t\tarticle.setTitle(title);\n\t\tarticle.setDescription(description);\n\t\tarticle.setContent(content);\n\t\tarticle.setType(type);\n\t\tarticle.setStructureId(structureId);\n\t\tarticle.setTemplateId(templateId);\n\t\tarticle.setDisplayDate(displayDate);\n\t\tarticle.setApproved(approved);\n\n\t\tif ((expirationDate == null) || expirationDate.after(now)) {\n\t\t\tarticle.setExpired(false);\n\t\t}\n\t\telse {\n\t\t\tarticle.setExpired(true);\n\t\t}\n\n\t\tarticle.setExpirationDate(expirationDate);\n\t\tarticle.setReviewDate(reviewDate);\n\t\tarticle.setIndexable(indexable);\n\n\t\tJournalArticleUtil.update(article);\n\n\t\t// Tags\n\n\t\tupdateTagsAsset(userId, article, tagsEntries);\n\n\t\t// Email\n\n\t\tif (incrementVersion) {\n\t\t\tsendEmail(article, articleURL, prefs, \"requested\");\n\t\t}\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isApproved() && article.isIndexable()) {\n\t\t\t\tIndexer.updateArticle(\n\t\t\t\t\tarticle.getCompanyId(), article.getGroupId(),\n\t\t\t\t\tarticle.getArticleId(), article.getVersion(),\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(),\n\t\t\t\t\tarticle.getDisplayDate());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + article.getPrimaryKey(), ioe);\n\t\t}\n\n\t\treturn article;\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteArticle(\n\t\t\tJournalArticle article, String articleURL, PortletPreferences prefs)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isApproved() && article.isIndexable()) {\n\t\t\t\tIndexer.deleteArticle(\n\t\t\t\t\tarticle.getCompanyId(), article.getArticleId());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Deleting index \" + article.getPrimaryKey(), ioe);\n\t\t}\n\n\t\t// Email\n\n\t\tif ((prefs != null) && !article.isApproved() &&\n\t\t\tisLatestVersion(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion())) {\n\n\t\t\tsendEmail(article, articleURL, prefs, \"denied\");\n\t\t}\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.deleteAsset(\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey());\n\n\t\t// Ratings\n\n\t\tRatingsStatsLocalServiceUtil.deleteStats(\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey());\n\n\t\t// Message boards\n\n\t\tMBMessageLocalServiceUtil.deleteDiscussionMessages(\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey());\n\n\t\t// Content searches\n\n\t\tJournalContentSearchLocalServiceUtil.deleteArticleContentSearches(\n\t\t\tarticle.getGroupId(), article.getArticleId());\n\n\t\t// Images\n\n\t\tJournalArticleImageLocalServiceUtil.deleteImages(\n\t\t\tarticle.getGroupId(), article.getArticleId(), article.getVersion());\n\n\t\t// Resources\n\n\t\tif (JournalArticleUtil.countByG_A(\n\t\t\t\tarticle.getGroupId(), article.getArticleId()) == 1) {\n\n\t\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\t\tarticle.getCompanyId(), JournalArticle.class.getName(),\n\t\t\t\tResourceImpl.SCOPE_INDIVIDUAL, article.getResourcePrimKey());\n\t\t}\n\n\t\t// Resource\n\n\t\tif (JournalArticleUtil.countByG_A(\n\t\t\t\tarticle.getGroupId(), article.getArticleId()) == 1) {\n\n\t\t\ttry {\n\t\t\t\tJournalArticleResourceLocalServiceUtil.deleteArticleResource(\n\t\t\t\t\tarticle.getGroupId(), article.getArticleId());\n\t\t\t}\n\t\t\tcatch (NoSuchArticleResourceException nsare) {\n\t\t\t}\n\t\t}\n\n\t\t// Article\n\n\t\tJournalArticleUtil.remove(article.getPrimaryKey());\n\t}","id":38163,"modified_method":"public void deleteArticle(\n\t\t\tJournalArticle article, String articleURL, PortletPreferences prefs)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isApproved()) {\n\t\t\t\tIndexer.deleteArticle(\n\t\t\t\t\tarticle.getCompanyId(), article.getArticleId());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Deleting index \" + article.getPrimaryKey(), ioe);\n\t\t}\n\n\t\t// Email\n\n\t\tif ((prefs != null) && !article.isApproved() &&\n\t\t\tisLatestVersion(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion())) {\n\n\t\t\tsendEmail(article, articleURL, prefs, \"denied\");\n\t\t}\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.deleteAsset(\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey());\n\n\t\t// Ratings\n\n\t\tRatingsStatsLocalServiceUtil.deleteStats(\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey());\n\n\t\t// Message boards\n\n\t\tMBMessageLocalServiceUtil.deleteDiscussionMessages(\n\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey());\n\n\t\t// Content searches\n\n\t\tJournalContentSearchLocalServiceUtil.deleteArticleContentSearches(\n\t\t\tarticle.getGroupId(), article.getArticleId());\n\n\t\t// Images\n\n\t\tJournalArticleImageLocalServiceUtil.deleteImages(\n\t\t\tarticle.getGroupId(), article.getArticleId(), article.getVersion());\n\n\t\t// Resources\n\n\t\tif (JournalArticleUtil.countByG_A(\n\t\t\t\tarticle.getGroupId(), article.getArticleId()) == 1) {\n\n\t\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\t\tarticle.getCompanyId(), JournalArticle.class.getName(),\n\t\t\t\tResourceImpl.SCOPE_INDIVIDUAL, article.getResourcePrimKey());\n\t\t}\n\n\t\t// Resource\n\n\t\tif (JournalArticleUtil.countByG_A(\n\t\t\t\tarticle.getGroupId(), article.getArticleId()) == 1) {\n\n\t\t\ttry {\n\t\t\t\tJournalArticleResourceLocalServiceUtil.deleteArticleResource(\n\t\t\t\t\tarticle.getGroupId(), article.getArticleId());\n\t\t\t}\n\t\t\tcatch (NoSuchArticleResourceException nsare) {\n\t\t\t}\n\t\t}\n\n\t\t// Article\n\n\t\tJournalArticleUtil.remove(article.getPrimaryKey());\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public JournalArticleDisplay getArticleDisplay(\n\t\t\tlong groupId, String articleId, double version, String templateId,\n\t\t\tString languageId, ThemeDisplay themeDisplay, String xmlRequest)\n\t\tthrows PortalException, SystemException {\n\n\t\tString content = null;\n\n\t\tJournalArticle article = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tif (article.isExpired()) {\n\t\t\tDate expirationDate = article.getExpirationDate();\n\n\t\t\tif ((expirationDate != null) && expirationDate.before(new Date())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tif (article.getDisplayDate().after(now)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/*if (!article.isTemplateDriven()) {\n\t\t\treturn article.getContent();\n\t\t}*/\n\n\t\tMap tokens = JournalUtil.getTokens(groupId, themeDisplay);\n\n\t\ttokens.put(\n\t\t\t\"article_resource_pk\",\n\t\t\tString.valueOf(article.getResourcePrimKey()));\n\n\t\tString xml = article.getContent();\n\n\t\ttry {\n\t\t\tDocument doc = null;\n\n\t\t\tElement root = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\t\t\t\tSAXReader reader = new SAXReader();\n\n\t\t\t\tdoc = reader.read(new StringReader(xml));\n\n\t\t\t\troot = doc.getRootElement();\n\n\t\t\t\tif (Validator.isNotNull(xmlRequest)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocument request = reader.read(\n\t\t\t\t\t\t\tnew StringReader(xmlRequest));\n\n\t\t\t\t\t\troot.add(request.getRootElement().createCopy());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tJournalUtil.addAllReservedEls(root, tokens, article);\n\n\t\t\t\txml = JournalUtil.formatXML(doc);\n\t\t\t}\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\tthrow new SystemException(de);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Transforming \" + articleId + \" \" + version + \" \" +\n\t\t\t\t\t\tlanguageId);\n\t\t\t}\n\n\t\t\tString script = null;\n\t\t\tString langType = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\n\t\t\t\t// Try with specified template first. If a template is not\n\t\t\t\t// specified, use the default one. If the specified template\n\t\t\t\t// does not exit, use the default one. If the default one does\n\t\t\t\t// not exist, throw an exception.\n\n\t\t\t\tString defaultTemplateId = article.getTemplateId();\n\n\t\t\t\tif (Validator.isNull(templateId)) {\n\t\t\t\t\ttemplateId = defaultTemplateId;\n\t\t\t\t}\n\n\t\t\t\tJournalTemplate template = null;\n\n\t\t\t\ttry {\n\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\tgroupId, templateId);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\t\tif (!defaultTemplateId.equals(templateId)) {\n\t\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\t\tgroupId, defaultTemplateId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nste;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscript = template.getXsl();\n\t\t\t\tlangType = template.getLangType();\n\t\t\t}\n\n\t\t\tcontent = JournalUtil.transform(\n\t\t\t\ttokens, languageId, xml, script, langType);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\n\t\treturn new JournalArticleDisplayImpl(\n\t\t\tarticle.getId(), article.getResourcePrimKey(), article.getGroupId(),\n\t\t\tarticle.getUserId(), article.getArticleId(), article.getVersion(),\n\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\tarticle.getAvailableLocales(), content, article.getType(),\n\t\t\tarticle.getStructureId(), templateId);\n\t}","id":38164,"modified_method":"public JournalArticleDisplay getArticleDisplay(\n\t\t\tlong groupId, String articleId, double version, String templateId,\n\t\t\tString languageId, ThemeDisplay themeDisplay, String xmlRequest)\n\t\tthrows PortalException, SystemException {\n\n\t\tString content = null;\n\n\t\tJournalArticle article = JournalArticleUtil.findByG_A_V(\n\t\t\tgroupId, articleId, version);\n\n\t\tif (article.isExpired()) {\n\t\t\tDate expirationDate = article.getExpirationDate();\n\n\t\t\tif ((expirationDate != null) && expirationDate.before(new Date())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t/*if (!article.isTemplateDriven()) {\n\t\t\treturn article.getContent();\n\t\t}*/\n\n\t\tMap tokens = JournalUtil.getTokens(groupId, themeDisplay);\n\n\t\ttokens.put(\n\t\t\t\"article_resource_pk\",\n\t\t\tString.valueOf(article.getResourcePrimKey()));\n\n\t\tString xml = article.getContent();\n\n\t\ttry {\n\t\t\tDocument doc = null;\n\n\t\t\tElement root = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\t\t\t\tSAXReader reader = new SAXReader();\n\n\t\t\t\tdoc = reader.read(new StringReader(xml));\n\n\t\t\t\troot = doc.getRootElement();\n\n\t\t\t\tif (Validator.isNotNull(xmlRequest)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocument request = reader.read(\n\t\t\t\t\t\t\tnew StringReader(xmlRequest));\n\n\t\t\t\t\t\troot.add(request.getRootElement().createCopy());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tJournalUtil.addAllReservedEls(root, tokens, article);\n\n\t\t\t\txml = JournalUtil.formatXML(doc);\n\t\t\t}\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\tthrow new SystemException(de);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\ttry {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Transforming \" + articleId + \" \" + version + \" \" +\n\t\t\t\t\t\tlanguageId);\n\t\t\t}\n\n\t\t\tString script = null;\n\t\t\tString langType = null;\n\n\t\t\tif (article.isTemplateDriven()) {\n\n\t\t\t\t// Try with specified template first. If a template is not\n\t\t\t\t// specified, use the default one. If the specified template\n\t\t\t\t// does not exit, use the default one. If the default one does\n\t\t\t\t// not exist, throw an exception.\n\n\t\t\t\tString defaultTemplateId = article.getTemplateId();\n\n\t\t\t\tif (Validator.isNull(templateId)) {\n\t\t\t\t\ttemplateId = defaultTemplateId;\n\t\t\t\t}\n\n\t\t\t\tJournalTemplate template = null;\n\n\t\t\t\ttry {\n\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\tgroupId, templateId);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchTemplateException nste) {\n\t\t\t\t\tif (!defaultTemplateId.equals(templateId)) {\n\t\t\t\t\t\ttemplate = JournalTemplateUtil.findByG_T(\n\t\t\t\t\t\t\tgroupId, defaultTemplateId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nste;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscript = template.getXsl();\n\t\t\t\tlangType = template.getLangType();\n\t\t\t}\n\n\t\t\tcontent = JournalUtil.transform(\n\t\t\t\ttokens, languageId, xml, script, langType);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\n\t\treturn new JournalArticleDisplayImpl(\n\t\t\tarticle.getId(), article.getResourcePrimKey(), article.getGroupId(),\n\t\t\tarticle.getUserId(), article.getArticleId(), article.getVersion(),\n\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\tarticle.getAvailableLocales(), content, article.getType(),\n\t\t\tarticle.getStructureId(), templateId);\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void expireArticle(\n\t\t\tJournalArticle article, String articleURL, PortletPreferences prefs)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Email\n\n\t\tif ((prefs != null) && !article.isApproved() &&\n\t\t\tisLatestVersion(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion())) {\n\n\t\t\tsendEmail(article, articleURL, prefs, \"denied\");\n\t\t}\n\n\t\t// Article\n\n\t\tarticle.setExpirationDate(new Date());\n\n\t\tarticle.setApproved(false);\n\t\tarticle.setExpired(true);\n\n\t\tJournalArticleUtil.update(article);\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (article.isIndexable()) {\n\t\t\t\tIndexer.deleteArticle(\n\t\t\t\t\t\tarticle.getCompanyId(),\n\t\t\t\t\t\tarticle.getArticleId());\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Remove Indexing of \" + article.getPrimaryKey(), ioe);\n\t\t}\n\t}","id":38165,"modified_method":"public void expireArticle(\n\t\t\tJournalArticle article, String articleURL, PortletPreferences prefs)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Email\n\n\t\tif ((prefs != null) && !article.isApproved() &&\n\t\t\tisLatestVersion(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion())) {\n\n\t\t\tsendEmail(article, articleURL, prefs, \"denied\");\n\t\t}\n\n\t\t// Article\n\n\t\tarticle.setExpirationDate(new Date());\n\n\t\tarticle.setApproved(false);\n\t\tarticle.setExpired(true);\n\n\t\tJournalArticleUtil.update(article);\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void checkArticles() throws PortalException, SystemException {\n\t\tDate now = new Date();\n\n\t\tList articles = JournalArticleFinder.findByExpirationDate(\n\t\t\tBoolean.FALSE, now,\n\t\t\tnew Date(now.getTime() - CheckArticleJob.INTERVAL));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Expiring \" + articles.size() + \" articles\");\n\t\t}\n\n\t\tSet companies = new HashSet();\n\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tarticle.setApproved(false);\n\t\t\tarticle.setExpired(true);\n\n\t\t\tJournalArticleUtil.update(article);\n\n\t\t\tJournalContentUtil.clearCache(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getTemplateId());\n\n\t\t\t// Lucene\n\n\t\t\ttry {\n\t\t\t\tif (article.isIndexable()) {\n\t\t\t\t\tIndexer.deleteArticle(\n\t\t\t\t\t\t\tarticle.getCompanyId(),\n\t\t\t\t\t\t\tarticle.getArticleId());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(\"Remove Indexing of \" + article.getPrimaryKey(), ioe);\n\t\t\t}\n\n\t\t\tcompanies.add(new Long(article.getCompanyId()));\n\t\t}\n\n\t\tIterator itr = companies.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tlong companyId = ((Long)itr.next()).longValue();\n\n\t\t\tLayoutCacheUtil.clearCache(companyId);\n\t\t}\n\n\t\tarticles = JournalArticleFinder.findByReviewDate(\n\t\t\tnow, new Date(now.getTime() - CheckArticleJob.INTERVAL));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Sending review notifications for \" + articles.size() +\n\t\t\t\t\t\" articles\");\n\t\t}\n\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tDate reviewDate = article.getReviewDate();\n\n\t\t\tif (reviewDate != null) {\n\t\t\t\tlong diff = reviewDate.getTime() - now.getTime();\n\n\t\t\t\tif ((diff > 0) && (diff < CheckArticleJob.INTERVAL)) {\n\t\t\t\t\tString articleURL = StringPool.BLANK;\n\n\t\t\t\t\tlong ownerId = article.getGroupId();\n\t\t\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\t\t\tString portletId = PortletKeys.JOURNAL;\n\n\t\t\t\t\tPortletPreferences prefs =\n\t\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\t\t\tarticle.getCompanyId(), ownerId, ownerType, plid,\n\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\tsendEmail(article, articleURL, prefs, \"review\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":38166,"modified_method":"public void checkArticles() throws PortalException, SystemException {\n\t\tDate now = new Date();\n\n\t\tList articles = JournalArticleFinder.findByExpirationDate(\n\t\t\tBoolean.FALSE, now,\n\t\t\tnew Date(now.getTime() - CheckArticleJob.INTERVAL));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Expiring \" + articles.size() + \" articles\");\n\t\t}\n\n\t\tSet companies = new HashSet();\n\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tarticle.setApproved(false);\n\t\t\tarticle.setExpired(true);\n\n\t\t\tJournalArticleUtil.update(article);\n\n\t\t\tJournalContentUtil.clearCache(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getTemplateId());\n\n\t\t\tcompanies.add(new Long(article.getCompanyId()));\n\t\t}\n\n\t\tIterator itr = companies.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tlong companyId = ((Long)itr.next()).longValue();\n\n\t\t\tLayoutCacheUtil.clearCache(companyId);\n\t\t}\n\n\t\tarticles = JournalArticleFinder.findByReviewDate(\n\t\t\tnow, new Date(now.getTime() - CheckArticleJob.INTERVAL));\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Sending review notifications for \" + articles.size() +\n\t\t\t\t\t\" articles\");\n\t\t}\n\n\t\tfor (int i = 0; i < articles.size(); i++) {\n\t\t\tJournalArticle article = (JournalArticle)articles.get(i);\n\n\t\t\tDate reviewDate = article.getReviewDate();\n\n\t\t\tif (reviewDate != null) {\n\t\t\t\tlong diff = reviewDate.getTime() - now.getTime();\n\n\t\t\t\tif ((diff > 0) && (diff < CheckArticleJob.INTERVAL)) {\n\t\t\t\t\tString articleURL = StringPool.BLANK;\n\n\t\t\t\t\tlong ownerId = article.getGroupId();\n\t\t\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\t\t\tString portletId = PortletKeys.JOURNAL;\n\n\t\t\t\t\tPortletPreferences prefs =\n\t\t\t\t\t\tPortletPreferencesLocalServiceUtil.getPreferences(\n\t\t\t\t\t\t\tarticle.getCompanyId(), ownerId, ownerType, plid,\n\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\tsendEmail(article, articleURL, prefs, \"review\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"cbc80415ada6ee4bd3666e4cc9de986b2a9712b9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry updateWorkflowStatus(\n\t\t\tlong userId, long fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\t// File version\n\n\t\tDLFileVersion fileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\tfileEntry.getName());\n\n\t\tfileVersion.setStatus(serviceContext.getStatus());\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(new Date());\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileVersion.getVersion(),\n\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION) < 0)) {\n\n\t\t\tfileVersion.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\t}\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\n\t\t// File entry\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) < 0)) {\n\n\t\t\tfileEntry.setVersion(fileVersion.getVersion());\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\t\telse if (!fileVersion.isApproved() &&\n\t\t\t\t (DLUtil.compareVersions(\n\t\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tString newVersion = DLFileEntryConstants.DEFAULT_VERSION;\n\n\t\t\tif (DLUtil.compareVersions(\n\t\t\t\t\tfileVersion.getVersion(), newVersion) > 1) {\n\n\t\t\t\tList<DLFileVersion> approvedFileVersions =\n\t\t\t\t\tdlFileVersionPersistence.findByG_F_N_S(\n\t\t\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\t\t\tfileEntry.getName(), StatusConstants.APPROVED);\n\n\t\t\t\tif (!approvedFileVersions.isEmpty()) {\n\t\t\t\t\tnewVersion = approvedFileVersions.get(0).getVersion();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfileEntry.setVersion(newVersion);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\ttrue);\n\t\t}\n\t\telse if (Validator.isNull(fileEntry.getVersion())) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\tfalse);\n\t\t}\n\n\t\t// Social\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tif (fileVersion.getVersion().equals(\n\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\tsocialActivityLocalService.addUniqueActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntryId, DLActivityKeys.ADD_FILE_ENTRY,\n\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntryId, DLActivityKeys.UPDATE_FILE_ENTRY,\n\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t}\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(DLFileEntry.class);\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) == 0)) {\n\n\t\t\tindexer.reindex(fileEntry);\n\t\t}\n\t\telse if (Validator.isNull(fileEntry.getVersion())) {\n\t\t\tindexer.delete(fileEntry);\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":38167,"modified_method":"public DLFileEntry updateWorkflowStatus(\n\t\t\tlong userId, long fileEntryId, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\t// File version\n\n\t\tDLFileVersion fileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\tfileEntry.getName());\n\n\t\tfileVersion.setStatus(serviceContext.getStatus());\n\t\tfileVersion.setStatusByUserId(user.getUserId());\n\t\tfileVersion.setStatusByUserName(user.getFullName());\n\t\tfileVersion.setStatusDate(new Date());\n\n\t\tdlFileVersionPersistence.update(fileVersion, false);\n\n\t\t// File entry\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\t(DLUtil.compareVersions(\n\t\t\t\tfileEntry.getVersion(), fileVersion.getVersion()) < 0)) {\n\n\t\t\tfileEntry.setVersion(fileVersion.getVersion());\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\t\telse if (!fileVersion.isApproved() &&\n\t\t\t\t fileEntry.getVersion().equals(fileVersion.getVersion())) {\n\n\t\t\tString newVersion = DLFileEntryConstants.DEFAULT_VERSION;\n\n\t\t\tList<DLFileVersion> approvedFileVersions =\n\t\t\t\tdlFileVersionPersistence.findByG_F_N_S(\n\t\t\t\t\tfileEntry.getGroupId(), fileEntry.getFolderId(),\n\t\t\t\t\tfileEntry.getName(), StatusConstants.APPROVED);\n\n\t\t\tif (!approvedFileVersions.isEmpty()) {\n\t\t\t\tnewVersion = approvedFileVersions.get(0).getVersion();\n\t\t\t}\n\n\t\t\tfileEntry.setVersion(newVersion);\n\n\t\t\tdlFileEntryPersistence.update(fileEntry, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tif (fileVersion.isApproved() &&\n\t\t\tfileEntry.getVersion().equals(fileVersion.getVersion())) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\ttrue);\n\t\t}\n\t\telse if (Validator.isNull(fileEntry.getVersion())) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\tfalse);\n\t\t}\n\n\t\t// Social\n\n\t\tif (fileVersion.isApproved()) {\n\t\t\tif (fileVersion.getVersion().equals(\n\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\t\tsocialActivityLocalService.addUniqueActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntryId, DLActivityKeys.ADD_FILE_ENTRY,\n\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\tfileVersion.getUserId(), fileVersion.getGroupId(),\n\t\t\t\t\tfileVersion.getCreateDate(), DLFileEntry.class.getName(),\n\t\t\t\t\tfileEntryId, DLActivityKeys.UPDATE_FILE_ENTRY,\n\t\t\t\t\tStringPool.BLANK, 0);\n\t\t\t}\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(DLFileEntry.class);\n\n\t\tif (fileVersion.isApproved()) {\n\t\t\tindexer.reindex(fileEntry);\n\t\t}\n\t\telse if (fileVersion.getVersion().equals(\n\t\t\t\t\tDLFileEntryConstants.DEFAULT_VERSION)) {\n\n\t\t\tindexer.delete(fileEntry);\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"dade6e4ee0b99f45f7703aeccac278fb08c50e17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry addFileEntry(\n\t\t\tString uuid, long userId, long groupId, long folderId, String name,\n\t\t\tString title, String description, String versionDescription,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = getFolderId(user.getCompanyId(), folderId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tname = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\n\t\tDate now = new Date();\n\n\t\tvalidate(groupId, folderId, title, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tfileEntry.setUuid(uuid);\n\t\tfileEntry.setGroupId(groupId);\n\t\tfileEntry.setCompanyId(user.getCompanyId());\n\t\tfileEntry.setUserId(user.getUserId());\n\t\tfileEntry.setUserName(user.getFullName());\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tfileEntry.setFolderId(folderId);\n\t\tfileEntry.setName(name);\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// File version\n\n\t\taddFileVersion(\n\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now),\n\t\t\tDLFileEntryConstants.DEFAULT_VERSION, null, size,\n\t\t\tserviceContext.getStatus());\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.DL_FILE_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, fileEntry.getUserName(), DLFileEntry.class.getName(),\n\t\t\t\tfileEntryId, StatusConstants.APPROVED);\n\t\t}\n\n\t\t// File\n\n\t\tdlLocalService.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tfileEntryId, fileEntry.getLuceneProperties(),\n\t\t\tfileEntry.getModifiedDate(), serviceContext, is);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.isStartWorkflow()) {\n\t\t\ttry {\n\t\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\t\tDLFileEntry.class.getName(), fileEntryId, fileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":38168,"modified_method":"public DLFileEntry addFileEntry(\n\t\t\tString uuid, long userId, long groupId, long folderId, String name,\n\t\t\tString title, String description, String versionDescription,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = getFolderId(user.getCompanyId(), folderId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = name;\n\t\t}\n\n\t\tname = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\n\t\tDate now = new Date();\n\n\t\tvalidate(groupId, folderId, title, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tfileEntry.setUuid(uuid);\n\t\tfileEntry.setGroupId(groupId);\n\t\tfileEntry.setCompanyId(user.getCompanyId());\n\t\tfileEntry.setUserId(user.getUserId());\n\t\tfileEntry.setUserName(user.getFullName());\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tfileEntry.setFolderId(folderId);\n\t\tfileEntry.setName(name);\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setVersion(DLFileEntryConstants.DEFAULT_VERSION);\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddFileEntryResources(\n\t\t\t\tfileEntry, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// File version\n\n\t\taddFileVersion(\n\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now),\n\t\t\tDLFileEntryConstants.DEFAULT_VERSION, null, size,\n\t\t\tserviceContext.getStatus());\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(folderId);\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.DL_FILE_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, fileEntry.getUserName(), DLFileEntry.class.getName(),\n\t\t\t\tfileEntryId, StatusConstants.APPROVED);\n\t\t}\n\n\t\t// File\n\n\t\tdlLocalService.addFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tfileEntryId, fileEntry.getLuceneProperties(),\n\t\t\tfileEntry.getModifiedDate(), serviceContext, is);\n\n\t\t// Status\n\n\t\tfileEntry = updateWorkflowStatus(userId, fileEntryId, serviceContext);\n\n\t\treturn fileEntry;\n\t}","commit_id":"dade6e4ee0b99f45f7703aeccac278fb08c50e17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong userId, long groupId, long folderId, long newFolderId,\n\t\t\tString name, String sourceFileName, String title,\n\t\t\tString description, String versionDescription, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = name;\n\t\t\t}\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tvalidate(\n\t\t\tgroupId, folderId, newFolderId, name, title, sourceFileName, is);\n\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Move file entry\n\n\t\tif (folderId != newFolderId) {\n\t\t\tlong oldFileEntryId = fileEntry.getFileEntryId();\n\n\t\t\tif (dlLocalService.hasFile(\n\t\t\t\t\tuser.getCompanyId(),\n\t\t\t\t\tDLFileEntryImpl.getRepositoryId(groupId, newFolderId),\n\t\t\t\t\tname, StringPool.BLANK)) {\n\n\t\t\t\tthrow new DuplicateFileException(name);\n\t\t\t}\n\n\t\t\tlong newFileEntryId = counterLocalService.increment();\n\n\t\t\tDLFileEntry newFileEntry = dlFileEntryPersistence.create(\n\t\t\t\tnewFileEntryId);\n\n\t\t\tnewFileEntry.setGroupId(fileEntry.getGroupId());\n\t\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\t\tnewFileEntry.setFolderId(newFolderId);\n\t\t\tnewFileEntry.setName(name);\n\t\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\t\t\tnewFileEntry.setExtraSettings(extraSettings);\n\n\t\t\tdlFileEntryPersistence.update(newFileEntry, false);\n\n\t\t\tdlFileEntryPersistence.remove(fileEntry);\n\n\t\t\tList<DLFileVersion> fileVersions =\n\t\t\t\tdlFileVersionPersistence.findByG_F_N(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileVersion fileVersion : fileVersions) {\n\t\t\t\tlong newFileVersionId = counterLocalService.increment();\n\n\t\t\t\tDLFileVersion newFileVersion = dlFileVersionPersistence.create(\n\t\t\t\t\tnewFileVersionId);\n\n\t\t\t\tnewFileVersion.setGroupId(fileVersion.getGroupId());\n\t\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\t\tnewFileVersion.setFolderId(newFolderId);\n\t\t\t\tnewFileVersion.setName(name);\n\t\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\t\t\t\tnewFileVersion.setStatus(fileVersion.getStatus());\n\t\t\t\tnewFileVersion.setStatusByUserId(userId);\n\t\t\t\tnewFileVersion.setStatusByUserName(user.getFullName());\n\t\t\t\tnewFileVersion.setStatusDate(\n\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\tdlFileVersionPersistence.update(newFileVersion, false);\n\n\t\t\t\tdlFileVersionPersistence.remove(fileVersion);\n\t\t\t}\n\n\t\t\tdlFileShortcutLocalService.updateFileShortcuts(\n\t\t\t\tgroupId, folderId, name, newFolderId, name);\n\n\t\t\t// Resources\n\n\t\t\tResource resource = resourceLocalService.getResource(\n\t\t\t\tfileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tString.valueOf(fileEntry.getFileEntryId()));\n\n\t\t\tresource.setPrimKey(String.valueOf(newFileEntryId));\n\n\t\t\tresourcePersistence.update(resource, false);\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\tList<DLFileShortcut> fileShortcuts =\n\t\t\t\tdlFileShortcutPersistence.findByG_TF_TN(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileShortcut fileShortcut : fileShortcuts) {\n\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\tDLFileShortcut.class.getName(),\n\t\t\t\t\tfileShortcut.getFileShortcutId());\n\t\t\t}\n\n\t\t\t// Expando\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// Ratings\n\n\t\t\tRatingsStats stats = ratingsStatsLocalService.getStats(\n\t\t\t\tDLFileEntry.class.getName(), oldFileEntryId);\n\n\t\t\tstats.setClassPK(newFileEntryId);\n\n\t\t\tratingsStatsPersistence.update(stats, false);\n\n\t\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\t\tDLFileEntry.class.getName());\n\n\t\t\tList<RatingsEntry> entries = ratingsEntryPersistence.findByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tfor (RatingsEntry entry : entries) {\n\t\t\t\tentry.setClassPK(newFileEntryId);\n\n\t\t\t\tratingsEntryPersistence.update(entry, false);\n\t\t\t}\n\n\t\t\t// Message boards\n\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tif (discussion != null) {\n\t\t\t\tdiscussion.setClassPK(newFileEntryId);\n\n\t\t\t\tmbDiscussionPersistence.update(discussion, false);\n\t\t\t}\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.deleteActivities(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// File\n\n\t\t\tdlService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tnewFileEntry.getGroupId(), fileEntry.getRepositoryId(),\n\t\t\t\tnewFileEntry.getRepositoryId(), name, newFileEntryId);\n\n\t\t\tfolderId = newFolderId;\n\t\t\tfileEntry = newFileEntry;\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// File version\n\n\t\tString version = getNextVersion(\n\t\t\tfileEntry, majorVersion, serviceContext.getStatus());\n\n\t\ttry {\n\t\t\tDLFileVersion fileVersion =\n\t\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tif (fileVersion.getStatus() == StatusConstants.DRAFT) {\n\t\t\t\tupdateFileVersion(\n\t\t\t\t\tuser, fileVersion, serviceContext.getModifiedDate(now),\n\t\t\t\t\tversion, versionDescription, size,\n\t\t\t\t\tserviceContext.getStatus());\n\t\t\t}\n\t\t\telse if (is != null) {\n\t\t\t\taddFileVersion(\n\t\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\t\tversion, versionDescription, size,\n\t\t\t\t\tserviceContext.getStatus());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\taddFileVersion(\n\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now), version,\n\t\t\t\tversionDescription, size, serviceContext.getStatus());\n\t\t}\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tfileEntry.setVersion(version);\n\t\t}\n\n\t\t// File entry\n\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Folder\n\n\t\tif (fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tfileEntry.getFolderId());\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// File\n\n\t\tif (is == null) {\n\t\t\tint fetchFailures = 0;\n\n\t\t\twhile (is == null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = dlLocalService.getFileAsStream(\n\t\t\t\t\t\tuser.getCompanyId(), fileEntry.getRepositoryId(), name);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t\t\tfetchFailures++;\n\n\t\t\t\t\tif (PropsValues.DL_HOOK_IMPL.equals(\n\t\t\t\t\t\t\tJCRHook.class.getName()) &&\n\t\t\t\t\t\t(fetchFailures <\n\t\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_FETCH_MAX_FAILURES)) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(PropsValues.DL_HOOK_JCR_FETCH_DELAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tdlService.deleteFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tfileEntry.getRepositoryId(), fileEntry.getName(), version);\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t}\n\n\t\tdlLocalService.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tversion, sourceFileName, fileEntry.getFileEntryId(),\n\t\t\tfileEntry.getLuceneProperties(), fileEntry.getModifiedDate(),\n\t\t\tserviceContext, is);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.isStartWorkflow()) {\n\t\t\ttry {\n\t\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId(),\n\t\t\t\t\tfileEntry);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":38169,"modified_method":"public DLFileEntry updateFileEntry(\n\t\t\tlong userId, long groupId, long folderId, long newFolderId,\n\t\t\tString name, String sourceFileName, String title,\n\t\t\tString description, String versionDescription, boolean majorVersion,\n\t\t\tString extraSettings, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = sourceFileName;\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle = name;\n\t\t\t}\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tDLFileEntry fileEntry = dlFileEntryPersistence.findByG_F_N(\n\t\t\tgroupId, folderId, name);\n\n\t\tvalidate(\n\t\t\tgroupId, folderId, newFolderId, name, title, sourceFileName, is);\n\n\t\tfileEntry.setTitle(title);\n\t\tfileEntry.setDescription(description);\n\t\tfileEntry.setExtraSettings(extraSettings);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\t// Move file entry\n\n\t\tif (folderId != newFolderId) {\n\t\t\tlong oldFileEntryId = fileEntry.getFileEntryId();\n\n\t\t\tif (dlLocalService.hasFile(\n\t\t\t\t\tuser.getCompanyId(),\n\t\t\t\t\tDLFileEntryImpl.getRepositoryId(groupId, newFolderId),\n\t\t\t\t\tname, StringPool.BLANK)) {\n\n\t\t\t\tthrow new DuplicateFileException(name);\n\t\t\t}\n\n\t\t\tlong newFileEntryId = counterLocalService.increment();\n\n\t\t\tDLFileEntry newFileEntry = dlFileEntryPersistence.create(\n\t\t\t\tnewFileEntryId);\n\n\t\t\tnewFileEntry.setGroupId(fileEntry.getGroupId());\n\t\t\tnewFileEntry.setCompanyId(fileEntry.getCompanyId());\n\t\t\tnewFileEntry.setUserId(fileEntry.getUserId());\n\t\t\tnewFileEntry.setUserName(fileEntry.getUserName());\n\t\t\tnewFileEntry.setVersionUserId(fileEntry.getVersionUserId());\n\t\t\tnewFileEntry.setVersionUserName(fileEntry.getVersionUserName());\n\t\t\tnewFileEntry.setCreateDate(fileEntry.getCreateDate());\n\t\t\tnewFileEntry.setModifiedDate(fileEntry.getModifiedDate());\n\t\t\tnewFileEntry.setFolderId(newFolderId);\n\t\t\tnewFileEntry.setName(name);\n\t\t\tnewFileEntry.setTitle(fileEntry.getTitle());\n\t\t\tnewFileEntry.setDescription(fileEntry.getDescription());\n\t\t\tnewFileEntry.setVersion(fileEntry.getVersion());\n\t\t\tnewFileEntry.setSize(fileEntry.getSize());\n\t\t\tnewFileEntry.setReadCount(fileEntry.getReadCount());\n\t\t\tnewFileEntry.setExtraSettings(extraSettings);\n\n\t\t\tdlFileEntryPersistence.update(newFileEntry, false);\n\n\t\t\tdlFileEntryPersistence.remove(fileEntry);\n\n\t\t\tList<DLFileVersion> fileVersions =\n\t\t\t\tdlFileVersionPersistence.findByG_F_N(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileVersion fileVersion : fileVersions) {\n\t\t\t\tlong newFileVersionId = counterLocalService.increment();\n\n\t\t\t\tDLFileVersion newFileVersion = dlFileVersionPersistence.create(\n\t\t\t\t\tnewFileVersionId);\n\n\t\t\t\tnewFileVersion.setGroupId(fileVersion.getGroupId());\n\t\t\t\tnewFileVersion.setCompanyId(fileVersion.getCompanyId());\n\t\t\t\tnewFileVersion.setUserId(fileVersion.getUserId());\n\t\t\t\tnewFileVersion.setUserName(fileVersion.getUserName());\n\t\t\t\tnewFileVersion.setCreateDate(fileVersion.getCreateDate());\n\t\t\t\tnewFileVersion.setFolderId(newFolderId);\n\t\t\t\tnewFileVersion.setName(name);\n\t\t\t\tnewFileVersion.setVersion(fileVersion.getVersion());\n\t\t\t\tnewFileVersion.setSize(fileVersion.getSize());\n\t\t\t\tnewFileVersion.setStatus(fileVersion.getStatus());\n\t\t\t\tnewFileVersion.setStatusByUserId(userId);\n\t\t\t\tnewFileVersion.setStatusByUserName(user.getFullName());\n\t\t\t\tnewFileVersion.setStatusDate(\n\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\tdlFileVersionPersistence.update(newFileVersion, false);\n\n\t\t\t\tdlFileVersionPersistence.remove(fileVersion);\n\t\t\t}\n\n\t\t\tdlFileShortcutLocalService.updateFileShortcuts(\n\t\t\t\tgroupId, folderId, name, newFolderId, name);\n\n\t\t\t// Resources\n\n\t\t\tResource resource = resourceLocalService.getResource(\n\t\t\t\tfileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tString.valueOf(fileEntry.getFileEntryId()));\n\n\t\t\tresource.setPrimKey(String.valueOf(newFileEntryId));\n\n\t\t\tresourcePersistence.update(resource, false);\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\tList<DLFileShortcut> fileShortcuts =\n\t\t\t\tdlFileShortcutPersistence.findByG_TF_TN(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfor (DLFileShortcut fileShortcut : fileShortcuts) {\n\t\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\t\tDLFileShortcut.class.getName(),\n\t\t\t\t\tfileShortcut.getFileShortcutId());\n\t\t\t}\n\n\t\t\t// Expando\n\n\t\t\texpandoValueLocalService.deleteValues(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// Ratings\n\n\t\t\tRatingsStats stats = ratingsStatsLocalService.getStats(\n\t\t\t\tDLFileEntry.class.getName(), oldFileEntryId);\n\n\t\t\tstats.setClassPK(newFileEntryId);\n\n\t\t\tratingsStatsPersistence.update(stats, false);\n\n\t\t\tlong classNameId = PortalUtil.getClassNameId(\n\t\t\t\tDLFileEntry.class.getName());\n\n\t\t\tList<RatingsEntry> entries = ratingsEntryPersistence.findByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tfor (RatingsEntry entry : entries) {\n\t\t\t\tentry.setClassPK(newFileEntryId);\n\n\t\t\t\tratingsEntryPersistence.update(entry, false);\n\t\t\t}\n\n\t\t\t// Message boards\n\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, oldFileEntryId);\n\n\t\t\tif (discussion != null) {\n\t\t\t\tdiscussion.setClassPK(newFileEntryId);\n\n\t\t\t\tmbDiscussionPersistence.update(discussion, false);\n\t\t\t}\n\n\t\t\t// Social\n\n\t\t\tsocialActivityLocalService.deleteActivities(\n\t\t\t\tDLFileEntry.class.getName(), fileEntry.getFileEntryId());\n\n\t\t\t// File\n\n\t\t\tdlService.updateFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tnewFileEntry.getGroupId(), fileEntry.getRepositoryId(),\n\t\t\t\tnewFileEntry.getRepositoryId(), name, newFileEntryId);\n\n\t\t\tfolderId = newFolderId;\n\t\t\tfileEntry = newFileEntry;\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, fileEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// File version\n\n\t\tString version = getNextVersion(\n\t\t\tfileEntry, majorVersion, serviceContext.getStatus());\n\n\t\ttry {\n\t\t\tDLFileVersion fileVersion =\n\t\t\t\tdlFileVersionLocalService.getLatestFileVersion(\n\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\tif (fileVersion.getStatus() == StatusConstants.DRAFT) {\n\t\t\t\tupdateFileVersion(\n\t\t\t\t\tuser, fileVersion, serviceContext.getModifiedDate(now),\n\t\t\t\t\tversion, versionDescription, size,\n\t\t\t\t\tserviceContext.getStatus());\n\t\t\t}\n\t\t\telse if (is != null) {\n\t\t\t\taddFileVersion(\n\t\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now),\n\t\t\t\t\tversion, versionDescription, size,\n\t\t\t\t\tserviceContext.getStatus());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFileVersionException nsfve) {\n\t\t\taddFileVersion(\n\t\t\t\tuser, fileEntry, serviceContext.getModifiedDate(now), version,\n\t\t\t\tversionDescription, size, serviceContext.getStatus());\n\t\t}\n\n\t\tif (serviceContext.getStatus() == StatusConstants.APPROVED) {\n\t\t\tfileEntry.setVersion(version);\n\t\t}\n\n\t\t// File entry\n\n\t\tfileEntry.setVersionUserId(user.getUserId());\n\t\tfileEntry.setVersionUserName(user.getFullName());\n\t\tfileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tfileEntry.setSize(size);\n\t\tfileEntry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tdlFileEntryPersistence.update(fileEntry, false);\n\n\t\t// Folder\n\n\t\tif (fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder folder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tfileEntry.getFolderId());\n\n\t\t\tfolder.setLastPostDate(fileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(folder, false);\n\t\t}\n\n\t\t// File\n\n\t\tif (is == null) {\n\t\t\tint fetchFailures = 0;\n\n\t\t\twhile (is == null) {\n\t\t\t\ttry {\n\t\t\t\t\tis = dlLocalService.getFileAsStream(\n\t\t\t\t\t\tuser.getCompanyId(), fileEntry.getRepositoryId(), name);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t\t\tfetchFailures++;\n\n\t\t\t\t\tif (PropsValues.DL_HOOK_IMPL.equals(\n\t\t\t\t\t\t\tJCRHook.class.getName()) &&\n\t\t\t\t\t\t(fetchFailures <\n\t\t\t\t\t\t\tPropsValues.DL_HOOK_JCR_FETCH_MAX_FAILURES)) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(PropsValues.DL_HOOK_JCR_FETCH_DELAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (InterruptedException ie) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tdlService.deleteFile(\n\t\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\t\tfileEntry.getRepositoryId(), fileEntry.getName(), version);\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t}\n\n\t\tdlLocalService.updateFile(\n\t\t\tuser.getCompanyId(), PortletKeys.DOCUMENT_LIBRARY,\n\t\t\tfileEntry.getGroupId(), fileEntry.getRepositoryId(), name, false,\n\t\t\tversion, sourceFileName, fileEntry.getFileEntryId(),\n\t\t\tfileEntry.getLuceneProperties(), fileEntry.getModifiedDate(),\n\t\t\tserviceContext, is);\n\n\t\t// Status\n\n\t\tfileEntry = updateWorkflowStatus(\n\t\t\tuserId, fileEntry.getFileEntryId(), serviceContext);\n\n\t\treturn fileEntry;\n\t}","commit_id":"dade6e4ee0b99f45f7703aeccac278fb08c50e17","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateTagsAsset(\n\t\t\tlong userId, JournalArticle article, String[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean updateAsset = true;\n\n\t\tif (article.getVersion() == 1) {\n\t\t}\n\t\telse if (!article.isApproved()) {\n\t\t\tupdateAsset = false;\n\t\t}\n\t\telse if (!isLatestVersion(\n\t\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\t\tarticle.getVersion(), Boolean.TRUE)) {\n\n\t\t\t\tupdateAsset = false;\n\t\t}\n\n\t\tif (updateAsset) {\n\t\t\ttagsAssetLocalService.updateAsset(\n\t\t\t\tuserId, article.getGroupId(), JournalArticle.class.getName(),\n\t\t\t\tarticle.getResourcePrimKey(), tagsEntries, null, null,\n\t\t\t\tarticle.getDisplayDate(), article.getExpirationDate(),\n\t\t\t\tContentTypes.TEXT_HTML, article.getTitle(),\n\t\t\t\tarticle.getDescription(), null, null, 0, 0, null, false);\n\t\t}\n\t}","id":38170,"modified_method":"public void updateTagsAsset(\n\t\t\tlong userId, JournalArticle article, String[] tagsEntries)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (article.isApproved() || (article.getVersion() == 1)) {\n\t\t\t//\n\t\t\t// Get earliest display date and latest expiration date among all article versions\n\t\t\t//\n\t\t\tDate earliestDisplayDate = article.getDisplayDate();\n\t\t\tDate latestExpirationDate = article.getExpirationDate();\n\n\t\t\tDate[] dateInterval = setDateIntervalForAsset(article.getGroupId(),article.getArticleId(),earliestDisplayDate,latestExpirationDate);\n\n\t\t\ttagsAssetLocalService.updateAsset(\n\t\t\t\tuserId, article.getGroupId(), JournalArticle.class.getName(),\n\t\t\t\tarticle.getResourcePrimKey(), tagsEntries, null, null,\n\t\t\t\tdateInterval[0], dateInterval[1],\n\t\t\t\tContentTypes.TEXT_HTML, article.getTitle(),\n\t\t\t\tarticle.getDescription(), null, null, 0, 0, null, false);\n\t\t}\n\t}","commit_id":"56938193b402306ba313716f8a44c4100f2f0763","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateViewCount(\n\t\t\tlong userId, long resourcePrimKey, int viewCount)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tArticle article = getLatestArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tarticle.setViewCount(viewCount);\n\n\t\tarticlePersistence.update(article, false);\n\n\t\tif (!article.isApproved() && !article.isFirstVersion()) {\n\t\t\tarticle = getLatestArticle(\n\t\t\t\tresourcePrimKey, WorkflowConstants.STATUS_APPROVED);\n\n\t\t\tarticle.setViewCount(viewCount);\n\n\t\t\tarticlePersistence.update(article, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.incrementViewCounter(\n\t\t\tuserId, Article.class.getName(), article.getClassPK());\n\t}","id":38171,"modified_method":"public void updateViewCount(\n\t\t\tlong userId, long resourcePrimKey, int viewCount)\n\t\tthrows PortalException, SystemException {\n\n\t\tArticle article = getLatestArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tarticle.setViewCount(viewCount);\n\n\t\tarticlePersistence.update(article, false);\n\n\t\tif (article.isApproved() || article.isFirstVersion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tarticle = getLatestArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_APPROVED);\n\n\t\tarticle.setViewCount(viewCount);\n\n\t\tarticlePersistence.update(article, false);\n\t}","commit_id":"efe4917641ccfe859978030ba6f9a8d9469cd631","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n    * Get the principal and credential for a specific context and store them in\n    * the context.\n    * @param principals\n    * @param credentials\n    * @param ctxName\n    * @param securityContext\n    * @param person\n    */\n   public void setContextParameters (HashMap principals, HashMap credentials, String ctxName,\n         ISecurityContext securityContext, IPerson person) {\n      String username = (String)principals.get(ctxName);\n      String credential = (String)credentials.get(ctxName);\n      // If username or credential are null, this indicates that the token was not\n      // set in security properties. We will then use the value for root.\n      username = (username != null ? username : (String)principals.get(BASE_CONTEXT_NAME));\n      credential = (credential != null ? credential : (String)credentials.get(BASE_CONTEXT_NAME));\n      if (log.isDebugEnabled())\n          log.debug(\"Authentication::setContextParameters() username: \" + username);\n      // Retrieve and populate an instance of the principal object\n      IPrincipal principalInstance = securityContext.getPrincipalInstance();\n      if (username != null && !username.equals(\"\")) {\n         principalInstance.setUID(username);\n      }\n      // Retrieve and populate an instance of the credentials object\n      IOpaqueCredentials credentialsInstance = securityContext.getOpaqueCredentialsInstance();\n      credentialsInstance.setCredentials(credential);\n   }","id":38172,"modified_method":"/**\n    * Get the principal and credential for a specific context and store them in\n    * the context.\n    * @param principals\n    * @param credentials\n    * @param ctxName\n    * @param securityContext\n    * @param person\n    */\n   public void setContextParameters (HashMap principals, HashMap credentials, String ctxName,\n         ISecurityContext securityContext, IPerson person) {\n      String username = (String)principals.get(ctxName);\n      String credential = (String)credentials.get(ctxName);\n      // If username or credential are null, this indicates that the token was not\n      // set in security properties. We will then use the value for root.\n      username = (username != null ? username : (String)principals.get(BASE_CONTEXT_NAME));\n      credential = (credential != null ? credential : (String)credentials.get(BASE_CONTEXT_NAME));\n      if (log.isDebugEnabled())\n          log.debug(\"Authentication::setContextParameters() username: \" + username);\n      // Retrieve and populate an instance of the principal object\n      IPrincipal principalInstance = securityContext.getPrincipalInstance();\n      if (username != null && !username.equals(\"\")) {\n         principalInstance.setUID(username);\n      }\n      // Retrieve and populate an instance of the credentials object\n      IOpaqueCredentials credentialsInstance = securityContext.getOpaqueCredentialsInstance();\n      if (credentialsInstance != null) {\n          credentialsInstance.setCredentials(credential);\n      }\n   }","commit_id":"ffa2a69056ecf4413c336f8df44ddd5f1bc84180","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n\n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n\n  \t/* Grab the target functional name, if any, off the login request.\n\t * Also any arguments for the target\n  \t * We will pass them  along after authentication.\n  \t */\n  \tString targetFname = request.getParameter(\"uP_fname\");\n  \tString targetArgs = request.getParameter(\"uP_args\");\n\n    // Clear out the existing session for the user if they have one\n    final HttpSession s = request.getSession(false);\n    if (s != null) {\n    \ttry {\n            s.invalidate();\n    \t} catch (IllegalStateException ise) {\n    \t\t// ISE indicates session was already invalidated.\n    \t\t// This is fine.  This servlet trying to guarantee that the session has been invalidated;\n    \t\t// it doesn't have to insist that it is the one that invalidated it.\n    \t\tif (log.isTraceEnabled()) {\n    \t\t\tlog.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n    \t\t}\n    \t}\n    }\n\n  \t//  Create the user's session\n    request.getSession(true);\n  \tIPerson person = null;\n    try {\n      // Get the person object associated with the request\n      person = PersonManagerFactory.getPersonManagerInstance().getPerson(request);\n      // WE grab all of the principals and credentials from the request and load\n      // them into their respective HashMaps.\n      HashMap principals = getPropertyFromRequest (principalTokens, request);\n      HashMap credentials = getPropertyFromRequest (credentialTokens, request);\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    \n    // create the redirect URL, adding fname and args parameters if necessary\n    String redirectTarget = null;\n\tif (targetFname == null){\n\t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n\t} else {\n\t\tredirectTarget = request.getContextPath() + \"/\" +\n\t\t\"tag.idempotent.\" +  redirectString + \"?uP_fname=\" + URLEncoder.encode(targetFname, \"UTF-8\");\n\t\tif (targetArgs != null) {\n\t\t\tredirectTarget = redirectTarget + \"&uP_args=\" + URLEncoder.encode(targetArgs, \"UTF-8\");\n\t\t}\n\t}\n\n\tif (person == null || !person.getSecurityContext().isAuthenticated()) {\n     if ( request.getMethod().equals(\"POST\") )\n         request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n     // Preserve the attempted username so it can be redisplayed to the user by CLogin\n     String attemptedUserName = request.getParameter(\"userName\");\n     if (attemptedUserName != null)\n     \trequest.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\t\t\n\t}\n\n    response.sendRedirect(redirectTarget);\n\n  }","id":38173,"modified_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n\n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n\n    final IPersonManager personManager = PersonManagerFactory.getPersonManagerInstance();\n    \n    // Clear out the existing session for the user if they have one\n    HttpSession s = request.getSession(false);\n    String targetUid = null;\n    String originalUid = null;\n    if (s != null) {\n    \ttry {\n    \t    targetUid = (String)s.getAttribute(SWAP_TARGET_UID);\n    \t    if (targetUid != null) {\n    \t        final IPerson person = personManager.getPerson(request);\n    \t        originalUid = person.getName();\n    \t    }\n\n            s.invalidate();\n    \t} catch (IllegalStateException ise) {\n    \t\t// ISE indicates session was already invalidated.\n    \t\t// This is fine.  This servlet trying to guarantee that the session has been invalidated;\n    \t\t// it doesn't have to insist that it is the one that invalidated it.\n    \t\tif (log.isTraceEnabled()) {\n    \t\t\tlog.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n    \t\t}\n    \t}\n    }\n\n  \t//  Create the user's session\n    s = request.getSession(true);\n    \n  \tIPerson person = null;\n    try {\n        final HashMap principals;\n        final HashMap credentials;\n        \n        // Get the person object associated with the request\n        person = personManager.getPerson(request);\n        \n        //If doing an identity swap\n        if (targetUid != null && originalUid != null) {\n            log.warn(\"Swapping identity for '\" + originalUid + \"' to '\" + targetUid + \"'\");\n            \n            //Track the originating user\n            s.setAttribute(SWAP_ORIGINAL_UID, originalUid);\n            \n            //Setup the swapped person\n            person.setUserName(targetUid);\n            \n            //Setup the custom security context\n            final IdentitySwapperPrincipal identitySwapperPrincipal = new IdentitySwapperPrincipal(person);\n            final IdentitySwapperSecurityContext identitySwapperSecurityContext = new IdentitySwapperSecurityContext(identitySwapperPrincipal);\n            person.setSecurityContext(identitySwapperSecurityContext);\n            \n            principals = new HashMap();\n            credentials = new HashMap();\n        }\n        //Norm authN path\n        else {\n          // WE grab all of the principals and credentials from the request and load\n          // them into their respective HashMaps.\n          principals = getPropertyFromRequest (principalTokens, request);\n          credentials = getPropertyFromRequest (credentialTokens, request);\n        }\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    \n    /* Grab the target functional name, if any, off the login request.\n     * Also any arguments for the target\n     * We will pass them  along after authentication.\n     */\n    String targetFname = request.getParameter(\"uP_fname\");\n    String targetArgs = request.getParameter(\"uP_args\");\n    \n    // create the redirect URL, adding fname and args parameters if necessary\n    String redirectTarget = null;\n\tif (targetFname == null){\n\t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n\t} else {\n\t\tredirectTarget = request.getContextPath() + \"/\" +\n\t\t\"tag.idempotent.\" +  redirectString + \"?uP_fname=\" + URLEncoder.encode(targetFname, \"UTF-8\");\n\t\tif (targetArgs != null) {\n\t\t\tredirectTarget = redirectTarget + \"&uP_args=\" + URLEncoder.encode(targetArgs, \"UTF-8\");\n\t\t}\n\t}\n\n\tif (person == null || !person.getSecurityContext().isAuthenticated()) {\n     if ( request.getMethod().equals(\"POST\") )\n         request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n     // Preserve the attempted username so it can be redisplayed to the user by CLogin\n     String attemptedUserName = request.getParameter(\"userName\");\n     if (attemptedUserName != null)\n     \trequest.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\t\t\n\t}\n\n    response.sendRedirect(redirectTarget);\n\n  }","commit_id":"ffa2a69056ecf4413c336f8df44ddd5f1bc84180","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void afterPropertiesSet() {\n\t\tHttpClientBuilder httpClientBuilder = HttpClients.custom();\n\n\t\tHttpClientConnectionManager httpClientConnectionManager =\n\t\t\tgetPoolingHttpClientConnectionManager();\n\n\t\thttpClientBuilder.setConnectionManager(httpClientConnectionManager);\n\n\t\tif ((_login != null) && (_password != null)) {\n\t\t\tCredentialsProvider credentialsProvider =\n\t\t\t\tnew BasicCredentialsProvider();\n\n\t\t\tcredentialsProvider.setCredentials(\n\t\t\t\tnew AuthScope(_hostName, _hostPort),\n\t\t\t\tnew UsernamePasswordCredentials(_login, _password));\n\n\t\t\thttpClientBuilder.setDefaultCredentialsProvider(\n\t\t\t\tcredentialsProvider);\n\t\t\thttpClientBuilder.setRetryHandler(\n\t\t\t\tnew HttpRequestRetryHandlerImpl());\n\t\t}\n\t\telse {\n\t\t\tif (_logger.isWarnEnabled()) {\n\t\t\t\t_logger.warn(\"Login and password are required\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tsetProxyHost(httpClientBuilder);\n\n\t\t\t_closeableHttpClient = httpClientBuilder.build();\n\n\t\t\t_idleConnectionMonitorThread = new IdleConnectionMonitorThread(\n\t\t\t\thttpClientConnectionManager);\n\n\t\t\t_idleConnectionMonitorThread.start();\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Configured client for \" + _protocol + \"://\" + _hostName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(\"Unable to configure client\", e);\n\t\t}\n\t}","id":38174,"modified_method":"public void afterPropertiesSet() {\n\t\tHttpClientBuilder httpClientBuilder = HttpClients.custom();\n\n\t\tHttpClientConnectionManager httpClientConnectionManager =\n\t\t\tgetPoolingHttpClientConnectionManager();\n\n\t\thttpClientBuilder.setConnectionManager(httpClientConnectionManager);\n\n\t\tif (((_login != null) && (_password != null)) ||\n\t\t\t((_proxyLogin != null) && (_proxyPassword != null))) {\n\n\t\t\tCredentialsProvider credentialsProvider =\n\t\t\t\tnew BasicCredentialsProvider();\n\n\t\t\tif (_login != null) {\n\t\t\t\tcredentialsProvider.setCredentials(\n\t\t\t\t\tnew AuthScope(_hostName, _hostPort),\n\t\t\t\t\tnew UsernamePasswordCredentials(_login, _password));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_logger.isInfoEnabled()) {\n\t\t\t\t\t_logger.info(\"No credentials are used\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_proxyLogin != null) {\n\t\t\t\tcredentialsProvider.setCredentials(\n\t\t\t\t\tnew AuthScope(_proxyHostName, _proxyHostPort),\n\t\t\t\t\tnew UsernamePasswordCredentials(\n\t\t\t\t\t\t_proxyLogin, _proxyPassword));\n\t\t\t}\n\n\t\t\thttpClientBuilder.setDefaultCredentialsProvider(\n\t\t\t\tcredentialsProvider);\n\t\t\thttpClientBuilder.setRetryHandler(\n\t\t\t\tnew HttpRequestRetryHandlerImpl());\n\t\t}\n\n\t\ttry {\n\t\t\tsetProxyHost(httpClientBuilder);\n\n\t\t\t_closeableHttpClient = httpClientBuilder.build();\n\n\t\t\t_idleConnectionMonitorThread = new IdleConnectionMonitorThread(\n\t\t\t\thttpClientConnectionManager);\n\n\t\t\t_idleConnectionMonitorThread.start();\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Configured client for \" + _protocol + \"://\" + _hostName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_logger.error(\"Unable to configure client\", e);\n\t\t}\n\t}","commit_id":"cab0976f0fef0f68f597260cd289a1a3519c2fcd","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@NotNull\n  public CredentialsProvider setProxyCredentials(@NotNull CredentialsProvider provider, boolean useProxy) {\n    if (useProxy && PROXY_AUTHENTICATION) {\n      provider.setCredentials(new AuthScope(PROXY_HOST, PROXY_PORT), new UsernamePasswordCredentials(PROXY_LOGIN, getPlainProxyPassword()));\n    }\n\n    return provider;\n  }","id":38175,"modified_method":"@NotNull\n  public CredentialsProvider setProxyCredentials(@NotNull CredentialsProvider provider, boolean useProxy) {\n    if (useProxy && PROXY_AUTHENTICATION) {\n      String ntlmUserPassword = PROXY_LOGIN.replace('\\\\', '/') + \":\" + getPlainProxyPassword();\n      provider.setCredentials(new AuthScope(PROXY_HOST, PROXY_PORT, AuthScope.ANY_REALM, AuthSchemes.NTLM), new NTCredentials(ntlmUserPassword));\n      provider.setCredentials(new AuthScope(PROXY_HOST, PROXY_PORT), new UsernamePasswordCredentials(PROXY_LOGIN, getPlainProxyPassword()));\n    }\n\n    return provider;\n  }","commit_id":"0e8d393279f915a9c69a1726bb6c91ee4be1cdf0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Notification sendNewIssues(Project project, int newIssues) {\n    Notification notification = newNotification(project, \"new-issues\")\n      .setDefaultMessage(newIssues + \" new issues on \" + project.getLongName() + \".\")\n      .setFieldValue(\"projectDate\", DateUtils.formatDateTime(project.getAnalysisDate()))\n      .setFieldValue(\"count\", String.valueOf(newIssues));\n    notificationsManager.scheduleForSending(notification);\n    return notification;\n  }","id":38176,"modified_method":"public Notification sendNewIssues(Project project, IssuesBySeverity newIssues) {\n    Notification notification = newNotification(project, \"new-issues\")\n      .setDefaultMessage(newIssues.size() + \" new issues on \" + project.getLongName() + \".\\n\")\n      .setFieldValue(\"projectDate\", DateUtils.formatDateTime(project.getAnalysisDate()))\n      .setFieldValue(\"count\", String.valueOf(newIssues.size()));\n    for (String severity : Severity.ALL) {\n      notification.setFieldValue(\"count-\"+ severity,  String.valueOf(newIssues.issues(severity)));\n    }\n    notificationsManager.scheduleForSending(notification);\n    return notification;\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_send_new_issues() throws Exception {\n    Date date = DateUtils.parseDateTime(\"2013-05-18T13:00:03+0200\");\n    Project project = new Project(\"struts\").setAnalysisDate(date);\n    Notification notification = issueNotifications.sendNewIssues(project, 42);\n\n    assertThat(notification.getFieldValue(\"count\")).isEqualTo(\"42\");\n    assertThat(DateUtils.parseDateTime(notification.getFieldValue(\"projectDate\"))).isEqualTo(date);\n    Mockito.verify(manager).scheduleForSending(notification);\n  }","id":38177,"modified_method":"@Test\n  public void should_send_new_issues() throws Exception {\n    Date date = DateUtils.parseDateTime(\"2013-05-18T13:00:03+0200\");\n    Project project = new Project(\"struts\").setAnalysisDate(date);\n    IssuesBySeverity issuesBySeverity = mock(IssuesBySeverity.class);\n    when(issuesBySeverity.size()).thenReturn(42);\n    when(issuesBySeverity.issues(\"MINOR\")).thenReturn(10);\n    Notification notification = issueNotifications.sendNewIssues(project, issuesBySeverity);\n\n    assertThat(notification.getFieldValue(\"count\")).isEqualTo(\"42\");\n    assertThat(notification.getFieldValue(\"count-MINOR\")).isEqualTo(\"10\");\n    assertThat(DateUtils.parseDateTime(notification.getFieldValue(\"projectDate\"))).isEqualTo(date);\n    Mockito.verify(manager).scheduleForSending(notification);\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public NewIssuesEmailTemplate(EmailSettings settings) {\n    this.settings = settings;\n  }","id":38178,"modified_method":"public NewIssuesEmailTemplate(EmailSettings settings, I18n i18n) {\n    this.settings = settings;\n    this.i18n = i18n;\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public EmailMessage format(Notification notification) {\n    if (!\"new-issues\".equals(notification.getType())) {\n      return null;\n    }\n    String projectName = notification.getFieldValue(\"projectName\");\n    String violationsCount = notification.getFieldValue(\"count\");\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Project: \").append(projectName).append('\\n');\n    sb.append(violationsCount).append(\" new issues\").append('\\n');\n    appendFooter(sb, notification);\n\n    EmailMessage message = new EmailMessage()\n      .setMessageId(\"new-issues/\" + notification.getFieldValue(\"projectKey\"))\n      .setSubject(projectName + \": new issues\")\n      .setMessage(sb.toString());\n\n    return message;\n  }","id":38179,"modified_method":"@Override\n  public EmailMessage format(Notification notification) {\n    if (!\"new-issues\".equals(notification.getType())) {\n      return null;\n    }\n    String projectName = notification.getFieldValue(\"projectName\");\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Project: \").append(projectName).append(\"\\n\\n\");\n    sb.append(notification.getFieldValue(\"count\")).append(\" new issues\").append(\"\\n\\n\");\n    sb.append(\"   \");\n    for (Iterator<String> severityIterator = Lists.reverse(Severity.ALL).iterator(); severityIterator.hasNext(); ) {\n      String severity = severityIterator.next();\n      String severityLabel = i18n.message(getLocale(), \"severity.\"+ severity, severity);\n      sb.append(severityLabel).append(\": \").append(notification.getFieldValue(\"count-\"+ severity));\n      if (severityIterator.hasNext()) {\n        sb.append(\"   \");\n      }\n    }\n    sb.append('\\n');\n\n    appendFooter(sb, notification);\n\n    EmailMessage message = new EmailMessage()\n      .setMessageId(\"new-issues/\" + notification.getFieldValue(\"projectKey\"))\n      .setSubject(projectName + \": new issues\")\n      .setMessage(sb.toString());\n\n    return message;\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * <pre>\n   * Subject: Project Struts, new issues\n   * From: Sonar\n   *\n   * Project: Foo\n   * 32 new issues\n   *\n   * See it in SonarQube: http://nemo.sonarsource.org/drilldown/measures/org.sonar.foo:foo?metric=new_violations\n   * <\/pre>\n   */\n  @Test\n  public void shouldFormatCommentAdded() {\n    Notification notification = new Notification(\"new-issues\")\n      .setFieldValue(\"count\", \"32\")\n      .setFieldValue(\"projectName\", \"Struts\")\n      .setFieldValue(\"projectKey\", \"org.apache:struts\")\n      .setFieldValue(\"projectDate\", \"2010-05-18T14:50:45+0000\");\n\n    EmailMessage message = template.format(notification);\n    assertThat(message.getMessageId()).isEqualTo(\"new-issues/org.apache:struts\");\n    assertThat(message.getSubject()).isEqualTo(\"Struts: new issues\");\n    assertThat(message.getMessage()).isEqualTo(\"\" +\n      \"Project: Struts\\n\" +\n      \"32 new issues\\n\" +\n      \"\\n\" +\n      \"See it in SonarQube: http://nemo.sonarsource.org/issues/search?componentRoots=org.apache%3Astruts&createdAt=2010-05-18T14%3A50%3A45%2B0000\\n\");\n  }","id":38180,"modified_method":"/**\n   * <pre>\n   * Subject: Project Struts, new issues\n   * From: Sonar\n   *\n   * Project: Foo\n   * 32 new issues\n   *\n   * See it in SonarQube: http://nemo.sonarsource.org/drilldown/measures/org.sonar.foo:foo?metric=new_violations\n   * <\/pre>\n   */\n  @Test\n  public void shouldFormatCommentAdded() {\n    Notification notification = new Notification(\"new-issues\")\n      .setFieldValue(\"count\", \"32\")\n      .setFieldValue(\"count-INFO\", \"1\")\n      .setFieldValue(\"count-MINOR\", \"3\")\n      .setFieldValue(\"count-MAJOR\", \"10\")\n      .setFieldValue(\"count-CRITICAL\", \"5\")\n      .setFieldValue(\"count-BLOCKER\", \"0\")\n      .setFieldValue(\"projectName\", \"Struts\")\n      .setFieldValue(\"projectKey\", \"org.apache:struts\")\n      .setFieldValue(\"projectDate\", \"2010-05-18T14:50:45+0000\");\n\n    when(i18n.message(any(Locale.class), eq(\"severity.BLOCKER\"), anyString())).thenReturn(\"Blocker\");\n    when(i18n.message(any(Locale.class), eq(\"severity.CRITICAL\"), anyString())).thenReturn(\"Critical\");\n    when(i18n.message(any(Locale.class), eq(\"severity.MAJOR\"), anyString())).thenReturn(\"Major\");\n    when(i18n.message(any(Locale.class), eq(\"severity.MINOR\"), anyString())).thenReturn(\"Minor\");\n    when(i18n.message(any(Locale.class), eq(\"severity.INFO\"), anyString())).thenReturn(\"Info\");\n\n    EmailMessage message = template.format(notification);\n    assertThat(message.getMessageId()).isEqualTo(\"new-issues/org.apache:struts\");\n    assertThat(message.getSubject()).isEqualTo(\"Struts: new issues\");\n    assertThat(message.getMessage()).isEqualTo(\"\" +\n      \"Project: Struts\\n\" +\n      \"\\n\" +\n      \"32 new issues\\n\" +\n      \"\\n\" +\n      \"   Blocker: 0   Critical: 5   Major: 10   Minor: 3   Info: 1\\n\" +\n      \"\\n\" +\n      \"See it in SonarQube: http://nemo.sonarsource.org/issues/search?componentRoots=org.apache%3Astruts&createdAt=2010-05-18T14%3A50%3A45%2B0000\\n\");\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    EmailSettings settings = mock(EmailSettings.class);\n    when(settings.getServerBaseURL()).thenReturn(\"http://nemo.sonarsource.org\");\n    template = new NewIssuesEmailTemplate(settings);\n    TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n  }","id":38181,"modified_method":"@Before\n  public void setUp() {\n    EmailSettings settings = mock(EmailSettings.class);\n    when(settings.getServerBaseURL()).thenReturn(\"http://nemo.sonarsource.org\");\n    template = new NewIssuesEmailTemplate(settings, i18n);\n    TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void sendNotifications(Project project) {\n    int newIssues = 0;\n    IssueChangeContext context = IssueChangeContext.createScan(project.getAnalysisDate());\n    Map<DefaultIssue, Rule> shouldSentNotification = new LinkedHashMap<DefaultIssue, Rule>();\n    for (DefaultIssue issue : issueCache.all()) {\n      if (issue.isNew() && issue.resolution() == null) {\n        newIssues++;\n      }\n      if (!issue.isNew() && issue.isChanged() && issue.mustSendNotifications()) {\n        Rule rule = ruleFinder.findByKey(issue.ruleKey());\n        // TODO warning - rules with status REMOVED are currently ignored, but should not\n        if (rule != null) {\n          shouldSentNotification.put(issue, rule);\n        }\n      }\n    }\n    if (!shouldSentNotification.isEmpty()) {\n      notifications.sendChanges(shouldSentNotification, context, project, null);\n    }\n    if (newIssues > 0) {\n      notifications.sendNewIssues(project, newIssues);\n    }\n  }","id":38182,"modified_method":"private void sendNotifications(Project project) {\n    IssuesBySeverity newIssues = new IssuesBySeverity();\n    IssueChangeContext context = IssueChangeContext.createScan(project.getAnalysisDate());\n    Map<DefaultIssue, Rule> shouldSentNotification = new LinkedHashMap<DefaultIssue, Rule>();\n    for (DefaultIssue issue : issueCache.all()) {\n      if (issue.isNew() && issue.resolution() == null) {\n        newIssues.add(issue);\n      }\n      if (!issue.isNew() && issue.isChanged() && issue.mustSendNotifications()) {\n        Rule rule = ruleFinder.findByKey(issue.ruleKey());\n        // TODO warning - rules with status REMOVED are currently ignored, but should not\n        if (rule != null) {\n          shouldSentNotification.put(issue, rule);\n        }\n      }\n    }\n    if (!shouldSentNotification.isEmpty()) {\n      notifications.sendChanges(shouldSentNotification, context, project, null);\n    }\n    if (newIssues.size() > 0) {\n      notifications.sendNewIssues(project, newIssues);\n    }\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_send_notif_if_new_issues() throws Exception {\n    when(project.getAnalysisDate()).thenReturn(DateUtils.parseDate(\"2013-05-18\"));\n    when(issueCache.all()).thenReturn(Arrays.asList(\n      new DefaultIssue().setNew(true),\n      new DefaultIssue().setNew(false)\n      ));\n\n    SendIssueNotificationsPostJob job = new SendIssueNotificationsPostJob(issueCache, notifications, ruleFinder);\n    job.executeOn(project, sensorContext);\n\n    verify(notifications).sendNewIssues(project, 1);\n  }","id":38183,"modified_method":"@Test\n  public void should_send_notif_if_new_issues() throws Exception {\n    when(project.getAnalysisDate()).thenReturn(DateUtils.parseDate(\"2013-05-18\"));\n    when(issueCache.all()).thenReturn(Arrays.asList(\n      new DefaultIssue().setNew(true).setSeverity(\"MAJOR\"),\n      new DefaultIssue().setNew(false).setSeverity(\"MINOR\")\n      ));\n\n    SendIssueNotificationsPostJob job = new SendIssueNotificationsPostJob(issueCache, notifications, ruleFinder);\n    job.executeOn(project, sensorContext);\n\n    ArgumentCaptor<IssuesBySeverity> argument = ArgumentCaptor.forClass(IssuesBySeverity.class);\n    verify(notifications).sendNewIssues(eq(project), argument.capture());\n    assertThat(argument.getValue().size()).isEqualTo(1);\n  }","commit_id":"b4b3b848a8e671a08ecb0fd9941714696efc822b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected DebugInfo readCache(SModelDescriptor sm) {\n    LOG.warning(\"Should not use readCache method since it may cause a deadlock.\\nSee MPS-13899\", new RuntimeException());\n    return readCache(sm, sm.getModule());\n  }","id":38184,"modified_method":"@Override\n  protected DebugInfo readCache(SModelDescriptor sm) {\n    if (log.isWarnEnabled()) {\n      log.warn(\"Should not use readCache method since it may cause a deadlock.\\nSee MPS-13899\", new RuntimeException());\n    }\n    return readCache(sm, sm.getModule());\n  }","commit_id":"23d52c4a03301d2b50b39445bfaa38e1fb18b40e","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private DebugInfo loadCacheFromUrl(@Nullable URL url, @NotNull SModelDescriptor sm) {\n    if (url == null) {\n      return null;\n    }\n    IFile file = TraceInfoCache.getFileByURL(url);\n    if (file != null) {\n      myFilesToModels.put(file, sm);\n    }\n    InputStream stream = null;\n    try {\n      stream = url.openStream();\n      if (stream == null) {\n        return null;\n      }\n      return load(stream);\n    } catch (IOException e) {\n      return null;\n    } finally {\n      try {\n        if (stream != null) {\n          stream.close();\n        }\n      } catch (IOException e) {\n        LOG.error(e);\n      }\n    }\n  }","id":38185,"modified_method":"@Nullable\n  private DebugInfo loadCacheFromUrl(@Nullable URL url, @NotNull SModelDescriptor sm) {\n    if (url == null) {\n      return null;\n    }\n    IFile file = TraceInfoCache.getFileByURL(url);\n    if (file != null) {\n      myFilesToModels.put(file, sm);\n    }\n    InputStream stream = null;\n    try {\n      stream = url.openStream();\n      if (stream == null) {\n        return null;\n      }\n      return load(stream);\n    } catch (IOException e) {\n      return null;\n    } finally {\n      try {\n        if (stream != null) {\n          stream.close();\n        }\n      } catch (IOException e) {\n        if (log.isErrorEnabled()) {\n          log.error(\"\", e);\n        }\n      }\n    }\n  }","commit_id":"23d52c4a03301d2b50b39445bfaa38e1fb18b40e","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Handles client handshake response.\n     *\n     * @param msg A handshake response.\n     * @throws GridClientHandshakeException If handshake failed.\n     */\n    private void handleHandshakeResponse(GridClientHandshakeResponse msg) throws GridClientHandshakeException {\n        byte rc = msg.resultCode();\n\n        if (rc != GridClientHandshakeResponse.OK.resultCode()) {\n            if (rc == GridClientHandshakeResponse.ERR_VERSION_CHECK_FAILED.resultCode())\n                log.warning(\"Client and server versions are different (see server log for more details).\");\n            else if (rc == GridClientHandshakeResponse.ERR_UNKNOWN_PROTO_ID.resultCode())\n                throw new GridClientHandshakeException(rc, \"Unknown/unsupported protocol ID.\");\n            else\n                throw new GridClientHandshakeException(rc,\n                    \"Handshake failed due to internal error (see server log for more details).\");\n        }\n    }","id":38186,"modified_method":"/**\n     * Handles client handshake response.\n     *\n     * @param msg A handshake response.\n     * @throws GridClientHandshakeException If handshake failed.\n     */\n    private void handleHandshakeResponse(GridClientHandshakeResponse msg) throws GridClientHandshakeException {\n        byte rc = msg.resultCode();\n\n        if (rc != GridClientHandshakeResponse.OK.resultCode()) {\n            if (rc == GridClientHandshakeResponse.ERR_UNKNOWN_PROTO_ID.resultCode())\n                throw new GridClientHandshakeException(rc, \"Unknown/unsupported protocol ID.\");\n            else\n                throw new GridClientHandshakeException(rc,\n                    \"Handshake failed due to internal error (see server log for more details).\");\n        }\n    }","commit_id":"a9756cbf0294e3a316d871d2af2e18e547ffa782","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @SuppressWarnings(\"ConstantConditions\")\n    @Override public void onMessage(final GridNioSession ses, final GridClientMessage msg) {\n        if (msg instanceof GridMemcachedMessage)\n            memcachedLsnr.onMessage(ses, (GridMemcachedMessage)msg);\n        else {\n            if (msg == GridClientPingPacket.PING_MESSAGE)\n                ses.send(GridClientPingPacket.PING_MESSAGE);\n            else if (msg instanceof GridClientHandshakeRequest) {\n                GridClientHandshakeResponse res = null;\n\n                GridClientHandshakeRequest hs = (GridClientHandshakeRequest)msg;\n\n                byte[] verBytes = hs.versionBytes();\n\n                if (!Arrays.equals(VER_BYTES, verBytes)) {\n                    log.warning(\"Client version check failed [ses=\" + ses +\n                        \", expected=\" + Arrays.toString(VER_BYTES)\n                        + \", actual=\" + Arrays.toString(verBytes) + ']');\n\n                    res = GridClientHandshakeResponse.ERR_VERSION_CHECK_FAILED;\n                }\n\n                GridClientMarshaller marsh = suppMarshMap.get(hs.protocolId());\n\n                if (marsh == null) {\n                    log.error(\"No marshaller found with given protocol ID [protocolId=\" + hs.protocolId() + ']');\n\n                    ses.send(GridClientHandshakeResponse.ERR_UNKNOWN_PROTO_ID).listenAsync(\n                        new CI1<GridNioFuture<?>>() {\n                            @Override public void apply(GridNioFuture<?> fut) {\n                                ses.close();\n                            }\n                        });\n\n                    return;\n                }\n\n                ses.addMeta(GridNioSessionMetaKey.MARSHALLER.ordinal(), marsh);\n\n                ses.send(res == null ? GridClientHandshakeResponse.OK : res);\n            }\n            else {\n                final GridRestRequest req = createRestRequest(msg);\n\n                if (req != null)\n                    hnd.handleAsync(req).listenAsync(new CI1<GridFuture<GridRestResponse>>() {\n                        @Override public void apply(GridFuture<GridRestResponse> fut) {\n                            GridClientResponse res = new GridClientResponse();\n\n                            res.requestId(msg.requestId());\n                            res.clientId(msg.clientId());\n\n                            try {\n                                GridRestResponse restRes = fut.get();\n\n                                res.sessionToken(restRes.sessionTokenBytes());\n                                res.successStatus(restRes.getSuccessStatus());\n                                res.errorMessage(restRes.getError());\n\n                                Object o = restRes.getResponse();\n\n                                // In case of metrics a little adjustment is needed.\n                                if (o instanceof GridCacheRestMetrics)\n                                    o = ((GridCacheRestMetrics)o).map();\n\n                                res.result(o);\n                            }\n                            catch (GridException e) {\n                                U.error(log, \"Failed to process client request: \" + msg, e);\n\n                                res.successStatus(GridClientResponse.STATUS_FAILED);\n                                res.errorMessage(\"Failed to process client request: \" + e.getMessage());\n                            }\n\n                            ses.send(res);\n                        }\n                    });\n                else\n                    U.error(log, \"Failed to process client request (unknown packet type) [ses=\" + ses +\n                        \", msg=\" + msg + ']');\n            }\n        }\n    }","id":38187,"modified_method":"/** {@inheritDoc} */\n    @SuppressWarnings(\"ConstantConditions\")\n    @Override public void onMessage(final GridNioSession ses, final GridClientMessage msg) {\n        if (msg instanceof GridMemcachedMessage)\n            memcachedLsnr.onMessage(ses, (GridMemcachedMessage)msg);\n        else {\n            if (msg == GridClientPingPacket.PING_MESSAGE)\n                ses.send(GridClientPingPacket.PING_MESSAGE);\n            else if (msg instanceof GridClientHandshakeRequest) {\n                GridClientHandshakeRequest hs = (GridClientHandshakeRequest)msg;\n\n                byte[] verBytes = hs.versionBytes();\n\n                if (!Arrays.equals(VER_BYTES, verBytes))\n                    U.warn(log, \"Client version check failed [ses=\" + ses +\n                        \", expected=\" + Arrays.toString(VER_BYTES)\n                        + \", actual=\" + Arrays.toString(verBytes) + ']');\n\n                GridClientMarshaller marsh = suppMarshMap.get(hs.protocolId());\n\n                if (marsh == null) {\n                    log.error(\"No marshaller found with given protocol ID [protocolId=\" + hs.protocolId() + ']');\n\n                    ses.send(GridClientHandshakeResponse.ERR_UNKNOWN_PROTO_ID).listenAsync(\n                        new CI1<GridNioFuture<?>>() {\n                            @Override public void apply(GridNioFuture<?> fut) {\n                                ses.close();\n                            }\n                        });\n\n                    return;\n                }\n\n                ses.addMeta(GridNioSessionMetaKey.MARSHALLER.ordinal(), marsh);\n\n                ses.send(GridClientHandshakeResponse.OK);\n            }\n            else {\n                final GridRestRequest req = createRestRequest(msg);\n\n                if (req != null)\n                    hnd.handleAsync(req).listenAsync(new CI1<GridFuture<GridRestResponse>>() {\n                        @Override public void apply(GridFuture<GridRestResponse> fut) {\n                            GridClientResponse res = new GridClientResponse();\n\n                            res.requestId(msg.requestId());\n                            res.clientId(msg.clientId());\n\n                            try {\n                                GridRestResponse restRes = fut.get();\n\n                                res.sessionToken(restRes.sessionTokenBytes());\n                                res.successStatus(restRes.getSuccessStatus());\n                                res.errorMessage(restRes.getError());\n\n                                Object o = restRes.getResponse();\n\n                                // In case of metrics a little adjustment is needed.\n                                if (o instanceof GridCacheRestMetrics)\n                                    o = ((GridCacheRestMetrics)o).map();\n\n                                res.result(o);\n                            }\n                            catch (GridException e) {\n                                U.error(log, \"Failed to process client request: \" + msg, e);\n\n                                res.successStatus(GridClientResponse.STATUS_FAILED);\n                                res.errorMessage(\"Failed to process client request: \" + e.getMessage());\n                            }\n\n                            ses.send(res);\n                        }\n                    });\n                else\n                    U.error(log, \"Failed to process client request (unknown packet type) [ses=\" + ses +\n                        \", msg=\" + msg + ']');\n            }\n        }\n    }","commit_id":"a9756cbf0294e3a316d871d2af2e18e547ffa782","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @SuppressWarnings(\"TypeMayBeWeakened\")\n    @Override public void onMessage(final GridNioSession ses, final GridClientMessage msg) {\n        if (msg instanceof GridRouterRequest) {\n            GridRouterRequest routerMsg = (GridRouterRequest)msg;\n\n            final UUID clientId = routerMsg.clientId();\n            final long reqId = routerMsg.requestId();\n\n            try {\n                byte protoId = GridClientProtobufMarshaller.PROTOCOL_ID;\n\n                GridClientMarshaller marsh = ses.meta(MARSHALLER.ordinal());\n\n                if (marsh != null)\n                    protoId = marsh.getProtocolId();\n                else\n                    U.warn(log, \"No marshaller defined for session, using default PROTOBUF [ses=\" + ses + ']');\n\n                client.forwardMessage(routerMsg, routerMsg.destinationId(), protoId)\n                    .listenAsync(new GridClientFutureListener() {\n                        @Override public void onDone(GridClientFuture fut) {\n                            try {\n                                GridRouterResponse res = (GridRouterResponse)fut.get();\n                                // Restoring original request id, because it was overwritten by the client.\n                                res.requestId(reqId);\n\n                                ses.send(res);\n                            }\n                            catch (GridClientException e) {\n                                ses.send(makeFailureResponse(e, clientId, reqId));\n                            }\n                        }\n                    });\n            }\n            catch (GridClientException e) {\n                ses.send(makeFailureResponse(e, clientId, reqId));\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n\n                U.warn(\n                    log,\n                    \"Message forwarding was interrupted (will ignore last message): \" + e.getMessage(),\n                    \"Message forwarding was interrupted.\");\n            }\n        }\n        else if (msg instanceof GridClientHandshakeRequest) {\n            GridClientHandshakeResponse res = null;\n\n            GridClientHandshakeRequest hs = (GridClientHandshakeRequest)msg;\n\n            byte[] verBytes = hs.versionBytes();\n\n            if (!Arrays.equals(VER_BYTES, verBytes)) {\n                U.warn(log, \"Client version check failed [ses=\" + ses +\n                    \", expected=\" + Arrays.toString(VER_BYTES)\n                    + \", actual=\" + Arrays.toString(verBytes) + ']');\n\n                res = GridClientHandshakeResponse.ERR_VERSION_CHECK_FAILED;\n            }\n\n            final byte protoId = hs.protocolId();\n\n            GridClientMarshaller marsh = suppMarshMap.get(protoId);\n\n            if (marsh == null) {\n                U.warn(log,\n                    \"No marshaller found for a given protocol ID (will use a stub): \" + protoId);\n\n                // Use a marshaller stub to just save protocol ID.\n                ses.addMeta(MARSHALLER.ordinal(), new GridClientMarshaller() {\n                    @Override public byte[] marshal(Object obj) {\n                        U.warn(log, \"Attempt to marshal a message with a stub \" +\n                            \"(will output empty result): \" + obj);\n\n                        return ArrayUtils.EMPTY_BYTE_ARRAY;\n                    }\n\n                    @Override public <T> T unmarshal(byte[] bytes) {\n                        assert false : \"Attempt to unmarshal a message with a stub.\";\n\n                        return null;\n                    }\n\n                    @Override public byte getProtocolId() {\n                        return protoId;\n                    }\n                });\n            }\n            else\n                ses.addMeta(MARSHALLER.ordinal(), marsh);\n\n            ses.send(res == null ? GridClientHandshakeResponse.OK : res);\n        }\n        else if (msg instanceof GridClientPingPacket)\n            ses.send(GridClientPingPacket.PING_MESSAGE);\n        else\n            throw new IllegalArgumentException(\"Unsupported input message: \" + msg);\n    }","id":38188,"modified_method":"/** {@inheritDoc} */\n    @SuppressWarnings(\"TypeMayBeWeakened\")\n    @Override public void onMessage(final GridNioSession ses, final GridClientMessage msg) {\n        if (msg instanceof GridRouterRequest) {\n            GridRouterRequest routerMsg = (GridRouterRequest)msg;\n\n            final UUID clientId = routerMsg.clientId();\n            final long reqId = routerMsg.requestId();\n\n            try {\n                byte protoId = GridClientProtobufMarshaller.PROTOCOL_ID;\n\n                GridClientMarshaller marsh = ses.meta(MARSHALLER.ordinal());\n\n                if (marsh != null)\n                    protoId = marsh.getProtocolId();\n                else\n                    U.warn(log, \"No marshaller defined for session, using default PROTOBUF [ses=\" + ses + ']');\n\n                client.forwardMessage(routerMsg, routerMsg.destinationId(), protoId)\n                    .listenAsync(new GridClientFutureListener() {\n                        @Override public void onDone(GridClientFuture fut) {\n                            try {\n                                GridRouterResponse res = (GridRouterResponse)fut.get();\n                                // Restoring original request id, because it was overwritten by the client.\n                                res.requestId(reqId);\n\n                                ses.send(res);\n                            }\n                            catch (GridClientException e) {\n                                ses.send(makeFailureResponse(e, clientId, reqId));\n                            }\n                        }\n                    });\n            }\n            catch (GridClientException e) {\n                ses.send(makeFailureResponse(e, clientId, reqId));\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n\n                U.warn(\n                    log,\n                    \"Message forwarding was interrupted (will ignore last message): \" + e.getMessage(),\n                    \"Message forwarding was interrupted.\");\n            }\n        }\n        else if (msg instanceof GridClientHandshakeRequest) {\n            GridClientHandshakeRequest hs = (GridClientHandshakeRequest)msg;\n\n            byte[] verBytes = hs.versionBytes();\n\n            if (!Arrays.equals(VER_BYTES, verBytes))\n                U.warn(log, \"Client version check failed [ses=\" + ses +\n                    \", expected=\" + Arrays.toString(VER_BYTES)\n                    + \", actual=\" + Arrays.toString(verBytes) + ']');\n\n            final byte protoId = hs.protocolId();\n\n            GridClientMarshaller marsh = suppMarshMap.get(protoId);\n\n            if (marsh == null) {\n                U.warn(log,\n                    \"No marshaller found for a given protocol ID (will use a stub): \" + protoId);\n\n                // Use a marshaller stub to just save protocol ID.\n                ses.addMeta(MARSHALLER.ordinal(), new GridClientMarshaller() {\n                    @Override public byte[] marshal(Object obj) {\n                        U.warn(log, \"Attempt to marshal a message with a stub \" +\n                            \"(will output empty result): \" + obj);\n\n                        return ArrayUtils.EMPTY_BYTE_ARRAY;\n                    }\n\n                    @Override public <T> T unmarshal(byte[] bytes) {\n                        assert false : \"Attempt to unmarshal a message with a stub.\";\n\n                        return null;\n                    }\n\n                    @Override public byte getProtocolId() {\n                        return protoId;\n                    }\n                });\n            }\n            else\n                ses.addMeta(MARSHALLER.ordinal(), marsh);\n\n            ses.send(GridClientHandshakeResponse.OK);\n        }\n        else if (msg instanceof GridClientPingPacket)\n            ses.send(GridClientPingPacket.PING_MESSAGE);\n        else\n            throw new IllegalArgumentException(\"Unsupported input message: \" + msg);\n    }","commit_id":"a9756cbf0294e3a316d871d2af2e18e547ffa782","url":"https://github.com/apache/ignite"},{"original_method":"/**\n   * Returns the DOM object associated with the user\n   * NOTE: This should be made more effecient through caching\n   * @return DOM object associated with the user\n   */\n  private Document getUserXML () {\n    // Get the fullname of the current user\n    String fullName = (String)staticData.getPerson().getFullName();\n    // Get a new DOM instance\n    Document doc = DocumentFactory.getNewDocument();\n    // Create <header> element\n    Element headerEl = doc.createElement(\"header\");\n    // Create <full-name> element under <header>\n    Element fullNameEl = doc.createElement(\"full-name\");\n    fullNameEl.appendChild(doc.createTextNode(fullName));\n    headerEl.appendChild(fullNameEl);\n    // Create <timestamp-long> element under <header>\n    Element timeStampLongEl = doc.createElement(\"timestamp-long\");\n    timeStampLongEl.appendChild(doc.createTextNode(getDate(\"EEEE, MMM d, yyyy 'at' hh:mm a\")));\n    headerEl.appendChild(timeStampLongEl);\n    // Create <timestamp-short> element under <header>\n    Element timeStampShortEl = doc.createElement(\"timestamp-short\");\n    timeStampShortEl.appendChild(doc.createTextNode(getDate(\"M.d.y h:mm a\")));\n    headerEl.appendChild(timeStampShortEl);\n    // Don't render the publish, subscribe, user preferences links if it's the guest user\n    if (!staticData.getPerson().isGuest()) {\n      Context globalIDContext = null;\n      try {\n        // Get the context that holds the global IDs for this user\n        globalIDContext = (Context)staticData.getJNDIContext().lookup(\"/channel-ids\");\n      } catch (NotContextException nce) {\n        LogService.instance().log(LogService.ERROR, \"CHeader.getUserXML(): Could not find subcontext /channel-ids in JNDI\");\n      } catch (NamingException e) {\n        LogService.instance().log(LogService.ERROR, e);\n      }\n      try {\n        if (canUserPublish()) {\n          // Create <chan-mgr-chanid> element under <header>\n          Element chanMgrChanidEl = doc.createElement(\"chan-mgr-chanid\");\n          chanMgrChanidEl.appendChild(doc.createTextNode((String)globalIDContext.lookup(\"/portal/channelmanager/general\")));\n          headerEl.appendChild(chanMgrChanidEl);\n        }\n      } catch (NotContextException nce) {\n        LogService.instance().log(LogService.ERROR, \"CHeader.getUserXML(): Could not find channel ID for fname=/portal/channelmanager/general for UID=\"\n            + staticData.getPerson().getID() + \". Be sure that the channel is in their layout.\");\n      } catch (NamingException e) {\n        LogService.instance().log(LogService.ERROR, e);\n      }\n      try {\n        // Create <preferences-chanid> element under <header>\n        Element preferencesChanidEl = doc.createElement(\"preferences-chanid\");\n        preferencesChanidEl.appendChild(doc.createTextNode((String)globalIDContext.lookup(\"/portal/userpreferences/general\")));\n        headerEl.appendChild(preferencesChanidEl);\n      } catch (NotContextException nce) {\n        LogService.instance().log(LogService.ERROR, \"CHeader.getUserXML(): Could not find channel ID for fname=/portal/userpreferences/general for UID=\"\n            + staticData.getPerson().getID() + \". Be sure that the channel is in their layout.\");\n      } catch (NamingException e) {\n        LogService.instance().log(LogService.ERROR, e);\n      }\n    }\n    doc.appendChild(headerEl);\n    return  (doc);\n  }","id":38189,"modified_method":"/**\n   * Returns the DOM object associated with the user\n   * NOTE: This should be made more effecient through caching\n   * @return DOM object associated with the user\n   */\n  private Document getUserXML () {\n    // Get the fullname of the current user\n    String fullName = (String)staticData.getPerson().getFullName();\n    // Get a new DOM instance\n    Document doc = DocumentFactory.getNewDocument();\n    // Create <header> element\n    Element headerEl = doc.createElement(\"header\");\n    // Create <full-name> element under <header>\n    Element fullNameEl = doc.createElement(\"full-name\");\n    fullNameEl.appendChild(doc.createTextNode(fullName));\n    headerEl.appendChild(fullNameEl);\n    // Create <timestamp-long> element under <header>\n    Element timeStampLongEl = doc.createElement(\"timestamp-long\");\n    timeStampLongEl.appendChild(doc.createTextNode(getDate(\"EEEE, MMM d, yyyy 'at' hh:mm a\")));\n    headerEl.appendChild(timeStampLongEl);\n    // Create <timestamp-short> element under <header>\n    Element timeStampShortEl = doc.createElement(\"timestamp-short\");\n    timeStampShortEl.appendChild(doc.createTextNode(getDate(\"M.d.y h:mm a\")));\n    headerEl.appendChild(timeStampShortEl);\n    // Don't render the publish, subscribe, user preferences links if it's the guest user\n    if (!staticData.getPerson().getSecurityContext().isAuthenticated()) {\n      Context globalIDContext = null;\n      try {\n        // Get the context that holds the global IDs for this user\n        globalIDContext = (Context)staticData.getJNDIContext().lookup(\"/channel-ids\");\n      } catch (NotContextException nce) {\n        LogService.instance().log(LogService.ERROR, \"CHeader.getUserXML(): Could not find subcontext /channel-ids in JNDI\");\n      } catch (NamingException e) {\n        LogService.instance().log(LogService.ERROR, e);\n      }\n      try {\n        if (canUserPublish()) {\n          // Create <chan-mgr-chanid> element under <header>\n          Element chanMgrChanidEl = doc.createElement(\"chan-mgr-chanid\");\n          chanMgrChanidEl.appendChild(doc.createTextNode((String)globalIDContext.lookup(\"/portal/channelmanager/general\")));\n          headerEl.appendChild(chanMgrChanidEl);\n        }\n      } catch (NotContextException nce) {\n        LogService.instance().log(LogService.ERROR, \"CHeader.getUserXML(): Could not find channel ID for fname=/portal/channelmanager/general for UID=\"\n            + staticData.getPerson().getID() + \". Be sure that the channel is in their layout.\");\n      } catch (NamingException e) {\n        LogService.instance().log(LogService.ERROR, e);\n      }\n      try {\n        // Create <preferences-chanid> element under <header>\n        Element preferencesChanidEl = doc.createElement(\"preferences-chanid\");\n        preferencesChanidEl.appendChild(doc.createTextNode((String)globalIDContext.lookup(\"/portal/userpreferences/general\")));\n        headerEl.appendChild(preferencesChanidEl);\n      } catch (NotContextException nce) {\n        LogService.instance().log(LogService.ERROR, \"CHeader.getUserXML(): Could not find channel ID for fname=/portal/userpreferences/general for UID=\"\n            + staticData.getPerson().getID() + \". Be sure that the channel is in their layout.\");\n      } catch (NamingException e) {\n        LogService.instance().log(LogService.ERROR, e);\n      }\n    }\n    doc.appendChild(headerEl);\n    return  (doc);\n  }","commit_id":"b12b54cabe9ce0d489b77b62e04152e5602d41ec","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * put your documentation comment here\n   * @return ChannelCacheKey\n   */\n  public ChannelCacheKey generateKey () {\n    ChannelCacheKey k = new ChannelCacheKey();\n    StringBuffer sbKey = new StringBuffer(1024);\n    // guest pages are cached system-wide\n    k.setKeyScope(ChannelCacheKey.SYSTEM_KEY_SCOPE);\n    sbKey.append(\"org.jasig.portal.CHeader: \");\n    sbKey.append(\"userId:\").append(staticData.getPerson().getID()).append(\", \");\n    sbKey.append(\"baseActionURL:\").append(runtimeData.getBaseActionURL());\n    sbKey.append(\"stylesheetURI:\");\n    try {\n      String sslUri = ResourceLoader.getResourceAsURLString(this.getClass(), sslLocation);\n      sbKey.append(XSLT.getStylesheetURI(sslUri, runtimeData.getBrowserInfo()));\n    } catch (Exception e) {\n      sbKey.append(\"not defined\");\n    }\n    k.setKey(sbKey.toString());\n    k.setKeyValidity(new Long(System.currentTimeMillis()));\n    return  k;\n  }","id":38190,"modified_method":"/**\n   * put your documentation comment here\n   * @return ChannelCacheKey\n   */\n  public ChannelCacheKey generateKey () {\n    ChannelCacheKey k = new ChannelCacheKey();\n    StringBuffer sbKey = new StringBuffer(1024);\n\n    sbKey.append(\"org.jasig.portal.CHeader: \");\n\n    if(staticData.getPerson().isGuest()) {\n        // guest users are cached system-wide. \n        k.setKeyScope(ChannelCacheKey.SYSTEM_KEY_SCOPE);\n        sbKey.append(\"userId:\").append(staticData.getPerson().getID()).append(\", \");\n    } else {\n        // otherwise cache is instance-specific\n        k.setKeyScope(ChannelCacheKey.INSTANCE_KEY_SCOPE);\n    }\n    sbKey.append(\"authenticated:\").append(staticData.getPerson().getSecurityContext().isAuthenticated()).append(\", \");\n    sbKey.append(\"baseActionURL:\").append(runtimeData.getBaseActionURL());\n    sbKey.append(\"stylesheetURI:\");\n    try {\n      String sslUri = ResourceLoader.getResourceAsURLString(this.getClass(), sslLocation);\n      sbKey.append(XSLT.getStylesheetURI(sslUri, runtimeData.getBrowserInfo()));\n    } catch (Exception e) {\n      sbKey.append(\"not defined\");\n    }\n    k.setKey(sbKey.toString());\n    k.setKeyValidity(new Long(System.currentTimeMillis()));\n    return  k;\n  }","commit_id":"b12b54cabe9ce0d489b77b62e04152e5602d41ec","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * Render method.\n   * @param out\n   * @exception PortalException\n   */\n  public void renderXML (ContentHandler out) throws PortalException {\n    // Perform the transformation\n    XSLT xslt = new XSLT(this);\n    xslt.setXML(getUserXML());\n    xslt.setXSL(sslLocation, runtimeData.getBrowserInfo());\n    xslt.setTarget(out);\n    xslt.setStylesheetParameter(\"baseActionURL\", runtimeData.getBaseActionURL());\n    if (staticData.getPerson().isGuest()) {\n      xslt.setStylesheetParameter(\"guest\", \"true\");\n    }\n    xslt.transform();\n  }","id":38191,"modified_method":"/**\n   * Render method.\n   * @param out\n   * @exception PortalException\n   */\n  public void renderXML (ContentHandler out) throws PortalException {\n    // Perform the transformation\n    XSLT xslt = new XSLT(this);\n    xslt.setXML(getUserXML());\n    xslt.setXSL(sslLocation, runtimeData.getBrowserInfo());\n    xslt.setTarget(out);\n    xslt.setStylesheetParameter(\"baseActionURL\", runtimeData.getBaseActionURL());\n    if (staticData.getPerson().getSecurityContext().isAuthenticated()) {\n      xslt.setStylesheetParameter(\"authenticated\", \"true\");\n    }\n    xslt.transform();\n  }","commit_id":"b12b54cabe9ce0d489b77b62e04152e5602d41ec","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n   * put your documentation comment here\n   * @param validity\n   * @return true if cache is valid\n   */\n  public boolean isCacheValid (Object validity) {\n    if (validity instanceof Long) {\n      Long oldtime = (Long)validity;\n      if (staticData.getPerson().isGuest()) {\n        return  true;\n      }\n      if (System.currentTimeMillis() - oldtime.longValue() < 1*60*1000) {\n        return  true;\n      }\n    }\n    return  false;\n  }","id":38192,"modified_method":"/**\n   * put your documentation comment here\n   * @param validity\n   * @return true if cache is valid\n   */\n  public boolean isCacheValid (Object validity) {\n    if (validity instanceof Long) {\n      Long oldtime = (Long)validity;\n      if (!staticData.getPerson().getSecurityContext().isAuthenticated()) {\n        // cache entries for unauthenticated users don't expire\n        return  true;\n      }\n      if (System.currentTimeMillis() - oldtime.longValue() < 1*60*1000) {\n        return  true;\n      }\n    }\n    return  false;\n  }","commit_id":"eaec59f80187a6604a96faea480eddd8612e3034","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void renderXML (ContentHandler out) throws PortalException\n  {\n    String fullName = (String)staticData.getPerson().getFullName();\n    Document doc = new org.apache.xerces.dom.DocumentImpl();\n\n    // Create <login-status> element\n    Element loginStatusElement = doc.createElement(\"login-status\");\n\n    if (bSecurityError)\n    {\n      // Create <error> element under <login-status>\n      Element errorElement = doc.createElement(\"error\");\n      loginStatusElement.appendChild(errorElement);\n    }\n    else if (bauthenticationAttemptFailed && !bAuthenticated)\n    {\n      // Create <failure> element under <login-status>\n      Element failureElement = doc.createElement(\"failure\");\n      failureElement.setAttribute(\"attemptedUserName\", attemptedUserName);\n      loginStatusElement.appendChild(failureElement);\n    }\n    else if (fullName != null)\n    {\n      // Create <full-name> element under <header>\n      Element fullNameElement = doc.createElement(\"full-name\");\n      fullNameElement.appendChild(doc.createTextNode(fullName));\n      loginStatusElement.appendChild(fullNameElement);\n    }\n\n    doc.appendChild(loginStatusElement);\n\n    try\n    {\n      XSLT xslt = new XSLT(this);\n      xslt.setXML(doc);\n      xslt.setXSL(sslLocation, runtimeData.getBrowserInfo());\n      xslt.setTarget(out);\n      xslt.setStylesheetParameter(\"baseActionURL\", runtimeData.getBaseActionURL());\n      if (staticData.getPerson().isGuest()) {\n        xslt.setStylesheetParameter(\"guest\", \"true\");\n      }\n      xslt.transform();\n    }\n    catch (Exception e)\n    {\n      throw new GeneralRenderingException(e.getMessage());\n    }\n  }","id":38193,"modified_method":"public void renderXML (ContentHandler out) throws PortalException\n  {\n    String fullName = (String)staticData.getPerson().getFullName();\n    Document doc = new org.apache.xerces.dom.DocumentImpl();\n\n    // Create <login-status> element\n    Element loginStatusElement = doc.createElement(\"login-status\");\n\n    if (bSecurityError)\n    {\n      // Create <error> element under <login-status>\n      Element errorElement = doc.createElement(\"error\");\n      loginStatusElement.appendChild(errorElement);\n    }\n    else if (bauthenticationAttemptFailed && !bAuthenticated)\n    {\n      // Create <failure> element under <login-status>\n      Element failureElement = doc.createElement(\"failure\");\n      failureElement.setAttribute(\"attemptedUserName\", attemptedUserName);\n      loginStatusElement.appendChild(failureElement);\n    }\n    else if (fullName != null)\n    {\n      // Create <full-name> element under <header>\n      Element fullNameElement = doc.createElement(\"full-name\");\n      fullNameElement.appendChild(doc.createTextNode(fullName));\n      loginStatusElement.appendChild(fullNameElement);\n    }\n\n    doc.appendChild(loginStatusElement);\n\n    try\n    {\n      XSLT xslt = new XSLT(this);\n      xslt.setXML(doc);\n      xslt.setXSL(sslLocation, runtimeData.getBrowserInfo());\n      xslt.setTarget(out);\n      xslt.setStylesheetParameter(\"baseActionURL\", runtimeData.getBaseActionURL());\n      if (!staticData.getPerson().getSecurityContext().isAuthenticated()) {\n        xslt.setStylesheetParameter(\"unauthenticated\", \"true\");\n      }\n      xslt.transform();\n    }\n    catch (Exception e)\n    {\n      throw new GeneralRenderingException(e.getMessage());\n    }\n  }","commit_id":"eaec59f80187a6604a96faea480eddd8612e3034","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ChannelCacheKey generateKey() {\n    ChannelCacheKey k = new ChannelCacheKey();\n    StringBuffer sbKey = new StringBuffer(1024);\n    // guest pages are cached system-wide\n    if(staticData.getPerson().isGuest()) {\n      k.setKeyScope(ChannelCacheKey.SYSTEM_KEY_SCOPE);\n      sbKey.append(systemCacheId);\n    } else {\n      k.setKeyScope(ChannelCacheKey.INSTANCE_KEY_SCOPE);\n    }\n    sbKey.append(\"userId:\").append(staticData.getPerson().getID()).append(\", \");\n\n    if(xslUriForKey == null) {\n      try {\n        String sslUri = ResourceLoader.getResourceAsURLString(this.getClass(), sslLocation);\n        xslUriForKey=XSLT.getStylesheetURI(sslUri, runtimeData.getBrowserInfo());\n      } catch (PortalException pe) {\n        xslUriForKey = \"Not attainable!\";\n      }\n    }\n    sbKey.append(\"xslUri:\").append(xslUriForKey).append(\", \");\n    sbKey.append(\"bAuthenticated:\").append(bAuthenticated).append(\", \");\n    sbKey.append(\"bauthenticationAttemptFailed:\").append(bauthenticationAttemptFailed).append(\", \");\n    sbKey.append(\"attemptedUserName:\").append(attemptedUserName).append(\", \");\n    sbKey.append(\"bSecurityError:\").append(bSecurityError);\n    k.setKey(sbKey.toString());\n    k.setKeyValidity(new Long(System.currentTimeMillis()));\n    return k;\n  }","id":38194,"modified_method":"public ChannelCacheKey generateKey() {\n    ChannelCacheKey k = new ChannelCacheKey();\n    StringBuffer sbKey = new StringBuffer(1024);\n    // guest pages are cached system-wide\n    if(staticData.getPerson().isGuest()) {\n      k.setKeyScope(ChannelCacheKey.SYSTEM_KEY_SCOPE);\n      sbKey.append(systemCacheId);\n    } else {\n      k.setKeyScope(ChannelCacheKey.INSTANCE_KEY_SCOPE);\n    }\n    sbKey.append(\"userId:\").append(staticData.getPerson().getID()).append(\", \");\n    sbKey.append(\"authenticated:\").append(staticData.getPerson().getSecurityContext().isAuthenticated()).append(\", \");\n\n    if(xslUriForKey == null) {\n      try {\n        String sslUri = ResourceLoader.getResourceAsURLString(this.getClass(), sslLocation);\n        xslUriForKey=XSLT.getStylesheetURI(sslUri, runtimeData.getBrowserInfo());\n      } catch (PortalException pe) {\n        xslUriForKey = \"Not attainable!\";\n      }\n    }\n    sbKey.append(\"xslUri:\").append(xslUriForKey).append(\", \");\n    sbKey.append(\"bAuthenticated:\").append(bAuthenticated).append(\", \");\n    sbKey.append(\"bauthenticationAttemptFailed:\").append(bauthenticationAttemptFailed).append(\", \");\n    sbKey.append(\"attemptedUserName:\").append(attemptedUserName).append(\", \");\n    sbKey.append(\"bSecurityError:\").append(bSecurityError);\n    k.setKey(sbKey.toString());\n    k.setKeyValidity(new Long(System.currentTimeMillis()));\n    return k;\n  }","commit_id":"eaec59f80187a6604a96faea480eddd8612e3034","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected boolean doWorkOnMember( boolean isCore, int id )\n    {\n        SocketAddress address = backupAddress.apply( isCore, id );\n        File backupDirectory = new File( baseDirectory, Integer.toString( address.getPort() ) );\n\n        OnlineBackup backup;\n        try\n        {\n            backup = OnlineBackup.from( address.getHostname(), address.getPort() ).backup( backupDirectory );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( e.getCause() instanceof ConnectException )\n            {\n                // if we could not connect, wait a bit and try again...\n                LockSupport.parkNanos( 10_000_000 );\n                return true;\n            }\n            throw e;\n        }\n\n        boolean success = backup.isConsistent();\n        if ( !success )\n        {\n            System.err.println( \"Not consistent backup from \" + address );\n        }\n        return success;\n    }","id":38195,"modified_method":"@Override\n    protected void doWorkOnMember( boolean isCore, int id )\n    {\n        SocketAddress address = backupAddress.apply( isCore, id );\n        File backupDirectory = new File( baseDirectory, Integer.toString( address.getPort() ) );\n\n        OnlineBackup backup;\n        try\n        {\n            backup = OnlineBackup.from( address.getHostname(), address.getPort() ).backup( backupDirectory );\n        }\n        catch ( RuntimeException e )\n        {\n            if ( e.getCause() instanceof ConnectException )\n            {\n                // if we could not connect, wait a bit and try again...\n                LockSupport.parkNanos( 10_000_000 );\n                return;\n            }\n            throw e;\n        }\n\n        if ( !backup.isConsistent() )\n        {\n            throw new RuntimeException( \"Not consistent backup from \" + address );\n        }\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBehaveCorrectlyUnderStress() throws Exception\n    {\n        int numberOfCores =\n                parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_CORES\", DEFAULT_NUMBER_OF_CORES ) );\n        int numberOfEdges =\n                parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_EDGES\", DEFAULT_NUMBER_OF_EDGES ) );\n        long durationInMinutes =\n                parseLong( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_DURATION\", DEFAULT_DURATION_IN_MINUTES ) );\n        String workingDirectory =\n                fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_WORKING_DIRECTORY\", DEFAULT_WORKING_DIR );\n        int baseCoreBackupPort = parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_BASE_CORE_BACKUP_PORT\",\n                DEFAULT_BASE_CORE_BACKUP_PORT ) );\n        int baseEdgeBackupPort = parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_BASE_EDGE_BACKUP_PORT\",\n                DEFAULT_BASE_EDGE_BACKUP_PORT ) );\n\n        File clusterDirectory = ensureExistsAndEmpty( new File( workingDirectory, \"cluster\" ) );\n        File backupDirectory = ensureExistsAndEmpty( new File( workingDirectory, \"backups\" ) );\n\n        BiFunction<Boolean,Integer,SocketAddress> backupAddress = ( isCore, id ) ->\n                new AdvertisedSocketAddress( \"localhost\", (isCore ? baseCoreBackupPort : baseEdgeBackupPort) + id );\n\n        Map<String,String> coreParams =\n                configureRaftLogRotationAndPruning( configureTxLogRotationAndPruning( new HashMap<>() ) );\n        Map<String,String> edgeParams = configureTxLogRotationAndPruning( new HashMap<>() );\n\n        Map<String,IntFunction<String>> instanceCoreParams =\n                configureBackup( new HashMap<>(), id -> backupAddress.apply( true, id ) );\n        Map<String,IntFunction<String>> instanceEdgeParams =\n                configureBackup( new HashMap<>(), id -> backupAddress.apply( false, id ) );\n\n        HazelcastDiscoveryServiceFactory discoveryServiceFactory = new HazelcastDiscoveryServiceFactory();\n        Cluster cluster =\n                new Cluster( clusterDirectory, numberOfCores, numberOfEdges, discoveryServiceFactory, coreParams,\n                        instanceCoreParams, edgeParams, instanceEdgeParams, StandardV3_0.NAME );\n\n        AtomicBoolean stopTheWorld = new AtomicBoolean();\n        BooleanSupplier keepGoing =\n                () -> !stopTheWorld.get() && untilTimeExpired( durationInMinutes, TimeUnit.MINUTES ).getAsBoolean();\n        Runnable onFailure = () -> stopTheWorld.set( true );\n\n        ExecutorService service = Executors.newFixedThreadPool( 3 );\n        try\n        {\n            cluster.start();\n            Future<Boolean> workload = service.submit( new Workload( keepGoing, onFailure, cluster ) );\n            Future<Boolean> startStopWorker = service.submit( new StartStopLoad( keepGoing, onFailure, cluster ) );\n            Future<Boolean> backupWorker =\n                    service.submit( new BackupLoad( keepGoing, onFailure, cluster, backupDirectory, backupAddress ) );\n\n            assertTrue( workload.get() );\n            assertTrue( startStopWorker.get() );\n            assertTrue( backupWorker.get() );\n        }\n        finally\n        {\n            cluster.shutdown();\n        }\n\n        // let's cleanup disk space when everything went well\n        FileUtils.deleteRecursively( clusterDirectory );\n        FileUtils.deleteRecursively( backupDirectory );\n    }","id":38196,"modified_method":"@Test\n    public void shouldBehaveCorrectlyUnderStress() throws Exception\n    {\n        int numberOfCores =\n                parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_CORES\", DEFAULT_NUMBER_OF_CORES ) );\n        int numberOfEdges =\n                parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_EDGES\", DEFAULT_NUMBER_OF_EDGES ) );\n        long durationInMinutes =\n                parseLong( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_DURATION\", DEFAULT_DURATION_IN_MINUTES ) );\n        String workingDirectory =\n                fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_WORKING_DIRECTORY\", DEFAULT_WORKING_DIR );\n        int baseCoreBackupPort = parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_BASE_CORE_BACKUP_PORT\",\n                DEFAULT_BASE_CORE_BACKUP_PORT ) );\n        int baseEdgeBackupPort = parseInt( fromEnv( \"BACKUP_STORE_COPY_INTERACTION_STRESS_BASE_EDGE_BACKUP_PORT\",\n                DEFAULT_BASE_EDGE_BACKUP_PORT ) );\n\n        File clusterDirectory = ensureExistsAndEmpty( new File( workingDirectory, \"cluster\" ) );\n        File backupDirectory = ensureExistsAndEmpty( new File( workingDirectory, \"backups\" ) );\n\n        BiFunction<Boolean,Integer,SocketAddress> backupAddress = ( isCore, id ) ->\n                new AdvertisedSocketAddress( \"localhost\", (isCore ? baseCoreBackupPort : baseEdgeBackupPort) + id );\n\n        Map<String,String> coreParams =\n                configureRaftLogRotationAndPruning( configureTxLogRotationAndPruning( new HashMap<>() ) );\n        Map<String,String> edgeParams = configureTxLogRotationAndPruning( new HashMap<>() );\n\n        Map<String,IntFunction<String>> instanceCoreParams =\n                configureBackup( new HashMap<>(), id -> backupAddress.apply( true, id ) );\n        Map<String,IntFunction<String>> instanceEdgeParams =\n                configureBackup( new HashMap<>(), id -> backupAddress.apply( false, id ) );\n\n        HazelcastDiscoveryServiceFactory discoveryServiceFactory = new HazelcastDiscoveryServiceFactory();\n        Cluster cluster =\n                new Cluster( clusterDirectory, numberOfCores, numberOfEdges, discoveryServiceFactory, coreParams,\n                        instanceCoreParams, edgeParams, instanceEdgeParams, StandardV3_0.NAME );\n\n        AtomicBoolean stopTheWorld = new AtomicBoolean();\n        BooleanSupplier keepGoing =\n                () -> !stopTheWorld.get() && untilTimeExpired( durationInMinutes, TimeUnit.MINUTES ).getAsBoolean();\n        Runnable onFailure = () -> stopTheWorld.set( true );\n\n        ExecutorService service = Executors.newFixedThreadPool( 3 );\n        try\n        {\n            cluster.start();\n            Future<Throwable> workload = service.submit( new Workload( keepGoing, onFailure, cluster ) );\n            Future<Throwable> startStopWorker = service.submit( new StartStopLoad( keepGoing, onFailure, cluster ) );\n            Future<Throwable> backupWorker =\n                    service.submit( new BackupLoad( keepGoing, onFailure, cluster, backupDirectory, backupAddress ) );\n\n            assertNull( prettyPrintStackTrace( workload.get() ), workload.get() );\n            assertNull( prettyPrintStackTrace( startStopWorker.get() ), startStopWorker.get() );\n            assertNull( prettyPrintStackTrace( backupWorker.get() ), backupWorker.get() );\n        }\n        finally\n        {\n            cluster.shutdown();\n        }\n\n        // let's cleanup disk space when everything went well\n        FileUtils.deleteRecursively( clusterDirectory );\n        FileUtils.deleteRecursively( backupDirectory );\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected boolean doWork()\n    {\n        CoreClusterMember leader;\n        try\n        {\n            leader = cluster.awaitLeader();\n        }\n        catch ( TimeoutException e )\n        {\n            // whatever... we'll try again\n            return true;\n        }\n\n        long txIdBeforeStartingNewEdge = txId( leader );\n        int newMemberId = cluster.edgeMembers().size();\n        final EdgeClusterMember edgeClusterMember = cluster.addEdgeMemberWithId( newMemberId );\n\n        AtomicReference<Throwable> exception;\n        try\n        {\n            exception = startAndRegisterExceptionMonitor( edgeClusterMember );\n            await( () -> txIdBeforeStartingNewEdge <= txId( edgeClusterMember ), 3, TimeUnit.MINUTES );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            cluster.removeEdgeMemberWithMemberId( newMemberId );\n        }\n\n        if ( exception.get() != null )\n        {\n            throw new RuntimeException( exception.get() );\n        }\n\n        return true;\n    }","id":38197,"modified_method":"@Override\n    protected void doWork()\n    {\n        CoreClusterMember leader;\n        try\n        {\n            leader = cluster.awaitLeader();\n        }\n        catch ( TimeoutException e )\n        {\n            // whatever... we'll try again\n            return;\n        }\n\n        long txIdBeforeStartingNewEdge = txId( leader );\n        int newMemberId = cluster.edgeMembers().size();\n        final EdgeClusterMember edgeClusterMember = cluster.addEdgeMemberWithId( newMemberId );\n\n        AtomicReference<Throwable> exception;\n        try\n        {\n            exception = startAndRegisterExceptionMonitor( edgeClusterMember );\n            await( () -> txIdBeforeStartingNewEdge <= txId( edgeClusterMember ), 3, TimeUnit.MINUTES );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            cluster.removeEdgeMemberWithMemberId( newMemberId );\n        }\n\n        if ( exception.get() != null )\n        {\n            throw new RuntimeException( exception.get() );\n        }\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBehaveCorrectlyUnderStress() throws Exception\n    {\n        int numberOfCores =\n                parseInt( fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_CORES\", DEFAULT_NUMBER_OF_CORES ) );\n        int numberOfEdges =\n                parseInt( fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_EDGES\", DEFAULT_NUMBER_OF_EDGES ) );\n        long durationInMinutes =\n                parseLong( fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_DURATION\", DEFAULT_DURATION_IN_MINUTES ) );\n        String workingDirectory =\n                fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_WORKING_DIRECTORY\", DEFAULT_WORKING_DIR );\n\n        File clusterDirectory = ensureExistsAndEmpty( new File( workingDirectory, \"cluster\" ) );\n\n        Map<String,String> coreParams =\n                configureRaftLogRotationAndPruning( configureTxLogRotationAndPruning( new HashMap<>() ) );\n        Map<String,String> edgeParams = configureTxLogRotationAndPruning( new HashMap<>() );\n\n        HazelcastDiscoveryServiceFactory discoveryServiceFactory = new HazelcastDiscoveryServiceFactory();\n        Cluster cluster =\n                new Cluster( clusterDirectory, numberOfCores, numberOfEdges, discoveryServiceFactory, coreParams,\n                        emptyMap(), edgeParams, emptyMap(), StandardV3_0.NAME );\n\n        AtomicBoolean stopTheWorld = new AtomicBoolean();\n        BooleanSupplier keepGoing =\n                () -> !stopTheWorld.get() && untilTimeExpired( durationInMinutes, TimeUnit.MINUTES ).getAsBoolean();\n        Runnable onFailure = () -> stopTheWorld.set( true );\n\n        ExecutorService service = Executors.newFixedThreadPool( 3 );\n        try\n        {\n            cluster.start();\n            Future<Boolean> workload = service.submit( new Workload( keepGoing, onFailure, cluster ) );\n            Future<Boolean> startStopWorker = service.submit( new StartStopLoad( keepGoing, onFailure, cluster ) );\n            Future<Boolean> catchUpWorker = service.submit( new CatchUpLoad( keepGoing, onFailure, cluster ) );\n\n            assertTrue( workload.get() );\n            assertTrue( startStopWorker.get() );\n            assertTrue( catchUpWorker.get() );\n        }\n        finally\n        {\n            cluster.shutdown();\n        }\n\n        // let's cleanup disk space when everything went well\n        FileUtils.deleteRecursively( clusterDirectory );\n    }","id":38198,"modified_method":"@Test\n    public void shouldBehaveCorrectlyUnderStress() throws Exception\n    {\n        int numberOfCores =\n                parseInt( fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_CORES\", DEFAULT_NUMBER_OF_CORES ) );\n        int numberOfEdges =\n                parseInt( fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_NUMBER_OF_EDGES\", DEFAULT_NUMBER_OF_EDGES ) );\n        long durationInMinutes =\n                parseLong( fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_DURATION\", DEFAULT_DURATION_IN_MINUTES ) );\n        String workingDirectory =\n                fromEnv( \"CATCHUP_STORE_COPY_INTERACTION_STRESS_WORKING_DIRECTORY\", DEFAULT_WORKING_DIR );\n\n        File clusterDirectory = ensureExistsAndEmpty( new File( workingDirectory, \"cluster\" ) );\n\n        Map<String,String> coreParams =\n                configureRaftLogRotationAndPruning( configureTxLogRotationAndPruning( new HashMap<>() ) );\n        Map<String,String> edgeParams = configureTxLogRotationAndPruning( new HashMap<>() );\n\n        HazelcastDiscoveryServiceFactory discoveryServiceFactory = new HazelcastDiscoveryServiceFactory();\n        Cluster cluster =\n                new Cluster( clusterDirectory, numberOfCores, numberOfEdges, discoveryServiceFactory, coreParams,\n                        emptyMap(), edgeParams, emptyMap(), StandardV3_0.NAME );\n\n        AtomicBoolean stopTheWorld = new AtomicBoolean();\n        BooleanSupplier keepGoing =\n                () -> !stopTheWorld.get() && untilTimeExpired( durationInMinutes, TimeUnit.MINUTES ).getAsBoolean();\n        Runnable onFailure = () -> stopTheWorld.set( true );\n\n        ExecutorService service = Executors.newFixedThreadPool( 3 );\n        try\n        {\n            cluster.start();\n            Future<Throwable> workload = service.submit( new Workload( keepGoing, onFailure, cluster ) );\n            Future<Throwable> startStopWorker = service.submit( new StartStopLoad( keepGoing, onFailure, cluster ) );\n            Future<Throwable> catchUpWorker = service.submit( new CatchUpLoad( keepGoing, onFailure, cluster ) );\n\n            assertNull( prettyPrintStackTrace( workload.get() ), workload.get() );\n            assertNull( prettyPrintStackTrace( startStopWorker.get() ), startStopWorker.get() );\n            assertNull( prettyPrintStackTrace( catchUpWorker.get() ), catchUpWorker.get() );\n        }\n        finally\n        {\n            cluster.shutdown();\n        }\n\n        // let's cleanup disk space when everything went well\n        FileUtils.deleteRecursively( clusterDirectory );\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected abstract boolean doWork();","id":38199,"modified_method":"protected abstract void doWork();","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public final Boolean call()\n    {\n        try\n        {\n            boolean success = true;\n            while ( keepGoing.getAsBoolean() )\n            {\n                success &= doWork();\n                if ( !success )\n                {\n                    onFailure.run();\n                }\n            }\n            return success;\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            onFailure.run();\n            return false;\n        }\n    }","id":38200,"modified_method":"@Override\n    public final Throwable call()\n    {\n        try\n        {\n            while ( keepGoing.getAsBoolean() )\n            {\n                doWork();\n            }\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            onFailure.run();\n            return t;\n        }\n\n        return null;\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected abstract boolean doWorkOnMember( boolean isCore, int id );","id":38201,"modified_method":"protected abstract void doWorkOnMember( boolean isCore, int id );","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected final boolean doWork()\n    {\n        boolean isCore = onlyCores || random.nextBoolean();\n        Collection<? extends ClusterMember> members = isCore ? cluster.coreMembers() : cluster.edgeMembers();\n        if ( members.isEmpty() )\n        {\n            return true;\n        }\n        int id = random.nextInt( members.size() );\n        return doWorkOnMember( isCore, id );\n    }","id":38202,"modified_method":"@Override\n    protected final void doWork()\n    {\n        boolean isCore = onlyCores || random.nextBoolean();\n        Collection<? extends ClusterMember> members = isCore ? cluster.coreMembers() : cluster.edgeMembers();\n        if ( members.isEmpty() )\n        {\n            return;\n        }\n        int id = random.nextInt( members.size() );\n        doWorkOnMember( isCore, id );\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected boolean doWorkOnMember( boolean isCore, int id )\n    {\n        ClusterMember member = isCore ? cluster.getCoreMemberById( id ) : cluster.getEdgeMemberById( id );\n        member.shutdown();\n        LockSupport.parkNanos( 5_000_000_000L );\n        member.start();\n        return true;\n    }","id":38203,"modified_method":"@Override\n    protected void doWorkOnMember( boolean isCore, int id )\n    {\n        ClusterMember member = isCore ? cluster.getCoreMemberById( id ) : cluster.getEdgeMemberById( id );\n        member.shutdown();\n        LockSupport.parkNanos( 5_000_000_000L );\n        member.start();\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected boolean doWork()\n    {\n        try\n        {\n            cluster.coreTx( ( db, tx ) ->\n            {\n                Node node = db.createNode();\n                node.setProperty( \"prop1\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop2\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop3\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop4\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop5\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop6\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop7\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop8\", \"let's add some data here so the transaction logs rotate more often...\" );\n                tx.success();\n            } );\n        }\n        catch ( InterruptedException e )\n        {\n            // whatever let's go on with the workload\n            Thread.interrupted();\n        }\n        catch ( TimeoutException | DatabaseShutdownException e )\n        {\n            // whatever let's go on with the workload\n        }\n        return true;\n    }","id":38204,"modified_method":"@Override\n    protected void doWork()\n    {\n        try\n        {\n            cluster.coreTx( ( db, tx ) ->\n            {\n                Node node = db.createNode();\n                node.setProperty( \"prop1\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop2\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop3\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop4\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop5\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop6\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop7\", \"let's add some data here so the transaction logs rotate more often...\" );\n                node.setProperty( \"prop8\", \"let's add some data here so the transaction logs rotate more often...\" );\n                tx.success();\n            } );\n        }\n        catch ( InterruptedException e )\n        {\n            // whatever let's go on with the workload\n            Thread.interrupted();\n        }\n        catch ( TimeoutException | DatabaseShutdownException e )\n        {\n            // whatever let's go on with the workload\n        }\n    }","commit_id":"9a90ceee1a1ff9fedcbf37fcfd8616ea84800c50","url":"https://github.com/neo4j/neo4j"},{"original_method":"void runOne() throws Exception {\n        // 1/10th of txns roll back\n        byte shouldRollback = (byte) (m_random.nextInt(10) == 0 ? 1 : 0);\n\n        try {\n            String procName = null;\n            switch (m_type) {\n            case PARTITIONED_SP:\n                procName = \"UpdatePartitionedSP\";\n                break;\n            case PARTITIONED_MP:\n                procName = \"UpdatePartitionedMP\";\n                break;\n            case REPLICATED:\n                procName = \"UpdateReplicatedMP\";\n                break;\n            case HYBRID:\n                procName = \"UpdateBothMP\";\n                break;\n            case ADHOC_MP:\n                procName = \"UpdateReplicatedMPInProcAdHoc\";\n                break;\n            }\n\n            byte[] payload = m_processor.generateForStore().getStoreValue();\n\n            ClientResponse response;\n            try {\n                response = m_client.callProcedure(procName,\n                        m_cid,\n                        m_nextRid,\n                        payload,\n                        shouldRollback);\n            } catch (Exception e) {\n                if (shouldRollback == 0) {\n                    log.warn(\"ClientThread threw after \" + m_txnsRun.get() +\n                            \" calls while calling procedure: \" + procName +\n                            \" with args: cid: \" + m_cid + \", nextRid: \" + m_nextRid +\n                            \", payload: \" + payload +\n                            \", shouldRollback: \" + shouldRollback);\n                }\n                throw e;\n            }\n\n            // fake a proc call exception if we think one should be thrown\n            if (response.getStatus() != ClientResponse.SUCCESS) {\n                throw new UserProcCallException(response);\n            }\n\n            VoltTable[] results = response.getResults();\n\n            m_txnsRun.incrementAndGet();\n\n            if (results.length != 3) {\n                log.error(String.format(\n                        \"Client cid %d procedure %s returned %d results instead of 3\",\n                        m_cid, procName, results.length));\n                log.error(((ClientResponseImpl) response).toJSONString());\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n            VoltTable data = results[2];\n            try {\n                UpdateBaseProc.validateCIDData(data, \"ClientThread:\" + m_cid);\n            }\n            catch (VoltAbortException vae) {\n                log.error(\"validateCIDData failed on: \" + procName + \", shouldRollback: \" +\n                        shouldRollback + \" data: \" + data);\n                throw vae;\n            }\n        }\n        finally {\n            // ensure rid is incremented (if not rolled back intentionally)\n            if (shouldRollback == 0) {\n                m_nextRid++;\n            }\n        }\n    }","id":38205,"modified_method":"void runOne() throws Exception {\n        // 1/10th of txns roll back\n        byte shouldRollback = (byte) (m_random.nextInt(10) == 0 ? 1 : 0);\n\n        try {\n            String procName = null;\n            int expectedTables = 3;\n            switch (m_type) {\n            case PARTITIONED_SP:\n                procName = \"UpdatePartitionedSP\";\n                break;\n            case PARTITIONED_MP:\n                procName = \"UpdatePartitionedMP\";\n                expectedTables = 4;\n                break;\n            case REPLICATED:\n                procName = \"UpdateReplicatedMP\";\n                expectedTables = 4;\n                break;\n            case HYBRID:\n                procName = \"UpdateBothMP\";\n                expectedTables = 4;\n                break;\n            case ADHOC_MP:\n                procName = \"UpdateReplicatedMPInProcAdHoc\";\n                expectedTables = 4;\n                break;\n            }\n\n            byte[] payload = m_processor.generateForStore().getStoreValue();\n\n            ClientResponse response;\n            try {\n                response = m_client.callProcedure(procName,\n                        m_cid,\n                        m_nextRid,\n                        payload,\n                        shouldRollback);\n            } catch (Exception e) {\n                if (shouldRollback == 0) {\n                    log.warn(\"ClientThread threw after \" + m_txnsRun.get() +\n                            \" calls while calling procedure: \" + procName +\n                            \" with args: cid: \" + m_cid + \", nextRid: \" + m_nextRid +\n                            \", payload: \" + payload +\n                            \", shouldRollback: \" + shouldRollback);\n                }\n                throw e;\n            }\n\n            // fake a proc call exception if we think one should be thrown\n            if (response.getStatus() != ClientResponse.SUCCESS) {\n                throw new UserProcCallException(response);\n            }\n\n            VoltTable[] results = response.getResults();\n\n            m_txnsRun.incrementAndGet();\n\n            if (results.length != expectedTables) {\n                log.error(String.format(\n                        \"Client cid %d procedure %s returned %d results instead of %d\",\n                        m_cid, procName, results.length, expectedTables));\n                log.error(((ClientResponseImpl) response).toJSONString());\n                Benchmark.printJStack();\n                System.exit(-1);\n            }\n            VoltTable data = results[2];\n            try {\n                UpdateBaseProc.validateCIDData(data, \"ClientThread:\" + m_cid);\n            }\n            catch (VoltAbortException vae) {\n                log.error(\"validateCIDData failed on: \" + procName + \", shouldRollback: \" +\n                        shouldRollback + \" data: \" + data);\n                throw vae;\n            }\n        }\n        finally {\n            // ensure rid is incremented (if not rolled back intentionally)\n            if (shouldRollback == 0) {\n                m_nextRid++;\n            }\n        }\n    }","commit_id":"abe8deba5b34655a53b33f573bf581d1bad57838","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        VoltTable[] results1 = doWork(p_getCIDData, p_cleanUp, p_insert, p_getAdhocData,\n                cid, rid, value, rollback);\n        VoltTable[] results2 = doWork(r_getCIDData, r_cleanUp, r_insert, r_getAdhocData,\n                cid, rid, value, rollback);\n\n        assert(results1.length == 3);\n        assert(results2.length == 3);\n\n        // make sure the partitioned and local results are the same\n\n        long checksumR1a = MiscUtils.cheesyBufferCheckSum(results1[0].getBuffer());\n        long checksumR1b = MiscUtils.cheesyBufferCheckSum(results1[1].getBuffer());\n        long checksumR1c = MiscUtils.cheesyBufferCheckSum(results1[2].getBuffer());\n\n        long checksumR2a = MiscUtils.cheesyBufferCheckSum(results2[0].getBuffer());\n        long checksumR2b = MiscUtils.cheesyBufferCheckSum(results2[1].getBuffer());\n        long checksumR2c = MiscUtils.cheesyBufferCheckSum(results2[2].getBuffer());\n\n        assert(checksumR1a == checksumR2a);\n        assert(checksumR1b == checksumR2b);\n        assert(checksumR1c == checksumR2c);\n\n        return results2;\n    }","id":38206,"modified_method":"public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        VoltTable[] results1 = doWork(p_getCIDData, p_cleanUp, p_insert, p_getAdhocData,\n                cid, rid, value, rollback);\n        VoltTable[] results2 = doWork(r_getCIDData, r_cleanUp, r_insert, r_getAdhocData,\n                cid, rid, value, rollback);\n\n        assert(results1.length == 3);\n        assert(results2.length == 3);\n\n        // make sure the partitioned and local results are the same\n\n        long checksumR1a = MiscUtils.cheesyBufferCheckSum(results1[0].getBuffer());\n        long checksumR1b = MiscUtils.cheesyBufferCheckSum(results1[1].getBuffer());\n        long checksumR1c = MiscUtils.cheesyBufferCheckSum(results1[2].getBuffer());\n\n        long checksumR2a = MiscUtils.cheesyBufferCheckSum(results2[0].getBuffer());\n        long checksumR2b = MiscUtils.cheesyBufferCheckSum(results2[1].getBuffer());\n        long checksumR2c = MiscUtils.cheesyBufferCheckSum(results2[2].getBuffer());\n\n        assert(checksumR1a == checksumR2a);\n        assert(checksumR1b == checksumR2b);\n        assert(checksumR1c == checksumR2c);\n\n        VoltTable[] combined = doSummaryAndCombineResults(results2);\n\n        return combined;\n    }","commit_id":"abe8deba5b34655a53b33f573bf581d1bad57838","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        return doWork(p_getCIDData, p_cleanUp, p_insert, p_getAdhocData,\n                cid, rid, value, rollback);\n    }","id":38207,"modified_method":"public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        VoltTable[] results = doWork(p_getCIDData, p_cleanUp, p_insert, p_getAdhocData,\n                cid, rid, value, rollback);\n\n        return doSummaryAndCombineResults(results);\n    }","commit_id":"abe8deba5b34655a53b33f573bf581d1bad57838","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        return doWork(r_getCIDData, r_cleanUp, r_insert, p_getAdhocData,\n                cid, rid, value, rollback);\n    }","id":38208,"modified_method":"public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        VoltTable[] results = doWork(r_getCIDData, r_cleanUp, r_insert, p_getAdhocData,\n                cid, rid, value, rollback);\n\n        return doSummaryAndCombineResults(results);\n    }","commit_id":"abe8deba5b34655a53b33f573bf581d1bad57838","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        return doWorkInProcAdHoc(cid, rid, value, rollback);\n    }","id":38209,"modified_method":"@Override\n    public VoltTable[] run(byte cid, long rid, byte[] value, byte rollback) {\n        VoltTable[] results = doWorkInProcAdHoc(cid, rid, value, rollback);\n\n        return doSummaryAndCombineResults(results);\n    }","commit_id":"abe8deba5b34655a53b33f573bf581d1bad57838","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n   * Check if the sketch is modified and ask user to save changes.\n   * @return false if canceling the close/quit operation\n   */\n  protected boolean checkModified() {\n    if (!sketch.isModified()) return true;\n\n    // As of Processing 1.0.10, this always happens immediately.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=1456\n\n    // With Java 7u40 on OS X, need to bring the window forward.\n    toFront();\n    \n    String prompt = \"Save changes to \" + sketch.getName() + \"?  \";\n\n    if (!Base.isMacOS()) {\n      int result =\n        JOptionPane.showConfirmDialog(this, prompt, \"Close\",\n                                      JOptionPane.YES_NO_CANCEL_OPTION,\n                                      JOptionPane.QUESTION_MESSAGE);\n\n      if (result == JOptionPane.YES_OPTION) {\n        return handleSave(true);\n\n      } else if (result == JOptionPane.NO_OPTION) {\n        return true;  // ok to continue\n\n      } else if (result == JOptionPane.CANCEL_OPTION ||\n                 result == JOptionPane.CLOSED_OPTION) {\n        return false;\n\n      } else {\n        throw new IllegalStateException();\n      }\n\n    } else {\n      // This code is disabled unless Java 1.5 is being used on Mac OS X\n      // because of a Java bug that prevents the initial value of the\n      // dialog from being set properly (at least on my MacBook Pro).\n      // The bug causes the \"Don't Save\" option to be the highlighted,\n      // blinking, default. This sucks. But I'll tell you what doesn't\n      // suck--workarounds for the Mac and Apple's snobby attitude about it!\n      // I think it's nifty that they treat their developers like dirt.\n\n      // Pane formatting adapted from the quaqua guide\n      // http://www.randelshofer.ch/quaqua/guide/joptionpane.html\n      JOptionPane pane =\n        new JOptionPane(\"<html> \" +\n                        \"<head> <style type=\\\"text/css\\\">\"+\n                        \"b { font: 13pt \\\"Lucida Grande\\\" }\"+\n                        \"p { font: 11pt \\\"Lucida Grande\\\"; margin-top: 8px }\"+\n                        \"<\/style> <\/head>\" +\n                        \"<b>Do you want to save changes to this sketch<BR>\" +\n                        \" before closing?<\/b>\" +\n                        \"<p>If you don't save, your changes will be lost.\",\n                        JOptionPane.QUESTION_MESSAGE);\n\n      String[] options = new String[] {\n        \"Save\", \"Cancel\", \"Don't Save\"\n      };\n      pane.setOptions(options);\n\n      // highlight the safest option ala apple hig\n      pane.setInitialValue(options[0]);\n\n      // on macosx, setting the destructive property places this option\n      // away from the others at the lefthand side\n      pane.putClientProperty(\"Quaqua.OptionPane.destructiveOption\",\n                             new Integer(2));\n\n      JDialog dialog = pane.createDialog(this, null);\n      dialog.setVisible(true);\n\n      Object result = pane.getValue();\n      if (result == options[0]) {  // save (and close/quit)\n        return handleSave(true);\n\n      } else if (result == options[2]) {  // don't save (still close/quit)\n        return true;\n\n      } else {  // cancel?\n        return false;\n      }\n    }\n  }","id":38210,"modified_method":"/**\n   * Check if the sketch is modified and ask user to save changes.\n   * \n   * @return false if canceling the close/quit operation\n   */\n  protected boolean checkModified() {\n    boolean ret;\n    if (!sketch.isModified()){\n      stopReloadThread = true;\n      return true;\n    }\n\n    // As of Processing 1.0.10, this always happens immediately.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=1456\n\n    // With Java 7u40 on OS X, need to bring the window forward.\n    toFront();\n\n    String prompt = \"Save changes to \" + sketch.getName() + \"?  \";\n\n    if (!Base.isMacOS()) {\n      int result = JOptionPane\n        .showConfirmDialog(this, prompt, \"Close\",\n                           JOptionPane.YES_NO_CANCEL_OPTION,\n                           JOptionPane.QUESTION_MESSAGE);\n\n      if (result == JOptionPane.YES_OPTION) {\n        ret = handleSave(true);\n\n      } else if (result == JOptionPane.NO_OPTION) {\n        ret = true; // ok to continue\n\n      } else if (result == JOptionPane.CANCEL_OPTION\n        || result == JOptionPane.CLOSED_OPTION) {\n        ret = false;\n\n      } else {\n        throw new IllegalStateException();\n      }\n\n    } else {\n      // This code is disabled unless Java 1.5 is being used on Mac OS X\n      // because of a Java bug that prevents the initial value of the\n      // dialog from being set properly (at least on my MacBook Pro).\n      // The bug causes the \"Don't Save\" option to be the highlighted,\n      // blinking, default. This sucks. But I'll tell you what doesn't\n      // suck--workarounds for the Mac and Apple's snobby attitude about it!\n      // I think it's nifty that they treat their developers like dirt.\n\n      // Pane formatting adapted from the quaqua guide\n      // http://www.randelshofer.ch/quaqua/guide/joptionpane.html\n      JOptionPane pane = new JOptionPane(\"<html> \"\n        + \"<head> <style type=\\\"text/css\\\">\"\n        + \"b { font: 13pt \\\"Lucida Grande\\\" }\"\n        + \"p { font: 11pt \\\"Lucida Grande\\\"; margin-top: 8px }\"\n        + \"<\/style> <\/head>\"\n        + \"<b>Do you want to save changes to this sketch<BR>\"\n        + \" before closing?<\/b>\"\n        + \"<p>If you don't save, your changes will be lost.\",\n                                         JOptionPane.QUESTION_MESSAGE);\n\n      String[] options = new String[] { \"Save\", \"Cancel\", \"Don't Save\" };\n      pane.setOptions(options);\n\n      // highlight the safest option ala apple hig\n      pane.setInitialValue(options[0]);\n\n      // on macosx, setting the destructive property places this option\n      // away from the others at the lefthand side\n      pane.putClientProperty(\"Quaqua.OptionPane.destructiveOption\",\n                             new Integer(2));\n\n      JDialog dialog = pane.createDialog(this, null);\n      dialog.setVisible(true);\n\n      Object result = pane.getValue();\n      if (result == options[0]) { // save (and close/quit)\n        ret = handleSave(true);\n\n      } else if (result == options[2]) { // don't save (still close/quit)\n        ret = true;\n\n      } else { // cancel?\n        ret = false;\n      }\n    }\n    if (ret) {\n      //the sketch is closing\n      stopReloadThread = true;\n    }\n    return ret;\n  }","commit_id":"312131ca5a8c5ddb49f5f57b98edd3682cff0acc","url":"https://github.com/processing/processing"},{"original_method":"private void initFileChangeListener() {\n    try {\n      WatchService watchService = FileSystems.getDefault().newWatchService();\n      key = sketch.getFolder().toPath()\n        .register(watchService,\n//                  StandardWatchEventKinds.ENTRY_CREATE,\n//                  StandardWatchEventKinds.ENTRY_DELETE,\n                  StandardWatchEventKinds.ENTRY_MODIFY);\n    } catch (IOException e) {\n      //registring the watch failed, ignore it\n    }\n\n    final WatchKey finKey = key;\n\n    //if the key is null for some reason, don't bother attaching a listener to it, they can deal without one\n    if (finKey != null) {\n      //the key can now be polled for changes in the files\n      Thread th = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          //polls for changes to the directory\n          while (true) {\n            try {\n              //check every .1s if the file has changed\n              Thread.sleep(FILE_CHECK_DELAY);\n            } catch (InterruptedException e) {\n            }\n            List<WatchEvent<?>> events = finKey.pollEvents();\n            processFileEvents(events);\n\n            //if the directory was deleted, then quit the loop\n            if (!finKey.isValid()) {\n              break;\n            }\n          }\n        }\n      });\n      th.start();\n    }\n  }","id":38211,"modified_method":"private void initFileChangeListener() {\n    //if it is disabled, don't bother starting one\n    if (!reloadEnabled) {\n      return;\n    }\n\n    try {\n      WatchService watchService = FileSystems.getDefault().newWatchService();\n      key = sketch.getFolder().toPath()\n        .register(watchService,\n//                  StandardWatchEventKinds.ENTRY_CREATE,\n//                  StandardWatchEventKinds.ENTRY_DELETE,\n                  StandardWatchEventKinds.ENTRY_MODIFY);\n    } catch (IOException e) {\n      //registring the watch failed, ignore it\n    }\n\n    final WatchKey finKey = key;\n\n    //if the key is null for some reason, don't bother attaching a listener to it, they can deal without one\n    if (finKey != null) {\n      //the key can now be polled for changes in the files\n      stopReloadThread = false;\n      Thread th = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          //polls for changes to the directory\n          while (true) {\n            try {\n              //check every .1s if the file has changed\n              Thread.sleep(FILE_CHECK_DELAY);\n            } catch (InterruptedException e) {\n            }\n            List<WatchEvent<?>> events = finKey.pollEvents();\n\n            //called when a sketch is closed\n            if (stopReloadThread) {\n              break;\n            }\n            //if it is disabled after being started, stop it\n            if (!reloadEnabled) {\n              break;\n            }\n\n            processFileEvents(events);\n\n            //if the directory was deleted, then quit the loop\n            if (!finKey.isValid()) {\n              break;\n            }\n          }\n        }\n      });\n      th.start();\n    }\n  }","commit_id":"312131ca5a8c5ddb49f5f57b98edd3682cff0acc","url":"https://github.com/processing/processing"},{"original_method":"protected void handleSaveImpl() {\n    statusNotice(\"Saving...\");\n    try {\n      if (sketch.save()) {\n        saved = true;\n        statusNotice(\"Done Saving.\");\n      } else {\n        statusEmpty();\n      }\n\n    } catch (Exception e) {\n      // show the error as a message in the window\n      statusError(e);\n\n      // zero out the current action,\n      // so that checkModified2 will just do nothing\n      //checkModifiedMode = 0;\n      // this is used when another operation calls a save\n    }\n  }","id":38212,"modified_method":"protected void handleSaveImpl() {\n    statusNotice(\"Saving...\");\n    try {\n      if (sketch.save()) {\n        statusNotice(\"Done Saving.\");\n      } else {\n        statusEmpty();\n      }\n\n    } catch (Exception e) {\n      // show the error as a message in the window\n      statusError(e);\n\n      // zero out the current action,\n      // so that checkModified2 will just do nothing\n      //checkModifiedMode = 0;\n      // this is used when another operation calls a save\n    }\n  }","commit_id":"2677e280d66902d91872545bf565fdeef3e56d73","url":"https://github.com/processing/processing"},{"original_method":"private void initFileChangeListener() {\n    //if it is disabled, don't bother starting one\n    if (!reloadEnabled) {\n      return;\n    }\n\n    try {\n      WatchService watchService = FileSystems.getDefault().newWatchService();\n      key = sketch.getFolder().toPath()\n        .register(watchService,\n//                  StandardWatchEventKinds.ENTRY_CREATE,\n//                  StandardWatchEventKinds.ENTRY_DELETE,\n                  StandardWatchEventKinds.ENTRY_MODIFY);\n    } catch (IOException e) {\n      //registring the watch failed, ignore it\n    }\n\n    final WatchKey finKey = key;\n\n    //if the key is null for some reason, don't bother attaching a listener to it, they can deal without one\n    if (finKey != null) {\n      //the key can now be polled for changes in the files\n      stopReloadThread = false;\n      Thread th = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          //polls for changes to the directory\n          while (true) {\n            try {\n              //check every .1s if the file has changed\n              Thread.sleep(FILE_CHECK_DELAY);\n            } catch (InterruptedException e) {\n            }\n            List<WatchEvent<?>> events = finKey.pollEvents();\n\n            //called when a sketch is closed\n            if (stopReloadThread) {\n              break;\n            }\n            //if it is disabled after being started, stop it\n            if (!reloadEnabled) {\n              break;\n            }\n\n            processFileEvents(events);\n\n            //if the directory was deleted, then quit the loop\n            if (!finKey.isValid()) {\n              break;\n            }\n          }\n        }\n      });\n      th.start();\n    }\n  }","id":38213,"modified_method":"private void initFileChangeListener() {\n    try {\n      WatchService watchService = FileSystems.getDefault().newWatchService();\n      key = sketch.getFolder().toPath()\n        .register(watchService,\n//                  StandardWatchEventKinds.ENTRY_CREATE,\n//                  StandardWatchEventKinds.ENTRY_DELETE,\n                  StandardWatchEventKinds.ENTRY_MODIFY);\n    } catch (IOException e) {\n      //registring the watch failed, ignore it\n    }\n\n    final WatchKey finKey = key;\n\n    //if the key is null for some reason, don't bother attaching a listener to it, they can deal without one\n    if (finKey != null) {\n      //the key can now be polled for changes in the files\n      addFocusListener(new FocusListener() {\n        @Override\n        public void focusLost(FocusEvent e) {\n          //do nothing\n        }\n        \n        @Override\n        public void focusGained(FocusEvent e) {\n          //if the directory was deleted, then don't scan\n          if (!finKey.isValid()) {\n            return;\n          }\n          \n          List<WatchEvent<?>> events = finKey.pollEvents();\n          processFileEvents(events);\n        }\n      });\n     \n    }\n  }","commit_id":"2677e280d66902d91872545bf565fdeef3e56d73","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * called when a file is changed\n   * \n   * @param events\n   *          the list of events that have occured in the registered folder\n   *          (sketch.getFolder())\n   */\n  private void processFileEvents(List<WatchEvent<?>> events) {\n    didReload = false;\n    for (WatchEvent<?> e : events) {\n      //the context is the name of the file inside the path\n      //due to some weird shit, if a file was editted in gedit, the context is .goutputstream-XXXXX\n      //this makes things.... complicated\n      //System.out.println(e.context());\n\n      //if the file was saved, don't prompt anything\n      if (saved)\n        break;\n      //if we already reloaded in this cycle, then don't reload again\n      if (didReload) {\n        break;\n      }\n      if (e.kind().equals(StandardWatchEventKinds.ENTRY_MODIFY)) {\n//        Path p = (Path) e.context();\n//        Path root = (Path) key.watchable();\n//        Path path = root.resolve(p);\n        int response = Base\n          .showYesNoQuestion(Editor.this, \"File Modified\",\n                             \"A file has been modified externally\",\n                             \"Would you like to reload the sketch?\");\n        if (response == 0) {\n          //reload the sketch\n          sketch.reload();\n          header.rebuild();\n          didReload = true;\n        }\n      } else {\n        //called when a file is created or deleted\n        //for now, do nothing\n      }\n    }\n    saved = false;\n  }","id":38214,"modified_method":"/**\n   * called when a file is changed\n   * \n   * @param events\n   *          the list of events that have occured in the registered folder\n   *          (sketch.getFolder())\n   */\n  private void processFileEvents(List<WatchEvent<?>> events) {\n    didReload = false;\n    for (WatchEvent<?> e : events) {\n      //the context is the name of the file inside the path\n      //due to some weird shit, if a file was editted in gedit, the context is .goutputstream-XXXXX\n      //this makes things.... complicated\n      //System.out.println(e.context());\n      \n      //if we already reloaded in this cycle, then don't reload again\n      if (didReload){\n        break;\n      }\n      if (e.kind().equals(StandardWatchEventKinds.ENTRY_MODIFY)) {\n//        Path p = (Path) e.context();\n//        Path root = (Path) key.watchable();\n//        Path path = root.resolve(p);\n        int response = Base\n          .showYesNoQuestion(Editor.this, \"File Modified\",\n                             \"A file has been modified externally\",\n                             \"Would you like to reload the sketch?\");\n        if (response == 0) {\n          //reload the sketch\n          sketch.reload();\n          header.rebuild();\n          didReload = true;\n        }\n      } else {\n        //called when a file is created or deleted\n        //for now, do nothing\n      }\n    }\n  }","commit_id":"2677e280d66902d91872545bf565fdeef3e56d73","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Check if the sketch is modified and ask user to save changes.\n   * \n   * @return false if canceling the close/quit operation\n   */\n  protected boolean checkModified() {\n    boolean ret;\n    if (!sketch.isModified()){\n      stopReloadThread = true;\n      return true;\n    }\n\n    // As of Processing 1.0.10, this always happens immediately.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=1456\n\n    // With Java 7u40 on OS X, need to bring the window forward.\n    toFront();\n\n    String prompt = \"Save changes to \" + sketch.getName() + \"?  \";\n\n    if (!Base.isMacOS()) {\n      int result = JOptionPane\n        .showConfirmDialog(this, prompt, \"Close\",\n                           JOptionPane.YES_NO_CANCEL_OPTION,\n                           JOptionPane.QUESTION_MESSAGE);\n\n      if (result == JOptionPane.YES_OPTION) {\n        ret = handleSave(true);\n\n      } else if (result == JOptionPane.NO_OPTION) {\n        ret = true; // ok to continue\n\n      } else if (result == JOptionPane.CANCEL_OPTION\n        || result == JOptionPane.CLOSED_OPTION) {\n        ret = false;\n\n      } else {\n        throw new IllegalStateException();\n      }\n\n    } else {\n      // This code is disabled unless Java 1.5 is being used on Mac OS X\n      // because of a Java bug that prevents the initial value of the\n      // dialog from being set properly (at least on my MacBook Pro).\n      // The bug causes the \"Don't Save\" option to be the highlighted,\n      // blinking, default. This sucks. But I'll tell you what doesn't\n      // suck--workarounds for the Mac and Apple's snobby attitude about it!\n      // I think it's nifty that they treat their developers like dirt.\n\n      // Pane formatting adapted from the quaqua guide\n      // http://www.randelshofer.ch/quaqua/guide/joptionpane.html\n      JOptionPane pane = new JOptionPane(\"<html> \"\n        + \"<head> <style type=\\\"text/css\\\">\"\n        + \"b { font: 13pt \\\"Lucida Grande\\\" }\"\n        + \"p { font: 11pt \\\"Lucida Grande\\\"; margin-top: 8px }\"\n        + \"<\/style> <\/head>\"\n        + \"<b>Do you want to save changes to this sketch<BR>\"\n        + \" before closing?<\/b>\"\n        + \"<p>If you don't save, your changes will be lost.\",\n                                         JOptionPane.QUESTION_MESSAGE);\n\n      String[] options = new String[] { \"Save\", \"Cancel\", \"Don't Save\" };\n      pane.setOptions(options);\n\n      // highlight the safest option ala apple hig\n      pane.setInitialValue(options[0]);\n\n      // on macosx, setting the destructive property places this option\n      // away from the others at the lefthand side\n      pane.putClientProperty(\"Quaqua.OptionPane.destructiveOption\",\n                             new Integer(2));\n\n      JDialog dialog = pane.createDialog(this, null);\n      dialog.setVisible(true);\n\n      Object result = pane.getValue();\n      if (result == options[0]) { // save (and close/quit)\n        ret = handleSave(true);\n\n      } else if (result == options[2]) { // don't save (still close/quit)\n        ret = true;\n\n      } else { // cancel?\n        ret = false;\n      }\n    }\n    if (ret) {\n      //the sketch is closing\n      stopReloadThread = true;\n    }\n    return ret;\n  }","id":38215,"modified_method":"/**\n   * Check if the sketch is modified and ask user to save changes.\n   * @return false if canceling the close/quit operation\n   */\n  protected boolean checkModified() {\n    if (!sketch.isModified()) return true;\n\n    // As of Processing 1.0.10, this always happens immediately.\n    // http://dev.processing.org/bugs/show_bug.cgi?id=1456\n\n    // With Java 7u40 on OS X, need to bring the window forward.\n    toFront();\n    \n    String prompt = \"Save changes to \" + sketch.getName() + \"?  \";\n\n    if (!Base.isMacOS()) {\n      int result =\n        JOptionPane.showConfirmDialog(this, prompt, \"Close\",\n                                      JOptionPane.YES_NO_CANCEL_OPTION,\n                                      JOptionPane.QUESTION_MESSAGE);\n\n      if (result == JOptionPane.YES_OPTION) {\n        return handleSave(true);\n\n      } else if (result == JOptionPane.NO_OPTION) {\n        return true;  // ok to continue\n\n      } else if (result == JOptionPane.CANCEL_OPTION ||\n                 result == JOptionPane.CLOSED_OPTION) {\n        return false;\n\n      } else {\n        throw new IllegalStateException();\n      }\n\n    } else {\n      // This code is disabled unless Java 1.5 is being used on Mac OS X\n      // because of a Java bug that prevents the initial value of the\n      // dialog from being set properly (at least on my MacBook Pro).\n      // The bug causes the \"Don't Save\" option to be the highlighted,\n      // blinking, default. This sucks. But I'll tell you what doesn't\n      // suck--workarounds for the Mac and Apple's snobby attitude about it!\n      // I think it's nifty that they treat their developers like dirt.\n\n      // Pane formatting adapted from the quaqua guide\n      // http://www.randelshofer.ch/quaqua/guide/joptionpane.html\n      JOptionPane pane =\n        new JOptionPane(\"<html> \" +\n                        \"<head> <style type=\\\"text/css\\\">\"+\n                        \"b { font: 13pt \\\"Lucida Grande\\\" }\"+\n                        \"p { font: 11pt \\\"Lucida Grande\\\"; margin-top: 8px }\"+\n                        \"<\/style> <\/head>\" +\n                        \"<b>Do you want to save changes to this sketch<BR>\" +\n                        \" before closing?<\/b>\" +\n                        \"<p>If you don't save, your changes will be lost.\",\n                        JOptionPane.QUESTION_MESSAGE);\n\n      String[] options = new String[] {\n        \"Save\", \"Cancel\", \"Don't Save\"\n      };\n      pane.setOptions(options);\n\n      // highlight the safest option ala apple hig\n      pane.setInitialValue(options[0]);\n\n      // on macosx, setting the destructive property places this option\n      // away from the others at the lefthand side\n      pane.putClientProperty(\"Quaqua.OptionPane.destructiveOption\",\n                             new Integer(2));\n\n      JDialog dialog = pane.createDialog(this, null);\n      dialog.setVisible(true);\n\n      Object result = pane.getValue();\n      if (result == options[0]) {  // save (and close/quit)\n        return handleSave(true);\n\n      } else if (result == options[2]) {  // don't save (still close/quit)\n        return true;\n\n      } else {  // cancel?\n        return false;\n      }\n    }\n  }","commit_id":"2677e280d66902d91872545bf565fdeef3e56d73","url":"https://github.com/processing/processing"},{"original_method":"private void accum_all2(Chunk chks[], Chunk wrks, int nh[], int[] rows) {\n    final DHistogram hcs[][] = _hcs;\n    // Local temp arrays, no atomic updates.\n    int    bins[] = new int   [_nbins];\n    double sums[] = new double[_nbins];\n    double ssqs[] = new double[_nbins];\n    // For All Columns\n    for( int c=0; c<_ncols; c++) { // for all columns\n      Chunk chk = chks[c];\n      // For All NIDs\n      for( int n=0; n<hcs.length; n++ ) {\n        final DRealHistogram rh = ((DRealHistogram)hcs[n][c]);\n        if( rh==null ) continue; // Ignore untracked columns in this split\n        final int lo = n==0 ? 0 : nh[n-1];\n        final int hi = nh[n];\n        float min = rh._min2;\n        float max = rh._maxIn;\n        // While most of the time we are limited to nbins, we allow more bins\n        // in a few cases (top-level splits have few total bins across all\n        // the (few) splits) so it's safe to bin more; also categoricals want\n        // to split one bin-per-level no matter how many levels).\n        if( rh._bins.length >= bins.length ) { // Grow bins if needed\n          bins = new int   [rh._bins.length];\n          sums = new double[rh._bins.length];\n          ssqs = new double[rh._bins.length];\n        }\n\n        // Gather all the data for this set of rows, for 1 column and 1 split/NID\n        // Gather min/max, sums and sum-squares.\n        for( int xrow=lo; xrow<hi; xrow++ ) {\n          int row = rows[xrow];\n          float col_data = (float)chk.atd(row);\n          if( col_data < min ) min = col_data;\n          if( col_data > max ) max = col_data;\n          int b = rh.bin(col_data); // Compute bin# via linear interpolation\n          bins[b]++;                // Bump count in bin\n          double resp = wrks.atd(row);\n          sums[b] += resp;\n          ssqs[b] += resp*resp;\n        }\n\n        // Add all the data into the Histogram (atomically add)\n        rh.setMin(min);       // Track actual lower/upper bound per-bin\n        rh.setMax(max);\n        for( int b=0; b<rh._bins.length; b++ ) { // Bump counts in bins\n          if( bins[b] != 0 ) { AtomicUtils.IntArray.add(rh._bins,b,bins[b]); bins[b]=0; }\n          if( ssqs[b] != 0 ) { rh.incr1(b,(float)sums[b],(float)ssqs[b]); sums[b]=ssqs[b]=0; }\n        }\n      }\n    }\n  }","id":38216,"modified_method":"private void accum_all2(Chunk chks[], Chunk wrks, int nh[], int[] rows) {\n    final DHistogram hcs[][] = _hcs;\n    // Local temp arrays, no atomic updates.\n    int    bins[] = new int   [_nbins];\n    double sums[] = new double[_nbins];\n    double ssqs[] = new double[_nbins];\n    // For All Columns\n    for( int c=0; c<_ncols; c++) { // for all columns\n      Chunk chk = chks[c];\n      // For All NIDs\n      for( int n=0; n<hcs.length; n++ ) {\n        final DRealHistogram rh = ((DRealHistogram)hcs[n][c]);\n        if( rh==null ) continue; // Ignore untracked columns in this split\n        final int lo = n==0 ? 0 : nh[n-1];\n        final int hi = nh[n];\n        float min = rh._min2;\n        float max = rh._maxIn;\n        // While most of the time we are limited to nbins, we allow more bins\n        // in a few cases (top-level splits have few total bins across all\n        // the (few) splits) so it's safe to bin more; also categoricals want\n        // to split one bin-per-level no matter how many levels).\n        if( rh._bins.length >= bins.length ) { // Grow bins if needed\n          bins = new int   [rh._bins.length];\n          sums = new double[rh._bins.length];\n          ssqs = new double[rh._bins.length];\n        }\n\n        // Gather all the data for this set of rows, for 1 column and 1 split/NID\n        // Gather min/max, sums and sum-squares.\n        for( int xrow=lo; xrow<hi; xrow++ ) {\n          int row = rows[xrow];\n          float col_data = (float)chk.atd(row);\n          if( col_data < min ) min = col_data;\n          if( col_data > max ) max = col_data;\n          int b = rh.bin(col_data); // Compute bin# via linear interpolation\n          bins[b]++;                // Bump count in bin\n          double resp = wrks.atd(row);\n          sums[b] += resp;\n          ssqs[b] += resp*resp;\n        }\n\n        // Add all the data into the Histogram (atomically add)\n        rh.setMin(min);       // Track actual lower/upper bound per-bin\n        rh.setMax(max);\n        for( int b=0; b<rh._bins.length; b++ ) { // Bump counts in bins\n          if( bins[b] != 0 ) { AtomicUtils.IntArray.add(rh._bins,b,bins[b]); bins[b]=0; }\n          if( ssqs[b] != 0 ) { rh.incr1(b,sums[b],ssqs[b]); sums[b]=ssqs[b]=0; }\n        }\n      }\n    }\n  }","commit_id":"366a7733d6c6b264b83cf1c3372ce5be68bfb110","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void accum_subset(Chunk chks[], Chunk wrks, int nnids[]) {\n    for( int row=0; row<nnids.length; row++ ) { // Over all rows\n      int nid = nnids[row];                     // Get Node to decide from\n      if( nid >= 0 ) {        // row already predicts perfectly or OOB\n        assert !Double.isNaN(wrks.atd(row)); // Already marked as sampled-away\n        DHistogram nhs[] = _hcs[nid];\n        int sCols[] = _tree.undecided(nid+_leaf)._scoreCols; // Columns to score (null, or a list of selected cols)\n        for( int col : sCols ) // For tracked cols\n        //FIXME/TODO: sum into local variables, do atomic increment once at the end, similar to accum_all\n          nhs[col].incr((float)chks[col].atd(row),(float)wrks.atd(row)); // Histogram row/col\n      }\n    }\n  }","id":38217,"modified_method":"private void accum_subset(Chunk chks[], Chunk wrks, int nnids[]) {\n    for( int row=0; row<nnids.length; row++ ) { // Over all rows\n      int nid = nnids[row];                     // Get Node to decide from\n      if( nid >= 0 ) {        // row already predicts perfectly or OOB\n        assert !Double.isNaN(wrks.atd(row)); // Already marked as sampled-away\n        DHistogram nhs[] = _hcs[nid];\n        int sCols[] = _tree.undecided(nid+_leaf)._scoreCols; // Columns to score (null, or a list of selected cols)\n        for( int col : sCols ) // For tracked cols\n        //FIXME/TODO: sum into local variables, do atomic increment once at the end, similar to accum_all\n          nhs[col].incr((float)chks[col].atd(row),wrks.atd(row)); // Histogram row/col\n      }\n    }\n  }","commit_id":"366a7733d6c6b264b83cf1c3372ce5be68bfb110","url":"https://github.com/h2oai/h2o-3"},{"original_method":"static public DHistogram make(String name, final int nbins, int nbins_cats, byte isInt, float min, float maxEx) {\n    return new DHistogram(name,nbins, nbins_cats, isInt, min, maxEx);\n  }","id":38218,"modified_method":"static public DHistogram make(String name, final int nbins, int nbins_cats, byte isInt, double min, double maxEx) {\n    return new DHistogram(name,nbins, nbins_cats, isInt, min, maxEx);\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"static public DHistogram[] initialHist(Frame fr, int ncols, int nbins, int nbins_cats, DHistogram hs[]) {\n    Vec vecs[] = fr.vecs();\n    for( int c=0; c<ncols; c++ ) {\n      Vec v = vecs[c];\n      final float minIn = (float)Math.max(v.min(),-Float.MAX_VALUE); // inclusive vector min\n      final float maxIn = (float)Math.min(v.max(), Float.MAX_VALUE); // inclusive vector max\n      final float maxEx = find_maxEx(maxIn,v.isInt()?1:0); // smallest exclusive max\n      final long vlen = v.length();\n      hs[c] = v.naCnt()==vlen || v.min()==v.max() ? null :\n        make(fr._names[c],nbins, nbins_cats, (byte)(v.isCategorical() ? 2 : (v.isInt()?1:0)), minIn, maxEx);\n      assert (hs[c] == null || vlen > 0);\n    }\n    return hs;\n  }","id":38219,"modified_method":"static public DHistogram[] initialHist(Frame fr, int ncols, int nbins, int nbins_cats, DHistogram hs[]) {\n    Vec vecs[] = fr.vecs();\n    for( int c=0; c<ncols; c++ ) {\n      Vec v = vecs[c];\n      final double minIn = Math.max(v.min(),-Double.MAX_VALUE); // inclusive vector min\n      final double maxIn = Math.min(v.max(), Double.MAX_VALUE); // inclusive vector max\n      final double maxEx = find_maxEx(maxIn,v.isInt()?1:0); // smallest exclusive max\n      final long vlen = v.length();\n      hs[c] = v.naCnt()==vlen || v.min()==v.max() ? null :\n        make(fr._names[c],nbins, nbins_cats, (byte)(v.isCategorical() ? 2 : (v.isInt()?1:0)), minIn, maxEx);\n      assert (hs[c] == null || vlen > 0);\n    }\n    return hs;\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"void incr0( int b, double y, double w ) {\n    AtomicUtils.DoubleArray.add(_sums,b,(float)(w*y)); //See 'HistogramTest' JUnit for float-casting rationalization\n    AtomicUtils.DoubleArray.add(_ssqs,b,(float)(w*y*y));\n  }","id":38220,"modified_method":"void incr0( int b, double y, double w ) {\n    AtomicUtils.DoubleArray.add(_sums,b,w*y); //See 'HistogramTest' JUnit for float-casting rationalization (not done right now)\n    AtomicUtils.DoubleArray.add(_ssqs,b,w*y*y);\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"void incr( float col_data, double y, double w ) {\n    assert Float.isNaN(col_data) || Float.isInfinite(col_data) || (_min <= col_data && col_data < _maxEx) : \"col_data \"+col_data+\" out of range \"+this;\n    int b = bin(col_data);      // Compute bin# via linear interpolation\n    water.util.AtomicUtils.DoubleArray.add(_bins,b,w); // Bump count in bin\n    // Track actual lower/upper bound per-bin\n    if (!Float.isInfinite(col_data)) {\n      setMin(col_data);\n      setMax(col_data);\n    }\n    if( y != 0 && w != 0) incr0(b,y,w);\n  }","id":38221,"modified_method":"void incr( double col_data, double y, double w ) {\n    assert Double.isNaN(col_data) || Double.isInfinite(col_data) || (_min <= col_data && col_data < _maxEx) : \"col_data \"+col_data+\" out of range \"+this;\n    int b = bin(col_data);      // Compute bin# via linear interpolation\n    water.util.AtomicUtils.DoubleArray.add(_bins,b,w); // Bump count in bin\n    // Track actual lower/upper bound per-bin\n    if (!Double.isInfinite(col_data)) {\n      setMin(col_data);\n      setMax(col_data);\n    }\n    if( y != 0 && w != 0) incr0(b,y,w);\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"void incr1( int b, double y, double yy) {\n    AtomicUtils.DoubleArray.add(_sums,b,(float)y); //See 'HistogramTest' JUnit for float-casting rationalization\n    AtomicUtils.DoubleArray.add(_ssqs,b,(float)yy);\n  }","id":38222,"modified_method":"void incr1( int b, double y, double yy) {\n    AtomicUtils.DoubleArray.add(_sums,b,y); //See 'HistogramTest' JUnit for float-casting rationalization (not done right now)\n    AtomicUtils.DoubleArray.add(_ssqs,b,yy);\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"float binAt( int b ) { return _min+b/_step; }","id":38223,"modified_method":"double binAt( int b ) { return _min+b/_step; }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DTree.Split scoreMSE( int col, double min_rows ) {\n    final int nbins = nbins();\n    assert nbins > 1;\n\n    // Histogram arrays used for splitting, these are either the original bins\n    // (for an ordered predictor), or sorted by the mean response (for an\n    // unordered predictor, i.e. categorical predictor).\n    double[] sums = _sums;\n    double[] ssqs = _ssqs;\n    double[] bins = _bins;\n    int idxs[] = null;          // and a reverse index mapping\n\n    // For categorical (unordered) predictors, sort the bins by average\n    // prediction then look for an optimal split.  Currently limited to categoricals\n    // where we're one-per-bin.  No point for 3 or fewer bins as all possible\n    // combinations (just 3) are tested without needing to sort.\n    if( _isInt == 2 && _step == 1.0f && nbins >= 4 ) {\n      // Sort the index by average response\n      idxs = MemoryManager.malloc4(nbins+1); // Reverse index\n      for( int i=0; i<nbins+1; i++ ) idxs[i] = i;\n      final double[] avgs = MemoryManager.malloc8d(nbins+1);\n      for( int i=0; i<nbins; i++ ) avgs[i] = _bins[i]==0 ? 0 : _sums[i]/_bins[i]; // Average response\n      avgs[nbins] = Double.MAX_VALUE;\n      ArrayUtils.sort(idxs, avgs);\n      // Fill with sorted data.  Makes a copy, so the original data remains in\n      // its original order.\n      sums = MemoryManager.malloc8d(nbins);\n      ssqs = MemoryManager.malloc8d(nbins);\n      bins = MemoryManager.malloc8d(nbins);\n      for( int i=0; i<nbins; i++ ) {\n        sums[i] = _sums[idxs[i]];\n        ssqs[i] = _ssqs[idxs[i]];\n        bins[i] = _bins[idxs[i]];\n      }\n    }\n\n    // Compute mean/var for cumulative bins from 0 to nbins inclusive.\n    double sums0[] = MemoryManager.malloc8d(nbins+1);\n    double ssqs0[] = MemoryManager.malloc8d(nbins+1);\n    double   ns0[] = MemoryManager.malloc8d(nbins+1);\n    for( int b=1; b<=nbins; b++ ) {\n      double m0 = sums0[b-1],  m1 = sums[b-1];\n      double s0 = ssqs0[b-1],  s1 = ssqs[b-1];\n      double k0 = ns0  [b-1],  k1 = bins[b-1];\n      if( k0==0 && k1==0 )\n        continue;\n      sums0[b] = m0+m1;\n      ssqs0[b] = s0+s1;\n      ns0  [b] = k0+k1;\n    }\n    double tot = ns0[nbins];\n    // Is any split possible with at least min_obs?\n    if( tot < 2*min_rows )\n      return null;\n    // If we see zero variance, we must have a constant response in this\n    // column.  Normally this situation is cut out before we even try to split,\n    // but we might have NA's in THIS column...\n    double var = ssqs0[nbins]*tot - sums0[nbins]*sums0[nbins];\n    if( var == 0 ) {\n      assert isConstantResponse();\n      return null;\n    }\n    // If variance is really small, then the predictions (which are all at\n    // single-precision resolution), will be all the same and the tree split\n    // will be in vain.\n    if( ((float)var) == 0f )\n      return null;\n\n    // Compute mean/var for cumulative bins from nbins to 0 inclusive.\n    double sums1[] = MemoryManager.malloc8d(nbins+1);\n    double ssqs1[] = MemoryManager.malloc8d(nbins+1);\n    double   ns1[] = MemoryManager.malloc8d(nbins+1);\n    for( int b=nbins-1; b>=0; b-- ) {\n      double m0 = sums1[b+1], m1 = sums[b];\n      double s0 = ssqs1[b+1], s1 = ssqs[b];\n      double k0 = ns1  [b+1], k1 = bins[b];\n      if( k0==0 && k1==0 )\n        continue;\n      sums1[b] = m0+m1;\n      ssqs1[b] = s0+s1;\n      ns1  [b] = k0+k1;\n      assert MathUtils.compare(ns0[b]+ns1[b],tot,1e-5,1e-5);\n    }\n\n    // Now roll the split-point across the bins.  There are 2 ways to do this:\n    // split left/right based on being less than some value, or being equal/\n    // not-equal to some value.  Equal/not-equal makes sense for categoricals\n    // but both splits could work for any integral datatype.  Do the less-than\n    // splits first.\n    int best=0;                         // The no-split\n    double best_se0=Double.MAX_VALUE;   // Best squared error\n    double best_se1=Double.MAX_VALUE;   // Best squared error\n    byte equal=0;                       // Ranged check\n    for( int b=1; b<=nbins-1; b++ ) {\n      if( bins[b] == 0 ) continue; // Ignore empty splits\n      if( ns0[b] < min_rows ) continue;\n      if( ns1[b] < min_rows ) break; // ns1 shrinks at the higher bin#s, so if it fails once it fails always\n      // We're making an unbiased estimator, so that MSE==Var.\n      // Then Squared Error = MSE*N = Var*N\n      //                    = (ssqs/N - mean^2)*N\n      //                    = ssqs - N*mean^2\n      //                    = ssqs - N*(sum/N)(sum/N)\n      //                    = ssqs - sum^2/N\n      double se0 = ssqs0[b] - sums0[b]*sums0[b]/ns0[b];\n      double se1 = ssqs1[b] - sums1[b]*sums1[b]/ns1[b];\n      if( se0 < 0 ) se0 = 0;    // Roundoff error; sometimes goes negative\n      if( se1 < 0 ) se1 = 0;    // Roundoff error; sometimes goes negative\n      if( (se0+se1 < best_se0+best_se1) || // Strictly less error?\n              // Or tied MSE, then pick split towards middle bins\n              (se0+se1 == best_se0+best_se1 &&\n                      Math.abs(b -(nbins>>1)) < Math.abs(best-(nbins>>1))) ) {\n        best_se0 = se0;   best_se1 = se1;\n        best = b;\n      }\n    }\n\n    // If the bin covers a single value, we can also try an equality-based split\n    if( _isInt > 0 && _step == 1.0f &&    // For any integral (not float) column\n            _maxEx-_min > 2 && idxs==null ) { // Also need more than 2 (boolean) choices to actually try a new split pattern\n      for( int b=1; b<=nbins-1; b++ ) {\n        if( bins[b] < min_rows ) continue; // Ignore too small splits\n        double N = ns0[b] + ns1[b+1];\n        if( N < min_rows )\n          continue; // Ignore too small splits\n        double sums2 = sums0[b  ]+sums1[b+1];\n        double ssqs2 = ssqs0[b  ]+ssqs1[b+1];\n        double si =    ssqs2     -sums2  *sums2  /   N   ; // Left+right, excluding 'b'\n        double sx =    ssqs [b]  -sums[b]*sums[b]/bins[b]; // Just 'b'\n        if( si < 0 ) si = 0;    // Roundoff error; sometimes goes negative\n        if( sx < 0 ) sx = 0;    // Roundoff error; sometimes goes negative\n        if( si+sx < best_se0+best_se1 ) { // Strictly less error?\n          best_se0 = si;   best_se1 = sx;\n          best = b;        equal = 1; // Equality check\n        }\n      }\n    }\n\n    // For categorical (unordered) predictors, we sorted the bins by average\n    // prediction then found the optimal split on sorted bins\n    IcedBitSet bs = null;       // In case we need an arbitrary bitset\n    if( idxs != null ) {        // We sorted bins; need to build a bitset\n      int min=Integer.MAX_VALUE;// Compute lower bound and span for bitset\n      int max=Integer.MIN_VALUE;\n      for( int i=best; i<nbins; i++ ) {\n        min=Math.min(min,idxs[i]);\n        max=Math.max(max,idxs[i]);\n      }\n      bs = new IcedBitSet(max-min+1,min); // Bitset with just enough span to cover the interesting bits\n      for( int i=best; i<nbins; i++ ) bs.set(idxs[i]); // Reverse the index then set bits\n      equal = (byte)(bs.max() <= 32 ? 2 : 3); // Flag for bitset split; also check max size\n    }\n\n    if( best==0 ) return null;  // No place to split\n    double se = ssqs1[0] - sums1[0]*sums1[0]/ns1[0]; // Squared Error with no split\n    if( se <= best_se0+best_se1) return null; // Ultimately roundoff error loses, and no split actually helped\n    double n0 = equal != 1 ?   ns0[best] :   ns0[best]+  ns1[best+1];\n    double n1 = equal != 1 ?   ns1[best] :  bins[best]              ;\n    double p0 = equal != 1 ? sums0[best] : sums0[best]+sums1[best+1];\n    double p1 = equal != 1 ? sums1[best] :  sums[best]              ;\n    if( MathUtils.equalsWithinOneSmallUlp((float)(p0/n0),(float)(p1/n1)) ) return null; // No difference in predictions, which are all at 1 float ULP\n    return new DTree.Split(col,best,bs,equal,se,best_se0,best_se1,n0,n1,p0/n0,p1/n1);\n  }","id":38224,"modified_method":"public DTree.Split scoreMSE( int col, double min_rows, int nid ) {\n    final int nbins = nbins();\n    assert nbins > 1;\n\n    // Histogram arrays used for splitting, these are either the original bins\n    // (for an ordered predictor), or sorted by the mean response (for an\n    // unordered predictor, i.e. categorical predictor).\n    double[] sums = _sums;\n    double[] ssqs = _ssqs;\n    double[] bins = _bins;\n    int idxs[] = null;          // and a reverse index mapping\n\n    // For categorical (unordered) predictors, sort the bins by average\n    // prediction then look for an optimal split.  Currently limited to categoricals\n    // where we're one-per-bin.  No point for 3 or fewer bins as all possible\n    // combinations (just 3) are tested without needing to sort.\n    if( _isInt == 2 && _step == 1.0f && nbins >= 4 ) {\n      // Sort the index by average response\n      idxs = MemoryManager.malloc4(nbins+1); // Reverse index\n      for( int i=0; i<nbins+1; i++ ) idxs[i] = i;\n      final double[] avgs = MemoryManager.malloc8d(nbins+1);\n      for( int i=0; i<nbins; i++ ) avgs[i] = _bins[i]==0 ? 0 : _sums[i]/_bins[i]; // Average response\n      avgs[nbins] = Double.MAX_VALUE;\n      ArrayUtils.sort(idxs, avgs);\n      // Fill with sorted data.  Makes a copy, so the original data remains in\n      // its original order.\n      sums = MemoryManager.malloc8d(nbins);\n      ssqs = MemoryManager.malloc8d(nbins);\n      bins = MemoryManager.malloc8d(nbins);\n      for( int i=0; i<nbins; i++ ) {\n        sums[i] = _sums[idxs[i]];\n        ssqs[i] = _ssqs[idxs[i]];\n        bins[i] = _bins[idxs[i]];\n      }\n    }\n\n    // Compute mean/var for cumulative bins from 0 to nbins inclusive.\n    double sums0[] = MemoryManager.malloc8d(nbins+1);\n    double ssqs0[] = MemoryManager.malloc8d(nbins+1);\n    double   ns0[] = MemoryManager.malloc8d(nbins+1);\n    for( int b=1; b<=nbins; b++ ) {\n      double m0 = sums0[b-1],  m1 = sums[b-1];\n      double s0 = ssqs0[b-1],  s1 = ssqs[b-1];\n      double k0 = ns0  [b-1],  k1 = bins[b-1];\n      if( k0==0 && k1==0 )\n        continue;\n      sums0[b] = m0+m1;\n      ssqs0[b] = s0+s1;\n      ns0  [b] = k0+k1;\n    }\n    double tot = ns0[nbins];\n    // Is any split possible with at least min_obs?\n    if( tot < 2*min_rows )\n      return null;\n    // If we see zero variance, we must have a constant response in this\n    // column.  Normally this situation is cut out before we even try to split,\n    // but we might have NA's in THIS column...\n    double var = ssqs0[nbins]*tot - sums0[nbins]*sums0[nbins];\n    if( var == 0 ) {\n      assert isConstantResponse();\n      return null;\n    }\n    // If variance is really small, then the predictions (which are all at\n    // single-precision resolution), will be all the same and the tree split\n    // will be in vain.\n    if( ((float)var) == 0f )\n      return null;\n\n    // Compute mean/var for cumulative bins from nbins to 0 inclusive.\n    double sums1[] = MemoryManager.malloc8d(nbins+1);\n    double ssqs1[] = MemoryManager.malloc8d(nbins+1);\n    double   ns1[] = MemoryManager.malloc8d(nbins+1);\n    for( int b=nbins-1; b>=0; b-- ) {\n      double m0 = sums1[b+1], m1 = sums[b];\n      double s0 = ssqs1[b+1], s1 = ssqs[b];\n      double k0 = ns1  [b+1], k1 = bins[b];\n      if( k0==0 && k1==0 )\n        continue;\n      sums1[b] = m0+m1;\n      ssqs1[b] = s0+s1;\n      ns1  [b] = k0+k1;\n      assert MathUtils.compare(ns0[b]+ns1[b],tot,1e-5,1e-5);\n    }\n\n    // Now roll the split-point across the bins.  There are 2 ways to do this:\n    // split left/right based on being less than some value, or being equal/\n    // not-equal to some value.  Equal/not-equal makes sense for categoricals\n    // but both splits could work for any integral datatype.  Do the less-than\n    // splits first.\n    int best=0;                         // The no-split\n    double best_se0=Double.MAX_VALUE;   // Best squared error\n    double best_se1=Double.MAX_VALUE;   // Best squared error\n    byte equal=0;                       // Ranged check\n    for( int b=1; b<=nbins-1; b++ ) {\n      if( bins[b] == 0 ) continue; // Ignore empty splits\n      if( ns0[b] < min_rows ) continue;\n      if( ns1[b] < min_rows ) break; // ns1 shrinks at the higher bin#s, so if it fails once it fails always\n      // We're making an unbiased estimator, so that MSE==Var.\n      // Then Squared Error = MSE*N = Var*N\n      //                    = (ssqs/N - mean^2)*N\n      //                    = ssqs - N*mean^2\n      //                    = ssqs - N*(sum/N)(sum/N)\n      //                    = ssqs - sum^2/N\n      double se0 = ssqs0[b] - sums0[b]*sums0[b]/ns0[b];\n      double se1 = ssqs1[b] - sums1[b]*sums1[b]/ns1[b];\n      if( se0 < 0 ) se0 = 0;    // Roundoff error; sometimes goes negative\n      if( se1 < 0 ) se1 = 0;    // Roundoff error; sometimes goes negative\n      if( (se0+se1 < best_se0+best_se1) || // Strictly less error?\n              // Or tied MSE, then pick split towards middle bins\n              (se0+se1 == best_se0+best_se1 &&\n                      Math.abs(b -(nbins>>1)) < Math.abs(best-(nbins>>1))) ) {\n        best_se0 = se0;   best_se1 = se1;\n        best = b;\n      }\n    }\n\n    // If the bin covers a single value, we can also try an equality-based split\n    if( _isInt > 0 && _step == 1.0f &&    // For any integral (not float) column\n            _maxEx-_min > 2 && idxs==null ) { // Also need more than 2 (boolean) choices to actually try a new split pattern\n      for( int b=1; b<=nbins-1; b++ ) {\n        if( bins[b] < min_rows ) continue; // Ignore too small splits\n        double N = ns0[b] + ns1[b+1];\n        if( N < min_rows )\n          continue; // Ignore too small splits\n        double sums2 = sums0[b  ]+sums1[b+1];\n        double ssqs2 = ssqs0[b  ]+ssqs1[b+1];\n        double si =    ssqs2     -sums2  *sums2  /   N   ; // Left+right, excluding 'b'\n        double sx =    ssqs [b]  -sums[b]*sums[b]/bins[b]; // Just 'b'\n        if( si < 0 ) si = 0;    // Roundoff error; sometimes goes negative\n        if( sx < 0 ) sx = 0;    // Roundoff error; sometimes goes negative\n        if( si+sx < best_se0+best_se1 ) { // Strictly less error?\n          best_se0 = si;   best_se1 = sx;\n          best = b;        equal = 1; // Equality check\n        }\n      }\n    }\n\n    // For categorical (unordered) predictors, we sorted the bins by average\n    // prediction then found the optimal split on sorted bins\n    IcedBitSet bs = null;       // In case we need an arbitrary bitset\n    if( idxs != null ) {        // We sorted bins; need to build a bitset\n      int min=Integer.MAX_VALUE;// Compute lower bound and span for bitset\n      int max=Integer.MIN_VALUE;\n      for( int i=best; i<nbins; i++ ) {\n        min=Math.min(min,idxs[i]);\n        max=Math.max(max,idxs[i]);\n      }\n      bs = new IcedBitSet(max-min+1,min); // Bitset with just enough span to cover the interesting bits\n      for( int i=best; i<nbins; i++ ) bs.set(idxs[i]); // Reverse the index then set bits\n      equal = (byte)(bs.max() <= 32 ? 2 : 3); // Flag for bitset split; also check max size\n    }\n\n    if( best==0 ) return null;  // No place to split\n    double se = ssqs1[0] - sums1[0]*sums1[0]/ns1[0]; // Squared Error with no split\n    if( se <= best_se0+best_se1) return null; // Ultimately roundoff error loses, and no split actually helped\n    double n0 = equal != 1 ?   ns0[best] :   ns0[best]+  ns1[best+1];\n    double n1 = equal != 1 ?   ns1[best] :  bins[best]              ;\n    double p0 = equal != 1 ? sums0[best] : sums0[best]+sums1[best+1];\n    double p1 = equal != 1 ? sums1[best] :  sums[best]              ;\n    if( MathUtils.equalsWithinOneSmallUlp((float)(p0/n0),(float)(p1/n1)) ) return null; // No difference in predictions, which are all at 1 float ULP\n    return new DTree.Split(col,best,bs,equal,se,best_se0,best_se1,n0,n1,p0/n0,p1/n1);\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DHistogram(String name, final int nbins, int nbins_cats, byte isInt, float min, float maxEx) {\n    assert nbins > 1;\n    assert nbins_cats > 1;\n    assert maxEx > min : \"Caller ensures \"+maxEx+\">\"+min+\", since if max==min== the column \"+name+\" is all constants\";\n    _isInt = isInt;\n    _name = name;\n    _min=min;\n    _maxEx=maxEx;               // Set Exclusive max\n    _min2 =  Float.MAX_VALUE;   // Set min/max to outer bounds\n    _maxIn= -Float.MAX_VALUE;\n    // See if we can show there are fewer unique elements than nbins.\n    // Common for e.g. boolean columns, or near leaves.\n    int xbins = isInt == 2 ? nbins_cats : nbins;\n    if( isInt>0 && maxEx-min <= xbins ) {\n      assert ((long)min)==min;                // No overflow\n      xbins = (char)((long)maxEx-(long)min);  // Shrink bins\n      _step = 1.0f;                           // Fixed stepsize\n    } else {\n      _step = xbins/(maxEx-min);              // Step size for linear interpolation, using mul instead of div\n      assert _step > 0 && !Float.isInfinite(_step);\n    }\n    _nbin = (char)xbins;\n    // Do not allocate the big arrays here; wait for scoreCols to pick which cols will be used.\n  }","id":38225,"modified_method":"public DHistogram(String name, final int nbins, int nbins_cats, byte isInt, double min, double maxEx) {\n    assert nbins > 1;\n    assert nbins_cats > 1;\n    assert maxEx > min : \"Caller ensures \"+maxEx+\">\"+min+\", since if max==min== the column \"+name+\" is all constants\";\n    _isInt = isInt;\n    _name = name;\n    _min=min;\n    _maxEx=maxEx;               // Set Exclusive max\n    _min2 =  Double.MAX_VALUE;   // Set min/max to outer bounds\n    _maxIn= -Double.MAX_VALUE;\n    // See if we can show there are fewer unique elements than nbins.\n    // Common for e.g. boolean columns, or near leaves.\n    int xbins = isInt == 2 ? nbins_cats : nbins;\n    if( isInt>0 && maxEx-min <= xbins ) {\n      assert ((long)min)==min;                // No overflow\n      xbins = (char)((long)maxEx-(long)min);  // Shrink bins\n      _step = 1.0f;                           // Fixed stepsize\n    } else {\n      _step = xbins/(maxEx-min);              // Step size for linear interpolation, using mul instead of div\n      assert _step > 0 && !Double.isInfinite(_step);\n    }\n    _nbin = (char)xbins;\n    // Do not allocate the big arrays here; wait for scoreCols to pick which cols will be used.\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"static private float find_maxEx(float maxIn, int isInt ) {\n    float ulp = Math.ulp(maxIn);\n    if( isInt > 0 && 1 > ulp ) ulp = 1;\n    float res = maxIn+ulp;\n    return Float.isInfinite(res) ? maxIn : res;\n  }","id":38226,"modified_method":"static private double find_maxEx(double maxIn, int isInt ) {\n    double ulp = Math.ulp(maxIn);\n    if( isInt > 0 && 1 > ulp ) ulp = 1;\n    double res = maxIn+ulp;\n    return Double.isInfinite(res) ? maxIn : res;\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"float find_min  () { return _min2 ; }","id":38227,"modified_method":"double find_min  () { return _min2 ; }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"float find_maxEx() { return find_maxEx(_maxIn,_isInt); }","id":38228,"modified_method":"double find_maxEx() { return find_maxEx(_maxIn,_isInt); }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"float find_maxIn() { return _maxIn; }","id":38229,"modified_method":"double find_maxIn() { return _maxIn; }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DHistogram[] split(int way, char nbins, char nbins_cats, double min_rows, DHistogram hs[], float splat) {\n      double n = way==0 ? _n0 : _n1;\n      if( n < min_rows || n <= 1 ) return null; // Too few elements\n      double se = way==0 ? _se0 : _se1;\n      if( se <= 1e-30 ) return null; // No point in splitting a perfect prediction\n\n      // Build a next-gen split point from the splitting bin\n      int cnt=0;                  // Count of possible splits\n      DHistogram nhists[] = new DHistogram[hs.length]; // A new histogram set\n      for( int j=0; j<hs.length; j++ ) { // For every column in the new split\n        DHistogram h = hs[j];            // old histogram of column\n        if( h == null ) continue;        // Column was not being tracked?\n        int adj_nbins      = Math.max(h.nbins()>>1,nbins);\n        // min & max come from the original column data, since splitting on an\n        // unrelated column will not change the j'th columns min/max.\n        // Tighten min/max based on actual observed data for tracked columns\n        float min, maxEx;\n        if( h._bins == null ) { // Not tracked this last pass?\n          min = h._min;         // Then no improvement over last go\n          maxEx = h._maxEx;\n        } else {                // Else pick up tighter observed bounds\n          min = h.find_min();   // Tracked inclusive lower bound\n          if( h.find_maxIn() == min ) continue; // This column will not split again\n          maxEx = h.find_maxEx(); // Exclusive max\n        }\n\n        // Tighter bounds on the column getting split: exactly each new\n        // DHistogram's bound are the bins' min & max.\n        if( _col==j ) {\n          switch( _equal ) {\n          case 0:  // Ranged split; know something about the left & right sides\n            if( h._bins[_bin]==0 )\n              throw H2O.unimpl(); // Here I should walk up & down same as split() above.\n            assert _bs==null : \"splat not defined for BitSet splits\";\n            float split = splat;\n            if( h._isInt > 0 ) split = (float)Math.ceil(split);\n            if( way == 0 ) maxEx= split;\n            else           min  = split;\n            break;\n          case 1:               // Equality split; no change on unequals-side\n            if( way == 1 ) continue; // but know exact bounds on equals-side - and this col will not split again\n            break;\n          case 2:               // BitSet (small) split\n          case 3:               // BitSet (big)   split\n            break;\n          default: throw H2O.fail();\n          }\n        }\n        if( min >  maxEx ) continue; // Happens for all-NA subsplits\n        if( MathUtils.equalsWithinOneSmallUlp(min, maxEx) ) continue; // This column will not split again\n        if( Float.isInfinite(adj_nbins/(maxEx-min)) ) continue;\n        if( h._isInt > 0 && !(min+1 < maxEx ) ) continue; // This column will not split again\n        assert min < maxEx && adj_nbins > 1 : \"\"+min+\"<\"+maxEx+\" nbins=\"+adj_nbins;\n        nhists[j] = DHistogram.make(h._name, adj_nbins, nbins_cats, h._isInt, min, maxEx);\n        cnt++;                    // At least some chance of splitting\n      }\n      return cnt == 0 ? null : nhists;\n    }","id":38230,"modified_method":"public DHistogram[] split(int way, char nbins, char nbins_cats, double min_rows, DHistogram hs[], double splat) {\n      double n = way==0 ? _n0 : _n1;\n      if( n < min_rows || n <= 1 ) return null; // Too few elements\n      double se = way==0 ? _se0 : _se1;\n      if( se <= 1e-30 ) return null; // No point in splitting a perfect prediction\n\n      // Build a next-gen split point from the splitting bin\n      int cnt=0;                  // Count of possible splits\n      DHistogram nhists[] = new DHistogram[hs.length]; // A new histogram set\n      for( int j=0; j<hs.length; j++ ) { // For every column in the new split\n        DHistogram h = hs[j];            // old histogram of column\n        if( h == null ) continue;        // Column was not being tracked?\n        int adj_nbins      = Math.max(h.nbins()>>1,nbins);\n        // min & max come from the original column data, since splitting on an\n        // unrelated column will not change the j'th columns min/max.\n        // Tighten min/max based on actual observed data for tracked columns\n        double min, maxEx;\n        if( h._bins == null ) { // Not tracked this last pass?\n          min = h._min;         // Then no improvement over last go\n          maxEx = h._maxEx;\n        } else {                // Else pick up tighter observed bounds\n          min = h.find_min();   // Tracked inclusive lower bound\n          if( h.find_maxIn() == min ) continue; // This column will not split again\n          maxEx = h.find_maxEx(); // Exclusive max\n        }\n\n        // Tighter bounds on the column getting split: exactly each new\n        // DHistogram's bound are the bins' min & max.\n        if( _col==j ) {\n          switch( _equal ) {\n          case 0:  // Ranged split; know something about the left & right sides\n            if( h._bins[_bin]==0 )\n              throw H2O.unimpl(); // Here I should walk up & down same as split() above.\n            assert _bs==null : \"splat not defined for BitSet splits\";\n            double split = splat;\n            if( h._isInt > 0 ) split = (float)Math.ceil(split);\n            if( way == 0 ) maxEx= split;\n            else           min  = split;\n            break;\n          case 1:               // Equality split; no change on unequals-side\n            if( way == 1 ) continue; // but know exact bounds on equals-side - and this col will not split again\n            break;\n          case 2:               // BitSet (small) split\n          case 3:               // BitSet (big)   split\n            break;\n          default: throw H2O.fail();\n          }\n        }\n        if( min >  maxEx ) continue; // Happens for all-NA subsplits\n        if( MathUtils.equalsWithinOneSmallUlp(min, maxEx) ) continue; // This column will not split again\n        if( Double.isInfinite(adj_nbins/(maxEx-min)) ) continue;\n        if( h._isInt > 0 && !(min+1 < maxEx ) ) continue; // This column will not split again\n        assert min < maxEx && adj_nbins > 1 : \"\"+min+\"<\"+maxEx+\" nbins=\"+adj_nbins;\n        nhists[j] = DHistogram.make(h._name, adj_nbins, nbins_cats, h._isInt, min, maxEx);\n        cnt++;                    // At least some chance of splitting\n      }\n      return cnt == 0 ? null : nhists;\n    }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"float splat(DHistogram hs[]) {\n      DHistogram h = hs[_col];\n      assert _bin > 0 && _bin < h.nbins();\n      assert _bs==null : \"Dividing point is a bitset, not a bin#, so dont call splat() as result is meaningless\";\n      if( _equal == 1 ) { assert h.bins(_bin)!=0; return h.binAt(_bin); }\n      assert _equal==0; // not here for bitset splits, just range splits\n      // Find highest non-empty bin below the split\n      int x=_bin-1;\n      while( x >= 0 && h.bins(x)==0 ) x--;\n      // Find lowest  non-empty bin above the split\n      int n=_bin;\n      while( n < h.nbins() && h.bins(n)==0 ) n++;\n      // Lo is the high-side of the low non-empty bin, rounded to int for int columns\n      // Hi is the low -side of the hi  non-empty bin, rounded to int for int columns\n\n      // Example: Suppose there are no empty bins, and we are splitting an\n      // integer column at 48.4 (more than nbins, so step != 1.0, perhaps\n      // step==1.8).  The next lowest non-empty bin is from 46.6 to 48.4, and\n      // we set lo=48.4.  The next highest non-empty bin is from 48.4 to 50.2\n      // and we set hi=48.4.  Since this is an integer column, we round lo to\n      // 48 (largest integer below the split) and hi to 49 (smallest integer\n      // above the split).  Finally we average them, and split at 48.5.\n      float lo = h.binAt(x+1);\n      float hi = h.binAt(n  );\n      if( h._isInt > 0 ) lo = h._step==1 ? lo-1 : (float)Math.floor(lo);\n      if( h._isInt > 0 ) hi = h._step==1 ? hi   : (float)Math.ceil (hi);\n      return (lo+hi)/2.0f;\n    }","id":38231,"modified_method":"float splat(DHistogram hs[]) {\n      DHistogram h = hs[_col];\n      assert _bin > 0 && _bin < h.nbins();\n      assert _bs==null : \"Dividing point is a bitset, not a bin#, so dont call splat() as result is meaningless\";\n      if( _equal == 1 ) { assert h.bins(_bin)!=0; return (float)h.binAt(_bin); }\n      assert _equal==0; // not here for bitset splits, just range splits\n      // Find highest non-empty bin below the split\n      int x=_bin-1;\n      while( x >= 0 && h.bins(x)==0 ) x--;\n      // Find lowest  non-empty bin above the split\n      int n=_bin;\n      while( n < h.nbins() && h.bins(n)==0 ) n++;\n      // Lo is the high-side of the low non-empty bin, rounded to int for int columns\n      // Hi is the low -side of the hi  non-empty bin, rounded to int for int columns\n\n      // Example: Suppose there are no empty bins, and we are splitting an\n      // integer column at 48.4 (more than nbins, so step != 1.0, perhaps\n      // step==1.8).  The next lowest non-empty bin is from 46.6 to 48.4, and\n      // we set lo=48.4.  The next highest non-empty bin is from 48.4 to 50.2\n      // and we set hi=48.4.  Since this is an integer column, we round lo to\n      // 48 (largest integer below the split) and hi to 49 (smallest integer\n      // above the split).  Finally we average them, and split at 48.5.\n      double lo = h.binAt(x+1);\n      double hi = h.binAt(n  );\n      if( h._isInt > 0 ) lo = h._step==1 ? lo-1 : Math.floor(lo);\n      if( h._isInt > 0 ) hi = h._step==1 ? hi   : Math.ceil (hi);\n      return (float)((lo+hi)/2.0);\n    }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public DecidedNode( UndecidedNode n, DHistogram hs[] ) {\n      super(n._tree,n._pid,n._nid); // Replace Undecided with this DecidedNode\n      _nids = new int[2];           // Split into 2 subsets\n      _split = bestCol(n,hs);       // Best split-point for this tree\n      if( _split._col == -1 ) {     // No good split?\n        // Happens because the predictor columns cannot split the responses -\n        // which might be because all predictor columns are now constant, or\n        // because all responses are now constant.\n        _splat = Float.NaN;\n        Arrays.fill(_nids,-1);\n        return;\n      }\n      _splat = (_split._equal == 0 || _split._equal == 1) ? _split.splat(hs) : -1; // Split-at value (-1 for group-wise splits)\n      final char nbins   = _tree._nbins;\n      final char nbins_cats = _tree._nbins_cats;\n      final double min_rows = _tree._min_rows;\n\n      for( int b=0; b<2; b++ ) { // For all split-points\n        // Setup for children splits\n        DHistogram nhists[] = _split.split(b,nbins, nbins_cats, min_rows, hs, _splat);\n        assert nhists==null || nhists.length==_tree._ncols;\n        _nids[b] = nhists == null ? -1 : makeUndecidedNode(nhists)._nid;\n      }\n    }","id":38232,"modified_method":"public DecidedNode( UndecidedNode n, DHistogram hs[] ) {\n      super(n._tree,n._pid,n._nid); // Replace Undecided with this DecidedNode\n      _nids = new int[2];           // Split into 2 subsets\n      _split = bestCol(n,hs);       // Best split-point for this tree\n      if( _split._col == -1 ) {     // No good split?\n        // Happens because the predictor columns cannot split the responses -\n        // which might be because all predictor columns are now constant, or\n        // because all responses are now constant.\n        _splat = Float.NaN;\n        Arrays.fill(_nids,-1);\n        return;\n      }\n      _splat = (_split._equal == 0 || _split._equal == 1) ? _split.splat(hs) : -1f; // Split-at value (-1 for group-wise splits)\n      final char nbins   = _tree._nbins;\n      final char nbins_cats = _tree._nbins_cats;\n      final double min_rows = _tree._min_rows;\n\n      for( int b=0; b<2; b++ ) { // For all split-points\n        // Setup for children splits\n        DHistogram nhists[] = _split.split(b,nbins, nbins_cats, min_rows, hs, _splat);\n        assert nhists==null || nhists.length==_tree._ncols;\n        _nids[b] = nhists == null ? -1 : makeUndecidedNode(nhists)._nid;\n      }\n    }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public int ns( Chunk chks[], int row ) {\n      float d = (float)chks[_split._col].atd(row);\n      int bin;\n      // Note that during *scoring* (as opposed to training), we can be exposed\n      // to data which is outside the bin limits.\n      if(_split._equal == 0)\n        bin = d >= _splat ? 1 : 0; //NaN goes to 0 // >= goes right\n      else if(_split._equal == 1)\n        bin = d == _splat ? 1 : 0; //NaN goes to 0\n      else\n        bin = _split._bs.contains((int)d) ? 1 : 0; // contains goes right\n      return _nids[bin];\n    }","id":38233,"modified_method":"public int ns( Chunk chks[], int row ) {\n      double d = chks[_split._col].atd(row);\n      int bin;\n      // Note that during *scoring* (as opposed to training), we can be exposed\n      // to data which is outside the bin limits.\n      if(_split._equal == 0)\n        bin = d >= _splat ? 1 : 0; //NaN goes to 0 // >= goes right\n      else if(_split._equal == 1)\n        bin = d == _splat ? 1 : 0; //NaN goes to 0\n      else\n        bin = _split._bs.contains((int)d) ? 1 : 0; // contains goes right\n      return _nids[bin];\n    }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"FindSplits(DHistogram[] hs, int col) { _hs = hs; _col = col; }","id":38234,"modified_method":"FindSplits(DHistogram[] hs, int col, int nid) { _hs = hs; _col = col; _nid = nid;}","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override\n      protected void compute2() {\n        _s = _hs[_col].scoreMSE(_col, _tree._min_rows);\n        tryComplete();\n      }","id":38235,"modified_method":"@Override\n      protected void compute2() {\n        _s = _hs[_col].scoreMSE(_col, _tree._min_rows, _nid);\n        tryComplete();\n      }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public Split bestCol( UndecidedNode u, DHistogram hs[] ) {\n      // Find the column with the best split (lowest score).  Unlike RF, DRF\n      // scores on all columns and selects splits on all columns.\n      DTree.Split best = new DTree.Split(-1,-1,null,(byte)0,Double.MAX_VALUE,Double.MAX_VALUE,Double.MAX_VALUE,0L,0L,0,0);\n      if( hs == null ) return best;\n      final int maxCols = u._scoreCols == null /* all cols */ ? hs.length : u._scoreCols.length;\n      FindSplits[] findSplits = new FindSplits[maxCols];\n      //total work is to find the best split across sum_over_cols_to_split(nbins)\n      long nbinsSum = 0;\n      for( int i=0; i<maxCols; i++ ) {\n        int col = u._scoreCols == null ? i : u._scoreCols[i];\n        if( hs[col]==null || hs[col].nbins() <= 1 ) continue;\n        nbinsSum += hs[col].nbins();\n      }\n      // for small work loads, do a serial loop, otherwise, submit work to FJ thread pool\n      final boolean isSmall = (nbinsSum <= 1024); //heuristic - 50 cols with 20 nbins, or 1 column with 1024 bins, etc.\n      for( int i=0; i<maxCols; i++ ) {\n        int col = u._scoreCols == null ? i : u._scoreCols[i];\n        if( hs[col]==null || hs[col].nbins() <= 1 ) continue;\n        findSplits[i] = new FindSplits(hs, col);\n        if (isSmall) findSplits[i].compute2();\n        else H2O.submitTask(findSplits[i]);\n      }\n      for( int i=0; i<maxCols; i++ ) {\n        if (findSplits[i]==null) continue;\n        findSplits[i].join();\n        DTree.Split s = findSplits[i]._s;\n        if( s == null ) continue;\n        if (s.se() < best.se()) best = s;\n      }\n      return best;\n    }","id":38236,"modified_method":"public Split bestCol( UndecidedNode u, DHistogram hs[] ) {\n      // Find the column with the best split (lowest score).  Unlike RF, DRF\n      // scores on all columns and selects splits on all columns.\n      DTree.Split best = new DTree.Split(-1,-1,null,(byte)0,Double.MAX_VALUE,Double.MAX_VALUE,Double.MAX_VALUE,0L,0L,0,0);\n      if( hs == null ) return best;\n      final int maxCols = u._scoreCols == null /* all cols */ ? hs.length : u._scoreCols.length;\n      FindSplits[] findSplits = new FindSplits[maxCols];\n      //total work is to find the best split across sum_over_cols_to_split(nbins)\n      long nbinsSum = 0;\n      for( int i=0; i<maxCols; i++ ) {\n        int col = u._scoreCols == null ? i : u._scoreCols[i];\n        if( hs[col]==null || hs[col].nbins() <= 1 ) continue;\n        nbinsSum += hs[col].nbins();\n      }\n      // for small work loads, do a serial loop, otherwise, submit work to FJ thread pool\n      final boolean isSmall = (nbinsSum <= 1024); //heuristic - 50 cols with 20 nbins, or 1 column with 1024 bins, etc.\n      for( int i=0; i<maxCols; i++ ) {\n        int col = u._scoreCols == null ? i : u._scoreCols[i];\n        if( hs[col]==null || hs[col].nbins() <= 1 ) continue;\n        findSplits[i] = new FindSplits(hs, col, u._nid);\n        if (isSmall) findSplits[i].compute2();\n        else H2O.submitTask(findSplits[i]);\n      }\n      for( int i=0; i<maxCols; i++ ) {\n        if (findSplits[i]==null) continue;\n        findSplits[i].join();\n        DTree.Split s = findSplits[i]._s;\n        if( s == null ) continue;\n        if (s.se() < best.se()) best = s;\n      }\n      return best;\n    }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void accum_subset(Chunk chks[], Chunk wrks, Chunk weight, int nnids[]) {\n    for( int row=0; row<nnids.length; row++ ) { // Over all rows\n      int nid = nnids[row];                     // Get Node to decide from\n      if( nid >= 0 ) {        // row already predicts perfectly or OOB\n        double w = weight.atd(row);\n        if (w == 0) continue;\n        double resp = wrks.atd(row);\n        assert !Double.isNaN(wrks.atd(row)); // Already marked as sampled-away\n        DHistogram nhs[] = _hcs[nid];\n        int sCols[] = _tree.undecided(nid+_leaf)._scoreCols; // Columns to score (null, or a list of selected cols)\n        if (sCols == null) {\n          for(int col=0; col<nhs.length; ++col ) { //all columns\n            if (nhs[col]!=null)\n              nhs[col].incr((float) chks[col].atd(row), resp, w); // Histogram row/col\n          }\n        } else {\n          for( int col : sCols )\n            nhs[col].incr((float) chks[col].atd(row), resp, w); // Histogram row/col\n        }\n      }\n    }\n  }","id":38237,"modified_method":"private void accum_subset(Chunk chks[], Chunk wrks, Chunk weight, int nnids[]) {\n    for( int row=0; row<nnids.length; row++ ) { // Over all rows\n      int nid = nnids[row];                     // Get Node to decide from\n      if( nid >= 0 ) {        // row already predicts perfectly or OOB\n        double w = weight.atd(row);\n        if (w == 0) continue;\n        double resp = wrks.atd(row);\n        assert !Double.isNaN(wrks.atd(row)); // Already marked as sampled-away\n        DHistogram nhs[] = _hcs[nid];\n        int sCols[] = _tree.undecided(nid+_leaf)._scoreCols; // Columns to score (null, or a list of selected cols)\n        if (sCols == null) {\n          for(int col=0; col<nhs.length; ++col ) { //all columns\n            if (nhs[col]!=null)\n              nhs[col].incr(chks[col].atd(row), resp, w); // Histogram row/col\n          }\n        } else {\n          for( int col : sCols )\n            nhs[col].incr(chks[col].atd(row), resp, w); // Histogram row/col\n        }\n      }\n    }\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private static void overAllRows(Chunk chks[], Chunk wrks, Chunk weight, int nh[], int[] rows, DHistogram hcs[][], int c, int n, double[] bins, double[] sums, double[] ssqs, int binslen) {\n    Chunk chk = chks[c];\n    final DHistogram rh = hcs[n][c];\n    if( rh==null ) return; // Ignore untracked columns in this split\n    double[] rhbins = rh._bins;\n    int rhbinslen = rhbins.length;\n    final int lo = n==0 ? 0 : nh[n-1];\n    final int hi = nh[n];\n    float min = rh._min2;\n    float max = rh._maxIn;\n    // While most of the time we are limited to nbins, we allow more bins\n    // in a few cases (top-level splits have few total bins across all\n    // the (few) splits) so it's safe to bin more; also categoricals want\n    // to split one bin-per-level no matter how many levels).\n    if( rhbinslen >= binslen) { // Grow bins if needed\n      bins = new double[rhbinslen];\n      sums = new double[rhbinslen];\n      ssqs = new double[rhbinslen];\n    }\n\n    // Gather all the data for this set of rows, for 1 column and 1 split/NID\n    // Gather min/max, sums and sum-squares.\n    for( int xrow=lo; xrow<hi; xrow++ ) {\n      int row = rows[xrow];\n      double w = weight.atd(row);\n      if (w == 0) continue;\n      float col_data = (float)chk.atd(row);\n      if( col_data < min ) min = col_data;\n      if( col_data > max ) max = col_data;\n      int b = rh.bin(col_data); // Compute bin# via linear interpolation\n      double resp = wrks.atd(row); // fitting target (residual)\n      double wy = w*resp;\n      bins[b] += w;                // Bump count in bin\n      sums[b] += wy;\n      ssqs[b] += wy*resp;\n    }\n\n    // Add all the data into the Histogram (atomically add)\n    rh.setMin(min);       // Track actual lower/upper bound per-bin\n    rh.setMax(max);\n    int len = rhbinslen;\n    for( int b=0; b<len; b++ ) { // Bump counts in bins\n      if( bins[b] != 0 ) { AtomicUtils.DoubleArray.add(rhbins,b,bins[b]); bins[b]=0; }\n      if( sums[b] != 0 ) { rh.incr1(b,sums[b],ssqs[b]); sums[b]=ssqs[b]=0; }\n    }\n  }","id":38238,"modified_method":"private static void overAllRows(Chunk chks[], Chunk wrks, Chunk weight, int nh[], int[] rows, DHistogram hcs[][], int c, int n, double[] bins, double[] sums, double[] ssqs, int binslen) {\n    Chunk chk = chks[c];\n    final DHistogram rh = hcs[n][c];\n    if( rh==null ) return; // Ignore untracked columns in this split\n    double[] rhbins = rh._bins;\n    int rhbinslen = rhbins.length;\n    final int lo = n==0 ? 0 : nh[n-1];\n    final int hi = nh[n];\n    double min = rh._min2;\n    double max = rh._maxIn;\n    // While most of the time we are limited to nbins, we allow more bins\n    // in a few cases (top-level splits have few total bins across all\n    // the (few) splits) so it's safe to bin more; also categoricals want\n    // to split one bin-per-level no matter how many levels).\n    if( rhbinslen >= binslen) { // Grow bins if needed\n      bins = new double[rhbinslen];\n      sums = new double[rhbinslen];\n      ssqs = new double[rhbinslen];\n    }\n\n    // Gather all the data for this set of rows, for 1 column and 1 split/NID\n    // Gather min/max, sums and sum-squares.\n    for( int xrow=lo; xrow<hi; xrow++ ) {\n      int row = rows[xrow];\n      double w = weight.atd(row);\n      if (w == 0) continue;\n      double col_data = chk.atd(row);\n      if( col_data < min ) min = col_data;\n      if( col_data > max ) max = col_data;\n      int b = rh.bin(col_data); // Compute bin# via linear interpolation\n      double resp = wrks.atd(row); // fitting target (residual)\n      double wy = w*resp;\n      bins[b] += w;                // Bump count in bin\n      sums[b] += wy;\n      ssqs[b] += wy*resp;\n    }\n\n    // Add all the data into the Histogram (atomically add)\n    rh.setMin(min);       // Track actual lower/upper bound per-bin\n    rh.setMax(max);\n    int len = rhbinslen;\n    for( int b=0; b<len; b++ ) { // Bump counts in bins\n      if( bins[b] != 0 ) { AtomicUtils.DoubleArray.add(rhbins,b,bins[b]); bins[b]=0; }\n      if( sums[b] != 0 ) { rh.incr1(b,sums[b],ssqs[b]); sums[b]=ssqs[b]=0; }\n    }\n  }","commit_id":"c8c3603b74c3739f88e4e48d09f8b2fd40577347","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void map( Chunk[] chks ) {\n        final Chunk    y       = importance ? chk_resp(chks) : null; // Response\n        final float [] rpred   = importance ? new float [1+_nclass] : null; // Row prediction\n        final double[] rowdata = importance ? new double[_ncols] : null; // Pre-allocated row data\n        final Chunk   oobt  = chk_oobt(chks); // Out-of-bag rows counter over all trees\n        // Iterate over all rows\n        for( int row=0; row<oobt._len; row++ ) {\n          boolean wasOOBRow = false;\n          // For all tree (i.e., k-classes)\n          for( int k=0; k<_nclass; k++ ) {\n            final DTree tree = _trees[k];\n            if( tree == null ) continue; // Empty class is ignored\n            // If we have all constant responses, then we do not split even the\n            // root and the residuals should be zero.\n            if( tree.root() instanceof LeafNode ) continue;\n            final Chunk nids = chk_nids(chks,k); // Node-ids  for this tree/class\n            final Chunk ct   = chk_tree(chks,k); // k-tree working column holding votes for given row\n            int nid = (int)nids.at8(row);         // Get Node to decide from\n            // Update only out-of-bag rows\n            // This is out-of-bag row - but we would like to track on-the-fly prediction for the row\n            if( ScoreBuildHistogram.isOOBRow(nid) ) { // The row should be OOB for all k-trees !!!\n              assert k==0 || wasOOBRow : \"Something is wrong: k-class trees oob row computing is broken! All k-trees should agree on oob row!\";\n              wasOOBRow = true;\n              nid = ScoreBuildHistogram.oob2Nid(nid);\n              if( tree.node(nid) instanceof UndecidedNode ) // If we bottomed out the tree\n                nid = tree.node(nid).pid();                 // Then take parent's decision\n              DecidedNode dn = tree.decided(nid);           // Must have a decision point\n              if( dn._split.col() == -1 )     // Unable to decide?\n                dn = tree.decided(tree.node(nid).pid());    // Then take parent's decision\n              int leafnid = dn.ns(chks,row); // Decide down to a leafnode\n              // Setup Tree(i) - on the fly prediction of i-tree for row-th row\n              //   - for classification: cumulative number of votes for this row\n              //   - for regression: cumulative sum of prediction of each tree - has to be normalized by number of trees\n              double prediction = ((LeafNode)tree.node(leafnid)).pred(); // Prediction for this k-class and this row\n              if (importance) rpred[1+k] = (float) prediction; // for both regression and classification\n              assert(ct.atd(row) >= 0);\n              ct.set(row, (float) (ct.atd(row) + prediction));\n              // For this tree this row is out-of-bag - i.e., a tree voted for this row\n              oobt.set(row, _nclass > 1 ? 1 : oobt.atd(row) + 1); // for regression track number of trees, for classification boolean flag is enough\n            }\n            // reset help column for this row and this k-class\n            nids.set(row, 0);\n          } /* end of k-trees iteration */\n          if (importance) {\n            if (wasOOBRow && !y.isNA(row)) {\n              if (isClassifier()) {\n                int treePred = getPrediction(rpred, data_row(chks, row, rowdata));\n                int actuPred = (int) y.at8(row);\n                if (treePred==actuPred) rightVotes++; // No miss !\n              } else { // regression\n                float  treePred = rpred[1];\n                float  actuPred = (float) y.atd(row);\n                sse += (actuPred-treePred)*(actuPred-treePred);\n              }\n              allRows++;\n            }\n          }\n        }\n      }","id":38239,"modified_method":"@Override public void map( Chunk[] chks ) {\n        final Chunk    y       = importance ? chk_resp(chks) : null; // Response\n        final float [] rpred   = importance ? new float [1+_nclass] : null; // Row prediction\n        final double[] rowdata = importance ? new double[_ncols] : null; // Pre-allocated row data\n        final Chunk   oobt  = chk_oobt(chks); // Out-of-bag rows counter over all trees\n        // Iterate over all rows\n        for( int row=0; row<oobt._len; row++ ) {\n          boolean wasOOBRow = false;\n          // For all tree (i.e., k-classes)\n          for( int k=0; k<_nclass; k++ ) {\n            final DTree tree = _trees[k];\n            if( tree == null ) continue; // Empty class is ignored\n            // If we have all constant responses, then we do not split even the\n            // root and the residuals should be zero.\n            if( tree.root() instanceof LeafNode ) continue;\n            final Chunk nids = chk_nids(chks,k); // Node-ids  for this tree/class\n            final Chunk ct   = chk_tree(chks,k); // k-tree working column holding votes for given row\n            int nid = (int)nids.at8(row);         // Get Node to decide from\n            // Update only out-of-bag rows\n            // This is out-of-bag row - but we would like to track on-the-fly prediction for the row\n            if( ScoreBuildHistogram.isOOBRow(nid) ) { // The row should be OOB for all k-trees !!!\n              assert k==0 || wasOOBRow : \"Something is wrong: k-class trees oob row computing is broken! All k-trees should agree on oob row!\";\n              wasOOBRow = true;\n              nid = ScoreBuildHistogram.oob2Nid(nid);\n              if( tree.node(nid) instanceof UndecidedNode ) // If we bottomed out the tree\n                nid = tree.node(nid).pid();                 // Then take parent's decision\n              DecidedNode dn = tree.decided(nid);           // Must have a decision point\n              if( dn._split.col() == -1 )     // Unable to decide?\n                dn = tree.decided(tree.node(nid).pid());    // Then take parent's decision\n              int leafnid = dn.ns(chks,row); // Decide down to a leafnode\n              // Setup Tree(i) - on the fly prediction of i-tree for row-th row\n              //   - for classification: cumulative number of votes for this row\n              //   - for regression: cumulative sum of prediction of each tree - has to be normalized by number of trees\n              double prediction = ((LeafNode)tree.node(leafnid)).pred(); // Prediction for this k-class and this row\n              if (importance) rpred[1+k] = (float) prediction; // for both regression and classification\n              assert(ct.atd(row) >= 0);\n              ct.set(row, (float) (ct.atd(row) + prediction));\n              // For this tree this row is out-of-bag - i.e., a tree voted for this row\n              oobt.set(row, _nclass > 1 ? 1 : oobt.atd(row) + 1); // for regression track number of trees, for classification boolean flag is enough\n            }\n            // reset help column for this row and this k-class\n            nids.set(row, 0);\n          } /* end of k-trees iteration */\n          if (importance) {\n            if (wasOOBRow && !y.isNA(row)) {\n              if (isClassifier()) {\n                int treePred = getPrediction(rpred, data_row(chks, row, rowdata));\n                int actuPred = (int) y.at8(row);\n                if (treePred==actuPred) rightVotes++; // No miss !\n              } else { // regression\n                float  treePred = rpred[1];\n                double actuPred = y.atd(row);\n                sse += (actuPred-treePred)*(actuPred-treePred);\n              }\n              allRows++;\n            }\n          }\n        }\n      }","commit_id":"921ba4dbf164bd05e4b5bc754771504995b4d8f3","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected float score1( Chunk chks[], float fs[/*nclass*/], int row ) {\n    float sum = 0;\n    if (_nclass > 1) { //classification\n      for (int k = 0; k < _nclass; k++)\n        sum += (fs[k+1] = (float) chk_tree(chks, k).atd(row));\n    } else { //regression\n      // average per trees voted for this row (only trees which have row in \"out-of-bag\"\n      sum += (fs[0] = (float) chk_tree(chks, 0).atd(row) / (float)chk_oobt(chks).atd(row) );\n      fs[1] = 0;\n    }\n    return sum;\n  }","id":38240,"modified_method":"@Override protected float score1( Chunk chks[], float fs[/*nclass*/], int row ) {\n    double sum = 0;\n    if (_nclass > 1) { //classification\n      for (int k = 0; k < _nclass; k++)\n        sum += (fs[k+1] = (float) chk_tree(chks, k).atd(row));\n    } else { //regression\n      // average per trees voted for this row (only trees which have row in \"out-of-bag\"\n      sum += (fs[0] = (float) chk_tree(chks, 0).atd(row) / (float)chk_oobt(chks).atd(row) );\n      fs[1] = 0;\n    }\n    return (float)sum;\n  }","commit_id":"921ba4dbf164bd05e4b5bc754771504995b4d8f3","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected float score1( Chunk chks[], float fs[/*nclass*/], int row ) {\n    if( _parms._loss == GBMModel.GBMParameters.Family.bernoulli ) {\n      fs[1] = 1.0f/(float)(1f+Math.exp(chk_tree(chks,0).atd(row)));\n      fs[2] = 1f-fs[1];\n      return fs[1]+fs[2];\n    }\n    if( _nclass == 1 ) // Regression\n      return fs[0]=(float)chk_tree(chks,0).atd(row);\n    if( _nclass == 2 ) {        // The Boolean Optimization\n      // This optimization assumes the 2nd tree of a 2-class system is the\n      // inverse of the first.  Fill in the missing tree\n      fs[1] = (float)Math.exp(chk_tree(chks,0).atd(row));\n      fs[2] = 1.0f/fs[1]; // exp(-d) === 1/exp(d)\n      return fs[1]+fs[2];\n    }\n    float sum=0;\n    for( int k=0; k<_nclass; k++ ) // Sum across of likelyhoods\n      sum+=(fs[k+1]=(float)Math.exp(chk_tree(chks,k).atd(row)));\n    return sum;\n  }","id":38241,"modified_method":"@Override protected float score1( Chunk chks[], float fs[/*nclass*/], int row ) {\n    if( _parms._loss == GBMModel.GBMParameters.Family.bernoulli ) {\n      fs[1] = 1.0f/(float)(1f+Math.exp(chk_tree(chks,0).atd(row)));\n      fs[2] = 1f-fs[1];\n      return fs[1]+fs[2];\n    }\n    if( _nclass == 1 ) // Regression\n      return fs[0]=(float)chk_tree(chks,0).atd(row);\n    if( _nclass == 2 ) {        // The Boolean Optimization\n      // This optimization assumes the 2nd tree of a 2-class system is the\n      // inverse of the first.  Fill in the missing tree\n      fs[1] = (float)Math.exp(chk_tree(chks,0).atd(row));\n      fs[2] = 1.0f/fs[1]; // exp(-d) === 1/exp(d)\n      return fs[1]+fs[2];\n    }\n    double sum=0;\n    for( int k=0; k<_nclass; k++ ) // Sum across of likelyhoods\n      sum+=(fs[k+1]=(float)Math.exp(chk_tree(chks,k).atd(row)));\n    return (float)sum;\n  }","commit_id":"921ba4dbf164bd05e4b5bc754771504995b4d8f3","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test public void testReprodubilityAirline() {\n    Frame tfr=null;\n    final int N = 1;\n    double[] mses = new double[N];\n\n    Scope.enter();\n    try {\n      // Load data, hack frames\n      tfr = parse_test_file(\"./smalldata/airlines/allyears2k_headers.zip\");\n\n      // rebalance to fixed number of chunks\n      Key dest = Key.make(\"df.rebalanced.hex\");\n      RebalanceDataSet rb = new RebalanceDataSet(tfr, dest, 256);\n      H2O.submitTask(rb);\n      rb.join();\n      tfr.delete();\n      tfr = DKV.get(dest).get();\n//      Scope.track(tfr.replace(54, tfr.vecs()[54].toEnum())._key);\n//      DKV.put(tfr);\n      for (String s : new String[]{\n          \"DepTime\", \"ArrTime\", \"ActualElapsedTime\",\n          \"AirTime\", \"ArrDelay\", \"DepDelay\", \"Cancelled\",\n          \"CancellationCode\", \"CarrierDelay\", \"WeatherDelay\",\n          \"NASDelay\", \"SecurityDelay\", \"LateAircraftDelay\", \"IsArrDelayed\"\n      }) {\n        tfr.remove(s).remove();\n      }\n      DKV.put(tfr);\n      for (int i=0; i<N; ++i) {\n        GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n        parms._train = tfr._key;\n        parms._response_column = \"IsDepDelayed\";\n        parms._nbins = 10;\n        parms._ntrees = 7;\n        parms._max_depth = 10;\n        parms._min_rows = 1;\n        parms._loss = Family.bernoulli;\n        parms._balance_classes = true;\n\n        // Build a first model; all remaining models should be equal\n        GBM job = new GBM(parms);\n        GBMModel gbm = job.trainModel().get();\n        assertEquals(gbm._output._ntrees, parms._ntrees);\n\n        mses[i] = gbm._output._mse_train[gbm._output._mse_train.length-1];\n        job.remove();\n        gbm.delete();\n      }\n    } finally {\n      if (tfr != null) tfr.remove();\n    }\n    Scope.exit();\n    for( double mse : mses )\n      assertEquals(0.2061627735630746, mse, 1e-8); //check for the same result on 1 nodes and 5 nodes (will only work with enough chunks)\n  }","id":38242,"modified_method":"@Test public void testReprodubilityAirline() {\n    Frame tfr=null;\n    final int N = 1;\n    double[] mses = new double[N];\n\n    Scope.enter();\n    try {\n      // Load data, hack frames\n      tfr = parse_test_file(\"./smalldata/airlines/allyears2k_headers.zip\");\n\n      // rebalance to fixed number of chunks\n      Key dest = Key.make(\"df.rebalanced.hex\");\n      RebalanceDataSet rb = new RebalanceDataSet(tfr, dest, 256);\n      H2O.submitTask(rb);\n      rb.join();\n      tfr.delete();\n      tfr = DKV.get(dest).get();\n//      Scope.track(tfr.replace(54, tfr.vecs()[54].toEnum())._key);\n//      DKV.put(tfr);\n      for (String s : new String[]{\n          \"DepTime\", \"ArrTime\", \"ActualElapsedTime\",\n          \"AirTime\", \"ArrDelay\", \"DepDelay\", \"Cancelled\",\n          \"CancellationCode\", \"CarrierDelay\", \"WeatherDelay\",\n          \"NASDelay\", \"SecurityDelay\", \"LateAircraftDelay\", \"IsArrDelayed\"\n      }) {\n        tfr.remove(s).remove();\n      }\n      DKV.put(tfr);\n      for (int i=0; i<N; ++i) {\n        GBMModel.GBMParameters parms = new GBMModel.GBMParameters();\n        parms._train = tfr._key;\n        parms._response_column = \"IsDepDelayed\";\n        parms._nbins = 10;\n        parms._ntrees = 7;\n        parms._max_depth = 5;\n        parms._min_rows = 10;\n        parms._loss = Family.bernoulli;\n        parms._balance_classes = true;\n\n        // Build a first model; all remaining models should be equal\n        GBM job = new GBM(parms);\n        GBMModel gbm = job.trainModel().get();\n        assertEquals(gbm._output._ntrees, parms._ntrees);\n\n        mses[i] = gbm._output._mse_train[gbm._output._mse_train.length-1];\n        job.remove();\n        gbm.delete();\n      }\n    } finally {\n      if (tfr != null) tfr.remove();\n    }\n    Scope.exit();\n    for( double mse : mses )\n      assertEquals(0.21925349482557605, mse, 1e-15); //check for the same result on 1 nodes and 5 nodes (will only work with enough chunks)\n  }","commit_id":"a7e1d84c8bfffc9ff552c7114c916fd7d330f093","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void accum_subset(Chunk chks[], Chunk wrks, int nnids[]) {\n    for( int row=0; row<nnids.length; row++ ) { // Over all rows\n      int nid = nnids[row];                     // Get Node to decide from\n      if( nid >= 0 ) {        // row already predicts perfectly or OOB\n        assert !Double.isNaN(wrks.atd(row)); // Already marked as sampled-away\n        DHistogram nhs[] = _hcs[nid];\n        int sCols[] = _tree.undecided(nid+_leaf)._scoreCols; // Columns to score (null, or a list of selected cols)\n        for( int col : sCols ) // For tracked cols\n        //FIXME/TODO: sum into local variables, do atomic increment once at the end, similar to accum_all\n          nhs[col].incr((float)chks[col].atd(row),(float)wrks.atd(row)); // Histogram row/col\n      }\n    }\n  }","id":38243,"modified_method":"private void accum_subset(Chunk chks[], Chunk wrks, int nnids[]) {\n    for( int row=0; row<nnids.length; row++ ) { // Over all rows\n      int nid = nnids[row];                     // Get Node to decide from\n      if( nid >= 0 ) {        // row already predicts perfectly or OOB\n        assert !Double.isNaN(wrks.atd(row)); // Already marked as sampled-away\n        DHistogram nhs[] = _hcs[nid];\n        int sCols[] = _tree.undecided(nid+_leaf)._scoreCols; // Columns to score (null, or a list of selected cols)\n        for( int col : sCols ) // For tracked cols\n        //FIXME/TODO: sum into local variables, do atomic increment once at the end, similar to accum_all\n          nhs[col].incr((float)chks[col].atd(row),wrks.atd(row)); // Histogram row/col\n      }\n    }\n  }","commit_id":"a7e1d84c8bfffc9ff552c7114c916fd7d330f093","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private void accum_all2(Chunk chks[], Chunk wrks, int nh[], int[] rows) {\n    final DHistogram hcs[][] = _hcs;\n    // Local temp arrays, no atomic updates.\n    int    bins[] = new int   [_nbins];\n    double sums[] = new double[_nbins];\n    double ssqs[] = new double[_nbins];\n    // For All Columns\n    for( int c=0; c<_ncols; c++) { // for all columns\n      Chunk chk = chks[c];\n      // For All NIDs\n      for( int n=0; n<hcs.length; n++ ) {\n        final DRealHistogram rh = ((DRealHistogram)hcs[n][c]);\n        if( rh==null ) continue; // Ignore untracked columns in this split\n        final int lo = n==0 ? 0 : nh[n-1];\n        final int hi = nh[n];\n        float min = rh._min2;\n        float max = rh._maxIn;\n        // While most of the time we are limited to nbins, we allow more bins\n        // in a few cases (top-level splits have few total bins across all\n        // the (few) splits) so it's safe to bin more; also categoricals want\n        // to split one bin-per-level no matter how many levels).\n        if( rh._bins.length >= bins.length ) { // Grow bins if needed\n          bins = new int   [rh._bins.length];\n          sums = new double[rh._bins.length];\n          ssqs = new double[rh._bins.length];\n        }\n\n        // Gather all the data for this set of rows, for 1 column and 1 split/NID\n        // Gather min/max, sums and sum-squares.\n        for( int xrow=lo; xrow<hi; xrow++ ) {\n          int row = rows[xrow];\n          float col_data = (float)chk.atd(row);\n          if( col_data < min ) min = col_data;\n          if( col_data > max ) max = col_data;\n          int b = rh.bin(col_data); // Compute bin# via linear interpolation\n          bins[b]++;                // Bump count in bin\n          double resp = wrks.atd(row);\n          sums[b] += resp;\n          ssqs[b] += resp*resp;\n        }\n\n        // Add all the data into the Histogram (atomically add)\n        rh.setMin(min);       // Track actual lower/upper bound per-bin\n        rh.setMax(max);\n        for( int b=0; b<rh._bins.length; b++ ) { // Bump counts in bins\n          if( bins[b] != 0 ) { AtomicUtils.IntArray.add(rh._bins,b,bins[b]); bins[b]=0; }\n          if( ssqs[b] != 0 ) { rh.incr1(b,sums[b],ssqs[b]); sums[b]=ssqs[b]=0; }\n        }\n      }\n    }\n  }","id":38244,"modified_method":"private void accum_all2(Chunk chks[], Chunk wrks, int nh[], int[] rows) {\n    final DHistogram hcs[][] = _hcs;\n    // Local temp arrays, no atomic updates.\n    int    bins[] = new int   [_nbins];\n    double sums[] = new double[_nbins];\n    double ssqs[] = new double[_nbins];\n    // For All Columns\n    for( int c=0; c<_ncols; c++) { // for all columns\n      Chunk chk = chks[c];\n      // For All NIDs\n      for( int n=0; n<hcs.length; n++ ) {\n        final DRealHistogram rh = ((DRealHistogram)hcs[n][c]);\n        if( rh==null ) continue; // Ignore untracked columns in this split\n        final int lo = n==0 ? 0 : nh[n-1];\n        final int hi = nh[n];\n        float min = rh._min2;\n        float max = rh._maxIn;\n        // While most of the time we are limited to nbins, we allow more bins\n        // in a few cases (top-level splits have few total bins across all\n        // the (few) splits) so it's safe to bin more; also categoricals want\n        // to split one bin-per-level no matter how many levels).\n        if( rh._bins.length >= bins.length ) { // Grow bins if needed\n          bins = new int   [rh._bins.length];\n          sums = new double[rh._bins.length];\n          ssqs = new double[rh._bins.length];\n        }\n\n        // Gather all the data for this set of rows, for 1 column and 1 split/NID\n        // Gather min/max, sums and sum-squares.\n        for( int xrow=lo; xrow<hi; xrow++ ) {\n          int row = rows[xrow];\n          float col_data = (float)chk.atd(row);\n          if( col_data < min ) min = col_data;\n          if( col_data > max ) max = col_data;\n          int b = rh.bin(col_data); // Compute bin# via linear interpolation\n          bins[b]++;                // Bump count in bin\n          double resp = wrks.atd(row);\n          sums[b] += resp;\n          ssqs[b] += resp*resp;\n        }\n\n        // Add all the data into the Histogram (atomically add)\n        rh.setMin(min);       // Track actual lower/upper bound per-bin\n        rh.setMax(max);\n        for( int b=0; b<rh._bins.length; b++ ) { // Bump counts in bins\n          if( bins[b] != 0 ) { AtomicUtils.IntArray.add(rh._bins,b,bins[b]); bins[b]=0; }\n          if( sums[b] != 0 ) { rh.incr1(b,sums[b],ssqs[b]); sums[b]=ssqs[b]=0; }\n        }\n      }\n    }\n  }","commit_id":"a7e1d84c8bfffc9ff552c7114c916fd7d330f093","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public boolean open() \r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\r\n\t\tprops.setLook(shell);\r\n\t\tshell.setImage((Image) GUIResource.getInstance().getImageConnection());\r\n\t\t\r\n\t\tlsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tslaveServer.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tmiddle = props.getMiddlePct();\r\n\t\tmargin = Const.MARGIN;\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tshell.setText(Messages.getString(\"SlaveServerDialog.Shell.Title\"));\r\n\t\tshell.setLayout (formLayout);\r\n \t\t\r\n\t\t// First, add the buttons...\r\n\t\t\r\n\t\t// Buttons\r\n\t\twOK     = new Button(shell, SWT.PUSH); \r\n\t\twOK.setText(\" &OK \");\r\n\r\n\t\twCancel = new Button(shell, SWT.PUSH); \r\n\t\twCancel.setText(\" &Cancel \");\r\n\n\t\tButton[] buttons = new Button[] { wOK, wCancel };\n\t\tBaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\n\t\t\r\n\t\t// The rest stays above the buttons...\r\n\t\t\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n\t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\n\t\taddServiceTab();\r\n\t\taddProxyTab();\n        \r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(0, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(wOK, -margin);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\r\n\t\t\r\n\t\t// Add listeners\r\n\t\twOK.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { ok(); } } );\r\n\t\twCancel.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { cancel(); } } );\r\n\t\t\r\n\t\tSelectionAdapter selAdapter=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\twUsername.addSelectionListener(selAdapter);\r\n\t\twPassword.addSelectionListener(selAdapter);\r\n\t\twHostname.addSelectionListener(selAdapter);\r\n\t\twPort.addSelectionListener(selAdapter);\r\n\t\twProxyHost.addSelectionListener(selAdapter);\r\n\t\twProxyPort.addSelectionListener(selAdapter);\r\n\t\twNonProxyHosts.addSelectionListener(selAdapter);\r\n\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\t\r\n\t\twTabFolder.setSelection(0);\r\n        \r\n\t\tgetData();\r\n\r\n\t\tBaseStepDialog.setSize(shell);\n\t\t\r\n\t\tshell.open();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\twhile (!shell.isDisposed()) \r\n\t\t{\r\n\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn ok;\r\n\t}","id":38245,"modified_method":"public boolean open() \r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\r\n\t\tprops.setLook(shell);\r\n\t\tshell.setImage( GUIResource.getInstance().getImageConnection());\r\n\t\t\r\n\t\tlsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tslaveServer.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tmiddle = props.getMiddlePct();\r\n\t\tmargin = Const.MARGIN;\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tshell.setText(Messages.getString(\"SlaveServerDialog.Shell.Title\"));\r\n\t\tshell.setLayout (formLayout);\r\n \t\t\r\n\t\t// First, add the buttons...\r\n\t\t\r\n\t\t// Buttons\r\n\t\twOK     = new Button(shell, SWT.PUSH); \r\n\t\twOK.setText(\" &OK \");\r\n\r\n\t\twCancel = new Button(shell, SWT.PUSH); \r\n\t\twCancel.setText(\" &Cancel \");\r\n\n\t\tButton[] buttons = new Button[] { wOK, wCancel };\n\t\tBaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\n\t\t\r\n\t\t// The rest stays above the buttons...\r\n\t\t\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n\t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\n\t\taddServiceTab();\r\n\t\taddProxyTab();\n        \r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(0, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(wOK, -margin);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\r\n\t\t\r\n\t\t// Add listeners\r\n\t\twOK.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { ok(); } } );\r\n\t\twCancel.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { cancel(); } } );\r\n\t\t\r\n\t\tSelectionAdapter selAdapter=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\twUsername.addSelectionListener(selAdapter);\r\n\t\twPassword.addSelectionListener(selAdapter);\r\n\t\twHostname.addSelectionListener(selAdapter);\r\n\t\twPort.addSelectionListener(selAdapter);\r\n\t\twProxyHost.addSelectionListener(selAdapter);\r\n\t\twProxyPort.addSelectionListener(selAdapter);\r\n\t\twNonProxyHosts.addSelectionListener(selAdapter);\r\n\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\t\r\n\t\twTabFolder.setSelection(0);\r\n        \r\n\t\tgetData();\r\n\r\n\t\tBaseStepDialog.setSize(shell);\n\t\t\r\n\t\tshell.open();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\twhile (!shell.isDisposed()) \r\n\t\t{\r\n\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn ok;\r\n\t}","commit_id":"46dba00727647d9aa68c9a9ee4143e6c6aa8ed20","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n    {\r\n        Shell parent = getParent();\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n        props.setLook(shell);\r\n\t\tshell.setImage((Image) GUIResource.getInstance().getImageConnection());\r\n\r\n        lsMod = new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                databaseMeta.setChanged();\r\n            }\r\n        };\r\n        changed = databaseMeta.hasChanged();\r\n\r\n        middle = props.getMiddlePct();\r\n        margin = Const.MARGIN;\r\n\r\n        FormLayout formLayout = new FormLayout();\r\n        formLayout.marginWidth = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setText(Messages.getString(\"DatabaseDialog.Shell.title\")); //$NON-NLS-1$\r\n        shell.setLayout(formLayout);\r\n\r\n        // First, add the buttons...\r\n\r\n        // Buttons\r\n        wOK = new Button(shell, SWT.PUSH);\r\n        wOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n        wTest = new Button(shell, SWT.PUSH);\r\n        wTest.setText(Messages.getString(\"DatabaseDialog.button.Test\")); //$NON-NLS-1$\r\n\r\n        wExp = new Button(shell, SWT.PUSH);\r\n        wExp.setText(Messages.getString(\"DatabaseDialog.button.Explore\")); //$NON-NLS-1$\r\n\r\n        wList = new Button(shell, SWT.PUSH);\r\n        wList.setText(Messages.getString(\"DatabaseDialog.button.FeatureList\")); //$NON-NLS-1$\r\n\r\n        wCancel = new Button(shell, SWT.PUSH);\r\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n        Button[] buttons = new Button[] { wOK, wTest, wExp, wList, wCancel };\r\n        BaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\r\n\r\n        // The rest stays above the buttons...\r\n\r\n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n        props.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\r\n        addGeneralTab();\r\n        addPoolTab();\r\n        addMySQLTab();\r\n        addOracleTab();\r\n        addInformixTab();\r\n        addSAPTab();\r\n        addMSSQLTab();\r\n        addGenericTab();\r\n        addOptionsTab();\r\n        addSQLTab();\r\n        addClusterTab();\r\n\r\n        FormData fdTabFolder = new FormData();\r\n        fdTabFolder.left = new FormAttachment(0, 0);\r\n        fdTabFolder.top = new FormAttachment(0, margin);\r\n        fdTabFolder.right = new FormAttachment(100, 0);\r\n        fdTabFolder.bottom = new FormAttachment(wOK, -margin);\r\n        wTabFolder.setLayoutData(fdTabFolder);\r\n\r\n        // Add listeners\r\n        wOK.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                ok();\r\n            }\r\n        });\r\n\r\n        wCancel.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n        wTest.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                test();\r\n            }\r\n        });\r\n        wExp.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                explore();\r\n            }\r\n        });\r\n        wList.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                showFeatureList();\r\n            }\r\n        });\r\n        SelectionAdapter selAdapter = new SelectionAdapter()\r\n        {\r\n            public void widgetDefaultSelected(SelectionEvent e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n        wHostName.addSelectionListener(selAdapter);\r\n        wDBName.addSelectionListener(selAdapter);\r\n        wPort.addSelectionListener(selAdapter);\r\n        wUsername.addSelectionListener(selAdapter);\r\n        wPassword.addSelectionListener(selAdapter);\r\n        wConn.addSelectionListener(selAdapter);\r\n        wData.addSelectionListener(selAdapter);\r\n        wIndex.addSelectionListener(selAdapter);\r\n\r\n        // OK, if the password contains a variable, we don't want to have the password hidden...\r\n        wPassword.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                checkPasswordVisible(wPassword.getTextWidget());\r\n            }\r\n        });\r\n\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener(new ShellAdapter()\r\n        {\r\n            public void shellClosed(ShellEvent e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n\r\n        wTabFolder.setSelection(0);\r\n\r\n        getData();\r\n        enableFields();\r\n\r\n        SelectionAdapter lsTypeAcc = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                enableFields();\r\n                setPortNumber();\r\n            }\r\n        };\r\n\r\n        wConnType.addSelectionListener(lsTypeAcc);\r\n        wConnAcc.addSelectionListener(lsTypeAcc);\r\n\r\n        BaseStepDialog.setSize(shell);\r\n\r\n        databaseMeta.setChanged(changed);\r\n        shell.open();\r\n        Display display = parent.getDisplay();\r\n        while (!shell.isDisposed())\r\n        {\r\n            if (!display.readAndDispatch()) display.sleep();\r\n        }\r\n        return databaseName;\r\n    }","id":38246,"modified_method":"public String open()\r\n    {\r\n        Shell parent = getParent();\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n        props.setLook(shell);\r\n\t\tshell.setImage(GUIResource.getInstance().getImageConnection());\r\n\r\n        lsMod = new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                databaseMeta.setChanged();\r\n            }\r\n        };\r\n        changed = databaseMeta.hasChanged();\r\n\r\n        middle = props.getMiddlePct();\r\n        margin = Const.MARGIN;\r\n\r\n        FormLayout formLayout = new FormLayout();\r\n        formLayout.marginWidth = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setText(Messages.getString(\"DatabaseDialog.Shell.title\")); //$NON-NLS-1$\r\n        shell.setLayout(formLayout);\r\n\r\n        // First, add the buttons...\r\n\r\n        // Buttons\r\n        wOK = new Button(shell, SWT.PUSH);\r\n        wOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n        wTest = new Button(shell, SWT.PUSH);\r\n        wTest.setText(Messages.getString(\"DatabaseDialog.button.Test\")); //$NON-NLS-1$\r\n\r\n        wExp = new Button(shell, SWT.PUSH);\r\n        wExp.setText(Messages.getString(\"DatabaseDialog.button.Explore\")); //$NON-NLS-1$\r\n\r\n        wList = new Button(shell, SWT.PUSH);\r\n        wList.setText(Messages.getString(\"DatabaseDialog.button.FeatureList\")); //$NON-NLS-1$\r\n\r\n        wCancel = new Button(shell, SWT.PUSH);\r\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n        Button[] buttons = new Button[] { wOK, wTest, wExp, wList, wCancel };\r\n        BaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\r\n\r\n        // The rest stays above the buttons...\r\n\r\n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n        props.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\r\n        addGeneralTab();\r\n        addPoolTab();\r\n        addMySQLTab();\r\n        addOracleTab();\r\n        addInformixTab();\r\n        addSAPTab();\r\n        addMSSQLTab();\r\n        addGenericTab();\r\n        addOptionsTab();\r\n        addSQLTab();\r\n        addClusterTab();\r\n\r\n        FormData fdTabFolder = new FormData();\r\n        fdTabFolder.left = new FormAttachment(0, 0);\r\n        fdTabFolder.top = new FormAttachment(0, margin);\r\n        fdTabFolder.right = new FormAttachment(100, 0);\r\n        fdTabFolder.bottom = new FormAttachment(wOK, -margin);\r\n        wTabFolder.setLayoutData(fdTabFolder);\r\n\r\n        // Add listeners\r\n        wOK.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                ok();\r\n            }\r\n        });\r\n\r\n        wCancel.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n        wTest.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                test();\r\n            }\r\n        });\r\n        wExp.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                explore();\r\n            }\r\n        });\r\n        wList.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                showFeatureList();\r\n            }\r\n        });\r\n        SelectionAdapter selAdapter = new SelectionAdapter()\r\n        {\r\n            public void widgetDefaultSelected(SelectionEvent e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n        wHostName.addSelectionListener(selAdapter);\r\n        wDBName.addSelectionListener(selAdapter);\r\n        wPort.addSelectionListener(selAdapter);\r\n        wUsername.addSelectionListener(selAdapter);\r\n        wPassword.addSelectionListener(selAdapter);\r\n        wConn.addSelectionListener(selAdapter);\r\n        wData.addSelectionListener(selAdapter);\r\n        wIndex.addSelectionListener(selAdapter);\r\n\r\n        // OK, if the password contains a variable, we don't want to have the password hidden...\r\n        wPassword.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                checkPasswordVisible(wPassword.getTextWidget());\r\n            }\r\n        });\r\n\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener(new ShellAdapter()\r\n        {\r\n            public void shellClosed(ShellEvent e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n\r\n        wTabFolder.setSelection(0);\r\n\r\n        getData();\r\n        enableFields();\r\n\r\n        SelectionAdapter lsTypeAcc = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                enableFields();\r\n                setPortNumber();\r\n            }\r\n        };\r\n\r\n        wConnType.addSelectionListener(lsTypeAcc);\r\n        wConnAcc.addSelectionListener(lsTypeAcc);\r\n\r\n        BaseStepDialog.setSize(shell);\r\n\r\n        databaseMeta.setChanged(changed);\r\n        shell.open();\r\n        Display display = parent.getDisplay();\r\n        while (!shell.isDisposed())\r\n        {\r\n            if (!display.readAndDispatch()) display.sleep();\r\n        }\r\n        return databaseName;\r\n    }","commit_id":"876727f0732d305eb725b20bde77e9f8bbab3eea","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n    {\r\n        Shell parent = getParent();\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n        props.setLook(shell);\r\n\t\tshell.setImage((Image) GUIResource.getInstance().getImageConnection());\r\n\r\n        lsMod = new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                databaseMeta.setChanged();\r\n            }\r\n        };\r\n        changed = databaseMeta.hasChanged();\r\n\r\n        middle = props.getMiddlePct();\r\n        margin = Const.MARGIN;\r\n\r\n        FormLayout formLayout = new FormLayout();\r\n        formLayout.marginWidth = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setText(Messages.getString(\"DatabaseDialog.Shell.title\")); //$NON-NLS-1$\r\n        shell.setLayout(formLayout);\r\n\r\n        // First, add the buttons...\r\n\r\n        // Buttons\r\n        wOK = new Button(shell, SWT.PUSH);\r\n        wOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n        wTest = new Button(shell, SWT.PUSH);\r\n        wTest.setText(Messages.getString(\"DatabaseDialog.button.Test\")); //$NON-NLS-1$\r\n\r\n        wExp = new Button(shell, SWT.PUSH);\r\n        wExp.setText(Messages.getString(\"DatabaseDialog.button.Explore\")); //$NON-NLS-1$\r\n\r\n        wList = new Button(shell, SWT.PUSH);\r\n        wList.setText(Messages.getString(\"DatabaseDialog.button.FeatureList\")); //$NON-NLS-1$\r\n\r\n        wCancel = new Button(shell, SWT.PUSH);\r\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n        Button[] buttons = new Button[] { wOK, wTest, wExp, wList, wCancel };\r\n        BaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\r\n\r\n        // The rest stays above the buttons...\r\n\r\n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n        props.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\r\n        addGeneralTab();\r\n        addPoolTab();\r\n        addMySQLTab();\r\n        addOracleTab();\r\n        addInformixTab();\r\n        addSAPTab();\r\n        addGenericTab();\r\n        addOptionsTab();\r\n        addSQLTab();\r\n        addClusterTab();\r\n\r\n        FormData fdTabFolder = new FormData();\r\n        fdTabFolder.left = new FormAttachment(0, 0);\r\n        fdTabFolder.top = new FormAttachment(0, margin);\r\n        fdTabFolder.right = new FormAttachment(100, 0);\r\n        fdTabFolder.bottom = new FormAttachment(wOK, -margin);\r\n        wTabFolder.setLayoutData(fdTabFolder);\r\n\r\n        // Add listeners\r\n        wOK.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                ok();\r\n            }\r\n        });\r\n\r\n        wCancel.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n        wTest.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                test();\r\n            }\r\n        });\r\n        wExp.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                explore();\r\n            }\r\n        });\r\n        wList.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                showFeatureList();\r\n            }\r\n        });\r\n        SelectionAdapter selAdapter = new SelectionAdapter()\r\n        {\r\n            public void widgetDefaultSelected(SelectionEvent e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n        wHostName.addSelectionListener(selAdapter);\r\n        wDBName.addSelectionListener(selAdapter);\r\n        wPort.addSelectionListener(selAdapter);\r\n        wUsername.addSelectionListener(selAdapter);\r\n        wPassword.addSelectionListener(selAdapter);\r\n        wConn.addSelectionListener(selAdapter);\r\n        wData.addSelectionListener(selAdapter);\r\n        wIndex.addSelectionListener(selAdapter);\r\n\r\n        // OK, if the password contains a variable, we don't want to have the password hidden...\r\n        wPassword.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                checkPasswordVisible(wPassword.getTextWidget());\r\n            }\r\n        });\r\n\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener(new ShellAdapter()\r\n        {\r\n            public void shellClosed(ShellEvent e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n\r\n        wTabFolder.setSelection(0);\r\n\r\n        getData();\r\n        enableFields();\r\n\r\n        SelectionAdapter lsTypeAcc = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                enableFields();\r\n                setPortNumber();\r\n            }\r\n        };\r\n\r\n        wConnType.addSelectionListener(lsTypeAcc);\r\n        wConnAcc.addSelectionListener(lsTypeAcc);\r\n\r\n        BaseStepDialog.setSize(shell);\r\n\r\n        databaseMeta.setChanged(changed);\r\n        shell.open();\r\n        Display display = parent.getDisplay();\r\n        while (!shell.isDisposed())\r\n        {\r\n            if (!display.readAndDispatch()) display.sleep();\r\n        }\r\n        return databaseName;\r\n    }","id":38247,"modified_method":"public String open()\r\n    {\r\n        Shell parent = getParent();\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n        props.setLook(shell);\r\n\t\tshell.setImage( GUIResource.getInstance().getImageConnection());\r\n\r\n        lsMod = new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                databaseMeta.setChanged();\r\n            }\r\n        };\r\n        changed = databaseMeta.hasChanged();\r\n\r\n        middle = props.getMiddlePct();\r\n        margin = Const.MARGIN;\r\n\r\n        FormLayout formLayout = new FormLayout();\r\n        formLayout.marginWidth = Const.FORM_MARGIN;\r\n        formLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n        shell.setText(Messages.getString(\"DatabaseDialog.Shell.title\")); //$NON-NLS-1$\r\n        shell.setLayout(formLayout);\r\n\r\n        // First, add the buttons...\r\n\r\n        // Buttons\r\n        wOK = new Button(shell, SWT.PUSH);\r\n        wOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\r\n\r\n        wTest = new Button(shell, SWT.PUSH);\r\n        wTest.setText(Messages.getString(\"DatabaseDialog.button.Test\")); //$NON-NLS-1$\r\n\r\n        wExp = new Button(shell, SWT.PUSH);\r\n        wExp.setText(Messages.getString(\"DatabaseDialog.button.Explore\")); //$NON-NLS-1$\r\n\r\n        wList = new Button(shell, SWT.PUSH);\r\n        wList.setText(Messages.getString(\"DatabaseDialog.button.FeatureList\")); //$NON-NLS-1$\r\n\r\n        wCancel = new Button(shell, SWT.PUSH);\r\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\r\n\r\n        Button[] buttons = new Button[] { wOK, wTest, wExp, wList, wCancel };\r\n        BaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\r\n\r\n        // The rest stays above the buttons...\r\n\r\n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n        props.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n\r\n        addGeneralTab();\r\n        addPoolTab();\r\n        addMySQLTab();\r\n        addOracleTab();\r\n        addInformixTab();\r\n        addSAPTab();\r\n        addGenericTab();\r\n        addOptionsTab();\r\n        addSQLTab();\r\n        addClusterTab();\r\n\r\n        FormData fdTabFolder = new FormData();\r\n        fdTabFolder.left = new FormAttachment(0, 0);\r\n        fdTabFolder.top = new FormAttachment(0, margin);\r\n        fdTabFolder.right = new FormAttachment(100, 0);\r\n        fdTabFolder.bottom = new FormAttachment(wOK, -margin);\r\n        wTabFolder.setLayoutData(fdTabFolder);\r\n\r\n        // Add listeners\r\n        wOK.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                ok();\r\n            }\r\n        });\r\n\r\n        wCancel.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n        wTest.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                test();\r\n            }\r\n        });\r\n        wExp.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                explore();\r\n            }\r\n        });\r\n        wList.addListener(SWT.Selection, new Listener()\r\n        {\r\n            public void handleEvent(Event e)\r\n            {\r\n                showFeatureList();\r\n            }\r\n        });\r\n        SelectionAdapter selAdapter = new SelectionAdapter()\r\n        {\r\n            public void widgetDefaultSelected(SelectionEvent e)\r\n            {\r\n                ok();\r\n            }\r\n        };\r\n        wHostName.addSelectionListener(selAdapter);\r\n        wDBName.addSelectionListener(selAdapter);\r\n        wPort.addSelectionListener(selAdapter);\r\n        wUsername.addSelectionListener(selAdapter);\r\n        wPassword.addSelectionListener(selAdapter);\r\n        wConn.addSelectionListener(selAdapter);\r\n        wData.addSelectionListener(selAdapter);\r\n        wIndex.addSelectionListener(selAdapter);\r\n\r\n        // OK, if the password contains a variable, we don't want to have the password hidden...\r\n        wPassword.addModifyListener(new ModifyListener()\r\n        {\r\n            public void modifyText(ModifyEvent e)\r\n            {\r\n                checkPasswordVisible(wPassword.getTextWidget());\r\n            }\r\n        });\r\n\r\n        // Detect X or ALT-F4 or something that kills this window...\r\n        shell.addShellListener(new ShellAdapter()\r\n        {\r\n            public void shellClosed(ShellEvent e)\r\n            {\r\n                cancel();\r\n            }\r\n        });\r\n\r\n        wTabFolder.setSelection(0);\r\n\r\n        getData();\r\n        enableFields();\r\n\r\n        SelectionAdapter lsTypeAcc = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                enableFields();\r\n                setPortNumber();\r\n            }\r\n        };\r\n\r\n        wConnType.addSelectionListener(lsTypeAcc);\r\n        wConnAcc.addSelectionListener(lsTypeAcc);\r\n\r\n        BaseStepDialog.setSize(shell);\r\n\r\n        databaseMeta.setChanged(changed);\r\n        shell.open();\r\n        Display display = parent.getDisplay();\r\n        while (!shell.isDisposed())\r\n        {\r\n            if (!display.readAndDispatch()) display.sleep();\r\n        }\r\n        return databaseName;\r\n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDatabases(ArrayList databases)\r\n    {\r\n        this.databases = databases;\r\n    }","id":38248,"modified_method":"public void setDatabases(ArrayList<DatabaseMeta> databases)\r\n    {\r\n        this.databases = databases;\r\n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public DatabaseExplorerDialog(Shell par, int style, DatabaseMeta conn, List databases, boolean look)\n    {\n        this(par, style, conn, databases, look, false);\n    }","id":38249,"modified_method":"public DatabaseExplorerDialog(Shell par, int style, DatabaseMeta conn, List<DatabaseMeta> databases, boolean look)\n    {\n        this(par, style, conn, databases, look, false);\n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, ArrayList databases)\n    {\n        this(par, style, conn, (List)databases);\n    }","id":38250,"modified_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, ArrayList<DatabaseMeta> databases)\n    {\n        this(par, style, conn, databases);\n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getDDLForOther(String tableName)\r\n\t{\n        if (databases!=null)\n        {\r\n    \t\tDatabase db = new Database(dbMeta);\r\n    \t\ttry\r\n    \t\t{\r\n    \t\t\tdb.connect();\r\n    \t\t\t\r\n    \t\t\tRowMetaInterface r = db.getTableFields(tableName);\r\n    \r\n    \t\t\t// Now select the other connection...\n                \n                // Only take non-SAP R/3 connections....\n                List dbs = new ArrayList();\n                for (int i=0;i<databases.size();i++) \n                    if (((DatabaseMeta)databases.get(i)).getDatabaseType()!=DatabaseMeta.TYPE_DATABASE_SAPR3) dbs.add(databases.get(i));\n                \n                String conn[] = new String[dbs.size()];\r\n    \t\t\tfor (int i=0;i<conn.length;i++) conn[i] = ((DatabaseMeta)dbs.get(i)).getName();\r\n    \t\t\t\r\n    \t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, conn, Messages.getString(\"DatabaseExplorerDialog.TargetDatabase.Title\"),\n                    Messages.getString(\"DatabaseExplorerDialog.TargetDatabase.Message\"));\r\n    \t\t\tString target = esd.open();\r\n    \t\t\tif (target!=null)\r\n    \t\t\t{\r\n    \t\t\t\tDatabaseMeta targetdbi = DatabaseMeta.findDatabase(dbs, target);\r\n    \t\t\t\tDatabase targetdb = new Database(targetdbi);\r\n    \r\n    \t\t\t\tString sql = targetdb.getCreateTableStatement(tableName, r, null, false, null, true);\r\n    \t\t\t\tSQLEditor se = new SQLEditor(shell, SWT.NONE, dbMeta, dbcache, sql);\r\n    \t\t\t\tse.open();\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tcatch(KettleDatabaseException dbe)\r\n    \t\t{\r\n    \t\t\tnew ErrorDialog(shell, Messages.getString(\"Dialog.Error.Header\"),\n                    Messages.getString(\"DatabaseExplorerDialog.Error.GenDDL\"), dbe);\r\n    \t\t}\r\n    \t\tfinally\r\n    \t\t{\r\n    \t\t\tdb.disconnect();\r\n    \t\t}\n        }\n        else\n        {\n            MessageBox mb = new MessageBox(shell, SWT.NONE | SWT.ICON_INFORMATION);\n            mb.setMessage(Messages.getString(\"DatabaseExplorerDialog.NoConnectionsKnown.Message\"));\n            mb.setText(Messages.getString(\"DatabaseExplorerDialog.NoConnectionsKnown.Title\"));\n            mb.open();\n        }\r\n\t}","id":38251,"modified_method":"public void getDDLForOther(String tableName)\r\n\t{\n        if (databases!=null)\n        {\r\n    \t\tDatabase db = new Database(dbMeta);\r\n    \t\ttry\r\n    \t\t{\r\n    \t\t\tdb.connect();\r\n    \t\t\t\r\n    \t\t\tRowMetaInterface r = db.getTableFields(tableName);\r\n    \r\n    \t\t\t// Now select the other connection...\n                \n                // Only take non-SAP R/3 connections....\n                List<DatabaseMeta> dbs = new ArrayList<DatabaseMeta>();\n                for (int i=0;i<databases.size();i++) \n                    if ((databases.get(i)).getDatabaseType()!=DatabaseMeta.TYPE_DATABASE_SAPR3) dbs.add(databases.get(i));\n                \n                String conn[] = new String[dbs.size()];\r\n    \t\t\tfor (int i=0;i<conn.length;i++) conn[i] = (dbs.get(i)).getName();\r\n    \t\t\t\r\n    \t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, conn, Messages.getString(\"DatabaseExplorerDialog.TargetDatabase.Title\"),\n                    Messages.getString(\"DatabaseExplorerDialog.TargetDatabase.Message\"));\r\n    \t\t\tString target = esd.open();\r\n    \t\t\tif (target!=null)\r\n    \t\t\t{\r\n    \t\t\t\tDatabaseMeta targetdbi = DatabaseMeta.findDatabase(dbs, target);\r\n    \t\t\t\tDatabase targetdb = new Database(targetdbi);\r\n    \r\n    \t\t\t\tString sql = targetdb.getCreateTableStatement(tableName, r, null, false, null, true);\r\n    \t\t\t\tSQLEditor se = new SQLEditor(shell, SWT.NONE, dbMeta, dbcache, sql);\r\n    \t\t\t\tse.open();\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tcatch(KettleDatabaseException dbe)\r\n    \t\t{\r\n    \t\t\tnew ErrorDialog(shell, Messages.getString(\"Dialog.Error.Header\"),\n                    Messages.getString(\"DatabaseExplorerDialog.Error.GenDDL\"), dbe);\r\n    \t\t}\r\n    \t\tfinally\r\n    \t\t{\r\n    \t\t\tdb.disconnect();\r\n    \t\t}\n        }\n        else\n        {\n            MessageBox mb = new MessageBox(shell, SWT.NONE | SWT.ICON_INFORMATION);\n            mb.setMessage(Messages.getString(\"DatabaseExplorerDialog.NoConnectionsKnown.Message\"));\n            mb.setText(Messages.getString(\"DatabaseExplorerDialog.NoConnectionsKnown.Title\"));\n            mb.open();\n        }\r\n\t}","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, List databases, boolean look)\n    {\n        this(par, style, conn, databases, look);\n    }","id":38252,"modified_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, List<DatabaseMeta> databases, boolean look)\n    {\n        this(par, style, conn, databases, look);\n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, List databases)\n    {\n        this(par, style, conn, databases);\n    }","id":38253,"modified_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, List<DatabaseMeta> databases)\n    {\n        this(par, style, conn, databases);\n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, ArrayList databases, boolean look)\n    {\n        this(par, style, conn, databases, look);\n    }","id":38254,"modified_method":"/** @deprecated */\n    public DatabaseExplorerDialog(Shell par, Props pr, int style, DatabaseMeta conn, ArrayList<DatabaseMeta> databases, boolean look)\n    {\n        this(par, style, conn, databases, look);\n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public DatabaseExplorerDialog(Shell par, int style, DatabaseMeta conn, List databases, boolean look, boolean splitSchemaAndTable)\n    {\n        super(par, style);\n        this.dbMeta=conn;\n        this.databases = databases;\n        this.justLook=look;\n        this.splitSchemaAndTable = splitSchemaAndTable;\n                \n        selectedSchema=null;\n        selectedTable=null;\n    \n        props=Props.getInstance();\n        log=LogWriter.getInstance();\n        dbcache = DBCache.getInstance();\n        \n    }","id":38255,"modified_method":"public DatabaseExplorerDialog(Shell par, int style, DatabaseMeta conn, List<DatabaseMeta> databases, boolean look, boolean splitSchemaAndTable)\n    {\n        super(par, style);\n        this.dbMeta=conn;\n        this.databases = databases;\n        this.justLook=look;\n        this.splitSchemaAndTable = splitSchemaAndTable;\n                \n        selectedSchema=null;\n        selectedTable=null;\n    \n        props=Props.getInstance();\n        log=LogWriter.getInstance();\n        dbcache = DBCache.getInstance();\n        \n    }","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public DatabaseExplorerDialog(Shell par, int style, DatabaseMeta conn, List databases)\r\n\t{\r\n\t\tthis(par, style, conn, databases, false, false);\r\n\t}","id":38256,"modified_method":"public DatabaseExplorerDialog(Shell par, int style, DatabaseMeta conn, List<DatabaseMeta> databases)\r\n\t{\r\n\t\tthis(par, style, conn, databases, false, false);\r\n\t}","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getData()\n\t{\n\t\tfor (int i=0;i<buffer.size();i++)\n\t\t{\n\t\t\tObject[] row = (Object[])buffer.get(i);\n\n\t\t\twFields.table.getItem(i).setText(0, \"\"+(position-scroll_size+i));\n\t\t\t\n\t\t\tfor (int c=0;c<rowMeta.size();c++)\n\t\t\t{\n\t\t\t\tValueMetaInterface v=rowMeta.getValueMeta(c);\n\t\t\t\tString show;\n                try\n                {\n    \t\t\t\tif (v.isNumeric()) show = v.getString(row[c]); // TODO add support for padding\n    \t\t\t\telse               show = v.getString(row[c]);\n    \t\t\t\twFields.table.getItem(i).setText(c+1, show);\n                }\n                catch(KettleValueException e)\n                {\n                    LogWriter.getInstance().logError(toString(), Const.getStackTracker(e));\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t}","id":38257,"modified_method":"public void getData()\n\t{\n\t\tfor (int i=0;i<buffer.size();i++)\n\t\t{\n\t\t\tObject[] row = buffer.get(i);\n\n\t\t\twFields.table.getItem(i).setText(0, \"\"+(position-scroll_size+i));\n\t\t\t\n\t\t\tfor (int c=0;c<rowMeta.size();c++)\n\t\t\t{\n\t\t\t\tValueMetaInterface v=rowMeta.getValueMeta(c);\n\t\t\t\tString show;\n                try\n                {\n    \t\t\t\tif (v.isNumeric()) show = v.getString(row[c]); // TODO add support for padding\n    \t\t\t\telse               show = v.getString(row[c]);\n    \t\t\t\twFields.table.getItem(i).setText(c+1, show);\n                }\n                catch(KettleValueException e)\n                {\n                    LogWriter.getInstance().logError(toString(), Const.getStackTracker(e));\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getNext() throws KettleException\n\t{\n\t\tbuffer = new ArrayList();\n\n\t\t// OK, now get a maximum of <scroll_size> rows\n\t\tObject[] row = db.getRow(rs);\n\t\tfor (int i=0;i<scroll_size && row!=null;i++)\n\t\t{\n\t\t\tposition++;\n\t\t\tif (position>max_position) max_position=position;\n\t\t\tbuffer.add(row);\n\n\t\t\trow = db.getRow(rs);\n\t\t}\n\t}","id":38258,"modified_method":"public void getNext() throws KettleException\n\t{\n\t\tbuffer = new ArrayList<Object[]>();\n\n\t\t// OK, now get a maximum of <scroll_size> rows\n\t\tObject[] row = db.getRow(rs);\n\t\tfor (int i=0;i<scroll_size && row!=null;i++)\n\t\t{\n\t\t\tposition++;\n\t\t\tif (position>max_position) max_position=position;\n\t\t\tbuffer.add(row);\n\n\t\t\trow = db.getRow(rs);\n\t\t}\n\t}","commit_id":"6e1f2c8be09a920881d186083afc8819f34f1fb0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean open() \r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\r\n \t\tprops.setLook(shell);\r\n\t\tshell.setImage((Image) GUIResource.getInstance().getImageConnection());\r\n\r\n\t\tlsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tclusterSchema.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tmiddle = props.getMiddlePct();\r\n\t\tmargin = Const.MARGIN;\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tshell.setText(Messages.getString(\"ClusterSchemaDialog.Shell.Title\"));\r\n\t\tshell.setLayout (formLayout);\r\n \t\t\r\n\t\t// First, add the buttons...\r\n\t\t\r\n\t\t// Buttons\r\n\t\twOK     = new Button(shell, SWT.PUSH); \r\n\t\twOK.setText(\" &OK \");\r\n\r\n\t\twCancel = new Button(shell, SWT.PUSH); \r\n\t\twCancel.setText(\" &Cancel \");\r\n\n\t\tButton[] buttons = new Button[] { wOK, wCancel };\n\t\tBaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\n\t\t\r\n\t\t// The rest stays above the buttons, so we added those first...\r\n        \r\n        // What's the schema name??\r\n        Label wlName = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlName);\r\n        wlName.setText(Messages.getString(\"ClusterSchemaDialog.Schema.Label\"));\r\n        FormData fdlName = new FormData();\r\n        fdlName.top   = new FormAttachment(0, 0);\r\n        fdlName.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlName.right = new FormAttachment(middle, 0);\r\n        wlName.setLayoutData(fdlName);\r\n\r\n        wName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wName);\r\n        wName.addModifyListener(lsMod);\r\n        FormData fdName = new FormData();\r\n        fdName.top  = new FormAttachment(0, 0);\r\n        fdName.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdName.right= new FormAttachment(95, 0);\r\n        wName.setLayoutData(fdName);\r\n        \r\n        // What's the base port??\r\n        Label wlPort = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlPort);\r\n        wlPort.setText(Messages.getString(\"ClusterSchemaDialog.Port.Label\"));\r\n        FormData fdlPort = new FormData();\r\n        fdlPort.top   = new FormAttachment(wName, margin);\r\n        fdlPort.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlPort.right = new FormAttachment(middle, 0);\r\n        wlPort.setLayoutData(fdlPort);\r\n\r\n        wPort = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wPort);\r\n        wPort.addModifyListener(lsMod);\r\n        FormData fdPort = new FormData();\r\n        fdPort.top  = new FormAttachment(wName, margin);\r\n        fdPort.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdPort.right= new FormAttachment(95, 0);\r\n        wPort.setLayoutData(fdPort);\r\n\r\n        \r\n        // What are the sockets buffer sizes??\r\n        Label wlBufferSize = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlBufferSize);\r\n        wlBufferSize.setText(Messages.getString(\"ClusterSchemaDialog.SocketBufferSize.Label\"));\r\n        FormData fdlBufferSize = new FormData();\r\n        fdlBufferSize.top   = new FormAttachment(wPort, margin);\r\n        fdlBufferSize.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlBufferSize.right = new FormAttachment(middle, 0);\r\n        wlBufferSize.setLayoutData(fdlBufferSize);\r\n\r\n        wBufferSize = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wBufferSize);\r\n        wBufferSize.addModifyListener(lsMod);\r\n        FormData fdBufferSize = new FormData();\r\n        fdBufferSize.top  = new FormAttachment(wPort, margin);\r\n        fdBufferSize.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdBufferSize.right= new FormAttachment(95, 0);\r\n        wBufferSize.setLayoutData(fdBufferSize);\r\n\r\n        // What are the sockets buffer sizes??\r\n        Label wlFlushInterval = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlFlushInterval);\r\n        wlFlushInterval.setText(Messages.getString(\"ClusterSchemaDialog.SocketFlushRows.Label\"));  \r\n        FormData fdlFlushInterval = new FormData();\r\n        fdlFlushInterval.top   = new FormAttachment(wBufferSize, margin);\r\n        fdlFlushInterval.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlFlushInterval.right = new FormAttachment(middle, 0);\r\n        wlFlushInterval.setLayoutData(fdlFlushInterval);\r\n\r\n        wFlushInterval = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wFlushInterval);\r\n        wFlushInterval.addModifyListener(lsMod);\r\n        FormData fdFlushInterval = new FormData();\r\n        fdFlushInterval.top  = new FormAttachment(wBufferSize, margin);\r\n        fdFlushInterval.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdFlushInterval.right= new FormAttachment(95, 0);\r\n        wFlushInterval.setLayoutData(fdFlushInterval);\r\n\r\n        // What are the sockets buffer sizes??\r\n        Label wlCompressed = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlCompressed);\r\n        wlCompressed.setText(Messages.getString(\"ClusterSchemaDialog.SocketDataCompressed.Label\"));\r\n        FormData fdlCompressed = new FormData();\r\n        fdlCompressed.top   = new FormAttachment(wFlushInterval, margin);\r\n        fdlCompressed.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlCompressed.right = new FormAttachment(middle, 0);\r\n        wlCompressed.setLayoutData(fdlCompressed);\r\n\r\n        wCompressed = new Button(shell, SWT.CHECK );\r\n        props.setLook(wCompressed);\r\n        FormData fdCompressed = new FormData();\r\n        fdCompressed.top  = new FormAttachment(wFlushInterval, margin);\r\n        fdCompressed.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdCompressed.right= new FormAttachment(95, 0);\r\n        wCompressed.setLayoutData(fdCompressed);\r\n\r\n        \r\n        // Schema servers:\r\n        Label wlServers = new Label(shell, SWT.RIGHT);\r\n        wlServers.setText(Messages.getString(\"ClusterSchemaDialog.SlaveServers.Label\"));\r\n        props.setLook(wlServers);\r\n        FormData fdlServers=new FormData();\r\n        fdlServers.left = new FormAttachment(0, 0);\r\n        fdlServers.right = new FormAttachment(middle, 0);\r\n        fdlServers.top  = new FormAttachment(wCompressed, margin);\r\n        wlServers.setLayoutData(fdlServers);\r\n        \r\n        // Some buttons to manage...\r\n        wSelect = new Button(shell, SWT.PUSH);\r\n        wSelect.setText(Messages.getString(\"ClusterSchemaDialog.SelectSlaveServers.Label\"));\r\n        props.setLook(wSelect);\r\n        FormData fdSelect=new FormData();\r\n        fdSelect.right= new FormAttachment(100, 0);\r\n        fdSelect.top  = new FormAttachment(wlServers, 5*margin);\r\n        wSelect.setLayoutData(fdSelect);\r\n        wSelect.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { selectSlaveServers(); }});\r\n\r\n        ColumnInfo[] partitionColumns = new ColumnInfo[] { \r\n                new ColumnInfo( Messages.getString(\"ClusterSchemaDialog.ColumnInfoName.Label\"), ColumnInfo.COLUMN_TYPE_TEXT, true, false), //$NON-NLS-1$\r\n                new ColumnInfo( Messages.getString(\"ClusterSchemaDialog.ColumnInfoServiceURL.Label\"), ColumnInfo.COLUMN_TYPE_TEXT, true, true), //$NON-NLS-1$\r\n                new ColumnInfo( Messages.getString(\"ClusterSchemaDialog.ColumnInfoMaster.Label\"), ColumnInfo.COLUMN_TYPE_TEXT, true, true), //$NON-NLS-1$\r\n        };\r\n        wServers = new TableView(shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.SINGLE, partitionColumns, 1, lsMod, props);\r\n        wServers.setReadonly(false);\r\n        props.setLook(wServers);\r\n        FormData fdServers = new FormData();\r\n        fdServers.left = new FormAttachment(middle, margin );\r\n        fdServers.right = new FormAttachment(wSelect, -2*margin);\r\n        fdServers.top = new FormAttachment(wCompressed, margin);\r\n        fdServers.bottom = new FormAttachment(wOK, -margin * 2);\r\n        wServers.setLayoutData(fdServers);\r\n        wServers.table.addSelectionListener(new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { editSlaveServer(); }});\r\n\t\t\r\n\t\t// Add listeners\r\n\t\twOK.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { ok(); } } );\r\n        wCancel.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { cancel(); } } );\r\n\t\t\r\n        SelectionAdapter selAdapter=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\twName.addSelectionListener(selAdapter);\r\n        wPort.addSelectionListener(selAdapter);\r\n        wBufferSize.addSelectionListener(selAdapter);\r\n        wFlushInterval.addSelectionListener(selAdapter);\r\n\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\t\r\n\t\tgetData();\r\n\r\n\t\tBaseStepDialog.setSize(shell);\n\t\t\r\n\t\tshell.open();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\twhile (!shell.isDisposed()) {\r\n\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn ok;\r\n\t}","id":38259,"modified_method":"public boolean open() \r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN );\r\n \t\tprops.setLook(shell);\r\n\t\tshell.setImage( GUIResource.getInstance().getImageConnection());\r\n\r\n\t\tlsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tclusterSchema.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tmiddle = props.getMiddlePct();\r\n\t\tmargin = Const.MARGIN;\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tshell.setText(Messages.getString(\"ClusterSchemaDialog.Shell.Title\"));\r\n\t\tshell.setLayout (formLayout);\r\n \t\t\r\n\t\t// First, add the buttons...\r\n\t\t\r\n\t\t// Buttons\r\n\t\twOK     = new Button(shell, SWT.PUSH); \r\n\t\twOK.setText(\" &OK \");\r\n\r\n\t\twCancel = new Button(shell, SWT.PUSH); \r\n\t\twCancel.setText(\" &Cancel \");\r\n\n\t\tButton[] buttons = new Button[] { wOK, wCancel };\n\t\tBaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\n\t\t\r\n\t\t// The rest stays above the buttons, so we added those first...\r\n        \r\n        // What's the schema name??\r\n        Label wlName = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlName);\r\n        wlName.setText(Messages.getString(\"ClusterSchemaDialog.Schema.Label\"));\r\n        FormData fdlName = new FormData();\r\n        fdlName.top   = new FormAttachment(0, 0);\r\n        fdlName.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlName.right = new FormAttachment(middle, 0);\r\n        wlName.setLayoutData(fdlName);\r\n\r\n        wName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wName);\r\n        wName.addModifyListener(lsMod);\r\n        FormData fdName = new FormData();\r\n        fdName.top  = new FormAttachment(0, 0);\r\n        fdName.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdName.right= new FormAttachment(95, 0);\r\n        wName.setLayoutData(fdName);\r\n        \r\n        // What's the base port??\r\n        Label wlPort = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlPort);\r\n        wlPort.setText(Messages.getString(\"ClusterSchemaDialog.Port.Label\"));\r\n        FormData fdlPort = new FormData();\r\n        fdlPort.top   = new FormAttachment(wName, margin);\r\n        fdlPort.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlPort.right = new FormAttachment(middle, 0);\r\n        wlPort.setLayoutData(fdlPort);\r\n\r\n        wPort = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wPort);\r\n        wPort.addModifyListener(lsMod);\r\n        FormData fdPort = new FormData();\r\n        fdPort.top  = new FormAttachment(wName, margin);\r\n        fdPort.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdPort.right= new FormAttachment(95, 0);\r\n        wPort.setLayoutData(fdPort);\r\n\r\n        \r\n        // What are the sockets buffer sizes??\r\n        Label wlBufferSize = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlBufferSize);\r\n        wlBufferSize.setText(Messages.getString(\"ClusterSchemaDialog.SocketBufferSize.Label\"));\r\n        FormData fdlBufferSize = new FormData();\r\n        fdlBufferSize.top   = new FormAttachment(wPort, margin);\r\n        fdlBufferSize.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlBufferSize.right = new FormAttachment(middle, 0);\r\n        wlBufferSize.setLayoutData(fdlBufferSize);\r\n\r\n        wBufferSize = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wBufferSize);\r\n        wBufferSize.addModifyListener(lsMod);\r\n        FormData fdBufferSize = new FormData();\r\n        fdBufferSize.top  = new FormAttachment(wPort, margin);\r\n        fdBufferSize.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdBufferSize.right= new FormAttachment(95, 0);\r\n        wBufferSize.setLayoutData(fdBufferSize);\r\n\r\n        // What are the sockets buffer sizes??\r\n        Label wlFlushInterval = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlFlushInterval);\r\n        wlFlushInterval.setText(Messages.getString(\"ClusterSchemaDialog.SocketFlushRows.Label\"));  \r\n        FormData fdlFlushInterval = new FormData();\r\n        fdlFlushInterval.top   = new FormAttachment(wBufferSize, margin);\r\n        fdlFlushInterval.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlFlushInterval.right = new FormAttachment(middle, 0);\r\n        wlFlushInterval.setLayoutData(fdlFlushInterval);\r\n\r\n        wFlushInterval = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\r\n        props.setLook(wFlushInterval);\r\n        wFlushInterval.addModifyListener(lsMod);\r\n        FormData fdFlushInterval = new FormData();\r\n        fdFlushInterval.top  = new FormAttachment(wBufferSize, margin);\r\n        fdFlushInterval.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdFlushInterval.right= new FormAttachment(95, 0);\r\n        wFlushInterval.setLayoutData(fdFlushInterval);\r\n\r\n        // What are the sockets buffer sizes??\r\n        Label wlCompressed = new Label(shell, SWT.RIGHT); \r\n        props.setLook(wlCompressed);\r\n        wlCompressed.setText(Messages.getString(\"ClusterSchemaDialog.SocketDataCompressed.Label\"));\r\n        FormData fdlCompressed = new FormData();\r\n        fdlCompressed.top   = new FormAttachment(wFlushInterval, margin);\r\n        fdlCompressed.left  = new FormAttachment(0, 0);  // First one in the left top corner\r\n        fdlCompressed.right = new FormAttachment(middle, 0);\r\n        wlCompressed.setLayoutData(fdlCompressed);\r\n\r\n        wCompressed = new Button(shell, SWT.CHECK );\r\n        props.setLook(wCompressed);\r\n        FormData fdCompressed = new FormData();\r\n        fdCompressed.top  = new FormAttachment(wFlushInterval, margin);\r\n        fdCompressed.left = new FormAttachment(middle, margin); // To the right of the label\r\n        fdCompressed.right= new FormAttachment(95, 0);\r\n        wCompressed.setLayoutData(fdCompressed);\r\n\r\n        \r\n        // Schema servers:\r\n        Label wlServers = new Label(shell, SWT.RIGHT);\r\n        wlServers.setText(Messages.getString(\"ClusterSchemaDialog.SlaveServers.Label\"));\r\n        props.setLook(wlServers);\r\n        FormData fdlServers=new FormData();\r\n        fdlServers.left = new FormAttachment(0, 0);\r\n        fdlServers.right = new FormAttachment(middle, 0);\r\n        fdlServers.top  = new FormAttachment(wCompressed, margin);\r\n        wlServers.setLayoutData(fdlServers);\r\n        \r\n        // Some buttons to manage...\r\n        wSelect = new Button(shell, SWT.PUSH);\r\n        wSelect.setText(Messages.getString(\"ClusterSchemaDialog.SelectSlaveServers.Label\"));\r\n        props.setLook(wSelect);\r\n        FormData fdSelect=new FormData();\r\n        fdSelect.right= new FormAttachment(100, 0);\r\n        fdSelect.top  = new FormAttachment(wlServers, 5*margin);\r\n        wSelect.setLayoutData(fdSelect);\r\n        wSelect.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { selectSlaveServers(); }});\r\n\r\n        ColumnInfo[] partitionColumns = new ColumnInfo[] { \r\n                new ColumnInfo( Messages.getString(\"ClusterSchemaDialog.ColumnInfoName.Label\"), ColumnInfo.COLUMN_TYPE_TEXT, true, false), //$NON-NLS-1$\r\n                new ColumnInfo( Messages.getString(\"ClusterSchemaDialog.ColumnInfoServiceURL.Label\"), ColumnInfo.COLUMN_TYPE_TEXT, true, true), //$NON-NLS-1$\r\n                new ColumnInfo( Messages.getString(\"ClusterSchemaDialog.ColumnInfoMaster.Label\"), ColumnInfo.COLUMN_TYPE_TEXT, true, true), //$NON-NLS-1$\r\n        };\r\n        wServers = new TableView(shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.SINGLE, partitionColumns, 1, lsMod, props);\r\n        wServers.setReadonly(false);\r\n        props.setLook(wServers);\r\n        FormData fdServers = new FormData();\r\n        fdServers.left = new FormAttachment(middle, margin );\r\n        fdServers.right = new FormAttachment(wSelect, -2*margin);\r\n        fdServers.top = new FormAttachment(wCompressed, margin);\r\n        fdServers.bottom = new FormAttachment(wOK, -margin * 2);\r\n        wServers.setLayoutData(fdServers);\r\n        wServers.table.addSelectionListener(new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { editSlaveServer(); }});\r\n\t\t\r\n\t\t// Add listeners\r\n\t\twOK.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { ok(); } } );\r\n        wCancel.addListener(SWT.Selection, new Listener () { public void handleEvent (Event e) { cancel(); } } );\r\n\t\t\r\n        SelectionAdapter selAdapter=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\twName.addSelectionListener(selAdapter);\r\n        wPort.addSelectionListener(selAdapter);\r\n        wBufferSize.addSelectionListener(selAdapter);\r\n        wFlushInterval.addSelectionListener(selAdapter);\r\n\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\t\r\n\t\tgetData();\r\n\r\n\t\tBaseStepDialog.setSize(shell);\n\t\t\r\n\t\tshell.open();\r\n\t\tDisplay display = parent.getDisplay();\r\n\t\twhile (!shell.isDisposed()) {\r\n\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn ok;\r\n\t}","commit_id":"89c3f221516a6125ed81eab5d87f67609698e16c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void testDuelTerms() throws Exception {\n        final int numDocs = scaledRandomIntBetween(1000, 2000);\n        final int maxNumTerms = randomIntBetween(10, 5000);\n\n        final IntOpenHashSet valuesSet = new IntOpenHashSet();\n        immutableCluster().wipeIndices(\"idx\");\n        prepareCreate(\"idx\")\n                .setSettings(ImmutableSettings.builder().put(InternalGlobalOrdinalsBuilder.ORDINAL_MAPPING_THRESHOLD_INDEX_SETTING_KEY, randomIntBetween(1, maxNumTerms)))\n                .addMapping(\"type\", jsonBuilder().startObject()\n                        .startObject(\"type\")\n                        .startObject(\"properties\")\n                        .startObject(\"string_values\")\n                        .field(\"type\", \"string\")\n                        .field(\"index\", \"not_analyzed\")\n                        .startObject(\"fields\")\n                            .startObject(\"doc_values\")\n                                .field(\"type\", \"string\")\n                                .field(\"index\", \"no\")\n                                .startObject(\"fielddata\")\n                                    .field(\"format\", \"doc_values\")\n                                .endObject()\n                            .endObject()\n                        .endObject()\n                        .endObject()\n                        .startObject(\"long_values\")\n                        .field(\"type\", \"long\")\n                        .endObject()\n                        .startObject(\"double_values\")\n                        .field(\"type\", \"double\")\n                        .endObject()\n                        .endObject()\n                        .endObject()).execute().actionGet();\n\n        List<IndexRequestBuilder> indexingRequests = Lists.newArrayList();\n        for (int i = 0; i < numDocs; ++i) {\n            final int[] values = new int[randomInt(4)];\n            for (int j = 0; j < values.length; ++j) {\n                values[j] = randomInt(maxNumTerms - 1) - 1000;\n                valuesSet.add(values[j]);\n            }\n            XContentBuilder source = jsonBuilder()\n                    .startObject()\n                    .field(\"num\", randomDouble())\n                    .startArray(\"long_values\");\n            for (int j = 0; j < values.length; ++j) {\n                source = source.value(values[j]);\n            }\n            source = source.endArray().startArray(\"double_values\");\n            for (int j = 0; j < values.length; ++j) {\n                source = source.value((double) values[j]);\n            }\n            source = source.endArray().startArray(\"string_values\");\n            for (int j = 0; j < values.length; ++j) {\n                source = source.value(Integer.toString(values[j]));\n            }\n            source = source.endArray().endObject();\n            indexingRequests.add(client().prepareIndex(\"idx\", \"type\").setSource(source));\n        }\n        indexRandom(true, indexingRequests);\n\n        assertNoFailures(client().admin().indices().prepareRefresh(\"idx\").setIndicesOptions(IndicesOptions.lenientExpandOpen()).execute().get());\n\n        TermsAggregatorFactory.ExecutionMode[] globalOrdinalModes = new TermsAggregatorFactory.ExecutionMode[]{\n                TermsAggregatorFactory.ExecutionMode.GLOBAL_ORDINALS_HASH,\n                TermsAggregatorFactory.ExecutionMode.GLOBAL_ORDINALS\n        };\n\n        SearchResponse resp = client().prepareSearch(\"idx\")\n                .addAggregation(terms(\"long\").field(\"long_values\").size(maxNumTerms).collectMode(randomFrom(SubAggCollectionMode.values())).subAggregation(min(\"min\").field(\"num\")))\n                .addAggregation(terms(\"double\").field(\"double_values\").size(maxNumTerms).collectMode(randomFrom(SubAggCollectionMode.values())).subAggregation(max(\"max\").field(\"num\")))\n                .addAggregation(terms(\"string_map\").field(\"string_values\").collectMode(randomFrom(SubAggCollectionMode.values())).executionHint(TermsAggregatorFactory.ExecutionMode.MAP.toString()).size(maxNumTerms).subAggregation(stats(\"stats\").field(\"num\")))\n                .addAggregation(terms(\"string_ordinals\").field(\"string_values\").collectMode(randomFrom(SubAggCollectionMode.values())).executionHint(TermsAggregatorFactory.ExecutionMode.ORDINALS.toString()).size(maxNumTerms).subAggregation(extendedStats(\"stats\").field(\"num\")))\n                .addAggregation(terms(\"string_global_ordinals\").field(\"string_values\").collectMode(randomFrom(SubAggCollectionMode.values())).executionHint(globalOrdinalModes[randomInt(globalOrdinalModes.length - 1)].toString()).size(maxNumTerms).subAggregation(extendedStats(\"stats\").field(\"num\")))\n                .addAggregation(terms(\"string_global_ordinals_doc_values\").field(\"string_values.doc_values\").collectMode(randomFrom(SubAggCollectionMode.values())).executionHint(globalOrdinalModes[randomInt(globalOrdinalModes.length - 1)].toString()).size(maxNumTerms).subAggregation(extendedStats(\"stats\").field(\"num\")))\n                .execute().actionGet();\n        assertAllSuccessful(resp);\n        assertEquals(numDocs, resp.getHits().getTotalHits());\n\n        final Terms longTerms = resp.getAggregations().get(\"long\");\n        final Terms doubleTerms = resp.getAggregations().get(\"double\");\n        final Terms stringMapTerms = resp.getAggregations().get(\"string_map\");\n        final Terms stringOrdinalsTerms = resp.getAggregations().get(\"string_ordinals\");\n\n        assertEquals(valuesSet.size(), longTerms.getBuckets().size());\n        assertEquals(valuesSet.size(), doubleTerms.getBuckets().size());\n        assertEquals(valuesSet.size(), stringMapTerms.getBuckets().size());\n        assertEquals(valuesSet.size(), stringOrdinalsTerms.getBuckets().size());\n        for (Terms.Bucket bucket : longTerms.getBuckets()) {\n            final Terms.Bucket doubleBucket = doubleTerms.getBucketByKey(Double.toString(Long.parseLong(bucket.getKeyAsText().string())));\n            final Terms.Bucket stringMapBucket = stringMapTerms.getBucketByKey(bucket.getKeyAsText().string());\n            final Terms.Bucket stringOrdinalsBucket = stringOrdinalsTerms.getBucketByKey(bucket.getKeyAsText().string());\n            assertNotNull(doubleBucket);\n            assertNotNull(stringMapBucket);\n            assertNotNull(stringOrdinalsBucket);\n            assertEquals(bucket.getDocCount(), doubleBucket.getDocCount());\n            assertEquals(bucket.getDocCount(), stringMapBucket.getDocCount());\n            assertEquals(bucket.getDocCount(), stringOrdinalsBucket.getDocCount());\n        }\n    }","id":38260,"modified_method":"public void testDuelTerms() throws Exception {\n        final int numDocs = scaledRandomIntBetween(1000, 2000);\n        final int maxNumTerms = randomIntBetween(10, 5000);\n\n        final IntOpenHashSet valuesSet = new IntOpenHashSet();\n        immutableCluster().wipeIndices(\"idx\");\n        prepareCreate(\"idx\")\n                .setSettings(ImmutableSettings.builder().put(InternalGlobalOrdinalsBuilder.ORDINAL_MAPPING_THRESHOLD_INDEX_SETTING_KEY, randomIntBetween(1, maxNumTerms)))\n                .addMapping(\"type\", jsonBuilder().startObject()\n                        .startObject(\"type\")\n                        .startObject(\"properties\")\n                        .startObject(\"string_values\")\n                        .field(\"type\", \"string\")\n                        .field(\"index\", \"not_analyzed\")\n                        .startObject(\"fields\")\n                            .startObject(\"doc_values\")\n                                .field(\"type\", \"string\")\n                                .field(\"index\", \"no\")\n                                .startObject(\"fielddata\")\n                                    .field(\"format\", \"doc_values\")\n                                .endObject()\n                            .endObject()\n                        .endObject()\n                        .endObject()\n                        .startObject(\"long_values\")\n                        .field(\"type\", \"long\")\n                        .endObject()\n                        .startObject(\"double_values\")\n                        .field(\"type\", \"double\")\n                        .endObject()\n                        .endObject()\n                        .endObject()).execute().actionGet();\n\n        List<IndexRequestBuilder> indexingRequests = Lists.newArrayList();\n        for (int i = 0; i < numDocs; ++i) {\n            final int[] values = new int[randomInt(4)];\n            for (int j = 0; j < values.length; ++j) {\n                values[j] = randomInt(maxNumTerms - 1) - 1000;\n                valuesSet.add(values[j]);\n            }\n            XContentBuilder source = jsonBuilder()\n                    .startObject()\n                    .field(\"num\", randomDouble())\n                    .startArray(\"long_values\");\n            for (int j = 0; j < values.length; ++j) {\n                source = source.value(values[j]);\n            }\n            source = source.endArray().startArray(\"double_values\");\n            for (int j = 0; j < values.length; ++j) {\n                source = source.value((double) values[j]);\n            }\n            source = source.endArray().startArray(\"string_values\");\n            for (int j = 0; j < values.length; ++j) {\n                source = source.value(Integer.toString(values[j]));\n            }\n            source = source.endArray().endObject();\n            indexingRequests.add(client().prepareIndex(\"idx\", \"type\").setSource(source));\n        }\n        indexRandom(true, indexingRequests);\n\n        assertNoFailures(client().admin().indices().prepareRefresh(\"idx\").setIndicesOptions(IndicesOptions.lenientExpandOpen()).execute().get());\n\n        TermsAggregatorFactory.ExecutionMode[] globalOrdinalModes = new TermsAggregatorFactory.ExecutionMode[]{\n                TermsAggregatorFactory.ExecutionMode.GLOBAL_ORDINALS_HASH,\n                TermsAggregatorFactory.ExecutionMode.GLOBAL_ORDINALS\n        };\n\n        SearchResponse resp = client().prepareSearch(\"idx\")\n                .addAggregation(terms(\"long\").field(\"long_values\").size(maxNumTerms).collectMode(randomFrom(SubAggCollectionMode.values())).subAggregation(min(\"min\").field(\"num\")))\n                .addAggregation(terms(\"double\").field(\"double_values\").size(maxNumTerms).collectMode(randomFrom(SubAggCollectionMode.values())).subAggregation(max(\"max\").field(\"num\")))\n                .addAggregation(terms(\"string_map\").field(\"string_values\").collectMode(randomFrom(SubAggCollectionMode.values())).executionHint(TermsAggregatorFactory.ExecutionMode.MAP.toString()).size(maxNumTerms).subAggregation(stats(\"stats\").field(\"num\")))\n                .addAggregation(terms(\"string_global_ordinals\").field(\"string_values\").collectMode(randomFrom(SubAggCollectionMode.values())).executionHint(globalOrdinalModes[randomInt(globalOrdinalModes.length - 1)].toString()).size(maxNumTerms).subAggregation(extendedStats(\"stats\").field(\"num\")))\n                .addAggregation(terms(\"string_global_ordinals_doc_values\").field(\"string_values.doc_values\").collectMode(randomFrom(SubAggCollectionMode.values())).executionHint(globalOrdinalModes[randomInt(globalOrdinalModes.length - 1)].toString()).size(maxNumTerms).subAggregation(extendedStats(\"stats\").field(\"num\")))\n                .execute().actionGet();\n        assertAllSuccessful(resp);\n        assertEquals(numDocs, resp.getHits().getTotalHits());\n\n        final Terms longTerms = resp.getAggregations().get(\"long\");\n        final Terms doubleTerms = resp.getAggregations().get(\"double\");\n        final Terms stringMapTerms = resp.getAggregations().get(\"string_map\");\n        final Terms stringGlobalOrdinalsTerms = resp.getAggregations().get(\"string_global_ordinals\");\n        final Terms stringGlobalOrdinalsDVTerms = resp.getAggregations().get(\"string_global_ordinals_doc_values\");\n\n        assertEquals(valuesSet.size(), longTerms.getBuckets().size());\n        assertEquals(valuesSet.size(), doubleTerms.getBuckets().size());\n        assertEquals(valuesSet.size(), stringMapTerms.getBuckets().size());\n        assertEquals(valuesSet.size(), stringGlobalOrdinalsTerms.getBuckets().size());\n        assertEquals(valuesSet.size(), stringGlobalOrdinalsDVTerms.getBuckets().size());\n        for (Terms.Bucket bucket : longTerms.getBuckets()) {\n            final Terms.Bucket doubleBucket = doubleTerms.getBucketByKey(Double.toString(Long.parseLong(bucket.getKeyAsText().string())));\n            final Terms.Bucket stringMapBucket = stringMapTerms.getBucketByKey(bucket.getKeyAsText().string());\n            final Terms.Bucket stringGlobalOrdinalsBucket = stringGlobalOrdinalsTerms.getBucketByKey(bucket.getKeyAsText().string());\n            final Terms.Bucket stringGlobalOrdinalsDVBucket = stringGlobalOrdinalsDVTerms.getBucketByKey(bucket.getKeyAsText().string());\n            assertNotNull(doubleBucket);\n            assertNotNull(stringMapBucket);\n            assertNotNull(stringGlobalOrdinalsBucket);\n            assertNotNull(stringGlobalOrdinalsDVBucket);\n            assertEquals(bucket.getDocCount(), doubleBucket.getDocCount());\n            assertEquals(bucket.getDocCount(), stringMapBucket.getDocCount());\n            assertEquals(bucket.getDocCount(), stringGlobalOrdinalsBucket.getDocCount());\n            assertEquals(bucket.getDocCount(), stringGlobalOrdinalsDVBucket.getDocCount());\n        }\n    }","commit_id":"232394e3a889597a476c091961e943423f6e45aa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Making sure that if there are multiple aggregations, working on the same field, yet require different\n     * value source type, they can all still work. It used to fail as we used to cache the ValueSource by the\n     * field name. If the cached value source was of type \"bytes\" and another aggregation on the field required to see\n     * it as \"numeric\", it didn't work. Now we cache the Value Sources by a custom key (field name + ValueSource type)\n     * so there's no conflict there.\n     */\n    public void testMetaDataSetOnAggregationResult() throws Exception {\n\n        createIndex(\"idx\");\n        IndexRequestBuilder[] builders = new IndexRequestBuilder[randomInt(30)];\n        IntIntMap values = new IntIntHashMap();\n        long missingValues = 0;\n        for (int i = 0; i < builders.length; i++) {\n            String name = \"name_\" + randomIntBetween(1, 10);\n            if (rarely()) {\n                missingValues++;\n                builders[i] = client().prepareIndex(\"idx\", \"type\").setSource(jsonBuilder()\n                        .startObject()\n                        .field(\"name\", name)\n                        .endObject());\n            } else {\n                int value = randomIntBetween(1, 10);\n                values.put(value, values.getOrDefault(value, 0) + 1);\n                builders[i] = client().prepareIndex(\"idx\", \"type\").setSource(jsonBuilder()\n                        .startObject()\n                        .field(\"name\", name)\n                        .field(\"value\", value)\n                        .endObject());\n            }\n        }\n        indexRandom(true, builders);\n        ensureSearchable();\n\n        final Map<String, Object> nestedMetaData = new HashMap<String, Object>() {{\n            put(\"nested\", \"value\");\n        }};\n\n        Map<String, Object> missingValueMetaData = new HashMap<String, Object>() {{\n            put(\"key\", \"value\");\n            put(\"numeric\", 1.2);\n            put(\"bool\", true);\n            put(\"complex\", nestedMetaData);\n        }};\n\n        SearchResponse response = client().prepareSearch(\"idx\")\n                .addAggregation(missing(\"missing_values\").field(\"value\").setMetaData(missingValueMetaData))\n                .execute().actionGet();\n\n        assertSearchResponse(response);\n\n        Aggregations aggs = response.getAggregations();\n        assertNotNull(aggs);\n\n        Missing missing = aggs.get(\"missing_values\");\n        assertNotNull(missing);\n        assertThat(missing.getDocCount(), equalTo(missingValues));\n\n        Map<String, Object> returnedMetaData = missing.getMetaData();\n        assertNotNull(returnedMetaData);\n        assertEquals(4, returnedMetaData.size());\n        assertEquals(\"value\", returnedMetaData.get(\"key\"));\n        assertEquals(1.2, returnedMetaData.get(\"numeric\"));\n        assertEquals(true, returnedMetaData.get(\"bool\"));\n\n        Object nestedObject = returnedMetaData.get(\"complex\");\n        assertNotNull(nestedObject);\n\n        Map<String, Object> nestedMap = (Map<String, Object>)nestedObject;\n        assertEquals(\"value\", nestedMap.get(\"nested\"));\n    }","id":38261,"modified_method":"public void testMetaDataSetOnAggregationResult() throws Exception {\n        createIndex(\"idx\");\n        IndexRequestBuilder[] builders = new IndexRequestBuilder[randomInt(30)];\n        for (int i = 0; i < builders.length; i++) {\n            String name = \"name_\" + randomIntBetween(1, 10);\n            builders[i] = client().prepareIndex(\"idx\", \"type\").setSource(jsonBuilder()\n                .startObject()\n                    .field(\"name\", name)\n                    .field(\"value\", randomInt())\n                .endObject());\n        }\n        indexRandom(true, builders);\n        ensureSearchable();\n\n        final Map<String, Object> nestedMetaData = new HashMap<String, Object>() {{\n            put(\"nested\", \"value\");\n        }};\n\n        Map<String, Object> metaData = new HashMap<String, Object>() {{\n            put(\"key\", \"value\");\n            put(\"numeric\", 1.2);\n            put(\"bool\", true);\n            put(\"complex\", nestedMetaData);\n        }};\n\n        SearchResponse response = client().prepareSearch(\"idx\")\n                .addAggregation(\n                    terms(\"the_terms\")\n                        .setMetaData(metaData)\n                        .field(\"name\")\n                        .subAggregation(\n                            sum(\"the_sum\")\n                                .setMetaData(metaData)\n                                .field(\"value\")\n                            )\n                )\n                .addAggregation(\n                    maxBucket(\"the_max_bucket\")\n                        .setMetaData(metaData)\n                        .setBucketsPaths(\"the_terms>the_sum\")\n                )\n                .execute().actionGet();\n\n        assertSearchResponse(response);\n\n        Aggregations aggs = response.getAggregations();\n        assertNotNull(aggs);\n\n        Terms terms = aggs.get(\"the_terms\");\n        assertNotNull(terms);\n        assertMetaData(terms.getMetaData());\n\n        List<? extends Terms.Bucket> buckets = terms.getBuckets();\n        for (Terms.Bucket bucket : buckets) {\n            Aggregations subAggs = bucket.getAggregations();\n            assertNotNull(subAggs);\n\n            Sum sum = subAggs.get(\"the_sum\");\n            assertNotNull(sum);\n            assertMetaData(sum.getMetaData());\n        }\n\n        InternalBucketMetricValue maxBucket = aggs.get(\"the_max_bucket\");\n        assertNotNull(maxBucket);\n        assertMetaData(maxBucket.getMetaData());\n    }","commit_id":"2adce71d329d2c281c274c3e4ec975b9e6aab449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(getName()).startObject(type);\n        internalXContent(builder, params);\n        return builder.endObject().endObject();\n    }","id":38262,"modified_method":"@Override\n    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(getName());\n        if (this.metaData != null) {\n            builder.field(\"meta\", this.metaData);\n        }\n        builder.startObject(type);\n        internalXContent(builder, params);\n        return builder.endObject().endObject();\n    }","commit_id":"2adce71d329d2c281c274c3e4ec975b9e6aab449","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void deleteDocument(KEY key) throws ExecutionException, InterruptedException {\n    LOG.debug(\"DELETE _id:{} in index {}\", key, this.getIndexName());\n    getClient()\n      .prepareDelete()\n      .setIndex(this.getIndexName())\n      .setType(this.getIndexType())\n      .setId(this.getKeyValue(key))\n      .get();\n  }","id":38263,"modified_method":"private void deleteDocument(KEY key) throws ExecutionException, InterruptedException {\n    StopWatch fullProfile = profiling.start(\"es\", Profiling.Level.FULL);\n    StopWatch basicProfile = profiling.start(\"es\", Profiling.Level.BASIC);\n    LOG.debug(\"DELETE _id:{} in index {}\", key, this.getIndexName());\n    DeleteRequestBuilder request = getClient()\n      .prepareDelete()\n      .setIndex(this.getIndexName())\n      .setType(this.getIndexType())\n      .setId(this.getKeyValue(key));\n    basicProfile.stop(request.toString());\n    DeleteResponse response = request.get();\n    fullProfile.stop(response.toString());\n  }","commit_id":"1736bc64047d64c3995656d5b51bb4cfbfc06868","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DOMAIN getByKey(KEY key) {\n    GetResponse response = getClient().prepareGet()\n      .setType(this.getIndexType())\n      .setIndex(this.getIndexName())\n      .setId(this.getKeyValue(key))\n      .setRouting(this.getKeyValue(key))\n      .get();\n    if (response.isExists()) {\n      return toDoc(response.getSource());\n    }\n    return null;\n  }","id":38264,"modified_method":"public DOMAIN getByKey(KEY key) {\n    StopWatch fullProfile = profiling.start(\"es\", Profiling.Level.FULL);\n    StopWatch basicProfile = profiling.start(\"es\", Profiling.Level.BASIC);\n\n    GetRequestBuilder request = getClient().prepareGet()\n      .setType(this.getIndexType())\n      .setIndex(this.getIndexName())\n      .setId(this.getKeyValue(key))\n      .setRouting(this.getKeyValue(key));\n    basicProfile.stop(request.toString());\n\n    GetResponse response = request.get();\n    fullProfile.stop(response.toString());\n\n    if (response.isExists()) {\n      return toDoc(response.getSource());\n    }\n    return null;\n  }","commit_id":"1736bc64047d64c3995656d5b51bb4cfbfc06868","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void updateDocument(Collection<UpdateRequest> requests, KEY key) {\n    LOG.debug(\"UPDATE _id:{} in index {}\", key, this.getIndexName());\n    BulkRequestBuilder bulkRequest = getClient().prepareBulk();\n    for (UpdateRequest request : requests) {\n      // if request has no ID then no upsert possible!\n      if (request.id() == null || request.id().isEmpty()) {\n        bulkRequest.add(new IndexRequest()\n          .source(request.doc().sourceAsMap())\n          .type(this.getIndexType())\n          .index(this.getIndexName()));\n      } else {\n        bulkRequest.add(request\n          .id(this.getKeyValue(key))\n          .index(this.getIndexName())\n          .type(this.getIndexType()));\n      }\n    }\n    bulkRequest.get();\n  }","id":38265,"modified_method":"protected void updateDocument(Collection<UpdateRequest> requests, KEY key) {\n    StopWatch fullProfile = profiling.start(\"es\", Profiling.Level.FULL);\n    StopWatch basicProfile = profiling.start(\"es\", Profiling.Level.BASIC);\n    LOG.debug(\"UPDATE _id:{} in index {}\", key, this.getIndexName());\n    BulkRequestBuilder bulkRequest = getClient().prepareBulk();\n    for (UpdateRequest request : requests) {\n      // if request has no ID then no upsert possible!\n      if (request.id() == null || request.id().isEmpty()) {\n        bulkRequest.add(new IndexRequest()\n          .source(request.doc().sourceAsMap())\n          .type(this.getIndexType())\n          .index(this.getIndexName()));\n      } else {\n        bulkRequest.add(request\n          .id(this.getKeyValue(key))\n          .index(this.getIndexName())\n          .type(this.getIndexType()));\n      }\n    }\n    basicProfile.stop(bulkRequest.toString());\n    BulkResponse response = bulkRequest.get();\n    fullProfile.stop(response.toString());\n  }","commit_id":"1736bc64047d64c3995656d5b51bb4cfbfc06868","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public Date getLastSynchronization() {\n    Date date;\n    SearchRequestBuilder request = getClient().prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setQuery(QueryBuilders.matchAllQuery())\n      .setSize(0)\n      .addAggregation(AggregationBuilders.max(\"latest\")\n        .field(BaseNormalizer.UPDATED_AT_FIELD));\n\n    SearchResponse response = request.get();\n\n    Max max = (Max) response.getAggregations().get(\"latest\");\n\n    if (max.getValue() > 0) {\n      date = new DateTime(Double.valueOf(max.getValue()).longValue()).toDate();\n    } else {\n      date = new Date(0L);\n    }\n\n    LOG.info(\"Index {}:{} has last update of {}\", this.getIndexName(), this.getIndexType(), date);\n    return date;\n  }","id":38266,"modified_method":"@Override\n  public Date getLastSynchronization() {\n    StopWatch fullProfile = profiling.start(\"es\", Profiling.Level.FULL);\n    StopWatch basicProfile = profiling.start(\"es\", Profiling.Level.BASIC);\n\n    Date date;\n    SearchRequestBuilder request = getClient().prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setQuery(QueryBuilders.matchAllQuery())\n      .setSize(0)\n      .addAggregation(AggregationBuilders.max(\"latest\")\n        .field(BaseNormalizer.UPDATED_AT_FIELD));\n\n\n    basicProfile.stop(request.toString());\n    SearchResponse response = request.get();\n    fullProfile.stop(response.toString());\n\n    Max max = (Max) response.getAggregations().get(\"latest\");\n\n    if (max.getValue() > 0) {\n      date = new DateTime(Double.valueOf(max.getValue()).longValue()).toDate();\n    } else {\n      date = new Date(0L);\n    }\n\n    LOG.info(\"Index {}:{} has last update of {}\", this.getIndexName(), this.getIndexType(), date);\n    return date;\n  }","commit_id":"1736bc64047d64c3995656d5b51bb4cfbfc06868","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Map<String, Long> countByField(IndexField indexField, FilterBuilder filter) {\n    Map<String, Long> counts = new HashMap<String, Long>();\n    Terms values = getClient().prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setQuery(QueryBuilders.filteredQuery(\n        QueryBuilders.matchAllQuery(),\n        filter))\n      .setSize(0)\n      .addAggregation(AggregationBuilders\n        .terms(indexField.field())\n        .field(indexField.field())\n        .order(Terms.Order.count(false))\n        .size(Integer.MAX_VALUE)\n        .minDocCount(0)).get()\n      .getAggregations().get(indexField.field());\n\n    for (Terms.Bucket value : values.getBuckets()) {\n      counts.put(value.getKey(), value.getDocCount());\n    }\n    return counts;\n  }","id":38267,"modified_method":"public Map<String, Long> countByField(IndexField indexField, FilterBuilder filter) {\n    StopWatch fullProfile = profiling.start(\"es\", Profiling.Level.FULL);\n    StopWatch basicProfile = profiling.start(\"es\", Profiling.Level.BASIC);\n    Map<String, Long> counts = new HashMap<String, Long>();\n\n    SearchRequestBuilder request = getClient().prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setQuery(QueryBuilders.filteredQuery(\n        QueryBuilders.matchAllQuery(),\n        filter))\n      .setSize(0)\n      .addAggregation(AggregationBuilders\n        .terms(indexField.field())\n        .field(indexField.field())\n        .order(Terms.Order.count(false))\n        .size(Integer.MAX_VALUE)\n        .minDocCount(0));\n\n    basicProfile.stop(request.toString());\n    SearchResponse response = request.get();\n    fullProfile.stop(response.toString());\n\n    Terms values =\n      response.getAggregations().get(indexField.field());\n\n    for (Terms.Bucket value : values.getBuckets()) {\n      counts.put(value.getKey(), value.getDocCount());\n    }\n    return counts;\n  }","commit_id":"1736bc64047d64c3995656d5b51bb4cfbfc06868","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Result<Rule> search(RuleQuery query, QueryOptions options) {\n    StopWatch profile = profiling.start(\"es\", Profiling.Level.FULL);\n\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setIndices(this.getIndexName());\n\n    if (options.isScroll()) {\n      esSearch.setSearchType(SearchType.SCAN);\n      esSearch.setScroll(TimeValue.timeValueMinutes(3));\n    }\n\n    setFacets(options, esSearch);\n    setSorting(query, esSearch);\n    setPagination(options, esSearch);\n    setFields(options, esSearch);\n\n    FilterBuilder fb = this.getFilter(query, options);\n    QueryBuilder qb = this.getQuery(query, options);\n    esSearch.setQuery(QueryBuilders.filteredQuery(qb, fb));\n\n    SearchResponse esResult = esSearch.get();\n    profile.stop(\"query: \" + esSearch + \"\\nresult:\" + esResult);\n\n    return new Result<Rule>(this, esResult);\n  }","id":38268,"modified_method":"public Result<Rule> search(RuleQuery query, QueryOptions options) {\n    StopWatch fullProfile = profiling.start(\"es\", Profiling.Level.FULL);\n    StopWatch basicProfile = profiling.start(\"es\", Profiling.Level.BASIC);\n\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setTypes(this.getIndexType())\n      .setIndices(this.getIndexName());\n\n    if (options.isScroll()) {\n      esSearch.setSearchType(SearchType.SCAN);\n      esSearch.setScroll(TimeValue.timeValueMinutes(3));\n    }\n\n    setFacets(options, esSearch);\n    setSorting(query, esSearch);\n    setPagination(options, esSearch);\n    setFields(options, esSearch);\n\n    FilterBuilder fb = this.getFilter(query, options);\n    QueryBuilder qb = this.getQuery(query, options);\n    esSearch.setQuery(QueryBuilders.filteredQuery(qb, fb));\n\n    basicProfile.stop(esSearch.toString());\n    SearchResponse esResult = esSearch.get();\n    fullProfile.stop(esResult.toString());\n\n    return new Result<Rule>(this, esResult);\n  }","commit_id":"1736bc64047d64c3995656d5b51bb4cfbfc06868","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ProjectIterationResource getProjectIterationResource(URI uri) {\n\treturn createProxy(ProjectIterationResource.class, uri);\n    }","id":38269,"modified_method":"public ProjectIterationResource getProjectIterationResource(final URI uri) {\n\t\tfinal ProjectIterationResource projectIterationResource =  createProxy(ProjectIterationResource.class, uri);\n\t\treturn new ProjectIterationResource() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Response put(ProjectIteration project) {\n\t\t\t\treturn projectIterationResource.put(project);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic DocumentsResource getDocuments() {\n\t\t\t\treturn getDocumentsResource(uri.resolve(\"documents\"));\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic ClientResponse<ProjectIteration> get() {\n\t\t\t\treturn projectIterationResource.get();\n\t\t\t}\n\t\t};\n\t}","commit_id":"dbf93b8ba3f20004bfc5d27104deca351ebaa3b7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectsResource getProjectsResource(URI uri) {\n\treturn createProxy(ProjectsResource.class, uri);\n    }","id":38270,"modified_method":"public ProjectsResource getProjectsResource(final URI uri) {\n\t\tfinal ProjectsResource projectsResource = createProxy(ProjectsResource.class, uri);\n\t\t\n\t\treturn new ProjectsResource() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic ClientResponse<ProjectRefs> getProjects() {\n\t\t\t\treturn projectsResource.getProjects();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic ProjectResource getProject(String projectSlug) {\n\t\t\t\treturn getProjectResource(uri.resolve(\"p/\"+projectSlug));\n\t\t\t}\n\t\t};\n\t\t\n\t}","commit_id":"dbf93b8ba3f20004bfc5d27104deca351ebaa3b7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectResource getProjectResource(URI uri) {\n\treturn createProxy(ProjectResource.class, uri);\n    }","id":38271,"modified_method":"public ProjectResource getProjectResource(final URI uri) {\n\t\tfinal ProjectResource projectResource =  createProxy(ProjectResource.class, uri);\n\t\treturn new ProjectResource() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Response put(Project project) {\n\t\t\t\treturn projectResource.put(project);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic ProjectIterationResource getIteration(String iterationSlug) {\n\t\t\t\treturn getProjectIterationResource(uri.resolve(\"iterations/i/\"+iterationSlug));\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic ClientResponse<Project> get() {\n\t\t\t\treturn projectResource.get();\n\t\t\t}\n\t\t};\n\t}","commit_id":"dbf93b8ba3f20004bfc5d27104deca351ebaa3b7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DocumentsResource getDocumentsResource(URI uri) {\n\treturn createProxy(DocumentsResource.class, uri);\n    }","id":38272,"modified_method":"public DocumentsResource getDocumentsResource(final URI uri) {\n\t\tfinal DocumentsResource documentsResource = createProxy(DocumentsResource.class, uri);\n\t\treturn new DocumentsResource() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Response put(Documents documents) {\n\t\t\t\treturn documentsResource.put(documents);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Response post(Documents documents) {\n\t\t\t\treturn documentsResource.post(documents);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic ClientResponse<Documents> getDocuments() {\n\t\t\t\treturn documentsResource.getDocuments();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic DocumentResource getDocument(String documentId) {\n\t\t\t\treturn getDocumentResource(uri.resolve(\"d/\"+documentId));\n\t\t\t}\n\t\t};\n\t}","commit_id":"dbf93b8ba3f20004bfc5d27104deca351ebaa3b7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DocumentResource getDocumentResource(URI uri) {\n\treturn createProxy(DocumentResource.class, uri);\n    }","id":38273,"modified_method":"public DocumentResource getDocumentResource(URI uri) {\n\t\tfinal DocumentResource documentResource = createProxy(DocumentResource.class);\n\t\treturn new DocumentResource() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic Response put(Document document) {\n\t\t\t\treturn documentResource.put(document);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic ClientResponse<Document> get(String includeTargets) {\n\t\t\t\treturn documentResource.get(includeTargets);\n\t\t\t}\n\t\t};\n\t}","commit_id":"dbf93b8ba3f20004bfc5d27104deca351ebaa3b7","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public boolean isModules()\n   {\n      // modules are currently only supported by Maven Mojos:\n      return false;\n   }","id":38274,"modified_method":"@Override\n   public Set<String> getAllModules()\n   {\n      return Collections.emptySet();\n   }","commit_id":"d41f96353cda54f6603bf15b5da3914382caf594","url":"https://github.com/zanata/zanata-server"},{"original_method":"private boolean isRootModule()\n   {\n      return session.getExecutionRootDirectory().equalsIgnoreCase(basedir.toString());\n   }","id":38275,"modified_method":"@Override\n   public boolean isRootModule()\n   {\n      return session.getExecutionRootDirectory().equalsIgnoreCase(basedir.toString());\n   }","commit_id":"d41f96353cda54f6603bf15b5da3914382caf594","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean isModules()\n   {\n      return modules;\n   }","id":38276,"modified_method":"@Override\n   public Set<String> getAllModules()\n   {\n      Set<String> localModules = new HashSet<String>();\n      for (MavenProject module : reactorProjects)\n      {\n         String modID = module.getGroupId() + ':' + module.getArtifactId();\n         localModules.add(modID);\n      }\n      getLog().info(\"modules in the reactor: \" + localModules);\n      return localModules;\n   }","commit_id":"d41f96353cda54f6603bf15b5da3914382caf594","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void runCommand() throws Exception\n   {\n      if (skip)\n      {\n         getLog().info(\"skipping\");\n         return;\n      }\n      if (modules)\n      {\n         runModule();\n      }\n      else\n      {\n         //         getLog().info(\"run non-module\");\n         super.runCommand();\n      }\n   }","id":38277,"modified_method":"@Override\n   protected void runCommand() throws Exception\n   {\n      if (skip)\n      {\n         getLog().info(\"skipping\");\n         return;\n      }\n\n   }","commit_id":"d41f96353cda54f6603bf15b5da3914382caf594","url":"https://github.com/zanata/zanata-server"},{"original_method":"public <T> T createProxy(Class<T> clazz, URI baseUri)\n   {\n      log.debug(\"{} proxy uri: {}\", clazz.getSimpleName(), baseUri);\n      return crf.createProxy(clazz, baseUri);\n   }","id":38278,"modified_method":"public <T> T createProxy(Class<T> clazz, URI baseUri)\n   {\n      log.debug(\"{} proxy uri: {}\", clazz.getSimpleName(), baseUri);\n      T proxy = crf.createProxy(clazz, baseUri);\n      //      CacheFactory.makeCacheable(proxy);\n      return proxy;\n   }","commit_id":"d41f96353cda54f6603bf15b5da3914382caf594","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Export specific rows from an SSTable and write the resulting JSON to a PrintStream.\n     * \n     * @param ssTableFile the SSTable to export the rows from\n     * @param outs PrintStream to write the output to\n     * @param keys the keys corresponding to the rows to export\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(String ssTableFile, PrintStream outs, String[] keys, String[] excludes)\n    throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(ssTableFile));\n        SSTableScanner scanner = reader.getScanner(INPUT_FILE_BUFFER_SIZE);\n        IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();    \n        Set<String> excludeSet = new HashSet<String>();\n        int i = 0;\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n        \n        outs.println(\"{\");\n        \n        for (String key : keys)\n        {\n            if (excludeSet.contains(key))\n                continue;\n            DecoratedKey<?> dk = partitioner.decorateKey(ByteBuffer.wrap(hexToBytes(key)));\n            scanner.seekTo(dk);\n            \n            i++;\n            \n            if (scanner.hasNext())\n            {\n                SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n                try\n                {\n                    String jsonOut = serializeRow(row);\n                    if (i != 1)\n                        outs.println(\",\");\n                    outs.print(\"  \" + jsonOut);\n                }\n                catch (IOException ioexc)\n                {\n                    System.err.println(\"WARNING: Corrupt row \" + key + \" (skipping).\");\n                    continue;\n                }\n                catch (OutOfMemoryError oom)\n                {\n                    System.err.println(\"ERROR: Out of memory deserializing row \" + key);\n                    continue;\n                }\n            }\n        }\n        \n        outs.println(\"\\n}\");\n        outs.flush();\n    }","id":38279,"modified_method":"/**\n     * Export specific rows from an SSTable and write the resulting JSON to a PrintStream.\n     * \n     * @param ssTableFile the SSTable to export the rows from\n     * @param outs PrintStream to write the output to\n     * @param keys the keys corresponding to the rows to export\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(String ssTableFile, PrintStream outs, String[] keys, String[] excludes)\n    throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(ssTableFile));\n        SSTableScanner scanner = reader.getScanner(INPUT_FILE_BUFFER_SIZE);\n        IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();    \n        Set<String> excludeSet = new HashSet<String>();\n        int i = 0;\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n        \n        outs.println(\"{\");\n        \n        for (String key : keys)\n        {\n            if (excludeSet.contains(key))\n                continue;\n            DecoratedKey<?> dk = partitioner.decorateKey(ByteBuffer.wrap(hexToBytes(key)));\n            scanner.seekTo(dk);\n            \n            i++;\n            \n            if (scanner.hasNext())\n            {\n                SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n                try\n                {\n                    serializeRow(outs, row);\n                    if (i != 1)\n                        outs.println(\",\");\n                }\n                catch (IOException ioexc)\n                {\n                    System.err.println(\"WARNING: Corrupt row \" + key + \" (skipping).\");\n                    continue;\n                }\n                catch (OutOfMemoryError oom)\n                {\n                    System.err.println(\"ERROR: Out of memory deserializing row \" + key);\n                    continue;\n                }\n            }\n        }\n        \n        outs.println(\"\\n}\");\n        outs.flush();\n    }","commit_id":"fb2ce875415d5258fa92b835c91c3688c95e070d","url":"https://github.com/apache/cassandra"},{"original_method":"private static String serializeColumns(Collection<IColumn> cols, AbstractType comp)\n    {\n        StringBuilder json = new StringBuilder(\"[\");\n        \n        Iterator<IColumn> iter = cols.iterator();\n        while (iter.hasNext())\n        {\n            json.append(\"[\");\n            IColumn column = iter.next();\n            json.append(quote(bytesToHex(column.name())));\n            json.append(\", \");\n            json.append(quote(bytesToHex(column.value())));\n            json.append(\", \");\n            json.append(column.timestamp());\n            json.append(\", \");\n            json.append(column.isMarkedForDelete());\n            if (column instanceof ExpiringColumn) {\n              json.append(\", \");\n              json.append(((ExpiringColumn)column).getTimeToLive());\n              json.append(\", \");\n              json.append(column.getLocalDeletionTime());\n            }\n            json.append(\"]\");\n            if (iter.hasNext())\n                json.append(\", \");\n        }\n        \n        json.append(\"]\");\n        \n        return json.toString();\n    }","id":38280,"modified_method":"private static void serializeColumns(PrintStream outs, Collection<IColumn> cols, AbstractType comp)\n    {\n        outs.print(\"[\");\n\n        Iterator<IColumn> iter = cols.iterator();\n        while (iter.hasNext())\n        {\n            outs.print(\"[\");\n            IColumn column = iter.next();\n            outs.print(quote(bytesToHex(column.name())));\n            outs.print(\", \");\n            outs.print(quote(bytesToHex(column.value())));\n            outs.print(\", \");\n            outs.print(column.timestamp());\n            outs.print(\", \");\n            outs.print(column.isMarkedForDelete());\n            if (column instanceof ExpiringColumn) {\n              outs.print(\", \");\n              outs.print(((ExpiringColumn)column).getTimeToLive());\n              outs.print(\", \");\n              outs.print(column.getLocalDeletionTime());\n            }\n            outs.print(\"]\");\n            if (iter.hasNext())\n                outs.print(\", \");\n        }\n        \n        outs.print(\"]\");\n    }","commit_id":"fb2ce875415d5258fa92b835c91c3688c95e070d","url":"https://github.com/apache/cassandra"},{"original_method":"private static String serializeRow(SSTableIdentityIterator row) throws IOException\n    {\n        ColumnFamily cf = row.getColumnFamilyWithColumns();\n        AbstractType comparator = cf.getComparator();\n        StringBuilder json = new StringBuilder(asKey(bytesToHex(row.getKey().key)));\n        \n        if (cf.isSuper())\n        {\n            json.append(\"{ \");\n\n            Iterator<IColumn> iter = cf.getSortedColumns().iterator();\n            while (iter.hasNext())\n            {\n                IColumn column = iter.next();\n                json.append(asKey(bytesToHex(column.name())));\n                json.append(\"{\");\n                json.append(asKey(\"deletedAt\"));\n                json.append(column.getMarkedForDeleteAt());\n                json.append(\", \");\n                json.append(asKey(\"subColumns\"));\n                json.append(serializeColumns(column.getSubColumns(), comparator));\n                json.append(\"}\");\n                if (iter.hasNext())\n                    json.append(\", \");\n            }\n            \n            json.append(\"}\");\n        }\n        else\n        {\n            json.append(serializeColumns(cf.getSortedColumns(), comparator));\n        }\n     \n        return json.toString();\n    }","id":38281,"modified_method":"private static void serializeRow(PrintStream outs, SSTableIdentityIterator row) throws IOException\n    {\n        ColumnFamily cf = row.getColumnFamilyWithColumns();\n        AbstractType comparator = cf.getComparator();\n        outs.print(asKey(bytesToHex(row.getKey().key)));\n\n        if (cf.isSuper())\n        {\n            outs.print(\"{ \");\n\n            Iterator<IColumn> iter = cf.getSortedColumns().iterator();\n            while (iter.hasNext())\n            {\n                IColumn column = iter.next();\n                outs.print(asKey(bytesToHex(column.name())));\n                outs.print(\"{\");\n                outs.print(asKey(\"deletedAt\"));\n                outs.print(column.getMarkedForDeleteAt());\n                outs.print(\", \");\n                outs.print(asKey(\"subColumns\"));\n                serializeColumns(outs, column.getSubColumns(), comparator);\n                outs.print(\"}\");\n                if (iter.hasNext())\n                    outs.print(\", \");\n            }\n            \n            outs.print(\"}\");\n        }\n        else\n        {\n            serializeColumns(outs, cf.getSortedColumns(), comparator);\n        }\n    }","commit_id":"fb2ce875415d5258fa92b835c91c3688c95e070d","url":"https://github.com/apache/cassandra"},{"original_method":"static void export(SSTableReader reader, PrintStream outs, String[] excludes) throws IOException\n    {\n        SSTableScanner scanner = reader.getScanner(INPUT_FILE_BUFFER_SIZE);\n        Set<String> excludeSet = new HashSet<String>();\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n\n        outs.println(\"{\");\n\n        while (scanner.hasNext())\n        {\n            SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n            if (excludeSet.contains(bytesToHex(row.getKey().key)))\n                continue;\n            try\n            {\n                String jsonOut = serializeRow(row);\n                outs.print(\"  \" + jsonOut);\n                if (scanner.hasNext())\n                    outs.println(\",\");\n                else\n                    outs.println();\n            }\n            catch (IOException ioexcep)\n            {\n                System.err.println(\"WARNING: Corrupt row \" + bytesToHex(row.getKey().key) + \" (skipping).\");\n                continue;\n            }\n            catch (OutOfMemoryError oom)\n            {\n                System.err.println(\"ERROR: Out of memory deserializing row \" + bytesToHex(row.getKey().key));\n                continue;\n            }\n        }\n        \n        outs.println(\"}\");\n        outs.flush();\n    }","id":38282,"modified_method":"static void export(SSTableReader reader, PrintStream outs, String[] excludes) throws IOException\n    {\n        SSTableScanner scanner = reader.getScanner(INPUT_FILE_BUFFER_SIZE);\n        Set<String> excludeSet = new HashSet<String>();\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n\n        outs.println(\"{\");\n\n        while (scanner.hasNext())\n        {\n            SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n            if (excludeSet.contains(bytesToHex(row.getKey().key)))\n                continue;\n            try\n            {\n                serializeRow(outs, row);\n                outs.print(\"  \");\n                if (scanner.hasNext())\n                    outs.println(\",\");\n                else\n                    outs.println();\n            }\n            catch (IOException ioexcep)\n            {\n                System.err.println(\"WARNING: Corrupt row \" + bytesToHex(row.getKey().key) + \" (skipping).\");\n                continue;\n            }\n            catch (OutOfMemoryError oom)\n            {\n                System.err.println(\"ERROR: Out of memory deserializing row \" + bytesToHex(row.getKey().key));\n                continue;\n            }\n        }\n        \n        outs.println(\"}\");\n        outs.flush();\n    }","commit_id":"fb2ce875415d5258fa92b835c91c3688c95e070d","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Export specific rows from an SSTable and write the resulting JSON to a PrintStream.\n     * \n     * @param ssTableFile the SSTableScanner to export the rows from\n     * @param outs PrintStream to write the output to\n     * @param toExport the keys corresponding to the rows to export\n     * @param excludes keys to exclude from export\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(String ssTableFile, PrintStream outs, Collection<String> toExport, String[] excludes) throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(ssTableFile));\n        SSTableScanner scanner = reader.getDirectScanner(BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE);\n\n        IPartitioner<?> partitioner = StorageService.getPartitioner();\n\n        if (excludes != null)\n            toExport.removeAll(Arrays.asList(excludes));\n\n        outs.println(\"{\");\n\n        int i = 0;\n\n        // last key to compare order\n        DecoratedKey lastKey = null;\n\n        for (String key : toExport)\n        {\n            DecoratedKey decoratedKey = partitioner.decorateKey(hexToBytes(key));\n\n            if (lastKey != null && lastKey.compareTo(decoratedKey) > 0)\n                throw new IOException(\"Key out of order! \" + lastKey + \" > \" + decoratedKey);\n\n            lastKey = decoratedKey;\n\n            scanner.seekTo(decoratedKey);\n\n            if (!scanner.hasNext())\n                continue;\n\n            SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n            if (!row.getKey().equals(decoratedKey))\n                continue;\n\n            serializeRow(reader, row, decoratedKey, outs);\n\n            if (i != 0)\n                outs.println(\",\");\n\n            i++;\n        }\n\n        outs.println(\"\\n}\");\n        outs.flush();\n\n        scanner.close();\n    }","id":38283,"modified_method":"/**\n     * Export specific rows from an SSTable and write the resulting JSON to a PrintStream.\n     * \n     * @param ssTableFile the SSTableScanner to export the rows from\n     * @param outs PrintStream to write the output to\n     * @param toExport the keys corresponding to the rows to export\n     * @param excludes keys to exclude from export\n     * @throws IOException on failure to read/write input/output\n     */\n    public static void export(String ssTableFile, PrintStream outs, Collection<String> toExport, String[] excludes) throws IOException\n    {\n        SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(ssTableFile));\n        SSTableScanner scanner = reader.getDirectScanner(BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE);\n\n        IPartitioner<?> partitioner = StorageService.getPartitioner();\n\n        if (excludes != null)\n            toExport.removeAll(Arrays.asList(excludes));\n\n        outs.println(\"{\");\n\n        int i = 0;\n\n        // last key to compare order\n        DecoratedKey lastKey = null;\n\n        for (String key : toExport)\n        {\n            DecoratedKey decoratedKey = partitioner.decorateKey(hexToBytes(key));\n\n            if (lastKey != null && lastKey.compareTo(decoratedKey) > 0)\n                throw new IOException(\"Key out of order! \" + lastKey + \" > \" + decoratedKey);\n\n            lastKey = decoratedKey;\n\n            scanner.seekTo(decoratedKey);\n\n            if (!scanner.hasNext())\n                continue;\n\n            SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n            if (!row.getKey().equals(decoratedKey))\n                continue;\n\n            serializeRow(row, decoratedKey, outs);\n\n            if (i != 0)\n                outs.println(\",\");\n\n            i++;\n        }\n\n        outs.println(\"\\n}\");\n        outs.flush();\n\n        scanner.close();\n    }","commit_id":"b3817177b5dc05e8639133df51922039c44c1ff8","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Get portion of the columns and serialize in loop while not more columns left in the row\n     * @param reader SSTableReader for given SSTable\n     * @param row SSTableIdentityIterator row representation with Column Family\n     * @param key Decorated Key for the required row\n     * @param out output stream\n     */\n    private static void serializeRow(SSTableReader reader, SSTableIdentityIterator row, DecoratedKey key, PrintStream out)\n    {\n        ColumnFamily columnFamily = row.getColumnFamily();\n        boolean isSuperCF = columnFamily.isSuper();\n        ByteBuffer startColumn = ByteBufferUtil.EMPTY_BYTE_BUFFER; // initial column name, \"blank\" for first\n\n        out.print(asKey(bytesToHex(key.key)));\n\n        out.print(isSuperCF ? \"{\" : \"[\");\n\n        while (true)\n        {\n            QueryFilter filter = QueryFilter.getSliceFilter(key,\n                                                            new QueryPath(columnFamily.metadata().tableName),\n                                                            startColumn,\n                                                            ByteBufferUtil.EMPTY_BYTE_BUFFER,\n                                                            false,\n                                                            PAGE_SIZE);\n\n            IColumnIterator columns = filter.getSSTableColumnIterator(reader);\n\n            Pair<Integer, ByteBuffer> serialized;\n            try\n            {\n                serialized = serializeRow(columns, isSuperCF, out);\n            }\n            catch (IOException e)\n            {\n                System.err.println(\"WARNING: Corrupt row \" + key + \" (skipping).\");\n                continue;\n            }\n            finally\n            {\n                try\n                {\n                    columns.close();\n                }\n                catch (IOException e)\n                {\n                    throw new IOError(e);\n                }\n            }\n\n            if (serialized.left < PAGE_SIZE)\n                break;\n\n            out.print(\",\");\n        }\n\n        out.print(isSuperCF ? \"}\" : \"]\");\n    }","id":38284,"modified_method":"/**\n     * Get portion of the columns and serialize in loop while not more columns left in the row\n     * @param row SSTableIdentityIterator row representation with Column Family\n     * @param key Decorated Key for the required row\n     * @param out output stream\n     */\n    private static void serializeRow(SSTableIdentityIterator row, DecoratedKey key, PrintStream out)\n    {\n        ColumnFamily columnFamily = row.getColumnFamily();\n        boolean isSuperCF = columnFamily.isSuper();\n\n        out.print(asKey(bytesToHex(key.key)));\n        out.print(isSuperCF ? \"{\" : \"[\");\n\n        if (isSuperCF)\n        {\n            while (row.hasNext())\n            {\n                IColumn column = row.next();\n\n                out.print(asKey(bytesToHex(column.name())));\n                out.print(\"{\");\n                out.print(asKey(\"deletedAt\"));\n                out.print(column.getMarkedForDeleteAt());\n                out.print(\", \");\n                out.print(asKey(\"subColumns\"));\n                out.print(\"[\");\n                serializeColumns(column.getSubColumns().iterator(), out);\n                out.print(\"]\");\n                out.print(\"}\");\n\n                if (row.hasNext())\n                    out.print(\", \");\n            }\n        }\n        else\n        {\n            serializeColumns(row, out);\n        }\n\n        out.print(isSuperCF ? \"}\" : \"]\");\n    }","commit_id":"b3817177b5dc05e8639133df51922039c44c1ff8","url":"https://github.com/apache/cassandra"},{"original_method":"static void export(SSTableReader reader, PrintStream outs, String[] excludes) throws IOException\n    {\n        Set<String> excludeSet = new HashSet<String>();\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n\n\n        SSTableIdentityIterator row;\n        SSTableScanner scanner = reader.getDirectScanner(BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE);\n\n        outs.println(\"{\");\n\n        int i = 0;\n\n        // collecting keys to export\n        while (scanner.hasNext())\n        {\n            row = (SSTableIdentityIterator) scanner.next();\n\n            String currentKey = bytesToHex(row.getKey().key);\n\n            if (excludeSet.contains(currentKey))\n                continue;\n            else if (i != 0)\n                outs.println(\",\");\n\n            serializeRow(reader, row, row.getKey(), outs);\n\n            i++;\n        }\n\n        outs.println(\"\\n}\");\n        outs.flush();\n\n        scanner.close();\n    }","id":38285,"modified_method":"static void export(SSTableReader reader, PrintStream outs, String[] excludes) throws IOException\n    {\n        Set<String> excludeSet = new HashSet<String>();\n\n        if (excludes != null)\n            excludeSet = new HashSet<String>(Arrays.asList(excludes));\n\n\n        SSTableIdentityIterator row;\n        SSTableScanner scanner = reader.getDirectScanner(BufferedRandomAccessFile.DEFAULT_BUFFER_SIZE);\n\n        outs.println(\"{\");\n\n        int i = 0;\n\n        // collecting keys to export\n        while (scanner.hasNext())\n        {\n            row = (SSTableIdentityIterator) scanner.next();\n\n            String currentKey = bytesToHex(row.getKey().key);\n\n            if (excludeSet.contains(currentKey))\n                continue;\n            else if (i != 0)\n                outs.println(\",\");\n\n            serializeRow(row, row.getKey(), outs);\n\n            i++;\n        }\n\n        outs.println(\"\\n}\");\n        outs.flush();\n\n        scanner.close();\n    }","commit_id":"b3817177b5dc05e8639133df51922039c44c1ff8","url":"https://github.com/apache/cassandra"},{"original_method":"private void verifyTerminateSequence(String wsaUri, RMConstants consts) throws Exception {\n        if (RM11Constants.NAMESPACE_URI.equals(consts.getWSRMNamespace())) {\n            awaitMessages(3, 3);\n        } else {\n            awaitMessages(3, 2);\n        }\n        \n        MessageFlow mf = new MessageFlow(outRecorder.getOutboundMessages(),\n            inRecorder.getInboundMessages(), wsaUri, consts.getWSRMNamespace());\n        \n        mf.verifyMessages(3, true);\n        String[] expectedActions = new String[] {consts.getCreateSequenceAction(), \n                                                 GREETME_ONEWAY_ACTION,\n                                                 consts.getTerminateSequenceAction()};\n        mf.verifyActions(expectedActions, true);\n        mf.verifyMessageNumbers(new String[] {null, \"1\", null}, true);\n        if (RM11Constants.NAMESPACE_URI.equals(consts.getWSRMNamespace())) {\n            // no LastMessage\n            mf.verifyLastMessage(new boolean[] {false, false, false}, true);\n        } else {\n            // uses LastMessage\n            mf.verifyLastMessage(new boolean[] {false, true, false}, true);\n        }\n\n        if (RM11Constants.NAMESPACE_URI.equals(consts.getWSRMNamespace())) {\n            // CSR, ACK, TSR\n            mf.verifyMessages(3, false);\n            expectedActions = new String[] {consts.getCreateSequenceResponseAction(), \n                                            consts.getSequenceAckAction(),\n                                            RM11Constants.INSTANCE.getTerminateSequenceResponseAction()};\n            mf.verifyActions(expectedActions, false);\n            mf.verifyAcknowledgements(new boolean[] {false, true, false}, false);\n\n        } else {\n            // CSR, ACK, PR\n            mf.verifyMessages(2, false);\n            expectedActions = new String[] {consts.getCreateSequenceResponseAction(), \n                                            consts.getSequenceAckAction()};\n            mf.verifyActions(expectedActions, false);\n            mf.verifyAcknowledgements(new boolean[] {false, true}, false);\n        }\n    }","id":38286,"modified_method":"private void verifyTerminateSequence(String wsaUri, RMConstants consts) throws Exception {\n        MessageFlow mf = new MessageFlow(outRecorder.getOutboundMessages(),\n                                         inRecorder.getInboundMessages(), wsaUri, consts.getWSRMNamespace());\n        if (RM11Constants.NAMESPACE_URI.equals(consts.getWSRMNamespace())) {\n            awaitMessages(4, 4);\n            \n            mf.verifyMessages(4, true);\n            String[] expectedActions = new String[] {consts.getCreateSequenceAction(), \n                                                     GREETME_ONEWAY_ACTION,\n                                                     consts.getCloseSequenceAction(),\n                                                     consts.getTerminateSequenceAction()};\n            mf.verifyActions(expectedActions, true);\n            mf.verifyMessageNumbers(new String[] {null, \"1\", null, null}, true);\n\n            // no LastMessage\n            mf.verifyLastMessage(new boolean[] {false, false, false, false}, true);\n\n            // CrSR, ACK, ClSR, TSR\n            mf.verifyMessages(4, false);\n            expectedActions = new String[] {consts.getCreateSequenceResponseAction(), \n                                            consts.getSequenceAckAction(),\n                                            RM11Constants.INSTANCE.getCloseSequenceResponseAction(),\n                                            RM11Constants.INSTANCE.getTerminateSequenceResponseAction()};\n            mf.verifyActions(expectedActions, false);\n            mf.verifyAcknowledgements(new boolean[] {false, true, false, false}, false);\n\n        } else {\n            awaitMessages(3, 2);\n            \n            mf.verifyMessages(3, true);\n            String[] expectedActions = new String[] {consts.getCreateSequenceAction(), \n                                                     GREETME_ONEWAY_ACTION,\n                                                     consts.getTerminateSequenceAction()};\n            mf.verifyActions(expectedActions, true);\n            mf.verifyMessageNumbers(new String[] {null, \"1\", null}, true);\n\n            // uses LastMessage\n            mf.verifyLastMessage(new boolean[] {false, true, false}, true);\n\n            // CrSR, ACK, PR\n            mf.verifyMessages(2, false);\n            expectedActions = new String[] {consts.getCreateSequenceResponseAction(), \n                                            consts.getSequenceAckAction()};\n            mf.verifyActions(expectedActions, false);\n            mf.verifyAcknowledgements(new boolean[] {false, true}, false);\n        }\n    }","commit_id":"77c9f157297e65c2bc23182b19ab79d8a442b93e","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Used by the RM source to cache received acknowledgements for this\n     * sequence.\n     * \n     * @param acknowledgement an acknowledgement for this sequence\n     */\n    public void setAcknowledged(SequenceAcknowledgement a) throws RMException {\n        acknowledgement = a;\n        source.getManager().getRetransmissionQueue().purgeAcknowledged(this);\n        if (allAcknowledged()) {\n            if (null == target || RMUtils.getAddressingConstants().getAnonymousURI().equals(\n                target.getAddress().getValue())) {\n                LOG.log(Level.WARNING, \"STANDALONE_ANON_TERMINATE_SEQUENCE_MSG\");\n                // keep the sequence and let RMOutInterceptor remove it after building the TS message\n                // if we remove the sequence here, RMOutInterceptor should check for a null sequence\n            } else {\n                RMEndpoint rme = source.getReliableEndpoint();\n                Proxy proxy = rme.getProxy();\n                // REVIST for rm 1.1, provide an option to how the close and terminate messages are sent\n                proxy.terminate(this);\n                source.removeSequence(this);\n            }\n        }\n    }","id":38287,"modified_method":"/**\n     * Used by the RM source to cache received acknowledgements for this\n     * sequence.\n     * \n     * @param acknowledgement an acknowledgement for this sequence\n     */\n    public void setAcknowledged(SequenceAcknowledgement a) throws RMException {\n        acknowledgement = a;\n        source.getManager().getRetransmissionQueue().purgeAcknowledged(this);\n        if (allAcknowledged()) {\n            if (null == target || RMUtils.getAddressingConstants().getAnonymousURI().equals(\n                target.getAddress().getValue())) {\n                LOG.log(Level.WARNING, \"STANDALONE_ANON_TERMINATE_SEQUENCE_MSG\");\n                // keep the sequence and let RMOutInterceptor remove it after building the TS message\n                // if we remove the sequence here, RMOutInterceptor should check for a null sequence\n            } else {\n                RMEndpoint rme = source.getReliableEndpoint();\n                Proxy proxy = rme.getProxy();\n                // REVIST for rm 1.1, provide an option to how the close and terminate messages are sent\n                if (ProtocolVariation.RM11WSA200508 == getProtocol()) {\n                    proxy.lastMessage(this);\n                }\n                proxy.terminate(this);\n                source.removeSequence(this);\n            }\n        }\n    }","commit_id":"77c9f157297e65c2bc23182b19ab79d8a442b93e","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method. Returns this panel that\n     * has been configured to display a chat contact.\n     *\n     * @param list the source list\n     * @param value the value of the current cell\n     * @param index the index of the current cell in the source list\n     * @param isSelected indicates if this cell is selected\n     * @param cellHasFocus indicates if this cell is focused\n     * \n     * @return this panel\n     */\n    @Override\n    public Component getListCellRendererComponent(  JList list,\n                                                    Object value,\n                                                    int index,\n                                                    boolean isSelected,\n                                                    boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.rightLabel.setIcon(null);\n\n        final ChatContact chatContact = (ChatContact) value;\n        final ChatRoomMember member \n            = (ChatRoomMember) chatContact.getDescriptor();\n\n        this.setPreferredSize(new Dimension(20, 30));\n\n        String displayName = chatContact.getName();\n\n        if (displayName == null || displayName.length() < 1)\n        {\n            displayName = GuiActivator.getResources()\n                .getI18NString(\"service.gui.UNKNOWN\");\n        }\n\n        this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n        this.nameLabel.setText(displayName);\n\n        if(member.getRole() != null)\n            this.nameLabel.setIcon(\n                ChatContactRoleIcon.getRoleIcon(member.getRole()));\n\n        if (contactForegroundColor != null)\n            this.nameLabel.setForeground(contactForegroundColor);\n\n        this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 1));\n\n        ImageIcon avatar = chatContact.getAvatar();\n\n        if (avatar != null)\n            this.rightLabel.setIcon(avatar);\n        else\n        {\n            if(chatContact.getName().equals(\n                    member.getChatRoom().getUserNickname()))\n            {\n                // Try to retrieve local user avatar:\n                OperationSetServerStoredAccountInfo opSet\n                    = (OperationSetServerStoredAccountInfo)\n                    member.getChatRoom().getParentProvider().getOperationSet(\n                        OperationSetServerStoredAccountInfo.class);\n\n                Iterator<GenericDetail> itr = opSet.getAllAvailableDetails();\n                while(itr.hasNext())\n                {\n                    GenericDetail detail = itr.next();\n                    if(detail instanceof BinaryDetail)\n                    {\n                        BinaryDetail bin = (BinaryDetail)detail;\n                        if(bin.getBytes() != null)\n                            this.rightLabel.setIcon(\n                                ImageUtils.getScaledRoundedIcon(\n                                    bin.getBytes(), 25, 25));\n                        break;\n                    }\n                }\n                ChatRoomMemberRole role = member.getChatRoom().getUserRole();\n                if (role != null)\n                    this.nameLabel.setIcon(\n                        ChatContactRoleIcon.getRoleIcon(role));\n            }\n            else\n            {\n                // Try to retrieve participant avatar:\n                OperationSetPersistentPresence opSet\n                    = (OperationSetPersistentPresence)\n                member.getChatRoom().getParentProvider().getOperationSet(\n                    OperationSetPersistentPresence.class);\n\n                Contact c = opSet.findContactByID(member.getContactAddress());\n\n                if(opSet != null && c != null && c.getImage() != null)\n                    this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(\n                            c.getImage(), 25, 25));\n            }\n        }\n\n        // We should set the bounds of the cell explicitly in order to\n        // make getComponentAt work properly.\n        this.setBounds(0, 0, list.getWidth() - 2, 30);\n\n        this.nameLabel.setBounds(\n                    0, 0, list.getWidth() - 28, 17);\n\n        this.rightLabel.setBounds(\n            list.getWidth() - 28, 0, 25, 30);\n\n        this.isLeaf = true;\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","id":38288,"modified_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method. Returns this panel that\n     * has been configured to display a chat contact.\n     *\n     * @param list the source list\n     * @param value the value of the current cell\n     * @param index the index of the current cell in the source list\n     * @param isSelected indicates if this cell is selected\n     * @param cellHasFocus indicates if this cell is focused\n     * \n     * @return this panel\n     */\n    @Override\n    public Component getListCellRendererComponent(  JList list,\n                                                    Object value,\n                                                    int index,\n                                                    boolean isSelected,\n                                                    boolean cellHasFocus)\n    {\n        this.index = index;\n\n        this.rightLabel.setIcon(null);\n\n        final ChatContact chatContact = (ChatContact) value;\n        final ChatRoomMember member \n            = (ChatRoomMember) chatContact.getDescriptor();\n\n        this.setPreferredSize(new Dimension(20, 30));\n\n        String displayName = chatContact.getName();\n\n        if (displayName == null || displayName.length() < 1)\n        {\n            displayName = GuiActivator.getResources()\n                .getI18NString(\"service.gui.UNKNOWN\");\n        }\n\n        this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));\n        this.nameLabel.setText(displayName);\n\n        if(member.getRole() != null)\n            this.nameLabel.setIcon(\n                ChatContactRoleIcon.getRoleIcon(member.getRole()));\n\n        if (contactForegroundColor != null)\n            this.nameLabel.setForeground(contactForegroundColor);\n\n        this.setBorder(BorderFactory.createEmptyBorder(1, 5, 1, 1));\n\n        ImageIcon avatar = chatContact.getAvatar();\n\n        if (avatar != null)\n            this.rightLabel.setIcon(avatar);\n        else\n        {\n            if(chatContact.getName().equals(\n                    member.getChatRoom().getUserNickname()))\n            {\n                // Try to retrieve local user avatar:\n                OperationSetServerStoredAccountInfo opSet\n                    = member.getChatRoom().getParentProvider().getOperationSet(\n                        OperationSetServerStoredAccountInfo.class);\n\n                Iterator<GenericDetail> itr = opSet.getAllAvailableDetails();\n                while(itr.hasNext())\n                {\n                    GenericDetail detail = itr.next();\n                    if(detail instanceof BinaryDetail)\n                    {\n                        BinaryDetail bin = (BinaryDetail)detail;\n                        if(bin.getBytes() != null)\n                            this.rightLabel.setIcon(\n                                ImageUtils.getScaledRoundedIcon(\n                                    bin.getBytes(), 25, 25));\n                        break;\n                    }\n                }\n                ChatRoomMemberRole role = member.getChatRoom().getUserRole();\n                if (role != null)\n                    this.nameLabel.setIcon(\n                        ChatContactRoleIcon.getRoleIcon(role));\n            }\n            else\n            {\n                // Try to retrieve participant avatar:\n                OperationSetPersistentPresence opSet\n                    = member.getChatRoom().getParentProvider().getOperationSet(\n                    OperationSetPersistentPresence.class);\n\n                Contact c = opSet.findContactByID(member.getContactAddress());\n\n                if(opSet != null && c != null && c.getImage() != null)\n                    this.rightLabel.setIcon(ImageUtils.getScaledRoundedIcon(\n                            c.getImage(), 25, 25));\n            }\n        }\n\n        // We should set the bounds of the cell explicitly in order to\n        // make getComponentAt work properly.\n        this.setBounds(0, 0, list.getWidth() - 2, 30);\n\n        this.nameLabel.setBounds(\n                    0, 0, list.getWidth() - 28, 17);\n\n        this.rightLabel.setBounds(\n            list.getWidth() - 28, 0, 25, 30);\n\n        this.isLeaf = true;\n\n        this.isSelected = isSelected;\n\n        return this;\n    }","commit_id":"aae0c5d7ccfe130cb145c9587a61596467dbf024","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the menu, by adding all containing menu items.\n     */\n    private void init()\n    {\n        this.kickItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.KICK\"));\n\n        this.banItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.BAN\"));\n\n        this.grantAdminItem.setMnemonic(\n           GuiActivator.getResources().getI18nMnemonic(\n           \"service.gui.GRANT_ADMIN\"));\n        this.grantMembershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n           \"service.gui.GRANT_MEMBERSHIP\"));\n        this.grantModeratorItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.GRANT_MODERATOR\"));\n        this.grantOwnershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.GRANT_OWNERSHIP\"));\n        this.grantVoiceItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.GRANT_VOICE\"));\n        this.revokeAdminItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_ADMIN\"));\n        this.revokeMembershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_MEMBERSHIP\"));\n        this.revokeModeratorItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_MODERATOR\"));\n        this.revokeOwnershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_OWNERSHIP\"));\n        this.revokeVoiceItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_VOICE\"));\n        this.changeNicknameItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.CHANGE_NICKNAME\"));\n        this.changeNicknameItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.CHANGE_ROOM_SUBJECT\"));\n\n        this.kickItem.addActionListener(this);\n        this.banItem.addActionListener(this);\n        this.changeNicknameItem.addActionListener(this);\n        this.changeRoomSubjectItem.addActionListener(this);\n        this.grantAdminItem.addActionListener(this);\n        this.grantMembershipItem.addActionListener(this);\n        this.grantModeratorItem.addActionListener(this);\n        this.grantOwnershipItem.addActionListener(this);\n        this.grantVoiceItem.addActionListener(this);\n        this.revokeAdminItem.addActionListener(this);\n        this.revokeMembershipItem.addActionListener(this);\n        this.revokeModeratorItem.addActionListener(this);\n        this.revokeOwnershipItem.addActionListener(this);\n        this.revokeVoiceItem.addActionListener(this);\n\n        this.grantOwnershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_OWNER), 16, 16));\n        this.grantAdminItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_ADMIN), 16, 16));\n        this.grantMembershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.grantModeratorItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(\n                ImageLoader.CHATROOM_MEMBER_MODERATOR), 16, 16));\n        this.grantVoiceItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.revokeAdminItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.revokeMembershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_GUEST), 16, 16));\n        this.revokeModeratorItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.revokeOwnershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_ADMIN), 16, 16));\n        this.revokeVoiceItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_SILENT), 16, 16));\n        this.kickItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.KICK_ICON_16x16)));\n        this.banItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.BAN_ICON_16x16)));\n        this.changeNicknameItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.CHANGE_NICKNAME_ICON_16x16)));\n        this.changeRoomSubjectItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.CHANGE_ROOM_SUBJECT_ICON_16x16)));\n        int roleIndex = ((ChatRoomMember)\n                chatContact.getDescriptor()).getRole().getRoleIndex();\n        String roleName = ((ChatRoomMember)\n                chatContact.getDescriptor()).getRole().getRoleName();\n\n        if(chatContact.getName().equals(room.getUserNickname()))\n        {\n            roleName = room.getUserRole().getRoleName();\n            roleIndex  = room.getUserRole().getRoleIndex();\n        }\n\n        JLabel jl_username\n            = new JLabel(\" \"+chatContact.getName()+\" (\"+roleName+\") \");\n        jl_username.setFont(jl_username.getFont().deriveFont(Font.BOLD));\n\n        this.add(jl_username);\n        this.addSeparator();\n\n        OperationSetPersistentPresence opSet\n            = (OperationSetPersistentPresence) room.getParentProvider()\n                .getOperationSet(OperationSetPersistentPresence.class);\n\n        Contact c = opSet.findContactByID(room.getUserNickname());\n\n        // Here we build the menu when the local user cell renderer is clicked:\n        if(chatContact.getName().equals(room.getUserNickname()))\n        {\n            if(roleIndex >= 50)\n            {\n                // It means we are at least a moderator, so we can change room's\n                // subject:\n                this.add(this.changeRoomSubjectItem);\n            }\n\n            this.add(this.changeNicknameItem);\n        }\n        else\n        {\n            if(room.getUserRole().getRoleIndex() >= 50)\n            {\n                if(roleIndex <= 40)\n                {\n                    this.add(this.kickItem);\n\n                    // Admins and owners can ban members:\n                    if(room.getUserRole().getRoleIndex() >= 60 && roleIndex < 50)\n                    {\n                        this.add(this.banItem);\n                    }\n                    this.addSeparator();\n                }\n\n                // we must at least be a moderator for managing voice rights\n                if(roleIndex <= 20)\n                    this.add(this.grantVoiceItem);\n                else if(roleIndex == 40 || roleIndex == 30)\n                    this.add(this.revokeVoiceItem);\n            }\n\n            if(room.getUserRole().getRoleIndex() >= 60)\n            {\n                // we must at least be an admin to manage membership\n                if(roleIndex < 40)\n                    this.add(this.grantMembershipItem);\n                else if(roleIndex == 40)\n                    this.add(this.revokeMembershipItem);\n\n                if(roleIndex < 50)    // room admins can edit moderators list\n                    this.add(this.grantModeratorItem);\n                else if(roleIndex == 50)\n                    this.add(this.revokeModeratorItem);\n            }\n\n            // only room owners can edit admins list\n            if(room.getUserRole().getRoleIndex() == 70)\n            {\n                if(roleIndex != 60 && roleIndex >= 30)\n                // room owners can grant members or unaffiliated users as admins\n                    this.add(this.grantAdminItem);\n                else if(roleIndex == 60)\n                    this.add(this.revokeAdminItem);\n\n                // room owners can edit owners list\n                if(roleIndex != 70 && roleIndex >= 40)\n                    this.add(this.grantOwnershipItem);\n                else if(roleIndex == 70)\n                    this.add(this.revokeOwnershipItem);\n            }\n        }\n    }","id":38289,"modified_method":"/**\n     * Initializes the menu, by adding all containing menu items.\n     */\n    private void init()\n    {\n        this.kickItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.KICK\"));\n\n        this.banItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\"service.gui.BAN\"));\n\n        this.grantAdminItem.setMnemonic(\n           GuiActivator.getResources().getI18nMnemonic(\n           \"service.gui.GRANT_ADMIN\"));\n        this.grantMembershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n           \"service.gui.GRANT_MEMBERSHIP\"));\n        this.grantModeratorItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.GRANT_MODERATOR\"));\n        this.grantOwnershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.GRANT_OWNERSHIP\"));\n        this.grantVoiceItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.GRANT_VOICE\"));\n        this.revokeAdminItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_ADMIN\"));\n        this.revokeMembershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_MEMBERSHIP\"));\n        this.revokeModeratorItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_MODERATOR\"));\n        this.revokeOwnershipItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_OWNERSHIP\"));\n        this.revokeVoiceItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.REVOKE_VOICE\"));\n        this.changeNicknameItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.CHANGE_NICKNAME\"));\n        this.changeNicknameItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n            \"service.gui.CHANGE_ROOM_SUBJECT\"));\n\n        this.kickItem.addActionListener(this);\n        this.banItem.addActionListener(this);\n        this.changeNicknameItem.addActionListener(this);\n        this.changeRoomSubjectItem.addActionListener(this);\n        this.grantAdminItem.addActionListener(this);\n        this.grantMembershipItem.addActionListener(this);\n        this.grantModeratorItem.addActionListener(this);\n        this.grantOwnershipItem.addActionListener(this);\n        this.grantVoiceItem.addActionListener(this);\n        this.revokeAdminItem.addActionListener(this);\n        this.revokeMembershipItem.addActionListener(this);\n        this.revokeModeratorItem.addActionListener(this);\n        this.revokeOwnershipItem.addActionListener(this);\n        this.revokeVoiceItem.addActionListener(this);\n\n        this.grantOwnershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_OWNER), 16, 16));\n        this.grantAdminItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_ADMIN), 16, 16));\n        this.grantMembershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.grantModeratorItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(\n                ImageLoader.CHATROOM_MEMBER_MODERATOR), 16, 16));\n        this.grantVoiceItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.revokeAdminItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.revokeMembershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_GUEST), 16, 16));\n        this.revokeModeratorItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_STANDARD), 16, 16));\n        this.revokeOwnershipItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_ADMIN), 16, 16));\n        this.revokeVoiceItem.setIcon(ImageUtils.getScaledRoundedIcon(\n            ImageLoader.getImage(ImageLoader.CHATROOM_MEMBER_SILENT), 16, 16));\n        this.kickItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.KICK_ICON_16x16)));\n        this.banItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.BAN_ICON_16x16)));\n        this.changeNicknameItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.CHANGE_NICKNAME_ICON_16x16)));\n        this.changeRoomSubjectItem.setIcon(new ImageIcon(ImageLoader.getImage(\n            ImageLoader.CHANGE_ROOM_SUBJECT_ICON_16x16)));\n        int roleIndex = ((ChatRoomMember)\n                chatContact.getDescriptor()).getRole().getRoleIndex();\n        String roleName = ((ChatRoomMember)\n                chatContact.getDescriptor()).getRole().getRoleName();\n\n        if(chatContact.getName().equals(room.getUserNickname()))\n        {\n            roleName = room.getUserRole().getRoleName();\n            roleIndex  = room.getUserRole().getRoleIndex();\n        }\n\n        JLabel jl_username\n            = new JLabel(\" \"+chatContact.getName()+\" (\"+roleName+\") \");\n        jl_username.setFont(jl_username.getFont().deriveFont(Font.BOLD));\n\n        this.add(jl_username);\n        this.addSeparator();\n\n        OperationSetPersistentPresence opSet\n            = room.getParentProvider()\n                .getOperationSet(OperationSetPersistentPresence.class);\n\n        Contact c = opSet.findContactByID(room.getUserNickname());\n\n        // Here we build the menu when the local user cell renderer is clicked:\n        if(chatContact.getName().equals(room.getUserNickname()))\n        {\n            if(roleIndex >= 50)\n            {\n                // It means we are at least a moderator, so we can change room's\n                // subject:\n                this.add(this.changeRoomSubjectItem);\n            }\n\n            this.add(this.changeNicknameItem);\n        }\n        else\n        {\n            if(room.getUserRole().getRoleIndex() >= 50)\n            {\n                if(roleIndex <= 40)\n                {\n                    this.add(this.kickItem);\n\n                    // Admins and owners can ban members:\n                    if(room.getUserRole().getRoleIndex() >= 60 && roleIndex < 50)\n                    {\n                        this.add(this.banItem);\n                    }\n                    this.addSeparator();\n                }\n\n                // we must at least be a moderator for managing voice rights\n                if(roleIndex <= 20)\n                    this.add(this.grantVoiceItem);\n                else if(roleIndex == 40 || roleIndex == 30)\n                    this.add(this.revokeVoiceItem);\n            }\n\n            if(room.getUserRole().getRoleIndex() >= 60)\n            {\n                // we must at least be an admin to manage membership\n                if(roleIndex < 40)\n                    this.add(this.grantMembershipItem);\n                else if(roleIndex == 40)\n                    this.add(this.revokeMembershipItem);\n\n                if(roleIndex < 50)    // room admins can edit moderators list\n                    this.add(this.grantModeratorItem);\n                else if(roleIndex == 50)\n                    this.add(this.revokeModeratorItem);\n            }\n\n            // only room owners can edit admins list\n            if(room.getUserRole().getRoleIndex() == 70)\n            {\n                if(roleIndex != 60 && roleIndex >= 30)\n                // room owners can grant members or unaffiliated users as admins\n                    this.add(this.grantAdminItem);\n                else if(roleIndex == 60)\n                    this.add(this.revokeAdminItem);\n\n                // room owners can edit owners list\n                if(roleIndex != 70 && roleIndex >= 40)\n                    this.add(this.grantOwnershipItem);\n                else if(roleIndex == 70)\n                    this.add(this.revokeOwnershipItem);\n            }\n        }\n    }","commit_id":"aae0c5d7ccfe130cb145c9587a61596467dbf024","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            OperationSetBasicTelephony telephony =\n                (OperationSetBasicTelephony) callPeer.getProtocolProvider()\n                    .getOperationSet(OperationSetBasicTelephony.class);\n\n            try\n            {\n                if (isOnHold)\n                    telephony.putOnHold(callPeer);\n                else\n                    telephony.putOffHold(callPeer);\n            }\n            catch (OperationFailedException ex)\n            {\n                String callPeerAddress = callPeer.getAddress();\n\n                if (isOnHold)\n                    logger.error(\"Failed to put\"\n                        + callPeerAddress + \" on hold.\", ex);\n                else\n                    logger.error(\"Failed to put\"\n                        + callPeerAddress + \" off hold.\", ex);\n            }\n        }","id":38290,"modified_method":"public void run()\n        {\n            OperationSetBasicTelephony telephony =\n                callPeer.getProtocolProvider()\n                    .getOperationSet(OperationSetBasicTelephony.class);\n\n            try\n            {\n                if (isOnHold)\n                    telephony.putOnHold(callPeer);\n                else\n                    telephony.putOffHold(callPeer);\n            }\n            catch (OperationFailedException ex)\n            {\n                String callPeerAddress = callPeer.getAddress();\n\n                if (isOnHold)\n                    logger.error(\"Failed to put\"\n                        + callPeerAddress + \" on hold.\", ex);\n                else\n                    logger.error(\"Failed to put\"\n                        + callPeerAddress + \" off hold.\", ex);\n            }\n        }","commit_id":"42f97ab2ecd576d8ba23dfcca8b1de6c84979124","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            ProtocolProviderService pps = callPeer.getProtocolProvider();\n\n            OperationSetBasicTelephony telephony =\n                (OperationSetBasicTelephony) pps\n                    .getOperationSet(OperationSetBasicTelephony.class);\n\n            try\n            {\n                telephony.hangupCallPeer(callPeer);\n            }\n            catch (OperationFailedException e)\n            {\n                logger.error(\"Could not hang up : \" + callPeer\n                    + \" caused by the following exception: \" + e);\n            }\n        }","id":38291,"modified_method":"public void run()\n        {\n            ProtocolProviderService pps = callPeer.getProtocolProvider();\n\n            OperationSetBasicTelephony telephony =\n                pps.getOperationSet(OperationSetBasicTelephony.class);\n\n            try\n            {\n                telephony.hangupCallPeer(callPeer);\n            }\n            catch (OperationFailedException e)\n            {\n                logger.error(\"Could not hang up : \" + callPeer\n                    + \" caused by the following exception: \" + e);\n            }\n        }","commit_id":"42f97ab2ecd576d8ba23dfcca8b1de6c84979124","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void run()\n        {\n            OperationSetBasicTelephony telephony =\n                (OperationSetBasicTelephony) callPeer.getProtocolProvider()\n                    .getOperationSet(OperationSetBasicTelephony.class);\n\n            telephony.setMute(callPeer, isMute);\n        }","id":38292,"modified_method":"public void run()\n        {\n            OperationSetBasicTelephony telephony =\n                callPeer.getProtocolProvider()\n                    .getOperationSet(OperationSetBasicTelephony.class);\n\n            telephony.setMute(callPeer, isMute);\n        }","commit_id":"42f97ab2ecd576d8ba23dfcca8b1de6c84979124","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a <tt>ConferenceDescription<\/tt> to the list of conferences.\n     *\n     * @param chatConference the <tt>ConferenceDescription<\/tt> to add\n     */\n    public void addConference(ConferenceDescription conferenceDescription)\n    {\n        chatConferenceListPanel.addConference(conferenceDescription);\n    }","id":38293,"modified_method":"/**\n     * Adds a <tt>ConferenceDescription<\/tt> to the list of conferences.\n     *\n     * @param conferenceDescription the <tt>ConferenceDescription<\/tt> to add\n     */\n    public void addConference(ConferenceDescription conferenceDescription)\n    {\n        chatConferenceListPanel.addConference(conferenceDescription);\n    }","commit_id":"1f990a0d5c1a4689d45965d9d05f6616d0dbd3c8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Joins an existing chat room conference call.\n     */\n    private void joinConference()\n    {\n        \n        ConferenceDescription chatConference\n            = (ConferenceDescription)chatConferenceListPanel.getSelectedValue();\n\n        if (chatConference != null)\n            CallManager.call(chatPanel.getChatSession()\n                .getCurrentChatTransport()\n                    .getProtocolProvider(), chatConference, chatRoom);\n    }","id":38294,"modified_method":"/**\n     * Joins an existing chat room conference call.\n     */\n    private void joinConference()\n    {\n        \n        ConferenceDescription chatConference\n            = chatConferenceListPanel.getSelectedValue();\n\n        if (chatConference != null)\n            CallManager.call(chatPanel.getChatSession()\n                .getCurrentChatTransport()\n                    .getProtocolProvider(), chatConference, chatRoom);\n    }","commit_id":"1f990a0d5c1a4689d45965d9d05f6616d0dbd3c8","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\r\n    protected void run()\r\n    {\r\n        ConfigurationService configService\r\n            = MUCActivator.getConfigurationService();\r\n    \r\n        String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\r\n    \r\n        List<String> accounts =\r\n            configService.getPropertyNamesByPrefix(prefix, true);\r\n    \r\n        for(ProtocolProviderService pps : MUCActivator\r\n            .getChatRoomProviders())\r\n        {\r\n            for (String accountRootPropName : accounts) {\r\n                String accountUID\r\n                    = configService.getString(accountRootPropName);\r\n    \r\n                if(accountUID.equals(pps\r\n                        .getAccountID().getAccountUniqueID()))\r\n                {\r\n                    List<String> chatRooms = configService\r\n                        .getPropertyNamesByPrefix(\r\n                            accountRootPropName + \".chatRooms\", true);\r\n    \r\n                    for (String chatRoomPropName : chatRooms)\r\n                    {\r\n                        if(count > 0 && getQueryResultCount() > count)\r\n                        {\r\n                            if (getStatus() != QUERY_CANCELED)\r\n                                setStatus(QUERY_COMPLETED);\r\n                            return;\r\n                        }\r\n                        \r\n                        addChatRoom( pps, configService.getString(\r\n                            chatRoomPropName + \".chatRoomName\"),\r\n                            configService.getString(chatRoomPropName));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (getStatus() != QUERY_CANCELED)\r\n            setStatus(QUERY_COMPLETED);\r\n    }","id":38295,"modified_method":"@Override\r\n    protected void run()\r\n    {\r\n        Iterator<ChatRoomProviderWrapper> chatRoomProviders\r\n            = MUCActivator\r\n                .getMUCService().getChatRoomList().getChatRoomProviders();\r\n        while (chatRoomProviders.hasNext())\r\n        {\r\n            ChatRoomProviderWrapper provider = chatRoomProviders.next();\r\n            for(int i = 0; i < provider.countChatRooms(); i++)\r\n            {\r\n                if(count > 0 && getQueryResultCount() > count)\r\n                {\r\n                    if (getStatus() != QUERY_CANCELED)\r\n                        setStatus(QUERY_COMPLETED);\r\n                    return;\r\n                }\r\n                ChatRoomWrapper chatRoom = provider.getChatRoom(i);\r\n                addChatRoom( provider.getProtocolProvider(), \r\n                    chatRoom.getChatRoomName(), chatRoom.getChatRoomID());\r\n            }\r\n        }\r\n        if (getStatus() != QUERY_CANCELED)\r\n            setStatus(QUERY_COMPLETED);\r\n    }","commit_id":"1f990a0d5c1a4689d45965d9d05f6616d0dbd3c8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Creates an instance of <tt>ChatRoomQuery<\/tt> by specifying\r\n     * the parent contact source, the query string to match and the maximum\r\n     * result contacts to return.\r\n     *\r\n     * @param contactSource the parent contact source\r\n     * @param queryString the query string to match\r\n     * @param contactCount the maximum result contact count\r\n     */\r\n    public ChatRoomQuery(String queryString,\r\n        int count, ChatRoomContactSourceService contactSource)\r\n    {\r\n        super(contactSource,\r\n            Pattern.compile(queryString, Pattern.CASE_INSENSITIVE\r\n                            | Pattern.LITERAL), true);\r\n        this.count = count;\r\n        this.queryString = queryString;\r\n        for(ProtocolProviderService pps : MUCActivator\r\n            .getChatRoomProviders())\r\n        {\r\n            OperationSetMultiUserChat opSetMUC = (OperationSetMultiUserChat)\r\n                pps.getOperationSet(OperationSetMultiUserChat.class);\r\n            if(opSetMUC != null)\r\n            {\r\n                opSetMUC.addPresenceListener(this);\r\n            }\r\n        }\r\n        \r\n        MUCActivator.getMUCService().addChatRoomListChangeListener(this);\r\n    }","id":38296,"modified_method":"/**\r\n     * Creates an instance of <tt>ChatRoomQuery<\/tt> by specifying\r\n     * the parent contact source, the query string to match and the maximum\r\n     * result contacts to return.\r\n     *\r\n     * @param contactSource the parent contact source\r\n     * @param queryString the query string to match\r\n     * @param count the maximum result contact count\r\n     */\r\n    public ChatRoomQuery(String queryString,\r\n        int count, ChatRoomContactSourceService contactSource)\r\n    {\r\n        super(contactSource,\r\n            Pattern.compile(queryString, Pattern.CASE_INSENSITIVE\r\n                            | Pattern.LITERAL), true);\r\n        this.count = count;\r\n        this.queryString = queryString;\r\n        for(ProtocolProviderService pps : MUCActivator\r\n            .getChatRoomProviders())\r\n        {\r\n            OperationSetMultiUserChat opSetMUC \r\n                = pps.getOperationSet(OperationSetMultiUserChat.class);\r\n            if(opSetMUC != null)\r\n            {\r\n                opSetMUC.addPresenceListener(this);\r\n            }\r\n        }\r\n        \r\n        MUCActivator.getMUCService().addChatRoomListChangeListener(this);\r\n    }","commit_id":"1f990a0d5c1a4689d45965d9d05f6616d0dbd3c8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a reference to a CredentialsStorageService implementation\n     * currently registered in the bundle context or null if no such\n     * implementation was found.\n     *\n     * @return a currently valid implementation of the\n     * CredentialsStorageService.\n     */\n    public static CredentialsStorageService getCredentialsStorageService()\n    {\n        if (credentialsService == null)\n        {\n            credentialsService\n                = (CredentialsStorageService) ServiceUtils.getService(\n                    bundleContext, CredentialsStorageService.class);\n        }\n        return credentialsService;\n    }","id":38297,"modified_method":"/**\n     * Returns a reference to a CredentialsStorageService implementation\n     * currently registered in the bundle context or null if no such\n     * implementation was found.\n     *\n     * @return a currently valid implementation of the\n     * CredentialsStorageService.\n     */\n    public static CredentialsStorageService getCredentialsStorageService()\n    {\n        if (credentialsService == null)\n        {\n            credentialsService\n                = ServiceUtils.getService(\n                    bundleContext, CredentialsStorageService.class);\n        }\n        return credentialsService;\n    }","commit_id":"1f990a0d5c1a4689d45965d9d05f6616d0dbd3c8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n         * @override {@link SwingWorker}{@link #doInBackground()} to perform\r\n         * all asynchronous tasks.\r\n         * @return SUCCESS if success, otherwise the error code\r\n         */\r\n        @Override\r\n        public void run()\r\n        {\r\n            ChatRoom chatRoom = chatRoomWrapper.getChatRoom();\r\n\r\n            try\r\n            {\r\n                if(password != null && password.length > 0)\r\n                    chatRoom.joinAs(nickName, password);\r\n                else if (nickName != null)\r\n                    chatRoom.joinAs(nickName);\r\n                else\r\n                    chatRoom.join();\r\n\r\n                done(SUCCESS);\r\n            }\r\n            catch (OperationFailedException e)\r\n            {\r\n                if (logger.isTraceEnabled())\r\n                    logger.trace(\"Failed to join chat room: \"\r\n                    + chatRoom.getName(), e);\r\n\r\n                switch (e.getErrorCode())\r\n                {\r\n                case OperationFailedException.AUTHENTICATION_FAILED:\r\n                    done(AUTHENTICATION_FAILED);\r\n                case OperationFailedException.REGISTRATION_REQUIRED:\r\n                    done(REGISTRATION_REQUIRED);\r\n                case OperationFailedException.PROVIDER_NOT_REGISTERED:\r\n                    done(PROVIDER_NOT_REGISTERED);\r\n                case OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS:\r\n                    done(SUBSCRIPTION_ALREADY_EXISTS);\r\n                default:\r\n                    done(UNKNOWN_ERROR);\r\n                }\r\n            }\r\n        }","id":38298,"modified_method":"/**\r\n         * @override {@link Thread}{@link #run()} to perform all asynchronous \r\n         * tasks.\r\n         */\r\n        @Override\r\n        public void run()\r\n        {\r\n            ChatRoom chatRoom = chatRoomWrapper.getChatRoom();\r\n\r\n            try\r\n            {\r\n                if(password != null && password.length > 0)\r\n                    chatRoom.joinAs(nickName, password);\r\n                else if (nickName != null)\r\n                    chatRoom.joinAs(nickName);\r\n                else\r\n                    chatRoom.join();\r\n\r\n                done(SUCCESS);\r\n            }\r\n            catch (OperationFailedException e)\r\n            {\r\n                if (logger.isTraceEnabled())\r\n                    logger.trace(\"Failed to join chat room: \"\r\n                    + chatRoom.getName(), e);\r\n\r\n                switch (e.getErrorCode())\r\n                {\r\n                case OperationFailedException.AUTHENTICATION_FAILED:\r\n                    done(AUTHENTICATION_FAILED);\r\n                    break;\r\n                case OperationFailedException.REGISTRATION_REQUIRED:\r\n                    done(REGISTRATION_REQUIRED);\r\n                    break;\r\n                case OperationFailedException.PROVIDER_NOT_REGISTERED:\r\n                    done(PROVIDER_NOT_REGISTERED);\r\n                    break;\r\n                case OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS:\r\n                    done(SUBSCRIPTION_ALREADY_EXISTS);\r\n                    break;\r\n                default:\r\n                    done(UNKNOWN_ERROR);\r\n                }\r\n            }\r\n        }","commit_id":"1f990a0d5c1a4689d45965d9d05f6616d0dbd3c8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n         * @override {@link SwingWorker}{@link #done()} to perform UI changes\r\n         * after the chat room join task has finished.\r\n         */\r\n        private void done(String returnCode)\r\n        {\r\n\r\n            ConfigurationUtils.updateChatRoomStatus(\r\n                chatRoomWrapper.getParentProvider().getProtocolProvider(),\r\n                chatRoomWrapper.getChatRoomID(),\r\n                GlobalStatusEnum.ONLINE_STATUS);\r\n\r\n            String errorMessage = null;\r\n            if(AUTHENTICATION_FAILED.equals(returnCode))\r\n            {\r\n                chatRoomWrapper.removePassword();\r\n\r\n                AuthenticationWindowService authWindowsService\r\n                    = ServiceUtils.getService(\r\n                        MUCActivator.bundleContext,\r\n                        AuthenticationWindowService.class);\r\n\r\n                AuthenticationWindowService.AuthenticationWindow authWindow =\r\n                    authWindowsService.create(\r\n                        null, null, null, false,\r\n                        chatRoomWrapper.isPersistent(),\r\n                        ImageLoader.getAuthenticationWindowIcon(\r\n                            chatRoomWrapper.getParentProvider()\r\n                                .getProtocolProvider()),\r\n                        resources.getI18NString(\r\n                            \"service.gui.AUTHENTICATION_WINDOW_TITLE\",\r\n                            new String[]{chatRoomWrapper.getParentProvider()\r\n                                            .getName()}),\r\n                        resources.getI18NString(\r\n                                \"service.gui.CHAT_ROOM_REQUIRES_PASSWORD\",\r\n                                new String[]{\r\n                                        chatRoomWrapper.getChatRoomName()}),\r\n                        \"\", null,\r\n                        isFirstAttempt ?\r\n                            null :\r\n                        resources.getI18NString(\r\n                                \"service.gui.AUTHENTICATION_FAILED\",\r\n                                new String[]{chatRoomWrapper.getChatRoomName()}),\r\n                        null);\r\n\r\n                authWindow.setVisible(true);\r\n\r\n                if (!authWindow.isCanceled())\r\n                {\r\n                    joinChatRoom(\r\n                            chatRoomWrapper,\r\n                            nickName,\r\n                            new String(authWindow.getPassword()).getBytes(),\r\n                            authWindow.isRememberPassword(),\r\n                            false,\r\n                            subject);\r\n                }\r\n            }\r\n            else if(REGISTRATION_REQUIRED.equals(returnCode))\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\r\n                            \"service.gui.CHAT_ROOM_REGISTRATION_REQUIRED\",\r\n                            new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n            else if(PROVIDER_NOT_REGISTERED.equals(returnCode))\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\"service.gui.CHAT_ROOM_NOT_CONNECTED\",\r\n                        new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n            else if(SUBSCRIPTION_ALREADY_EXISTS.equals(returnCode))\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\"service.gui.CHAT_ROOM_ALREADY_JOINED\",\r\n                            new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n            else\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\"service.gui.FAILED_TO_JOIN_CHAT_ROOM\",\r\n                            new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n\r\n            if (!SUCCESS.equals(returnCode) && \r\n                !AUTHENTICATION_FAILED.equals(returnCode))\r\n            {\r\n                MUCActivator.getAlertUIService().showAlertDialog(\r\n                    resources.getI18NString(\"service.gui.ERROR\"), errorMessage);\r\n            }\r\n\r\n            if (SUCCESS.equals(returnCode))\r\n            {\r\n                if(rememberPassword)\r\n                {\r\n                    chatRoomWrapper.savePassword(new String(password));\r\n                }\r\n                \r\n                if(subject != null)\r\n                {\r\n                    try\r\n                    {\r\n                        chatRoomWrapper.getChatRoom().setSubject(subject);\r\n                    }\r\n                    catch(OperationFailedException ex)\r\n                    {\r\n                        logger.warn(\"Failed to set subject.\");\r\n                    }\r\n                }\r\n            }\r\n        }","id":38299,"modified_method":"/**\r\n         * Performs UI changes after the chat room join task has finished.\r\n         * @param returnCode the result code from the chat room join task.\r\n         */\r\n        private void done(String returnCode)\r\n        {\r\n\r\n            ConfigurationUtils.updateChatRoomStatus(\r\n                chatRoomWrapper.getParentProvider().getProtocolProvider(),\r\n                chatRoomWrapper.getChatRoomID(),\r\n                GlobalStatusEnum.ONLINE_STATUS);\r\n\r\n            String errorMessage = null;\r\n            if(AUTHENTICATION_FAILED.equals(returnCode))\r\n            {\r\n                chatRoomWrapper.removePassword();\r\n\r\n                AuthenticationWindowService authWindowsService\r\n                    = ServiceUtils.getService(\r\n                        MUCActivator.bundleContext,\r\n                        AuthenticationWindowService.class);\r\n\r\n                AuthenticationWindowService.AuthenticationWindow authWindow =\r\n                    authWindowsService.create(\r\n                        null, null, null, false,\r\n                        chatRoomWrapper.isPersistent(),\r\n                        ImageLoader.getAuthenticationWindowIcon(\r\n                            chatRoomWrapper.getParentProvider()\r\n                                .getProtocolProvider()),\r\n                        resources.getI18NString(\r\n                            \"service.gui.AUTHENTICATION_WINDOW_TITLE\",\r\n                            new String[]{chatRoomWrapper.getParentProvider()\r\n                                            .getName()}),\r\n                        resources.getI18NString(\r\n                                \"service.gui.CHAT_ROOM_REQUIRES_PASSWORD\",\r\n                                new String[]{\r\n                                        chatRoomWrapper.getChatRoomName()}),\r\n                        \"\", null,\r\n                        isFirstAttempt ?\r\n                            null :\r\n                        resources.getI18NString(\r\n                                \"service.gui.AUTHENTICATION_FAILED\",\r\n                                new String[]{chatRoomWrapper.getChatRoomName()}),\r\n                        null);\r\n\r\n                authWindow.setVisible(true);\r\n\r\n                if (!authWindow.isCanceled())\r\n                {\r\n                    joinChatRoom(\r\n                            chatRoomWrapper,\r\n                            nickName,\r\n                            new String(authWindow.getPassword()).getBytes(),\r\n                            authWindow.isRememberPassword(),\r\n                            false,\r\n                            subject);\r\n                }\r\n            }\r\n            else if(REGISTRATION_REQUIRED.equals(returnCode))\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\r\n                            \"service.gui.CHAT_ROOM_REGISTRATION_REQUIRED\",\r\n                            new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n            else if(PROVIDER_NOT_REGISTERED.equals(returnCode))\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\"service.gui.CHAT_ROOM_NOT_CONNECTED\",\r\n                        new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n            else if(SUBSCRIPTION_ALREADY_EXISTS.equals(returnCode))\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\"service.gui.CHAT_ROOM_ALREADY_JOINED\",\r\n                            new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n            else\r\n            {\r\n                errorMessage\r\n                    = resources\r\n                        .getI18NString(\"service.gui.FAILED_TO_JOIN_CHAT_ROOM\",\r\n                            new String[]{chatRoomWrapper.getChatRoomName()});\r\n            }\r\n\r\n            if (!SUCCESS.equals(returnCode) && \r\n                !AUTHENTICATION_FAILED.equals(returnCode))\r\n            {\r\n                MUCActivator.getAlertUIService().showAlertDialog(\r\n                    resources.getI18NString(\"service.gui.ERROR\"), errorMessage);\r\n            }\r\n\r\n            if (SUCCESS.equals(returnCode))\r\n            {\r\n                if(rememberPassword)\r\n                {\r\n                    chatRoomWrapper.savePassword(new String(password));\r\n                }\r\n                \r\n                if(subject != null)\r\n                {\r\n                    try\r\n                    {\r\n                        chatRoomWrapper.getChatRoom().setSubject(subject);\r\n                    }\r\n                    catch(OperationFailedException ex)\r\n                    {\r\n                        logger.warn(\"Failed to set subject.\");\r\n                    }\r\n                }\r\n            }\r\n        }","commit_id":"1f990a0d5c1a4689d45965d9d05f6616d0dbd3c8","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void injectMessage(SessionID sessionID, String messageText)\r\n        {\r\n            Contact contact = getContact(sessionID);\r\n            OperationSetBasicInstantMessaging imOpSet =\r\n                (OperationSetBasicInstantMessaging) contact\r\n                    .getProtocolProvider().getOperationSet(\r\n                        OperationSetBasicInstantMessaging.class);\r\n\r\n            Message message = imOpSet.createMessage(messageText);\r\n            injectedMessageUIDs.add(message.getMessageUID());\r\n            imOpSet.sendInstantMessage(contact, message);\r\n        }","id":38300,"modified_method":"public void injectMessage(SessionID sessionID, String messageText)\r\n        {\r\n            Contact contact = getContact(sessionID);\r\n            OperationSetBasicInstantMessaging imOpSet\r\n                = contact\r\n                    .getProtocolProvider()\r\n                        .getOperationSet(OperationSetBasicInstantMessaging.class);\r\n            Message message = imOpSet.createMessage(messageText);\r\n\r\n            injectedMessageUIDs.add(message.getMessageUID());\r\n            imOpSet.sendInstantMessage(contact, message);\r\n        }","commit_id":"2f8b4304f21676487399641eccc8c18db2f5824c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the protocol icon. If an icon 32x32 is available, returns it,\n     * otherwise tries to scale a bigger icon if available. If we didn't find\n     * a bigger icon to scale, we return null.\n     *\n     * @return the protocol icon\n     */\n    private ImageIcon getProtocolIcon()\n    {\n        Image protocolImage =\n            ImageLoader.getBytesInImage(protocolProvider.getProtocolIcon()\n                .getIcon(ProtocolIcon.ICON_SIZE_32x32));\n\n        if (protocolImage != null)\n        {\n            return new ImageIcon(protocolImage);\n        }\n        else\n        {\n            protocolImage =\n                ImageLoader.getBytesInImage(protocolProvider.getProtocolIcon()\n                    .getIcon(ProtocolIcon.ICON_SIZE_48x48));\n\n            if (protocolImage != null)\n            {\n                return ImageUtils.scaleIconWithinBounds(\n                    protocolImage, 32, 32);\n            }\n            else\n            {\n                protocolImage =\n                    ImageLoader.getBytesInImage(\n                        protocolProvider.getProtocolIcon()\n                            .getIcon(ProtocolIcon.ICON_SIZE_64x64));\n\n                if (protocolImage != null)\n                {\n                    return ImageUtils.scaleIconWithinBounds(\n                        protocolImage, 32, 32);\n                }\n            }\n        }\n\n        return null;\n    }","id":38301,"modified_method":"/**\n     * Returns the protocol icon. If an icon 32x32 is available, returns it,\n     * otherwise tries to scale a bigger icon if available. If we didn't find\n     * a bigger icon to scale, we return null.\n     *\n     * @return the protocol icon\n     */\n    private ImageIcon getProtocolIcon()\n    {\n        ProtocolIcon protocolIcon = protocolProvider.getProtocolIcon();\n        Image protocolImage\n            = ImageLoader\n                .getBytesInImage(\n                    protocolIcon.getIcon(ProtocolIcon.ICON_SIZE_32x32));\n\n        if (protocolImage != null)\n        {\n            return new ImageIcon(protocolImage);\n        }\n        else\n        {\n            protocolImage\n                = ImageLoader\n                    .getBytesInImage(\n                        protocolIcon.getIcon(ProtocolIcon.ICON_SIZE_48x48));\n            if (protocolImage == null)\n                protocolImage\n                    = ImageLoader\n                        .getBytesInImage(\n                            protocolIcon.getIcon(ProtocolIcon.ICON_SIZE_64x64));\n\n            if (protocolImage != null)\n                return ImageUtils.scaleIconWithinBounds(protocolImage, 32, 32);\n        }\n\n        return null;\n    }","commit_id":"e559b4192a613a2943bffdc4be32b2122d4e5766","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the current presence status of the given protocol provider.\n     * \n     * @param protocolProvider the protocol provider which status we're looking\n     * for.\n     * @return the current presence status of the given protocol provider.\n     */\n    private String getAccountStatus(ProtocolProviderService protocolProvider)\n    {\n        String status;\n\n        OperationSetPresence presence\n            = (OperationSetPresence) protocolProvider\n                .getOperationSet(OperationSetPresence.class);\n\n        if (presence != null)\n        {\n            status = presence.getPresenceStatus().getStatusName();\n        }\n        else\n        {\n            if (protocolProvider.isRegistered())\n            {\n                status = GuiActivator.getResources()\n                    .getI18NString(\"service.gui.ONLINE\");\n            }\n            else\n            {\n                status = GuiActivator.getResources()\n                    .getI18NString(\"service.gui.OFFLINE\");\n            }\n        }\n\n        return status;\n    }","id":38302,"modified_method":"/**\n     * Returns the current presence status of the given protocol provider.\n     * \n     * @param protocolProvider the protocol provider which status we're looking\n     * for.\n     * @return the current presence status of the given protocol provider.\n     */\n    private String getAccountStatus(ProtocolProviderService protocolProvider)\n    {\n        String status;\n\n        OperationSetPresence presence\n            = protocolProvider.getOperationSet(OperationSetPresence.class);\n\n        if (presence != null)\n        {\n            status = presence.getPresenceStatus().getStatusName();\n        }\n        else\n        {\n            status\n                = GuiActivator\n                    .getResources()\n                        .getI18NString(\n                            protocolProvider.isRegistered()\n                                ? \"service.gui.ONLINE\"\n                                : \"service.gui.OFFLINE\");\n        }\n\n        return status;\n    }","commit_id":"e559b4192a613a2943bffdc4be32b2122d4e5766","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>ServiceListener<\/tt> method. Verifies whether the\n     * passed event concerns a <tt>ProtocolProviderService<\/tt> and adds the\n     * corresponding UI controls.\n     *\n     * @param event The <tt>ServiceEvent<\/tt> object.\n     */\n    public void serviceChanged(ServiceEvent event)\n    {\n        // if the event is caused by a bundle being stopped, we don't want to\n        // know\n        if (event.getServiceReference().getBundle().getState()\n                == Bundle.STOPPING)\n        {\n            return;\n        }\n        Object sourceService =\n            GuiActivator.bundleContext.getService(event.getServiceReference());\n\n        // we don't care if the source service is not a protocol provider\n        if (!(sourceService instanceof ProtocolProviderService))\n        {\n            return;\n        }\n\n        ProtocolProviderService protocolProvider\n            = (ProtocolProviderService) sourceService;\n\n        // If the protocol provider is hidden we don't want to show it in the\n        // list.\n        boolean isHidden\n            = (protocolProvider.getAccountID().getAccountProperty\n                (ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null);\n\n        if (isHidden)\n            return;\n\n        // Add or remove the protocol provider from our accounts list.\n        if (event.getType() == ServiceEvent.REGISTERED)\n        {\n            // Add a presence listener in order to listen for any status\n            // changes.\n            OperationSetPresence presence\n                = protocolProvider\n                    .getOperationSet(OperationSetPresence.class);\n\n            if (presence != null)\n            {\n                presence.addProviderPresenceStatusListener(this);\n            }\n\n            accountListModel.addElement(new Account(protocolProvider));\n        }\n        else if (event.getType() == ServiceEvent.UNREGISTERING)\n        {\n            Object[] accountListModelElements = accountListModel.toArray();\n\n            for (Object accountListModelElement : accountListModelElements)\n            {\n                Account account = (Account) accountListModelElement;\n\n                if (account.getProtocolProvider().equals(protocolProvider))\n                    accountListModel.removeElement(account);\n            }\n        }\n    }","id":38303,"modified_method":"/**\n     * Implements the <tt>ServiceListener<\/tt> method. Verifies whether the\n     * passed event concerns a <tt>ProtocolProviderService<\/tt> and adds the\n     * corresponding UI controls.\n     *\n     * @param event The <tt>ServiceEvent<\/tt> object.\n     */\n    public void serviceChanged(ServiceEvent event)\n    {\n        // if the event is caused by a bundle being stopped, we don't want to\n        // know\n        if (event.getServiceReference().getBundle().getState()\n                == Bundle.STOPPING)\n        {\n            return;\n        }\n        Object sourceService =\n            GuiActivator.bundleContext.getService(event.getServiceReference());\n\n        // we don't care if the source service is not a protocol provider\n        if (!(sourceService instanceof ProtocolProviderService))\n        {\n            return;\n        }\n\n        ProtocolProviderService protocolProvider\n            = (ProtocolProviderService) sourceService;\n\n        // If the protocol provider is hidden we don't want to show it in the\n        // list.\n        boolean isHidden\n            = (protocolProvider.getAccountID().getAccountProperty\n                (ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null);\n\n        if (isHidden)\n            return;\n\n        // Add or remove the protocol provider from our accounts list.\n        if (event.getType() == ServiceEvent.REGISTERED)\n        {\n            // Add a presence listener in order to listen for any status\n            // changes.\n            OperationSetPresence presence\n                = protocolProvider\n                    .getOperationSet(OperationSetPresence.class);\n\n            if (presence != null)\n            {\n                presence.addProviderPresenceStatusListener(this);\n            }\n\n            accountListModel.addElement(new Account(protocolProvider));\n        }\n        else if (event.getType() == ServiceEvent.UNREGISTERING)\n        {\n            for (Object accountListModelElement : accountListModel.toArray())\n            {\n                Account account = (Account) accountListModelElement;\n\n                if (account.getProtocolProvider().equals(protocolProvider))\n                    accountListModel.removeElement(account);\n            }\n        }\n    }","commit_id":"e559b4192a613a2943bffdc4be32b2122d4e5766","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Handles the <tt>ActionEvent<\/tt> triggered when user clicks on on the\r\n     * buttons. Shows the account registration wizard when user clicks on \"New\".\r\n     *\r\n     * @param evt the action event that has just occurred.\r\n     */\r\n    public void actionPerformed(ActionEvent evt)\r\n    {\r\n        JButton sourceButton = (JButton) evt.getSource();\r\n\r\n        if (sourceButton.equals(newButton))\r\n        {\r\n            NewAccountDialog.showNewAccountDialog();\r\n        }\r\n        else if (sourceButton.equals(removeButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            ProtocolProviderService protocolProvider\r\n                = account.getProtocolProvider();\r\n\r\n            ProtocolProviderFactory providerFactory =\r\n                GuiActivator.getProtocolProviderFactory(protocolProvider);\r\n\r\n            if (providerFactory != null)\r\n            {\r\n                int result =\r\n                    JOptionPane.showConfirmDialog(this, GuiActivator\r\n                        .getResources().getI18NString(\r\n                            \"service.gui.REMOVE_ACCOUNT_MESSAGE\"),\r\n                        GuiActivator.getResources().getI18NString(\r\n                            \"service.gui.REMOVE_ACCOUNT\"),\r\n                        JOptionPane.YES_NO_OPTION);\r\n\r\n                if (result == JOptionPane.YES_OPTION)\r\n                {\r\n                    ConfigurationService configService =\r\n                        GuiActivator.getConfigurationService();\r\n\r\n                    String prefix =\r\n                        \"net.java.sip.communicator.impl.gui.accounts\";\r\n\r\n                    List<String> accounts =\r\n                        configService\r\n                            .getPropertyNamesByPrefix(prefix, true);\r\n\r\n                    for (String accountRootPropName : accounts)\r\n                    {\r\n                        String accountUID =\r\n                            configService.getString(accountRootPropName);\r\n\r\n                        if (accountUID.equals(protocolProvider\r\n                            .getAccountID().getAccountUniqueID()))\r\n                        {\r\n                            configService.setProperty(accountRootPropName,\r\n                                null);\r\n                            break;\r\n                        }\r\n                    }\r\n                    providerFactory.uninstallAccount(protocolProvider\r\n                        .getAccountID());\r\n                }\r\n            }\r\n        }\r\n        else if (sourceButton.equals(editButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            AccountRegWizardContainerImpl wizard =\r\n                (AccountRegWizardContainerImpl) GuiActivator.getUIService()\r\n                    .getAccountRegWizardContainer();\r\n\r\n            wizard.setTitle(GuiActivator.getResources().getI18NString(\r\n                \"service.gui.ACCOUNT_REGISTRATION_WIZARD\"));\r\n\r\n            wizard.modifyAccount(account.getProtocolProvider());\r\n            wizard.showDialog(false);\r\n        }\r\n    }","id":38304,"modified_method":"/**\r\n     * Handles the <tt>ActionEvent<\/tt> triggered when user clicks on on the\r\n     * buttons. Shows the account registration wizard when user clicks on \"New\".\r\n     *\r\n     * @param evt the action event that has just occurred.\r\n     */\r\n    public void actionPerformed(ActionEvent evt)\r\n    {\r\n        Object sourceButton = evt.getSource();\r\n\r\n        if (sourceButton.equals(newButton))\r\n        {\r\n            NewAccountDialog.showNewAccountDialog();\r\n        }\r\n        else if (sourceButton.equals(removeButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            if (account == null)\r\n                return;\r\n\r\n            ProtocolProviderService protocolProvider\r\n                = account.getProtocolProvider();\r\n            ProtocolProviderFactory providerFactory =\r\n                GuiActivator.getProtocolProviderFactory(protocolProvider);\r\n\r\n            if (providerFactory != null)\r\n            {\r\n                int result\r\n                    = JOptionPane\r\n                        .showConfirmDialog(\r\n                            this,\r\n                            GuiActivator\r\n                                .getResources()\r\n                                    .getI18NString(\r\n                                        \"service.gui.REMOVE_ACCOUNT_MESSAGE\"),\r\n                        GuiActivator.getResources().getI18NString(\r\n                            \"service.gui.REMOVE_ACCOUNT\"),\r\n                        JOptionPane.YES_NO_OPTION);\r\n\r\n                if (result == JOptionPane.YES_OPTION)\r\n                {\r\n                    ConfigurationService configService\r\n                        = GuiActivator.getConfigurationService();\r\n                    String prefix\r\n                        = \"net.java.sip.communicator.impl.gui.accounts\";\r\n                    List<String> accounts\r\n                        = configService.getPropertyNamesByPrefix(prefix, true);\r\n\r\n                    for (String accountRootPropName : accounts)\r\n                    {\r\n                        String accountUID\r\n                            = configService.getString(accountRootPropName);\r\n\r\n                        if (accountUID.equals(protocolProvider\r\n                            .getAccountID().getAccountUniqueID()))\r\n                        {\r\n                            configService.setProperty(accountRootPropName, null);\r\n                            break;\r\n                        }\r\n                    }\r\n                    providerFactory.uninstallAccount(protocolProvider.getAccountID());\r\n                }\r\n            }\r\n        }\r\n        else if (sourceButton.equals(editButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            if (account == null)\r\n                return;\r\n\r\n            AccountRegWizardContainerImpl wizard =\r\n                (AccountRegWizardContainerImpl) GuiActivator.getUIService()\r\n                    .getAccountRegWizardContainer();\r\n\r\n            wizard.setTitle(GuiActivator.getResources().getI18NString(\r\n                \"service.gui.ACCOUNT_REGISTRATION_WIZARD\"));\r\n\r\n            wizard.modifyAccount(account.getProtocolProvider());\r\n            wizard.showDialog(false);\r\n        }\r\n    }","commit_id":"e559b4192a613a2943bffdc4be32b2122d4e5766","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Creates and initializes this account configuration panel.\r\n     */\r\n    public AccountsConfigurationPanel()\r\n    {\r\n        super(new BorderLayout());\r\n\r\n        accountList = new AccountList(this);\r\n\r\n        this.setPreferredSize(new Dimension(500, 400));\r\n\r\n        JScrollPane accountListPane = new JScrollPane();\r\n\r\n        accountListPane.getViewport().add(accountList);\r\n        accountListPane.getVerticalScrollBar().setUnitIncrement(30);\r\n\r\n        this.add(accountListPane, BorderLayout.CENTER);\r\n\r\n        JPanel buttonsPanel =\r\n            new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));\r\n\r\n        newButton.addActionListener(this);\r\n        editButton.addActionListener(this);\r\n        removeButton.addActionListener(this);\r\n\r\n        this.newButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(\r\n                \"service.gui.ADD\"));\r\n        this.editButton\r\n            .setMnemonic(GuiActivator.getResources().getI18nMnemonic(\r\n                \"service.gui.EDIT\"));\r\n        this.removeButton\r\n            .setMnemonic(GuiActivator.getResources().getI18nMnemonic(\r\n                \"service.gui.DELETE\"));\r\n\r\n        buttonsPanel.add(newButton);\r\n        buttonsPanel.add(editButton);\r\n        buttonsPanel.add(removeButton);\r\n\r\n        this.add(buttonsPanel, BorderLayout.SOUTH);\r\n    }","id":38305,"modified_method":"/**\r\n     * Creates and initializes this account configuration panel.\r\n     */\r\n    public AccountsConfigurationPanel()\r\n    {\r\n        super(new BorderLayout());\r\n\r\n        accountList = new AccountList(this);\r\n\r\n        /*\r\n         * It seems that we can only delete one account at a time because our\r\n         * confirmation dialog asks for one account.\r\n         */\r\n        accountList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\r\n\r\n        this.setPreferredSize(new Dimension(500, 400));\r\n\r\n        JScrollPane accountListPane = new JScrollPane();\r\n\r\n        accountListPane.getViewport().add(accountList);\r\n        accountListPane.getVerticalScrollBar().setUnitIncrement(30);\r\n\r\n        this.add(accountListPane, BorderLayout.CENTER);\r\n\r\n        JPanel buttonsPanel =\r\n            new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));\r\n\r\n        newButton.addActionListener(this);\r\n        editButton.addActionListener(this);\r\n        removeButton.addActionListener(this);\r\n\r\n        this.newButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(\r\n                \"service.gui.ADD\"));\r\n        this.editButton\r\n            .setMnemonic(GuiActivator.getResources().getI18nMnemonic(\r\n                \"service.gui.EDIT\"));\r\n        this.removeButton\r\n            .setMnemonic(GuiActivator.getResources().getI18nMnemonic(\r\n                \"service.gui.DELETE\"));\r\n\r\n        buttonsPanel.add(newButton);\r\n        buttonsPanel.add(editButton);\r\n        buttonsPanel.add(removeButton);\r\n\r\n        this.add(buttonsPanel, BorderLayout.SOUTH);\r\n\r\n        accountList.addListSelectionListener(this);\r\n        updateButtons();\r\n    }","commit_id":"e559b4192a613a2943bffdc4be32b2122d4e5766","url":"https://github.com/jitsi/jitsi"},{"original_method":"public synchronized void remove(PersistentBlobTempBucket bucket, ObjectContainer container) {\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" from database\", new Exception(\"debug\"));\n\t\tlong index = bucket.index;\n\t\tPersistentBlobTempBucketTag tag = bucket.tag;\n\t\tcontainer.activate(tag, 1);\n\t\tif(!bucket.persisted()) {\n\t\t\tmaybeShrink(container);\n\t\t\treturn;\n\t\t}\n\t\tif(!bucket.freed()) {\n\t\t\tLogger.error(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" but not freed!\", new Exception(\"debug\"));\n\t\t\tnotCommittedBlobs.put(index, bucket);\n\t\t} else {\n\t\t\tfreeSlots.put(index, tag);\n\t\t}\n\t\ttag.bucket = null;\n\t\ttag.isFree = true;\n\t\tcontainer.store(tag);\n\t\tcontainer.delete(bucket);\n\t\tbucket.onRemove();\n\t\t\n\t\tmaybeShrink(container);\n\t}","id":38306,"modified_method":"public synchronized void remove(PersistentBlobTempBucket bucket, ObjectContainer container) {\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" from database\", new Exception(\"debug\"));\n\t\tlong index = bucket.index;\n\t\tPersistentBlobTempBucketTag tag = bucket.tag;\n\t\tcontainer.activate(tag, 1);\n\t\tif(!bucket.persisted()) {\n\t\t\tmaybeShrink(container);\n\t\t\treturn;\n\t\t}\n\t\tif(!bucket.freed()) {\n\t\t\tLogger.error(this, \"Removing bucket \"+bucket+\" for slot \"+bucket.index+\" but not freed!\", new Exception(\"debug\"));\n\t\t\tnotCommittedBlobs.put(index, bucket);\n\t\t} else {\n\t\t\talmostFreeSlots.put(index, tag);\n\t\t}\n\t\ttag.bucket = null;\n\t\ttag.isFree = true;\n\t\tcontainer.store(tag);\n\t\tcontainer.delete(bucket);\n\t\tbucket.onRemove();\n\t\t\n\t\tmaybeShrink(container);\n\t}","commit_id":"935027a44d701beb6ba8ecf27dbc6053e5a812e6","url":"https://github.com/freenet/fred"},{"original_method":"void onInit(ObjectContainer container, DBJobRunner jobRunner2, Random fastWeakRandom, File storageFile2, long blockSize2, Ticker ticker) throws IOException {\n\t\tcontainer.activate(storageFile, 100);\n\t\tif(storageFile2.getPath().equals(storageFile.getPath())) {\n\t\t\tif(blockSize != blockSize2)\n\t\t\t\tthrow new IllegalStateException(\"My block size is \"+blockSize2+\n\t\t\t\t\t\t\" but stored block size is \"+blockSize+\n\t\t\t\t\t\t\" for same file \"+storageFile);\n\t\t} else {\n\t\t\tif(!FileUtil.moveTo(storageFile, storageFile2, false))\n\t\t\t\tthrow new IOException(\"Unable to move temp blob file from \"+storageFile+\" to \"+storageFile2);\n\t\t}\n\t\traf = new RandomAccessFile(storageFile, \"rw\");\n\t\tchannel = raf.getChannel();\n\t\tnotCommittedBlobs = new TreeMap<Long,PersistentBlobTempBucket>();\n\t\tfreeSlots = new TreeMap<Long,PersistentBlobTempBucketTag>();\n\t\tjobRunner = jobRunner2;\n\t\tweakRandomSource = fastWeakRandom;\n\t\tthis.ticker = ticker;\n\t}","id":38307,"modified_method":"void onInit(ObjectContainer container, DBJobRunner jobRunner2, Random fastWeakRandom, File storageFile2, long blockSize2, Ticker ticker) throws IOException {\n\t\tcontainer.activate(storageFile, 100);\n\t\tif(storageFile2.getPath().equals(storageFile.getPath())) {\n\t\t\tif(blockSize != blockSize2)\n\t\t\t\tthrow new IllegalStateException(\"My block size is \"+blockSize2+\n\t\t\t\t\t\t\" but stored block size is \"+blockSize+\n\t\t\t\t\t\t\" for same file \"+storageFile);\n\t\t} else {\n\t\t\tif(!FileUtil.moveTo(storageFile, storageFile2, false))\n\t\t\t\tthrow new IOException(\"Unable to move temp blob file from \"+storageFile+\" to \"+storageFile2);\n\t\t}\n\t\traf = new RandomAccessFile(storageFile, \"rw\");\n\t\tchannel = raf.getChannel();\n\t\tnotCommittedBlobs = new TreeMap<Long,PersistentBlobTempBucket>();\n\t\tfreeSlots = new TreeMap<Long,PersistentBlobTempBucketTag>();\n\t\talmostFreeSlots = new TreeMap<Long,PersistentBlobTempBucketTag>();\n\t\tjobRunner = jobRunner2;\n\t\tweakRandomSource = fastWeakRandom;\n\t\tthis.ticker = ticker;\n\t}","commit_id":"935027a44d701beb6ba8ecf27dbc6053e5a812e6","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * @return A bucket, or null in various failure cases.\n\t */\n\tpublic PersistentBlobTempBucket makeBucket() {\n\t\t// Find a free slot.\n\t\tsynchronized(this) {\n\t\t\tif(!freeSlots.isEmpty()) {\n\t\t\t\tLong slot = freeSlots.firstKey();\n\t\t\t\tPersistentBlobTempBucketTag tag = freeSlots.remove(slot);\n\t\t\t\tif(notCommittedBlobs.get(slot) != null) {\n\t\t\t\t\tLogger.error(this, \"Slot \"+slot+\" already occupied by a not committed blob despite being in freeSlots!!\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPersistentBlobTempBucket bucket = new PersistentBlobTempBucket(this, blockSize, slot, tag);\n\t\t\t\tnotCommittedBlobs.put(slot, bucket);\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Using slot \"+slot+\" for \"+bucket);\n\t\t\t\treturn bucket;\n\t\t\t}\n\t\t}\n\t\tjobRunner.runBlocking(slotFinder, NativeThread.HIGH_PRIORITY);\n\t\tsynchronized(this) {\n\t\t\tif(!freeSlots.isEmpty()) {\n\t\t\t\tLong slot = freeSlots.firstKey();\n\t\t\t\tPersistentBlobTempBucketTag tag = freeSlots.remove(slot);\n\t\t\t\tif(notCommittedBlobs.get(slot) != null) {\n\t\t\t\t\tLogger.error(this, \"Slot \"+slot+\" already occupied by a not committed blob despite being in freeSlots!!\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPersistentBlobTempBucket bucket = new PersistentBlobTempBucket(this, blockSize, slot, tag);\n\t\t\t\tnotCommittedBlobs.put(slot, bucket);\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Using slot \"+slot+\" for \"+bucket+\" (after waiting)\");\n\t\t\t\treturn bucket;\n\t\t\t}\n\t\t}\n\t\tLogger.error(this, \"Returning null, unable to create a bucket for some reason, node will fallback to file-based buckets\");\n\t\treturn null;\n\t}","id":38308,"modified_method":"/**\n\t * @return A bucket, or null in various failure cases.\n\t */\n\tpublic PersistentBlobTempBucket makeBucket() {\n\t\t// Find a free slot.\n\t\tsynchronized(this) {\n\t\t\tif(!freeSlots.isEmpty()) {\n\t\t\t\tLong slot = freeSlots.firstKey();\n\t\t\t\tPersistentBlobTempBucketTag tag = freeSlots.remove(slot);\n\t\t\t\tif(notCommittedBlobs.get(slot) != null || almostFreeSlots.get(slot) != null) {\n\t\t\t\t\tLogger.error(this, \"Slot \"+slot+\" already occupied by a not committed blob despite being in freeSlots!!\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPersistentBlobTempBucket bucket = new PersistentBlobTempBucket(this, blockSize, slot, tag);\n\t\t\t\tnotCommittedBlobs.put(slot, bucket);\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Using slot \"+slot+\" for \"+bucket);\n\t\t\t\treturn bucket;\n\t\t\t}\n\t\t}\n\t\tjobRunner.runBlocking(slotFinder, NativeThread.HIGH_PRIORITY);\n\t\tsynchronized(this) {\n\t\t\tif(!freeSlots.isEmpty()) {\n\t\t\t\tLong slot = freeSlots.firstKey();\n\t\t\t\tPersistentBlobTempBucketTag tag = freeSlots.remove(slot);\n\t\t\t\tif(notCommittedBlobs.get(slot) != null || almostFreeSlots.get(slot) != null) {\n\t\t\t\t\tLogger.error(this, \"Slot \"+slot+\" already occupied by a not committed blob despite being in freeSlots!!\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPersistentBlobTempBucket bucket = new PersistentBlobTempBucket(this, blockSize, slot, tag);\n\t\t\t\tnotCommittedBlobs.put(slot, bucket);\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Using slot \"+slot+\" for \"+bucket+\" (after waiting)\");\n\t\t\t\treturn bucket;\n\t\t\t}\n\t\t}\n\t\tLogger.error(this, \"Returning null, unable to create a bucket for some reason, node will fallback to file-based buckets\");\n\t\treturn null;\n\t}","commit_id":"935027a44d701beb6ba8ecf27dbc6053e5a812e6","url":"https://github.com/freenet/fred"},{"original_method":"void maybeShrink(ObjectContainer container) {\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"maybeShrink()\");\n\t\tlong now = System.currentTimeMillis();\n\t\t\n\t\tlong newBlocks;\n\t\t\n\t\tsynchronized(this) {\n\t\t\n\t\tif(now - lastCheckedEnd > 60*1000) {\n\t\t\tif(logMINOR) Logger.minor(this, \"maybeShrink() inner\");\n\t\t\t// Check whether there is a big white space at the end of the file.\n\t\t\tlong size;\n\t\t\ttry {\n\t\t\t\tsize = channel.size();\n\t\t\t} catch (IOException e1) {\n\t\t\t\tLogger.error(this, \"Unable to find size of temp blob storage file: \"+e1, e1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsize -= size % blockSize;\n\t\t\tlong blocks = (size / blockSize) - 1;\n\t\t\tif(blocks <= 32) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not shrinking, blob file not larger than a megabyte\");\n\t\t\t\tlastCheckedEnd = now;\n\t\t\t\tqueueMaybeShrink();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlong lastNotCommitted = notCommittedBlobs.isEmpty() ? 0 : notCommittedBlobs.lastKey();\n\t\t\tdouble full = (double)lastNotCommitted / (double)blocks;\n\t\t\tif(full > 0.8) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not shrinking, last not committed block is at \"+full*100+\"% (\"+lastNotCommitted+\" of \"+blocks+\")\");\n\t\t\t\tlastCheckedEnd = now;\n\t\t\t\tqueueMaybeShrink();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tQuery query = container.query();\n\t\t\tquery.constrain(PersistentBlobTempBucketTag.class);\n\t\t\tquery.descend(\"isFree\").constrain(false);\n\t\t\tquery.descend(\"index\").orderDescending();\n\t\t\tObjectSet<PersistentBlobTempBucketTag> tags = query.execute();\n\t\t\tlong lastCommitted;\n\t\t\tif(tags.isEmpty()) {\n\t\t\t\t// No used slots at all?!\n\t\t\t\t// There may be some not committed though\n\t\t\t\tLogger.normal(this, \"No used slots in persistent temp file (but last not committed = \"+lastNotCommitted+\")\");\n\t\t\t\tlastCommitted = 0;\n\t\t\t} else {\n\t\t\t\tlastCommitted = tags.next().index;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Last committed slot is \"+lastCommitted+\" last not committed is \"+lastNotCommitted);\n\t\t\t}\n\t\t\tfull = (double) lastCommitted / (double) blocks;\n\t\t\tif(full > 0.8) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not shrinking, last committed block is at \"+full*100+\"%\");\n\t\t\t\tlastCheckedEnd = now;\n\t\t\t\tqueueMaybeShrink();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlong lastBlock = Math.max(lastCommitted, lastNotCommitted);\n\t\t\t// Must be 10% free at end\n\t\t\tnewBlocks = (long) ((lastBlock + 32) * (1.0 / 1.1));\n\t\t\tnewBlocks = Math.max(newBlocks, 32);\n\t\t\tSystem.err.println(\"Shrinking blob file from \"+blocks+\" to \"+newBlocks);\n\t\t\tfor(long l = newBlocks; l <= blocks; l++) {\n\t\t\t\tfreeSlots.remove(l);\n\t\t\t}\n\t\t\tfor(Long l : freeSlots.keySet()) {\n\t\t\t\tif(l > newBlocks) {\n\t\t\t\t\tLogger.error(this, \"Removing free slot \"+l+\" over the current block limit\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastCheckedEnd = now;\n\t\t\tqueueMaybeShrink();\n\t\t} else return;\n\t\t}\n\t\ttry {\n\t\t\tchannel.truncate(newBlocks * blockSize);\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Shrinking blob file failed!\");\n\t\t\tSystem.err.println(e);\n\t\t\te.printStackTrace();\n\t\t\tLogger.error(this, \"Shrinking blob file failed!: \"+e, e);\n\t\t}\n\t\tQuery query = container.query();\n\t\tquery.constrain(PersistentBlobTempBucketTag.class);\n\t\tquery.descend(\"index\").constrain(newBlocks).greater();\n\t\tObjectSet<PersistentBlobTempBucketTag> tags = query.execute();\n\t\twhile(tags.hasNext()) container.delete(tags.next());\n\t\t\n\t}","id":38309,"modified_method":"void maybeShrink(ObjectContainer container) {\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"maybeShrink()\");\n\t\tlong now = System.currentTimeMillis();\n\t\t\n\t\tlong newBlocks;\n\t\t\n\t\tsynchronized(this) {\n\t\t\n\t\tif(now - lastCheckedEnd > 60*1000) {\n\t\t\tif(logMINOR) Logger.minor(this, \"maybeShrink() inner\");\n\t\t\t// Check whether there is a big white space at the end of the file.\n\t\t\tlong size;\n\t\t\ttry {\n\t\t\t\tsize = channel.size();\n\t\t\t} catch (IOException e1) {\n\t\t\t\tLogger.error(this, \"Unable to find size of temp blob storage file: \"+e1, e1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsize -= size % blockSize;\n\t\t\tlong blocks = (size / blockSize) - 1;\n\t\t\tif(blocks <= 32) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not shrinking, blob file not larger than a megabyte\");\n\t\t\t\tlastCheckedEnd = now;\n\t\t\t\tqueueMaybeShrink();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlong lastNotCommitted = notCommittedBlobs.isEmpty() ? 0 : notCommittedBlobs.lastKey();\n\t\t\tlong lastAlmostFreed = almostFreeSlots.isEmpty() ? 0 : almostFreeSlots.lastKey();\n\t\t\tif(lastNotCommitted < lastAlmostFreed) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Last almost freed: \"+lastAlmostFreed+\" replacing last not committed: \"+lastNotCommitted);\n\t\t\t\tlastNotCommitted = lastAlmostFreed;\n\t\t\t}\n\t\t\tdouble full = (double)lastNotCommitted / (double)blocks;\n\t\t\tif(full > 0.8) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not shrinking, last not committed block is at \"+full*100+\"% (\"+lastNotCommitted+\" of \"+blocks+\")\");\n\t\t\t\tlastCheckedEnd = now;\n\t\t\t\tqueueMaybeShrink();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tQuery query = container.query();\n\t\t\tquery.constrain(PersistentBlobTempBucketTag.class);\n\t\t\tquery.descend(\"isFree\").constrain(false);\n\t\t\tquery.descend(\"index\").orderDescending();\n\t\t\tObjectSet<PersistentBlobTempBucketTag> tags = query.execute();\n\t\t\tlong lastCommitted;\n\t\t\tif(tags.isEmpty()) {\n\t\t\t\t// No used slots at all?!\n\t\t\t\t// There may be some not committed though\n\t\t\t\tLogger.normal(this, \"No used slots in persistent temp file (but last not committed = \"+lastNotCommitted+\")\");\n\t\t\t\tlastCommitted = 0;\n\t\t\t} else {\n\t\t\t\tlastCommitted = tags.next().index;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Last committed slot is \"+lastCommitted+\" last not committed is \"+lastNotCommitted);\n\t\t\t}\n\t\t\tfull = (double) lastCommitted / (double) blocks;\n\t\t\tif(full > 0.8) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not shrinking, last committed block is at \"+full*100+\"%\");\n\t\t\t\tlastCheckedEnd = now;\n\t\t\t\tqueueMaybeShrink();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlong lastBlock = Math.max(lastCommitted, lastNotCommitted);\n\t\t\t// Must be 10% free at end\n\t\t\tnewBlocks = (long) ((lastBlock + 32) * (1.0 / 1.1));\n\t\t\tnewBlocks = Math.max(newBlocks, 32);\n\t\t\tSystem.err.println(\"Shrinking blob file from \"+blocks+\" to \"+newBlocks);\n\t\t\tfor(long l = newBlocks; l <= blocks; l++) {\n\t\t\t\tfreeSlots.remove(l);\n\t\t\t}\n\t\t\tfor(Long l : freeSlots.keySet()) {\n\t\t\t\tif(l > newBlocks) {\n\t\t\t\t\tLogger.error(this, \"Removing free slot \"+l+\" over the current block limit\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastCheckedEnd = now;\n\t\t\tqueueMaybeShrink();\n\t\t} else return;\n\t\t}\n\t\ttry {\n\t\t\tchannel.truncate(newBlocks * blockSize);\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Shrinking blob file failed!\");\n\t\t\tSystem.err.println(e);\n\t\t\te.printStackTrace();\n\t\t\tLogger.error(this, \"Shrinking blob file failed!: \"+e, e);\n\t\t}\n\t\tQuery query = container.query();\n\t\tquery.constrain(PersistentBlobTempBucketTag.class);\n\t\tquery.descend(\"index\").constrain(newBlocks).greater();\n\t\tObjectSet<PersistentBlobTempBucketTag> tags = query.execute();\n\t\twhile(tags.hasNext()) container.delete(tags.next());\n\t\t\n\t}","commit_id":"935027a44d701beb6ba8ecf27dbc6053e5a812e6","url":"https://github.com/freenet/fred"},{"original_method":"public Bucket makeBucket(long size) throws IOException {\n\t\tBucket rawBucket = null;\n\t\tif(size == BLOB_SIZE) {\n\t\t\trawBucket = blobFactory.makeBucket();\n\t\t}\n\t\tif(rawBucket == null)\n\t\t\trawBucket = new PersistentTempFileBucket(fg.makeRandomFilename(), fg);\n\t\tBucket maybeEncryptedBucket = (encrypt ? new PaddedEphemerallyEncryptedBucket(rawBucket, 1024, strongPRNG, weakPRNG) : rawBucket);\n\t\treturn new DelayedFreeBucket(this, maybeEncryptedBucket);\n\t}","id":38310,"modified_method":"public Bucket makeBucket(long size) throws IOException {\n\t\tBucket rawBucket = null;\n\t\tif(size == BLOB_SIZE) {\n\t\t\t// No need for a DelayedFreeBucket, we handle this internally (and more efficiently) for blobs.\n\t\t\treturn blobFactory.makeBucket();\n\t\t}\n\t\tif(rawBucket == null)\n\t\t\trawBucket = new PersistentTempFileBucket(fg.makeRandomFilename(), fg);\n\t\tBucket maybeEncryptedBucket = (encrypt ? new PaddedEphemerallyEncryptedBucket(rawBucket, 1024, strongPRNG, weakPRNG) : rawBucket);\n\t\treturn new DelayedFreeBucket(this, maybeEncryptedBucket);\n\t}","commit_id":"935027a44d701beb6ba8ecf27dbc6053e5a812e6","url":"https://github.com/freenet/fred"},{"original_method":"public void postCommit(ObjectContainer db) {\n\t\tLinkedList<DelayedFreeBucket> toFree = grabBucketsToFree();\n\t\tfor(Iterator<DelayedFreeBucket> i=toFree.iterator();i.hasNext();) {\n\t\t\tDelayedFreeBucket bucket = i.next();\n\t\t\ttry {\n\t\t\t\tif(bucket.toFree())\n\t\t\t\t\tbucket.realFree();\n\t\t\t\tif(bucket.toRemove())\n\t\t\t\t\tbucket.realRemoveFrom(db);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tLogger.error(this, \"Caught \"+t+\" freeing bucket \"+bucket+\" after transaction commit\", t);\n\t\t\t}\n\t\t}\n\t}","id":38311,"modified_method":"public void postCommit(ObjectContainer db) {\n\t\tblobFactory.postCommit();\n\t\tLinkedList<DelayedFreeBucket> toFree = grabBucketsToFree();\n\t\tfor(Iterator<DelayedFreeBucket> i=toFree.iterator();i.hasNext();) {\n\t\t\tDelayedFreeBucket bucket = i.next();\n\t\t\ttry {\n\t\t\t\tif(bucket.toFree())\n\t\t\t\t\tbucket.realFree();\n\t\t\t\tif(bucket.toRemove())\n\t\t\t\t\tbucket.realRemoveFrom(db);\n\t\t\t} catch (Throwable t) {\n\t\t\t\tLogger.error(this, \"Caught \"+t+\" freeing bucket \"+bucket+\" after transaction commit\", t);\n\t\t\t}\n\t\t}\n\t}","commit_id":"935027a44d701beb6ba8ecf27dbc6053e5a812e6","url":"https://github.com/freenet/fred"},{"original_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\ttry {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmaybeAddToBinaryBlob(data, i, true, container, context);\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tcheckBuckets[i].data = null;\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcheckBuckets[i].removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tif(persistent && checkKeys[i] != null)\n\t\t\t\t\tcheckKeys[i].removeFrom(container);\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t\tif(persistent && !fetcherFinished) {\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\t\t}\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob()) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t\t} finally {\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t}\n\t}","id":38312,"modified_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\ttry {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tBucket wrapper = queueHeal(data, container, context);\n\t\t\t\t\tif(wrapper != data) {\n\t\t\t\t\t\tassert(!persistent);\n\t\t\t\t\t\tdataBuckets[i].setData(wrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmaybeAddToBinaryBlob(data, i, true, container, context);\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tBucket wrapper = queueHeal(data, container, context);\n\t\t\t\t\tif(wrapper != data) {\n\t\t\t\t\t\tassert(!persistent);\n\t\t\t\t\t\twrapper.free();\n\t\t\t\t\t}\n\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tcheckBuckets[i].data = null;\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcheckBuckets[i].removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tif(persistent && checkKeys[i] != null)\n\t\t\t\t\tcheckKeys[i].removeFrom(container);\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t\tif(persistent && !fetcherFinished) {\n\t\t\t\tcontainer.store(this);\n\t\t\t}\n\t\t}\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob()) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t\t} finally {\n\t\t\tif(persistent)\n\t\t\t\tencoderFinished(container, context);\n\t\t}\n\t}","commit_id":"c1f08df1c895a9d2e237ce6684e3409a93da796f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Queue the data for a healing insert. The data will be freed when it the healing insert completes,\n\t * or immediately if a healing insert isn't queued. If we are persistent, copies the data.\n\t * @param data\n\t * @param container\n\t * @param context\n\t */\n\tprivate void queueHeal(Bucket data, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\ttry {\n\t\t\t\tBucket copy = context.tempBucketFactory.makeBucket(data.size());\n\t\t\t\tBucketTools.copy(data, copy);\n\t\t\t\tdata.free();\n\t\t\t\tif(persistent)\n\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\tdata = copy;\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.normal(this, \"Failed to copy data for healing: \"+e, e);\n\t\t\t\tdata.free();\n\t\t\t\tif(persistent)\n\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Queueing healing insert for \"+data+\" on \"+this);\n\t\tcontext.healingQueue.queue(data, forceCryptoKey, cryptoAlgorithm, context);\n\t}","id":38313,"modified_method":"/**\n\t * Queue the data for a healing insert. If the data is persistent, we copy it; the caller must free the \n\t * original data when it is finished with it, the healing queue will free the copied data. If the data is \n\t * not persistent, we create a MultiReaderBucket wrapper, so that the data will be freed when both the caller\n\t * and the healing queue are finished with it; the caller must accept the returned bucket, and free it when it\n\t * is finished with it. \n\t */\n\tprivate Bucket queueHeal(Bucket data, ObjectContainer container, ClientContext context) {\n\t\tBucket copy;\n\t\tif(persistent) {\n\t\t\ttry {\n\t\t\t\tcopy = context.tempBucketFactory.makeBucket(data.size());\n\t\t\t\tBucketTools.copy(data, copy);\n\t\t\t\tdata.free();\n\t\t\t\tif(persistent)\n\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\tdata = copy;\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.normal(this, \"Failed to copy data for healing: \"+e, e);\n\t\t\t\treturn data;\n\t\t\t}\n\t\t} else {\n\t\t\tMultiReaderBucket wrapper = new MultiReaderBucket(data);\n\t\t\tcopy = wrapper.getReaderBucket();\n\t\t\tdata = wrapper.getReaderBucket();\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Queueing healing insert for \"+data+\" on \"+this);\n\t\tcontext.healingQueue.queue(copy, forceCryptoKey, cryptoAlgorithm, context);\n\t\treturn data;\n\t}","commit_id":"c1f08df1c895a9d2e237ce6684e3409a93da796f","url":"https://github.com/freenet/fred"},{"original_method":"NodeClientCore(Node node, Config config, SubConfig nodeConfig, File nodeDir, int portNumber, int sortOrder, SimpleFieldSet oldConfig, SubConfig fproxyConfig, SimpleToadletServer toadlets) throws NodeInitException {\n\t\tthis.node = node;\n\t\tthis.nodeStats = node.nodeStats;\n\t\tthis.random = node.random;\n\t\tthis.backgroundBlockEncoder = new BackgroundBlockEncoder();\n\t\tclientSlowSerialExecutor = new SerialExecutor[RequestStarter.MINIMUM_PRIORITY_CLASS - RequestStarter.MAXIMUM_PRIORITY_CLASS + 1];\n\t\tfor(int i = 0; i < clientSlowSerialExecutor.length; i++) {\n\t\t\tint prio;\n\t\t\tif(i <= RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS)\n\t\t\t\tprio = NativeThread.NORM_PRIORITY;\n\t\t\telse if(i <= RequestStarter.UPDATE_PRIORITY_CLASS)\n\t\t\t\tprio = NativeThread.LOW_PRIORITY;\n\t\t\telse\n\t\t\t\tprio = NativeThread.MIN_PRIORITY;\n\t\t\tclientSlowSerialExecutor[i] = new SerialExecutor(prio);\n\t\t}\n\t\tbyte[] pwdBuf = new byte[16];\n\t\trandom.nextBytes(pwdBuf);\n\t\tthis.formPassword = Base64.encode(pwdBuf);\n\t\talerts = new UserAlertManager(this);\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\n\t\tpersister = new ConfigurablePersister(this, nodeConfig, \"clientThrottleFile\", \"client-throttle.dat\", sortOrder++, true, false,\n\t\t\t\"NodeClientCore.fileForClientStats\", \"NodeClientCore.fileForClientStatsLong\", node.ps, nodeDir);\n\n\t\tSimpleFieldSet throttleFS = persister.read();\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Read throttleFS:\\n\" + throttleFS);\n\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Serializing RequestStarterGroup from:\\n\" + throttleFS);\n\t\trequestStarters = new RequestStarterGroup(node, this, portNumber, random, config, throttleFS);\n\n\t\t// Temp files\n\n\t\tnodeConfig.register(\"tempDir\", new File(nodeDir, \"temp-\" + portNumber).toString(), sortOrder++, true, true, \"NodeClientCore.tempDir\", \"NodeClientCore.tempDirLong\",\n\t\t\tnew StringCallback() {\n\n\t\t\t\tpublic String get() {\n\t\t\t\t\treturn tempDir.getPath();\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n\t\t\t\t\tif(tempDir.equals(new File(val)))\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// FIXME\n\t\t\t\t\tthrow new InvalidConfigValueException(l10n(\"movingTempDirOnTheFlyNotSupported\"));\n\t\t\t\t}\n\t\t\t});\n\n\t\ttempDir = new File(nodeConfig.getString(\"tempDir\"));\n\t\tif(!((tempDir.exists() && tempDir.isDirectory()) || (tempDir.mkdir()))) {\n\t\t\tString msg = \"Could not find or create temporary directory\";\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_TEMP_DIR, msg);\n\t\t}\n\n\t\ttry {\n\t\t\ttempFilenameGenerator = new FilenameGenerator(random, true, tempDir, \"temp-\");\n\t\t} catch(IOException e) {\n\t\t\tString msg = \"Could not find or create temporary directory (filename generator)\";\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_TEMP_DIR, msg);\n\t\t}\n\n\t\t// Persistent temp files\n\t\tnodeConfig.register(\"persistentTempDir\", new File(nodeDir, \"persistent-temp-\" + portNumber).toString(), sortOrder++, true, false, \"NodeClientCore.persistentTempDir\", \"NodeClientCore.persistentTempDirLong\",\n\t\t\tnew StringCallback() {\n\n\t\t\t\tpublic String get() {\n\t\t\t\t\treturn persistentTempBucketFactory.getDir().toString();\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n\t\t\t\t\tif(get().equals(val))\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// FIXME\n\t\t\t\t\tthrow new InvalidConfigValueException(\"Moving persistent temp directory on the fly not supported at present\");\n\t\t\t\t}\n\t\t\t});\n\t\ttry {\n\t\t\tpersistentTempBucketFactory = new PersistentTempBucketFactory(new File(nodeConfig.getString(\"persistentTempDir\")), \"freenet-temp-\", random, node.fastWeakRandom);\n\t\t\tpersistentEncryptedTempBucketFactory = new PersistentEncryptedTempBucketFactory(persistentTempBucketFactory);\n\t\t} catch(IOException e2) {\n\t\t\tString msg = \"Could not find or create persistent temporary directory\";\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_TEMP_DIR, msg);\n\t\t}\n\n\t\tnodeConfig.register(\"encryptTempBuckets\", true, sortOrder++, true, false, \"NodeClientCore.encryptTempBuckets\", \"NodeClientCore.encryptTempBucketsLong\", new BooleanCallback() {\n\n\t\t\tpublic boolean get() {\n\t\t\t\treturn encryptTempBucketFactory;\n\t\t\t}\n\n\t\t\tpublic void set(boolean val) throws InvalidConfigValueException {\n\t\t\t\tthrow new UnsupportedOperationException(\"Can't be changed on the fly!\");\n\t\t\t}\n\t\t});\n\t\tBucketFactory _tempBucketFactory = new TempBucketFactory(tempFilenameGenerator);\n\t\tencryptTempBucketFactory = nodeConfig.getBoolean(\"encryptTempBuckets\");\n\t\ttempBucketFactory = (encryptTempBucketFactory ? new PaddedEphemerallyEncryptedBucketFactory(_tempBucketFactory, random, node.fastWeakRandom, 1024) : _tempBucketFactory);\n\n\t\t// Downloads directory\n\n\t\tnodeConfig.register(\"downloadsDir\", \"downloads\", sortOrder++, true, true, \"NodeClientCore.downloadDir\", \"NodeClientCore.downloadDirLong\", new StringCallback() {\n\n\t\t\tpublic String get() {\n\t\t\t\treturn downloadDir.getPath();\n\t\t\t}\n\n\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n\t\t\t\tif(downloadDir.equals(new File(val)))\n\t\t\t\t\treturn;\n\t\t\t\tFile f = new File(val);\n\t\t\t\tif(!((f.exists() && f.isDirectory()) || (f.mkdir())))\n\t\t\t\t\t// Relatively commonly used, despite being advanced (i.e. not something we want to show to newbies). So translate it.\n\t\t\t\t\tthrow new InvalidConfigValueException(l10n(\"couldNotFindOrCreateDir\"));\n\t\t\t\tdownloadDir = new File(val);\n\t\t\t}\n\t\t});\n\n\t\tString val = nodeConfig.getString(\"downloadsDir\");\n\t\tdownloadDir = new File(val);\n\t\tif(!((downloadDir.exists() && downloadDir.isDirectory()) || (downloadDir.mkdir())))\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_DOWNLOADS_DIR, \"Could not find or create default downloads directory\");\n\n\t\t// Downloads allowed, uploads allowed\n\n\t\tnodeConfig.register(\"downloadAllowedDirs\", new String[]{\"all\"}, sortOrder++, true, true, \"NodeClientCore.downloadAllowedDirs\",\n\t\t\t\"NodeClientCore.downloadAllowedDirsLong\",\n\t\t\tnew StringArrCallback() {\n\n\t\t\t\tpublic String[] get() {\n\t\t\t\t\tsynchronized(NodeClientCore.this) {\n\t\t\t\t\t\tif(downloadAllowedEverywhere)\n\t\t\t\t\t\t\treturn new String[]{\"all\"};\n\t\t\t\t\t\tString[] dirs = new String[downloadAllowedDirs.length + (includeDownloadDir ? 1 : 0)];\n\t\t\t\t\t\tfor(int i = 0; i < downloadAllowedDirs.length; i++)\n\t\t\t\t\t\t\tdirs[i] = downloadAllowedDirs[i].getPath();\n\t\t\t\t\t\tif(includeDownloadDir)\n\t\t\t\t\t\t\tdirs[downloadAllowedDirs.length] = \"downloads\";\n\t\t\t\t\t\treturn dirs;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String[] val) throws InvalidConfigValueException {\n\t\t\t\t\tsetDownloadAllowedDirs(val);\n\t\t\t\t}\n\t\t\t});\n\t\tsetDownloadAllowedDirs(nodeConfig.getStringArr(\"downloadAllowedDirs\"));\n\n\t\tnodeConfig.register(\"uploadAllowedDirs\", new String[]{\"all\"}, sortOrder++, true, true, \"NodeClientCore.uploadAllowedDirs\",\n\t\t\t\"NodeClientCore.uploadAllowedDirsLong\",\n\t\t\tnew StringArrCallback() {\n\n\t\t\t\tpublic String[] get() {\n\t\t\t\t\tsynchronized(NodeClientCore.this) {\n\t\t\t\t\t\tif(uploadAllowedEverywhere)\n\t\t\t\t\t\t\treturn new String[]{\"all\"};\n\t\t\t\t\t\tString[] dirs = new String[uploadAllowedDirs.length];\n\t\t\t\t\t\tfor(int i = 0; i < uploadAllowedDirs.length; i++)\n\t\t\t\t\t\t\tdirs[i] = uploadAllowedDirs[i].getPath();\n\t\t\t\t\t\treturn dirs;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String[] val) throws InvalidConfigValueException {\n\t\t\t\t\tsetUploadAllowedDirs(val);\n\t\t\t\t}\n\t\t\t});\n\t\tsetUploadAllowedDirs(nodeConfig.getStringArr(\"uploadAllowedDirs\"));\n\n\t\tarchiveManager = new ArchiveManager(MAX_ARCHIVE_HANDLERS, MAX_CACHED_ARCHIVE_DATA, MAX_ARCHIVE_SIZE, MAX_ARCHIVED_FILE_SIZE, MAX_CACHED_ELEMENTS, random, node.fastWeakRandom, tempFilenameGenerator);\n\t\tLogger.normal(this, \"Initializing USK Manager\");\n\t\tSystem.out.println(\"Initializing USK Manager\");\n\t\tuskManager = new USKManager(this);\n\n\t\thealingQueue = new SimpleHealingQueue(requestStarters.chkPutScheduler,\n\t\t\tnew InsertContext(tempBucketFactory, tempBucketFactory, persistentTempBucketFactory,\n\t\t\trandom, 0, 2, 1, 0, 0, new SimpleEventProducer(),\n\t\t\t!Node.DONT_CACHE_LOCAL_REQUESTS, uskManager, backgroundBlockEncoder, node.executor), RequestStarter.PREFETCH_PRIORITY_CLASS, 512 /* FIXME make configurable */);\n\n\t\tnodeConfig.register(\"lazyResume\", false, sortOrder++, true, false, \"NodeClientCore.lazyResume\",\n\t\t\t\"NodeClientCore.lazyResumeLong\", new BooleanCallback() {\n\n\t\t\tpublic boolean get() {\n\t\t\t\treturn lazyResume;\n\t\t\t}\n\n\t\t\tpublic void set(boolean val) throws InvalidConfigValueException {\n\t\t\t\tsynchronized(NodeClientCore.this) {\n\t\t\t\t\tlazyResume = val;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlazyResume = nodeConfig.getBoolean(\"lazyResume\");\n\n\t\tnodeConfig.register(\"maxBackgroundUSKFetchers\", \"64\", sortOrder++, true, false, \"NodeClientCore.maxUSKFetchers\",\n\t\t\t\"NodeClientCore.maxUSKFetchersLong\", new IntCallback() {\n\n\t\t\tpublic int get() {\n\t\t\t\treturn maxBackgroundUSKFetchers;\n\t\t\t}\n\n\t\t\tpublic void set(int uskFetch) throws InvalidConfigValueException {\n\t\t\t\tif(uskFetch <= 0)\n\t\t\t\t\tthrow new InvalidConfigValueException(l10n(\"maxUSKFetchersMustBeGreaterThanZero\"));\n\t\t\t\tmaxBackgroundUSKFetchers = uskFetch;\n\t\t\t}\n\t\t});\n\n\t\tmaxBackgroundUSKFetchers = nodeConfig.getInt(\"maxBackgroundUSKFetchers\");\n\n\n\t\t// This is all part of construction, not of start().\n\t\t// Some plugins depend on it, so it needs to be *created* before they are started.\n\n\t\t// TMCI\n\t\ttry {\n\t\t\ttmci = TextModeClientInterfaceServer.maybeCreate(node, this, config);\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_COULD_NOT_START_TMCI, \"Could not start TMCI: \" + e);\n\t\t}\n\n\t\t// FCP (including persistent requests so needs to start before FProxy)\n\t\ttry {\n\t\t\tfcpServer = FCPServer.maybeCreate(node, this, node.config);\n\t\t} catch(IOException e) {\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_COULD_NOT_START_FCP, \"Could not start FCP: \" + e);\n\t\t} catch(InvalidConfigValueException e) {\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_COULD_NOT_START_FCP, \"Could not start FCP: \" + e);\n\t\t}\n\n\t\t// FProxy\n\t\t// FIXME this is a hack, the real way to do this is plugins\n\t\tthis.alerts.register(startingUpAlert = new SimpleUserAlert(true, l10n(\"startingUpTitle\"), l10n(\"startingUp\"), l10n(\"startingUpShort\"), UserAlert.MINOR));\n\t\ttoadletContainer = toadlets;\n\t\ttoadletContainer.setCore(this);\n\t\ttoadletContainer.setBucketFactory(tempBucketFactory);\n\t\tif(toadletContainer.isEnabled()) {\n\t\t\ttoadletContainer.createFproxy();\n\t\t\ttoadletContainer.removeStartupToadlet();\n\t\t}\n\n\t}","id":38314,"modified_method":"NodeClientCore(Node node, Config config, SubConfig nodeConfig, File nodeDir, int portNumber, int sortOrder, SimpleFieldSet oldConfig, SubConfig fproxyConfig, SimpleToadletServer toadlets) throws NodeInitException {\n\t\tthis.node = node;\n\t\tthis.nodeStats = node.nodeStats;\n\t\tthis.random = node.random;\n\t\tthis.backgroundBlockEncoder = new BackgroundBlockEncoder();\n\t\tclientSlowSerialExecutor = new SerialExecutor[RequestStarter.MINIMUM_PRIORITY_CLASS - RequestStarter.MAXIMUM_PRIORITY_CLASS + 1];\n\t\tfor(int i = 0; i < clientSlowSerialExecutor.length; i++) {\n\t\t\tint prio;\n\t\t\tif(i <= RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS)\n\t\t\t\tprio = NativeThread.NORM_PRIORITY;\n\t\t\telse if(i <= RequestStarter.UPDATE_PRIORITY_CLASS)\n\t\t\t\tprio = NativeThread.LOW_PRIORITY;\n\t\t\telse\n\t\t\t\tprio = NativeThread.MIN_PRIORITY;\n\t\t\tclientSlowSerialExecutor[i] = new SerialExecutor(prio);\n\t\t}\n\t\tbyte[] pwdBuf = new byte[16];\n\t\trandom.nextBytes(pwdBuf);\n\t\tthis.formPassword = Base64.encode(pwdBuf);\n\t\talerts = new UserAlertManager(this);\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\n\t\tpersister = new ConfigurablePersister(this, nodeConfig, \"clientThrottleFile\", \"client-throttle.dat\", sortOrder++, true, false,\n\t\t\t\"NodeClientCore.fileForClientStats\", \"NodeClientCore.fileForClientStatsLong\", node.ps, nodeDir);\n\n\t\tSimpleFieldSet throttleFS = persister.read();\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Read throttleFS:\\n\" + throttleFS);\n\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Serializing RequestStarterGroup from:\\n\" + throttleFS);\n\t\trequestStarters = new RequestStarterGroup(node, this, portNumber, random, config, throttleFS);\n\n\t\t// Temp files\n\n\t\tnodeConfig.register(\"tempDir\", new File(nodeDir, \"temp-\" + portNumber).toString(), sortOrder++, true, true, \"NodeClientCore.tempDir\", \"NodeClientCore.tempDirLong\",\n\t\t\tnew StringCallback() {\n\n\t\t\t\tpublic String get() {\n\t\t\t\t\treturn tempDir.getPath();\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n\t\t\t\t\tif(tempDir.equals(new File(val)))\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// FIXME\n\t\t\t\t\tthrow new InvalidConfigValueException(l10n(\"movingTempDirOnTheFlyNotSupported\"));\n\t\t\t\t}\n\t\t\t});\n\n\t\ttempDir = new File(nodeConfig.getString(\"tempDir\"));\n\t\tif(!((tempDir.exists() && tempDir.isDirectory()) || (tempDir.mkdir()))) {\n\t\t\tString msg = \"Could not find or create temporary directory\";\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_TEMP_DIR, msg);\n\t\t}\n\n\t\ttry {\n\t\t\ttempFilenameGenerator = new FilenameGenerator(random, true, tempDir, \"temp-\");\n\t\t} catch(IOException e) {\n\t\t\tString msg = \"Could not find or create temporary directory (filename generator)\";\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_TEMP_DIR, msg);\n\t\t}\n\n\t\t// Persistent temp files\n\t\tnodeConfig.register(\"persistentTempDir\", new File(nodeDir, \"persistent-temp-\" + portNumber).toString(), sortOrder++, true, false, \"NodeClientCore.persistentTempDir\", \"NodeClientCore.persistentTempDirLong\",\n\t\t\tnew StringCallback() {\n\n\t\t\t\tpublic String get() {\n\t\t\t\t\treturn persistentTempBucketFactory.getDir().toString();\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n\t\t\t\t\tif(get().equals(val))\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// FIXME\n\t\t\t\t\tthrow new InvalidConfigValueException(\"Moving persistent temp directory on the fly not supported at present\");\n\t\t\t\t}\n\t\t\t});\n\t\ttry {\n\t\t\tpersistentTempBucketFactory = new PersistentTempBucketFactory(new File(nodeConfig.getString(\"persistentTempDir\")), \"freenet-temp-\", random, node.fastWeakRandom);\n\t\t\tpersistentEncryptedTempBucketFactory = new PersistentEncryptedTempBucketFactory(persistentTempBucketFactory);\n\t\t} catch(IOException e2) {\n\t\t\tString msg = \"Could not find or create persistent temporary directory\";\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_TEMP_DIR, msg);\n\t\t}\n\n\t\tnodeConfig.register(\"encryptTempBuckets\", true, sortOrder++, true, false, \"NodeClientCore.encryptTempBuckets\", \"NodeClientCore.encryptTempBucketsLong\", new BooleanCallback() {\n\n\t\t\tpublic boolean get() {\n\t\t\t\treturn (tempBucketFactory == null ? true : tempBucketFactory.isEncrypting());\n\t\t\t}\n\n\t\t\tpublic void set(boolean val) throws InvalidConfigValueException {\n\t\t\t\tif((val == get()) || (tempBucketFactory == null)) return;\n\t\t\t\ttempBucketFactory.setEncryption(val);\n\t\t\t}\n\t\t});\n\t\tBucketFactory _tempBucketFactory = new TempBucketFactory(tempFilenameGenerator);\n\t\ttempBucketFactory = new PaddedEphemerallyEncryptedBucketFactory(_tempBucketFactory, random, node.fastWeakRandom, 1024, nodeConfig.getBoolean(\"encryptTempBuckets\"));\n\n\t\t// Downloads directory\n\n\t\tnodeConfig.register(\"downloadsDir\", \"downloads\", sortOrder++, true, true, \"NodeClientCore.downloadDir\", \"NodeClientCore.downloadDirLong\", new StringCallback() {\n\n\t\t\tpublic String get() {\n\t\t\t\treturn downloadDir.getPath();\n\t\t\t}\n\n\t\t\tpublic void set(String val) throws InvalidConfigValueException {\n\t\t\t\tif(downloadDir.equals(new File(val)))\n\t\t\t\t\treturn;\n\t\t\t\tFile f = new File(val);\n\t\t\t\tif(!((f.exists() && f.isDirectory()) || (f.mkdir())))\n\t\t\t\t\t// Relatively commonly used, despite being advanced (i.e. not something we want to show to newbies). So translate it.\n\t\t\t\t\tthrow new InvalidConfigValueException(l10n(\"couldNotFindOrCreateDir\"));\n\t\t\t\tdownloadDir = new File(val);\n\t\t\t}\n\t\t});\n\n\t\tString val = nodeConfig.getString(\"downloadsDir\");\n\t\tdownloadDir = new File(val);\n\t\tif(!((downloadDir.exists() && downloadDir.isDirectory()) || (downloadDir.mkdir())))\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_BAD_DOWNLOADS_DIR, \"Could not find or create default downloads directory\");\n\n\t\t// Downloads allowed, uploads allowed\n\n\t\tnodeConfig.register(\"downloadAllowedDirs\", new String[]{\"all\"}, sortOrder++, true, true, \"NodeClientCore.downloadAllowedDirs\",\n\t\t\t\"NodeClientCore.downloadAllowedDirsLong\",\n\t\t\tnew StringArrCallback() {\n\n\t\t\t\tpublic String[] get() {\n\t\t\t\t\tsynchronized(NodeClientCore.this) {\n\t\t\t\t\t\tif(downloadAllowedEverywhere)\n\t\t\t\t\t\t\treturn new String[]{\"all\"};\n\t\t\t\t\t\tString[] dirs = new String[downloadAllowedDirs.length + (includeDownloadDir ? 1 : 0)];\n\t\t\t\t\t\tfor(int i = 0; i < downloadAllowedDirs.length; i++)\n\t\t\t\t\t\t\tdirs[i] = downloadAllowedDirs[i].getPath();\n\t\t\t\t\t\tif(includeDownloadDir)\n\t\t\t\t\t\t\tdirs[downloadAllowedDirs.length] = \"downloads\";\n\t\t\t\t\t\treturn dirs;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String[] val) throws InvalidConfigValueException {\n\t\t\t\t\tsetDownloadAllowedDirs(val);\n\t\t\t\t}\n\t\t\t});\n\t\tsetDownloadAllowedDirs(nodeConfig.getStringArr(\"downloadAllowedDirs\"));\n\n\t\tnodeConfig.register(\"uploadAllowedDirs\", new String[]{\"all\"}, sortOrder++, true, true, \"NodeClientCore.uploadAllowedDirs\",\n\t\t\t\"NodeClientCore.uploadAllowedDirsLong\",\n\t\t\tnew StringArrCallback() {\n\n\t\t\t\tpublic String[] get() {\n\t\t\t\t\tsynchronized(NodeClientCore.this) {\n\t\t\t\t\t\tif(uploadAllowedEverywhere)\n\t\t\t\t\t\t\treturn new String[]{\"all\"};\n\t\t\t\t\t\tString[] dirs = new String[uploadAllowedDirs.length];\n\t\t\t\t\t\tfor(int i = 0; i < uploadAllowedDirs.length; i++)\n\t\t\t\t\t\t\tdirs[i] = uploadAllowedDirs[i].getPath();\n\t\t\t\t\t\treturn dirs;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic void set(String[] val) throws InvalidConfigValueException {\n\t\t\t\t\tsetUploadAllowedDirs(val);\n\t\t\t\t}\n\t\t\t});\n\t\tsetUploadAllowedDirs(nodeConfig.getStringArr(\"uploadAllowedDirs\"));\n\n\t\tarchiveManager = new ArchiveManager(MAX_ARCHIVE_HANDLERS, MAX_CACHED_ARCHIVE_DATA, MAX_ARCHIVE_SIZE, MAX_ARCHIVED_FILE_SIZE, MAX_CACHED_ELEMENTS, random, node.fastWeakRandom, tempFilenameGenerator);\n\t\tLogger.normal(this, \"Initializing USK Manager\");\n\t\tSystem.out.println(\"Initializing USK Manager\");\n\t\tuskManager = new USKManager(this);\n\n\t\thealingQueue = new SimpleHealingQueue(requestStarters.chkPutScheduler,\n\t\t\tnew InsertContext(tempBucketFactory, tempBucketFactory, persistentTempBucketFactory,\n\t\t\trandom, 0, 2, 1, 0, 0, new SimpleEventProducer(),\n\t\t\t!Node.DONT_CACHE_LOCAL_REQUESTS, uskManager, backgroundBlockEncoder, node.executor), RequestStarter.PREFETCH_PRIORITY_CLASS, 512 /* FIXME make configurable */);\n\n\t\tnodeConfig.register(\"lazyResume\", false, sortOrder++, true, false, \"NodeClientCore.lazyResume\",\n\t\t\t\"NodeClientCore.lazyResumeLong\", new BooleanCallback() {\n\n\t\t\tpublic boolean get() {\n\t\t\t\treturn lazyResume;\n\t\t\t}\n\n\t\t\tpublic void set(boolean val) throws InvalidConfigValueException {\n\t\t\t\tsynchronized(NodeClientCore.this) {\n\t\t\t\t\tlazyResume = val;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlazyResume = nodeConfig.getBoolean(\"lazyResume\");\n\n\t\tnodeConfig.register(\"maxBackgroundUSKFetchers\", \"64\", sortOrder++, true, false, \"NodeClientCore.maxUSKFetchers\",\n\t\t\t\"NodeClientCore.maxUSKFetchersLong\", new IntCallback() {\n\n\t\t\tpublic int get() {\n\t\t\t\treturn maxBackgroundUSKFetchers;\n\t\t\t}\n\n\t\t\tpublic void set(int uskFetch) throws InvalidConfigValueException {\n\t\t\t\tif(uskFetch <= 0)\n\t\t\t\t\tthrow new InvalidConfigValueException(l10n(\"maxUSKFetchersMustBeGreaterThanZero\"));\n\t\t\t\tmaxBackgroundUSKFetchers = uskFetch;\n\t\t\t}\n\t\t});\n\n\t\tmaxBackgroundUSKFetchers = nodeConfig.getInt(\"maxBackgroundUSKFetchers\");\n\n\n\t\t// This is all part of construction, not of start().\n\t\t// Some plugins depend on it, so it needs to be *created* before they are started.\n\n\t\t// TMCI\n\t\ttry {\n\t\t\ttmci = TextModeClientInterfaceServer.maybeCreate(node, this, config);\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_COULD_NOT_START_TMCI, \"Could not start TMCI: \" + e);\n\t\t}\n\n\t\t// FCP (including persistent requests so needs to start before FProxy)\n\t\ttry {\n\t\t\tfcpServer = FCPServer.maybeCreate(node, this, node.config);\n\t\t} catch(IOException e) {\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_COULD_NOT_START_FCP, \"Could not start FCP: \" + e);\n\t\t} catch(InvalidConfigValueException e) {\n\t\t\tthrow new NodeInitException(NodeInitException.EXIT_COULD_NOT_START_FCP, \"Could not start FCP: \" + e);\n\t\t}\n\n\t\t// FProxy\n\t\t// FIXME this is a hack, the real way to do this is plugins\n\t\tthis.alerts.register(startingUpAlert = new SimpleUserAlert(true, l10n(\"startingUpTitle\"), l10n(\"startingUp\"), l10n(\"startingUpShort\"), UserAlert.MINOR));\n\t\ttoadletContainer = toadlets;\n\t\ttoadletContainer.setCore(this);\n\t\ttoadletContainer.setBucketFactory(tempBucketFactory);\n\t\tif(toadletContainer.isEnabled()) {\n\t\t\ttoadletContainer.createFproxy();\n\t\t\ttoadletContainer.removeStartupToadlet();\n\t\t}\n\n\t}","commit_id":"c6ad2fb1b017e2676089cce755e85af982c923d6","url":"https://github.com/freenet/fred"},{"original_method":"public Bucket makeBucket(long size) throws IOException {\n\t\treturn new PaddedEphemerallyEncryptedBucket(baseFactory.makeBucket(size), minSize, strongPRNG, weakPRNG);\n\t}","id":38315,"modified_method":"public Bucket makeBucket(long size) throws IOException {\n\t\tBucket realBucket = baseFactory.makeBucket(size);\n\t\tif(!reallyEncrypt)\n\t\t\treturn realBucket;\n\t\telse\n\t\t\treturn new PaddedEphemerallyEncryptedBucket(realBucket, minSize, strongPRNG, weakPRNG);\n\t}","commit_id":"c6ad2fb1b017e2676089cce755e85af982c923d6","url":"https://github.com/freenet/fred"},{"original_method":"public PaddedEphemerallyEncryptedBucketFactory(BucketFactory factory, RandomSource strongPRNG, Random weakPRNG, int minSize) {\n\t\tbaseFactory = factory;\n\t\tthis.minSize = minSize;\n\t\tthis.strongPRNG = strongPRNG;\n\t\tthis.weakPRNG = weakPRNG;\n\t}","id":38316,"modified_method":"public PaddedEphemerallyEncryptedBucketFactory(BucketFactory factory, RandomSource strongPRNG, Random weakPRNG, int minSize, boolean reallyEncrypt) {\n\t\tbaseFactory = factory;\n\t\tthis.minSize = minSize;\n\t\tthis.strongPRNG = strongPRNG;\n\t\tthis.weakPRNG = weakPRNG;\n\t\tthis.reallyEncrypt = reallyEncrypt;\n\t}","commit_id":"c6ad2fb1b017e2676089cce755e85af982c923d6","url":"https://github.com/freenet/fred"},{"original_method":"private void visitAssignment(JetExpression lhs, @Nullable JetExpression rhs, JetExpression parentExpression) {\n            JetExpression left = JetPsiUtil.deparenthesize(lhs);\n            if (left == null) {\n                builder.compilationError(lhs, \"No lValue in assignment\");\n                return;\n            }\n\n            if (left instanceof JetArrayAccessExpression) {\n                ResolvedCall<FunctionDescriptor> setResolvedCall = trace.get(BindingContext.INDEXED_LVALUE_SET, left);\n                generateArrayAccess((JetArrayAccessExpression) left, setResolvedCall);\n                recordWrite(left, parentExpression);\n                return;\n            }\n\n            if (left instanceof JetSimpleNameExpression || left instanceof JetProperty) {\n                generateInstructions(rhs, false);\n            }\n            else if (left instanceof JetQualifiedExpression) {\n                generateInstructions(rhs, false);\n                generateInstructions(((JetQualifiedExpression) left).getReceiverExpression(), false);\n            }\n            else {\n                builder.unsupported(parentExpression); // TODO\n            }\n\n            recordWrite(left, parentExpression);\n        }","id":38317,"modified_method":"private void visitAssignment(JetExpression lhs, @Nullable JetExpression rhs, JetExpression parentExpression) {\n            JetExpression left = JetPsiUtil.deparenthesize(lhs);\n            if (left == null) {\n                builder.compilationError(lhs, \"No lValue in assignment\");\n                return;\n            }\n\n            if (left instanceof JetArrayAccessExpression) {\n                ResolvedCall<FunctionDescriptor> setResolvedCall = trace.get(BindingContext.INDEXED_LVALUE_SET, left);\n                generateArrayAccess((JetArrayAccessExpression) left, setResolvedCall);\n                recordWrite(left, parentExpression);\n                return;\n            }\n\n            generateInstructions(rhs, false);\n            if (left instanceof JetSimpleNameExpression || left instanceof JetProperty) {\n                // Do nothing, just record write below\n            }\n            else if (left instanceof JetQualifiedExpression) {\n                generateInstructions(((JetQualifiedExpression) left).getReceiverExpression(), false);\n            }\n            else {\n                builder.unsupported(parentExpression); // TODO\n            }\n\n            recordWrite(left, parentExpression);\n        }","commit_id":"e0cf73d9890bea299e5729ba229d7a9900d84e68","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (!canHandle(network.getGuestType(), dc)) {\n            s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            return false;\n        }\n\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n\n        NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());\n        \n        // We need to re-implement the network since the redundancy capability may changed\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n        \n        /* Get the host_id in order to find the cluster */\n        long host_id = 0;\n        boolean result = true;\n        boolean ret = true;\n        for (DomainRouterVO router : routers) {\n            host_id = router.getHostId();\n            if (_routerMgr.stopRouter(router.getId(), false) == null) {\n                s_logger.warn(\"Failed to stop virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                ret = false;\n            }\n            result = _routerMgr.destroyRouter(router.getId());\n            if (!result) {\n                s_logger.warn(\"Failed to destroy virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                ret = false;\n            }\n           \n        }\n        \n        \n        Cluster cluster = _configMgr.getCluster(_hostDao.findById(host_id).getClusterId());\n        dest = new DeployDestination(dc, null, cluster, null);\n        implement(network, networkOffering, dest, context);\n        return ret;\n    }","id":38318,"modified_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (!canHandle(network.getGuestType(), dc)) {\n            s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            return false;\n        }\n\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n\n        NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());\n        \n        // We need to re-implement the network since the redundancy capability may changed\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n        \n        /* Get the host_id in order to find the cluster */\n        long host_id = 0;\n        for (DomainRouterVO router : routers) {\n            host_id = router.getHostId();\n            /* TODO it's not completely safe to ignore these failure, but we would try to push on now */\n            if (_routerMgr.stopRouter(router.getId(), false) == null) {\n                s_logger.warn(\"Failed to stop virtual router element \" + router + \" as a part of network \" + network + \" restart\");\n            }\n            if (!_routerMgr.destroyRouter(router.getId())) {\n                s_logger.warn(\"Failed to destroy virtual router element \" + router + \" as a part of network \" + network + \" restart\");\n            }\n        }\n        \n        /* The cluster here is only used to determine hypervisor type, not the real deployment */\n        Cluster cluster = _configMgr.getCluster(_hostDao.findById(host_id).getClusterId());\n        dest = new DeployDestination(dc, null, cluster, null);\n        return implement(network, networkOffering, dest, context);\n    }","commit_id":"9569a7bbeed4b8a88df0851d678834fc3dadeaa8","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (!canHandle(network.getGuestType(), dc)) {\n            s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            return false;\n        }\n\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n\n        NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());\n        \n        // We need to re-implement the network since the redundancy capability may changed\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n\n        /* Get the host_id in order to find the cluster */\n        long host_id = 0;\n        boolean result = true;\n        boolean ret = true;\n        for (DomainRouterVO router : routers) {\n            host_id = router.getHostId();\n            if (_routerMgr.stopRouter(router.getId(), false) == null) {\n                s_logger.warn(\"Failed to stop virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                ret = false;\n            }\n            result = _routerMgr.destroyRouter(router.getId());\n            if (!result) {\n                s_logger.warn(\"Failed to destroy virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                ret = false;\n            }\n           \n        }\n        \n        \n        Cluster cluster = _configMgr.getCluster(_hostDao.findById(host_id).getClusterId());\n        dest = new DeployDestination(dc, null, cluster, null);\n        implement(network, networkOffering, dest, context);\n        return ret;\n    }","id":38319,"modified_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (!canHandle(network.getGuestType(), dc)) {\n            s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            return false;\n        }\n\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n\n        NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());\n        \n        // We need to re-implement the network since the redundancy capability may changed\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n\n        /* Get the host_id in order to find the cluster */\n        long host_id = 0;\n        for (DomainRouterVO router : routers) {\n            host_id = router.getHostId();\n            /* TODO it's not completely safe to ignore these failure, but we would try to push on now */\n            if (_routerMgr.stopRouter(router.getId(), false) == null) {\n                s_logger.warn(\"Failed to stop virtual router element \" + router + \" as a part of network \" + network + \" restart\");\n            }\n            if (!_routerMgr.destroyRouter(router.getId())) {\n                s_logger.warn(\"Failed to destroy virtual router element \" + router + \" as a part of network \" + network + \" restart\");\n            }\n        }\n        \n        /* The cluster here is only used to determine hypervisor type, not the real deployment */\n        Cluster cluster = _configMgr.getCluster(_hostDao.findById(host_id).getClusterId());\n        dest = new DeployDestination(dc, null, cluster, null);\n        return implement(network, networkOffering, dest, context);\n    }","commit_id":"16119d5cacbe48cfb9e942ee9449c2a2841c7584","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (!canHandle(network.getGuestType(), dc)) {\n            s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            return false;\n        }\n\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n\n        NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());\n        \n        // We need to re-implement the network since the redundancy capability may changed\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n\n        /* Get the host_id in order to find the cluster */\n        long host_id = 0;\n        boolean result = true;\n        boolean ret = true;\n        for (DomainRouterVO router : routers) {\n            host_id = router.getHostId();\n            if (_routerMgr.stopRouter(router.getId(), false) == null) {\n                s_logger.warn(\"Failed to stop virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                ret = false;\n            }\n            result = _routerMgr.destroyRouter(router.getId());\n            if (!result) {\n                s_logger.warn(\"Failed to destroy virtual router element \" + router + \" as a part of netowrk \" + network + \" restart\");\n                ret = false;\n            }\n           \n        }\n        \n        \n        Cluster cluster = _configMgr.getCluster(_hostDao.findById(host_id).getClusterId());\n        dest = new DeployDestination(dc, null, cluster, null);\n        implement(network, networkOffering, dest, context);\n        return ret;\n    }","id":38320,"modified_method":"@Override\n    public boolean restart(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException{\n        DataCenter dc = _configMgr.getZone(network.getDataCenterId());\n        if (!canHandle(network.getGuestType(), dc)) {\n            s_logger.trace(\"Virtual router element doesn't handle network restart for the network \" + network);\n            return false;\n        }\n\n        DeployDestination dest = new DeployDestination(dc, null, null, null);\n\n        NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());\n        \n        // We need to re-implement the network since the redundancy capability may changed\n        List<DomainRouterVO> routers = _routerDao.findByNetwork(network.getId());\n        if (routers == null || routers.isEmpty()) {\n            s_logger.trace(\"Can't find virtual router element in network \" + network.getId());\n            return true;\n        }\n\n        /* Get the host_id in order to find the cluster */\n        long host_id = 0;\n        for (DomainRouterVO router : routers) {\n            host_id = router.getHostId();\n            /* TODO it's not completely safe to ignore these failure, but we would try to push on now */\n            if (_routerMgr.stopRouter(router.getId(), false) == null) {\n                s_logger.warn(\"Failed to stop virtual router element \" + router + \" as a part of network \" + network + \" restart\");\n            }\n            if (!_routerMgr.destroyRouter(router.getId())) {\n                s_logger.warn(\"Failed to destroy virtual router element \" + router + \" as a part of network \" + network + \" restart\");\n            }\n        }\n        \n        /* The cluster here is only used to determine hypervisor type, not the real deployment */\n        Cluster cluster = _configMgr.getCluster(_hostDao.findById(host_id).getClusterId());\n        dest = new DeployDestination(dc, null, cluster, null);\n        return implement(network, networkOffering, dest, context);\n    }","commit_id":"bcf5058edae6db530fba26e5164df6ee5c3b1057","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean isMatchingFile(File file, String checkXmlFile)\n\t\tthrows AutoDeployException {\n\n\t\tif (!isMatchingFileExtension(file)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tZipFile zipFile = null;\n\n\t\ttry {\n\t\t\tzipFile = new ZipFile(file);\n\n\t\t\tif (zipFile.getEntry(\"WEB-INF/\" + checkXmlFile) == null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\tfile.getPath() + \" does not have WEB-INF/\" +\n\t\t\t\t\t\t\tcheckXmlFile);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new AutoDeployException(ioe);\n\t\t}\n\t\tfinally {\n\t\t\tif (zipFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipFile.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":38321,"modified_method":"public boolean isMatchingFile(File file, String checkXmlFile)\n\t\tthrows AutoDeployException {\n\n\t\tif (!isMatchingFileExtension(file)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tZipFile zipFile = null;\n\n\t\ttry {\n\t\t\tzipFile = new ZipFile(file);\n\n\t\t\tif (zipFile.getEntry(checkXmlFile) == null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\tfile.getPath() + \" does not have \" + checkXmlFile);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new AutoDeployException(ioe);\n\t\t}\n\t\tfinally {\n\t\t\tif (zipFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipFile.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"7cba04f3085b54fd35268018548217f9e406b278","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deployDirectory(\n\t\t\tFile srcFile, File deployDir, String displayName, boolean overwrite)\n\t\tthrows Exception {\n\n\t\tcopyJars(srcFile);\n\t\tcopyTlds(srcFile);\n\n\t\tupdateGeronimoWebXML(srcFile, displayName);\n\n\t\tFile webXML = new File(srcFile + \"/WEB-INF/web.xml\");\n\n\t\tupdateWebXML(webXML, srcFile, displayName);\n\n\t\tif ((deployDir != null) && !baseDir.equals(destDir)) {\n\t\t\tupdateDeployDirectory(srcFile);\n\n\t\t\tString excludes = StringPool.BLANK;\n\n\t\t\tif (appServerType.equals(\"tomcat\")) {\n\t\t\t\tString[] libs = FileUtil.listFiles(tomcatLibDir);\n\n\t\t\t\tfor (int i = 0; i < libs.length; i++) {\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/\" + libs[i] + \",\";\n\t\t\t\t}\n\n\t\t\t\tFile contextXML = new File(srcFile + \"/META-INF/context.xml\");\n\n\t\t\t\tif (contextXML.exists()) {\n\t\t\t\t\tString content = FileUtil.read(contextXML);\n\n\t\t\t\t\tif (content.indexOf(_PORTAL_CLASS_LOADER) != -1) {\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-bridges.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-java.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-taglib.jar,\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!unpackWar || appServerType.equals(\"websphere\")) {\n\t\t\t\tWarTask.war(srcFile, deployDir, \"WEB-INF/web.xml\", webXML);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// The deployer might only copy files that have been modified.\n\t\t\t\t// However, the deployer always copies and overwrites web.xml\n\t\t\t\t// after the other files have been copied because application\n\t\t\t\t// servers usually detect that a WAR has been modified based on\n\t\t\t\t// the web.xml time stamp.\n\n\t\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, StringPool.BLANK, excludes, overwrite,\n\t\t\t\t\ttrue);\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, \"**/WEB-INF/web.xml\", StringPool.BLANK,\n\t\t\t\t\ttrue, false);\n\n\t\t\t\tif (appServerType.equals(\"tomcat\")) {\n\n\t\t\t\t\t// See org.apache.catalina.startup.HostConfig to see how\n\t\t\t\t\t// Tomcat checks to make sure that web.xml was modified 5\n\t\t\t\t\t// seconds after WEB-INF\n\n\t\t\t\t\tFile deployWebXML = new File(\n\t\t\t\t\t\tdeployDir + \"/WEB-INF/web.xml\");\n\n\t\t\t\t\tdeployWebXML.setLastModified(\n\t\t\t\t\t\tSystem.currentTimeMillis() + (Time.SECOND * 6));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":38322,"modified_method":"protected void deployDirectory(\n\t\t\tFile srcFile, File deployDir, String displayName, boolean overwrite)\n\t\tthrows Exception {\n\n\t\tcopyJars(srcFile);\n\t\tcopyTlds(srcFile);\n\t\tcopyXmls(srcFile, displayName);\n\n\t\tupdateGeronimoWebXML(srcFile, displayName);\n\n\t\tFile webXML = new File(srcFile + \"/WEB-INF/web.xml\");\n\n\t\tupdateWebXML(webXML, srcFile, displayName);\n\n\t\tif ((deployDir != null) && !baseDir.equals(destDir)) {\n\t\t\tupdateDeployDirectory(srcFile);\n\n\t\t\tString excludes = StringPool.BLANK;\n\n\t\t\tif (appServerType.equals(\"tomcat\")) {\n\t\t\t\tString[] libs = FileUtil.listFiles(tomcatLibDir);\n\n\t\t\t\tfor (int i = 0; i < libs.length; i++) {\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/\" + libs[i] + \",\";\n\t\t\t\t}\n\n\t\t\t\tFile contextXML = new File(srcFile + \"/META-INF/context.xml\");\n\n\t\t\t\tif (contextXML.exists()) {\n\t\t\t\t\tString content = FileUtil.read(contextXML);\n\n\t\t\t\t\tif (content.indexOf(_PORTAL_CLASS_LOADER) != -1) {\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-bridges.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-java.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-taglib.jar,\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!unpackWar || appServerType.equals(\"websphere\")) {\n\t\t\t\tWarTask.war(srcFile, deployDir, \"WEB-INF/web.xml\", webXML);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// The deployer might only copy files that have been modified.\n\t\t\t\t// However, the deployer always copies and overwrites web.xml\n\t\t\t\t// after the other files have been copied because application\n\t\t\t\t// servers usually detect that a WAR has been modified based on\n\t\t\t\t// the web.xml time stamp.\n\n\t\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, StringPool.BLANK, excludes, overwrite,\n\t\t\t\t\ttrue);\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, \"**/WEB-INF/web.xml\", StringPool.BLANK,\n\t\t\t\t\ttrue, false);\n\n\t\t\t\tif (appServerType.equals(\"tomcat\")) {\n\n\t\t\t\t\t// See org.apache.catalina.startup.HostConfig to see how\n\t\t\t\t\t// Tomcat checks to make sure that web.xml was modified 5\n\t\t\t\t\t// seconds after WEB-INF\n\n\t\t\t\t\tFile deployWebXML = new File(\n\t\t\t\t\t\tdeployDir + \"/WEB-INF/web.xml\");\n\n\t\t\t\t\tdeployWebXML.setLastModified(\n\t\t\t\t\t\tSystem.currentTimeMillis() + (Time.SECOND * 6));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"7cba04f3085b54fd35268018548217f9e406b278","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deployFile(File srcFile) throws Exception {\n\t\tPluginPackage pluginPackage = _readPluginPackage(srcFile);\n\n\t\tSystem.out.println(\"\\nDeploying \" + srcFile.getName());\n\n\t\tString deployDir = null;\n\t\tString displayName = null;\n\t\tboolean overwrite = false;\n\t\tString preliminaryContext = null;\n\n\t\t// File names starting with DEPLOY_TO_PREFIX should use the filename\n\t\t// after the prefix as the deployment context\n\n\t\tif (srcFile.getName().startsWith(Constants.DEPLOY_TO_PREFIX)) {\n\t\t\tdisplayName = srcFile.getName().substring(\n\t\t\t\tConstants.DEPLOY_TO_PREFIX.length(),\n\t\t\t\tsrcFile.getName().length() - 4);\n\n\t\t\toverwrite = true;\n\t\t\tpreliminaryContext = displayName;\n\t\t}\n\n\t\tif (preliminaryContext == null) {\n\t\t\tpreliminaryContext = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (pluginPackage != null) {\n\t\t\tif (!PluginPackageUtil.isCurrentVersionSupported(\n\t\t\t\t\tpluginPackage.getLiferayVersions())) {\n\n\t\t\t\tthrow new AutoDeployException(\n\t\t\t\t\tsrcFile.getName() +\n\t\t\t\t\t\t\" does not support this version of Liferay\");\n\t\t\t}\n\n\t\t\tif (displayName == null) {\n\t\t\t\tdisplayName = pluginPackage.getRecommendedDeploymentContext();\n\t\t\t}\n\n\t\t\tif (Validator.isNull(displayName)) {\n\t\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t\t}\n\n\t\t\tpluginPackage.setContext(displayName);\n\n\t\t\tPluginPackageUtil.updateInstallingPluginPackage(\n\t\t\t\tpreliminaryContext, pluginPackage);\n\t\t}\n\n\t\tif (Validator.isNotNull(displayName)) {\n\t\t\tdeployDir = displayName + \".war\";\n\t\t}\n\t\telse {\n\t\t\tdeployDir = srcFile.getName();\n\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (appServerType.startsWith(\"jboss\")) {\n\t\t\tdeployDir = jbossPrefix + deployDir;\n\t\t}\n\t\telse if (appServerType.equals(\"jetty\") ||\n\t\t\t\t appServerType.equals(\"oc4j\") ||\n\t\t\t\t appServerType.equals(\"orion\") ||\n\t\t\t\t appServerType.equals(\"resin\") ||\n\t\t\t\t appServerType.equals(\"tomcat\")) {\n\n\t\t\tif (unpackWar) {\n\t\t\t\tdeployDir = deployDir.substring(0, deployDir.length() - 4);\n\t\t\t}\n\t\t}\n\n\t\tdeployDir = destDir + \"/\" + deployDir;\n\n\t\tFile deployDirFile = new File(deployDir);\n\n\t\ttry {\n\t\t\tPluginPackage previousPluginPackage =\n\t\t\t\t_readPluginPackage(deployDirFile);\n\n\t\t\tif (previousPluginPackage != null) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\t\"Updating \" + pluginPackage.getName() + \" from version \" +\n\t\t\t\t\t\tpreviousPluginPackage.getVersion() + \" to version \" +\n\t\t\t\t\t\t\tpluginPackage.getVersion());\n\n\t\t\t\tif (pluginPackage.isLaterVersionThan(\n\t\t\t\t\tpreviousPluginPackage)) {\n\n\t\t\t\t\toverwrite = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (srcFile.isDirectory()) {\n\t\t\t\tdeployDirectory(srcFile, deployDirFile, displayName, overwrite);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean deployed = deployFile(\n\t\t\t\t\tsrcFile, deployDirFile, displayName, overwrite);\n\n\t\t\t\tif (!deployed) {\n\t\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(\n\t\t\t\t\t\tpluginPackage.getContext());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (pluginPackage != null) {\n\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(\n\t\t\t\t\tpluginPackage.getContext());\n\t\t\t}\n\n\t\t\tthrow e;\n\t\t}\n\t}","id":38323,"modified_method":"protected void deployFile(File srcFile) throws Exception {\n\t\tPluginPackage pluginPackage = _readPluginPackage(srcFile);\n\n\t\tSystem.out.println(\"\\nDeploying \" + srcFile.getName());\n\n\t\tString deployDir = null;\n\t\tString displayName = null;\n\t\tboolean overwrite = false;\n\t\tString preliminaryContext = null;\n\n\t\t// File names starting with DEPLOY_TO_PREFIX should use the filename\n\t\t// after the prefix as the deployment context\n\n\t\tif (srcFile.getName().startsWith(Constants.DEPLOY_TO_PREFIX)) {\n\t\t\tdisplayName = srcFile.getName().substring(\n\t\t\t\tConstants.DEPLOY_TO_PREFIX.length(),\n\t\t\t\tsrcFile.getName().length() - 4);\n\n\t\t\toverwrite = true;\n\t\t\tpreliminaryContext = displayName;\n\t\t}\n\n\t\tif (preliminaryContext == null) {\n\t\t\tpreliminaryContext = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (pluginPackage != null) {\n\t\t\tif (!PluginPackageUtil.isCurrentVersionSupported(\n\t\t\t\t\tpluginPackage.getLiferayVersions())) {\n\n\t\t\t\tthrow new AutoDeployException(\n\t\t\t\t\tsrcFile.getName() +\n\t\t\t\t\t\t\" does not support this version of Liferay\");\n\t\t\t}\n\n\t\t\tif (displayName == null) {\n\t\t\t\tdisplayName = pluginPackage.getRecommendedDeploymentContext();\n\t\t\t}\n\n\t\t\tif (Validator.isNull(displayName)) {\n\t\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t\t}\n\n\t\t\tpluginPackage.setContext(displayName);\n\n\t\t\tPluginPackageUtil.updateInstallingPluginPackage(\n\t\t\t\tpreliminaryContext, pluginPackage);\n\t\t}\n\n\t\tif (Validator.isNotNull(displayName)) {\n\t\t\tdeployDir = displayName + \".war\";\n\t\t}\n\t\telse {\n\t\t\tdeployDir = srcFile.getName();\n\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (appServerType.startsWith(\"jboss\")) {\n\t\t\tdeployDir = jbossPrefix + deployDir;\n\t\t}\n\t\telse if (appServerType.equals(\"jetty\") ||\n\t\t\t\t appServerType.equals(\"oc4j\") ||\n\t\t\t\t appServerType.equals(\"orion\") ||\n\t\t\t\t appServerType.equals(\"resin\") ||\n\t\t\t\t appServerType.equals(\"tomcat\")) {\n\n\t\t\tif (unpackWar) {\n\t\t\t\tdeployDir = deployDir.substring(0, deployDir.length() - 4);\n\t\t\t}\n\t\t}\n\n\t\tdeployDir = destDir + \"/\" + deployDir;\n\n\t\tFile deployDirFile = new File(deployDir);\n\n\t\ttry {\n\t\t\tPluginPackage previousPluginPackage =\n\t\t\t\t_readPluginPackage(deployDirFile);\n\n\t\t\tif (previousPluginPackage != null) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\t\"Updating \" + pluginPackage.getName() + \" from version \" +\n\t\t\t\t\t\tpreviousPluginPackage.getVersion() + \" to version \" +\n\t\t\t\t\t\t\tpluginPackage.getVersion());\n\n\t\t\t\tif (pluginPackage.isLaterVersionThan(\n\t\t\t\t\tpreviousPluginPackage)) {\n\n\t\t\t\t\toverwrite = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (srcFile.isDirectory()) {\n\t\t\t\tdeployDirectory(srcFile, deployDirFile, displayName, overwrite);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean deployed = deployFile(\n\t\t\t\t\tsrcFile, deployDirFile, displayName, overwrite);\n\n\t\t\t\tif (!deployed) {\n\t\t\t\t\tString context = preliminaryContext;\n\t\t\t\t\tif (pluginPackage != null) {\n\t\t\t\t\t\tcontext = pluginPackage.getContext();\n\t\t\t\t\t}\n\t\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (pluginPackage != null) {\n\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(\n\t\t\t\t\tpluginPackage.getContext());\n\t\t\t}\n\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"7cba04f3085b54fd35268018548217f9e406b278","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(File file) throws AutoDeployException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isMatchingFile(file, \"liferay-layout-templates.xml\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying layout templates for \" + file.getPath());\n\t\t}\n\n\t\t_deployer.autoDeploy(file.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Layout templates for \" + file.getPath() +\n\t\t\t\t\t\" copied successfully\");\n\t\t}\n\t}","id":38324,"modified_method":"public void deploy(File file) throws AutoDeployException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isMatchingFile(file, \"WEB-INF/liferay-layout-templates.xml\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying layout templates for \" + file.getPath());\n\t\t}\n\n\t\t_deployer.autoDeploy(file.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Layout templates for \" + file.getPath() +\n\t\t\t\t\t\" copied successfully\");\n\t\t}\n\t}","commit_id":"7cba04f3085b54fd35268018548217f9e406b278","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(File file) throws AutoDeployException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isMatchingFile(file, PortalUtil.PORTLET_XML_FILE_NAME_STANDARD)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying portlets for \" + file.getPath());\n\t\t}\n\n\t\t_deployer.autoDeploy(file.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Portlets for \" + file.getPath() + \" copied successfully\");\n\t\t}\n\t}","id":38325,"modified_method":"public void deploy(File file) throws AutoDeployException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tAutoDeployer deployer = null;\n\n\t\tif (isMatchingFile(\n\t\t\tfile, \"WEB-INF/\" + PortalUtil.PORTLET_XML_FILE_NAME_STANDARD)) {\n\t\t\tdeployer = _deployer;\n\t\t}\n\t\telse if (isMatchingFile(file, \"index.php\")) {\n\t\t\tdeployer = getPhpDeployer();\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying portlets for \" + file.getPath());\n\t\t}\n\n\t\tdeployer.autoDeploy(file.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Portlets for \" + file.getPath() + \" copied successfully\");\n\t\t}\n\t}","commit_id":"7cba04f3085b54fd35268018548217f9e406b278","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(File file) throws AutoDeployException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isMatchingFile(file, \"liferay-look-and-feel.xml\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying themes for \" + file.getPath());\n\t\t}\n\n\t\t_deployer.autoDeploy(file.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Themes for \" + file.getPath() + \" copied successfully\");\n\t\t}\n\t}","id":38326,"modified_method":"public void deploy(File file) throws AutoDeployException {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isMatchingFile(file, \"WEB-INF/liferay-look-and-feel.xml\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying themes for \" + file.getPath());\n\t\t}\n\n\t\t_deployer.autoDeploy(file.getName());\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Themes for \" + file.getPath() + \" copied successfully\");\n\t\t}\n\t}","commit_id":"7cba04f3085b54fd35268018548217f9e406b278","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isThemePlugin(File file) throws AutoDeployException {\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-look-and-feel.xml\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString fileName = file.getName();\n\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-plugin-package.properties\") &&\n\t\t\tfileName.contains(\"-theme\")) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":38327,"modified_method":"public boolean isThemePlugin(File file) throws AutoDeployException {\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-look-and-feel.xml\") &&\n\t\t\t!isJarFile(file)) {\n\n\t\t\t\treturn true;\n\t\t}\n\n\t\tString fileName = file.getName();\n\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-plugin-package.properties\") &&\n\t\t\tfileName.contains(\"-theme\")) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"faf46474e71dfc7b8b42abdb2559ed1ac0f6e4ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isExtPlugin(File file) {\n\t\tString fileName = file.getName();\n\n\t\tif (fileName.contains(\"-ext\")) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":38328,"modified_method":"public boolean isExtPlugin(File file) {\n\t\tString fileName = file.getName();\n\n\t\tif (fileName.contains(\"-ext\") || !isJarFile(file)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"faf46474e71dfc7b8b42abdb2559ed1ac0f6e4ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isHookPlugin(File file) throws AutoDeployException {\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-hook.xml\") &&\n\t\t\t!isMatchingFile(file, \"WEB-INF/liferay-portlet.xml\")) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":38329,"modified_method":"public boolean isHookPlugin(File file) throws AutoDeployException {\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-hook.xml\") &&\n\t\t\t!isMatchingFile(file, \"WEB-INF/liferay-portlet.xml\") &&\n\t\t\t!isJarFile(file)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"faf46474e71dfc7b8b42abdb2559ed1ac0f6e4ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isWebPlugin(File file) throws AutoDeployException {\n\t\tString fileName = file.getName();\n\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-plugin-package.properties\") &&\n\t\t\tfileName.contains(\"-web\")) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":38330,"modified_method":"public boolean isWebPlugin(File file) throws AutoDeployException {\n\t\tString fileName = file.getName();\n\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-plugin-package.properties\") &&\n\t\t\tfileName.contains(\"-web\") && !isJarFile(file)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"faf46474e71dfc7b8b42abdb2559ed1ac0f6e4ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isMatchingFileExtension(File file) {\n\t\tString fileName = file.getName().toLowerCase();\n\n\t\tif (fileName.endsWith(\".war\") || fileName.endsWith(\".zip\")) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(file.getPath() + \" has a matching extension\");\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\tfile.getPath() + \" does not have a matching extension\");\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}","id":38331,"modified_method":"public boolean isMatchingFileExtension(File file) {\n\t\treturn isMatchingFileExtension(file, \".war\", \".zip\");\n\t}","commit_id":"faf46474e71dfc7b8b42abdb2559ed1ac0f6e4ff","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isHookPlugin(File file) throws AutoDeployException {\n\t\tString fileName = file.getName();\n\n\t\tif (isMatchingFile(file, \"WEB-INF/liferay-plugin-package.properties\") &&\n\t\t\tfileName.contains(\"-hook\") && !fileName.contains(\"-portlet\")) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":38332,"modified_method":"public boolean isHookPlugin(File file) throws AutoDeployException {\n\t\tString liferayHookFile=\"WEB-INF/liferay-hook.xml\";\n\t\tString liferayPortletFile=\"WEB-INF/liferay-portlet.xml\";\n\n\t\tif (isMatchingFile(file, liferayHookFile) &&\n\t\t\t!isMatchingFile(file, liferayPortletFile)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"019782f65ccc09de04e3189f4c08bdcf99d28540","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Tree getEntry(String principalName, String accessControlledPath, long index) throws Exception {\n        Tree principalRoot = getPrincipalRoot(principalName);\n        return traverse(principalRoot, accessControlledPath, index);\n    }","id":38333,"modified_method":"protected Tree getEntry(String principalName, String accessControlledPath, long index) throws Exception {\n        Tree principalRoot = getPrincipalRoot(principalName);\n        Tree parent = principalRoot.getChild(PermissionUtil.getEntryName(accessControlledPath));\n        Tree entry = parent.getChild(String.valueOf(index));\n        if (!entry.exists()) {\n            throw new RepositoryException(\"no such entry\");\n        }\n        return entry;\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testModifyRestrictions() throws Exception {\n        Tree testAce = root.getTree(testPath + \"/rep:policy\").getChildren().iterator().next();\n        assertEquals(testPrincipalName, testAce.getProperty(REP_PRINCIPAL_NAME).getValue(Type.STRING));\n\n        // add a new restriction node through the OAK API instead of access control manager\n        NodeUtil node = new NodeUtil(testAce);\n        NodeUtil restrictions = node.addChild(REP_RESTRICTIONS, NT_REP_RESTRICTIONS);\n        restrictions.setString(REP_GLOB, \"*\");\n        String restrictionsPath = restrictions.getTree().getPath();\n        root.commit();\n\n        Tree principalRoot = getPrincipalRoot(testPrincipalName);\n        assertEquals(1, cntEntries(principalRoot));\n        assertEquals(\"*\", principalRoot.getChildren().iterator().next().getProperty(REP_GLOB).getValue(Type.STRING));\n\n        // modify the restrictions node\n        Tree restrictionsNode = root.getTree(restrictionsPath);\n        restrictionsNode.setProperty(REP_GLOB, \"/*/jcr:content/*\");\n        root.commit();\n\n        principalRoot = getPrincipalRoot(testPrincipalName);\n        assertEquals(1, cntEntries(principalRoot));\n        assertEquals(\"/*/jcr:content/*\", principalRoot.getChildren().iterator().next().getProperty(REP_GLOB).getValue(Type.STRING));\n\n        // remove the restriction again\n        root.getTree(restrictionsPath).remove();\n        root.commit();\n\n        principalRoot = getPrincipalRoot(testPrincipalName);\n        assertEquals(1, cntEntries(principalRoot));\n        assertNull(principalRoot.getChildren().iterator().next().getProperty(REP_GLOB));\n    }","id":38334,"modified_method":"@Test\n    public void testModifyRestrictions() throws Exception {\n        Tree testAce = root.getTree(testPath + \"/rep:policy\").getChildren().iterator().next();\n        assertEquals(testPrincipalName, testAce.getProperty(REP_PRINCIPAL_NAME).getValue(Type.STRING));\n\n        // add a new restriction node through the OAK API instead of access control manager\n        NodeUtil node = new NodeUtil(testAce);\n        NodeUtil restrictions = node.addChild(REP_RESTRICTIONS, NT_REP_RESTRICTIONS);\n        restrictions.setString(REP_GLOB, \"*\");\n        String restrictionsPath = restrictions.getTree().getPath();\n        root.commit();\n\n        Tree principalRoot = getPrincipalRoot(testPrincipalName);\n        assertEquals(2, cntEntries(principalRoot));\n        Tree parent = principalRoot.getChildren().iterator().next();\n        assertEquals(\"*\", parent.getChildren().iterator().next().getProperty(REP_GLOB).getValue(Type.STRING));\n\n        // modify the restrictions node\n        Tree restrictionsNode = root.getTree(restrictionsPath);\n        restrictionsNode.setProperty(REP_GLOB, \"/*/jcr:content/*\");\n        root.commit();\n\n        principalRoot = getPrincipalRoot(testPrincipalName);\n        assertEquals(2, cntEntries(principalRoot));\n        parent = principalRoot.getChildren().iterator().next();\n        assertEquals(\"/*/jcr:content/*\", parent.getChildren().iterator().next().getProperty(REP_GLOB).getValue(Type.STRING));\n\n        // remove the restriction again\n        root.getTree(restrictionsPath).remove();\n        root.commit();\n\n        principalRoot = getPrincipalRoot(testPrincipalName);\n        assertEquals(2, cntEntries(principalRoot));\n        parent = principalRoot.getChildren().iterator().next();\n        assertNull(parent.getChildren().iterator().next().getProperty(REP_GLOB));\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testImplicitAceRemoval() throws Exception {\n        AccessControlManager acMgr = getAccessControlManager(root);\n        JackrabbitAccessControlList acl = AccessControlUtils.getAccessControlList(acMgr, testPath);\n        acl.addAccessControlEntry(getTestPrincipal(), privilegesFromNames(JCR_READ, REP_WRITE));\n        acMgr.setPolicy(testPath, acl);\n\n        acl = AccessControlUtils.getAccessControlList(acMgr, childPath);\n        acl.addAccessControlEntry(EveryonePrincipal.getInstance(), privilegesFromNames(JCR_READ));\n        acMgr.setPolicy(childPath, acl);\n        root.commit();\n\n        assertTrue(root.getTree(childPath + \"/rep:policy\").exists());\n\n        Tree principalRoot = getPrincipalRoot(EveryonePrincipal.NAME);\n        assertEquals(2, cntEntries(principalRoot));\n\n        ContentSession testSession = createTestSession();\n        Root testRoot = testSession.getLatestRoot();\n\n        assertTrue(testRoot.getTree(childPath).exists());\n        assertFalse(testRoot.getTree(childPath + \"/rep:policy\").exists());\n\n        testRoot.getTree(childPath).remove();\n        testRoot.commit();\n        testSession.close();\n\n        root.refresh();\n        assertFalse(root.getTree(testPath).hasChild(\"childNode\"));\n        assertFalse(root.getTree(childPath + \"/rep:policy\").exists());\n        // aces must be removed in the permission store even if the editing\n        // session wasn't able to access them.\n        principalRoot = getPrincipalRoot(EveryonePrincipal.NAME);\n        assertEquals(1, cntEntries(principalRoot));\n    }","id":38335,"modified_method":"@Test\n    public void testImplicitAceRemoval() throws Exception {\n        AccessControlManager acMgr = getAccessControlManager(root);\n        JackrabbitAccessControlList acl = AccessControlUtils.getAccessControlList(acMgr, testPath);\n        acl.addAccessControlEntry(getTestPrincipal(), privilegesFromNames(JCR_READ, REP_WRITE));\n        acMgr.setPolicy(testPath, acl);\n\n        acl = AccessControlUtils.getAccessControlList(acMgr, childPath);\n        acl.addAccessControlEntry(EveryonePrincipal.getInstance(), privilegesFromNames(JCR_READ));\n        acMgr.setPolicy(childPath, acl);\n        root.commit();\n\n        assertTrue(root.getTree(childPath + \"/rep:policy\").exists());\n\n        Tree principalRoot = getPrincipalRoot(EveryonePrincipal.NAME);\n        assertEquals(4, cntEntries(principalRoot));\n\n        ContentSession testSession = createTestSession();\n        Root testRoot = testSession.getLatestRoot();\n\n        assertTrue(testRoot.getTree(childPath).exists());\n        assertFalse(testRoot.getTree(childPath + \"/rep:policy\").exists());\n\n        testRoot.getTree(childPath).remove();\n        testRoot.commit();\n        testSession.close();\n\n        root.refresh();\n        assertFalse(root.getTree(testPath).hasChild(\"childNode\"));\n        assertFalse(root.getTree(childPath + \"/rep:policy\").exists());\n        // aces must be removed in the permission store even if the editing\n        // session wasn't able to access them.\n        principalRoot = getPrincipalRoot(EveryonePrincipal.NAME);\n        assertEquals(2, cntEntries(principalRoot));\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void refresh(@Nonnull ImmutableTree permissionsTree,\n                 @Nonnull PrivilegeBitsProvider bitsProvider) {\n        this.bitsProvider = bitsProvider;\n        // test if a permission has been added for those principals that didn't have one before\n        for (Principal principal : principals) {\n            Map<String, Tree> target = getTargetMap(principal);\n            Tree principalRoot = getPrincipalRoot(permissionsTree, principal);\n            String pName = principal.getName();\n            if (principalRoot.exists()) {\n                if (!target.containsKey(pName) || !principalRoot.equals(target.get(pName))) {\n                    target.put(pName, principalRoot);\n                }\n            } else {\n                target.remove(pName);\n            }\n        }\n    }","id":38336,"modified_method":"@Override\n    public void refresh(@Nonnull ImmutableTree permissionsTree,\n                 @Nonnull PrivilegeBitsProvider bitsProvider) {\n        this.bitsProvider = bitsProvider;\n        // test if a permission has been added for those principals that didn't have one before\n        for (Principal principal : principals) {\n            Map<String, Tree> target = getTargetMap(principal);\n            Tree principalRoot = getPrincipalRoot(permissionsTree, principal);\n            String pName = principal.getName();\n            if (principalRoot.exists()) {\n                if (!target.containsKey(pName) || !principalRoot.equals(target.get(pName))) {\n                    target.put(pName, principalRoot);\n                }\n            } else {\n                target.remove(pName);\n            }\n        }\n        // todo, improve flush stores\n        userStore.flush();\n        groupStore.flush();\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean isReadablePath(@Nullable Tree tree, @Nullable String treePath) {\n        if (!readPaths.isEmpty()) {\n            String targetPath = (tree != null) ? tree.getPath() : treePath;\n            if (targetPath != null) {\n                for (String path : readPaths) {\n                    if (Text.isDescendantOrEqual(path, targetPath)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","id":38337,"modified_method":"private boolean isReadablePath(@Nullable Tree tree, @Nullable String treePath) {\n        if (readPathsCheckList.length > 0) {\n            String targetPath = (tree != null) ? tree.getPath() : treePath;\n            if (targetPath != null) {\n                for (int i=0; i<readPathsCheckList.length; i++) {\n                    if (targetPath.equals(readPathsCheckList[i++])) {\n                        return true;\n                    }\n                    if (targetPath.startsWith(readPathsCheckList[i])) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    private Iterator<PermissionEntry> getEntryIterator(@Nonnull EntryPredicate predicate) {\n        Iterator<PermissionEntry> userEntries = (userTrees.isEmpty()) ?\n                Iterators.<PermissionEntry>emptyIterator() :\n                new EntryIterator(userTrees, predicate);\n        Iterator<PermissionEntry> groupEntries = (groupTrees.isEmpty()) ?\n                Iterators.<PermissionEntry>emptyIterator():\n                new EntryIterator(groupTrees, predicate);\n        return Iterators.concat(userEntries, groupEntries);\n    }","id":38338,"modified_method":"@Nonnull\n    private Iterator<PermissionStore.PermissionEntry> getEntryIterator(@Nonnull PermissionStore.EntryPredicate predicate) {\n        Iterator<PermissionStore.PermissionEntry> userEntries = userStore.getEntryIterator(predicate);\n        Iterator<PermissionStore.PermissionEntry> groupEntries = groupStore.getEntryIterator(predicate);\n        return Iterators.concat(userEntries, groupEntries);\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    private PrivilegeBits getPrivilegeBits(@Nullable Tree tree) {\n        EntryPredicate pred = (tree == null) ? new EntryPredicate() : new EntryPredicate(tree, null);\n        Iterator<PermissionEntry> entries = getEntryIterator(pred);\n\n        PrivilegeBits allowBits = PrivilegeBits.getInstance();\n        PrivilegeBits denyBits = PrivilegeBits.getInstance();\n\n        while (entries.hasNext()) {\n            PermissionEntry entry = entries.next();\n            if (entry.isAllow) {\n                allowBits.addDifference(entry.privilegeBits, denyBits);\n            } else {\n                denyBits.addDifference(entry.privilegeBits, allowBits);\n            }\n        }\n\n        // special handling for paths that are always readable\n        if (isReadablePath(tree, null)) {\n            allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\n        }\n        return allowBits;\n    }","id":38339,"modified_method":"@Nonnull\n    private PrivilegeBits getPrivilegeBits(@Nullable Tree tree) {\n        PermissionStore.EntryPredicate pred = (tree == null)\n                ? new PermissionStore.EntryPredicate()\n                : new PermissionStore.EntryPredicate(tree, null);\n        Iterator<PermissionStore.PermissionEntry> entries = getEntryIterator(pred);\n\n        PrivilegeBits allowBits = PrivilegeBits.getInstance();\n        PrivilegeBits denyBits = PrivilegeBits.getInstance();\n\n        while (entries.hasNext()) {\n            PermissionStore.PermissionEntry entry = entries.next();\n            if (entry.isAllow) {\n                allowBits.addDifference(entry.privilegeBits, denyBits);\n            } else {\n                denyBits.addDifference(entry.privilegeBits, allowBits);\n            }\n        }\n\n        // special handling for paths that are always readable\n        if (isReadablePath(tree, null)) {\n            allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\n        }\n        return allowBits;\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isGranted(@Nonnull String path, long permissions) {\n        Iterator<PermissionEntry> it = getEntryIterator(new EntryPredicate(path));\n        return hasPermissions(it, permissions, null, path);\n    }","id":38340,"modified_method":"@Override\n    public boolean isGranted(@Nonnull String path, long permissions) {\n        Iterator<PermissionStore.PermissionEntry> it = getEntryIterator(new PermissionStore.EntryPredicate(path));\n        return hasPermissions(it, permissions, null, path);\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isGranted(long permissions) {\n        return hasPermissions(getEntryIterator(new EntryPredicate()), permissions, null, null);\n    }","id":38341,"modified_method":"@Override\n    public boolean isGranted(long permissions) {\n        return hasPermissions(getEntryIterator(new PermissionStore.EntryPredicate()), permissions, null, null);\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries,\n                                   long permissions, @Nullable Tree tree, @Nullable String path) {\n        // calculate readable paths if the given permissions includes any read permission.\n        boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && isReadablePath(tree, path);\n        if (!entries.hasNext() && !isReadable) {\n            return false;\n        }\n\n        boolean respectParent = (tree != null || path != null) &&\n                (Permissions.includes(permissions, Permissions.ADD_NODE) ||\n                Permissions.includes(permissions, Permissions.REMOVE_NODE) ||\n                Permissions.includes(permissions, Permissions.MODIFY_CHILD_NODE_COLLECTION));\n\n        long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;\n        long denies = Permissions.NO_PERMISSION;\n\n        PrivilegeBits allowBits = PrivilegeBits.getInstance();\n        if (isReadable) {\n            allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\n        }\n        PrivilegeBits denyBits = PrivilegeBits.getInstance();\n        PrivilegeBits parentAllowBits;\n        PrivilegeBits parentDenyBits;\n        String parentPath = null;\n\n        if (respectParent) {\n            parentAllowBits = PrivilegeBits.getInstance();\n            parentDenyBits = PrivilegeBits.getInstance();\n            if (path != null || tree != null) {\n                parentPath = PermissionUtil.getParentPathOrNull((path != null) ? path : tree.getPath());\n            }\n        } else {\n            parentAllowBits = PrivilegeBits.EMPTY;\n            parentDenyBits = PrivilegeBits.EMPTY;\n            parentPath = null;\n        }\n\n        while (entries.hasNext()) {\n            PermissionEntry entry = entries.next();\n            if (respectParent && (parentPath != null)) {\n                boolean matchesParent = entry.matchesParent(parentPath);\n                if (matchesParent) {\n                    if (entry.isAllow) {\n                        parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);\n                    } else {\n                        parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);\n                    }\n                }\n            }\n\n            if (entry.isAllow) {\n                allowBits.addDifference(entry.privilegeBits, denyBits);\n                long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\n                allows |= Permissions.diff(ap, denies);\n                if ((allows | ~permissions) == -1) {\n                    return true;\n                }\n            } else {\n                denyBits.addDifference(entry.privilegeBits, allowBits);\n                long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\n                denies |= Permissions.diff(dp, allows);\n                if (Permissions.includes(denies, permissions)) {\n                    return false;\n                }\n            }\n        }\n\n        return (allows | ~permissions) == -1;\n    }","id":38342,"modified_method":"private boolean hasPermissions(@Nonnull Iterator<PermissionStore.PermissionEntry> entries,\n                                   long permissions, @Nullable Tree tree, @Nullable String path) {\n        // calculate readable paths if the given permissions includes any read permission.\n        boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && isReadablePath(tree, path);\n        if (!entries.hasNext() && !isReadable) {\n            return false;\n        }\n\n        boolean respectParent = (tree != null || path != null) &&\n                (Permissions.includes(permissions, Permissions.ADD_NODE) ||\n                Permissions.includes(permissions, Permissions.REMOVE_NODE) ||\n                Permissions.includes(permissions, Permissions.MODIFY_CHILD_NODE_COLLECTION));\n\n        long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;\n        long denies = Permissions.NO_PERMISSION;\n\n        PrivilegeBits allowBits = PrivilegeBits.getInstance();\n        if (isReadable) {\n            allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\n        }\n        PrivilegeBits denyBits = PrivilegeBits.getInstance();\n        PrivilegeBits parentAllowBits;\n        PrivilegeBits parentDenyBits;\n        String parentPath;\n\n        if (respectParent) {\n            parentAllowBits = PrivilegeBits.getInstance();\n            parentDenyBits = PrivilegeBits.getInstance();\n            parentPath = PermissionUtil.getParentPathOrNull((path != null) ? path : tree.getPath());\n        } else {\n            parentAllowBits = PrivilegeBits.EMPTY;\n            parentDenyBits = PrivilegeBits.EMPTY;\n            parentPath = null;\n        }\n\n        while (entries.hasNext()) {\n            PermissionStore.PermissionEntry entry = entries.next();\n            if (respectParent && (parentPath != null)) {\n                boolean matchesParent = entry.matchesParent(parentPath);\n                if (matchesParent) {\n                    if (entry.isAllow) {\n                        parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);\n                    } else {\n                        parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);\n                    }\n                }\n            }\n\n            if (entry.isAllow) {\n                allowBits.addDifference(entry.privilegeBits, denyBits);\n                long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\n                allows |= Permissions.diff(ap, denies);\n                if ((allows | ~permissions) == -1) {\n                    return true;\n                }\n            } else {\n                denyBits.addDifference(entry.privilegeBits, allowBits);\n                long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\n                denies |= Permissions.diff(dp, allows);\n                if (Permissions.includes(denies, permissions)) {\n                    return false;\n                }\n            }\n        }\n\n        return (allows | ~permissions) == -1;\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isGranted(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\n        Iterator<PermissionEntry> it = getEntryIterator(new EntryPredicate(tree, property));\n        return hasPermissions(it, permissions, tree, null);\n    }","id":38343,"modified_method":"@Override\n    public boolean isGranted(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\n        Iterator<PermissionStore.PermissionEntry> it = getEntryIterator(new PermissionStore.EntryPredicate(tree, property));\n        return hasPermissions(it, permissions, tree, null);\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"CompiledPermissionImpl(@Nonnull Set<Principal> principals,\n                           @Nonnull ImmutableTree permissionsTree,\n                           @Nonnull PrivilegeBitsProvider bitsProvider,\n                           @Nonnull RestrictionProvider restrictionProvider,\n                           @Nonnull Set<String> readPaths) {\n        checkArgument(!principals.isEmpty());\n        this.principals = principals;\n        this.restrictionProvider = restrictionProvider;\n        this.bitsProvider = bitsProvider;\n        this.readPaths = readPaths;\n\n        userTrees = new HashMap<String, Tree>(principals.size());\n        groupTrees = new HashMap<String, Tree>(principals.size());\n        if (permissionsTree.exists()) {\n            for (Principal principal : principals) {\n                Tree t = getPrincipalRoot(permissionsTree, principal);\n                Map<String, Tree> target = getTargetMap(principal);\n                if (t.exists()) {\n                    target.put(principal.getName(), t);\n                } else {\n                    target.remove(principal.getName());\n                }\n            }\n        }\n    }","id":38344,"modified_method":"CompiledPermissionImpl(@Nonnull Set<Principal> principals,\n                           @Nonnull ImmutableTree permissionsTree,\n                           @Nonnull PrivilegeBitsProvider bitsProvider,\n                           @Nonnull RestrictionProvider restrictionProvider,\n                           @Nonnull Set<String> readPaths) {\n        checkArgument(!principals.isEmpty());\n        this.principals = principals;\n        this.restrictionProvider = restrictionProvider;\n        this.bitsProvider = bitsProvider;\n        readPathsCheckList = new String[readPaths.size() * 2];\n        int i=0;\n        for (String p: readPaths) {\n            readPathsCheckList[i++] = p;\n            readPathsCheckList[i++] = p + \"/\";\n        }\n\n        userTrees = new HashMap<String, Tree>(principals.size());\n        groupTrees = new HashMap<String, Tree>(principals.size());\n        if (permissionsTree.exists()) {\n            for (Principal principal : principals) {\n                Tree t = getPrincipalRoot(permissionsTree, principal);\n                Map<String, Tree> target = getTargetMap(principal);\n                if (t.exists()) {\n                    target.put(principal.getName(), t);\n                } else {\n                    target.remove(principal.getName());\n                }\n            }\n        }\n\n        userStore = new PermissionStore(userTrees, restrictionProvider);\n        groupStore = new PermissionStore(groupTrees, restrictionProvider);\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public ReadStatus getReadStatus(@Nonnull Tree tree, @Nullable PropertyState property) {\n        if (isReadablePath(tree, null)) {\n            return ReadStatus.ALLOW_ALL_REGULAR;\n        }\n        long permission = (property == null) ? Permissions.READ_NODE : Permissions.READ_PROPERTY;\n        Iterator<PermissionEntry> it = getEntryIterator(new EntryPredicate(tree, property));\n        while (it.hasNext()) {\n            PermissionEntry entry = it.next();\n            if (entry.readStatus != null) {\n                return entry.readStatus;\n            } else if (entry.privilegeBits.includesRead(permission)) {\n                return (entry.isAllow) ? ReadStatus.ALLOW_THIS : ReadStatus.DENY_THIS;\n            }\n        }\n        return ReadStatus.DENY_THIS;\n    }","id":38345,"modified_method":"@Override\n    public ReadStatus getReadStatus(@Nonnull Tree tree, @Nullable PropertyState property) {\n        if (isReadablePath(tree, null)) {\n            return ReadStatus.ALLOW_ALL_REGULAR;\n        }\n        long permission = (property == null) ? Permissions.READ_NODE : Permissions.READ_PROPERTY;\n        Iterator<PermissionStore.PermissionEntry> it = getEntryIterator(new PermissionStore.EntryPredicate(tree, property));\n        while (it.hasNext()) {\n            PermissionStore.PermissionEntry entry = it.next();\n            if (entry.readStatus != null) {\n                return entry.readStatus;\n            } else if (entry.privilegeBits.includesRead(permission)) {\n                return (entry.isAllow) ? ReadStatus.ALLOW_THIS : ReadStatus.DENY_THIS;\n            }\n        }\n        return ReadStatus.DENY_THIS;\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean childNodeAdded(String name, NodeState after) {\n            if (NodeStateUtils.isHidden(name)) {\n                // ignore hidden nodes\n            } else if (isACL(name, after)) {\n                int index = 0;\n                for (String aceName : getAceNames(after)) {\n                    Tree child = getTree(aceName, after.getChildNode(aceName));\n                    if (isACE(child)) {\n                        PermissionEntry entry = createPermissionEntry(child, index, new AfterNode(parentAfter, name));\n                        entry.add();\n                    }\n                    index++;\n                }\n            } else {\n                Node before = new BeforeNode(parentBefore.getPath(), name, EMPTY_NODE);\n                AfterNode node = new AfterNode(parentAfter, name);\n                after.compareAgainstBaseState(before.getNodeState(), new Diff(before, node));\n            }\n            return true;\n        }","id":38346,"modified_method":"@Override\n        public boolean childNodeAdded(String name, NodeState after) {\n            if (NodeStateUtils.isHidden(name)) {\n                // ignore hidden nodes\n                return true;\n            }\n            String path = parentPath + \"/\" + name;\n            Tree tree = getTree(name, after);\n            if (isACL(tree)) {\n                Acl acl = new Acl(parentPath, name, new AfterNode(path, after));\n                modified.put(acl.accessControlledPath, acl);\n            } else {\n                after.compareAgainstBaseState(EMPTY_NODE, new Diff(path));\n            }\n            return true;\n        }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"BeforeNode(String parentPath, String name, NodeState nodeState) {\n            super(parentPath, name);\n            this.nodeState = nodeState;\n        }","id":38347,"modified_method":"BeforeNode(String parentPath, NodeState nodeState) {\n            super(parentPath);\n            this.nodeState = nodeState;\n        }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private AcEntry(@Nonnull Tree aceTree, @Nonnull String accessControlledPath) {\n            this.accessControlledPath = accessControlledPath;\n            principalName = Text.escapeIllegalJcrChars(checkNotNull(TreeUtil.getString(aceTree, REP_PRINCIPAL_NAME)));\n            privilegeBits = bitsProvider.getBits(TreeUtil.getStrings(aceTree, REP_PRIVILEGES));\n            isAllow = NT_REP_GRANT_ACE.equals(TreeUtil.getPrimaryTypeName(aceTree));\n            restrictions = restrictionProvider.readRestrictions(Strings.emptyToNull(accessControlledPath), aceTree);\n        }","id":38348,"modified_method":"private AcEntry(@Nonnull Tree aceTree, @Nonnull String accessControlledPath, long index) {\n            this.accessControlledPath = accessControlledPath;\n            principalName = Text.escapeIllegalJcrChars(checkNotNull(TreeUtil.getString(aceTree, REP_PRINCIPAL_NAME)));\n            privilegeBits = bitsProvider.getBits(TreeUtil.getStrings(aceTree, REP_PRIVILEGES));\n            isAllow = NT_REP_GRANT_ACE.equals(TreeUtil.getPrimaryTypeName(aceTree));\n            restrictions = restrictionProvider.readRestrictions(Strings.emptyToNull(accessControlledPath), aceTree);\n            this.index = index;\n        }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean childNodeChanged(String name, final NodeState before, NodeState after) {\n            if (NodeStateUtils.isHidden(name)) {\n                // ignore hidden nodes\n            } else if (isACL(name, before) || isACL(name, after)) {\n                List<AcEntry> entriesBefore = createEntries(new BeforeNode(parentBefore, name, before));\n                List<AcEntry> entriesAfter = createEntries(new AfterNode(parentAfter, name));\n\n                for (int indexBefore = 0; indexBefore < entriesBefore.size(); indexBefore++) {\n                    AcEntry ace = entriesBefore.get(indexBefore);\n                    if (entriesAfter.isEmpty() || !entriesAfter.contains(ace)) {\n                        new PermissionEntry(ace, indexBefore).remove();\n                    }\n                }\n\n                List<PermissionEntry> toRemove = new ArrayList<PermissionEntry>();\n                List<PermissionEntry> toAdd = new ArrayList<PermissionEntry>();\n                for (int indexAfter = 0; indexAfter < entriesAfter.size(); indexAfter++) {\n                    AcEntry ace = entriesAfter.get(indexAfter);\n                    int indexBefore = entriesBefore.indexOf(ace);\n                    if (indexBefore == -1) {\n                        toAdd.add(new PermissionEntry(ace, indexAfter));\n                    } else if (indexBefore != indexAfter) {\n                        toRemove.add(new PermissionEntry(entriesBefore.get(indexBefore), indexBefore));\n                        toAdd.add(new PermissionEntry(ace, indexAfter));\n                    } // else: nothing to do\n                }\n                for (PermissionEntry pe : toRemove) {\n                    pe.remove();\n                }\n                for (PermissionEntry pe : toAdd) {\n                    pe.add();\n                }\n            } else {\n                BeforeNode nodeBefore = new BeforeNode(parentBefore.getPath(), name, before);\n                AfterNode nodeAfter = new AfterNode(parentAfter, name);\n                after.compareAgainstBaseState(before, new Diff(nodeBefore, nodeAfter));\n            }\n            return true;\n        }","id":38349,"modified_method":"@Override\n        public boolean childNodeChanged(String name, NodeState before, NodeState after) {\n            if (NodeStateUtils.isHidden(name)) {\n                // ignore hidden nodes\n                return true;\n            }\n            String path = parentPath + \"/\" + name;\n            Tree beforeTree = getTree(name, before);\n            Tree afterTree = getTree(name, after);\n            if (isACL(beforeTree)) {\n                if (isACL(afterTree)) {\n                    Acl acl = new Acl(parentPath, name, new AfterNode(path, after));\n                    modified.put(acl.accessControlledPath, acl);\n\n                    // also consider to remove the ACL from removed entries of other principals\n                    Acl beforeAcl = new Acl(parentPath, name, new BeforeNode(path, before));\n                    beforeAcl.entries.keySet().removeAll(acl.entries.keySet());\n                    if (!beforeAcl.entries.isEmpty()) {\n                        deleted.put(parentPath, beforeAcl);\n                    }\n\n                } else {\n                    Acl acl = new Acl(parentPath, name, new BeforeNode(path, before));\n                    deleted.put(acl.accessControlledPath, acl);\n                }\n            } else if (isACL(afterTree)) {\n                Acl acl = new Acl(parentPath, name, new AfterNode(path, after));\n                modified.put(acl.accessControlledPath, acl);\n            } else {\n                after.compareAgainstBaseState(before, new Diff(path));\n            }\n            return true;\n        }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private AfterNode(String parentPath, String name, NodeState state) {\n            super(parentPath, name);\n            this.builder = state.builder();\n        }","id":38350,"modified_method":"private AfterNode(String path, NodeState state) {\n            super(path);\n            this.builder = state.builder();\n        }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean childNodeDeleted(String name, NodeState before) {\n            if (NodeStateUtils.isHidden(name)) {\n                // ignore hidden nodes\n            } else if (isACL(name, before)) {\n                int index = 0;\n                for (String aceName : getAceNames(before)) {\n                    Tree child = getTree(aceName, before.getChildNode(aceName));\n                    if (isACE(child)) {\n                        PermissionEntry entry = createPermissionEntry(child, index,\n                                new BeforeNode(parentBefore, name, before));\n                        entry.remove();\n                    }\n                    index++;\n                }\n            } else {\n                BeforeNode nodeBefore = new BeforeNode(parentBefore.getPath(), name, before);\n                AfterNode after = new AfterNode(parentAfter.getPath(), name, EMPTY_NODE);\n                after.getNodeState().compareAgainstBaseState(before, new Diff(nodeBefore, after));\n            }\n            return true;\n        }","id":38351,"modified_method":"@Override\n        public boolean childNodeDeleted(String name, NodeState before) {\n            if (NodeStateUtils.isHidden(name)) {\n                // ignore hidden nodes\n                return true;\n            }\n            String path = parentPath + \"/\" + name;\n            Tree tree = getTree(name, before);\n            if (isACL(tree)) {\n                Acl acl = new Acl(parentPath, name, new BeforeNode(path, before));\n                deleted.put(acl.accessControlledPath, acl);\n            } else {\n                EMPTY_NODE.compareAgainstBaseState(before, new Diff(path));\n            }\n            return true;\n        }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public NodeState processCommit(final NodeState before, NodeState after) throws CommitFailedException {\n        NodeBuilder rootAfter = after.builder();\n\n        permissionRoot = getPermissionRoot(rootAfter);\n        ntMgr = ReadOnlyNodeTypeManager.getInstance(before);\n        bitsProvider = new PrivilegeBitsProvider(new ImmutableRoot(before));\n\n        after.compareAgainstBaseState(before, new Diff(new BeforeNode(before), new AfterNode(rootAfter)));\n        return rootAfter.getNodeState();\n    }","id":38352,"modified_method":"@Nonnull\n    @Override\n    public NodeState processCommit(final NodeState before, NodeState after) throws CommitFailedException {\n        NodeBuilder rootAfter = after.builder();\n\n        permissionRoot = getPermissionRoot(rootAfter);\n        ntMgr = ReadOnlyNodeTypeManager.getInstance(before);\n        bitsProvider = new PrivilegeBitsProvider(new ImmutableRoot(before));\n\n        Diff diff = new Diff(\"\");\n        after.compareAgainstBaseState(before, diff);\n        apply();\n        return rootAfter.getNodeState();\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    public static String getParentPathOrNull(@Nonnull String path) {\n        return (PathUtils.denotesRoot(path) || path.isEmpty()) ? null : Text.getRelativeParent(path, 1);\n    }","id":38353,"modified_method":"@CheckForNull\n    public static String getParentPathOrNull(@Nonnull final String path) {\n        if (path.length() <= 1) {\n            return null;\n        } else {\n            int idx = path.lastIndexOf('/');\n            if (idx == 0) {\n                return \"/\";\n            } else {\n                return path.substring(0, idx);\n            }\n        }\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void assertEntry(final int index, final boolean isAllow) throws RepositoryException {\n        AccessControlEntry first = AccessControlUtils.getAccessControlList(superuser, path).getAccessControlEntries()[index];\n\n        assertEquals(testUser.getPrincipal(), first.getPrincipal());\n\n        Node n = superuser.getNode(\"/jcr:system/rep:permissionStore/default/\" + testUser.getPrincipal().getName());\n        TraversingItemVisitor v = new TraversingItemVisitor.Default(true, -1) {\n            @Override\n            protected void entering(Node node, int level) throws RepositoryException {\n                if (node.isNodeType(\"rep:Permissions\") && path.equals(node.getProperty(\"rep:accessControlledPath\").getString())) {\n                    assertEquals(index, node.getProperty(\"rep:index\").getLong());\n                    assertEquals(isAllow, node.getProperty(\"rep:isAllow\").getBoolean());\n                }\n            }\n        };\n        v.visit(n);\n    }","id":38354,"modified_method":"private void assertEntry(final int index, final boolean isAllow) throws RepositoryException {\n        AccessControlEntry first = AccessControlUtils.getAccessControlList(superuser, path).getAccessControlEntries()[index];\n\n        assertEquals(testUser.getPrincipal(), first.getPrincipal());\n\n        Node n = superuser.getNode(\"/jcr:system/rep:permissionStore/default/\" + testUser.getPrincipal().getName());\n        TraversingItemVisitor v = new TraversingItemVisitor.Default(true, -1) {\n            @Override\n            protected void entering(Node node, int level) throws RepositoryException {\n                if (node.isNodeType(\"rep:Permissions\")\n                        && node.hasProperty(\"rep:accessControlledPath\")\n                        && path.equals(node.getProperty(\"rep:accessControlledPath\").getString())) {\n                    assertEquals(index, node.getProperty(\"rep:index\").getLong());\n                    assertEquals(isAllow, node.getProperty(\"rep:isAllow\").getBoolean());\n                }\n            }\n        };\n        v.visit(n);\n    }","commit_id":"41cbc4fa38c77c36725ea9094a703132b9d6cd27","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Since we keep track of an explicit base node state for a\n     * {@link ModifiedNodeState} instance, we can do this in two steps:\n     * first compare the base states to each other (often a fast operation),\n     * ignoring all changed properties and child nodes for which we have\n     * further modifications, and then compare all the modified properties\n     * and child nodes to those in the given base state.\n     */\n    @Override\n    public void compareAgainstBaseState(\n            NodeState base, final NodeStateDiff diff) {\n        if (this.base != base) {\n            this.base.compareAgainstBaseState(base, new NodeStateDiff() {\n                @Override\n                public void propertyAdded(PropertyState after) {\n                    if (!properties.containsKey(after.getName())) {\n                        diff.propertyAdded(after);\n                    }\n                }\n                @Override\n                public void propertyChanged(\n                        PropertyState before, PropertyState after) {\n                    if (!properties.containsKey(before.getName())) {\n                        diff.propertyChanged(before, after);\n                    }\n                }\n                @Override\n                public void propertyDeleted(PropertyState before) {\n                    if (!properties.containsKey(before.getName())) {\n                        diff.propertyDeleted(before);\n                    }\n                }\n                @Override\n                public void childNodeAdded(String name, NodeState after) {\n                    if (!nodes.containsKey(name)) {\n                        diff.childNodeAdded(name, after);\n                    }\n                }\n                @Override\n                public void childNodeChanged(String name, NodeState before, NodeState after) {\n                    if (!nodes.containsKey(name)) {\n                        diff.childNodeChanged(name, before, after);\n                    }\n                }\n                @Override\n                public void childNodeDeleted(String name, NodeState before) {\n                    if (!nodes.containsKey(name)) {\n                        diff.childNodeDeleted(name, before);\n                    }\n                }\n            });\n        }\n\n        for (Map.Entry<String, ? extends PropertyState> entry : properties.entrySet()) {\n            PropertyState before = base.getProperty(entry.getKey());\n            PropertyState after = entry.getValue();\n            if (before == null && after == null) {\n                // do nothing\n            } else if (after == null) {\n                diff.propertyDeleted(before);\n            } else if (before == null) {\n                diff.propertyAdded(after);\n            } else if (!before.equals(after)) {\n                diff.propertyChanged(before, after);\n            }\n        }\n\n        for (Map.Entry<String, ? extends NodeState> entry : nodes.entrySet()) {\n            String name = entry.getKey();\n            NodeState before = base.getChildNode(name);\n            NodeState after = entry.getValue();\n            if (after == null) {\n                if (before.exists()) {\n                    diff.childNodeDeleted(name, before);\n                }\n            } else if (!before.exists()) {\n                diff.childNodeAdded(name, after);\n            } else if (!before.equals(after)) {\n                diff.childNodeChanged(name, before, after);\n            }\n        }\n    }","id":38355,"modified_method":"/**\n     * Since we keep track of an explicit base node state for a\n     * {@link ModifiedNodeState} instance, we can do this in two steps:\n     * first compare the base states to each other (often a fast operation),\n     * ignoring all changed properties and child nodes for which we have\n     * further modifications, and then compare all the modified properties\n     * and child nodes to those in the given base state.\n     */\n    @Override\n    public void compareAgainstBaseState(\n            NodeState base, final NodeStateDiff diff) {\n        this.base.compareAgainstBaseState(base, new NodeStateDiff() {\n            @Override\n            public void propertyAdded(PropertyState after) {\n                if (!properties.containsKey(after.getName())) {\n                    diff.propertyAdded(after);\n                }\n            }\n            @Override\n            public void propertyChanged(\n                    PropertyState before, PropertyState after) {\n                if (!properties.containsKey(before.getName())) {\n                    diff.propertyChanged(before, after);\n                }\n            }\n            @Override\n            public void propertyDeleted(PropertyState before) {\n                if (!properties.containsKey(before.getName())) {\n                    diff.propertyDeleted(before);\n                }\n            }\n            @Override\n            public void childNodeAdded(String name, NodeState after) {\n                if (!nodes.containsKey(name)) {\n                    diff.childNodeAdded(name, after);\n                }\n            }\n            @Override\n            public void childNodeChanged(String name, NodeState before, NodeState after) {\n                if (!nodes.containsKey(name)) {\n                    diff.childNodeChanged(name, before, after);\n                }\n            }\n            @Override\n            public void childNodeDeleted(String name, NodeState before) {\n                if (!nodes.containsKey(name)) {\n                    diff.childNodeDeleted(name, before);\n                }\n            }\n        });\n\n        for (Map.Entry<String, ? extends PropertyState> entry : properties.entrySet()) {\n            PropertyState before = base.getProperty(entry.getKey());\n            PropertyState after = entry.getValue();\n            if (before == null && after == null) {\n                // do nothing\n            } else if (after == null) {\n                diff.propertyDeleted(before);\n            } else if (before == null) {\n                diff.propertyAdded(after);\n            } else if (!before.equals(after)) {\n                diff.propertyChanged(before, after);\n            }\n        }\n\n        for (Map.Entry<String, ? extends NodeState> entry : nodes.entrySet()) {\n            String name = entry.getKey();\n            NodeState before = base.getChildNode(name);\n            NodeState after = entry.getValue();\n            if (after == null) {\n                if (before.exists()) {\n                    diff.childNodeDeleted(name, before);\n                }\n            } else if (!before.exists()) {\n                diff.childNodeAdded(name, after);\n            } else if (!before.equals(after)) {\n                diff.childNodeChanged(name, before, after);\n            }\n        }\n    }","commit_id":"2e70d98f28c8d0216119dde4c301cf1c9d0ae000","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        NodeBuilder rootBuilder = after.getBuilder();\n        NodeBuilder builder = rootBuilder;\n        for (String name : elements(index.getPath())) {\n            builder = builder.getChildBuilder(name);\n        }\n        builder = builder.getChildBuilder(INDEX_DATA_CHILD_NAME);\n        Directory directory = new ReadWriteOakDirectory(builder);\n\n        try {\n            IndexWriter writer = new IndexWriter(directory, config);\n            try {\n                LuceneDiff diff = new LuceneDiff(writer, \"/\");\n                if (before != null) {\n                    // normal diff\n                    after.compareAgainstBaseState(before, diff);\n                } else {\n                    // trigger re-indexing\n                    diff.childNodeAdded(\"\", after);\n                }\n\n                diff.postProcess(after);\n                writer.commit();\n                builder.setProperty(INDEX_UPDATE,\n                        new LongValue(System.currentTimeMillis()));\n            } finally {\n                writer.close();\n            }\n            return rootBuilder.getNodeState();\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new CommitFailedException(\n                    \"Failed to update the full text search index\", e);\n        }\n    }","id":38356,"modified_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        NodeBuilder rootBuilder = after.getBuilder();\n        NodeBuilder builder = rootBuilder;\n        for (String name : elements(index.getPath())) {\n            builder = builder.getChildBuilder(name);\n        }\n        builder = builder.getChildBuilder(INDEX_DATA_CHILD_NAME);\n        Directory directory = new ReadWriteOakDirectory(builder);\n\n        try {\n            IndexWriter writer = new IndexWriter(directory, config);\n            try {\n                LuceneDiff diff = new LuceneDiff(writer, \"/\");\n                after.compareAgainstBaseState(before, diff);\n                diff.postProcess(after);\n            } finally {\n                writer.close();\n                builder.setProperty(INDEX_UPDATE,\n                        new LongValue(System.currentTimeMillis()));\n            }\n            return rootBuilder.getNodeState();\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new CommitFailedException(\n                    \"Failed to update the full text search index\", e);\n        }\n    }","commit_id":"2e0c8be32289e4f2ff0a986c7feeb29dd6ffc4e7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n\n        List<IndexDefinition> defsBefore = IndexUtils.buildIndexDefinitions(\n                before, indexConfigPath, TYPE);\n        List<IndexDefinition> defsAfter = IndexUtils.buildIndexDefinitions(\n                after, indexConfigPath, TYPE);\n\n        // TODO add a more fine-grained change verifier\n        List<IndexDefinition> defsChanged = new ArrayList<IndexDefinition>();\n        for (IndexDefinition def : defsAfter) {\n            if (!defsBefore.contains(def)) {\n                defsChanged.add(def);\n            }\n            // verify initial state or forced reindex\n            if (def.getProperties().get(INDEX_UPDATE) == null) {\n                defsChanged.add(def);\n            }\n        }\n        if (defsChanged.isEmpty()) {\n            return after;\n        }\n        LOG.debug(\"found {} updated index definitions ({})\",\n                defsChanged.size(), defsChanged);\n        LOG.debug(\"reindexing repository content\");\n        long t = System.currentTimeMillis();\n        // TODO buffer content reindex\n        List<CommitHook> hooks = new ArrayList<CommitHook>();\n        for (IndexDefinition def : defsChanged) {\n            hooks.add(new LuceneEditor(def));\n        }\n        NodeState done = CompositeHook.compose(hooks).processCommit(null, after);\n        LOG.debug(\"done reindexing repository content in {} ms.\",\n                System.currentTimeMillis() - t);\n        return done;\n    }","id":38357,"modified_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n\n        List<IndexDefinition> defsBefore = IndexUtils.buildIndexDefinitions(\n                before, indexConfigPath, TYPE);\n        List<IndexDefinition> defsAfter = IndexUtils.buildIndexDefinitions(\n                after, indexConfigPath, TYPE);\n\n        // TODO add a more fine-grained change verifier\n        List<IndexDefinition> defsChanged = new ArrayList<IndexDefinition>();\n        for (IndexDefinition def : defsAfter) {\n            if (!defsBefore.contains(def)) {\n                defsChanged.add(def);\n            }\n            // verify initial state or forced reindex\n            if (def.getProperties().get(INDEX_UPDATE) == null) {\n                defsChanged.add(def);\n            }\n        }\n        if (defsChanged.isEmpty()) {\n            return after;\n        }\n        LOG.debug(\"found {} updated index definitions ({})\",\n                defsChanged.size(), defsChanged);\n        LOG.debug(\"reindexing repository content\");\n        long t = System.currentTimeMillis();\n        // TODO buffer content reindex\n        List<CommitHook> hooks = new ArrayList<CommitHook>();\n        for (IndexDefinition def : defsChanged) {\n            hooks.add(new LuceneEditor(def));\n        }\n        NodeState done = CompositeHook.compose(hooks).processCommit(\n                MemoryNodeState.EMPTY_NODE, after);\n        LOG.debug(\"done reindexing repository content in {} ms.\",\n                System.currentTimeMillis() - t);\n        return done;\n    }","commit_id":"2e0c8be32289e4f2ff0a986c7feeb29dd6ffc4e7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void compareOldRevision() throws Exception {\n        FileStore fileStoreV10 = new FileStore(directory, 1) {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public SegmentVersion getVersion() {\n                return SegmentVersion.V_10;\n            }\n        };\n        try {\n            NodeState content = addTestContent(fileStoreV10).getChildNode(\"content\");\n            NodeBuilder builder = content.builder();\n            builder.setChildNode(\"foo\");\n            JsopDiff diff = new JsopDiff();\n            content.compareAgainstBaseState(builder.getNodeState(), diff);\n            assertEquals(\"-\\\"/foo\\\"\", diff.toString());\n        } finally {\n            fileStoreV10.close();\n        }\n    }","id":38358,"modified_method":"@Test\n    public void compareOldRevision() throws Exception {\n        FileStore fileStoreV10 = new FileStore(directory, 1) {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public SegmentVersion getVersion() {\n                return SegmentVersion.V_10;\n            }\n        };\n        try {\n            NodeState content = addTestContent(fileStoreV10).getChildNode(\"content\");\n            NodeBuilder builder = content.builder();\n            builder.setChildNode(\"foo\");\n            content.compareAgainstBaseState(builder.getNodeState(), new NodeStateDiff() {\n                @Override\n                public boolean propertyAdded(PropertyState after) {\n                    fail();\n                    return false;\n                }\n\n                @Override\n                public boolean propertyChanged(PropertyState before, PropertyState after) {\n                    fail();\n                    return false;\n                }\n\n                @Override\n                public boolean propertyDeleted(PropertyState before) {\n                    fail();\n                    return false;\n                }\n\n                @Override\n                public boolean childNodeAdded(String name, NodeState after) {\n                    fail();\n                    return false;\n                }\n\n                @Override\n                public boolean childNodeChanged(String name, NodeState before, NodeState after) {\n                    fail();\n                    return false;\n                }\n\n                @Override\n                public boolean childNodeDeleted(String name, NodeState before) {\n                    assertEquals(\"foo\", name);\n                    return false;\n                }\n            });\n        } finally {\n            fileStoreV10.close();\n        }\n    }","commit_id":"f18ebc2d838bc2648716862fda3e4ff7a9c4c5e8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n   * Tests package installation.\n   * @throws BaseXException database exception\n   */\n  @Test\n  public void testRepoInstall() throws BaseXException {\n    // Try to install non-existing package\n    try {\n      new RepoManager(ctx).install(\"etc/pkg\", null);\n      fail(\"Not existing package not detected.\");\n    } catch(final QueryException ex) {\n      check(ex, Err.PKGNOTEXIST);\n    }\n    // Try to install a package\n    new RepoInstall(\"etc/repo/pkg3.xar\", null).execute(ctx);\n    final File pkgDir = new File(\"etc/repo/pkg3\");\n    assertTrue(pkgDir.exists());\n    assertTrue(pkgDir.isDirectory());\n    final File pkgDesc = new File(\"etc/repo/pkg3/expath-pkg.xml\");\n    assertTrue(pkgDesc.exists());\n    final File modDir1 = new File(\"etc/repo/pkg3/pkg3\");\n    assertTrue(modDir1.exists());\n    assertTrue(modDir1.isDirectory());\n    final File modDir2 = new File(\"etc/repo/pkg3/pkg3/mod\");\n    assertTrue(modDir2.exists());\n    assertTrue(modDir2.isDirectory());\n    final File modFile = new File(\"etc/repo/pkg3/pkg3/mod/pkg3mod1.xql\");\n    assertTrue(modFile.exists());\n\n    // Delete pkg3\n    new RepoDelete(\"pkg3\", null).execute(ctx);\n    // Assert that pkg3 was unregistered from repo\n    assertTrue(ctx.repo.pkgDict().id(token(\"pkg3-10.0\")) == 0);\n    // Assert that directory for pkg3 was deleted\n    assertTrue(!pkgDir.exists());\n  }","id":38359,"modified_method":"/**\n   * Tests package installation.\n   * @throws BaseXException database exception\n   */\n  @Test\n  public void testRepoInstall() throws BaseXException {\n    // Try to install non-existing package\n    try {\n      new RepoManager(ctx).install(\"etc/pkg\", null);\n      fail(\"Not existing package not detected.\");\n    } catch(final QueryException ex) {\n      check(ex, Err.PKGNOTEXIST);\n    }\n    // Try to install a package\n    new RepoInstall(\"etc/repo/pkg3.xar\", null).execute(ctx);\n    final File pkgDir = new File(\"etc/repo/pkg3\");\n    assertTrue(pkgDir.exists());\n    assertTrue(pkgDir.isDirectory());\n    final File pkgDesc = new File(\"etc/repo/pkg3/expath-pkg.xml\");\n    assertTrue(pkgDesc.exists());\n    final File modDir1 = new File(\"etc/repo/pkg3/pkg3\");\n    assertTrue(modDir1.exists());\n    assertTrue(modDir1.isDirectory());\n    final File modDir2 = new File(\"etc/repo/pkg3/pkg3/mod\");\n    assertTrue(modDir2.exists());\n    assertTrue(modDir2.isDirectory());\n    final File modFile = new File(\"etc/repo/pkg3/pkg3/mod/pkg3mod1.xql\");\n    assertTrue(modFile.exists());\n\n    // Delete package\n    modFile.delete();\n    modDir2.delete();\n    modDir1.delete();\n    pkgDesc.delete();\n    pkgDir.delete();\n\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Prepare test. */\n  @BeforeClass\n  public static void setUpBeforeClass() {\n    ctx = new Context();\n    ctx.repo.init(\"etc/repo\");\n  }","id":38360,"modified_method":"/** Prepare test. */\n  @Before\n  public void setUpBeforeClass() {\n    ctx = new Context();\n    ctx.repo.init(\"etc/repo\");\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() throws IOException {\n    final Table t = new Table();\n    t.header.add(\"Package\");\n    t.header.add(\"Version\");\n\n    for(final byte[] p : context.repo.pkgDict().keys()) {\n      if(p != null) {\n        final TokenList tl = new TokenList();\n        tl.add(string(Package.getName(p)));\n        tl.add(string(Package.getVersion(p)));\n        t.contents.add(tl);\n      }\n    }\n    t.sort();\n    out.println(t.finish());\n    return true;\n  }","id":38361,"modified_method":"@Override\n  protected boolean run() throws IOException {\n    final Table t = new Table();\n    t.header.add(\"Package\");\n    t.header.add(\"Version\");\n\n    for(final byte[] p : context.repo.pkgDict()) {\n      if(p != null) {\n        final TokenList tl = new TokenList();\n        tl.add(string(Package.getName(p)));\n        tl.add(string(Package.getVersion(p)));\n        t.contents.add(tl);\n      }\n    }\n    t.sort();\n    out.println(t.finish());\n    return true;\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Installs a new package.\n   * @param path package path\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public synchronized void install(final String path, final InputInfo ii)\n      throws QueryException {\n\n    // Check repository\n    createRepo();\n    // Check package existence\n    final File pkgFile = new File(path);\n    if(!pkgFile.exists()) PKGNOTEXIST.thrw(ii, path);\n    // Check package name - must be a .xar file\n    checkPkgName(path, ii);\n\n    try {\n      final ZipFile xar = new ZipFile(pkgFile);\n      final byte[] cont = FNZip.read(xar, DESCRIPTOR);\n      final Package pkg = new PkgParser(context, ii).parse(new IOContent(cont));\n      new PkgValidator(context, ii).check(pkg);\n      unzip(xar);\n      updateRepo(pkg, extractPkgName(xar.getName()));\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      throw PKGREADFAIL.thrw(ii, ex.getMessage());\n    }\n  }","id":38362,"modified_method":"/**\n   * Installs a new package.\n   * @param path package path\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public void install(final String path, final InputInfo ii)\n      throws QueryException {\n\n    // Check repository\n    createRepo();\n    // Check package existence\n    final File pkgFile = new File(path);\n    if(!pkgFile.exists()) PKGNOTEXIST.thrw(ii, path);\n    // Check package name - must be a .xar file\n    checkPkgName(path, ii);\n\n    try {\n      final ZipFile xar = new ZipFile(pkgFile);\n      final byte[] cont = FNZip.read(xar, DESCRIPTOR);\n      final Package pkg = new PkgParser(ctx, ii).parse(new IOContent(cont));\n      new PkgValidator(ctx, ii).check(pkg);\n      unzip(xar);\n      ctx.repo.add(pkg, extractPkgName(xar.getName()));\n    } catch(final IOException ex) {\n      Util.debug(ex);\n      throw PKGREADFAIL.thrw(ii, ex.getMessage());\n    }\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param ctx database context\n   */\n  public RepoManager(final Context ctx) {\n    context = ctx;\n  }","id":38363,"modified_method":"/**\n   * Constructor.\n   * @param c database context\n   */\n  public RepoManager(final Context c) {\n    ctx = c;\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Deletes a package recursively.\n   * @param dir package directory\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  private void deletePkg(final File dir, final InputInfo ii)\n      throws QueryException {\n    final File[] files = dir.listFiles();\n    if(files != null) for(final File f : files)\n      deletePkg(f, ii);\n    if(!dir.delete()) CANNOTDELPKG.thrw(ii);\n  }","id":38364,"modified_method":"/**\n   * Deletes a package recursively.\n   * @param dir package directory\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  private void deleteFromDisc(final File dir, final InputInfo ii)\n      throws QueryException {\n    final File[] files = dir.listFiles();\n    if(files != null) for(final File f : files) deleteFromDisc(f, ii);\n    if(!dir.delete()) CANNOTDELPKG.thrw(ii);\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Removes a package from package repository.\n   * @param pkg package\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public synchronized void delete(final String pkg, final InputInfo ii)\n      throws QueryException {\n    for(final byte[] nextPkg : context.repo.pkgDict().keys()) {\n      if(nextPkg != null) {\n        final byte[] dir = context.repo.pkgDict().get(nextPkg);\n        if(eq(Package.getName(nextPkg), token(pkg)) || eq(dir, token(pkg))) {\n          // A package can be deleted either by its name or by its directory\n          // name\n          final byte[] primPkg = getPrimary(nextPkg, ii);\n          if(primPkg == null) {\n            // Clean package repository\n            cleanRepo(nextPkg, dir, ii);\n            // Package does not participate in a dependency => delete it\n            deletePkg(new File(context.prop.get(Prop.REPOPATH), string(dir)),\n                ii);\n          } else {\n            PKGDEP.thrw(ii, string(primPkg), pkg);\n          }\n        }\n      }\n    }\n  }","id":38365,"modified_method":"/**\n   * Removes a package from package repository.\n   * @param pkg package\n   * @param ii input info\n   * @throws QueryException query exception\n   */\n  public void delete(final String pkg, final InputInfo ii)\n      throws QueryException {\n    for(final byte[] nextPkg : ctx.repo.pkgDict()) {\n      if(nextPkg != null) {\n        final byte[] dir = ctx.repo.pkgDict().get(nextPkg);\n        if(eq(Package.getName(nextPkg), token(pkg)) || eq(dir, token(pkg))) {\n          // A package can be deleted either by its name or by its directory\n          // name\n          final byte[] primPkg = getPrimary(nextPkg, ii);\n          if(primPkg == null) {\n            // Clean package repository\n            final File f = new File(ctx.prop.get(Prop.REPOPATH), string(dir));\n            final File desc = new File(f, DESCRIPTOR);\n            ctx.repo.remove(new PkgParser(ctx, ii).parse(new IOFile(desc)));\n            // Package does not participate in a dependency => delete it\n            deleteFromDisc(f, ii);\n          } else {\n            PKGDEP.thrw(ii, string(primPkg), pkg);\n          }\n        }\n      }\n    }\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks if a package participates in a dependency.\n   * @param pkgName package\n   * @param ii input info\n   * @return package depending on the current one\n   * @throws QueryException query exception\n   */\n  private byte[] getPrimary(final byte[] pkgName, final InputInfo ii)\n      throws QueryException {\n    for(final byte[] nextPkg : context.repo.pkgDict().keys()) {\n      if(nextPkg != null && !eq(nextPkg, pkgName)) {\n        // Check only packages different from the current one\n        final File pkgDesc = new File(new File(context.prop.get(Prop.REPOPATH),\n            string(context.repo.pkgDict().get(nextPkg))), DESCRIPTOR);\n        final IOFile io = new IOFile(pkgDesc);\n        final Package pkg = new PkgParser(context, ii).parse(io);\n        for(final Dependency dep : pkg.dep)\n          if(eq(dep.pkg, Package.getName(pkgName)))\n            return Package.getName(nextPkg);\n      }\n    }\n    return null;\n  }","id":38366,"modified_method":"/**\n   * Checks if a package participates in a dependency.\n   * @param pkgName package\n   * @param ii input info\n   * @return package depending on the current one\n   * @throws QueryException query exception\n   */\n  private byte[] getPrimary(final byte[] pkgName, final InputInfo ii)\n      throws QueryException {\n    for(final byte[] nextPkg : ctx.repo.pkgDict()) {\n      if(nextPkg != null && !eq(nextPkg, pkgName)) {\n        // Check only packages different from the current one\n        final File desc = new File(new File(ctx.prop.get(Prop.REPOPATH),\n            string(ctx.repo.pkgDict().get(nextPkg))), DESCRIPTOR);\n        final Package pkg = new PkgParser(ctx, ii).parse(new IOFile(desc));\n        for(final Dependency dep : pkg.dep)\n          if(eq(dep.pkg, Package.getName(pkgName)))\n            return Package.getName(nextPkg);\n      }\n    }\n    return null;\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the path to the repository.\n   * @return repository path\n   */\n  private File repoPath() {\n    return new File(context.prop.get(Prop.REPOPATH));\n  }","id":38367,"modified_method":"/**\n   * Returns the path to the repository.\n   * @return repository path\n   */\n  private File repoPath() {\n    return new File(ctx.prop.get(Prop.REPOPATH));\n  }","commit_id":"c1d3320c3bfeb7b436baf63e8d005b2e4212c5fe","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected static GrailsMethodExpression create(final GrailsApplication application,Class clazz, String queryParameter) {\n\t\t\tif(queryParameter.endsWith( LESS_THAN_OR_EQUAL )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, LESS_THAN_OR_EQUAL),\n\t\t\t\t\t\tLESS_THAN_OR_EQUAL,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tisNegation(queryParameter, LESS_THAN_OR_EQUAL) ) {\n\t\t\t\t\tCriterion createCriterion() {\n\t\t\t\t\t\treturn Restrictions.le( this.propertyName, arguments[0] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(queryParameter.endsWith( LESS_THAN )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, LESS_THAN),\n\t\t\t\t\t\tLESS_THAN,\n\t\t\t\t\t\t1, // argument count\n\t\t\t\t\t\tisNegation(queryParameter, LESS_THAN) ) {\n\t\t\t\t\tCriterion createCriterion() {\n                        if(arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.lt( this.propertyName, arguments[0] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(queryParameter.endsWith( GREATER_THAN_OR_EQUAL )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, GREATER_THAN_OR_EQUAL),\n\t\t\t\t\t\tGREATER_THAN_OR_EQUAL,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tisNegation(queryParameter, GREATER_THAN_OR_EQUAL) ) {\n\t\t\t\t\tCriterion createCriterion() {\n                        if(arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.ge( this.propertyName, arguments[0] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(queryParameter.endsWith( GREATER_THAN )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, GREATER_THAN),\n\t\t\t\t\t\tGREATER_THAN,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tisNegation(queryParameter, GREATER_THAN) ) {\n\t\t\t\t\tCriterion createCriterion() {\n                        if(arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.gt( this.propertyName, arguments[0] );\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(queryParameter.endsWith( LIKE )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, LIKE),\n\t\t\t\t\t\tLIKE,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tisNegation(queryParameter, LIKE) ) {\n\t\t\t\t\tCriterion createCriterion() {\n                        if(arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.like( this.propertyName, arguments[0] );\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n            else if(queryParameter.endsWith( ILIKE )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, ILIKE),\n                        ILIKE,\n                        1,\n                        isNegation(queryParameter, ILIKE) ) {\n                    Criterion createCriterion() {\n                        if(arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.ilike( this.propertyName, arguments[0] );\n                    }\n\n                };\n            }\n            else if(queryParameter.endsWith( RLIKE )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, RLIKE),\n                        RLIKE,\n                        1,\n                        isNegation(queryParameter, RLIKE) ) {\n                            Criterion createCriterion() {\n                                    if(arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                                    return new RlikeExpression( this.propertyName, arguments[0] );\n                             }\n                };\n            }\n\t\t\telse if(queryParameter.endsWith( IS_NOT_NULL )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, IS_NOT_NULL),\n\t\t\t\t\t\tIS_NOT_NULL,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tisNegation(queryParameter, IS_NOT_NULL) ) {\n\t\t\t\t\tCriterion createCriterion() {\n                            return Restrictions.isNotNull( this.propertyName );\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(queryParameter.endsWith( IS_NULL )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, IS_NULL),\n\t\t\t\t\t\tIS_NULL,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tisNegation(queryParameter, IS_NULL) ) {\n\t\t\t\t\tCriterion createCriterion() {\n\t\t\t\t\t\treturn Restrictions.isNull( this.propertyName );\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(queryParameter.endsWith( BETWEEN )) {\n\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, BETWEEN),\n\t\t\t\t\t\tBETWEEN,\n\t\t\t\t\t\t2,\n\t\t\t\t\t\tisNegation(queryParameter, BETWEEN) ) {\n\t\t\t\t\tCriterion createCriterion() {\n\t\t\t\t\t\treturn Restrictions.between( this.propertyName,this.arguments[0], this.arguments[1] );\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n            else if(queryParameter.endsWith( IN_LIST )) {\n\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, IN_LIST),\n                        IN_LIST,\n                        1,\n                        isNegation(queryParameter, IN_LIST) ) {\n                    Criterion createCriterion() {\n                        return Restrictions.in( this.propertyName,(Collection)this.arguments[0] );\n                    }\n\n                };\n            }\n\n            else if(queryParameter.endsWith( NOT_EQUAL )) {\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, NOT_EQUAL),\n\t\t\t\t\t\tNOT_EQUAL,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tisNegation(queryParameter, NOT_EQUAL) ) {\n\t\t\t\t\tCriterion createCriterion() {\n                        if(arguments[0] == null) return Restrictions.isNotNull(this.propertyName);\n                        return Restrictions.ne( this.propertyName,this.arguments[0]);\n\t\t\t\t\t}\n\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\treturn new GrailsMethodExpression(\n\t\t\t\t\t\tapplication,\n\t\t\t\t\t\tclazz,\n\t\t\t\t\t\tcalcPropertyName(queryParameter, null),\n\t\t\t\t\t\tEQUAL,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tisNegation(queryParameter, EQUAL) ) {\n\t\t\t\t\tCriterion createCriterion() {\n                        if(arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.eq( this.propertyName,this.arguments[0]);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}","id":38368,"modified_method":"protected static GrailsMethodExpression create(final GrailsApplication application,Class clazz, String queryParameter) {\n            if (queryParameter.endsWith( LESS_THAN_OR_EQUAL )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, LESS_THAN_OR_EQUAL),\n                        LESS_THAN_OR_EQUAL,\n                        1,\n                        isNegation(queryParameter, LESS_THAN_OR_EQUAL) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        return Restrictions.le( this.propertyName, arguments[0] );\n                    }\n                };\n            }\n\n            if (queryParameter.endsWith( LESS_THAN )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, LESS_THAN),\n                        LESS_THAN,\n                        1, // argument count\n                        isNegation(queryParameter, LESS_THAN) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        if (arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.lt( this.propertyName, arguments[0] );\n                    }\n                };\n            }\n\n            if (queryParameter.endsWith( GREATER_THAN_OR_EQUAL )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, GREATER_THAN_OR_EQUAL),\n                        GREATER_THAN_OR_EQUAL,\n                        1,\n                        isNegation(queryParameter, GREATER_THAN_OR_EQUAL) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        if (arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.ge( this.propertyName, arguments[0] );\n                    }\n                };\n            }\n\n            if (queryParameter.endsWith( GREATER_THAN )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, GREATER_THAN),\n                        GREATER_THAN,\n                        1,\n                        isNegation(queryParameter, GREATER_THAN) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        if (arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.gt( this.propertyName, arguments[0] );\n                    }\n\n                };\n            }\n\n            if (queryParameter.endsWith( LIKE )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, LIKE),\n                        LIKE,\n                        1,\n                        isNegation(queryParameter, LIKE) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        if (arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.like( this.propertyName, arguments[0] );\n                    }\n                };\n            }\n\n            if (queryParameter.endsWith( ILIKE )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, ILIKE),\n                        ILIKE,\n                        1,\n                        isNegation(queryParameter, ILIKE) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        if (arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                        return Restrictions.ilike( this.propertyName, arguments[0] );\n                    }\n\n                };\n            }\n\n            if (queryParameter.endsWith( RLIKE )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, RLIKE),\n                        RLIKE,\n                        1,\n                        isNegation(queryParameter, RLIKE) ) {\n                            @Override\n                            Criterion createCriterion() {\n                                if (arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                                return new RlikeExpression( this.propertyName, arguments[0] );\n                            }\n                };\n            }\n            if (queryParameter.endsWith( IS_NOT_NULL )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, IS_NOT_NULL),\n                        IS_NOT_NULL,\n                        0,\n                        isNegation(queryParameter, IS_NOT_NULL) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        return Restrictions.isNotNull( this.propertyName );\n                    }\n\n                };\n            }\n\n            if (queryParameter.endsWith( IS_NULL )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, IS_NULL),\n                        IS_NULL,\n                        0,\n                        isNegation(queryParameter, IS_NULL) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        return Restrictions.isNull( this.propertyName );\n                    }\n                };\n            }\n\n            if (queryParameter.endsWith( BETWEEN )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, BETWEEN),\n                        BETWEEN,\n                        2,\n                        isNegation(queryParameter, BETWEEN) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        return Restrictions.between( this.propertyName,this.arguments[0], this.arguments[1] );\n                    }\n\n                };\n            }\n\n            if (queryParameter.endsWith( IN_LIST )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, IN_LIST),\n                        IN_LIST,\n                        1,\n                        isNegation(queryParameter, IN_LIST) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        return Restrictions.in( this.propertyName,(Collection)this.arguments[0] );\n                    }\n                };\n            }\n\n            if (queryParameter.endsWith( NOT_EQUAL )) {\n                return new GrailsMethodExpression(\n                        application,\n                        clazz,\n                        calcPropertyName(queryParameter, NOT_EQUAL),\n                        NOT_EQUAL,\n                        1,\n                        isNegation(queryParameter, NOT_EQUAL) ) {\n                    @Override\n                    Criterion createCriterion() {\n                        if (arguments[0] == null) return Restrictions.isNotNull(this.propertyName);\n                        return Restrictions.ne( this.propertyName,this.arguments[0]);\n                    }\n                };\n            }\n\n            return new GrailsMethodExpression(\n                    application,\n                    clazz,\n                    calcPropertyName(queryParameter, null),\n                    EQUAL,\n                    1,\n                    isNegation(queryParameter, EQUAL) ) {\n            @Override\n                Criterion createCriterion() {\n                    if (arguments[0] == null) return Restrictions.isNull(this.propertyName);\n                    return Restrictions.eq( this.propertyName,this.arguments[0]);\n                }\n            };\n        }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"protected Criterion getCriterion() {\n\t\t\tif(arguments == null)\n\t\t\t\tthrow new IllegalStateException(\"Parameters array must be set before retrieving Criterion\");\n\n\t\t\tif(negation) {\n\t\t\t\treturn Restrictions.not( createCriterion() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn createCriterion();\n\t\t\t}\n\t\t}","id":38369,"modified_method":"protected Criterion getCriterion() {\n            if (arguments == null)\n                throw new IllegalStateException(\"Parameters array must be set before retrieving Criterion\");\n\n            if (negation) {\n                return Restrictions.not( createCriterion() );\n            }\n            return createCriterion();\n        }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Sets class to be used for the Hibernate CurrentSessionContext\n     *\n     * @param currentSessionContextClass An implementation of the CurrentSessionContext interface\n     */\n    public void setCurrentSessionContextClass(Class currentSessionContextClass) {\n        this.currentSessionContextClass = currentSessionContextClass;\n    }","id":38370,"modified_method":"/**\n     * Sets class to be used for the Hibernate CurrentSessionContext\n     *\n     * @param currentSessionContextClass An implementation of the CurrentSessionContext interface\n     */\n    public void setCurrentSessionContextClass(Class<?> currentSessionContextClass) {\n        this.currentSessionContextClass = currentSessionContextClass;\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Overrides default behaviour to allow for a configurable configuration class \n\t */\n\tprotected Configuration newConfiguration() {\n        ClassLoader cl = this.classLoader != null ? this.classLoader : Thread.currentThread().getContextClassLoader();\n        if(configClass == null) {\n            try {\n                configClass = cl.loadClass(\"org.codehaus.groovy.grails.orm.hibernate.cfg.GrailsAnnotationConfiguration\");\n            }\n            catch (Throwable e) {\n                // probably not Java 5 or missing some annotation jars, use default\n                configClass = DefaultGrailsDomainConfiguration.class;                \n            }\n        }\n        Object config = BeanUtils.instantiateClass(configClass);\n        if(config instanceof GrailsDomainConfiguration) {\n            GrailsDomainConfiguration grailsConfig = (GrailsDomainConfiguration) config;\n            grailsConfig.setGrailsApplication(grailsApplication);\n        }\n        if(currentSessionContextClass != null) {\n            ((Configuration)config).setProperty(Environment.CURRENT_SESSION_CONTEXT_CLASS, currentSessionContextClass.getName());\n            // don't allow Spring's LocaalSessionFactoryBean to override setting\n            setExposeTransactionAwareSessionFactory(false);\n        }\n        return (Configuration)config;\n\t}","id":38371,"modified_method":"/**\n     * Overrides default behaviour to allow for a configurable configuration class \n     */\n     @Override\n    protected Configuration newConfiguration() {\n        ClassLoader cl = this.classLoader != null ? this.classLoader : Thread.currentThread().getContextClassLoader();\n        if (configClass == null) {\n            try {\n                configClass = cl.loadClass(\"org.codehaus.groovy.grails.orm.hibernate.cfg.GrailsAnnotationConfiguration\");\n            }\n            catch (Throwable e) {\n                // probably not Java 5 or missing some annotation jars, use default\n                configClass = DefaultGrailsDomainConfiguration.class;                \n            }\n        }\n        Object config = BeanUtils.instantiateClass(configClass);\n        if (config instanceof GrailsDomainConfiguration) {\n            ((GrailsDomainConfiguration)config).setGrailsApplication(grailsApplication);\n        }\n        if (currentSessionContextClass != null) {\n            ((Configuration)config).setProperty(Environment.CURRENT_SESSION_CONTEXT_CLASS, currentSessionContextClass.getName());\n            // don't allow Spring's LocaalSessionFactoryBean to override setting\n            setExposeTransactionAwareSessionFactory(false);\n        }\n        return (Configuration)config;\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Sets the class to be used for Hibernate Configuration\n     * @param configClass A subclass of the Hibernate Configuration class\n     */\n    public void setConfigClass(Class configClass) {\n        this.configClass = configClass;\n    }","id":38372,"modified_method":"/**\n     * Sets the class to be used for Hibernate Configuration\n     * @param configClass A subclass of the Hibernate Configuration class\n     */\n    public void setConfigClass(Class<?> configClass) {\n        this.configClass = configClass;\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    public void destroy() throws HibernateException {\n        MetaClassRegistry registry = GroovySystem.getMetaClassRegistry();\n        Map classMetaData = getSessionFactory().getAllClassMetadata();\n        for (Object o : classMetaData.values()) {\n            ClassMetadata classMetadata = (ClassMetadata) o;\n            Class mappedClass = classMetadata.getMappedClass(EntityMode.POJO);\n            registry.removeMetaClass(mappedClass);\n        }\n        super.destroy();\n    }","id":38373,"modified_method":"@Override\n    public void destroy() throws HibernateException {\n        MetaClassRegistry registry = GroovySystem.getMetaClassRegistry();\n        Map<?, ?> classMetaData = getSessionFactory().getAllClassMetadata();\n        for (Object o : classMetaData.values()) {\n            ClassMetadata classMetadata = (ClassMetadata) o;\n            Class<?> mappedClass = classMetadata.getMappedClass(EntityMode.POJO);\n            registry.removeMetaClass(mappedClass);\n        }\n        super.destroy();\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public DateMarshaller() {\n        this(FastDateFormat.getInstance(\"yyyy-MM-dd HH:mm:ss.S z\"));\n    }","id":38374,"modified_method":"/**\n     * Default constructor.\n     */\n    public DateMarshaller() {\n        this(FastDateFormat.getInstance(\"yyyy-MM-dd HH:mm:ss.S z\"));\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public DateMarshaller(Format XML_DATE_FORMAT) {\n        this.XML_DATE_FORMAT = XML_DATE_FORMAT;\n    }","id":38375,"modified_method":"/**\n     * Constructor with a custom formatter.\n     * @param formatter  the formatter\n     */\n    public DateMarshaller(Format formatter) {\n        this.formatter = formatter;\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public void marshalObject(Object object, XML xml) throws ConverterException {\n        try {\n            xml.chars(XML_DATE_FORMAT.format(object));\n        } catch (Exception e) {\n            throw ConverterUtil.resolveConverterException(e);\n        }\n    }","id":38376,"modified_method":"public void marshalObject(Object object, XML xml) throws ConverterException {\n        try {\n            xml.chars(formatter.format(object));\n        } catch (Exception e) {\n            throw ConverterUtil.resolveConverterException(e);\n        }\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public void marshalObject(Object object, JSON converter) throws ConverterException {\n        try {\n            converter.getWriter().value(JSON_DATE_FORMAT.format((Date) object));\n        } catch (JSONException e) {\n            throw new ConverterException(e);\n        }\n    }","id":38377,"modified_method":"public void marshalObject(Object object, JSON converter) throws ConverterException {\n        try {\n            converter.getWriter().value(JSON_DATE_FORMAT.format(object));\n        } catch (JSONException e) {\n            throw new ConverterException(e);\n        }\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"protected Object doInvokeInternalWithExpressions(final Class clazz, String methodName, final Object[] arguments, final List expressions, String operatorInUse, final Closure additionalCriteria) {\n\n        final String operator = OPERATOR_OR.equals(operatorInUse) ? OPERATOR_OR : OPERATOR_AND;\n        return super.getHibernateTemplate().execute( new HibernateCallback() {\n\n\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\n\t\t\t\t\n\t\t\t\tCriteria crit = getCriteria(session, additionalCriteria, clazz);\n\t\t\t\tif(arguments.length > 0) {\n\t\t\t\t\tif(arguments[0] instanceof Map) {\n\t\t\t\t\t\tMap argMap = (Map)arguments[0];\n\t\t\t\t\t\tGrailsHibernateUtil.populateArgumentsForCriteria(clazz, crit,argMap);\n                        if(!argMap.containsKey(GrailsHibernateUtil.ARGUMENT_FETCH)) {\n                            crit.setMaxResults(1);\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n                if(operator.equals(OPERATOR_OR)) {\n                    if(firstExpressionIsRequiredBoolean()) {\n                        GrailsMethodExpression expression = (GrailsMethodExpression) expressions.remove(0);\n                        crit.add(expression.getCriterion());\n                    }\n                    Disjunction dis = Restrictions.disjunction();\n                    for (Object expression : expressions) {\n                        GrailsMethodExpression current = (GrailsMethodExpression) expression;\n                        dis.add(current.getCriterion());\n                    }\n                    crit.add(dis);\n                }\n                else {\n                    for (Object expression : expressions) {\n                        GrailsMethodExpression current = (GrailsMethodExpression) expression;\n                        crit.add(current.getCriterion());\n\n                    }\n                }\n\n\n                final List list = crit.list();\n                if(!list.isEmpty()) {\n                    return GrailsHibernateUtil.unwrapIfProxy(list.get(0));\n                }\n                return null;\n            }\n\t\t});\n\t}","id":38378,"modified_method":"@Override\n    protected Object doInvokeInternalWithExpressions(final Class clazz, String methodName, final Object[] arguments, final List expressions, String operatorInUse, final Closure additionalCriteria) {\n        final String operator = OPERATOR_OR.equals(operatorInUse) ? OPERATOR_OR : OPERATOR_AND;\n        return getHibernateTemplate().execute(new HibernateCallback<Object>() {\n            public Object doInHibernate(Session session) throws HibernateException, SQLException {\n\n                Criteria crit = getCriteria(session, additionalCriteria, clazz);\n                if (arguments.length > 0) {\n                    if (arguments[0] instanceof Map<?, ?>) {\n                        Map<?, ?> argMap = (Map<?, ?>)arguments[0];\n                        GrailsHibernateUtil.populateArgumentsForCriteria(clazz, crit,argMap);\n                        if (!argMap.containsKey(GrailsHibernateUtil.ARGUMENT_FETCH)) {\n                            crit.setMaxResults(1);\n                        }\n                    }\n                }\n\n                if (operator.equals(OPERATOR_OR)) {\n                    if (firstExpressionIsRequiredBoolean()) {\n                        GrailsMethodExpression expression = (GrailsMethodExpression) expressions.remove(0);\n                        crit.add(expression.getCriterion());\n                    }\n                    Disjunction dis = Restrictions.disjunction();\n                    for (Object expression : expressions) {\n                        GrailsMethodExpression current = (GrailsMethodExpression) expression;\n                        dis.add(current.getCriterion());\n                    }\n                    crit.add(dis);\n                }\n                else {\n                    for (Object expression : expressions) {\n                        GrailsMethodExpression current = (GrailsMethodExpression) expression;\n                        crit.add(current.getCriterion());\n                    }\n                }\n\n                final List<?> list = crit.list();\n                if (!list.isEmpty()) {\n                    return GrailsHibernateUtil.unwrapIfProxy(list.get(0));\n                }\n                return null;\n            }\n        });\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public FindByPersistentMethod(GrailsApplication application,SessionFactory sessionFactory, ClassLoader classLoader) {\n \t\tsuper(application,sessionFactory, classLoader, Pattern.compile( METHOD_PATTERN ),OPERATORS);\n\t}","id":38379,"modified_method":"/**\n     * Constructor.\n     * @param application\n     * @param sessionFactory\n     * @param classLoader\n     */\n    public FindByPersistentMethod(GrailsApplication application,SessionFactory sessionFactory, ClassLoader classLoader) {\n        super(application,sessionFactory, classLoader, Pattern.compile( METHOD_PATTERN ),OPERATORS);\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Sets the target object to read-write, allowing Hibernate to dirty check it and auto-flush\n     * changes\n     *\n     * @see #setObjectToReadyOnly(Object, org.hibernate.SessionFactory)\n     *\n     * @param target The target object\n     * @param sessionFactory The SessionFactory instance\n     */\n    public static void setObjectToReadWrite(final Object target, SessionFactory sessionFactory) {\n        HibernateTemplate template = new HibernateTemplate(sessionFactory);\n        template.setExposeNativeSession(true);\n        template.execute(new HibernateCallback() {\n\n            public Object doInHibernate(Session session) throws HibernateException, SQLException {\n                if(canModifyReadWriteState(session, target)) {\n                    SessionImplementor sessionImpl = (SessionImplementor) session;\n                    EntityEntry ee = sessionImpl.getPersistenceContext().getEntry(target);\n\n                    if(ee != null && ee.getStatus() == Status.READ_ONLY) {\n                        Object actualTarget = target;\n                        if(target instanceof HibernateProxy) {\n                            actualTarget = ((HibernateProxy)target).getHibernateLazyInitializer().getImplementation();\n                        }\n\n                        session.setReadOnly(actualTarget, false);\n                        session.setFlushMode(FlushMode.AUTO);\n                        incrementVersion(target);\n                    }\n                }\n                return null;\n\n            }\n        });\n\n    }","id":38380,"modified_method":"/**\n     * Sets the target object to read-write, allowing Hibernate to dirty check it and auto-flush\n     * changes\n     *\n     * @see #setObjectToReadyOnly(Object, org.hibernate.SessionFactory)\n     *\n     * @param target The target object\n     * @param sessionFactory The SessionFactory instance\n     */\n    public static void setObjectToReadWrite(final Object target, SessionFactory sessionFactory) {\n        HibernateTemplate template = new HibernateTemplate(sessionFactory);\n        template.setExposeNativeSession(true);\n        template.execute(new HibernateCallback<Void>() {\n            public Void doInHibernate(Session session) throws HibernateException, SQLException {\n                if(canModifyReadWriteState(session, target)) {\n                    SessionImplementor sessionImpl = (SessionImplementor) session;\n                    EntityEntry ee = sessionImpl.getPersistenceContext().getEntry(target);\n\n                    if(ee != null && ee.getStatus() == Status.READ_ONLY) {\n                        Object actualTarget = target;\n                        if(target instanceof HibernateProxy) {\n                            actualTarget = ((HibernateProxy)target).getHibernateLazyInitializer().getImplementation();\n                        }\n\n                        session.setReadOnly(actualTarget, false);\n                        session.setFlushMode(FlushMode.AUTO);\n                        incrementVersion(target);\n                    }\n                }\n                return null;\n            }\n        });\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public static void populateArgumentsForCriteria(Class targetClass, Criteria c, Map argMap) {\n       Integer maxParam = null;\n        Integer offsetParam = null;\n        if(argMap.containsKey(ARGUMENT_MAX)) {\n            maxParam = (Integer)converter.convertIfNecessary(argMap.get(ARGUMENT_MAX),Integer.class);\n        }\n        if(argMap.containsKey(ARGUMENT_OFFSET)) {\n            offsetParam = (Integer)converter.convertIfNecessary(argMap.get(ARGUMENT_OFFSET),Integer.class);\n        }\n        String orderParam = (String)argMap.get(ARGUMENT_ORDER);\n        Object fetchObj = argMap.get(ARGUMENT_FETCH);\n        if(fetchObj instanceof Map) {\n            Map fetch = (Map)fetchObj;\n            for (Object o : fetch.keySet()) {\n                String associationName = (String) o;\n                c.setFetchMode(associationName, getFetchMode(fetch.get(associationName)));\n            }\n        }\n\n        final String sort = (String)argMap.get(ARGUMENT_SORT);\n        final String order = ORDER_DESC.equalsIgnoreCase(orderParam) ? ORDER_DESC : ORDER_ASC;\n        final int max = maxParam == null ? -1 : maxParam;\n        final int offset = offsetParam == null ? -1 : offsetParam;\n        if(max > -1)\n            c.setMaxResults(max);\n        if(offset > -1)\n            c.setFirstResult(offset);\n        if(GrailsClassUtils.getBooleanFromMap(ARGUMENT_CACHE, argMap)) {\n            c.setCacheable(true);\n        }\n        if(GrailsClassUtils.getBooleanFromMap(ARGUMENT_LOCK, argMap)) {\n            c.setLockMode(LockMode.UPGRADE);\n        }\n        else {\n            if(argMap.get(ARGUMENT_CACHE) == null) {\n                cacheCriteriaByMapping(targetClass, c);\n            }\n        }\n        if(sort != null) {\n            boolean ignoreCase = true;\n            Object caseArg = argMap.get(ARGUMENT_IGNORE_CASE);\n            if(caseArg instanceof Boolean) {\n                ignoreCase = (Boolean) caseArg;\n            }\n            if(ORDER_DESC.equals(order)) {\n                c.addOrder( ignoreCase ? Order.desc(sort).ignoreCase() : Order.desc(sort));\n            }\n            else {\n                c.addOrder( ignoreCase ? Order.asc(sort).ignoreCase() : Order.asc(sort) );\n            }\n        }\n        else {\n            Mapping m = GrailsDomainBinder.getMapping(targetClass);\n            if(m!=null&&!StringUtils.isBlank(m.getSort())) {\n                if(ORDER_DESC.equalsIgnoreCase(m.getOrder())) {\n                    c.addOrder(Order.desc(m.getSort()));\n                }\n                else {\n                    c.addOrder(Order.asc(m.getSort()));\n                }\n            }\n        }\n\n    }","id":38381,"modified_method":"public static void populateArgumentsForCriteria(Class targetClass, Criteria c, Map argMap) {\n       Integer maxParam = null;\n        Integer offsetParam = null;\n        if(argMap.containsKey(ARGUMENT_MAX)) {\n            maxParam = converter.convertIfNecessary(argMap.get(ARGUMENT_MAX),Integer.class);\n        }\n        if(argMap.containsKey(ARGUMENT_OFFSET)) {\n            offsetParam = converter.convertIfNecessary(argMap.get(ARGUMENT_OFFSET),Integer.class);\n        }\n        String orderParam = (String)argMap.get(ARGUMENT_ORDER);\n        Object fetchObj = argMap.get(ARGUMENT_FETCH);\n        if(fetchObj instanceof Map) {\n            Map fetch = (Map)fetchObj;\n            for (Object o : fetch.keySet()) {\n                String associationName = (String) o;\n                c.setFetchMode(associationName, getFetchMode(fetch.get(associationName)));\n            }\n        }\n\n        final String sort = (String)argMap.get(ARGUMENT_SORT);\n        final String order = ORDER_DESC.equalsIgnoreCase(orderParam) ? ORDER_DESC : ORDER_ASC;\n        final int max = maxParam == null ? -1 : maxParam;\n        final int offset = offsetParam == null ? -1 : offsetParam;\n        if(max > -1)\n            c.setMaxResults(max);\n        if(offset > -1)\n            c.setFirstResult(offset);\n        if(GrailsClassUtils.getBooleanFromMap(ARGUMENT_CACHE, argMap)) {\n            c.setCacheable(true);\n        }\n        if(GrailsClassUtils.getBooleanFromMap(ARGUMENT_LOCK, argMap)) {\n            c.setLockMode(LockMode.UPGRADE);\n        }\n        else {\n            if(argMap.get(ARGUMENT_CACHE) == null) {\n                cacheCriteriaByMapping(targetClass, c);\n            }\n        }\n        if(sort != null) {\n            boolean ignoreCase = true;\n            Object caseArg = argMap.get(ARGUMENT_IGNORE_CASE);\n            if(caseArg instanceof Boolean) {\n                ignoreCase = (Boolean) caseArg;\n            }\n            if(ORDER_DESC.equals(order)) {\n                c.addOrder( ignoreCase ? Order.desc(sort).ignoreCase() : Order.desc(sort));\n            }\n            else {\n                c.addOrder( ignoreCase ? Order.asc(sort).ignoreCase() : Order.asc(sort) );\n            }\n        }\n        else {\n            Mapping m = GrailsDomainBinder.getMapping(targetClass);\n            if(m!=null&&!StringUtils.isBlank(m.getSort())) {\n                if(ORDER_DESC.equalsIgnoreCase(m.getOrder())) {\n                    c.addOrder(Order.desc(m.getSort()));\n                }\n                else {\n                    c.addOrder(Order.asc(m.getSort()));\n                }\n            }\n        }\n\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public void testRegisterAdditionalBean() throws Exception {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class dc = gcl.parseClass(\"class Test { Long id; Long version; }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[0], gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        GrailsApplicationContext ctx = (GrailsApplicationContext)conf.configure(new MockServletContext());\r\n        assertNotNull(ctx);\r\n\r\n        ctx.registerSingleton(\"Test\", dc);\r\n\r\n        GroovyObject testInstance = (GroovyObject)ctx.getBean(\"Test\");\r\n        assertNotNull(testInstance);\r\n\r\n        // now test override bean\r\n        gcl = new GroovyClassLoader();\r\n        dc = gcl.parseClass(\"class Test { Long id; Long version;String updatedProp = 'hello'; }\");\r\n        ctx.registerSingleton(\"Test\",dc);\r\n        testInstance = (GroovyObject)ctx.getBean(\"Test\");\r\n        assertNotNull(testInstance);\r\n        assertEquals(\"hello\",testInstance.getProperty(\"updatedProp\"));\r\n    }","id":38382,"modified_method":"public void testRegisterAdditionalBean() {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class<?> dc = gcl.parseClass(\"class Test { Long id; Long version; }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[0], gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        GrailsApplicationContext ctx = (GrailsApplicationContext)conf.configure(new MockServletContext());\r\n        assertNotNull(ctx);\r\n\r\n        ctx.registerSingleton(\"Test\", dc);\r\n\r\n        GroovyObject testInstance = getBean(ctx, \"Test\");\r\n        assertNotNull(testInstance);\r\n\r\n        // now test override bean\r\n        gcl = new GroovyClassLoader();\r\n        dc = gcl.parseClass(\"class Test { Long id; Long version;String updatedProp = 'hello'; }\");\r\n        ctx.registerSingleton(\"Test\",dc);\r\n        testInstance = getBean(ctx, \"Test\");\r\n        assertNotNull(testInstance);\r\n        assertEquals(\"hello\",testInstance.getProperty(\"updatedProp\"));\r\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public void testAutowireNonTransactionalServiceClasses() throws Exception {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class s1 =  gcl.parseClass(\"class TestService { boolean transactional = false;def serviceMethod() { 'hello' } }\");\r\n        Thread.sleep(1000);\r\n        Class s2 =  gcl.parseClass(\"class AnotherService { boolean transactional = false;TestService testService; def anotherMethod() { testService.serviceMethod() } }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{s1,s2}, gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        conf.setLoadExternalPersistenceConfig(false);\r\n        GrailsApplicationContext ctx = (GrailsApplicationContext)conf.configure(new MockServletContext());\r\n        assertNotNull(ctx);\r\n\r\n        assertEquals( s1, ctx.getBean(\"testService\").getClass());\r\n        assertEquals( s2, ctx.getBean(\"anotherService\").getClass());\r\n\r\n        GroovyObject anotherService = (GroovyObject)ctx.getBean(\"anotherService\");\r\n        assertNotNull(anotherService.getProperty(\"testService\"));\r\n        assertEquals(\"hello\",anotherService.invokeMethod(\"anotherMethod\", null));\r\n    }","id":38383,"modified_method":"public void testAutowireNonTransactionalServiceClasses() throws Exception {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class<?> s1 =  gcl.parseClass(\"class TestService { boolean transactional = false;def serviceMethod() { 'hello' } }\");\r\n        Thread.sleep(1000);\r\n        Class<?> s2 =  gcl.parseClass(\"class AnotherService { boolean transactional = false;TestService testService; def anotherMethod() { testService.serviceMethod() } }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{s1,s2}, gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        conf.setLoadExternalPersistenceConfig(false);\r\n        GrailsApplicationContext ctx = (GrailsApplicationContext)conf.configure(new MockServletContext());\r\n        assertNotNull(ctx);\r\n\r\n        assertEquals( s1, ctx.getBean(\"testService\").getClass());\r\n        assertEquals( s2, ctx.getBean(\"anotherService\").getClass());\r\n\r\n        GroovyObject anotherService = getBean(ctx, \"anotherService\");\r\n        assertNotNull(anotherService.getProperty(\"testService\"));\r\n        assertEquals(\"hello\",anotherService.invokeMethod(\"anotherMethod\", null));\r\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public void testConfigure() throws Exception {\r\n\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class dc = gcl.parseClass(\"class Test { Long id; Long version; }\");\r\n                \r\n        Class c = gcl.parseClass(\"class TestController { def list = {} }\");\r\n\r\n\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{dc,c}, gcl );\r\n\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n        parent.registerMockBean(\"classLoader\", gcl);\r\n\r\n        app.setApplicationContext(parent);\r\n        \r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        DefaultGrailsPluginManager manager = new DefaultGrailsPluginManager(new Class[0], app);\r\n        manager.setParentApplicationContext(parent);\r\n        parent.registerMockBean(\"manager\",manager);\r\n        conf.setPluginManager(manager);\r\n        ApplicationContext ctx = conf.configure(new MockServletContext());\r\n        \r\n        // test class editor setup\r\n        assertNotNull(ctx);\r\n        assertTrue(ctx.getBean(GrailsRuntimeConfigurator.CLASS_LOADER_BEAN) instanceof GroovyClassLoader );        \r\n\r\n        // test exception resolver\r\n        GrailsExceptionResolver er = (GrailsExceptionResolver)ctx.getBean(GrailsRuntimeConfigurator.EXCEPTION_HANDLER_BEAN);\r\n\r\n        assertNotNull(er);\r\n        ModelAndView mv = er.resolveException(new MockHttpServletRequest(),new MockHttpServletResponse(),null, new Exception());\r\n        assertEquals(\"/error\",mv.getViewName());\r\n\r\n        // test multipart support\r\n        assertTrue(ctx.getBean(GrailsRuntimeConfigurator.MULTIPART_RESOLVER_BEAN) instanceof CommonsMultipartResolver);\r\n\r\n        // test message source\r\n        MessageSource ms = (MessageSource)ctx.getBean(GrailsRuntimeConfigurator.MESSAGE_SOURCE_BEAN);\r\n        assertNotNull(ms);\r\n\r\n\r\n        // test domain class setup correctly in the ctx\r\n        GrailsDomainClass domainClass = (GrailsDomainClass)ctx.getBean(\"TestDomainClass\");\r\n\r\n        assertNotNull(domainClass);\r\n        assertEquals(\"Test\", domainClass.getShortName());\r\n\r\n        Class persistentClass = (Class)ctx.getBean(\"TestPersistentClass\");\r\n        assertEquals(dc,persistentClass);\r\n\r\n        org.codehaus.groovy.grails.validation.GrailsDomainClassValidator validator = (org.codehaus.groovy.grails.validation.GrailsDomainClassValidator)ctx.getBean(\"TestValidator\");\r\n        assertTrue(validator.supports(dc));\r\n\r\n        GroovyObject controller = (GroovyObject)ctx.getBean(\"TestController\");\r\n        assertEquals(c,controller.getClass());\r\n    }","id":38384,"modified_method":"public void testConfigure() throws Exception {\r\n\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class<?> dc = gcl.parseClass(\"class Test { Long id; Long version; }\");\r\n\r\n        Class<?> c = gcl.parseClass(\"class TestController { def list = {} }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{dc,c}, gcl );\r\n\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n        parent.registerMockBean(\"classLoader\", gcl);\r\n\r\n        app.setApplicationContext(parent);\r\n        \r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        DefaultGrailsPluginManager manager = new DefaultGrailsPluginManager(new Class[0], app);\r\n        manager.setParentApplicationContext(parent);\r\n        parent.registerMockBean(\"manager\",manager);\r\n        conf.setPluginManager(manager);\r\n        ApplicationContext ctx = conf.configure(new MockServletContext());\r\n        \r\n        // test class editor setup\r\n        assertNotNull(ctx);\r\n        assertTrue(ctx.getBean(GrailsRuntimeConfigurator.CLASS_LOADER_BEAN) instanceof GroovyClassLoader );        \r\n\r\n        // test exception resolver\r\n        GrailsExceptionResolver er = getBean(ctx, GrailsRuntimeConfigurator.EXCEPTION_HANDLER_BEAN);\r\n\r\n        assertNotNull(er);\r\n        ModelAndView mv = er.resolveException(new MockHttpServletRequest(),new MockHttpServletResponse(),null, new Exception());\r\n        assertEquals(\"/error\",mv.getViewName());\r\n\r\n        // test multipart support\r\n        assertTrue(ctx.getBean(GrailsRuntimeConfigurator.MULTIPART_RESOLVER_BEAN) instanceof CommonsMultipartResolver);\r\n\r\n        // test message source\r\n        MessageSource ms = getBean(ctx, GrailsRuntimeConfigurator.MESSAGE_SOURCE_BEAN);\r\n        assertNotNull(ms);\r\n\r\n        // test domain class setup correctly in the ctx\r\n        GrailsDomainClass domainClass = getBean(ctx, \"TestDomainClass\");\r\n\r\n        assertNotNull(domainClass);\r\n        assertEquals(\"Test\", domainClass.getShortName());\r\n\r\n        Class<?> persistentClass = getBean(ctx, \"TestPersistentClass\");\r\n        assertEquals(dc,persistentClass);\r\n\r\n        GrailsDomainClassValidator validator = getBean(ctx, \"TestValidator\");\r\n        assertTrue(validator.supports(dc));\r\n\r\n        GroovyObject controller = getBean(ctx, \"TestController\");\r\n        assertEquals(c,controller.getClass());\r\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public void testAutowireServiceClasses() throws Exception {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class s1 =  gcl.parseClass(\"class TestService { def serviceMethod() { 'hello' } }\");\r\n        \r\n        Class s2 =  gcl.parseClass(\"class AnotherService { TestService testService; def anotherMethod() { testService.serviceMethod() } }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{s1,s2}, gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        conf.setLoadExternalPersistenceConfig(false);\r\n        GrailsApplicationContext ctx = (GrailsApplicationContext)conf.configure(new MockServletContext(), false);\r\n        assertNotNull(ctx);\r\n\r\n        GroovyObject anotherService = (GroovyObject)ctx.getBean(\"anotherService\");\r\n\r\n        assertEquals(\"hello\",anotherService.invokeMethod(\"anotherMethod\", null));\r\n    }","id":38385,"modified_method":"public void testAutowireServiceClasses() {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class<?> s1 =  gcl.parseClass(\"class TestService { def serviceMethod() { 'hello' } }\");\r\n\r\n        Class<?> s2 =  gcl.parseClass(\"class AnotherService { TestService testService; def anotherMethod() { testService.serviceMethod() } }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{s1,s2}, gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        conf.setLoadExternalPersistenceConfig(false);\r\n        GrailsApplicationContext ctx = (GrailsApplicationContext)conf.configure(new MockServletContext(), false);\r\n        assertNotNull(ctx);\r\n\r\n        GroovyObject anotherService = getBean(ctx, \"anotherService\");\r\n\r\n        assertEquals(\"hello\",anotherService.invokeMethod(\"anotherMethod\", null));\r\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"public void testConfigureScaffolding() throws Exception {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class dc = gcl.parseClass(\"class Test { Long id; Long version; }\");\r\n\r\n        Class c = gcl.parseClass(\"class TestController { def scaffold = Test }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{dc,c}, gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        ApplicationContext ctx = conf.configure(new MockServletContext());\r\n        assertNotNull(ctx);\r\n\r\n    }","id":38386,"modified_method":"public void testConfigureScaffolding() {\r\n        GroovyClassLoader gcl = new GroovyClassLoader();\r\n        Class<?> dc = gcl.parseClass(\"class Test { Long id; Long version; }\");\r\n\r\n        Class<?> c = gcl.parseClass(\"class TestController { def scaffold = Test }\");\r\n\r\n        GrailsApplication app = new DefaultGrailsApplication(new Class[]{dc,c}, gcl );\r\n        MockApplicationContext parent = new MockApplicationContext();\r\n        parent.registerMockBean(GrailsApplication.APPLICATION_ID, app);\r\n\r\n        GrailsRuntimeConfigurator conf = new GrailsRuntimeConfigurator(app,parent);\r\n        ApplicationContext ctx = conf.configure(new MockServletContext());\r\n        assertNotNull(ctx);\r\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"private static String buildDispatchUrlForMapping(UrlMappingInfo info, boolean includeParams) {\n    \tif(info.getURI()!=null) {\n    \t\treturn info.getURI();\n    \t}\n    \telse {\n            final StringBuilder forwardUrl = new StringBuilder();\n\n            if (info.getViewName() != null) {\n                String viewName = info.getViewName();\n                forwardUrl.append(SLASH).append(viewName);\n            }\n            else {\n                forwardUrl.append(GrailsUrlPathHelper.GRAILS_SERVLET_PATH);\n                forwardUrl.append(SLASH)\n                                  .append(info.getControllerName());\n\n                if(!StringUtils.isBlank(info.getActionName())) {\n                    forwardUrl.append(SLASH)\n                              .append(info.getActionName());\n                }\n                forwardUrl.append(GrailsUrlPathHelper.GRAILS_DISPATCH_EXTENSION);\n            }\n\n            final Map parameters = info.getParameters();\n            if(parameters !=null && !parameters.isEmpty()  && includeParams) {\n                try {\n                    forwardUrl.append(toQueryString(parameters));\n                }\n                catch (UnsupportedEncodingException e) {\n                    throw new ControllerExecutionException(\"Unable to include \");\n                }\n            }\n            return forwardUrl.toString();\n    \t\t\n    \t}\n    }","id":38387,"modified_method":"private static String buildDispatchUrlForMapping(UrlMappingInfo info, boolean includeParams) {\n        if (info.getURI() != null) {\n            return info.getURI();\n        }\n\n        final StringBuilder forwardUrl = new StringBuilder();\n\n        if (info.getViewName() != null) {\n            String viewName = info.getViewName();\n            forwardUrl.append(SLASH).append(viewName);\n        }\n        else {\n            forwardUrl.append(GrailsUrlPathHelper.GRAILS_SERVLET_PATH);\n            forwardUrl.append(SLASH).append(info.getControllerName());\n\n            if (!StringUtils.isBlank(info.getActionName())) {\n                forwardUrl.append(SLASH).append(info.getActionName());\n            }\n            forwardUrl.append(GrailsUrlPathHelper.GRAILS_DISPATCH_EXTENSION);\n        }\n\n        final Map parameters = info.getParameters();\n        if (parameters !=null && !parameters.isEmpty()  && includeParams) {\n            try {\n                forwardUrl.append(toQueryString(parameters));\n            }\n            catch (UnsupportedEncodingException e) {\n                throw new ControllerExecutionException(\"Unable to include \");\n            }\n        }\n        return forwardUrl.toString();\n      }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Removes any GrailsWebRequest instance from the current request.\n     */\n    public static void clearGrailsWebRequest() {\n        RequestAttributes reqAttrs = RequestContextHolder.getRequestAttributes();\n        if (reqAttrs != null) {\n            // First remove the web request from the HTTP request\n            // attributes.\n            GrailsWebRequest webRequest = (GrailsWebRequest) reqAttrs;\n            webRequest.getRequest().removeAttribute(GrailsApplicationAttributes.WEB_REQUEST);\n\n            // Now remove it from RequestContextHolder.\n            RequestContextHolder.setRequestAttributes(null);\n        }\n    }","id":38388,"modified_method":"/**\n     * Removes any GrailsWebRequest instance from the current request.\n     */\n    public static void clearGrailsWebRequest() {\n        RequestAttributes reqAttrs = RequestContextHolder.getRequestAttributes();\n        if (reqAttrs != null) {\n            // First remove the web request from the HTTP request\n            // attributes.\n            GrailsWebRequest webRequest = (GrailsWebRequest) reqAttrs;\n            webRequest.getRequest().removeAttribute(GrailsApplicationAttributes.WEB_REQUEST);\n\n            // Now remove it from RequestContextHolder.\n            RequestContextHolder.resetRequestAttributes();\n        }\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Includes the given URL returning the resulting content as a String\n     *\n     * @param includeUrl The URL to include\n     * @param request The request\n     * @param response The response\n     * @param model The model\n     * @return The content\n     */\n    public static IncludedContent includeForUrl(String includeUrl, HttpServletRequest request, HttpServletResponse response, Map model) {\n        RequestDispatcher dispatcher = request.getRequestDispatcher(includeUrl);\n        HttpServletResponse wrapped = WrappedResponseHolder.getWrappedResponse();\n        response = wrapped != null ? wrapped : response;\n\n\n        exposeForwardRequestAttributes(request);\n        exposeRequestAttributes(request, model);\n\n\n        try {\n            final IncludeResponseWrapper responseWrapper = new IncludeResponseWrapper(response);\n            try {\n                WrappedResponseHolder.setWrappedResponse(responseWrapper);\n                dispatcher.include(request, responseWrapper);\n                if(responseWrapper.getRedirectURL()!=null) {\n                    return new IncludedContent(responseWrapper.getRedirectURL());\n                }\n                else {\n                    return new IncludedContent(responseWrapper.getContentType(), responseWrapper.getContent());\n                }\n            }\n            finally {\n                WrappedResponseHolder.setWrappedResponse(wrapped);\n\n            }\n        }\n        catch (Exception e) {\n            GrailsUtil.deepSanitize(e);\n            throw new ControllerExecutionException(\"Unable to execute include: \" + e.getMessage(),e );\n        }\n    }","id":38389,"modified_method":"/**\n     * Includes the given URL returning the resulting content as a String\n     *\n     * @param includeUrl The URL to include\n     * @param request The request\n     * @param response The response\n     * @param model The model\n     * @return The content\n     */\n    public static IncludedContent includeForUrl(String includeUrl, HttpServletRequest request, HttpServletResponse response, Map model) {\n        RequestDispatcher dispatcher = request.getRequestDispatcher(includeUrl);\n        HttpServletResponse wrapped = WrappedResponseHolder.getWrappedResponse();\n        response = wrapped != null ? wrapped : response;\n\n        exposeForwardRequestAttributes(request);\n        exposeRequestAttributes(request, model);\n\n        try {\n            final IncludeResponseWrapper responseWrapper = new IncludeResponseWrapper(response);\n            try {\n                WrappedResponseHolder.setWrappedResponse(responseWrapper);\n                dispatcher.include(request, responseWrapper);\n                if (responseWrapper.getRedirectURL()!=null) {\n                    return new IncludedContent(responseWrapper.getRedirectURL());\n                }\n                return new IncludedContent(responseWrapper.getContentType(), responseWrapper.getContent());\n            }\n            finally {\n                WrappedResponseHolder.setWrappedResponse(wrapped);\n            }\n        }\n        catch (Exception e) {\n            GrailsUtil.deepSanitize(e);\n            throw new ControllerExecutionException(\"Unable to execute include: \" + e.getMessage(),e );\n        }\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * The Grails dispatch servlet maps URIs like /app/grails/example/index.dispatch. This method infers the\n     * controller URI for the dispatch URI so that /app/grails/example/index.dispatch becomes /app/example/index\n     *\n     * @param request The request\n     */\n    public static String getRequestURIForGrailsDispatchURI(HttpServletRequest request) {\n        UrlPathHelper pathHelper = new UrlPathHelper();\n        if(request.getRequestURI().endsWith(DISPATCH_URI_SUFFIX))  {\n            String path = pathHelper.getPathWithinApplication(request);\n            if(path.startsWith(GRAILS_DISPATCH_SERVLET_NAME)) {\n                path = path.substring(GRAILS_DISPATCH_SERVLET_NAME.length(),path.length());\n            }\n            return path.substring(0, path.length()-DISPATCH_URI_SUFFIX.length());\n\n        }\n        else {\n            return pathHelper.getPathWithinApplication(request);\n        }\n    }","id":38390,"modified_method":"/**\n     * The Grails dispatch servlet maps URIs like /app/grails/example/index.dispatch. This method infers the\n     * controller URI for the dispatch URI so that /app/grails/example/index.dispatch becomes /app/example/index\n     *\n     * @param request The request\n     */\n    public static String getRequestURIForGrailsDispatchURI(HttpServletRequest request) {\n        UrlPathHelper pathHelper = new UrlPathHelper();\n        if (request.getRequestURI().endsWith(DISPATCH_URI_SUFFIX))  {\n            String path = pathHelper.getPathWithinApplication(request);\n            if (path.startsWith(GRAILS_DISPATCH_SERVLET_NAME)) {\n                path = path.substring(GRAILS_DISPATCH_SERVLET_NAME.length(),path.length());\n            }\n            return path.substring(0, path.length()-DISPATCH_URI_SUFFIX.length());\n\n        }\n        return pathHelper.getPathWithinApplication(request);\n    }","commit_id":"83b576d8fb440b8be2221808a1f3513f28327ef1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Returns the parameters of the collector with resolved macros.<p>\n     * \n     * @return the parameters of the collector with resolved macros\n     */\n    public String getParameter() {\n\n        Locale locale = getRequestContext().getLocale();\n\n        String params = m_content.getStringValue(getCmsObject(), NODE_PARAMETER, locale);\n        List links = m_content.getValues(NODE_LINKS, locale);\n\n        CmsMacroResolver macroResolver = CmsMacroResolver.newInstance();\n        macroResolver.setKeepEmptyMacros(true);\n        for (int i = 0; i < links.size(); i++) {\n            I_CmsXmlContentValue xmlValue = (I_CmsXmlContentValue)links.get(i);\n            String value = xmlValue.getStringValue(getCmsObject());\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                StringBuffer macro = new StringBuffer(10);\n                macro.append(MACRO_LINK_PREFIX).append(i + 1);\n                macroResolver.addMacro(macro.toString(), getRequestContext().removeSiteRoot(value));\n            }\n        }\n\n        return macroResolver.resolveMacros(params);\n    }","id":38391,"modified_method":"/**\n     * Returns the parameters of the collector with resolved macros.<p>\n     * \n     * @return the parameters of the collector with resolved macros\n     */\n    public String getParameter() {\n\n        Locale locale = getRequestContext().getLocale();\n\n        String params = m_content.getStringValue(getCmsObject(), NODE_PARAMETER, locale);\n        List<I_CmsXmlContentValue> links = m_content.getValues(NODE_LINKS, locale);\n\n        CmsMacroResolver macroResolver = CmsMacroResolver.newInstance();\n        macroResolver.setKeepEmptyMacros(true);\n        for (int i = 0; i < links.size(); i++) {\n            I_CmsXmlContentValue xmlValue = links.get(i);\n            String value = xmlValue.getStringValue(getCmsObject());\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                StringBuffer macro = new StringBuffer(10);\n                macro.append(MACRO_LINK_PREFIX).append(i + 1);\n                macroResolver.addMacro(macro.toString(), getRequestContext().removeSiteRoot(value));\n            }\n        }\n\n        return macroResolver.resolveMacros(params);\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a lazy initialized map with the mapped entries of the collected resources.<p>\n     * \n     * @return a lazy initialized map\n     */\n    public Map getMappedEntry() {\n\n        if (m_mappedEntries == null) {\n            m_mappedEntries = LazyMap.decorate(new HashMap(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsListBoxEntry entry = null;\n\n                    try {\n                        CmsXmlContent content;\n                        if (input instanceof CmsXmlContent) {\n                            content = (CmsXmlContent)input;\n                        } else {\n                            CmsResource resource = (CmsResource)input;\n                            content = CmsXmlContentFactory.unmarshal(getCmsObject(), getCmsObject().readFile(resource));\n                        }\n\n                        if (getMapping() != null) {\n                            entry = getMapping().getEntryFromXmlContent(\n                                getCmsObject(),\n                                content,\n                                getRequestContext().getLocale());\n                        }\n                    } catch (CmsException ex) {\n                        // noop\n                    }\n\n                    return entry;\n                }\n            });\n        }\n        return m_mappedEntries;\n    }","id":38392,"modified_method":"/**\n     * Returns a lazy initialized map with the mapped entries of the collected resources.<p>\n     * \n     * @return a lazy initialized map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Map<Object, CmsListBoxEntry> getMappedEntry() {\n\n        if (m_mappedEntries == null) {\n            m_mappedEntries = LazyMap.decorate(new HashMap<Object, CmsListBoxEntry>(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsListBoxEntry entry = null;\n\n                    try {\n                        CmsXmlContent content;\n                        if (input instanceof CmsXmlContent) {\n                            content = (CmsXmlContent)input;\n                        } else {\n                            CmsResource resource = (CmsResource)input;\n                            content = CmsXmlContentFactory.unmarshal(getCmsObject(), getCmsObject().readFile(resource));\n                        }\n\n                        if (getMapping() != null) {\n                            entry = getMapping().getEntryFromXmlContent(\n                                getCmsObject(),\n                                content,\n                                getRequestContext().getLocale());\n                        }\n                    } catch (CmsException ex) {\n                        // noop\n                    }\n\n                    return entry;\n                }\n            });\n        }\n        return m_mappedEntries;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.jsp.CmsJspBean#init(javax.servlet.jsp.PageContext, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void init(PageContext context, HttpServletRequest req, HttpServletResponse res) {\n\n        super.init(context, req, res);\n\n        // collect the configuration information \n        try {\n            String path = req.getParameter(PARAM_FILE);\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(path)) {\n                // TODO\n            }\n\n            CmsFile file = getCmsObject().readFile(\n                getCmsObject().getRequestContext().removeSiteRoot(path),\n                CmsResourceFilter.IGNORE_EXPIRATION);\n            m_content = CmsXmlContentFactory.unmarshal(getCmsObject(), file);\n\n            // process the default mappings (if set / available)\n            m_mapping = null;\n            int mapsize = m_content.getValues(NODE_MAPPING, getRequestContext().getLocale()).size();\n            if (mapsize > 0) {\n                m_mapping = new CmsListBoxContentMapping();\n                for (int i = 1; i <= mapsize; i++) {\n                    String basePath = CmsXmlUtils.createXpath(NODE_MAPPING, i);\n\n                    String field = m_content.getStringValue(\n                        getCmsObject(),\n                        CmsXmlUtils.concatXpath(basePath, \"Field\"),\n                        getRequestContext().getLocale());\n                    String defaultValue = m_content.getStringValue(getCmsObject(), CmsXmlUtils.concatXpath(\n                        basePath,\n                        \"Default\"), getRequestContext().getLocale());\n                    String maxLenghtStr = m_content.getStringValue(getCmsObject(), CmsXmlUtils.concatXpath(\n                        basePath,\n                        \"MaxLength\"), getRequestContext().getLocale());\n                    List xmlNodes = m_content.getValues(\n                        CmsXmlUtils.concatXpath(basePath, \"XmlNode\"),\n                        getRequestContext().getLocale());\n                    List nodes = new ArrayList(xmlNodes.size());\n                    for (int j = 0; j < xmlNodes.size(); j++) {\n                        nodes.add(((I_CmsXmlContentValue)xmlNodes.get(j)).getStringValue(getCmsObject()));\n                    }\n                    m_mapping.addListBoxFieldMapping(nodes, field, maxLenghtStr, defaultValue);\n                }\n            }\n\n        } catch (Exception e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getMessage(), e);\n            }\n        }\n    }","id":38393,"modified_method":"/**\n     * @see org.opencms.jsp.CmsJspBean#init(javax.servlet.jsp.PageContext, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    @Override\n    public void init(PageContext context, HttpServletRequest req, HttpServletResponse res) {\n\n        super.init(context, req, res);\n\n        // collect the configuration information \n        try {\n            String path = req.getParameter(I_CmsResourceLoader.PARAMETER_ELEMENT);\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(path)) {\n                // TODO\n            }\n\n            CmsFile file = getCmsObject().readFile(\n                getCmsObject().getRequestContext().removeSiteRoot(path),\n                CmsResourceFilter.IGNORE_EXPIRATION);\n            m_content = CmsXmlContentFactory.unmarshal(getCmsObject(), file);\n\n            // process the default mappings (if set / available)\n            m_mapping = null;\n            int mapsize = m_content.getValues(NODE_MAPPING, getRequestContext().getLocale()).size();\n            if (mapsize > 0) {\n                m_mapping = new CmsListBoxContentMapping();\n                for (int i = 1; i <= mapsize; i++) {\n                    String basePath = CmsXmlUtils.createXpath(NODE_MAPPING, i);\n\n                    String field = m_content.getStringValue(\n                        getCmsObject(),\n                        CmsXmlUtils.concatXpath(basePath, \"Field\"),\n                        getRequestContext().getLocale());\n                    String defaultValue = m_content.getStringValue(getCmsObject(), CmsXmlUtils.concatXpath(\n                        basePath,\n                        \"Default\"), getRequestContext().getLocale());\n                    String maxLenghtStr = m_content.getStringValue(getCmsObject(), CmsXmlUtils.concatXpath(\n                        basePath,\n                        \"MaxLength\"), getRequestContext().getLocale());\n                    List<I_CmsXmlContentValue> xmlNodes = m_content.getValues(CmsXmlUtils.concatXpath(\n                        basePath,\n                        \"XmlNode\"), getRequestContext().getLocale());\n                    List<String> nodes = new ArrayList<String>(xmlNodes.size());\n                    for (int j = 0; j < xmlNodes.size(); j++) {\n                        nodes.add(xmlNodes.get(j).getStringValue(getCmsObject()));\n                    }\n                    m_mapping.addListBoxFieldMapping(nodes, field, maxLenghtStr, defaultValue);\n                }\n                m_mapping.setFacade(m_content.getValue(NODE_FACADE, getRequestContext().getLocale()).getStringValue(\n                    getCmsObject()));\n            }\n        } catch (Exception e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getMessage(), e);\n            }\n        }\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry Description.<p>\n     * \n     * If no XML element has been mapped to the list box entry Description, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry Description\n     */\n    public String getMappingForDescription() {\n\n        CmsListBoxFieldMapping mapping = (CmsListBoxFieldMapping)m_mappings.get(ENTRY_TEXT);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","id":38394,"modified_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry Description.<p>\n     * \n     * If no XML element has been mapped to the list box entry Description, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry Description\n     */\n    public String getMappingForDescription() {\n\n        CmsListBoxFieldMapping mapping = m_mappings.get(ENTRY_TEXT);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a new list box field mapping with default value and max length setting.<p> \n     * \n     * @param xmlFields the fields in the XML content to map\n     * @param listBoxField the field in the list box to map the XML content to \n     * @param maxLength the maximum length the field is allowed to have (will be converted to an int)\n     * @param defaultValue the default value for the list box entry field in case no XML content match is found\n     */\n    public void addListBoxFieldMapping(List xmlFields, String listBoxField, String maxLength, String defaultValue) {\n\n        // store mappings as xpath to allow better control about what is mapped\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(defaultValue)) {\n            // we don't allow only whitespace defaults\n            defaultValue = null;\n        }\n        int maxLengthInt = 0;\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxLength)) {\n            try {\n                maxLengthInt = Integer.parseInt(maxLength);\n            } catch (NumberFormatException e) {\n                // should not happen as the XSD already checks this\n            }\n        }\n        addListBoxFieldMapping(xmlFields, listBoxField, maxLengthInt, defaultValue);\n    }","id":38395,"modified_method":"/**\n     * Adds a new list box field mapping with default value and max length setting.<p> \n     * \n     * @param xmlFields the fields in the XML content to map\n     * @param listBoxField the field in the list box to map the XML content to \n     * @param maxLength the maximum length the field is allowed to have (will be converted to an int)\n     * @param defaultValue the default value for the list box entry field in case no XML content match is found\n     */\n    public void addListBoxFieldMapping(\n        List<String> xmlFields,\n        String listBoxField,\n        String maxLength,\n        String defaultValue) {\n\n        // store mappings as xpath to allow better control about what is mapped\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(defaultValue)) {\n            // we don't allow only whitespace defaults\n            defaultValue = null;\n        }\n        int maxLengthInt = 0;\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxLength)) {\n            try {\n                maxLengthInt = Integer.parseInt(maxLength);\n            } catch (NumberFormatException e) {\n                // should not happen as the XSD already checks this\n            }\n        }\n        addListBoxFieldMapping(xmlFields, listBoxField, maxLengthInt, defaultValue);\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new list box content mapping.<p>\n     */\n    public CmsListBoxContentMapping() {\n\n        m_mappings = new HashMap();\n    }","id":38396,"modified_method":"/**\n     * Creates a new list box content mapping.<p>\n     */\n    public CmsListBoxContentMapping() {\n\n        m_mappings = new HashMap<String, CmsListBoxFieldMapping>();\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a new list box field mapping with default value and max length setting.<p> \n     * \n     * @param xmlFields the fields in the XML content to map\n     * @param listBoxField the field in the list box to map the XML content to\n     * @param maxLength the maximum length the field is allowed to have\n     * @param defaultValue the default value for the list box entry field in case no XML content match is found\n     */\n    public void addListBoxFieldMapping(List xmlFields, String listBoxField, int maxLength, String defaultValue) {\n\n        if (MAPPINGS_LIST.contains(listBoxField)) {\n            CmsListBoxFieldMapping mapping = new CmsListBoxFieldMapping(\n                xmlFields,\n                listBoxField,\n                maxLength,\n                defaultValue);\n            m_mappings.put(listBoxField, mapping);\n        }\n    }","id":38397,"modified_method":"/**\n     * Adds a new list box field mapping with default value and max length setting.<p> \n     * \n     * @param xmlFields the fields in the XML content to map\n     * @param listBoxField the field in the list box to map the XML content to\n     * @param maxLength the maximum length the field is allowed to have\n     * @param defaultValue the default value for the list box entry field in case no XML content match is found\n     */\n    public void addListBoxFieldMapping(List<String> xmlFields, String listBoxField, int maxLength, String defaultValue) {\n\n        if (MAPPINGS_LIST.contains(listBoxField)) {\n            CmsListBoxFieldMapping mapping = new CmsListBoxFieldMapping(\n                xmlFields,\n                listBoxField,\n                maxLength,\n                defaultValue);\n            m_mappings.put(listBoxField, mapping);\n        }\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a list box entry created from the given XML content using the configured rules of this content mapping.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param content the XML content to create the list box entry from\n     * @param locale the locale to use in the XML content\n     * \n     * @return a list box entry created from the given XML content using the configured rules of this content mapping\n     */\n    public CmsListBoxEntry getEntryFromXmlContent(CmsObject cms, CmsXmlContent content, Locale locale) {\n\n        if ((content == null) || (locale == null) || !content.hasLocale(locale)) {\n            // no entry can be created if input is silly\n            return null;\n        }\n\n        // get all configured mappings\n        Set mappings = m_mappings.entrySet();\n        // create the empty syndication entry\n        CmsListBoxEntry result = new CmsListBoxEntry();\n        boolean hasTitle = false;\n\n        Iterator i = mappings.iterator();\n        String link = null;\n        Date date = null;\n        while (i.hasNext()) {\n            Map.Entry e = (Map.Entry)i.next();\n            String listBoxField = (String)e.getKey();\n            CmsListBoxFieldMapping mapping = (CmsListBoxFieldMapping)e.getValue();\n\n            I_CmsXmlContentValue xmlContentValue = null;\n            List xmlFields = mapping.getXmlFields();\n            for (int j = 0, size = xmlFields.size(); j < size; j++) {\n                String xmlField = (String)xmlFields.get(j);\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(xmlField)) {\n                    xmlContentValue = content.getValue(xmlField, locale);\n                    if (xmlContentValue != null) {\n                        // found a matching XML content node\n                        break;\n                    }\n                }\n            }\n            String value = null;\n            if (xmlContentValue != null) {\n                // value was found in the content\n                value = xmlContentValue.getStringValue(cms);\n            } else if (mapping.hasDefaultValue()) {\n                // value not found in content, use default value\n                value = mapping.getDefaultValue();\n            }\n            if (value != null) {\n                if (mapping.hasMaxLenghtLimit()) {\n                    // apply length restriction if required\n                    value = applyLengthRestriction(cms, xmlContentValue, value, mapping.getMaxLenght());\n                }\n                // a value to map was found\n                int pos = MAPPINGS_LIST.indexOf(listBoxField);\n                switch (pos) {\n                    case 0: // Title\n                        result.setTitle(value);\n                        hasTitle = true;\n                        break;\n                    case 1: // Author\n                        result.setAuthor(value);\n                        break;\n                    case 2: // Description\n                        result.setDescription(value);\n                        break;\n                    case 3: // Date\n                        date = convertToDate(cms, content.getFile(), xmlContentValue, value);\n                        if (date != null) {\n                            result.setDate(date);\n                        }\n                        break;\n                    case 4: // Link\n                        // use link as provided in content\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            link = OpenCms.getLinkManager().getServerLink(cms, value);\n                        }\n                        break;\n                    case 5: // Image\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            result.setImage(value);\n                        }\n                        break;\n                    default: // unknown, this cannot happen as all mappings are checked when created            \n                }\n            }\n        }\n\n        if (hasTitle) {\n            // we need at least an entry and an description\n            if (link == null) {\n                // calculate the link\n                link = OpenCms.getLinkManager().getServerLink(cms, cms.getSitePath(content.getFile()));\n            }\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(link)) {\n                result.setLink(link);\n            }\n        } else {\n            // required mappings are not available\n            result = null;\n        }\n        return result;\n    }","id":38398,"modified_method":"/**\n     * Returns a list box entry created from the given XML content using the configured rules of this content mapping.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param content the XML content to create the list box entry from\n     * @param locale the locale to use in the XML content\n     * \n     * @return a list box entry created from the given XML content using the configured rules of this content mapping\n     */\n    public CmsListBoxEntry getEntryFromXmlContent(CmsObject cms, CmsXmlContent content, Locale locale) {\n\n        if ((content == null) || (locale == null) || !content.hasLocale(locale)) {\n            // no entry can be created if input is silly\n            return null;\n        }\n\n        // get all configured mappings\n        Set<Map.Entry<String, CmsListBoxFieldMapping>> mappings = m_mappings.entrySet();\n        // create the empty syndication entry\n        CmsListBoxEntry result = new CmsListBoxEntry();\n        boolean hasTitle = false;\n\n        Iterator<Map.Entry<String, CmsListBoxFieldMapping>> i = mappings.iterator();\n        String link = null;\n        Date date = null;\n        while (i.hasNext()) {\n            Map.Entry<String, CmsListBoxFieldMapping> e = i.next();\n            String listBoxField = e.getKey();\n            CmsListBoxFieldMapping mapping = e.getValue();\n\n            I_CmsXmlContentValue xmlContentValue = null;\n            List<String> xmlFields = mapping.getXmlFields();\n            for (int j = 0, size = xmlFields.size(); j < size; j++) {\n                String xmlField = xmlFields.get(j);\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(xmlField)) {\n                    xmlContentValue = content.getValue(xmlField, locale);\n                    if (xmlContentValue != null) {\n                        // found a matching XML content node\n                        break;\n                    }\n                }\n            }\n            String value = null;\n            if (xmlContentValue != null) {\n                // value was found in the content\n                value = xmlContentValue.getStringValue(cms);\n            } else if (mapping.hasDefaultValue()) {\n                // value not found in content, use default value\n                value = mapping.getDefaultValue();\n            }\n            if (value != null) {\n                if (mapping.hasMaxLenghtLimit()) {\n                    // apply length restriction if required\n                    value = applyLengthRestriction(cms, xmlContentValue, value, mapping.getMaxLenght());\n                }\n                // a value to map was found\n                int pos = MAPPINGS_LIST.indexOf(listBoxField);\n                switch (pos) {\n                    case 0: // Title\n                        result.setTitle(value);\n                        hasTitle = true;\n                        break;\n                    case 1: // Author\n                        result.setAuthor(value);\n                        break;\n                    case 2: // Description\n                        result.setDescription(value);\n                        break;\n                    case 3: // Date\n                        date = convertToDate(cms, content.getFile(), xmlContentValue, value);\n                        if (date != null) {\n                            result.setDate(date);\n                        }\n                        break;\n                    case 4: // Link\n                        // use link as provided in content\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            link = OpenCms.getLinkManager().getServerLink(cms, value);\n                        }\n                        break;\n                    case 5: // Image\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            result.setImage(value);\n                        }\n                        break;\n                    default: // unknown, this cannot happen as all mappings are checked when created            \n                }\n            }\n        }\n\n        if (hasTitle) {\n            // we need at least an entry and an description\n            if (link == null) {\n                // calculate the link                \n                link = OpenCms.getLinkManager().getServerLink(cms, m_facade);\n                link = CmsRequestUtil.appendParameter(\n                    link,\n                    CmsContainerPageBean.TEMPLATE_ELEMENT_PARAMETER,\n                    content.getFile().getStructureId().toString());\n            }\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(link)) {\n                result.setLink(link);\n            }\n        } else {\n            // required mappings are not available\n            result = null;\n        }\n        return result;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Converts an XML content value to a Date.<p>\n     * \n     * In case the XML content value itself can not be converted to a date, \n     * the given String value is used to access the given files attributes or properties\n     * using {@link CmsDateResourceComparator#calculateDate(CmsObject, org.opencms.file.CmsResource, List, long)}.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param file the current file from which the list box entry is created\n     * @param xmlContentValue the XML content value to convert\n     * @param stringValue the String value of the XML content value\n     * \n     * @return the converted Date, or <code>null<\/code> if no convertible data was found\n     */\n    private Date convertToDate(CmsObject cms, CmsFile file, I_CmsXmlContentValue xmlContentValue, String stringValue) {\n\n        Date result = null;\n        if (xmlContentValue instanceof CmsXmlDateTimeValue) {\n            // dates should be using the right XML content value type\n            result = new Date(((CmsXmlDateTimeValue)xmlContentValue).getDateTimeValue());\n        } else {\n            try {\n                // try to parse the date as long\n                result = new Date(Long.valueOf(stringValue).longValue());\n            } catch (NumberFormatException e) {\n                // no luck parsing, so we have no date - try using other options...\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(stringValue)) {\n                    List items = CmsStringUtil.splitAsList(stringValue, '|', true);\n                    long date = CmsDateResourceComparator.calculateDate(cms, file, items, -1);\n                    if (date != -1) {\n                        result = new Date(date);\n                    }\n                }\n            }\n        }\n        return result;\n    }","id":38399,"modified_method":"/**\n     * Converts an XML content value to a Date.<p>\n     * \n     * In case the XML content value itself can not be converted to a date, \n     * the given String value is used to access the given files attributes or properties\n     * using {@link CmsDateResourceComparator#calculateDate(CmsObject, org.opencms.file.CmsResource, List, long)}.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param file the current file from which the list box entry is created\n     * @param xmlContentValue the XML content value to convert\n     * @param stringValue the String value of the XML content value\n     * \n     * @return the converted Date, or <code>null<\/code> if no convertible data was found\n     */\n    private Date convertToDate(CmsObject cms, CmsFile file, I_CmsXmlContentValue xmlContentValue, String stringValue) {\n\n        Date result = null;\n        if (xmlContentValue instanceof CmsXmlDateTimeValue) {\n            // dates should be using the right XML content value type\n            result = new Date(((CmsXmlDateTimeValue)xmlContentValue).getDateTimeValue());\n        } else {\n            try {\n                // try to parse the date as long\n                result = new Date(Long.valueOf(stringValue).longValue());\n            } catch (NumberFormatException e) {\n                // no luck parsing, so we have no date - try using other options...\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(stringValue)) {\n                    List<String> items = CmsStringUtil.splitAsList(stringValue, '|', true);\n                    long date = CmsDateResourceComparator.calculateDate(cms, file, items, -1);\n                    if (date != -1) {\n                        result = new Date(date);\n                    }\n                }\n            }\n        }\n        return result;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Creates a new list box field mapping with default value and max length.<p> \n         * \n         * @param xmlField the field in the XML content to map\n         * @param listBoxField the field in the list box to map the XML content to\n         * @param maxLength the maximum length the field is allowed to have\n         * @param defaultValue the default value for the list box entry field in case no XML content match is found\n         */\n        public CmsListBoxFieldMapping(String xmlField, String listBoxField, int maxLength, String defaultValue) {\n\n            this(new ArrayList(Collections.singletonList(xmlField)), listBoxField, maxLength, defaultValue);\n        }","id":38400,"modified_method":"/**\n         * Creates a new list box field mapping with default value and max length.<p> \n         * \n         * @param xmlField the field in the XML content to map\n         * @param listBoxField the field in the list box to map the XML content to\n         * @param maxLength the maximum length the field is allowed to have\n         * @param defaultValue the default value for the list box entry field in case no XML content match is found\n         */\n        public CmsListBoxFieldMapping(String xmlField, String listBoxField, int maxLength, String defaultValue) {\n\n            this(new ArrayList<String>(Collections.singletonList(xmlField)), listBoxField, maxLength, defaultValue);\n        }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**        \n        * Creates a new list box field mapping to a list of XML fields with default value and max length.<p> \n        * \n        * @param xmlFields the List of field in the XML content to map (String with xpath)\n        * @param listBoxField the field in the list box to map the XML content to\n        * @param maxLength the maximum length the field is allowed to have\n        * @param defaultValue the default value for the list box field in case no XML content match is found\n        */\n        public CmsListBoxFieldMapping(List xmlFields, String listBoxField, int maxLength, String defaultValue) {\n\n            m_xmlFields = xmlFields;\n            m_listBoxField = listBoxField;\n            m_defaultValue = defaultValue;\n            m_maxLenght = maxLength;\n        }","id":38401,"modified_method":"/**        \n        * Creates a new list box field mapping to a list of XML fields with default value and max length.<p> \n        * \n        * @param xmlFields the List of field in the XML content to map (String with xpath)\n        * @param listBoxField the field in the list box to map the XML content to\n        * @param maxLength the maximum length the field is allowed to have\n        * @param defaultValue the default value for the list box field in case no XML content match is found\n        */\n        public CmsListBoxFieldMapping(List<String> xmlFields, String listBoxField, int maxLength, String defaultValue) {\n\n            m_xmlFields = xmlFields;\n            m_listBoxField = listBoxField;\n            m_defaultValue = defaultValue;\n            m_maxLenght = maxLength;\n        }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry date.<p>\n     * \n     * If no XML element has been mapped to the list box entry date, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry date\n     */\n    public String getMappingForDate() {\n\n        CmsListBoxFieldMapping mapping = (CmsListBoxFieldMapping)m_mappings.get(ENTRY_DATE);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","id":38402,"modified_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry date.<p>\n     * \n     * If no XML element has been mapped to the list box entry date, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry date\n     */\n    public String getMappingForDate() {\n\n        CmsListBoxFieldMapping mapping = m_mappings.get(ENTRY_DATE);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry Title.<p>\n     * \n     * If no XML element has been mapped to the list box entry Title, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry Title\n     */\n    public String getMappingForTitle() {\n\n        CmsListBoxFieldMapping mapping = (CmsListBoxFieldMapping)m_mappings.get(ENTRY_TITLE);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","id":38403,"modified_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry Title.<p>\n     * \n     * If no XML element has been mapped to the list box entry Title, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry Title\n     */\n    public String getMappingForTitle() {\n\n        CmsListBoxFieldMapping mapping = m_mappings.get(ENTRY_TITLE);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry Author.<p>\n     * \n     * If no XML element has been mapped to the list box entry Author, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry Author\n     */\n    public String getMappingForAuthor() {\n\n        CmsListBoxFieldMapping mapping = (CmsListBoxFieldMapping)m_mappings.get(ENTRY_AUTHOR);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","id":38404,"modified_method":"/**\n     * Returns the path of the first XML element that is mapped to the list box entry Author.<p>\n     * \n     * If no XML element has been mapped to the list box entry Author, <code>null<\/code> is returned.<p>\n     * \n     * @return the path of the first XML element that is mapped to the list box entry Author\n     */\n    public String getMappingForAuthor() {\n\n        CmsListBoxFieldMapping mapping = m_mappings.get(ENTRY_AUTHOR);\n        return (mapping != null) ? (String)mapping.getXmlFields().get(0) : null;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.jsp.CmsJspBean#init(javax.servlet.jsp.PageContext, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void init(PageContext context, HttpServletRequest req, HttpServletResponse res) {\n\n        super.init(context, req, res);\n\n        // preset\n        try {\n\n            m_presetPath = req.getParameter(PARAM_PRESET);\n            if (m_presetPath == null) {\n\n                // init configuration\n                initConfig();\n            }\n\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(m_presetPath)) {\n                CmsResource preset = getCmsObject().readResource(\n                    getCmsObject().getRequestContext().removeSiteRoot(m_presetPath),\n                    CmsResourceFilter.IGNORE_EXPIRATION);\n\n                Locale locale = OpenCms.getLocaleManager().getDefaultLocale(\n                    getCmsObject(),\n                    getCmsObject().getSitePath(preset));\n                m_preset = new CmsJspContentAccessBean(getCmsObject(), locale, preset);\n            }\n        } catch (Exception e) {\n            // problem reading preset, log error\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getMessage(), e);\n            }\n        }\n\n        // style\n        try {\n            m_stylePath = req.getParameter(PARAM_STYLE);\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_stylePath)) {\n                m_stylePath = property(PROPERTY_STYLE, \"search\");\n            }\n\n            CmsResource style = getCmsObject().readResource(\n                getCmsObject().getRequestContext().removeSiteRoot(m_stylePath),\n                CmsResourceFilter.IGNORE_EXPIRATION);\n\n            Locale locale = OpenCms.getLocaleManager().getDefaultLocale(\n                getCmsObject(),\n                getCmsObject().getSitePath(style));\n            m_style = new CmsJspContentAccessBean(getCmsObject(), locale, style);\n        } catch (Exception e) {\n            // problem reading preset, log error\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getMessage(), e);\n            }\n        }\n\n        // options\n        try {\n            String optionsPath = property(PROPERTY_OPTIONS, \"search\");\n\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(optionsPath)) {\n                CmsResource options = getCmsObject().readResource(\n                    getCmsObject().getRequestContext().removeSiteRoot(optionsPath),\n                    CmsResourceFilter.IGNORE_EXPIRATION);\n\n                Locale locale = OpenCms.getLocaleManager().getDefaultLocale(\n                    getCmsObject(),\n                    getCmsObject().getSitePath(options));\n                m_options = new CmsJspContentAccessBean(getCmsObject(), locale, options);\n            }\n\n        } catch (Exception e) {\n            // problem reading options, log error\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getMessage(), e);\n            }\n        }\n    }","id":38405,"modified_method":"/**\n     * @see org.opencms.jsp.CmsJspBean#init(javax.servlet.jsp.PageContext, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    @Override\n    public void init(PageContext context, HttpServletRequest req, HttpServletResponse res) {\n\n        super.init(context, req, res);\n\n        // style\n        try {\n            m_stylePath = req.getParameter(PARAM_STYLE);\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_stylePath)) {\n                m_stylePath = property(PROPERTY_STYLE, \"search\");\n            }\n\n            CmsResource style = getCmsObject().readResource(\n                getCmsObject().getRequestContext().removeSiteRoot(m_stylePath),\n                CmsResourceFilter.IGNORE_EXPIRATION);\n\n            Locale locale = OpenCms.getLocaleManager().getDefaultLocale(\n                getCmsObject(),\n                getCmsObject().getSitePath(style));\n            m_style = new CmsJspContentAccessBean(getCmsObject(), locale, style);\n        } catch (Exception e) {\n            // problem reading preset, log error\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getMessage(), e);\n            }\n        }\n\n        // options\n        try {\n            String optionsPath = property(PROPERTY_OPTIONS, \"search\");\n\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(optionsPath)) {\n                CmsResource options = getCmsObject().readResource(\n                    getCmsObject().getRequestContext().removeSiteRoot(optionsPath),\n                    CmsResourceFilter.IGNORE_EXPIRATION);\n\n                Locale locale = OpenCms.getLocaleManager().getDefaultLocale(\n                    getCmsObject(),\n                    getCmsObject().getSitePath(options));\n                m_options = new CmsJspContentAccessBean(getCmsObject(), locale, options);\n            }\n\n        } catch (Exception e) {\n            // problem reading options, log error\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getMessage(), e);\n            }\n        }\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Wrapper which returns null instead of an empty string to use the default\n     * functionality of &lt;c:out&gt;.<p>\n     * \n     * @return a lazy initialized map\n     */\n    public Map getStyleValue() {\n\n        if (m_styleValue == null) {\n            m_styleValue = LazyMap.decorate(new HashMap(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    if (getStyle() == null) {\n                        return null;\n                    }\n\n                    Object obj = getStyle().getValue().get(input);\n                    if (obj == null) {\n                        return null;\n                    }\n\n                    String value = obj.toString();\n                    if (CmsStringUtil.isEmptyOrWhitespaceOnly(value)) {\n                        return null;\n                    }\n\n                    return value;\n                }\n            });\n        }\n        return m_styleValue;\n    }","id":38406,"modified_method":"/**\n     * Wrapper which returns null instead of an empty string to use the default\n     * functionality of &lt;c:out&gt;.<p>\n     * \n     * @return a lazy initialized map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, String> getStyleValue() {\n\n        if (m_styleValue == null) {\n            m_styleValue = LazyMap.decorate(new HashMap<String, String>(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    if (getStyle() == null) {\n                        return null;\n                    }\n\n                    Object obj = getStyle().getValue().get(input);\n                    if (obj == null) {\n                        return null;\n                    }\n\n                    String value = obj.toString();\n                    if (CmsStringUtil.isEmptyOrWhitespaceOnly(value)) {\n                        return null;\n                    }\n\n                    return value;\n                }\n            });\n        }\n        return m_styleValue;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a list with css stylesheet files to include in the template.<p>\n     * \n     * @return a list with css stylesheet files to include in the template\n     */\n    public List getStylesheets() {\n\n        ArrayList result = new ArrayList();\n\n        String navMain = null;\n\n        // find path of the jsp of the main menu\n        String navPath = (String)getStyleValue().get(\"nav.main\");\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(navPath)) {\n            navMain = property(PROPERTY_STYLE, navPath);\n        }\n\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(navMain)) {\n            result.add(navMain);\n        } else {\n            // use default\n            result.add(VFS_PATH_CSS_DEAFULT_MAIN_NAV);\n        }\n        result.add(VFS_PATH_CSS_LEFT_NAV);\n\n        return result;\n    }","id":38407,"modified_method":"/**\n     * Returns a list with css stylesheet files to include in the template.<p>\n     * \n     * @return a list with css stylesheet files to include in the template\n     */\n    public List<String> getStylesheets() {\n\n        List<String> result = new ArrayList<String>();\n\n        String navMain = null;\n\n        // find path of the jsp of the main menu\n        String navPath = getStyleValue().get(\"nav.main\");\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(navPath)) {\n            navMain = property(PROPERTY_STYLE, navPath);\n        }\n\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(navMain)) {\n            result.add(navMain);\n        } else {\n            // use default\n            result.add(VFS_PATH_CSS_DEAFULT_MAIN_NAV);\n        }\n        result.add(VFS_PATH_CSS_LEFT_NAV);\n\n        return result;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a lazy initialized map that provides the navigation text as a key in the Map.<p> \n     * \n     * @return a lazy initialized map\n     */\n    public Map getNavText() {\n\n        if (m_navText == null) {\n            m_navText = LazyMap.decorate(new HashMap(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsJspNavElement elem = (CmsJspNavElement)input;\n\n                    String text = elem.getProperty(CmsPropertyDefinition.PROPERTY_NAVTEXT);\n                    if (CmsStringUtil.isEmptyOrWhitespaceOnly(text)) {\n                        text = elem.getProperty(CmsPropertyDefinition.PROPERTY_TITLE);\n                    }\n\n                    return text;\n                }\n            });\n        }\n        return m_navText;\n    }","id":38408,"modified_method":"/**\n     * Returns a lazy initialized map that provides the navigation text as a key in the Map.<p> \n     * \n     * @return a lazy initialized map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Map<CmsJspNavElement, String> getNavText() {\n\n        if (m_navText == null) {\n            m_navText = LazyMap.decorate(new HashMap<CmsJspNavElement, String>(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsJspNavElement elem = (CmsJspNavElement)input;\n\n                    String text = elem.getProperty(CmsPropertyDefinition.PROPERTY_NAVTEXT);\n                    if (CmsStringUtil.isEmptyOrWhitespaceOnly(text)) {\n                        text = elem.getProperty(CmsPropertyDefinition.PROPERTY_TITLE);\n                    }\n\n                    return text;\n                }\n            });\n        }\n        return m_navText;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the list with the elements of the menu.<p>\n     *\n     * @param elements the list with the elements of the menu to set\n     */\n    public void setElements(List elements) {\n\n        m_elements = elements;\n    }","id":38409,"modified_method":"/**\n     * Sets the list with the elements of the menu.<p>\n     *\n     * @param elements the list with the elements of the menu to set\n     */\n    public void setElements(List<CmsJspNavElement> elements) {\n\n        m_elements = elements;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a lazy initialized map that provides the current elements as a key in the Map.<p> \n     * \n     * @return a lazy initialized map\n     */\n    public Map getIsCurrent() {\n\n        if (m_current == null) {\n            m_current = LazyMap.decorate(new HashMap(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsJspNavElement elem = (CmsJspNavElement)input;\n\n                    String uri = getCmsObject().getRequestContext().getUri();\n                    CmsJspNavElement uriElem = null;\n                    try {\n                        uriElem = new CmsJspNavElement(uri, CmsProperty.toMap(getCmsObject().readPropertyObjects(\n                            uri,\n                            false)));\n                    } catch (CmsException ex) {\n                        // noop\n                    }\n\n                    // check if uri matches resource name\n                    if (elem.getResourceName().equals(uri)) {\n                        return new Boolean(true);\n                    }\n\n                    // check if the default file for the uri matches the resource name\n                    String path = CmsJspNavBuilder.getDefaultFile(getCmsObject(), elem.getResourceName());\n                    if (path == null || uriElem.isInNavigation()) {\n                        path = elem.getResourceName();\n                    }\n\n                    if (uri.equals(path)) {\n                        return new Boolean(true);\n                    }\n\n                    // check if uri is in NOT in the navigation and so a parent folder will be marked as current\n                    CmsJspNavElement navElem = uriElem;\n                    while (navElem != null && !navElem.isInNavigation()) {\n\n                        String parentPath = CmsResource.getParentFolder(navElem.getResourceName());\n                        if (parentPath == null) {\n                            break;\n                        }\n                        try {\n                            navElem = new CmsJspNavElement(\n                                parentPath,\n                                CmsProperty.toMap(getCmsObject().readPropertyObjects(parentPath, false)));\n                        } catch (CmsException ex) {\n                            break;\n                        }\n                    }\n\n                    if (navElem != null && !uriElem.isInNavigation()) {\n\n                        return new Boolean(elem.equals(navElem));\n                    }\n\n                    return new Boolean(false);\n                }\n            });\n        }\n        return m_current;\n    }","id":38410,"modified_method":"/**\n     * Returns a lazy initialized map that provides the current elements as a key in the Map.<p> \n     * \n     * @return a lazy initialized map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Map<CmsJspNavElement, Boolean> getIsCurrent() {\n\n        if (m_current == null) {\n            m_current = LazyMap.decorate(new HashMap<CmsJspNavElement, Boolean>(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsJspNavElement elem = (CmsJspNavElement)input;\n\n                    String uri = getCmsObject().getRequestContext().getUri();\n                    CmsJspNavElement uriElem = null;\n                    try {\n                        uriElem = new CmsJspNavElement(uri, CmsProperty.toMap(getCmsObject().readPropertyObjects(\n                            uri,\n                            false)));\n                    } catch (CmsException ex) {\n                        // noop\n                    }\n\n                    // check if uri matches resource name\n                    if (elem.getResourceName().equals(uri)) {\n                        return Boolean.TRUE;\n                    }\n\n                    // check if the default file for the uri matches the resource name\n                    String path = CmsJspNavBuilder.getDefaultFile(getCmsObject(), elem.getResourceName());\n                    if ((path == null) || ((uriElem != null) && uriElem.isInNavigation())) {\n                        path = elem.getResourceName();\n                    }\n\n                    if (uri.equals(path)) {\n                        return Boolean.TRUE;\n                    }\n\n                    // check if uri is in NOT in the navigation and so a parent folder will be marked as current\n                    CmsJspNavElement navElem = uriElem;\n                    while ((navElem != null) && !navElem.isInNavigation()) {\n\n                        String parentPath = CmsResource.getParentFolder(navElem.getResourceName());\n                        if (parentPath == null) {\n                            break;\n                        }\n                        try {\n                            navElem = new CmsJspNavElement(\n                                parentPath,\n                                CmsProperty.toMap(getCmsObject().readPropertyObjects(parentPath, false)));\n                        } catch (CmsException ex) {\n                            break;\n                        }\n                    }\n\n                    if ((navElem != null) && (uriElem != null) && !uriElem.isInNavigation()) {\n                        return Boolean.valueOf(elem.equals(navElem));\n                    }\n\n                    return Boolean.FALSE;\n                }\n            });\n        }\n        return m_current;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a lazy initialized map that provides the current elements as a key in the Map.<p> \n     * \n     * @return a lazy initialized map\n     */\n    public Map getHasChildren() {\n\n        if (m_children == null) {\n            m_children = LazyMap.decorate(new HashMap(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsJspNavElement elem = (CmsJspNavElement)input;\n\n                    int currentLevel = elem.getNavTreeLevel();\n                    int index = getElements().indexOf(elem);\n\n                    if (index < getElements().size() - 1) {\n                        CmsJspNavElement next = (CmsJspNavElement)getElements().get(index + 1);\n                        if (next.getNavTreeLevel() > currentLevel) {\n                            return new Boolean(true);\n                        }\n                    }\n\n                    return new Boolean(false);\n                }\n            });\n        }\n        return m_children;\n    }","id":38411,"modified_method":"/**\n     * Returns a lazy initialized map that provides the current elements as a key in the Map.<p> \n     * \n     * @return a lazy initialized map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Map<CmsJspNavElement, Boolean> getHasChildren() {\n\n        if (m_children == null) {\n            m_children = LazyMap.decorate(new HashMap<CmsJspNavElement, Boolean>(), new Transformer() {\n\n                /**\n                 * @see org.apache.commons.collections.Transformer#transform(java.lang.Object)\n                 */\n                public Object transform(Object input) {\n\n                    CmsJspNavElement elem = (CmsJspNavElement)input;\n\n                    int currentLevel = elem.getNavTreeLevel();\n                    int index = getElements().indexOf(elem);\n\n                    if (index < getElements().size() - 1) {\n                        CmsJspNavElement next = getElements().get(index + 1);\n                        if (next.getNavTreeLevel() > currentLevel) {\n                            return Boolean.TRUE;\n                        }\n                    }\n\n                    return Boolean.FALSE;\n                }\n            });\n        }\n        return m_children;\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the top level of the navigation.<p>\n     * \n     * @return the top level of the navigation\n     */\n    public int getTopLevel() {\n\n        CmsJspNavElement elem = (CmsJspNavElement)m_elements.get(0);\n        if (elem == null) {\n            return 0;\n        }\n\n        return elem.getNavTreeLevel();\n    }","id":38412,"modified_method":"/**\n     * Returns the top level of the navigation.<p>\n     * \n     * @return the top level of the navigation\n     */\n    public int getTopLevel() {\n\n        if ((m_elements == null) || m_elements.isEmpty()) {\n            return 0;\n        }\n        CmsJspNavElement elem = m_elements.get(0);\n        if (elem == null) {\n            return 0;\n        }\n\n        return elem.getNavTreeLevel();\n    }","commit_id":"6191a44afb963247841dd6327a624709d555aca1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.actions.I_CmsWorkplaceAction#executeAction(org.opencms.ui.I_CmsDialogContext)\n     */\n    public void executeAction(I_CmsDialogContext context) {\n\n        CmsObject cms = A_CmsUI.getCmsObject();\n        String url = OpenCms.getLinkManager().substituteLink(cms, \"/system/workplace/editors/editor.jsp\");\n        url += \"?resource=\";\n        url += cms.getSitePath(context.getResources().get(0));\n        url += \"&backlink=\";\n        try {\n            url += URLEncoder.encode(UI.getCurrent().getPage().getLocation().toString(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            url += UI.getCurrent().getPage().getLocation().toString();\n        }\n        UI.getCurrent().getPage().open(url, \"_self\");\n    }","id":38413,"modified_method":"/**\n     * @see org.opencms.ui.actions.I_CmsWorkplaceAction#executeAction(org.opencms.ui.I_CmsDialogContext)\n     */\n    public void executeAction(I_CmsDialogContext context) {\n\n        String state = CmsEditor.RESOURCE_ID_PREFIX\n            + context.getResources().get(0).getStructureId().toString()\n            + CmsEditor.STATE_SEPARATOR\n            + CmsEditor.BACK_LINK_PREFIX;\n        try {\n\n            state += URLEncoder.encode(UI.getCurrent().getPage().getLocation().toString(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            state += UI.getCurrent().getPage().getLocation().toString();\n        }\n        CmsAppWorkplaceUi.get().showApp(OpenCms.getWorkplaceAppManager().getAppConfiguration(\"editor\"), state);\n    }","commit_id":"dd73b43d0058c5b876952366dd3e1c334d0b0053","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Loads the default apps.<p>\n     *\n     * @return the default apps\n     */\n    private Collection<I_CmsWorkplaceAppConfiguration> loadDefaultApps() {\n\n        List<I_CmsWorkplaceAppConfiguration> result = Lists.newArrayList();\n        result.addAll(\n            Arrays.<I_CmsWorkplaceAppConfiguration> asList(\n                new CmsSitemapEditorConfiguration(),\n                new CmsPageEditorConfiguration(),\n                new CmsFileExplorerConfiguration(),\n                new CmsScheduledJobsAppConfig(),\n                new CmsAppHierarchyConfiguration()));\n        return result;\n    }","id":38414,"modified_method":"/**\n     * Loads the default apps.<p>\n     *\n     * @return the default apps\n     */\n    private Collection<I_CmsWorkplaceAppConfiguration> loadDefaultApps() {\n\n        List<I_CmsWorkplaceAppConfiguration> result = Lists.newArrayList();\n        result.addAll(\n            Arrays.<I_CmsWorkplaceAppConfiguration> asList(\n                new CmsSitemapEditorConfiguration(),\n                new CmsPageEditorConfiguration(),\n                new CmsFileExplorerConfiguration(),\n                new CmsScheduledJobsAppConfig(),\n                new CmsAppHierarchyConfiguration(),\n                new CmsEditorConfiguration()));\n        return result;\n    }","commit_id":"dd73b43d0058c5b876952366dd3e1c334d0b0053","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.editors.I_CmsEditor#initUI(org.opencms.ui.apps.I_CmsAppUIContext, org.opencms.file.CmsResource, java.lang.String)\n     */\n    public void initUI(I_CmsAppUIContext context, CmsResource resource, String backLink) {\n\n        CmsObject cms = A_CmsUI.getCmsObject();\n        String link = OpenCms.getLinkManager().substituteLinkForRootPath(cms, getEditorUri());\n        m_frame = new BrowserFrame();\n        m_frame.setDescription(\"Editor\");\n        m_frame.setSource(\n            new ExternalResource(link + \"?resource=\" + cms.getSitePath(resource) + \"&backlink=\" + backLink));\n        m_frame.setSizeFull();\n        context.showInfoArea(false);\n        context.hideToolbar();\n        context.setAppContent(m_frame);\n    }","id":38415,"modified_method":"/**\n     * @see org.opencms.ui.editors.I_CmsEditor#initUI(org.opencms.ui.apps.I_CmsAppUIContext, org.opencms.file.CmsResource, java.lang.String)\n     */\n    public void initUI(I_CmsAppUIContext context, CmsResource resource, String backLink) {\n\n        CmsObject cms = A_CmsUI.getCmsObject();\n        String link = OpenCms.getLinkManager().substituteLinkForRootPath(cms, getEditorUri());\n        m_frame = new CmsBrowserFrame();\n        m_frame.setDescription(\"Editor\");\n        m_frame.setName(\"edit\");\n        m_frame.setSource(\n            new ExternalResource(link + \"?resource=\" + cms.getSitePath(resource) + \"&backlink=\" + backLink));\n        m_frame.setSizeFull();\n        context.showInfoArea(false);\n        context.hideToolbar();\n        context.setAppContent(m_frame);\n    }","commit_id":"65ad711dea2fb41f630a15a2a7e2445074ac93d1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.editors.I_CmsEditor#matchesResource(org.opencms.file.CmsResource)\n     */\n    public boolean matchesResource(CmsResource resource) {\n\n        I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n        boolean result = false;\n\n        if (type instanceof CmsResourceTypeXmlContent) {\n            try {\n                result = CmsWorkplaceEditorManager.checkAcaciaEditorAvailable(A_CmsUI.getCmsObject(), resource);\n            } catch (CmsException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        return result;\n    }","id":38416,"modified_method":"/**\n     * @see org.opencms.ui.editors.I_CmsEditor#matchesResource(org.opencms.file.CmsResource, boolean)\n     */\n    public boolean matchesResource(CmsResource resource, boolean plainText) {\n\n        I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n        boolean result = false;\n\n        if (!plainText && (type instanceof CmsResourceTypeXmlContent)) {\n            try {\n                result = CmsWorkplaceEditorManager.checkAcaciaEditorAvailable(A_CmsUI.getCmsObject(), resource);\n            } catch (CmsException e) {\n                LOG.error(\"Error evaluating XML schema for acacia editor.\", e);\n            }\n        }\n\n        return result;\n    }","commit_id":"65ad711dea2fb41f630a15a2a7e2445074ac93d1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.actions.I_CmsWorkplaceAction#executeAction(org.opencms.ui.I_CmsDialogContext)\n     */\n    public void executeAction(I_CmsDialogContext context) {\n\n        CmsObject cms = A_CmsUI.getCmsObject();\n        String url = OpenCms.getLinkManager().substituteLink(cms, \"/system/workplace/editors/editor.jsp\");\n        url += \"?resource=\";\n        url += cms.getSitePath(context.getResources().get(0));\n        url += \"&editastext=true\";\n        url += \"&backlink=\";\n        try {\n            url += URLEncoder.encode(UI.getCurrent().getPage().getLocation().toString(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            url += UI.getCurrent().getPage().getLocation().toString();\n        }\n        UI.getCurrent().getPage().open(url, \"_self\");\n    }","id":38417,"modified_method":"/**\n     * @see org.opencms.ui.actions.I_CmsWorkplaceAction#executeAction(org.opencms.ui.I_CmsDialogContext)\n     */\n    public void executeAction(I_CmsDialogContext context) {\n\n        String backLink;\n        try {\n            backLink = URLEncoder.encode(UI.getCurrent().getPage().getLocation().toString(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            backLink = UI.getCurrent().getPage().getLocation().toString();\n        }\n        CmsAppWorkplaceUi.get().showApp(\n            OpenCms.getWorkplaceAppManager().getAppConfiguration(\"editor\"),\n            CmsEditor.getEditState(context.getResources().get(0).getStructureId(), true, backLink));\n    }","commit_id":"65ad711dea2fb41f630a15a2a7e2445074ac93d1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.actions.I_CmsWorkplaceAction#executeAction(org.opencms.ui.I_CmsDialogContext)\n     */\n    public void executeAction(I_CmsDialogContext context) {\n\n        String state = CmsEditor.RESOURCE_ID_PREFIX\n            + context.getResources().get(0).getStructureId().toString()\n            + CmsEditor.STATE_SEPARATOR\n            + CmsEditor.BACK_LINK_PREFIX;\n        try {\n\n            state += URLEncoder.encode(UI.getCurrent().getPage().getLocation().toString(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            state += UI.getCurrent().getPage().getLocation().toString();\n        }\n        CmsAppWorkplaceUi.get().showApp(OpenCms.getWorkplaceAppManager().getAppConfiguration(\"editor\"), state);\n    }","id":38418,"modified_method":"/**\n     * @see org.opencms.ui.actions.I_CmsWorkplaceAction#executeAction(org.opencms.ui.I_CmsDialogContext)\n     */\n    public void executeAction(I_CmsDialogContext context) {\n\n        String backLink;\n        try {\n            backLink = URLEncoder.encode(UI.getCurrent().getPage().getLocation().toString(), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            LOG.error(e.getLocalizedMessage(), e);\n            backLink = UI.getCurrent().getPage().getLocation().toString();\n        }\n        CmsAppWorkplaceUi.get().showApp(\n            OpenCms.getWorkplaceAppManager().getAppConfiguration(\"editor\"),\n            CmsEditor.getEditState(context.getResources().get(0).getStructureId(), false, backLink));\n    }","commit_id":"65ad711dea2fb41f630a15a2a7e2445074ac93d1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.apps.I_CmsWorkplaceApp#onStateChange(java.lang.String)\n     */\n    public void onStateChange(String state) {\n\n        CmsUUID resId = getResourceIdFromState(state);\n        CmsAppWorkplaceUi.get();\n        CmsObject cms = A_CmsUI.getCmsObject();\n        try {\n            CmsResource resource = cms.readResource(resId, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED);\n            I_CmsEditor editor = OpenCms.getWorkplaceAppManager().getEditorForResource(resource);\n            if (editor != null) {\n                m_editorInstance = editor.newInstance();\n                m_editorInstance.initUI(m_context, resource, getBackLinkFromState(state));\n            }\n\n        } catch (CmsException e) {\n            LOG.error(\"Error initializing the editor.\", e);\n        }\n    }","id":38419,"modified_method":"/**\n     * @see org.opencms.ui.apps.I_CmsWorkplaceApp#onStateChange(java.lang.String)\n     */\n    public void onStateChange(String state) {\n\n        CmsUUID resId = getResourceIdFromState(state);\n        CmsAppWorkplaceUi.get();\n        CmsObject cms = A_CmsUI.getCmsObject();\n        try {\n            CmsResource resource = cms.readResource(resId, CmsResourceFilter.ONLY_VISIBLE_NO_DELETED);\n            I_CmsEditor editor = OpenCms.getWorkplaceAppManager().getEditorForResource(resource, isPlainText(state));\n            if (editor != null) {\n                m_editorInstance = editor.newInstance();\n                m_editorInstance.initUI(m_context, resource, getBackLinkFromState(state));\n            }\n\n        } catch (CmsException e) {\n            LOG.error(\"Error initializing the editor.\", e);\n        }\n    }","commit_id":"65ad711dea2fb41f630a15a2a7e2445074ac93d1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.editors.I_CmsEditor#matchesResource(org.opencms.file.CmsResource)\n     */\n    public boolean matchesResource(CmsResource resource) {\n\n        I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n\n        return !((type instanceof CmsResourceTypeBinary) || (type instanceof CmsResourceTypeImage));\n    }","id":38420,"modified_method":"/**\n     * @see org.opencms.ui.editors.I_CmsEditor#matchesResource(org.opencms.file.CmsResource, boolean)\n     */\n    public boolean matchesResource(CmsResource resource, boolean plainText) {\n\n        I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n\n        return !((type instanceof CmsResourceTypeBinary) || (type instanceof CmsResourceTypeImage));\n    }","commit_id":"65ad711dea2fb41f630a15a2a7e2445074ac93d1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the editor for the given resource.<p>\n     *\n     * @param resource the resource to edit\n     *\n     * @return the editor\n     */\n    public I_CmsEditor getEditorForResource(CmsResource resource) {\n\n        List<I_CmsEditor> editors = new ArrayList<I_CmsEditor>();\n        for (int i = 0; i < EDITORS.length; i++) {\n            if (EDITORS[i].matchesResource(resource)) {\n                editors.add(EDITORS[i]);\n            }\n        }\n        I_CmsEditor result = null;\n        if (editors.size() == 1) {\n            result = editors.get(0);\n        } else if (editors.size() > 1) {\n            Collections.sort(editors, new Comparator<I_CmsEditor>() {\n\n                public int compare(I_CmsEditor o1, I_CmsEditor o2) {\n\n                    return o1.getPriority() > o1.getPriority() ? -1 : 1;\n                }\n            });\n            result = editors.get(0);\n        }\n        return result;\n    }","id":38421,"modified_method":"/**\n     * Returns the editor for the given resource.<p>\n     *\n     * @param resource the resource to edit\n     * @param plainText if plain text editing is required\n     *\n     * @return the editor\n     */\n    public I_CmsEditor getEditorForResource(CmsResource resource, boolean plainText) {\n\n        List<I_CmsEditor> editors = new ArrayList<I_CmsEditor>();\n        for (int i = 0; i < EDITORS.length; i++) {\n            if (EDITORS[i].matchesResource(resource, plainText)) {\n                editors.add(EDITORS[i]);\n            }\n        }\n        I_CmsEditor result = null;\n        if (editors.size() == 1) {\n            result = editors.get(0);\n        } else if (editors.size() > 1) {\n            Collections.sort(editors, new Comparator<I_CmsEditor>() {\n\n                public int compare(I_CmsEditor o1, I_CmsEditor o2) {\n\n                    return o1.getPriority() > o2.getPriority() ? -1 : 1;\n                }\n            });\n            result = editors.get(0);\n        }\n        return result;\n    }","commit_id":"65ad711dea2fb41f630a15a2a7e2445074ac93d1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            node.writeTo(out);\n            out.writeBoolean(withClusterState);\n        }","id":38422,"modified_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            node.writeTo(out);\n            if (out.getVersion().before(Version.V_1_4_0)) {\n                // old with cluster state flag\n                out.writeBoolean(false);\n            }\n        }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public MembershipAction(Settings settings, TransportService transportService, DiscoveryNodesProvider nodesProvider, MembershipListener listener) {\n        super(settings);\n        this.transportService = transportService;\n        this.nodesProvider = nodesProvider;\n        this.listener = listener;\n\n        transportService.registerHandler(JoinRequestRequestHandler.ACTION, new JoinRequestRequestHandler());\n        transportService.registerHandler(ValidateJoinRequestRequestHandler.ACTION, new ValidateJoinRequestRequestHandler());\n        transportService.registerHandler(LeaveRequestRequestHandler.ACTION, new LeaveRequestRequestHandler());\n    }","id":38423,"modified_method":"public MembershipAction(Settings settings, ClusterService clusterService, TransportService transportService, DiscoveryNodesProvider nodesProvider, MembershipListener listener) {\n        super(settings);\n        this.transportService = transportService;\n        this.nodesProvider = nodesProvider;\n        this.listener = listener;\n        this.clusterService = clusterService;\n\n        transportService.registerHandler(JoinRequestRequestHandler.ACTION, new JoinRequestRequestHandler());\n        transportService.registerHandler(ValidateJoinRequestRequestHandler.ACTION, new ValidateJoinRequestRequestHandler());\n        transportService.registerHandler(LeaveRequestRequestHandler.ACTION, new LeaveRequestRequestHandler());\n    }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private JoinRequest(DiscoveryNode node, boolean withClusterState) {\n            this.node = node;\n            this.withClusterState = withClusterState;\n        }","id":38424,"modified_method":"private JoinRequest(DiscoveryNode node) {\n            this.node = node;\n        }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void sendJoinRequest(DiscoveryNode masterNode, DiscoveryNode node) {\n        transportService.sendRequest(masterNode, JoinRequestRequestHandler.ACTION, new JoinRequest(node, false), EmptyTransportResponseHandler.INSTANCE_SAME);\n    }","id":38425,"modified_method":"public void sendJoinRequest(DiscoveryNode masterNode, DiscoveryNode node) {\n        transportService.sendRequest(masterNode, JoinRequestRequestHandler.ACTION, new JoinRequest(node), EmptyTransportResponseHandler.INSTANCE_SAME);\n    }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void messageReceived(final JoinRequest request, final TransportChannel channel) throws Exception {\n            listener.onJoin(request.node, new JoinCallback() {\n                @Override\n                public void onSuccess(ClusterState state) {\n                    try {\n                        if (request.withClusterState) {\n                            channel.sendResponse(new JoinResponse(state));\n                        } else {\n                            channel.sendResponse(TransportResponse.Empty.INSTANCE);\n                        }\n                    } catch (Throwable t) {\n                        onFailure(t);\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable t) {\n                    try {\n                        channel.sendResponse(t);\n                    } catch (Throwable e) {\n                        logger.warn(\"failed to send back failure on join request\", e);\n                    }\n                }\n            });\n        }","id":38426,"modified_method":"@Override\n        public void messageReceived(final JoinRequest request, final TransportChannel channel) throws Exception {\n            listener.onJoin(request.node, new JoinCallback() {\n                @Override\n                public void onSuccess() {\n                    try {\n                        // nodes from a version older than 1.4.0 may ask for this\n                        if (request.withClusterState) {\n                            channel.sendResponse(new JoinResponse(clusterService.state()));\n                        } else {\n                            channel.sendResponse(TransportResponse.Empty.INSTANCE);\n                        }\n                    } catch (Throwable t) {\n                        onFailure(t);\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable t) {\n                    try {\n                        channel.sendResponse(t);\n                    } catch (Throwable e) {\n                        logger.warn(\"failed to send back failure on join request\", e);\n                    }\n                }\n            });\n        }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Validates the join request, throwing a failure if it failed.\n     */\n    public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState clusterState, TimeValue timeout) throws ElasticsearchException {\n        transportService.submitRequest(node, ValidateJoinRequestRequestHandler.ACTION, new ValidateJoinRequest(clusterState), EmptyTransportResponseHandler.INSTANCE_SAME)\n                .txGet(timeout.millis(), TimeUnit.MILLISECONDS);\n    }","id":38427,"modified_method":"/**\n     * Validates the join request, throwing a failure if it failed.\n     */\n    public void sendValidateJoinRequestBlocking(DiscoveryNode node, TimeValue timeout) throws ElasticsearchException {\n        transportService.submitRequest(node, ValidateJoinRequestRequestHandler.ACTION, new ValidateJoinRequest(), EmptyTransportResponseHandler.INSTANCE_SAME)\n                .txGet(timeout.millis(), TimeUnit.MILLISECONDS);\n    }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            node = DiscoveryNode.readNode(in);\n            withClusterState = in.readBoolean();\n        }","id":38428,"modified_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            node = DiscoveryNode.readNode(in);\n            if (in.getVersion().before(Version.V_1_4_0)) {\n                withClusterState = in.readBoolean();\n            }\n        }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            clusterState = ClusterState.Builder.readFrom(in, nodesProvider.nodes().localNode());\n        }","id":38429,"modified_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            if (in.getVersion().before(Version.V_1_4_0)) {\n                ClusterState.Builder.readFrom(in, nodesProvider.nodes().localNode());\n            }\n        }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            ClusterState.Builder.writeTo(clusterState, out);\n        }","id":38430,"modified_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            if (out.getVersion().before(Version.V_1_4_0)) {\n                ClusterState.Builder.writeTo(clusterService.state(), out);\n            }\n        }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ClusterState sendJoinRequestBlocking(DiscoveryNode masterNode, DiscoveryNode node, TimeValue timeout) throws ElasticsearchException {\n        return transportService.submitRequest(masterNode, JoinRequestRequestHandler.ACTION, new JoinRequest(node, true), new FutureTransportResponseHandler<JoinResponse>() {\n            @Override\n            public JoinResponse newInstance() {\n                return new JoinResponse();\n            }\n        }).txGet(timeout.millis(), TimeUnit.MILLISECONDS).clusterState;\n    }","id":38431,"modified_method":"public void sendJoinRequestBlocking(DiscoveryNode masterNode, DiscoveryNode node, TimeValue timeout) throws ElasticsearchException {\n        transportService.submitRequest(masterNode, JoinRequestRequestHandler.ACTION, new JoinRequest(node), new FutureTransportResponseHandler<JoinResponse>() {\n            @Override\n            public JoinResponse newInstance() {\n                return new JoinResponse();\n            }\n        }).txGet(timeout.millis(), TimeUnit.MILLISECONDS);\n    }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public ZenDiscovery(Settings settings, ClusterName clusterName, ThreadPool threadPool,\n                        TransportService transportService, ClusterService clusterService, NodeSettingsService nodeSettingsService,\n                        DiscoveryNodeService discoveryNodeService, ZenPingService pingService, Version version, DiscoverySettings discoverySettings) {\n        super(settings);\n        this.clusterName = clusterName;\n        this.threadPool = threadPool;\n        this.clusterService = clusterService;\n        this.transportService = transportService;\n        this.discoveryNodeService = discoveryNodeService;\n        this.pingService = pingService;\n        this.version = version;\n\n        // also support direct discovery.zen settings, for cases when it gets extended\n        this.pingTimeout = settings.getAsTime(\"discovery.zen.ping.timeout\", settings.getAsTime(\"discovery.zen.ping_timeout\", componentSettings.getAsTime(\"ping_timeout\", componentSettings.getAsTime(\"initial_ping_timeout\", timeValueSeconds(3)))));\n        this.joinTimeout = settings.getAsTime(\"discovery.zen.join_timeout\", TimeValue.timeValueMillis(pingTimeout.millis() * 20));\n        this.sendLeaveRequest = componentSettings.getAsBoolean(\"send_leave_request\", true);\n\n        this.masterElectionFilterClientNodes = settings.getAsBoolean(\"discovery.zen.master_election.filter_client\", true);\n        this.masterElectionFilterDataNodes = settings.getAsBoolean(\"discovery.zen.master_election.filter_data\", false);\n\n        logger.debug(\"using ping.timeout [{}], join.timeout [{}], master_election.filter_client [{}], master_election.filter_data [{}]\", pingTimeout, joinTimeout, masterElectionFilterClientNodes, masterElectionFilterDataNodes);\n\n        this.electMaster = new ElectMasterService(settings);\n        nodeSettingsService.addListener(new ApplySettings());\n\n        this.masterFD = new MasterFaultDetection(settings, threadPool, transportService, this);\n        this.masterFD.addListener(new MasterNodeFailureListener());\n\n        this.nodesFD = new NodesFaultDetection(settings, threadPool, transportService);\n        this.nodesFD.addListener(new NodeFailureListener());\n\n        this.publishClusterState = new PublishClusterStateAction(settings, transportService, this, new NewClusterStateListener(), discoverySettings);\n        this.pingService.setNodesProvider(this);\n        this.membership = new MembershipAction(settings, transportService, this, new MembershipListener());\n\n        transportService.registerHandler(RejoinClusterRequestHandler.ACTION, new RejoinClusterRequestHandler());\n    }","id":38432,"modified_method":"@Inject\n    public ZenDiscovery(Settings settings, ClusterName clusterName, ThreadPool threadPool,\n                        TransportService transportService, ClusterService clusterService, NodeSettingsService nodeSettingsService,\n                        DiscoveryNodeService discoveryNodeService, ZenPingService pingService, Version version, DiscoverySettings discoverySettings) {\n        super(settings);\n        this.clusterName = clusterName;\n        this.threadPool = threadPool;\n        this.clusterService = clusterService;\n        this.transportService = transportService;\n        this.discoveryNodeService = discoveryNodeService;\n        this.pingService = pingService;\n        this.version = version;\n\n        // also support direct discovery.zen settings, for cases when it gets extended\n        this.pingTimeout = settings.getAsTime(\"discovery.zen.ping.timeout\", settings.getAsTime(\"discovery.zen.ping_timeout\", componentSettings.getAsTime(\"ping_timeout\", componentSettings.getAsTime(\"initial_ping_timeout\", timeValueSeconds(3)))));\n        this.joinTimeout = settings.getAsTime(\"discovery.zen.join_timeout\", TimeValue.timeValueMillis(pingTimeout.millis() * 20));\n        this.sendLeaveRequest = componentSettings.getAsBoolean(\"send_leave_request\", true);\n\n        this.masterElectionFilterClientNodes = settings.getAsBoolean(\"discovery.zen.master_election.filter_client\", true);\n        this.masterElectionFilterDataNodes = settings.getAsBoolean(\"discovery.zen.master_election.filter_data\", false);\n\n        logger.debug(\"using ping.timeout [{}], join.timeout [{}], master_election.filter_client [{}], master_election.filter_data [{}]\", pingTimeout, joinTimeout, masterElectionFilterClientNodes, masterElectionFilterDataNodes);\n\n        this.electMaster = new ElectMasterService(settings);\n        nodeSettingsService.addListener(new ApplySettings());\n\n        this.masterFD = new MasterFaultDetection(settings, threadPool, transportService, this);\n        this.masterFD.addListener(new MasterNodeFailureListener());\n\n        this.nodesFD = new NodesFaultDetection(settings, threadPool, transportService);\n        this.nodesFD.addListener(new NodeFailureListener());\n\n        this.publishClusterState = new PublishClusterStateAction(settings, transportService, this, new NewClusterStateListener(), discoverySettings);\n        this.pingService.setNodesProvider(this);\n        this.membership = new MembershipAction(settings, clusterService, transportService, this, new MembershipListener());\n\n        transportService.registerHandler(RejoinClusterRequestHandler.ACTION, new RejoinClusterRequestHandler());\n    }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void handleJoinRequest(final DiscoveryNode node, final MembershipAction.JoinCallback callback) {\n        if (!master) {\n            throw new ElasticsearchIllegalStateException(\"Node [\" + localNode + \"] not master for join request from [\" + node + \"]\");\n        }\n\n        if (!transportService.addressSupported(node.address().getClass())) {\n            // TODO, what should we do now? Maybe inform that node that its crap?\n            logger.warn(\"received a wrong address type from [{}], ignoring...\", node);\n        } else {\n            // try and connect to the node, if it fails, we can raise an exception back to the client...\n            transportService.connectToNode(node);\n            ClusterState state = clusterService.state();\n\n            // validate the join request, will throw a failure if it fails, which will get back to the\n            // node calling the join request\n            membership.sendValidateJoinRequestBlocking(node, state, joinTimeout);\n\n            clusterService.submitStateUpdateTask(\"zen-disco-receive(join from node[\" + node + \"])\", Priority.IMMEDIATE, new ProcessedClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    if (currentState.nodes().nodeExists(node.id())) {\n                        // the node already exists in the cluster\n                        logger.info(\"received a join request for an existing node [{}]\", node);\n                        // still send a new cluster state, so it will be re published and possibly update the other node\n                        return ClusterState.builder(currentState).build();\n                    }\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder(currentState.nodes());\n                    for (DiscoveryNode existingNode : currentState.nodes()) {\n                        if (node.address().equals(existingNode.address())) {\n                            builder.remove(existingNode.id());\n                            logger.warn(\"received join request from node [{}], but found existing node {} with same address, removing existing node\", node, existingNode);\n                        }\n                    }\n                    latestDiscoNodes = builder.build();\n                    // add the new node now (will update latestDiscoNodes on publish)\n                    return ClusterState.builder(currentState).nodes(latestDiscoNodes.newNode(node)).build();\n                }\n\n                @Override\n                public void onFailure(String source, Throwable t) {\n                    logger.error(\"unexpected failure during [{}]\", t, source);\n                    callback.onFailure(t);\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    callback.onSuccess(newState);\n                }\n            });\n        }\n    }","id":38433,"modified_method":"private void handleJoinRequest(final DiscoveryNode node, final MembershipAction.JoinCallback callback) {\n        if (!master) {\n            throw new ElasticsearchIllegalStateException(\"Node [\" + localNode + \"] not master for join request from [\" + node + \"]\");\n        }\n\n        if (!transportService.addressSupported(node.address().getClass())) {\n            // TODO, what should we do now? Maybe inform that node that its crap?\n            logger.warn(\"received a wrong address type from [{}], ignoring...\", node);\n        } else {\n            // try and connect to the node, if it fails, we can raise an exception back to the client...\n            transportService.connectToNode(node);\n\n            // validate the join request, will throw a failure if it fails, which will get back to the\n            // node calling the join request\n            membership.sendValidateJoinRequestBlocking(node, joinTimeout);\n\n            clusterService.submitStateUpdateTask(\"zen-disco-receive(join from node[\" + node + \"])\", Priority.IMMEDIATE, new ProcessedClusterStateUpdateTask() {\n                @Override\n                public ClusterState execute(ClusterState currentState) {\n                    if (currentState.nodes().nodeExists(node.id())) {\n                        // the node already exists in the cluster\n                        logger.info(\"received a join request for an existing node [{}]\", node);\n                        // still send a new cluster state, so it will be re published and possibly update the other node\n                        return ClusterState.builder(currentState).build();\n                    }\n                    DiscoveryNodes.Builder builder = DiscoveryNodes.builder(currentState.nodes());\n                    for (DiscoveryNode existingNode : currentState.nodes()) {\n                        if (node.address().equals(existingNode.address())) {\n                            builder.remove(existingNode.id());\n                            logger.warn(\"received join request from node [{}], but found existing node {} with same address, removing existing node\", node, existingNode);\n                        }\n                    }\n                    latestDiscoNodes = builder.build();\n                    // add the new node now (will update latestDiscoNodes on publish)\n                    return ClusterState.builder(currentState).nodes(latestDiscoNodes.newNode(node)).build();\n                }\n\n                @Override\n                public void onFailure(String source, Throwable t) {\n                    logger.error(\"unexpected failure during [{}]\", t, source);\n                    callback.onFailure(t);\n                }\n\n                @Override\n                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                    callback.onSuccess();\n                }\n            });\n        }\n    }","commit_id":"690820dae3b82e2140ea720af3dfca5aacc02d89","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public RejarClassesForAnalysis(RejarClassesForAnalysisCommandLine commandLine, int argCount, String[] args) {\n        this.commandLine = commandLine;\n        this.argCount = argCount;\n        this.args = args;\n    }","id":38434,"modified_method":"public static void readFromStandardInput(Collection<String> result) throws IOException {\n         readFrom(result, UserTextFile.bufferedReader(System.in));\n    }","commit_id":"7d5bc03c97c00daa44f223584d412a5617902151","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void execute() throws IOException {\n\n        List<String> fileList;\n\n        if (commandLine.inputFileList != null)\n            fileList = readFrom(new FileReader(commandLine.inputFileList));\n        else if (argCount == args.length)\n            fileList = readFromStandardInput();\n        else\n            fileList = Arrays.asList(args).subList(argCount, args.length);\n        List<String> auxFileList = Collections.emptyList();\n        if (commandLine.auxFileList != null)\n            auxFileList = readFrom(new FileReader(commandLine.auxFileList));\n\n        List<File> inputZipFiles = new ArrayList<File>(fileList.size());\n        List<File> auxZipFiles = new ArrayList<File>(auxFileList.size());\n        for (String fInName : fileList) {\n            File f = new File(fInName);\n            if (f.lastModified() < commandLine.maxAge) {\n                System.err.println(\"Skipping \" + fInName + \", too old (\" + new Date(f.lastModified()) + \")\");\n                continue;\n            }\n\n            int oldSize = copied.size();\n            classFileFound = false;\n            if (processZipEntries(f, new ZipElementHandler() {\n                boolean checked = false;\n\n                public void handle(ZipFile file, ZipEntry ze) throws IOException {\n                    if (commandLine.skip(ze))\n                        return;\n                    String name = ze.getName();\n\n                    String dottedName = name.replace('/', '.');\n                    if (exclude(dottedName))\n                        return;\n\n                    if (!checked) {\n                         checked = true;\n                        if (embeddedNameMismatch(file, ze)) {\n                            System.out.println(\"Class name mismatch for \" + name + \" in \" + file.getName());\n                            throw new ClassFileNameMismatch();\n                        }\n                    }\n                    if (!commandLine.prefix.matches(dottedName))\n                        return;\n                    classFileFound = true;\n                    if (copied.add(name)) {\n                        filesToAnalyze.add(name);\n                        numFilesToAnalyze++;\n                    }\n                }\n\n                /**\n                 * @param dottedName\n                 * @return\n                 */\n\n            }) && oldSize < copied.size())\n                inputZipFiles.add(f);\n            else if (classFileFound)\n                System.err.println(\"Skipping \" + fInName  + \", no new classes found\");\n            else \n                System.err.println(\"Skipping \" + fInName  + \", no classes found\");\n        }\n        for (String fInName : auxFileList) {\n            File f = new File(fInName);\n            if (f.lastModified() < commandLine.maxAge) {\n                System.err.println(\"Skipping \" + fInName + \", too old (\" + new Date(f.lastModified()) + \")\");\n                continue;\n            }\n            int oldSize = copied.size();\n            classFileFound = false;\n            if (processZipEntries(f, new ZipElementHandler() {\n                public void handle(ZipFile file, ZipEntry ze) {\n                    if (commandLine.skip(ze))\n                        return;\n\n                    String name = ze.getName();\n                    String dottedName = name.replace('/', '.');\n                    if (!exclude(dottedName)) {\n                        classFileFound = true;\n                        copied.add(ze.getName());\n                    }\n                }\n            }) && oldSize < copied.size())\n                auxZipFiles.add(f);\n            else if (classFileFound)\n                System.err.println(\"Skipping aux file \" + fInName  + \", no new classes found\");\n            else \n                System.err.println(\"Skipping aux file\" + fInName  + \", no classes found\");\n        }\n\n        System.out.printf(\"    # Zip/jar files: %2d%n\", inputZipFiles.size());\n        System.out.printf(\"# aux Zip/jar files: %2d%n\", auxZipFiles.size());\n        System.out.printf(\"Unique class files: %6d%n\", copied.size());\n        if (numFilesToAnalyze != copied.size())\n            System.out.printf(\"  files to analyze: %6d%n\", numFilesToAnalyze);\n\n        if (!excluded.isEmpty())\n            System.out.printf(\"   excluded  files: %6d%n\", excluded.size());\n\n        if (commandLine.onlyAnalyze)\n            return;\n\n        if (numFilesToAnalyze < copied.size() || numFilesToAnalyze > commandLine.maxClasses)\n            auxilaryOut = createZipFile(getNextAuxilaryFileOutput());\n\n        copied.clear();\n\n        int count = Integer.MAX_VALUE;\n        String oldBaseClass = \"x x\";\n        String oldPackage = \"x x\";\n        for (String path : filesToAnalyze) {\n            int lastSlash = path.lastIndexOf('/');\n            String packageName = lastSlash <= 0 ? \"\" : path.substring(0, lastSlash - 1);\n            int firstDollar = path.indexOf('$', lastSlash);\n            String baseClass = firstDollar < 0 ? path : path.substring(0, firstDollar - 1);\n            boolean switchOutput;\n            if (count > commandLine.maxClasses)\n                switchOutput = true;\n            else if (count + 50 > commandLine.maxClasses && !baseClass.equals(oldBaseClass))\n                switchOutput = true;\n            else if (count + 250 > commandLine.maxClasses && !packageName.equals(oldPackage))\n                switchOutput = true;\n            else\n                switchOutput = false;\n\n            if (switchOutput) {\n                // advance\n                String zipFileName = getNextAnalyzeFileOutput();\n                analysisOutputFiles.put(path, createZipFile(zipFileName));\n                System.out.printf(\"%s%n -> %s%n\", path, zipFileName);\n                count = 0;\n            }\n            count++;\n            oldPackage = packageName;\n            oldBaseClass = baseClass;\n        }\n\n        for (File f : inputZipFiles) {\n            System.err.println(\"Reading \" + f);\n            processZipEntries(f, new ZipElementHandler() {\n\n                public void handle(ZipFile zipInputFile, ZipEntry ze) throws IOException {\n                    if (commandLine.skip(ze))\n                        return;\n\n                    String name = ze.getName();\n                    String dottedName = name.replace('/', '.');\n                    if (exclude(dottedName))\n                        return;\n                    if (!copied.add(name)) {\n                        return;\n\n                    }\n                    boolean writeToAnalyzeOut = false;\n                    boolean writeToAuxilaryOut = false;\n                    if (commandLine.prefix.matches(dottedName)) {\n                        writeToAnalyzeOut = true;\n                        if (numFilesToAnalyze > commandLine.maxClasses)\n                            writeToAuxilaryOut = true;\n                    } else\n                        writeToAuxilaryOut = auxilaryOut != null;\n                    ZipOutputStream out = null;\n                    if (writeToAnalyzeOut) {\n                        out = getZipOutputFile(name);\n                        out.putNextEntry(new ZipEntry(ze));\n                    }\n\n                    if (writeToAuxilaryOut) {\n                        auxilaryClassCount++;\n                        if (auxilaryClassCount > 29999) {\n                            auxilaryClassCount = 0;\n                            advanceAuxilaryOut();\n                        }\n                        auxilaryOut.putNextEntry(new ZipEntry(ze));\n                    }\n\n                    copyEntry(zipInputFile, ze, writeToAnalyzeOut, out, writeToAuxilaryOut, auxilaryOut);\n                }\n\n            });\n        }\n\n        for (File f : auxZipFiles) {\n            System.err.println(\"Opening aux file \" + f);\n            processZipEntries(f, new ZipElementHandler() {\n\n                public void handle(ZipFile zipInputFile, ZipEntry ze) throws IOException {\n                    if (commandLine.skip(ze))\n                        return;\n\n                    String name = ze.getName();\n                    String dottedName = name.replace('/', '.');\n\n                    if (exclude(dottedName))\n                        return;\n                    if (!copied.add(name)) {\n                        return;\n                    }\n\n                    auxilaryClassCount++;\n                    if (auxilaryClassCount > 29999) {\n                        auxilaryClassCount = 0;\n                        advanceAuxilaryOut();\n                    }\n                    auxilaryOut.putNextEntry(new ZipEntry(ze));\n\n                    copyEntry(zipInputFile, ze, false, null, true, auxilaryOut);\n                }\n\n            });\n        }\n\n        if (auxilaryOut != null)\n            auxilaryOut.close();\n        for (ZipOutputStream out : analysisOutputFiles.values())\n            out.close();\n\n        System.out.println(\"All done\");\n    }","id":38435,"modified_method":"public void execute() throws IOException {\n\n        TreeSet<String> fileList = new TreeSet<String>();\n\n        if (commandLine.inputFileList != null)\n            readFrom(fileList, new FileReader(commandLine.inputFileList));\n        else if (argCount == args.length)\n             readFromStandardInput(fileList);\n        else\n            fileList.addAll(Arrays.asList(args).subList(argCount, args.length));\n        TreeSet<String> auxFileList = new TreeSet<String>();\n        if (commandLine.auxFileList != null) {\n            readFrom(auxFileList, new FileReader(commandLine.auxFileList));\n            auxFileList.removeAll(fileList);\n        }\n\n        List<File> inputZipFiles = new ArrayList<File>(fileList.size());\n        List<File> auxZipFiles = new ArrayList<File>(auxFileList.size());\n        for (String fInName : fileList) {\n            File f = new File(fInName);\n            if (f.lastModified() < commandLine.maxAge) {\n                System.err.println(\"Skipping \" + fInName + \", too old (\" + new Date(f.lastModified()) + \")\");\n                continue;\n            }\n\n            int oldSize = copied.size();\n            classFileFound = false;\n            if (processZipEntries(f, new ZipElementHandler() {\n                boolean checked = false;\n\n                public void handle(ZipFile file, ZipEntry ze) throws IOException {\n                    if (commandLine.skip(ze))\n                        return;\n                    String name = ze.getName();\n\n                    String dottedName = name.replace('/', '.');\n                    if (exclude(dottedName))\n                        return;\n\n                    if (!checked) {\n                         checked = true;\n                        if (embeddedNameMismatch(file, ze)) {\n                            System.out.println(\"Class name mismatch for \" + name + \" in \" + file.getName());\n                            throw new ClassFileNameMismatch();\n                        }\n                    }\n                    if (!commandLine.prefix.matches(dottedName))\n                        return;\n                    classFileFound = true;\n                    if (copied.add(name)) {\n                        filesToAnalyze.add(name);\n                        numFilesToAnalyze++;\n                    }\n                }\n\n                /**\n                 * @param dottedName\n                 * @return\n                 */\n\n            }) && oldSize < copied.size())\n                inputZipFiles.add(f);\n            else if (classFileFound)\n                System.err.println(\"Skipping \" + fInName  + \", no new classes found\");\n            else \n                System.err.println(\"Skipping \" + fInName  + \", no classes found\");\n        }\n        for (String fInName : auxFileList) {\n            File f = new File(fInName);\n            if (f.lastModified() < commandLine.maxAge) {\n                System.err.println(\"Skipping \" + fInName + \", too old (\" + new Date(f.lastModified()) + \")\");\n                continue;\n            }\n            int oldSize = copied.size();\n            classFileFound = false;\n            if (processZipEntries(f, new ZipElementHandler() {\n                public void handle(ZipFile file, ZipEntry ze) {\n                    if (commandLine.skip(ze))\n                        return;\n\n                    String name = ze.getName();\n                    String dottedName = name.replace('/', '.');\n                    if (!exclude(dottedName)) {\n                        classFileFound = true;\n                        copied.add(ze.getName());\n                    }\n                }\n            }) && oldSize < copied.size())\n                auxZipFiles.add(f);\n            else if (classFileFound)\n                System.err.println(\"Skipping aux file \" + fInName  + \", no new classes found\");\n            else \n                System.err.println(\"Skipping aux file\" + fInName  + \", no classes found\");\n        }\n\n        System.out.printf(\"    # Zip/jar files: %2d%n\", inputZipFiles.size());\n        System.out.printf(\"# aux Zip/jar files: %2d%n\", auxZipFiles.size());\n        System.out.printf(\"Unique class files: %6d%n\", copied.size());\n        if (numFilesToAnalyze != copied.size())\n            System.out.printf(\"  files to analyze: %6d%n\", numFilesToAnalyze);\n\n        if (!excluded.isEmpty())\n            System.out.printf(\"   excluded  files: %6d%n\", excluded.size());\n\n        if (commandLine.onlyAnalyze)\n            return;\n\n        if (numFilesToAnalyze < copied.size() || numFilesToAnalyze > commandLine.maxClasses)\n            auxilaryOut = createZipFile(getNextAuxilaryFileOutput());\n\n        copied.clear();\n\n        int count = Integer.MAX_VALUE;\n        String oldBaseClass = \"x x\";\n        String oldPackage = \"x x\";\n        for (String path : filesToAnalyze) {\n            int lastSlash = path.lastIndexOf('/');\n            String packageName = lastSlash <= 0 ? \"\" : path.substring(0, lastSlash - 1);\n            int firstDollar = path.indexOf('$', lastSlash);\n            String baseClass = firstDollar < 0 ? path : path.substring(0, firstDollar - 1);\n            boolean switchOutput;\n            if (count > commandLine.maxClasses)\n                switchOutput = true;\n            else if (count + 50 > commandLine.maxClasses && !baseClass.equals(oldBaseClass))\n                switchOutput = true;\n            else if (count + 250 > commandLine.maxClasses && !packageName.equals(oldPackage))\n                switchOutput = true;\n            else\n                switchOutput = false;\n\n            if (switchOutput) {\n                // advance\n                String zipFileName = getNextAnalyzeFileOutput();\n                analysisOutputFiles.put(path, createZipFile(zipFileName));\n                System.out.printf(\"%s%n -> %s%n\", path, zipFileName);\n                count = 0;\n            }\n            count++;\n            oldPackage = packageName;\n            oldBaseClass = baseClass;\n        }\n\n        for (File f : inputZipFiles) {\n            System.err.println(\"Reading \" + f);\n            processZipEntries(f, new ZipElementHandler() {\n\n                public void handle(ZipFile zipInputFile, ZipEntry ze) throws IOException {\n                    if (commandLine.skip(ze))\n                        return;\n\n                    String name = ze.getName();\n                    String dottedName = name.replace('/', '.');\n                    if (exclude(dottedName))\n                        return;\n                    if (!copied.add(name)) {\n                        return;\n\n                    }\n                    boolean writeToAnalyzeOut = false;\n                    boolean writeToAuxilaryOut = false;\n                    if (commandLine.prefix.matches(dottedName)) {\n                        writeToAnalyzeOut = true;\n                        if (numFilesToAnalyze > commandLine.maxClasses)\n                            writeToAuxilaryOut = true;\n                    } else\n                        writeToAuxilaryOut = auxilaryOut != null;\n                    ZipOutputStream out = null;\n                    if (writeToAnalyzeOut) {\n                        out = getZipOutputFile(name);\n                        out.putNextEntry(new ZipEntry(ze));\n                    }\n\n                    if (writeToAuxilaryOut) {\n                        auxilaryClassCount++;\n                        if (auxilaryClassCount > 29999) {\n                            auxilaryClassCount = 0;\n                            advanceAuxilaryOut();\n                        }\n                        auxilaryOut.putNextEntry(new ZipEntry(ze));\n                    }\n\n                    copyEntry(zipInputFile, ze, writeToAnalyzeOut, out, writeToAuxilaryOut, auxilaryOut);\n                }\n\n            });\n        }\n\n        for (File f : auxZipFiles) {\n            System.err.println(\"Opening aux file \" + f);\n            processZipEntries(f, new ZipElementHandler() {\n\n                public void handle(ZipFile zipInputFile, ZipEntry ze) throws IOException {\n                    if (commandLine.skip(ze))\n                        return;\n\n                    String name = ze.getName();\n                    String dottedName = name.replace('/', '.');\n\n                    if (exclude(dottedName))\n                        return;\n                    if (!copied.add(name)) {\n                        return;\n                    }\n\n                    auxilaryClassCount++;\n                    if (auxilaryClassCount > 29999) {\n                        auxilaryClassCount = 0;\n                        advanceAuxilaryOut();\n                    }\n                    auxilaryOut.putNextEntry(new ZipEntry(ze));\n\n                    copyEntry(zipInputFile, ze, false, null, true, auxilaryOut);\n                }\n\n            });\n        }\n\n        if (auxilaryOut != null)\n            auxilaryOut.close();\n        for (ZipOutputStream out : analysisOutputFiles.values())\n            out.close();\n\n        System.out.println(\"All done\");\n    }","commit_id":"7d5bc03c97c00daa44f223584d412a5617902151","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void execute(RestTestExecutionContext executionContext) throws IOException {\n\n        if (\"param\".equals(catchParam)) {\n            //client should throw validation error before sending request\n            //lets just return without doing anything as we don't have any client to test here\n            logger.info(\"found [catch: param], no request sent\");\n            return;\n        }\n\n        try {\n            RestResponse restResponse = executionContext.callApi(apiCallSection.getApi(), apiCallSection.getParams(), apiCallSection.getBodies());\n            if (Strings.hasLength(catchParam)) {\n                String catchStatusCode;\n                if (catches.containsKey(catchParam)) {\n                    catchStatusCode = catches.get(catchParam).v1();\n                } else if (catchParam.startsWith(\"/\") && catchParam.endsWith(\"/\")) {\n                    catchStatusCode = \"4xx|5xx\";\n                } else {\n                    throw new UnsupportedOperationException(\"catch value [\" + catchParam + \"] not supported\");\n                }\n                fail(formatStatusCodeMessage(restResponse, catchStatusCode));\n            }\n        } catch(RestException e) {\n            if (!Strings.hasLength(catchParam)) {\n                fail(formatStatusCodeMessage(e.restResponse(), \"2xx\"));\n            } else if (catches.containsKey(catchParam)) {\n                assertStatusCode(e.restResponse());\n            } else if (catchParam.length() > 2 && catchParam.startsWith(\"/\") && catchParam.endsWith(\"/\")) {\n                //the text of the error message matches regular expression\n                assertThat(formatStatusCodeMessage(e.restResponse(), \"4xx|5xx\"), e.statusCode(), greaterThanOrEqualTo(400));\n                Object error = executionContext.response(\"error\");\n                assertThat(\"error was expected in the response\", error, notNullValue());\n                //remove delimiters from regex\n                String regex = catchParam.substring(1, catchParam.length() - 1);\n                assertThat(\"the error message was expected to match the provided regex but didn't\",\n                        error.toString(), matches(regex));\n            } else {\n                throw new UnsupportedOperationException(\"catch value [\" + catchParam + \"] not supported\");\n            }\n        }\n    }","id":38436,"modified_method":"@Override\n    public void execute(RestTestExecutionContext executionContext) throws IOException {\n\n        if (\"param\".equals(catchParam)) {\n            //client should throw validation error before sending request\n            //lets just return without doing anything as we don't have any client to test here\n            logger.info(\"found [catch: param], no request sent\");\n            return;\n        }\n\n        try {\n            RestResponse restResponse = executionContext.callApi(apiCallSection.getApi(), apiCallSection.getParams(), apiCallSection.getBodies());\n            if (Strings.hasLength(catchParam)) {\n                String catchStatusCode;\n                if (catches.containsKey(catchParam)) {\n                    catchStatusCode = catches.get(catchParam).v1();\n                } else if (catchParam.startsWith(\"/\") && catchParam.endsWith(\"/\")) {\n                    catchStatusCode = \"4xx|5xx\";\n                } else {\n                    throw new UnsupportedOperationException(\"catch value [\" + catchParam + \"] not supported\");\n                }\n                fail(formatStatusCodeMessage(restResponse, catchStatusCode));\n            }\n        } catch(RestException e) {\n            if (!Strings.hasLength(catchParam)) {\n                System.out.println(apiCallSection.getBodies()); // NOCOMMIT remove this\n                fail(formatStatusCodeMessage(e.restResponse(), \"2xx\"));\n            } else if (catches.containsKey(catchParam)) {\n                assertStatusCode(e.restResponse());\n            } else if (catchParam.length() > 2 && catchParam.startsWith(\"/\") && catchParam.endsWith(\"/\")) {\n                //the text of the error message matches regular expression\n                assertThat(formatStatusCodeMessage(e.restResponse(), \"4xx|5xx\"), e.statusCode(), greaterThanOrEqualTo(400));\n                Object error = executionContext.response(\"error\");\n                assertThat(\"error was expected in the response\", error, notNullValue());\n                //remove delimiters from regex\n                String regex = catchParam.substring(1, catchParam.length() - 1);\n                assertThat(\"the error message was expected to match the provided regex but didn't\",\n                        error.toString(), matches(regex));\n            } else {\n                throw new UnsupportedOperationException(\"catch value [\" + catchParam + \"] not supported\");\n            }\n        }\n    }","commit_id":"2de450ca0b25723ec3974e98521631e92d649394","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeStringArray(indices);\n        out.writeVInt(warmers.size());\n        for (ObjectObjectCursor<String, List<IndexWarmersMetaData.Entry>> indexEntry : warmers) {\n            out.writeString(indexEntry.key);\n            out.writeVInt(indexEntry.value.size());\n            for (IndexWarmersMetaData.Entry warmerEntry : indexEntry.value) {\n                out.writeString(warmerEntry.name());\n                out.writeStringArray(warmerEntry.types());\n                out.writeOptionalBoolean(warmerEntry.requestCache());\n                warmerEntry.source().writeTo(out);\n            }\n        }\n        out.writeVInt(mappings.size());\n        for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexEntry : mappings) {\n            out.writeString(indexEntry.key);\n            out.writeVInt(indexEntry.value.size());\n            for (ObjectObjectCursor<String, MappingMetaData> mappingEntry : indexEntry.value) {\n                out.writeString(mappingEntry.key);\n                mappingEntry.value.writeTo(out);\n            }\n        }\n        out.writeVInt(aliases.size());\n        for (ObjectObjectCursor<String, List<AliasMetaData>> indexEntry : aliases) {\n            out.writeString(indexEntry.key);\n            out.writeVInt(indexEntry.value.size());\n            for (AliasMetaData aliasEntry : indexEntry.value) {\n                aliasEntry.writeTo(out);\n            }\n        }\n        out.writeVInt(settings.size());\n        for (ObjectObjectCursor<String, Settings> indexEntry : settings) {\n            out.writeString(indexEntry.key);\n            Settings.writeSettingsToStream(indexEntry.value, out);\n        }\n    }","id":38437,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeStringArray(indices);\n        out.writeVInt(warmers.size());\n        for (ObjectObjectCursor<String, List<IndexWarmersMetaData.Entry>> indexEntry : warmers) {\n            out.writeString(indexEntry.key);\n            out.writeVInt(indexEntry.value.size());\n            for (IndexWarmersMetaData.Entry warmerEntry : indexEntry.value) {\n                out.writeString(warmerEntry.name());\n                out.writeStringArray(warmerEntry.types());\n                out.writeOptionalBoolean(warmerEntry.requestCache());\n                boolean hasSource = warmerEntry.source() != null;\n                out.writeBoolean(hasSource);\n                if (hasSource) {\n                    warmerEntry.source().writeTo(out);\n                }\n            }\n        }\n        out.writeVInt(mappings.size());\n        for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexEntry : mappings) {\n            out.writeString(indexEntry.key);\n            out.writeVInt(indexEntry.value.size());\n            for (ObjectObjectCursor<String, MappingMetaData> mappingEntry : indexEntry.value) {\n                out.writeString(mappingEntry.key);\n                mappingEntry.value.writeTo(out);\n            }\n        }\n        out.writeVInt(aliases.size());\n        for (ObjectObjectCursor<String, List<AliasMetaData>> indexEntry : aliases) {\n            out.writeString(indexEntry.key);\n            out.writeVInt(indexEntry.value.size());\n            for (AliasMetaData aliasEntry : indexEntry.value) {\n                aliasEntry.writeTo(out);\n            }\n        }\n        out.writeVInt(settings.size());\n        for (ObjectObjectCursor<String, Settings> indexEntry : settings) {\n            out.writeString(indexEntry.key);\n            Settings.writeSettingsToStream(indexEntry.value, out);\n        }\n    }","commit_id":"2de450ca0b25723ec3974e98521631e92d649394","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        this.indices = in.readStringArray();\n        int warmersSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, List<IndexWarmersMetaData.Entry>> warmersMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < warmersSize; i++) {\n            String key = in.readString();\n            int valueSize = in.readVInt();\n            List<IndexWarmersMetaData.Entry> warmerEntryBuilder = new ArrayList<>();\n            for (int j = 0; j < valueSize; j++) {\n                warmerEntryBuilder.add(new IndexWarmersMetaData.Entry(\n                        in.readString(),\n                        in.readStringArray(),\n                        in.readOptionalBoolean(),\n                        SearchSourceBuilder.PROTOTYPE.readFrom(in))\n                );\n            }\n            warmersMapBuilder.put(key, Collections.unmodifiableList(warmerEntryBuilder));\n        }\n        warmers = warmersMapBuilder.build();\n        int mappingsSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> mappingsMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < mappingsSize; i++) {\n            String key = in.readString();\n            int valueSize = in.readVInt();\n            ImmutableOpenMap.Builder<String, MappingMetaData> mappingEntryBuilder = ImmutableOpenMap.builder();\n            for (int j = 0; j < valueSize; j++) {\n                mappingEntryBuilder.put(in.readString(), MappingMetaData.PROTO.readFrom(in));\n            }\n            mappingsMapBuilder.put(key, mappingEntryBuilder.build());\n        }\n        mappings = mappingsMapBuilder.build();\n        int aliasesSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, List<AliasMetaData>> aliasesMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < aliasesSize; i++) {\n            String key = in.readString();\n            int valueSize = in.readVInt();\n            List<AliasMetaData> aliasEntryBuilder = new ArrayList<>();\n            for (int j = 0; j < valueSize; j++) {\n                aliasEntryBuilder.add(AliasMetaData.Builder.readFrom(in));\n            }\n            aliasesMapBuilder.put(key, Collections.unmodifiableList(aliasEntryBuilder));\n        }\n        aliases = aliasesMapBuilder.build();\n        int settingsSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, Settings> settingsMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < settingsSize; i++) {\n            String key = in.readString();\n            settingsMapBuilder.put(key, Settings.readSettingsFromStream(in));\n        }\n        settings = settingsMapBuilder.build();\n    }","id":38438,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        this.indices = in.readStringArray();\n        int warmersSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, List<IndexWarmersMetaData.Entry>> warmersMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < warmersSize; i++) {\n            String key = in.readString();\n            int valueSize = in.readVInt();\n            List<IndexWarmersMetaData.Entry> warmerEntryBuilder = new ArrayList<>();\n            for (int j = 0; j < valueSize; j++) {\n                warmerEntryBuilder.add(new IndexWarmersMetaData.Entry(\n                        in.readString(),\n                        in.readStringArray(),\n                        in.readOptionalBoolean(),\n                        in.readBoolean() ? SearchSourceBuilder.PROTOTYPE.readFrom(in) : null)\n                );\n            }\n            warmersMapBuilder.put(key, Collections.unmodifiableList(warmerEntryBuilder));\n        }\n        warmers = warmersMapBuilder.build();\n        int mappingsSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> mappingsMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < mappingsSize; i++) {\n            String key = in.readString();\n            int valueSize = in.readVInt();\n            ImmutableOpenMap.Builder<String, MappingMetaData> mappingEntryBuilder = ImmutableOpenMap.builder();\n            for (int j = 0; j < valueSize; j++) {\n                mappingEntryBuilder.put(in.readString(), MappingMetaData.PROTO.readFrom(in));\n            }\n            mappingsMapBuilder.put(key, mappingEntryBuilder.build());\n        }\n        mappings = mappingsMapBuilder.build();\n        int aliasesSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, List<AliasMetaData>> aliasesMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < aliasesSize; i++) {\n            String key = in.readString();\n            int valueSize = in.readVInt();\n            List<AliasMetaData> aliasEntryBuilder = new ArrayList<>();\n            for (int j = 0; j < valueSize; j++) {\n                aliasEntryBuilder.add(AliasMetaData.Builder.readFrom(in));\n            }\n            aliasesMapBuilder.put(key, Collections.unmodifiableList(aliasEntryBuilder));\n        }\n        aliases = aliasesMapBuilder.build();\n        int settingsSize = in.readVInt();\n        ImmutableOpenMap.Builder<String, Settings> settingsMapBuilder = ImmutableOpenMap.builder();\n        for (int i = 0; i < settingsSize; i++) {\n            String key = in.readString();\n            settingsMapBuilder.put(key, Settings.readSettingsFromStream(in));\n        }\n        settings = settingsMapBuilder.build();\n    }","commit_id":"2de450ca0b25723ec3974e98521631e92d649394","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Wait for some output\n     * @param time Time to wait\n     * @param unit Units for time to wait\n     * @return The buffer of output\n     * @throws InterruptedException\n     */\n    public ByteBuffer waitForOutput(long time,TimeUnit unit) throws InterruptedException\n    {\n        ByteBuffer b;\n\n        try(Locker.Lock lock = _locker.lock())\n        {\n            if (BufferUtil.isEmpty(_out))\n                _hasOutput.await(time,unit);\n               \n            b=_out;\n            _out=BufferUtil.allocate(b.capacity());\n        }\n        getWriteFlusher().completeWrite();\n        return b;\n    }","id":38439,"modified_method":"/** Wait for some output\n     * @param time Time to wait\n     * @param unit Units for time to wait\n     * @return The buffer of output\n     * @throws InterruptedException\n     */\n    public ByteBuffer waitForOutput(long time,TimeUnit unit) throws InterruptedException\n    {\n        ByteBuffer b;\n\n        try(Locker.Lock lock = _locker.lock())\n        {\n            if (BufferUtil.isEmpty(_out) && !_closed && !_oshut)\n                _hasOutput.await(time,unit);\n               \n            b=_out;\n            _out=BufferUtil.allocate(b.capacity());\n        }\n        getWriteFlusher().completeWrite();\n        return b;\n    }","commit_id":"183e3acabb828af8ed370b8a5eeaacbd6a5bf91b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Wait for a response using a parser to detect the end of message\n         * @param head\n         * @param time\n         * @param unit\n         * @return Buffer containing full response or null for EOF;\n         * @throws Exception\n         */\n        public ByteBuffer waitForResponse(boolean head, long time,TimeUnit unit) throws Exception\n        {\n            HttpParser.ResponseHandler handler = new HttpParser.ResponseHandler()\n            {\n                @Override\n                public void parsedHeader(HttpField field)\n                {\n                }\n                \n                @Override\n                public boolean messageComplete()\n                {\n                    return true;\n                }\n                \n                @Override\n                public boolean headerComplete()\n                {\n                    return false;\n                }\n                \n                @Override\n                public int getHeaderCacheSize()\n                {\n                    return 0;\n                }\n                \n                @Override\n                public void earlyEOF()\n                {                \n                }\n                \n                @Override\n                public boolean content(ByteBuffer item)\n                {\n                    return false;\n                }\n                \n                @Override\n                public void badMessage(int status, String reason)\n                {\n                }\n                \n                @Override\n                public boolean startResponse(HttpVersion version, int status, String reason)\n                {\n                    return false;\n                }\n            };\n            \n            \n            HttpParser parser = new HttpParser(handler);\n            parser.setHeadResponse(head);\n            try(ByteArrayOutputStream2 bout = new ByteArrayOutputStream2();)\n            {\n                loop: while(true)\n                {\n                    // read a chunk of response\n                    ByteBuffer chunk = BufferUtil.hasContent(_responseData) \n                        ? _responseData : waitForOutput(time,unit);\n                    _responseData=null;\n\n                    // Parse the content of this chunk\n                    while (BufferUtil.hasContent(chunk))\n                    {\n                        int pos=chunk.position();\n                        boolean complete=parser.parseNext(chunk);\n                        if (chunk.position()==pos)\n                        {\n                            // Nothing consumed\n                            if (BufferUtil.isEmpty(chunk))\n                                break;\n                            return null;\n                        }\n\n                        // Add all consumed bytes to the output stream\n                        bout.write(chunk.array(),chunk.arrayOffset()+pos,chunk.position()-pos);\n\n                        // If we are complete then break the outer loop\n                        if (complete)\n                        {\n                            if (BufferUtil.hasContent(chunk))\n                                _responseData=chunk;\n                            break loop;\n                        }\n                    }\n                }\n                return ByteBuffer.wrap(bout.getBuf(),0,bout.getCount()); \n            }\n        }","id":38440,"modified_method":"/** Wait for a response using a parser to detect the end of message\n         * @param head\n         * @param time\n         * @param unit\n         * @return Buffer containing full response or null for EOF;\n         * @throws Exception\n         */\n        public ByteBuffer waitForResponse(boolean head, long time,TimeUnit unit) throws Exception\n        {\n            HttpParser.ResponseHandler handler = new HttpParser.ResponseHandler()\n            {\n                @Override\n                public void parsedHeader(HttpField field)\n                {\n                }\n                \n                @Override\n                public boolean messageComplete()\n                {\n                    return true;\n                }\n                \n                @Override\n                public boolean headerComplete()\n                {\n                    return false;\n                }\n                \n                @Override\n                public int getHeaderCacheSize()\n                {\n                    return 0;\n                }\n                \n                @Override\n                public void earlyEOF()\n                {                \n                }\n                \n                @Override\n                public boolean content(ByteBuffer item)\n                {\n                    return false;\n                }\n                \n                @Override\n                public void badMessage(int status, String reason)\n                {\n                }\n                \n                @Override\n                public boolean startResponse(HttpVersion version, int status, String reason)\n                {\n                    return false;\n                }\n            };\n            \n            HttpParser parser = new HttpParser(handler);\n            parser.setHeadResponse(head);\n            try(ByteArrayOutputStream2 bout = new ByteArrayOutputStream2();)\n            {\n                loop: while(true)\n                {\n                    // read a chunk of response\n                    ByteBuffer chunk;\n                    if (BufferUtil.hasContent(_responseData))\n                        chunk = _responseData;\n                    else \n                    {\n                        chunk = waitForOutput(time,unit);\n                        if (BufferUtil.isEmpty(chunk) && (!isOpen() || isOutputShutdown()))\n                        {\n                            parser.atEOF();\n                            parser.parseNext(BufferUtil.EMPTY_BUFFER);\n                            break loop;\n                        }\n                    }\n                    \n                    // Parse the content of this chunk\n                    while (BufferUtil.hasContent(chunk))\n                    {\n                        int pos=chunk.position();\n                        boolean complete=parser.parseNext(chunk);\n                        if (chunk.position()==pos)\n                        {\n                            // Nothing consumed\n                            if (BufferUtil.isEmpty(chunk))\n                                break;\n                            return null;\n                        }\n\n                        // Add all consumed bytes to the output stream\n                        bout.write(chunk.array(),chunk.arrayOffset()+pos,chunk.position()-pos);\n\n                        // If we are complete then break the outer loop\n                        if (complete)\n                        {\n                            if (BufferUtil.hasContent(chunk))\n                                _responseData=chunk;\n                            break loop;\n                        }\n                    }\n                }\n                return ByteBuffer.wrap(bout.getBuf(),0,bout.getCount()); \n            }\n        }","commit_id":"183e3acabb828af8ed370b8a5eeaacbd6a5bf91b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Get a single response using a parser to search for the end of the message.\n     * @param requestsBuffer The request to send\n     * @param head True if the response is for a head request\n     * @param time The time to wait\n     * @param unit The units of the wait\n     * @return ByteBuffer containing response or null.\n     * @throws Exception If there is a problem\n     */\n    public ByteBuffer getResponse(ByteBuffer requestsBuffer,boolean head, long time,TimeUnit unit) throws Exception\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"requests {}\", BufferUtil.toUTF8String(requestsBuffer));\n        LocalEndPoint endp = executeRequest(requestsBuffer);\n        return endp.waitForResponse(head,time,unit);\n    }","id":38441,"modified_method":"/** Get a single response using a parser to search for the end of the message.\n     * @param requestBuffer The request to send\n     * @param head True if the response is for a head request\n     * @param time The time to wait\n     * @param unit The units of the wait\n     * @return ByteBuffer containing response or null.\n     * @throws Exception If there is a problem\n     */\n    public ByteBuffer getResponse(ByteBuffer requestBuffer,boolean head, long time,TimeUnit unit) throws Exception\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"requests {}\", BufferUtil.toUTF8String(requestBuffer));\n        LocalEndPoint endp = executeRequest(requestBuffer);\n        return endp.waitForResponse(head,time,unit);\n    }","commit_id":"183e3acabb828af8ed370b8a5eeaacbd6a5bf91b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        protected void commitResponse(ResponseInfo info, ByteBuffer content) throws IOException\n        {\n            // Only one response writer at a time.\n            synchronized (this)\n            {\n                _info=info;\n\n                LOG.debug(\"{} commit {}\",this,_info);\n\n                try\n                {\n                    if (_generator.isCommitted())\n                        throw new IllegalStateException(\"committed\");\n                    if (BufferUtil.hasContent(_responseBuffer))\n                        throw new IllegalStateException(\"!empty\");\n                    if (_generator.isComplete())\n                        throw new EofException();\n\n                    loop: while (true)\n                    {\n                        HttpGenerator.Result result=_generator.generate(_info,_responseHeader,null,_responseBuffer,content,Action.COMPLETE);\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"{} commit: {} ({},{},{})@{}\",\n                                this,\n                                result,\n                                BufferUtil.toDetailString(_responseHeader),\n                                BufferUtil.toSummaryString(_responseBuffer),\n                                BufferUtil.toSummaryString(content),\n                                _generator.getState());\n\n                        switch(result)\n                        {\n                            case NEED_INFO:\n                                _info=_channel.getEventHandler().commit();\n                                if (_responseHeader==null)\n                                    _responseHeader=_bufferPool.acquire(_httpConfig.getResponseHeaderSize(),false);\n                                break;\n\n                            case NEED_HEADER:\n                                _responseHeader=_bufferPool.acquire(_httpConfig.getResponseHeaderSize(),false);\n                                break;\n\n                            case NEED_BUFFER:\n                                _responseBuffer=_bufferPool.acquire(_httpConfig.getResponseBufferSize(),false);\n                                break;\n\n                            case NEED_CHUNK:\n                                throw new IllegalStateException(\"!chunk when content length known\");\n\n                            case FLUSH:\n                                if (_info.isHead())\n                                {\n                                    if (_chunk!=null)\n                                        BufferUtil.clear(_chunk);\n                                    if (_responseBuffer!=null)\n                                        BufferUtil.clear(_responseBuffer);\n                                }\n                                write(_responseHeader,_chunk,_responseBuffer).get();\n                                break;\n\n                            case FLUSH_CONTENT:\n                                if (_info.isHead())\n                                {\n                                    if (_chunk!=null)\n                                        BufferUtil.clear(_chunk);\n                                    if (_responseBuffer!=null)\n                                        BufferUtil.clear(content);\n                                }\n                                // TODO need a proper call back to complete.\n                                write(_responseHeader,_chunk,content);\n                                break loop;\n\n                            case SHUTDOWN_OUT:\n                                terminate();\n                                break loop;\n\n                            case OK:\n                                if (_info!=null && _info.isInformational())\n                                    _info=null;\n                                break loop;\n                        }\n                    }\n                }\n                catch(InterruptedException e)\n                {\n                    LOG.debug(e);\n                }\n                catch(ExecutionException e)\n                {\n                    LOG.debug(e);\n                    FutureCallback.rethrow(e);\n                }\n            }\n        }","id":38442,"modified_method":"@Override\n        protected void commitResponse(ResponseInfo info, ByteBuffer content) throws IOException\n        {\n            // Only one response writer at a time.\n            synchronized (this)\n            {\n                _info=info;\n\n                LOG.debug(\"{} commit {}\",this,_info);\n\n                try\n                {\n                    if (_generator.isCommitted())\n                        throw new IllegalStateException(\"committed\");\n                    if (BufferUtil.hasContent(_responseBuffer))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"discarding uncommitted response {}\",BufferUtil.toDetailString(_responseBuffer));\n                        BufferUtil.clear(_responseBuffer);\n                    }\n                    if (_generator.isComplete())\n                        throw new EofException();\n\n                    loop: while (true)\n                    {\n                        HttpGenerator.Result result=_generator.generate(_info,_responseHeader,null,_responseBuffer,content,Action.COMPLETE);\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"{} commit: {} ({},{},{})@{}\",\n                                this,\n                                result,\n                                BufferUtil.toDetailString(_responseHeader),\n                                BufferUtil.toSummaryString(_responseBuffer),\n                                BufferUtil.toSummaryString(content),\n                                _generator.getState());\n\n                        switch(result)\n                        {\n                            case NEED_INFO:\n                                _info=_channel.getEventHandler().commit();\n                                if (_responseHeader==null)\n                                    _responseHeader=_bufferPool.acquire(_httpConfig.getResponseHeaderSize(),false);\n                                break;\n\n                            case NEED_HEADER:\n                                _responseHeader=_bufferPool.acquire(_httpConfig.getResponseHeaderSize(),false);\n                                break;\n\n                            case NEED_BUFFER:\n                                _responseBuffer=_bufferPool.acquire(_httpConfig.getResponseBufferSize(),false);\n                                break;\n\n                            case NEED_CHUNK:\n                                throw new IllegalStateException(\"!chunk when content length known\");\n\n                            case FLUSH:\n                                if (_info.isHead())\n                                {\n                                    if (_chunk!=null)\n                                        BufferUtil.clear(_chunk);\n                                    if (_responseBuffer!=null)\n                                        BufferUtil.clear(_responseBuffer);\n                                }\n                                write(_responseHeader,_chunk,_responseBuffer).get();\n                                break;\n\n                            case FLUSH_CONTENT:\n                                if (_info.isHead())\n                                {\n                                    if (_chunk!=null)\n                                        BufferUtil.clear(_chunk);\n                                    if (_responseBuffer!=null)\n                                        BufferUtil.clear(content);\n                                }\n                                // TODO need a proper call back to complete.\n                                write(_responseHeader,_chunk,content);\n                                break loop;\n\n                            case SHUTDOWN_OUT:\n                                terminate();\n                                break loop;\n\n                            case OK:\n                                if (_info!=null && _info.isInformational())\n                                    _info=null;\n                                break loop;\n                        }\n                    }\n                }\n                catch(InterruptedException e)\n                {\n                    LOG.debug(e);\n                }\n                catch(ExecutionException e)\n                {\n                    LOG.debug(e);\n                    FutureCallback.rethrow(e);\n                }\n            }\n        }","commit_id":"ed76d970492653af482dd5a4103c6430efa8bb7e","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            containingDocument.setGotSubmission();\n\n            // Variables declared here as they are used in a catch/finally block\n            boolean isDeferredSubmissionSecondPassReplaceAll = false;\n            XFormsSubmitErrorEvent submitErrorEvent = null;\n            XFormsSubmitDoneEvent submitDoneEvent = null;\n            final long submissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n\n            // Make sure submission element info is extracted\n            extractSubmissionElement();\n\n            // XPath function library and namespace mappings\n            final FunctionLibrary functionLibrary = XFormsContainingDocument.getFunctionLibrary();\n            final Map prefixToURIMap = container.getNamespaceMappings(submissionElement);\n\n            try {\n                final boolean isReplaceAll = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n                final boolean isReplaceInstance = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE);\n                final boolean isReplaceText = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_TEXT);\n                final boolean isReplaceNone = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE);\n\n                // Get current node for xforms:submission and instance containing the node to submit\n                final NodeInfo refNodeInfo;\n                final XFormsInstance refInstance;\n                // Get and reset context stack\n                final XFormsContextStack contextStack = model.getContextStack();\n                contextStack.resetBindingContext(pipelineContext);\n                final Item submissionElementContextItem;\n\n                final XFormsFunction.Context functionContext;\n                {\n                    contextStack.setBinding(pipelineContext, XFormsModelSubmission.this);\n\n                    refNodeInfo = contextStack.getCurrentSingleNode();\n                    functionContext = contextStack.getFunctionContext();\n                    submissionElementContextItem = contextStack.getContextItem();\n\n                    // Check that we have a current node and that it is pointing to a document or an element\n                    if (refNodeInfo == null)\n                        throw new XFormsSubmissionException(\"Empty single-node binding on xforms:submission for submission id: \" + id, \"getting submission single-node binding\",\n                        \t\t XFormsSubmitErrorEvent.ErrorType.NO_DATA);\n\n                    if (!(refNodeInfo instanceof DocumentInfo || refNodeInfo.getNodeKind() == org.w3c.dom.Document.ELEMENT_NODE)) {\n                        throw new XFormsSubmissionException(\"xforms:submission: single-node binding must refer to a document node or an element.\", \"getting submission single-node binding\",\n                        \t\tXFormsSubmitErrorEvent.ErrorType.NO_DATA);\n                    }\n\n                    // Current instance may be null if the document submitted is not part of an instance\n                    refInstance = contextStack.getCurrentInstance();\n                }\n\n                // Determine if the instance to submit has one or more bound and relevant upload controls\n                //\n                // o we don't check if we are currently initializing the document because at that point the\n                //   client cannot have any files to upload yet\n                //\n                // o we don't check if we have already processed the second pass of a submission during this\n                //   request, because it means that upload controls have been already committed\n                //\n                // o we don't check if we are requested not to with an attribute\n                //\n                // o we only check for replace=\"instance|none\" and if serialization must take place\n\n                final boolean hasBoundRelevantUploadControl;\n                if (refInstance!= null && !containingDocument.isInitializing() && !containingDocument.isGotSubmissionSecondPass() && xxfFormsEnsureUploads && !isReplaceAll && serialize) {\n                    hasBoundRelevantUploadControl = XFormsUtils.hasBoundRelevantUploadControls(containingDocument, refInstance);\n                } else {\n                    hasBoundRelevantUploadControl = false;\n                }\n\n                // Evaluate early AVTs\n                final String resolvedMethod;\n                final String actualHttpMethod;\n                final String resolvedMediatype;\n\n                final boolean resolvedValidate;\n                final boolean resolvedRelevant;\n                {\n                    // Resolved method AVT\n                    final String resolvedMethodQName = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMethod);\n                    resolvedMethod = Dom4jUtils.qNameToExplodedQName(Dom4jUtils.extractTextValueQName(prefixToURIMap, resolvedMethodQName, true));\n\n                    // Get actual method based on the method attribute\n                    actualHttpMethod = getActualHttpMethod(resolvedMethod);\n\n                    // Get mediatype\n                    resolvedMediatype = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMediatype);\n\n                    // Resolve validate and relevant AVTs\n                    final String resolvedValidateString = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtValidate);\n                    resolvedValidate = !\"false\".equals(resolvedValidateString);\n\n                    final String resolvedRelevantString = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtRelevant);\n                    resolvedRelevant = !\"false\".equals(resolvedRelevantString);\n                }\n\n                final boolean isHandlingOptimizedGet = XFormsProperties.isOptimizeGetAllSubmission(containingDocument) && actualHttpMethod.equals(\"GET\")\n                        && isReplaceAll\n                        && (resolvedMediatype == null || !resolvedMediatype.startsWith(NetUtils.APPLICATION_SOAP_XML)) // can't let SOAP requests be handled by the browser\n                        && avtXXFormsUsername == null // can't optimize if there are authentication credentials\n                        && avtXXFormsTarget == null;  // can't optimize if there is a target\n\n                // In noscript mode, or in \"Ajax portlet\" mode, there is no deferred submission process\n                final boolean isNoscript = XFormsProperties.isNoscript(containingDocument);\n                final boolean isAllowDeferredSubmission = !isNoscript && !XFormsProperties.isAjaxPortlet(containingDocument);\n\n                final boolean isPossibleDeferredSubmission = (isReplaceAll && !isHandlingOptimizedGet) || (!isReplaceAll && serialize && hasBoundRelevantUploadControl);\n                final boolean isDeferredSubmission = isAllowDeferredSubmission && isPossibleDeferredSubmission;\n                final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n                final boolean isDeferredSubmissionSecondPass = isDeferredSubmission && !isDeferredSubmissionFirstPass; // here we get XXFORMS_SUBMIT\n                isDeferredSubmissionSecondPassReplaceAll = isDeferredSubmissionSecondPass && isReplaceAll;\n\n                if (isDeferredSubmissionSecondPass)\n                    containingDocument.setGotSubmissionSecondPass();\n\n                // If a submission requiring a second pass was already set, then we ignore a subsequent submission but\n                // issue a warning\n                {\n                    final XFormsModelSubmission existingSubmission = containingDocument.getClientActiveSubmission();\n                    if (isDeferredSubmission && existingSubmission != null) {\n                        logger.warn(\"XForms - submission - another submission requiring a second pass already exists (\" + existingSubmission.getEffectiveId() + \"). Ignoring new submission (\" + this.getEffectiveId() + \").\");\n                        return;\n                    }\n                }\n\n                // \"The data model is updated\"\n                final XFormsModel modelForInstance;\n                if (refInstance != null) {\n                    modelForInstance = refInstance.getModel(containingDocument);\n                    {\n                        // NOTE: XForms 1.1 seems to say this should happen regardless of whether we serialize or not. If\n                        // the instance is not serialized and if no instance data is otherwise used for the submission,\n                        // this seems however unneeded.\n\n                        // TODO: XForms 1.1 says that we should rebuild/recalculate the \"model containing this submission\".\n                        modelForInstance.rebuildRecalculateIfNeeded(pipelineContext);\n                    }\n                } else {\n                    // Case where no instance was found\n                    modelForInstance = null;\n                }\n\n                // Resolve the target AVT because XFormsServer requires it for deferred submission\n                resolvedXXFormsTarget = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsTarget);\n\n                // Deferred submission: end of the first pass\n                if (isDeferredSubmissionFirstPass) {\n\n                    // Create document to submit here because in case of error, an Ajax response will still be produced\n                    if (serialize) {\n                        createDocumentToSubmit(pipelineContext, refNodeInfo, refInstance, modelForInstance, resolvedValidate, resolvedRelevant);\n                    }\n\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setClientActiveSubmission(this);\n                    return;\n                }\n\n                /* ************************************* Submission second pass ************************************* */\n\n                // Evaluate late AVTs\n                final String resolvedSerialization;\n                final String resolvedMode;\n                final String resolvedVersion;\n                final String resolvedEncoding;\n                final String resolvedSeparator;\n                final boolean resolvedIndent;\n                final boolean resolvedOmitxmldeclaration;\n                final Boolean resolvedStandalone;\n                final String resolvedXXFormsUsername;\n                final String resolvedXXFormsPassword;\n                final String resolvedXXFormsReadonly;\n                final String resolvedXXFormsShared;\n                final boolean resolvedXXFormsHandleXInclude;\n                {\n                    final String tempActionOrResource = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtActionOrResource);\n\n                    if (tempActionOrResource == null) {\n                        // This can be null if, e.g. you have an AVT like resource=\"{()}\"\n                        throw new XFormsSubmissionException(\"xforms:submission: mandatory resource or action evaluated to an empty sequence for attribute value: \" + avtActionOrResource,\n                                \"resolving resource URI\");\n                    }\n\n                    resolvedActionOrResource = XFormsUtils.encodeHRRI(tempActionOrResource, true);\n\n                    resolvedSerialization = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtSerialization);\n                    resolvedMode = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMode);\n                    resolvedVersion = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtVersion);\n                    resolvedEncoding = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtEncoding);\n                    resolvedSeparator = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtSeparator);\n\n                    final String tempIndent = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtIndent);\n                    resolvedIndent = Boolean.valueOf(tempIndent).booleanValue();\n\n                    final String tempAvtOmitxmldeclaration = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtOmitxmldeclaration);\n                    resolvedOmitxmldeclaration = Boolean.valueOf(tempAvtOmitxmldeclaration).booleanValue();\n\n                    final String tempStandalone = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtStandalone);\n                    resolvedStandalone = (tempStandalone != null) ? Boolean.valueOf(tempStandalone) : null;\n\n                    resolvedXXFormsUsername = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsUsername);\n                    resolvedXXFormsPassword = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsPassword);\n                    resolvedXXFormsReadonly = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsReadonly);\n                    resolvedXXFormsShared = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsShared);\n\n                    // Default is \"false\" for security reasons\n                    final String tempHandleXInclude = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsHandleXInclude);\n                    resolvedXXFormsHandleXInclude = Boolean.valueOf(tempHandleXInclude).booleanValue();\n                }\n\n                // Check read-only and shared hints\n                XFormsInstance.checkSharedHints(submissionElement, resolvedXXFormsReadonly, resolvedXXFormsShared);\n                final boolean isReadonlyHint = \"true\".equals(resolvedXXFormsReadonly);\n                final boolean isApplicationSharedHint = \"application\".equals(resolvedXXFormsShared);\n                final long timeToLive = XFormsInstance.getTimeToLive(submissionElement);\n                // TODO: move this to XFormsInstance.checkSharedHints(), and check how to deal w/ use of XFormsInstance.checkSharedHints() by XFormsInstance\n                if (isApplicationSharedHint) {\n                    if (!actualHttpMethod.equals(\"GET\"))\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with method=\\\"get\\\".\",\n                                \"checking read-only and shared hints\");\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                } else if (isReadonlyHint) {\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:readonly=\\\"true\\\" can be \\\"true\\\" only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                }\n\n                /* ************************************* Serialization ************************************* */\n\n                // Get serialization requested from @method and @serialization attributes\n                final String requestedSerialization = getRequestedSerialization(resolvedSerialization, resolvedMethod);\n\n                final Document documentToSubmit;\n                if (serialize) {\n                    // Handle uploaded files if any\n                    final Element filesElement = (event instanceof XXFormsSubmitEvent) ? ((XXFormsSubmitEvent) event).getFilesElement() : null;\n                    if (filesElement != null) {\n                        // Handle all file elements\n                        XFormsUploadControl.handleFileElement(pipelineContext, containingDocument, filesElement, null, !isReplaceAll);\n                    }\n\n                    // Check if a submission requires file upload information\n                    if (requestedSerialization.startsWith(\"multipart/\")) {\n                        // Annotate before re-rooting/pruning\n                        XFormsUtils.annotateBoundRelevantUploadControls(pipelineContext, containingDocument, refInstance);\n                    }\n\n                    // Create document to submit\n                    documentToSubmit = createDocumentToSubmit(pipelineContext, refNodeInfo, refInstance, modelForInstance, resolvedValidate, resolvedRelevant);\n\n                } else {\n                    // Don't recreate document\n                    documentToSubmit = null;\n                }\n\n                final String overriddenSerializedData;\n                if (serialize && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    // Fire xforms-submit-serialize\n\n                    // \"The event xforms-submit-serialize is dispatched. If the submission-body property of the event\n                    // is changed from the initial value of empty string, then the content of the submission-body\n                    // property string is used as the submission serialization. Otherwise, the submission serialization\n                    // consists of a serialization of the selected instance data according to the rules stated at 11.9\n                    // Submission Options.\"\n\n                    final XFormsSubmitSerializeEvent serializeEvent = new XFormsSubmitSerializeEvent(XFormsModelSubmission.this, refNodeInfo, requestedSerialization);\n                    container.dispatchEvent(pipelineContext, serializeEvent);\n\n                    // TODO: rest of submission should happen upon default action of event\n\n                    overriddenSerializedData = serializeEvent.getSerializedData();\n                } else {\n                    overriddenSerializedData = null;\n                }\n\n                // Serialize\n                final byte[] messageBody;// TODO: provide option for body to be a stream\n                final String queryString;\n                final String defaultMediatypeForSerialization;\n                if (serialize) {\n\n                    if (overriddenSerializedData != null && !overriddenSerializedData.equals(\"\")) {\n                        // Form author set data to serialize\n                        if (actualHttpMethod.equals(\"POST\") || actualHttpMethod.equals(\"PUT\")) {\n                            queryString = null;\n                            messageBody = overriddenSerializedData.getBytes(\"UTF-8\");\n                            defaultMediatypeForSerialization = \"application/xml\";\n                        } else {\n                            queryString = URLEncoder.encode(overriddenSerializedData, \"UTF-8\");\n                            messageBody = null;\n                            defaultMediatypeForSerialization = null;\n                        }\n                    } else if (requestedSerialization.equals(\"application/x-www-form-urlencoded\")) {\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        if (actualHttpMethod.equals(\"POST\") || actualHttpMethod.equals(\"PUT\")) {\n                            queryString = null;\n                            messageBody = XFormsSubmissionUtils.createWwwFormUrlEncoded(documentToSubmit, resolvedSeparator).getBytes(\"UTF-8\");// the resulting string is already ASCII in fact\n                            defaultMediatypeForSerialization = \"application/x-www-form-urlencoded\";\n                        } else {\n                            queryString = XFormsSubmissionUtils.createWwwFormUrlEncoded(documentToSubmit, resolvedSeparator);\n                            messageBody = null;\n                            defaultMediatypeForSerialization = null;\n                        }\n                    } else if (requestedSerialization.equals(\"application/xml\")) {\n                        // Serialize XML to a stream of bytes\n                        try {\n                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                            TransformerUtils.applyOutputProperties(identity,\n                                    \"xml\", resolvedVersion, null, null, resolvedEncoding, resolvedOmitxmldeclaration, resolvedStandalone, resolvedIndent, 4);\n\n                            // TODO: use cdata-section-elements\n\n                            final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                            identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                            messageBody = os.toByteArray();\n                        } catch (Exception e) {\n                            throw new XFormsSubmissionException(e, \"xforms:submission: exception while serializing instance to XML.\", \"serializing instance\");\n                        }\n                        defaultMediatypeForSerialization = \"application/xml\";\n                        queryString = null;\n                    } else if (requestedSerialization.equals(\"multipart/related\")) {\n                        // TODO\n                        throw new XFormsSubmissionException(\"xforms:submission: submission serialization not yet implemented: \" + requestedSerialization, \"serializing instance\");\n                    } else if (requestedSerialization.equals(\"multipart/form-data\")) {\n                        // Build multipart/form-data body\n\n                        // Create and set body\n                        final MultipartRequestEntity multipartFormData = XFormsSubmissionUtils.createMultipartFormData(pipelineContext, documentToSubmit);\n\n                        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        multipartFormData.writeRequest(os);\n\n                        messageBody = os.toByteArray();\n                        queryString = null;\n\n                        // The mediatype also contains the boundary\n                        defaultMediatypeForSerialization = multipartFormData.getContentType();\n\n                    } else if (requestedSerialization.equals(\"application/octet-stream\")) {\n                        // Binary serialization\n                        final String nodeType = InstanceData.getType(documentToSubmit.getRootElement());\n\n                        if (XMLConstants.XS_ANYURI_EXPLODED_QNAME.equals(nodeType)) {\n                            // Interpret node as anyURI\n                            // TODO: PERFORMANCE: Must pass InputStream all the way to the submission instead of storing into byte[] in memory!\n                            final String uri = documentToSubmit.getRootElement().getStringValue();\n                            messageBody = NetUtils.uriToByteArray(uri);\n                        } else if (XMLConstants.XS_BASE64BINARY_EXPLODED_QNAME.equals(nodeType)) {\n                            // TODO\n                            throw new XFormsSubmissionException(\"xforms:submission: binary serialization with base64Binary type is not yet implemented.\", \"serializing instance\");\n                        } else {\n                            // TODO\n                            throw new XFormsSubmissionException(\"xforms:submission: binary serialization without a type is not yet implemented.\", \"serializing instance\");\n                        }\n                        defaultMediatypeForSerialization = \"application/octet-stream\";\n                        queryString = null;\n                    } else if (XMLUtils.isTextContentType(requestedSerialization)) {\n                        // TODO: Text serialization\n                        throw new XFormsSubmissionException(\"xforms:submission: text serialization is not yet implemented.\", \"serializing instance\");\n                    } else {\n                        throw new XFormsSubmissionException(\"xforms:submission: invalid submission serialization requested: \" + requestedSerialization, \"serializing instance\");\n                    }\n                } else {\n                    queryString = null;\n                    messageBody = null;\n                    defaultMediatypeForSerialization = null;\n                }\n\n                /* ************************************* Execute submission ************************************* */\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                // Get URL type\n                final String urlType = submissionElement.attributeValue(XMLConstants.FORMATTING_URL_TYPE_QNAME);\n                final ExternalContext.Request request = externalContext.getRequest();\n\n                // Actual request mediatype\n                final String actualRequestMediatype = (resolvedMediatype == null) ? defaultMediatypeForSerialization : resolvedMediatype;\n\n                // Get async/sync\n                // NOTE: XForms 1.1 default to async, but we don't fully support async so we default to sync instead\n                final boolean isAsyncSubmission = isReplaceNone && \"asynchronous\".equals(resolvedMode);// for now we only support this with replace=\"none\"\n\n                // Evaluate headers if any\n                final Map /* LinkedHashMap<String headerName, String[] headerValues> */ customHeaderNameValues = evaluateHeaders(pipelineContext, contextStack);\n\n                // Result information\n                ConnectionResult connectionResult = null;\n                final long externalSubmissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n                try {\n                    if ((isReplaceInstance || isReplaceNone) && resolvedActionOrResource.startsWith(\"test:\")) {\n                        // Test action\n\n                        if (messageBody == null) {\n                            // Not sure when this can happen, but it can't be good\n                            throw new XFormsSubmissionException(\"Action 'test:': no message body.\", \"processing submission response\");\n                        } else {\n                            // Log message mody for debugging purposes\n                            if (XFormsServer.logger.isDebugEnabled())\n                                NetUtils.logRequestBody(containingDocument.getIndentedLogger(), actualRequestMediatype, messageBody);\n                        }\n\n                        // Do as if we are receiving a regular XML response\n                        connectionResult = new ConnectionResult(null);\n                        connectionResult.statusCode = 200;\n                        connectionResult.responseHeaders = new HashMap();\n                        connectionResult.setLastModified(null);\n                        connectionResult.setResponseContentType(\"application/xml\");// should we use actualRequestMediatype instead?\n                        connectionResult.dontHandleResponse = false;\n                        connectionResult.setResponseInputStream(new ByteArrayInputStream(messageBody));\n\n                    } else if (isHandlingOptimizedGet) {\n                        // GET with replace=\"all\": we can optimize and tell the client to just load the URL\n\n                        final String actionString = (queryString == null) ? resolvedActionOrResource : resolvedActionOrResource + ((resolvedActionOrResource.indexOf('?') == -1) ? \"?\" : \"\") + queryString;\n                        final String resultURL = XFormsLoadAction.resolveLoadValue(containingDocument, pipelineContext, submissionElement, true, actionString, null, null, fURLNorewrite, xxfShowProgress);\n                        connectionResult = new ConnectionResult(resultURL);\n                        connectionResult.dontHandleResponse = true;\n\n                    } else if (isAllowOptimizedSubmission(isReplaceAll, isNoscript, urlType, request, isAsyncSubmission)) {\n\n                        // This is an \"optimized\" submission, i.e. one that does not use an actual protocol handler to\n                        // access the resource, but instead uses servlet forward/include for servlets, or a local\n                        // mechanism for portlets.\n\n                        // NOTE: Optimizing with include() for servlets doesn't allow detecting errors caused by the\n                        // included resource. [As of 2009-02-13, not sure if this is the case.]\n\n                        // NOTE: For portlets, paths are served directly by the portlet, NOT as resources.\n\n                        // f:url-norewrite=\"true\" with an absolute path allows accessing other servlet contexts.\n\n                        // Current limitations:\n                        // o Portlets cannot access resources outside the portlet except by using absolute URLs (unless f:url-type=\"resource\")\n\n                        // URI with xml:base resolution\n                        final URI resolvedURI = XFormsUtils.resolveXMLBase(submissionElement, resolvedActionOrResource);\n\n                        // NOTE: We don't want any changes to happen to the document upon xxforms-submit when producing\n                        // a new document so we don't dispatch xforms-submit-done and pass a null XFormsModelSubmission\n                        // in that case\n\n                        if (XFormsServer.logger.isDebugEnabled())\n                            containingDocument.logDebug(\"submission\", \"starting optimized submission\", new String[] { \"id\", getEffectiveId() });\n\n                        // NOTE about headers forwarding: forward user-agent header for replace=\"all\", since that *usually*\n                        // simulates a request from the browser! Useful in particular when the target URL renders XForms\n                        // in noscript mode, where some browser sniffing takes place for handling the <button> vs. <submit>\n                        // element.\n                        final String[] headersToForward = isReplaceAll ? XFormsSubmissionUtils.STANDARD_HEADERS_TO_FORWARD : XFormsSubmissionUtils.MINIMAL_HEADERS_TO_FORWARD;\n                        // TODO: Harmonize with HTTP submission handling of headers\n\n                        connectionResult = XFormsSubmissionUtils.openOptimizedConnection(pipelineContext, externalContext, containingDocument,\n                                isDeferredSubmissionSecondPassReplaceAll ? null : this, actualHttpMethod, resolvedURI.toString(), fURLNorewrite, actualRequestMediatype,\n                                messageBody, queryString, isReplaceAll, headersToForward, customHeaderNameValues);\n\n                        // This means we got a submission with replace=\"all\"\n                        if (connectionResult.dontHandleResponse)\n                            containingDocument.setGotSubmissionReplaceAll();\n\n                    } else {\n                        // This is a regular remote submission going through a protocol handler\n\n                        // Absolute URLs or absolute paths are allowed to a local servlet\n                        String resolvedURL;\n\n                        if (NetUtils.urlHasProtocol(resolvedActionOrResource) || fURLNorewrite) {\n                            // Don't touch the URL if it is absolute or if f:url-norewrite=\"true\"\n                            resolvedURL = resolvedActionOrResource;\n                        } else {\n                            // Rewrite URL\n                            resolvedURL = XFormsUtils.resolveServiceURL(pipelineContext, submissionElement, resolvedActionOrResource,\n                                    ExternalContext.Response.REWRITE_MODE_ABSOLUTE_PATH_OR_RELATIVE);\n\n                            if (request.getContainerType().equals(\"portlet\") && \"resource\".equals(urlType) && !NetUtils.urlHasProtocol(resolvedURL)) {\n                                // In this case, we have to prepend the complete server path\n                                resolvedURL = request.getScheme() + \"://\" + request.getServerName() + (request.getServerPort() > 0 ? \":\" + request.getServerPort() : \"\") + resolvedURL;\n                            }\n                        }\n\n                        if (isApplicationSharedHint) {\n                            // Get the instance from shared instance cache\n                            // This can only happen is method=\"get\" and replace=\"instance\" and xxforms:readonly=\"true\" and xxforms:shared=\"application\"\n\n                            final NodeInfo destinationNodeInfo = evaluateTargetRef(pipelineContext, findReplaceInstanceNoTargetref(refInstance), submissionElementContextItem,\n                                                        prefixToURIMap, contextStack, functionLibrary, functionContext);\n\n                            if (destinationNodeInfo == null) {\n                                // Throw target-error\n\n                                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                                // then submission processing ends after dispatching the event\n                                // xforms-submit-error with an error-type of target-error.\"\n\n                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element for replace=\\\"instance\\\".\", \"processing targetref attribute\");\n                            }\n\n                            final XFormsInstance updatedInstance = containingDocument.getInstanceForNode(destinationNodeInfo);\n                            if (updatedInstance == null || !updatedInstance.getInstanceRootElementInfo().isSameNodeInfo(destinationNodeInfo)) {\n                                // Only support replacing the root element of an instance when using a shared instance\n                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                throw new XFormsSubmissionException(\"targetref attribute must point to an instance root element when using shared instance replacement.\", \"processing targetref attribute\");\n                            }\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"using instance from application shared instance cache\",\n                                        new String[] { \"instance\", updatedInstance.getEffectiveId() });\n\n                            final URL absoluteResolvedURL = NetUtils.createAbsoluteURL(resolvedURL, queryString, externalContext);\n                            final String absoluteResolvedURLString = absoluteResolvedURL.toExternalForm();\n\n                            final SharedXFormsInstance sharedInstance\n                                    = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, updatedInstance.getId(), updatedInstance.getEffectiveModelId(),\n                                        absoluteResolvedURLString, timeToLive, updatedInstance.getValidation(), resolvedXXFormsHandleXInclude);\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                        new String[] { \"instance\", sharedInstance.getEffectiveId() });\n\n                            final XFormsModel replaceModel = sharedInstance.getModel(containingDocument);\n\n                            // Dispatch xforms-delete event\n                            // NOTE: Do NOT dispatch so we are compatible with the regular root element replacement\n                            // (see below). In the future, we might want to dispatch this, especially if\n                            // XFormsInsertAction dispatches xforms-delete when removing the root element\n                            //updatedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(updatedInstance, Collections.singletonList(destinationNodeInfo), 1));\n\n                            // Handle new instance and associated event markings\n                            final NodeInfo newRootElementInfo = sharedInstance.getInstanceRootElementInfo();\n                            replaceModel.handleUpdatedInstance(pipelineContext, sharedInstance, newRootElementInfo);\n\n                            // Dispatch xforms-insert event\n                            // NOTE: use the root node as insert location as it seems to make more sense than pointing to the earlier root element\n                            sharedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext,\n                                new XFormsInsertEvent(sharedInstance, Collections.singletonList(newRootElementInfo), null, newRootElementInfo.getDocumentRoot(),\n                                        \"after\", null, null, true));\n\n                            connectionResult = null;\n                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, absoluteResolvedURLString, 200);\n                        } else {\n                            // Perform actual submission\n\n                            // Compute absolute submission URL\n                            final URL submissionURL = NetUtils.createAbsoluteURL(resolvedURL, queryString, externalContext);\n\n                            // Gather remaining information to process the request\n                            final String forwardSubmissionHeaders = XFormsProperties.getForwardSubmissionHeaders(containingDocument);\n\n                            // NOTE about headers forwarding: forward user-agent header for replace=\"all\", since that *usually*\n                            // simulates a request from the browser! Useful in particular when the target URL renders XForms\n                            // in noscript mode, where some browser sniffing takes place for handling the <button> vs. <submit>\n                            // element.\n                            final String newForwardSubmissionHeaders = isReplaceAll ? forwardSubmissionHeaders + \" user-agent\" : forwardSubmissionHeaders;\n\n                            // Open connection\n                            if (isAsyncSubmission) {\n                                final IndentedLogger indentedLogger = new IndentedLogger(XFormsServer.logger, \"XForms (async)\");\n                                final Map headersMap = NetUtils.getHeadersMap(externalContext, indentedLogger,\n                                            resolvedXXFormsUsername, customHeaderNameValues, newForwardSubmissionHeaders);\n\n                                // Pack call into a Runnable\n                                final Runnable runnable = new Runnable() {\n\n                                    public void run() {\n\n                                        // Here we just want to run the submission and not touch the HttpRequest or\n                                        // XFCD. Remember, we can't change XFCD because it may get out of the caches\n                                        // and not be picked up by further incoming Ajax requests.\n                                        NetUtils.openConnection(indentedLogger,\n                                            actualHttpMethod, submissionURL, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                            actualRequestMediatype, messageBody, headersMap);\n\n                                        // NOTE: In this very basic level of support, we don't support xforms-submit-done / xforms-submit-error handlers\n\n                                        // TODO: Do something with result, e.g. log?\n                                        // final ConnectionResult connectionResult = ...\n                                    }\n                                };\n\n                                // Tell XFCD that we have one more Runnable\n                                containingDocument.addAsynchronousSubmission(runnable);\n                                connectionResult = null;\n\n                            } else {\n                                // Just run it now\n                                connectionResult = NetUtils.openConnection(externalContext, containingDocument.getIndentedLogger(),\n                                        actualHttpMethod, submissionURL, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                        actualRequestMediatype, messageBody,\n                                        customHeaderNameValues, newForwardSubmissionHeaders);\n                            }\n                        }\n                    }\n\n                    /* ************************************* Submission response ************************************* */\n\n                    if (connectionResult != null && !connectionResult.dontHandleResponse) {\n                        // Handle response\n                        if (connectionResult.statusCode >= 200 && connectionResult.statusCode < 300) {// accept any success code (in particular \"201 Resource Created\")\n                            // Sucessful response\n                            if (connectionResult.hasContent()) {\n                                // There is a body\n\n                                if (isReplaceAll) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    if (!isDeferredSubmissionSecondPassReplaceAll) // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                                        container.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult));\n\n                                    // Remember that we got a submission producing output\n                                    containingDocument.setGotSubmissionReplaceAll();\n\n                                    // Get response from containing document\n                                    final ExternalContext.Response response = containingDocument.getResponse();\n\n                                    // Set content-type\n                                    response.setContentType(connectionResult.getResponseContentType());\n\n                                    // Forward headers to response\n                                    connectionResult.forwardHeaders(response);\n\n                                    // Forward content to response\n                                    final OutputStream outputStream = response.getOutputStream();\n                                    NetUtils.copyStream(connectionResult.getResponseInputStream(), outputStream);\n\n                                    // End document and close\n                                    outputStream.flush();\n                                    outputStream.close();\n\n                                    // TODO: [#306918] RFE: Must be able to do replace=\"all\" during initialization.\n                                    // http://forge.objectweb.org/tracker/index.php?func=detail&aid=306918&group_id=168&atid=350207\n                                    // Suggestion is to write either binary or XML to processor output ContentHandler,\n                                    // and make sure the code which would output the XHTML+XForms is disabled.\n\n                                } else if (isReplaceInstance) {\n\n                                    if (XMLUtils.isXMLMediatype(connectionResult.getResponseMediaType())) {\n                                        // Handling of XML media type\n                                        // Set new instance document to replace the one submitted\n\n                                        final XFormsInstance replaceInstanceNoTargetref = findReplaceInstanceNoTargetref(refInstance);\n                                        if (replaceInstanceNoTargetref == null) {\n\n                                            // Replacement instance or node was specified but not found\n                                            //\n                                            // Not sure what's the right thing to do with 1.1, but this could be done\n                                            // as part of the model's static analysis if the instance value is not\n                                            // obtained through AVT, and dynamically otherwise. However, in the dynamic\n                                            // case, I think that this should be a (currently non-specified by XForms)\n                                            // xforms-binding-error.\n                                            container.dispatchEvent(pipelineContext, new XFormsBindingExceptionEvent(XFormsModelSubmission.this));\n                                        } else {\n\n                                            final NodeInfo destinationNodeInfo = evaluateTargetRef(pipelineContext,\n                                                    replaceInstanceNoTargetref, submissionElementContextItem,\n                                                    prefixToURIMap, contextStack, functionLibrary, functionContext);\n\n                                            if (destinationNodeInfo == null) {\n                                                // Throw target-error\n\n                                                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                                                // then submission processing ends after dispatching the event\n                                                // xforms-submit-error with an error-type of target-error.\"\n\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element for replace=\\\"instance\\\".\", \"processing targetref attribute\");\n                                            }\n\n                                            // This is the instance which is effectively going to be updated\n                                            final XFormsInstance updatedInstance = containingDocument.getInstanceForNode(destinationNodeInfo);\n                                            if (updatedInstance == null) {\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element in an existing instance for replace=\\\"instance\\\".\", \"processing targetref attribute\");\n                                            }\n\n                                            // Whether the destination node is the root element of an instance\n                                            final boolean isDestinationRootElement = updatedInstance.getInstanceRootElementInfo().isSameNodeInfo(destinationNodeInfo);\n\n                                            // Obtain root element to insert\n                                            final NodeInfo newDocumentRootElement;\n                                            final XFormsInstance newInstance;\n                                            try {\n                                                // Create resulting instance whether entire instance is replaced or not, because this:\n                                                // 1. Wraps a Document within a DocumentInfo if needed\n                                                // 2. Performs text nodes adjustments if needed\n                                                if (!isReadonlyHint) {\n                                                    // Resulting instance must not be read-only\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    final Document resultingInstanceDocument\n                                                            = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with mutable instance\",\n                                                            new String[] { \"instance\", updatedInstance.getEffectiveId() });\n\n                                                    newInstance = new XFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                                                            resultingInstanceDocument, connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                                            false, -1, updatedInstance.getValidation(), resolvedXXFormsHandleXInclude);\n                                                } else {\n                                                    // Resulting instance must be read-only\n\n                                                    if (!isDestinationRootElement) {\n                                                        // Only support replacing the root element of an instance when using a shared instance\n                                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                        throw new XFormsSubmissionException(\"targetref attribute must point to instance root element when using read-only instance replacement.\", \"processing targetref attribute\");\n                                                    }\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    // NOTE: isApplicationSharedHint is always false when get get here. isApplicationSharedHint=\"true\" is handled above.\n                                                    final DocumentInfo resultingInstanceDocument\n                                                            = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                                            new String[] { \"instance\", updatedInstance.getEffectiveId() });\n\n                                                    newInstance = new SharedXFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                                                            resultingInstanceDocument, connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                                            false, -1, updatedInstance.getValidation(), resolvedXXFormsHandleXInclude);\n                                                }\n                                                newDocumentRootElement = newInstance.getInstanceRootElementInfo();\n                                            } catch (Exception e) {\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.PARSE_ERROR);\n                                                throw new XFormsSubmissionException(e, \"xforms:submission: exception while reading XML response.\", \"processing instance replacement\");\n                                            }\n\n                                            // Perform insert/delete. This will dispatch xforms-insert/xforms-delete events.\n                                            // \"the replacement is performed by an XForms action that performs some\n                                            // combination of node insertion and deletion operations that are\n                                            // performed by the insert action (10.3 The insert Element) and the\n                                            // delete action\"\n\n                                            if (isDestinationRootElement) {\n                                                // Optimized insertion for instance root element replacement\n\n                                                // Handle new instance and associated event markings\n                                                final XFormsModel replaceModel = newInstance.getModel(containingDocument);\n                                                replaceModel.handleUpdatedInstance(pipelineContext, newInstance, newDocumentRootElement);\n                                                \n                                                // Dispatch xforms-delete event\n                                                // NOTE: Do NOT dispatch so we are compatible with the regular root element replacement\n                                                // (see below). In the future, we might want to dispatch this, especially if\n                                                // XFormsInsertAction dispatches xforms-delete when removing the root element\n                                                //updatedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(updatedInstance, Collections.singletonList(destinationNodeInfo), 1));\n\n                                                // Dispatch xforms-insert event\n                                                // NOTE: use the root node as insert location as it seems to make more sense than pointing to the earlier root element\n                                                newInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext,\n                                                    new XFormsInsertEvent(newInstance, Collections.singletonList(newDocumentRootElement), null, newDocumentRootElement.getDocumentRoot(),\n                                                            \"after\", null, null, true));\n\n                                            } else {\n                                                // Generic insertion\n\n                                                final List destinationCollection = Collections.singletonList(destinationNodeInfo);\n\n                                                // Perform the insertion\n\n                                                // Insert before the target node, so that the position of the inserted node\n                                                // wrt its parent does not change after the target node is removed\n                                                final List insertedNode = XFormsInsertAction.doInsert(pipelineContext, containingDocument, \"before\",\n                                                        destinationCollection, destinationNodeInfo.getParent(),\n                                                        Collections.singletonList(newDocumentRootElement), 1, false, true);\n\n                                                if (!destinationNodeInfo.getParent().isSameNodeInfo(destinationNodeInfo.getDocumentRoot())) {\n                                                    // The node to replace is NOT a root element\n\n                                                    // Perform the deletion of the selected node\n                                                    XFormsDeleteAction.doDelete(pipelineContext, containingDocument, destinationCollection, 1, true);\n                                                }\n\n                                                // Perform model instance update\n                                                // Handle new instance and associated event markings\n                                                // NOTE: The inserted node NodeWrapper.index might be out of date at this point because:\n                                                // * doInsert() dispatches an event which might itself change the instance\n                                                // * doDelete() does as well\n                                                // Does this mean that we should check that the node is still where it should be?\n                                                final XFormsModel updatedModel = updatedInstance.getModel(containingDocument);\n                                                updatedModel.handleUpdatedInstance(pipelineContext, updatedInstance, (NodeInfo) insertedNode.get(0));\n                                            }\n\n                                            // Notify that submission is done\n                                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + connectionResult.getResponseMediaType(), \"processing instance replacement\");\n                                    }\n                                } else if (isReplaceText) {\n\n                                    // XForms 1.1: \"If the replace attribute contains the value \"text\" and the\n                                    // submission response conforms to an XML mediatype (as defined by the content type\n                                    // specifiers in [RFC 3023]) or a text media type (as defined by a content type\n                                    // specifier of text/*), then the response data is encoded as text and replaces the\n                                    // content of the replacement target node.\"\n\n                                    // Get response body\n                                    String responseBody = \"\";\n                                    if (XMLUtils.isTextContentType(connectionResult.getResponseMediaType())) {\n                                        // Text mediatype (including text/xml), read stream into String\n                                        try {\n                                            final String charset = NetUtils.getTextCharsetFromContentType(connectionResult.getResponseContentType());\n                                            final Reader reader = new InputStreamReader(connectionResult.getResponseInputStream(), charset);\n                                            try {\n                                                responseBody = NetUtils.readStreamAsString(reader);\n                                            } finally {\n                                                try {\n                                                    reader.close();\n                                                } catch (Exception e) {\n                                                }\n                                            }\n                                        } catch (Exception e) {\n                                            XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                                        }\n                                    } else if (XMLUtils.isXMLMediatype(connectionResult.getResponseMediaType())) {\n                                        // XML mediatype other than text/xml\n\n                                        // TODO: What should we do if the response Content-Type includes a charset parameter?\n                                        final Reader reader = XMLUtils.getReaderFromXMLInputStream(connectionResult.resourceURI, connectionResult.getResponseInputStream());\n                                        try {\n                                            responseBody = NetUtils.readStreamAsString(reader);\n                                        } finally {\n                                            try {\n                                                reader.close();\n                                            } catch (Exception e) {\n                                            }\n                                        }\n                                    } else {\n                                        // This is a binary result\n\n                                        // Don't store anything for now as per the spec, but we could do something better by going beyond the spec\n                                        // NetUtils.inputStreamToAnyURI(pipelineContext, connectionResult.resultInputStream, NetUtils.SESSION_SCOPE);\n\n                                        // XForms 1.1: \"For a success response including a body that is both a non-XML\n                                        // media type (i.e. with a content type not matching any of the specifiers in\n                                        // [RFC 3023]) and a non-text type (i.e. with a content type not matching\n                                        // text/*), when the value of the replace attribute on element submission is\n                                        // \"text\", nothing in the document is replaced and submission processing\n                                        // concludes after dispatching xforms-submit-error with appropriate context\n                                        // information, including an error-type of resource-error.\"\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Mediatype is neither text nor XML for replace=\\\"text\\\": \" + connectionResult.getResponseMediaType(), \"reading response body\");\n                                    }\n\n                                    // Find target location\n                                    final NodeInfo destinationNodeInfo;\n                                    if (targetref != null) {\n                                        // Evaluate destination node\n                                        final Object destinationObject\n                                                = XPathCache.evaluateSingle(pipelineContext, refNodeInfo, targetref, prefixToURIMap,\n                                                contextStack.getCurrentVariables(), functionLibrary, functionContext, null, getLocationData());\n\n                                        if (destinationObject instanceof NodeInfo) {\n                                            destinationNodeInfo = (NodeInfo) destinationObject;\n                                            if (destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ATTRIBUTE_NODE) {\n                                                // Throw target-error\n\n                                                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                                                // then submission processing ends after dispatching the event\n                                                // xforms-submit-error with an error-type of target-error.\"\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element or attribute for replace=\\\"text\\\".\", \"processing targetref attribute\");\n                                            }\n                                        } else {\n                                            // Throw target-error\n                                            // TODO: also do this for readonly situation\n\n                                            // XForms 1.1: \"If the processing of the targetref attribute fails, then\n                                            // submission processing ends after dispatching the event\n                                            // xforms-submit-error with an error-type of target-error.\"\n                                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                            throw new XFormsSubmissionException(\"targetref attribute doesn't point to a node for replace=\\\"text\\\".\", \"processing targetref attribute\");\n                                        }\n                                    } else {\n                                        // Handle default destination\n                                        destinationNodeInfo = findReplaceInstanceNoTargetref(refInstance).getInstanceRootElementInfo();\n                                    }\n\n                                    // Set value into the instance\n                                    XFormsSetvalueAction.doSetValue(pipelineContext, containingDocument, this, destinationNodeInfo, responseBody, null, false);\n\n                                    // Notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n\n                                } else if (isReplaceNone) {\n                                    // Just notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                } else {\n                                    submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR);\n                                    throw new XFormsSubmissionException(\"xforms:submission: invalid replace attribute: \" + replace, \"processing instance replacement\");\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n\n                                if (isReplaceInstance) {\n                                    // XForms 1.1 says it is fine not to have a body, but in most cases you will want\n                                    // to know that no instance replacement took place\n                                    XFormsServer.logger.warn(\"XForms - submission - instance replacement did not take place upon successful response because no body was provided. Submission: \"\n                                            + getEffectiveId());\n                                }\n\n                                submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                            }\n                        } else if (connectionResult.statusCode == 302 || connectionResult.statusCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            connectionResult.forwardHeaders(response);\n\n                            // Forward redirect\n                            response.setStatus(connectionResult.statusCode);\n\n                        } else {\n                            // Error code received\n                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                            throw new XFormsSubmissionException(\"xforms:submission for submission id: \" + id + \", error code received when submitting instance: \" + connectionResult.statusCode, \"processing submission response\");\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (connectionResult != null) {\n                        connectionResult.close();\n                    }\n                    // Log time spent in submission if needed\n                    if (XFormsServer.logger.isDebugEnabled()) {\n                        final long submissionTime = System.currentTimeMillis() - externalSubmissionStartTime;\n                        containingDocument.logDebug(\"submission\", \"external submission time including handling returned body\",\n                            new String[] { \"time\", Long.toString(submissionTime) });\n                    }\n                }\n            } catch (Throwable e) {\n                if (isDeferredSubmissionSecondPassReplaceAll && XFormsProperties.isOptimizeLocalSubmissionForward(containingDocument)) {\n                    // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                    throw new XFormsSubmissionException(e, \"Error while processing xforms:submission\", \"processing submission\");\n                } else {\n                    // Any exception will cause an error event to be dispatched\n                    if (submitErrorEvent == null)\n                        submitErrorEvent = new XFormsSubmitErrorEvent(XFormsModelSubmission.this, resolvedActionOrResource,\n                                (e instanceof XFormsSubmissionException)\n                                        ? ((XFormsSubmissionException) e).getErrorType()\n                                        : XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR, 0);\n                    \n                    submitErrorEvent.setThrowable(e);\n                    container.dispatchEvent(pipelineContext, submitErrorEvent);\n                }\n            } finally {\n                // If submission succeeded, dispatch success event\n                if (submitDoneEvent != null && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    container.dispatchEvent(pipelineContext, submitDoneEvent);\n                }\n                // Log total time spent in submission if needed\n                if (XFormsServer.logger.isDebugEnabled()) {\n                    final long submissionTime = System.currentTimeMillis() - submissionStartTime;\n                    containingDocument.logDebug(\"submission\", \"total submission time\",\n                        new String[] { \"time\", Long.toString(submissionTime) });\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_BINDING_EXCEPTION.equals(eventName)) {\n            // The default action for this event results in the following: Fatal error.\n            throw new ValidationException(\"Binding exception for target: \" + event.getTargetObject().getEffectiveId(), event.getTargetObject().getLocationData());\n        }\n    }","id":38443,"modified_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            containingDocument.setGotSubmission();\n\n            // Variables declared here as they are used in a catch/finally block\n            boolean isDeferredSubmissionSecondPassReplaceAll = false;\n            XFormsSubmitErrorEvent submitErrorEvent = null;\n            XFormsSubmitDoneEvent submitDoneEvent = null;\n            final long submissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n\n            // Make sure submission element info is extracted\n            extractSubmissionElement();\n\n            // XPath function library and namespace mappings\n            final FunctionLibrary functionLibrary = XFormsContainingDocument.getFunctionLibrary();\n            final Map prefixToURIMap = container.getNamespaceMappings(submissionElement);\n\n            try {\n                final boolean isReplaceAll = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n                final boolean isReplaceInstance = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE);\n                final boolean isReplaceText = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_TEXT);\n                final boolean isReplaceNone = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE);\n\n                // Get current node for xforms:submission and instance containing the node to submit\n                final NodeInfo refNodeInfo;\n                final XFormsInstance refInstance;\n                // Get and reset context stack\n                final XFormsContextStack contextStack = model.getContextStack();\n                contextStack.resetBindingContext(pipelineContext);\n                final Item submissionElementContextItem;\n\n                final XFormsFunction.Context functionContext;\n                {\n                    contextStack.setBinding(pipelineContext, XFormsModelSubmission.this);\n\n                    refNodeInfo = contextStack.getCurrentSingleNode();\n                    functionContext = contextStack.getFunctionContext();\n                    submissionElementContextItem = contextStack.getContextItem();\n\n                    // Check that we have a current node and that it is pointing to a document or an element\n                    if (refNodeInfo == null)\n                        throw new XFormsSubmissionException(\"Empty single-node binding on xforms:submission for submission id: \" + id, \"getting submission single-node binding\",\n                        \t\t XFormsSubmitErrorEvent.ErrorType.NO_DATA);\n\n                    if (!(refNodeInfo instanceof DocumentInfo || refNodeInfo.getNodeKind() == org.w3c.dom.Document.ELEMENT_NODE)) {\n                        throw new XFormsSubmissionException(\"xforms:submission: single-node binding must refer to a document node or an element.\", \"getting submission single-node binding\",\n                        \t\tXFormsSubmitErrorEvent.ErrorType.NO_DATA);\n                    }\n\n                    // Current instance may be null if the document submitted is not part of an instance\n                    refInstance = contextStack.getCurrentInstance();\n                }\n\n                // Determine if the instance to submit has one or more bound and relevant upload controls\n                //\n                // o we don't check if we are currently initializing the document because at that point the\n                //   client cannot have any files to upload yet\n                //\n                // o we don't check if we have already processed the second pass of a submission during this\n                //   request, because it means that upload controls have been already committed\n                //\n                // o we don't check if we are requested not to with an attribute\n                //\n                // o we only check for replace=\"instance|none\" and if serialization must take place\n\n                final boolean hasBoundRelevantUploadControl;\n                if (refInstance!= null && !containingDocument.isInitializing() && !containingDocument.isGotSubmissionSecondPass() && xxfFormsEnsureUploads && !isReplaceAll && serialize) {\n                    hasBoundRelevantUploadControl = XFormsUtils.hasBoundRelevantUploadControls(containingDocument, refInstance);\n                } else {\n                    hasBoundRelevantUploadControl = false;\n                }\n\n                // Evaluate early AVTs\n                final String resolvedMethod;\n                final String actualHttpMethod;\n                final String resolvedMediatype;\n\n                final boolean resolvedValidate;\n                final boolean resolvedRelevant;\n                {\n                    // Resolved method AVT\n                    final String resolvedMethodQName = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMethod);\n                    resolvedMethod = Dom4jUtils.qNameToExplodedQName(Dom4jUtils.extractTextValueQName(prefixToURIMap, resolvedMethodQName, true));\n\n                    // Get actual method based on the method attribute\n                    actualHttpMethod = getActualHttpMethod(resolvedMethod);\n\n                    // Get mediatype\n                    resolvedMediatype = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMediatype);\n\n                    // Resolve validate and relevant AVTs\n                    final String resolvedValidateString = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtValidate);\n                    resolvedValidate = !\"false\".equals(resolvedValidateString);\n\n                    final String resolvedRelevantString = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtRelevant);\n                    resolvedRelevant = !\"false\".equals(resolvedRelevantString);\n                }\n\n                final boolean isHandlingOptimizedGet = XFormsProperties.isOptimizeGetAllSubmission(containingDocument) && actualHttpMethod.equals(\"GET\")\n                        && isReplaceAll\n                        && (resolvedMediatype == null || !resolvedMediatype.startsWith(NetUtils.APPLICATION_SOAP_XML)) // can't let SOAP requests be handled by the browser\n                        && avtXXFormsUsername == null // can't optimize if there are authentication credentials\n                        && avtXXFormsTarget == null;  // can't optimize if there is a target\n\n                // In noscript mode, or in \"Ajax portlet\" mode, there is no deferred submission process\n                final boolean isNoscript = XFormsProperties.isNoscript(containingDocument);\n                final boolean isAllowDeferredSubmission = !isNoscript && !XFormsProperties.isAjaxPortlet(containingDocument);\n\n                final boolean isPossibleDeferredSubmission = (isReplaceAll && !isHandlingOptimizedGet) || (!isReplaceAll && serialize && hasBoundRelevantUploadControl);\n                final boolean isDeferredSubmission = isAllowDeferredSubmission && isPossibleDeferredSubmission;\n                final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n                final boolean isDeferredSubmissionSecondPass = isDeferredSubmission && !isDeferredSubmissionFirstPass; // here we get XXFORMS_SUBMIT\n                isDeferredSubmissionSecondPassReplaceAll = isDeferredSubmissionSecondPass && isReplaceAll;\n\n                if (isDeferredSubmissionSecondPass)\n                    containingDocument.setGotSubmissionSecondPass();\n\n                // If a submission requiring a second pass was already set, then we ignore a subsequent submission but\n                // issue a warning\n                {\n                    final XFormsModelSubmission existingSubmission = containingDocument.getClientActiveSubmission();\n                    if (isDeferredSubmission && existingSubmission != null) {\n                        logger.warn(\"XForms - submission - another submission requiring a second pass already exists (\" + existingSubmission.getEffectiveId() + \"). Ignoring new submission (\" + this.getEffectiveId() + \").\");\n                        return;\n                    }\n                }\n\n                // \"The data model is updated\"\n                final XFormsModel modelForInstance;\n                if (refInstance != null) {\n                    modelForInstance = refInstance.getModel(containingDocument);\n                    {\n                        // NOTE: XForms 1.1 seems to say this should happen regardless of whether we serialize or not. If\n                        // the instance is not serialized and if no instance data is otherwise used for the submission,\n                        // this seems however unneeded.\n\n                        // TODO: XForms 1.1 says that we should rebuild/recalculate the \"model containing this submission\".\n                        modelForInstance.rebuildRecalculateIfNeeded(pipelineContext);\n                    }\n                } else {\n                    // Case where no instance was found\n                    modelForInstance = null;\n                }\n\n                // Resolve the target AVT because XFormsServer requires it for deferred submission\n                resolvedXXFormsTarget = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsTarget);\n\n                // Deferred submission: end of the first pass\n                if (isDeferredSubmissionFirstPass) {\n\n                    // Create document to submit here because in case of error, an Ajax response will still be produced\n                    if (serialize) {\n                        createDocumentToSubmit(pipelineContext, refNodeInfo, refInstance, modelForInstance, resolvedValidate, resolvedRelevant);\n                    }\n\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setClientActiveSubmission(this);\n                    return;\n                }\n\n                /* ************************************* Submission second pass ************************************* */\n\n                // Evaluate late AVTs\n                final String resolvedSerialization;\n                final String resolvedMode;\n                final String resolvedVersion;\n                final String resolvedEncoding;\n                final String resolvedSeparator;\n                final boolean resolvedIndent;\n                final boolean resolvedOmitxmldeclaration;\n                final Boolean resolvedStandalone;\n                final String resolvedXXFormsUsername;\n                final String resolvedXXFormsPassword;\n                final String resolvedXXFormsReadonly;\n                final String resolvedXXFormsShared;\n                final boolean resolvedXXFormsHandleXInclude;\n                {\n                    final String tempActionOrResource = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtActionOrResource);\n\n                    if (tempActionOrResource == null) {\n                        // This can be null if, e.g. you have an AVT like resource=\"{()}\"\n                        throw new XFormsSubmissionException(\"xforms:submission: mandatory resource or action evaluated to an empty sequence for attribute value: \" + avtActionOrResource,\n                                \"resolving resource URI\");\n                    }\n\n                    resolvedActionOrResource = XFormsUtils.encodeHRRI(tempActionOrResource, true);\n\n                    resolvedSerialization = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtSerialization);\n                    resolvedMode = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMode);\n                    resolvedVersion = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtVersion);\n                    resolvedEncoding = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtEncoding);\n                    resolvedSeparator = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtSeparator);\n\n                    final String tempIndent = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtIndent);\n                    resolvedIndent = Boolean.valueOf(tempIndent).booleanValue();\n\n                    final String tempAvtOmitxmldeclaration = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtOmitxmldeclaration);\n                    resolvedOmitxmldeclaration = Boolean.valueOf(tempAvtOmitxmldeclaration).booleanValue();\n\n                    final String tempStandalone = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtStandalone);\n                    resolvedStandalone = (tempStandalone != null) ? Boolean.valueOf(tempStandalone) : null;\n\n                    resolvedXXFormsUsername = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsUsername);\n                    resolvedXXFormsPassword = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsPassword);\n                    resolvedXXFormsReadonly = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsReadonly);\n                    resolvedXXFormsShared = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsShared);\n\n                    // Default is \"false\" for security reasons\n                    final String tempHandleXInclude = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, refNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsHandleXInclude);\n                    resolvedXXFormsHandleXInclude = Boolean.valueOf(tempHandleXInclude).booleanValue();\n                }\n\n                // Check read-only and shared hints\n                XFormsInstance.checkSharedHints(submissionElement, resolvedXXFormsReadonly, resolvedXXFormsShared);\n                final boolean isReadonlyHint = \"true\".equals(resolvedXXFormsReadonly);\n                final boolean isApplicationSharedHint = \"application\".equals(resolvedXXFormsShared);\n                final long timeToLive = XFormsInstance.getTimeToLive(submissionElement);\n                // TODO: move this to XFormsInstance.checkSharedHints(), and check how to deal w/ use of XFormsInstance.checkSharedHints() by XFormsInstance\n                if (isApplicationSharedHint) {\n                    if (!actualHttpMethod.equals(\"GET\"))\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with method=\\\"get\\\".\",\n                                \"checking read-only and shared hints\");\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                } else if (isReadonlyHint) {\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:readonly=\\\"true\\\" can be \\\"true\\\" only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                }\n\n                /* ************************************* Serialization ************************************* */\n\n                // Get serialization requested from @method and @serialization attributes\n                final String requestedSerialization = getRequestedSerialization(resolvedSerialization, resolvedMethod);\n\n                final Document documentToSubmit;\n                if (serialize) {\n                    // Handle uploaded files if any\n                    final Element filesElement = (event instanceof XXFormsSubmitEvent) ? ((XXFormsSubmitEvent) event).getFilesElement() : null;\n                    if (filesElement != null) {\n                        // Handle all file elements\n                        XFormsUploadControl.handleFileElement(pipelineContext, containingDocument, filesElement, null, !isReplaceAll);\n                    }\n\n                    // Check if a submission requires file upload information\n                    if (requestedSerialization.startsWith(\"multipart/\")) {\n                        // Annotate before re-rooting/pruning\n                        XFormsUtils.annotateBoundRelevantUploadControls(pipelineContext, containingDocument, refInstance);\n                    }\n\n                    // Create document to submit\n                    documentToSubmit = createDocumentToSubmit(pipelineContext, refNodeInfo, refInstance, modelForInstance, resolvedValidate, resolvedRelevant);\n\n                } else {\n                    // Don't recreate document\n                    documentToSubmit = null;\n                }\n\n                final String overriddenSerializedData;\n                if (serialize && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    // Fire xforms-submit-serialize\n\n                    // \"The event xforms-submit-serialize is dispatched. If the submission-body property of the event\n                    // is changed from the initial value of empty string, then the content of the submission-body\n                    // property string is used as the submission serialization. Otherwise, the submission serialization\n                    // consists of a serialization of the selected instance data according to the rules stated at 11.9\n                    // Submission Options.\"\n\n                    final XFormsSubmitSerializeEvent serializeEvent = new XFormsSubmitSerializeEvent(XFormsModelSubmission.this, refNodeInfo, requestedSerialization);\n                    container.dispatchEvent(pipelineContext, serializeEvent);\n\n                    // TODO: rest of submission should happen upon default action of event\n\n                    overriddenSerializedData = serializeEvent.getSerializedData();\n                } else {\n                    overriddenSerializedData = null;\n                }\n\n                // Serialize\n                final byte[] messageBody;// TODO: provide option for body to be a stream\n                final String queryString;\n                final String defaultMediatypeForSerialization;\n                if (serialize) {\n\n                    if (overriddenSerializedData != null && !overriddenSerializedData.equals(\"\")) {\n                        // Form author set data to serialize\n                        if (actualHttpMethod.equals(\"POST\") || actualHttpMethod.equals(\"PUT\")) {\n                            queryString = null;\n                            messageBody = overriddenSerializedData.getBytes(\"UTF-8\");\n                            defaultMediatypeForSerialization = \"application/xml\";\n                        } else {\n                            queryString = URLEncoder.encode(overriddenSerializedData, \"UTF-8\");\n                            messageBody = null;\n                            defaultMediatypeForSerialization = null;\n                        }\n                    } else if (requestedSerialization.equals(\"application/x-www-form-urlencoded\")) {\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        if (actualHttpMethod.equals(\"POST\") || actualHttpMethod.equals(\"PUT\")) {\n                            queryString = null;\n                            messageBody = XFormsSubmissionUtils.createWwwFormUrlEncoded(documentToSubmit, resolvedSeparator).getBytes(\"UTF-8\");// the resulting string is already ASCII in fact\n                            defaultMediatypeForSerialization = \"application/x-www-form-urlencoded\";\n                        } else {\n                            queryString = XFormsSubmissionUtils.createWwwFormUrlEncoded(documentToSubmit, resolvedSeparator);\n                            messageBody = null;\n                            defaultMediatypeForSerialization = null;\n                        }\n                    } else if (requestedSerialization.equals(\"application/xml\")) {\n                        // Serialize XML to a stream of bytes\n                        try {\n                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                            TransformerUtils.applyOutputProperties(identity,\n                                    \"xml\", resolvedVersion, null, null, resolvedEncoding, resolvedOmitxmldeclaration, resolvedStandalone, resolvedIndent, 4);\n\n                            // TODO: use cdata-section-elements\n\n                            final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                            identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                            messageBody = os.toByteArray();\n                        } catch (Exception e) {\n                            throw new XFormsSubmissionException(e, \"xforms:submission: exception while serializing instance to XML.\", \"serializing instance\");\n                        }\n                        defaultMediatypeForSerialization = \"application/xml\";\n                        queryString = null;\n                    } else if (requestedSerialization.equals(\"multipart/related\")) {\n                        // TODO\n                        throw new XFormsSubmissionException(\"xforms:submission: submission serialization not yet implemented: \" + requestedSerialization, \"serializing instance\");\n                    } else if (requestedSerialization.equals(\"multipart/form-data\")) {\n                        // Build multipart/form-data body\n\n                        // Create and set body\n                        final MultipartRequestEntity multipartFormData = XFormsSubmissionUtils.createMultipartFormData(pipelineContext, documentToSubmit);\n\n                        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        multipartFormData.writeRequest(os);\n\n                        messageBody = os.toByteArray();\n                        queryString = null;\n\n                        // The mediatype also contains the boundary\n                        defaultMediatypeForSerialization = multipartFormData.getContentType();\n\n                    } else if (requestedSerialization.equals(\"application/octet-stream\")) {\n                        // Binary serialization\n                        final String nodeType = InstanceData.getType(documentToSubmit.getRootElement());\n\n                        if (XMLConstants.XS_ANYURI_EXPLODED_QNAME.equals(nodeType)) {\n                            // Interpret node as anyURI\n                            // TODO: PERFORMANCE: Must pass InputStream all the way to the submission instead of storing into byte[] in memory!\n                            final String uri = documentToSubmit.getRootElement().getStringValue();\n                            messageBody = NetUtils.uriToByteArray(uri);\n                        } else if (XMLConstants.XS_BASE64BINARY_EXPLODED_QNAME.equals(nodeType)) {\n                            // TODO\n                            throw new XFormsSubmissionException(\"xforms:submission: binary serialization with base64Binary type is not yet implemented.\", \"serializing instance\");\n                        } else {\n                            // TODO\n                            throw new XFormsSubmissionException(\"xforms:submission: binary serialization without a type is not yet implemented.\", \"serializing instance\");\n                        }\n                        defaultMediatypeForSerialization = \"application/octet-stream\";\n                        queryString = null;\n                    } else if (XMLUtils.isTextContentType(requestedSerialization)) {\n                        // TODO: Text serialization\n                        throw new XFormsSubmissionException(\"xforms:submission: text serialization is not yet implemented.\", \"serializing instance\");\n                    } else {\n                        throw new XFormsSubmissionException(\"xforms:submission: invalid submission serialization requested: \" + requestedSerialization, \"serializing instance\");\n                    }\n                } else {\n                    queryString = null;\n                    messageBody = null;\n                    defaultMediatypeForSerialization = null;\n                }\n\n                /* ************************************* Execute submission ************************************* */\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                // Get URL type\n                final String urlType = submissionElement.attributeValue(XMLConstants.FORMATTING_URL_TYPE_QNAME);\n                final ExternalContext.Request request = externalContext.getRequest();\n\n                // Actual request mediatype\n                final String actualRequestMediatype = (resolvedMediatype == null) ? defaultMediatypeForSerialization : resolvedMediatype;\n\n                // Get async/sync\n                // NOTE: XForms 1.1 default to async, but we don't fully support async so we default to sync instead\n                final boolean isAsyncSubmission = isReplaceNone && \"asynchronous\".equals(resolvedMode);// for now we only support this with replace=\"none\"\n\n                // Evaluate headers if any\n                final Map /* LinkedHashMap<String headerName, String[] headerValues> */ customHeaderNameValues = evaluateHeaders(pipelineContext, contextStack);\n\n                // Result information\n                ConnectionResult connectionResult = null;\n                final long externalSubmissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n                try {\n                    if ((isReplaceInstance || isReplaceNone) && resolvedActionOrResource.startsWith(\"test:\")) {\n                        // Test action\n\n                        if (messageBody == null) {\n                            // Not sure when this can happen, but it can't be good\n                            throw new XFormsSubmissionException(\"Action 'test:': no message body.\", \"processing submission response\");\n                        } else {\n                            // Log message mody for debugging purposes\n                            if (XFormsServer.logger.isDebugEnabled())\n                                NetUtils.logRequestBody(containingDocument.getIndentedLogger(), actualRequestMediatype, messageBody);\n                        }\n\n                        // Do as if we are receiving a regular XML response\n                        connectionResult = new ConnectionResult(null);\n                        connectionResult.statusCode = 200;\n                        connectionResult.responseHeaders = new HashMap();\n                        connectionResult.setLastModified(null);\n                        connectionResult.setResponseContentType(\"application/xml\");// should we use actualRequestMediatype instead?\n                        connectionResult.dontHandleResponse = false;\n                        connectionResult.setResponseInputStream(new ByteArrayInputStream(messageBody));\n\n                    } else if (isHandlingOptimizedGet) {\n                        // GET with replace=\"all\": we can optimize and tell the client to just load the URL\n\n                        final String actionString = (queryString == null) ? resolvedActionOrResource : resolvedActionOrResource + ((resolvedActionOrResource.indexOf('?') == -1) ? \"?\" : \"\") + queryString;\n                        final String resultURL = XFormsLoadAction.resolveLoadValue(containingDocument, pipelineContext, submissionElement, true, actionString, null, null, fURLNorewrite, xxfShowProgress);\n                        connectionResult = new ConnectionResult(resultURL);\n                        connectionResult.dontHandleResponse = true;\n\n                    } else if (isAllowOptimizedSubmission(isReplaceAll, isNoscript, urlType, request, isAsyncSubmission)) {\n\n                        // This is an \"optimized\" submission, i.e. one that does not use an actual protocol handler to\n                        // access the resource, but instead uses servlet forward/include for servlets, or a local\n                        // mechanism for portlets.\n\n                        // NOTE: Optimizing with include() for servlets doesn't allow detecting errors caused by the\n                        // included resource. [As of 2009-02-13, not sure if this is the case.]\n\n                        // NOTE: For portlets, paths are served directly by the portlet, NOT as resources.\n\n                        // f:url-norewrite=\"true\" with an absolute path allows accessing other servlet contexts.\n\n                        // Current limitations:\n                        // o Portlets cannot access resources outside the portlet except by using absolute URLs (unless f:url-type=\"resource\")\n\n                        // URI with xml:base resolution\n                        final URI resolvedURI = XFormsUtils.resolveXMLBase(submissionElement, resolvedActionOrResource);\n\n                        // NOTE: We don't want any changes to happen to the document upon xxforms-submit when producing\n                        // a new document so we don't dispatch xforms-submit-done and pass a null XFormsModelSubmission\n                        // in that case\n\n                        if (XFormsServer.logger.isDebugEnabled())\n                            containingDocument.logDebug(\"submission\", \"starting optimized submission\", new String[] { \"id\", getEffectiveId() });\n\n                        // NOTE about headers forwarding: forward user-agent header for replace=\"all\", since that *usually*\n                        // simulates a request from the browser! Useful in particular when the target URL renders XForms\n                        // in noscript mode, where some browser sniffing takes place for handling the <button> vs. <submit>\n                        // element.\n                        final String[] headersToForward = isReplaceAll ? XFormsSubmissionUtils.STANDARD_HEADERS_TO_FORWARD : XFormsSubmissionUtils.MINIMAL_HEADERS_TO_FORWARD;\n                        // TODO: Harmonize with HTTP submission handling of headers\n\n                        connectionResult = XFormsSubmissionUtils.openOptimizedConnection(pipelineContext, externalContext, containingDocument,\n                                isDeferredSubmissionSecondPassReplaceAll ? null : this, actualHttpMethod, resolvedURI.toString(), fURLNorewrite, actualRequestMediatype,\n                                messageBody, queryString, isReplaceAll, headersToForward, customHeaderNameValues);\n\n                        // This means we got a submission with replace=\"all\"\n                        if (connectionResult.dontHandleResponse)\n                            containingDocument.setGotSubmissionReplaceAll();\n\n                    } else {\n                        // This is a regular remote submission going through a protocol handler\n\n                        // Absolute URLs or absolute paths are allowed to a local servlet\n                        String resolvedURL;\n\n                        if (NetUtils.urlHasProtocol(resolvedActionOrResource) || fURLNorewrite) {\n                            // Don't touch the URL if it is absolute or if f:url-norewrite=\"true\"\n                            resolvedURL = resolvedActionOrResource;\n                        } else {\n                            // Rewrite URL\n                            resolvedURL = XFormsUtils.resolveServiceURL(pipelineContext, submissionElement, resolvedActionOrResource,\n                                    ExternalContext.Response.REWRITE_MODE_ABSOLUTE_PATH_OR_RELATIVE);\n\n                            if (request.getContainerType().equals(\"portlet\") && \"resource\".equals(urlType) && !NetUtils.urlHasProtocol(resolvedURL)) {\n                                // In this case, we have to prepend the complete server path\n                                resolvedURL = request.getScheme() + \"://\" + request.getServerName() + (request.getServerPort() > 0 ? \":\" + request.getServerPort() : \"\") + resolvedURL;\n                            }\n                        }\n\n                        if (isApplicationSharedHint) {\n                            // Get the instance from shared instance cache\n                            // This can only happen is method=\"get\" and replace=\"instance\" and xxforms:readonly=\"true\" and xxforms:shared=\"application\"\n\n                            final NodeInfo destinationNodeInfo = evaluateTargetRef(pipelineContext, findReplaceInstanceNoTargetref(refInstance), submissionElementContextItem,\n                                                        prefixToURIMap, contextStack, functionLibrary, functionContext);\n\n                            if (destinationNodeInfo == null) {\n                                // Throw target-error\n\n                                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                                // then submission processing ends after dispatching the event\n                                // xforms-submit-error with an error-type of target-error.\"\n\n                                submitErrorEvent = createErrorEvent(pipelineContext, null, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element for replace=\\\"instance\\\".\", \"processing targetref attribute\");\n                            }\n\n                            final XFormsInstance updatedInstance = containingDocument.getInstanceForNode(destinationNodeInfo);\n                            if (updatedInstance == null || !updatedInstance.getInstanceRootElementInfo().isSameNodeInfo(destinationNodeInfo)) {\n                                // Only support replacing the root element of an instance when using a shared instance\n                                submitErrorEvent = createErrorEvent(pipelineContext, null, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                throw new XFormsSubmissionException(\"targetref attribute must point to an instance root element when using shared instance replacement.\", \"processing targetref attribute\");\n                            }\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"using instance from application shared instance cache\",\n                                        new String[] { \"instance\", updatedInstance.getEffectiveId() });\n\n                            final URL absoluteResolvedURL = NetUtils.createAbsoluteURL(resolvedURL, queryString, externalContext);\n                            final String absoluteResolvedURLString = absoluteResolvedURL.toExternalForm();\n\n                            final SharedXFormsInstance sharedInstance\n                                    = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, updatedInstance.getId(), updatedInstance.getEffectiveModelId(),\n                                        absoluteResolvedURLString, timeToLive, updatedInstance.getValidation(), resolvedXXFormsHandleXInclude);\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                        new String[] { \"instance\", sharedInstance.getEffectiveId() });\n\n                            final XFormsModel replaceModel = sharedInstance.getModel(containingDocument);\n\n                            // Dispatch xforms-delete event\n                            // NOTE: Do NOT dispatch so we are compatible with the regular root element replacement\n                            // (see below). In the future, we might want to dispatch this, especially if\n                            // XFormsInsertAction dispatches xforms-delete when removing the root element\n                            //updatedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(updatedInstance, Collections.singletonList(destinationNodeInfo), 1));\n\n                            // Handle new instance and associated event markings\n                            final NodeInfo newRootElementInfo = sharedInstance.getInstanceRootElementInfo();\n                            replaceModel.handleUpdatedInstance(pipelineContext, sharedInstance, newRootElementInfo);\n\n                            // Dispatch xforms-insert event\n                            // NOTE: use the root node as insert location as it seems to make more sense than pointing to the earlier root element\n                            sharedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext,\n                                new XFormsInsertEvent(sharedInstance, Collections.singletonList(newRootElementInfo), null, newRootElementInfo.getDocumentRoot(),\n                                        \"after\", null, null, true));\n\n                            connectionResult = null;\n                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, absoluteResolvedURLString, 200);\n                        } else {\n                            // Perform actual submission\n\n                            // Compute absolute submission URL\n                            final URL submissionURL = NetUtils.createAbsoluteURL(resolvedURL, queryString, externalContext);\n\n                            // Gather remaining information to process the request\n                            final String forwardSubmissionHeaders = XFormsProperties.getForwardSubmissionHeaders(containingDocument);\n\n                            // NOTE about headers forwarding: forward user-agent header for replace=\"all\", since that *usually*\n                            // simulates a request from the browser! Useful in particular when the target URL renders XForms\n                            // in noscript mode, where some browser sniffing takes place for handling the <button> vs. <submit>\n                            // element.\n                            final String newForwardSubmissionHeaders = isReplaceAll ? forwardSubmissionHeaders + \" user-agent\" : forwardSubmissionHeaders;\n\n                            // Open connection\n                            if (isAsyncSubmission) {\n                                final IndentedLogger indentedLogger = new IndentedLogger(XFormsServer.logger, \"XForms (async)\");\n                                final Map headersMap = NetUtils.getHeadersMap(externalContext, indentedLogger,\n                                            resolvedXXFormsUsername, customHeaderNameValues, newForwardSubmissionHeaders);\n\n                                // Pack call into a Runnable\n                                final Runnable runnable = new Runnable() {\n\n                                    public void run() {\n\n                                        // Here we just want to run the submission and not touch the HttpRequest or\n                                        // XFCD. Remember, we can't change XFCD because it may get out of the caches\n                                        // and not be picked up by further incoming Ajax requests.\n                                        NetUtils.openConnection(indentedLogger,\n                                            actualHttpMethod, submissionURL, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                            actualRequestMediatype, messageBody, headersMap);\n\n                                        // NOTE: In this very basic level of support, we don't support xforms-submit-done / xforms-submit-error handlers\n\n                                        // TODO: Do something with result, e.g. log?\n                                        // final ConnectionResult connectionResult = ...\n                                    }\n                                };\n\n                                // Tell XFCD that we have one more Runnable\n                                containingDocument.addAsynchronousSubmission(runnable);\n                                connectionResult = null;\n\n                            } else {\n                                // Just run it now\n                                connectionResult = NetUtils.openConnection(externalContext, containingDocument.getIndentedLogger(),\n                                        actualHttpMethod, submissionURL, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                        actualRequestMediatype, messageBody,\n                                        customHeaderNameValues, newForwardSubmissionHeaders);\n                            }\n                        }\n                    }\n\n                    /* ************************************* Submission response ************************************* */\n\n                    if (connectionResult != null && !connectionResult.dontHandleResponse) {\n                        // Handle response\n                        if (connectionResult.statusCode >= 200 && connectionResult.statusCode < 300) {// accept any success code (in particular \"201 Resource Created\")\n                            // Sucessful response\n                            if (connectionResult.hasContent()) {\n                                // There is a body\n\n                                if (isReplaceAll) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    if (!isDeferredSubmissionSecondPassReplaceAll) // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                                        container.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult));\n\n                                    // Remember that we got a submission producing output\n                                    containingDocument.setGotSubmissionReplaceAll();\n\n                                    // Get response from containing document\n                                    final ExternalContext.Response response = containingDocument.getResponse();\n\n                                    // Set content-type\n                                    response.setContentType(connectionResult.getResponseContentType());\n\n                                    // Forward headers to response\n                                    connectionResult.forwardHeaders(response);\n\n                                    // Forward content to response\n                                    final OutputStream outputStream = response.getOutputStream();\n                                    NetUtils.copyStream(connectionResult.getResponseInputStream(), outputStream);\n\n                                    // End document and close\n                                    outputStream.flush();\n                                    outputStream.close();\n\n                                    // TODO: [#306918] RFE: Must be able to do replace=\"all\" during initialization.\n                                    // http://forge.objectweb.org/tracker/index.php?func=detail&aid=306918&group_id=168&atid=350207\n                                    // Suggestion is to write either binary or XML to processor output ContentHandler,\n                                    // and make sure the code which would output the XHTML+XForms is disabled.\n\n                                } else if (isReplaceInstance) {\n\n                                    if (XMLUtils.isXMLMediatype(connectionResult.getResponseMediaType())) {\n                                        // Handling of XML media type\n                                        // Set new instance document to replace the one submitted\n\n                                        final XFormsInstance replaceInstanceNoTargetref = findReplaceInstanceNoTargetref(refInstance);\n                                        if (replaceInstanceNoTargetref == null) {\n\n                                            // Replacement instance or node was specified but not found\n                                            //\n                                            // Not sure what's the right thing to do with 1.1, but this could be done\n                                            // as part of the model's static analysis if the instance value is not\n                                            // obtained through AVT, and dynamically otherwise. However, in the dynamic\n                                            // case, I think that this should be a (currently non-specified by XForms)\n                                            // xforms-binding-error.\n                                            container.dispatchEvent(pipelineContext, new XFormsBindingExceptionEvent(XFormsModelSubmission.this));\n                                        } else {\n\n                                            final NodeInfo destinationNodeInfo = evaluateTargetRef(pipelineContext,\n                                                    replaceInstanceNoTargetref, submissionElementContextItem,\n                                                    prefixToURIMap, contextStack, functionLibrary, functionContext);\n\n                                            if (destinationNodeInfo == null) {\n                                                // Throw target-error\n\n                                                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                                                // then submission processing ends after dispatching the event\n                                                // xforms-submit-error with an error-type of target-error.\"\n\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element for replace=\\\"instance\\\".\", \"processing targetref attribute\");\n                                            }\n\n                                            // This is the instance which is effectively going to be updated\n                                            final XFormsInstance updatedInstance = containingDocument.getInstanceForNode(destinationNodeInfo);\n                                            if (updatedInstance == null) {\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element in an existing instance for replace=\\\"instance\\\".\", \"processing targetref attribute\");\n                                            }\n\n                                            // Whether the destination node is the root element of an instance\n                                            final boolean isDestinationRootElement = updatedInstance.getInstanceRootElementInfo().isSameNodeInfo(destinationNodeInfo);\n                                            if (isReadonlyHint && !isDestinationRootElement) {\n                                                // Only support replacing the root element of an instance when using a shared instance\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"targetref attribute must point to instance root element when using read-only instance replacement.\", \"processing targetref attribute\");\n                                            }\n\n                                            // Obtain root element to insert\n                                            final NodeInfo newDocumentRootElement;\n                                            final XFormsInstance newInstance;\n                                            try {\n                                                // Create resulting instance whether entire instance is replaced or not, because this:\n                                                // 1. Wraps a Document within a DocumentInfo if needed\n                                                // 2. Performs text nodes adjustments if needed\n                                                if (!isReadonlyHint) {\n                                                    // Resulting instance must not be read-only\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    final Document resultingInstanceDocument\n                                                            = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with mutable instance\",\n                                                            new String[] { \"instance\", updatedInstance.getEffectiveId() });\n\n                                                    newInstance = new XFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                                                            resultingInstanceDocument, connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                                            false, -1, updatedInstance.getValidation(), resolvedXXFormsHandleXInclude);\n                                                } else {\n                                                    // Resulting instance must be read-only\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    // NOTE: isApplicationSharedHint is always false when get get here. isApplicationSharedHint=\"true\" is handled above.\n                                                    final DocumentInfo resultingInstanceDocument\n                                                            = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                                            new String[] { \"instance\", updatedInstance.getEffectiveId() });\n\n                                                    newInstance = new SharedXFormsInstance(updatedInstance.getEffectiveModelId(), updatedInstance.getId(),\n                                                            resultingInstanceDocument, connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword,\n                                                            false, -1, updatedInstance.getValidation(), resolvedXXFormsHandleXInclude);\n                                                }\n                                                newDocumentRootElement = newInstance.getInstanceRootElementInfo();\n                                            } catch (Exception e) {\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.PARSE_ERROR);\n                                                throw new XFormsSubmissionException(e, \"xforms:submission: exception while reading XML response.\", \"processing instance replacement\");\n                                            }\n\n                                            // Perform insert/delete. This will dispatch xforms-insert/xforms-delete events.\n                                            // \"the replacement is performed by an XForms action that performs some\n                                            // combination of node insertion and deletion operations that are\n                                            // performed by the insert action (10.3 The insert Element) and the\n                                            // delete action\"\n\n                                            if (isDestinationRootElement) {\n                                                // Optimized insertion for instance root element replacement\n\n                                                // Handle new instance and associated event markings\n                                                final XFormsModel replaceModel = newInstance.getModel(containingDocument);\n                                                replaceModel.handleUpdatedInstance(pipelineContext, newInstance, newDocumentRootElement);\n                                                \n                                                // Dispatch xforms-delete event\n                                                // NOTE: Do NOT dispatch so we are compatible with the regular root element replacement\n                                                // (see below). In the future, we might want to dispatch this, especially if\n                                                // XFormsInsertAction dispatches xforms-delete when removing the root element\n                                                //updatedInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(updatedInstance, Collections.singletonList(destinationNodeInfo), 1));\n\n                                                // Dispatch xforms-insert event\n                                                // NOTE: use the root node as insert location as it seems to make more sense than pointing to the earlier root element\n                                                newInstance.getXBLContainer(containingDocument).dispatchEvent(pipelineContext,\n                                                    new XFormsInsertEvent(newInstance, Collections.singletonList(newDocumentRootElement), null, newDocumentRootElement.getDocumentRoot(),\n                                                            \"after\", null, null, true));\n\n                                            } else {\n                                                // Generic insertion\n\n                                                final List destinationCollection = Collections.singletonList(destinationNodeInfo);\n\n                                                // Perform the insertion\n\n                                                // Insert before the target node, so that the position of the inserted node\n                                                // wrt its parent does not change after the target node is removed\n                                                final List insertedNode = XFormsInsertAction.doInsert(pipelineContext, containingDocument, \"before\",\n                                                        destinationCollection, destinationNodeInfo.getParent(),\n                                                        Collections.singletonList(newDocumentRootElement), 1, false, true);\n\n                                                if (!destinationNodeInfo.getParent().isSameNodeInfo(destinationNodeInfo.getDocumentRoot())) {\n                                                    // The node to replace is NOT a root element\n\n                                                    // Perform the deletion of the selected node\n                                                    XFormsDeleteAction.doDelete(pipelineContext, containingDocument, destinationCollection, 1, true);\n                                                }\n\n                                                // Perform model instance update\n                                                // Handle new instance and associated event markings\n                                                // NOTE: The inserted node NodeWrapper.index might be out of date at this point because:\n                                                // * doInsert() dispatches an event which might itself change the instance\n                                                // * doDelete() does as well\n                                                // Does this mean that we should check that the node is still where it should be?\n                                                final XFormsModel updatedModel = updatedInstance.getModel(containingDocument);\n                                                updatedModel.handleUpdatedInstance(pipelineContext, updatedInstance, (NodeInfo) insertedNode.get(0));\n                                            }\n\n                                            // Notify that submission is done\n                                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + connectionResult.getResponseMediaType(), \"processing instance replacement\");\n                                    }\n                                } else if (isReplaceText) {\n\n                                    // XForms 1.1: \"If the replace attribute contains the value \"text\" and the\n                                    // submission response conforms to an XML mediatype (as defined by the content type\n                                    // specifiers in [RFC 3023]) or a text media type (as defined by a content type\n                                    // specifier of text/*), then the response data is encoded as text and replaces the\n                                    // content of the replacement target node.\"\n\n                                    // Get response body\n                                    String responseBody = \"\";\n                                    if (XMLUtils.isTextContentType(connectionResult.getResponseMediaType())) {\n                                        // Text mediatype (including text/xml), read stream into String\n                                        try {\n                                            final String charset = NetUtils.getTextCharsetFromContentType(connectionResult.getResponseContentType());\n                                            final Reader reader = new InputStreamReader(connectionResult.getResponseInputStream(), charset);\n                                            try {\n                                                responseBody = NetUtils.readStreamAsString(reader);\n                                            } finally {\n                                                try {\n                                                    reader.close();\n                                                } catch (Exception e) {\n                                                }\n                                            }\n                                        } catch (Exception e) {\n                                            XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                                        }\n                                    } else if (XMLUtils.isXMLMediatype(connectionResult.getResponseMediaType())) {\n                                        // XML mediatype other than text/xml\n\n                                        // TODO: What should we do if the response Content-Type includes a charset parameter?\n                                        final Reader reader = XMLUtils.getReaderFromXMLInputStream(connectionResult.resourceURI, connectionResult.getResponseInputStream());\n                                        try {\n                                            responseBody = NetUtils.readStreamAsString(reader);\n                                        } finally {\n                                            try {\n                                                reader.close();\n                                            } catch (Exception e) {\n                                            }\n                                        }\n                                    } else {\n                                        // This is a binary result\n\n                                        // Don't store anything for now as per the spec, but we could do something better by going beyond the spec\n                                        // NetUtils.inputStreamToAnyURI(pipelineContext, connectionResult.resultInputStream, NetUtils.SESSION_SCOPE);\n\n                                        // XForms 1.1: \"For a success response including a body that is both a non-XML\n                                        // media type (i.e. with a content type not matching any of the specifiers in\n                                        // [RFC 3023]) and a non-text type (i.e. with a content type not matching\n                                        // text/*), when the value of the replace attribute on element submission is\n                                        // \"text\", nothing in the document is replaced and submission processing\n                                        // concludes after dispatching xforms-submit-error with appropriate context\n                                        // information, including an error-type of resource-error.\"\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Mediatype is neither text nor XML for replace=\\\"text\\\": \" + connectionResult.getResponseMediaType(), \"reading response body\");\n                                    }\n\n                                    // Find target location\n                                    final NodeInfo destinationNodeInfo;\n                                    if (targetref != null) {\n                                        // Evaluate destination node\n                                        final Object destinationObject\n                                                = XPathCache.evaluateSingle(pipelineContext, refNodeInfo, targetref, prefixToURIMap,\n                                                contextStack.getCurrentVariables(), functionLibrary, functionContext, null, getLocationData());\n\n                                        if (destinationObject instanceof NodeInfo) {\n                                            destinationNodeInfo = (NodeInfo) destinationObject;\n                                            if (destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ATTRIBUTE_NODE) {\n                                                // Throw target-error\n\n                                                // XForms 1.1: \"If the processing of the targetref attribute fails,\n                                                // then submission processing ends after dispatching the event\n                                                // xforms-submit-error with an error-type of target-error.\"\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"targetref attribute doesn't point to an element or attribute for replace=\\\"text\\\".\", \"processing targetref attribute\");\n                                            }\n                                        } else {\n                                            // Throw target-error\n                                            // TODO: also do this for readonly situation\n\n                                            // XForms 1.1: \"If the processing of the targetref attribute fails, then\n                                            // submission processing ends after dispatching the event\n                                            // xforms-submit-error with an error-type of target-error.\"\n                                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                            throw new XFormsSubmissionException(\"targetref attribute doesn't point to a node for replace=\\\"text\\\".\", \"processing targetref attribute\");\n                                        }\n                                    } else {\n                                        // Handle default destination\n                                        destinationNodeInfo = findReplaceInstanceNoTargetref(refInstance).getInstanceRootElementInfo();\n                                    }\n\n                                    // Set value into the instance\n                                    XFormsSetvalueAction.doSetValue(pipelineContext, containingDocument, this, destinationNodeInfo, responseBody, null, false);\n\n                                    // Notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n\n                                } else if (isReplaceNone) {\n                                    // Just notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                } else {\n                                    submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR);\n                                    throw new XFormsSubmissionException(\"xforms:submission: invalid replace attribute: \" + replace, \"processing instance replacement\");\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n\n                                if (isReplaceInstance) {\n                                    // XForms 1.1 says it is fine not to have a body, but in most cases you will want\n                                    // to know that no instance replacement took place\n                                    XFormsServer.logger.warn(\"XForms - submission - instance replacement did not take place upon successful response because no body was provided. Submission: \"\n                                            + getEffectiveId());\n                                }\n\n                                submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                            }\n                        } else if (connectionResult.statusCode == 302 || connectionResult.statusCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            connectionResult.forwardHeaders(response);\n\n                            // Forward redirect\n                            response.setStatus(connectionResult.statusCode);\n\n                        } else {\n                            // Error code received\n                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                            throw new XFormsSubmissionException(\"xforms:submission for submission id: \" + id + \", error code received when submitting instance: \" + connectionResult.statusCode, \"processing submission response\");\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (connectionResult != null) {\n                        connectionResult.close();\n                    }\n                    // Log time spent in submission if needed\n                    if (XFormsServer.logger.isDebugEnabled()) {\n                        final long submissionTime = System.currentTimeMillis() - externalSubmissionStartTime;\n                        containingDocument.logDebug(\"submission\", \"external submission time including handling returned body\",\n                            new String[] { \"time\", Long.toString(submissionTime) });\n                    }\n                }\n            } catch (Throwable e) {\n                if (isDeferredSubmissionSecondPassReplaceAll && XFormsProperties.isOptimizeLocalSubmissionForward(containingDocument)) {\n                    // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                    throw new XFormsSubmissionException(e, \"Error while processing xforms:submission\", \"processing submission\");\n                } else {\n                    // Any exception will cause an error event to be dispatched\n                    if (submitErrorEvent == null)\n                        submitErrorEvent = new XFormsSubmitErrorEvent(XFormsModelSubmission.this, resolvedActionOrResource,\n                                (e instanceof XFormsSubmissionException)\n                                        ? ((XFormsSubmissionException) e).getErrorType()\n                                        : XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR, 0);\n                    \n                    submitErrorEvent.setThrowable(e);\n                    container.dispatchEvent(pipelineContext, submitErrorEvent);\n                }\n            } finally {\n                // If submission succeeded, dispatch success event\n                if (submitDoneEvent != null && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    container.dispatchEvent(pipelineContext, submitDoneEvent);\n                }\n                // Log total time spent in submission if needed\n                if (XFormsServer.logger.isDebugEnabled()) {\n                    final long submissionTime = System.currentTimeMillis() - submissionStartTime;\n                    containingDocument.logDebug(\"submission\", \"total submission time\",\n                        new String[] { \"time\", Long.toString(submissionTime) });\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_BINDING_EXCEPTION.equals(eventName)) {\n            // The default action for this event results in the following: Fatal error.\n            throw new ValidationException(\"Binding exception for target: \" + event.getTargetObject().getEffectiveId(), event.getTargetObject().getLocationData());\n        }\n    }","commit_id":"068efa7298701bc69b6c05afb6046c93397db16f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public XFormsSubmitErrorEvent(PipelineContext pipelineContext, XFormsEventTarget targetObject, ErrorType errorType, ConnectionResult connectionResult) {\n        super(XFormsEvents.XFORMS_SUBMIT_ERROR, targetObject, connectionResult);\n        this.errorType = errorType;\n\n        // Try to add body information\n        if (connectionResult.hasContent()) {\n\n            // \"When the error response specifies an XML media type as defined by [RFC 3023], the response body is\n            // parsed into an XML document and the root element of the document is returned. If the parse fails, or if\n            // the error response specifies a text media type (starting with text/), then the response body is returned\n            // as a string. Otherwise, an empty string is returned.\"\n\n            // Read the whole stream to a temp URI so we can read it more than once if needed\n            final String tempURI;\n            try {\n                tempURI = NetUtils.inputStreamToAnyURI(pipelineContext, connectionResult.getResponseInputStream(), NetUtils.REQUEST_SCOPE);\n                connectionResult.getResponseInputStream().close();\n            } catch (Exception e) {\n                // Simply can't read the bocy\n                XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                return;\n            }\n\n            boolean isXMLParseFailed = false;\n            if (XMLUtils.isXMLMediatype(connectionResult.getResponseMediaType())) {\n                // XML content-type\n                // Read stream into Document\n                // TODO: In case of text/xml, charset is not handled. Should modify readTinyTree() and readDom4j()\n                InputStream is = null; \n                try {\n                    is = new URL(tempURI).openStream();\n                    final DocumentInfo responseBody = TransformerUtils.readTinyTree(is, connectionResult.resourceURI, false);\n                    setBodyDocument(responseBody);\n                    return;\n                } catch (Exception e) {\n                    XFormsServer.logger.error(\"XForms - submission - error while parsing response body as XML, defaulting to plain text.\", e);\n                    isXMLParseFailed = true;\n                } finally {\n                    try {\n                        is.close();\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (isXMLParseFailed || XMLUtils.isTextContentType(connectionResult.getResponseMediaType())) {\n                // XML parsing failed, or we got a text content-type\n                // Read stream into String\n                try {\n                    final String charset = NetUtils.getTextCharsetFromContentType(connectionResult.getResponseContentType());\n                    final InputStream is = new URL(tempURI).openStream();\n                    final Reader reader = new InputStreamReader(is, charset);\n                    try {\n                        final String responseBody = NetUtils.readStreamAsString(reader);\n                        setBodyString(responseBody);\n                    } finally {\n                        try {\n                            reader.close();\n                        } catch (Exception e) {\n                        }\n                    }\n                } catch (Exception e) {\n                    XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                }\n            } else {\n                // This is binary\n                // Don't store anything for now\n            }\n        }\n    }","id":38444,"modified_method":"public XFormsSubmitErrorEvent(PipelineContext pipelineContext, XFormsEventTarget targetObject, ErrorType errorType, ConnectionResult connectionResult) {\n        super(XFormsEvents.XFORMS_SUBMIT_ERROR, targetObject, connectionResult);\n        this.errorType = errorType;\n\n        // Try to add body information\n        if (connectionResult != null && connectionResult.hasContent()) {\n\n            // \"When the error response specifies an XML media type as defined by [RFC 3023], the response body is\n            // parsed into an XML document and the root element of the document is returned. If the parse fails, or if\n            // the error response specifies a text media type (starting with text/), then the response body is returned\n            // as a string. Otherwise, an empty string is returned.\"\n\n            // Read the whole stream to a temp URI so we can read it more than once if needed\n            final String tempURI;\n            try {\n                tempURI = NetUtils.inputStreamToAnyURI(pipelineContext, connectionResult.getResponseInputStream(), NetUtils.REQUEST_SCOPE);\n                connectionResult.getResponseInputStream().close();\n            } catch (Exception e) {\n                // Simply can't read the bocy\n                XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                return;\n            }\n\n            boolean isXMLParseFailed = false;\n            if (XMLUtils.isXMLMediatype(connectionResult.getResponseMediaType())) {\n                // XML content-type\n                // Read stream into Document\n                // TODO: In case of text/xml, charset is not handled. Should modify readTinyTree() and readDom4j()\n                InputStream is = null; \n                try {\n                    is = new URL(tempURI).openStream();\n                    final DocumentInfo responseBody = TransformerUtils.readTinyTree(is, connectionResult.resourceURI, false);\n                    setBodyDocument(responseBody);\n                    return;\n                } catch (Exception e) {\n                    XFormsServer.logger.error(\"XForms - submission - error while parsing response body as XML, defaulting to plain text.\", e);\n                    isXMLParseFailed = true;\n                } finally {\n                    try {\n                        is.close();\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (isXMLParseFailed || XMLUtils.isTextContentType(connectionResult.getResponseMediaType())) {\n                // XML parsing failed, or we got a text content-type\n                // Read stream into String\n                try {\n                    final String charset = NetUtils.getTextCharsetFromContentType(connectionResult.getResponseContentType());\n                    final InputStream is = new URL(tempURI).openStream();\n                    final Reader reader = new InputStreamReader(is, charset);\n                    try {\n                        final String responseBody = NetUtils.readStreamAsString(reader);\n                        setBodyString(responseBody);\n                    } finally {\n                        try {\n                            reader.close();\n                        } catch (Exception e) {\n                        }\n                    }\n                } catch (Exception e) {\n                    XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                }\n            } else {\n                // This is binary\n                // Don't store anything for now\n            }\n        }\n    }","commit_id":"068efa7298701bc69b6c05afb6046c93397db16f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"protected void validateVarElement(String fileName, Element element) {\n\t\tList<Attribute> attributes = element.attributes();\n\n\t\tMap<String, String> attributeMap = new HashMap<String, String>();\n\n\t\tfor (Attribute attribute : attributes) {\n\t\t\tString attributeName = attribute.getName();\n\t\t\tString attributeValue = attribute.getValue();\n\n\t\t\tif (!attributeName.equals(\"value\") &&\n\t\t\t\tValidator.isNull(attributeValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1006, fileName, element, attributeName);\n\t\t\t}\n\n\t\t\tif (!_allowedVarAttributes.contains(attributeName)) {\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1005, fileName, element, attributeName);\n\t\t\t}\n\n\t\t\tattributeMap.put(attributeName, attributeValue);\n\t\t}\n\n\t\tif (!attributeMap.containsKey(\"name\")) {\n\t\t\tthrowValidationException(\n\t\t\t\t1004, fileName, element, new String[] {\"name\"});\n\t\t}\n\t\telse {\n\t\t\tString nameValue = attributeMap.get(\"name\");\n\n\t\t\tif (Validator.isNull(nameValue)) {\n\t\t\t\tthrowValidationException(1006, fileName, element, \"name\");\n\t\t\t}\n\t\t}\n\n\t\tboolean elementHasInnerText = element.hasContent();\n\n\t\tif (!elementHasInnerText &&\n\t\t\t!attributeMap.containsKey(\"locator-key\") &&\n\t\t\t!attributeMap.containsKey(\"path\") &&\n\t\t\t!attributeMap.containsKey(\"value\")) {\n\n\t\t\tthrowValidationException(\n\t\t\t\t1004, fileName, element, new String [] {\"value\"});\n\t\t}\n\n\t\tif (!attributeMap.containsKey(\"value\")) {\n\t\t\tString locatorKeyValue = attributeMap.get(\"locator-key\");\n\t\t\tString pathValue = attributeMap.get(\"path\");\n\n\t\t\tif (Validator.isNull(locatorKeyValue) &&\n\t\t\t\tValidator.isNotNull(pathValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1004, fileName, element, new String [] {\"locator-key\"});\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(locatorKeyValue) &&\n\t\t\t\tValidator.isNull(pathValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1004, fileName, element, new String [] {\"path\"});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString varValue = attributeMap.get(\"value\");\n\n\t\t\tif (elementHasInnerText) {\n\t\t\t\tvarValue = element.getText();\n\t\t\t}\n\n\t\t\tPattern pattern = Pattern.compile(\"\\\\$\\\\{([^\\\\}]*?)\\\\}\");\n\n\t\t\tMatcher matcher = pattern.matcher(varValue);\n\n\t\t\twhile (matcher.find()) {\n\t\t\t\tString statement = matcher.group(1);\n\n\t\t\t\tPattern statementPattern = Pattern.compile(\n\t\t\t\t\t\"(.*)\\\\?(.*)\\\\(([^\\\\)]*?)\\\\)\");\n\n\t\t\t\tMatcher statementMatcher = statementPattern.matcher(statement);\n\n\t\t\t\tif (statementMatcher.find()) {\n\t\t\t\t\tString operand = statementMatcher.group(1);\n\n\t\t\t\t\tString method = statementMatcher.group(2);\n\n\t\t\t\t\tif (operand.equals(\"\") || method.equals(\"\")) {\n\t\t\t\t\t\tthrowValidationException(\n\t\t\t\t\t\t\t1006, fileName, element, \"value\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!_methodNames.contains(method)) {\n\t\t\t\t\t\tthrowValidationException(\n\t\t\t\t\t\t\t1013, fileName, element, method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (statement.matches(\".*[\\\\?\\\\(\\\\)\\\\}\\\\{].*\")) {\n\t\t\t\t\t\tthrowValidationException(\n\t\t\t\t\t\t\t1006, fileName, element, \"value\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Element> childElements = element.elements();\n\n\t\tif (!childElements.isEmpty()) {\n\t\t\tElement childElement = childElements.get(0);\n\n\t\t\tString childElementName = childElement.getName();\n\n\t\t\tthrowValidationException(\n\t\t\t\t1002, fileName, childElement, childElementName);\n\t\t}\n\t}","id":38445,"modified_method":"protected void validateVarElement(String fileName, Element element) {\n\t\tList<Attribute> attributes = element.attributes();\n\n\t\tMap<String, String> attributeMap = new HashMap<String, String>();\n\n\t\tfor (Attribute attribute : attributes) {\n\t\t\tString attributeName = attribute.getName();\n\t\t\tString attributeValue = attribute.getValue();\n\n\t\t\tif (!attributeName.equals(\"value\") &&\n\t\t\t\tValidator.isNull(attributeValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1006, fileName, element, attributeName);\n\t\t\t}\n\n\t\t\tif (!_allowedVarAttributes.contains(attributeName)) {\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1005, fileName, element, attributeName);\n\t\t\t}\n\n\t\t\tattributeMap.put(attributeName, attributeValue);\n\t\t}\n\n\t\tif (!attributeMap.containsKey(\"name\")) {\n\t\t\tthrowValidationException(\n\t\t\t\t1004, fileName, element, new String[] {\"name\"});\n\t\t}\n\t\telse {\n\t\t\tString nameValue = attributeMap.get(\"name\");\n\n\t\t\tif (Validator.isNull(nameValue)) {\n\t\t\t\tthrowValidationException(1006, fileName, element, \"name\");\n\t\t\t}\n\t\t}\n\n\t\tif (!element.hasContent() &&\n\t\t\t!attributeMap.containsKey(\"locator-key\") &&\n\t\t\t!attributeMap.containsKey(\"path\") &&\n\t\t\t!attributeMap.containsKey(\"value\")) {\n\n\t\t\tthrowValidationException(\n\t\t\t\t1004, fileName, element, new String [] {\"value\"});\n\t\t}\n\n\t\tif (!attributeMap.containsKey(\"value\")) {\n\t\t\tString locatorKeyValue = attributeMap.get(\"locator-key\");\n\t\t\tString pathValue = attributeMap.get(\"path\");\n\n\t\t\tif (Validator.isNull(locatorKeyValue) &&\n\t\t\t\tValidator.isNotNull(pathValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1004, fileName, element, new String [] {\"locator-key\"});\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(locatorKeyValue) &&\n\t\t\t\tValidator.isNull(pathValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1004, fileName, element, new String [] {\"path\"});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString varValue = attributeMap.get(\"value\");\n\n\t\t\tif (element.hasContent()) {\n\t\t\t\tvarValue = element.getText();\n\t\t\t}\n\n\t\t\tPattern pattern = Pattern.compile(\"\\\\$\\\\{([^\\\\}]*?)\\\\}\");\n\n\t\t\tMatcher matcher = pattern.matcher(varValue);\n\n\t\t\twhile (matcher.find()) {\n\t\t\t\tString statement = matcher.group(1);\n\n\t\t\t\tPattern statementPattern = Pattern.compile(\n\t\t\t\t\t\"(.*)\\\\?(.*)\\\\(([^\\\\)]*?)\\\\)\");\n\n\t\t\t\tMatcher statementMatcher = statementPattern.matcher(statement);\n\n\t\t\t\tif (statementMatcher.find()) {\n\t\t\t\t\tString operand = statementMatcher.group(1);\n\n\t\t\t\t\tString method = statementMatcher.group(2);\n\n\t\t\t\t\tif (operand.equals(\"\") || method.equals(\"\")) {\n\t\t\t\t\t\tthrowValidationException(\n\t\t\t\t\t\t\t1006, fileName, element, \"value\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!_methodNames.contains(method)) {\n\t\t\t\t\t\tthrowValidationException(\n\t\t\t\t\t\t\t1013, fileName, element, method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (statement.matches(\".*[\\\\?\\\\(\\\\)\\\\}\\\\{].*\")) {\n\t\t\t\t\t\tthrowValidationException(\n\t\t\t\t\t\t\t1006, fileName, element, \"value\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Element> childElements = element.elements();\n\n\t\tif (!childElements.isEmpty()) {\n\t\t\tElement childElement = childElements.get(0);\n\n\t\t\tString childElementName = childElement.getName();\n\n\t\t\tthrowValidationException(\n\t\t\t\t1002, fileName, childElement, childElementName);\n\t\t}\n\t}","commit_id":"c7ecfeb66614375f748894985673a50766a9c321","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateSimpleElement(\n\t\tString fileName, Element element, String[] neededAttributes) {\n\n\t\tMap<String, Boolean> hasNeededAttributes =\n\t\t\tnew HashMap<String, Boolean>();\n\n\t\tfor (String neededAttribute : neededAttributes) {\n\t\t\thasNeededAttributes.put(neededAttribute, false);\n\t\t}\n\n\t\tList<Attribute> attributes = element.attributes();\n\n\t\tfor (Attribute attribute : attributes) {\n\t\t\tString attributeName = attribute.getName();\n\t\t\tString attributeValue = attribute.getValue();\n\n\t\t\tList<String> acceptedNullAttributes = ListUtil.fromArray(\n\t\t\t\tnew String[] {\"value\", \"message\", \"arg1\", \"arg2\"});\n\n\t\t\tif (!acceptedNullAttributes.contains(attributeName) &&\n\t\t\t\tValidator.isNull(attributeValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1006, fileName, element, attributeName);\n\t\t\t}\n\n\t\t\tif (hasNeededAttributes.containsKey(attributeName)) {\n\t\t\t\thasNeededAttributes.put(attributeName, true);\n\t\t\t}\n\n\t\t\tif (!attributeName.equals(\"line-number\") &&\n\t\t\t\t!hasNeededAttributes.containsKey(attributeName)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1005, fileName, element, attributeName);\n\t\t\t}\n\t\t}\n\n\t\tfor (String neededAttribute : neededAttributes) {\n\t\t\tif (!hasNeededAttributes.get(neededAttribute)) {\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1004, fileName, element, neededAttributes);\n\t\t\t}\n\t\t}\n\n\t\tList<Element> childElements = element.elements();\n\n\t\tif (!childElements.isEmpty()) {\n\t\t\tElement childElement = childElements.get(0);\n\n\t\t\tString childElementName = childElement.getName();\n\n\t\t\tthrowValidationException(\n\t\t\t\t1002, fileName, childElement, childElementName);\n\t\t}\n\t}","id":38446,"modified_method":"protected void validateSimpleElement(\n\t\tString fileName, Element element, String[] neededAttributes) {\n\n\t\tMap<String, Boolean> hasNeededAttributes =\n\t\t\tnew HashMap<String, Boolean>();\n\n\t\tfor (String neededAttribute : neededAttributes) {\n\t\t\thasNeededAttributes.put(neededAttribute, false);\n\t\t}\n\n\t\tList<Attribute> attributes = element.attributes();\n\n\t\tfor (Attribute attribute : attributes) {\n\t\t\tString attributeName = attribute.getName();\n\t\t\tString attributeValue = attribute.getValue();\n\n\t\t\tif (!_allowedNullAttributes.contains(attributeName) &&\n\t\t\t\tValidator.isNull(attributeValue)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1006, fileName, element, attributeName);\n\t\t\t}\n\n\t\t\tif (hasNeededAttributes.containsKey(attributeName)) {\n\t\t\t\thasNeededAttributes.put(attributeName, true);\n\t\t\t}\n\n\t\t\tif (!attributeName.equals(\"line-number\") &&\n\t\t\t\t!hasNeededAttributes.containsKey(attributeName)) {\n\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1005, fileName, element, attributeName);\n\t\t\t}\n\t\t}\n\n\t\tfor (String neededAttribute : neededAttributes) {\n\t\t\tif (!hasNeededAttributes.get(neededAttribute)) {\n\t\t\t\tthrowValidationException(\n\t\t\t\t\t1004, fileName, element, neededAttributes);\n\t\t\t}\n\t\t}\n\n\t\tList<Element> childElements = element.elements();\n\n\t\tif (!childElements.isEmpty()) {\n\t\t\tElement childElement = childElements.get(0);\n\n\t\t\tString childElementName = childElement.getName();\n\n\t\t\tthrowValidationException(\n\t\t\t\t1002, fileName, childElement, childElementName);\n\t\t}\n\t}","commit_id":"c7ecfeb66614375f748894985673a50766a9c321","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Compiler<?> createCppCompiler() {\n        unavailableTool(\"C++ compiler is not available\");\n        return null;\n    }","id":38447,"modified_method":"protected Compiler<?> createCppCompiler() {\n        throw unavailableTool(\"C++ compiler is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected Compiler<?> createStaticLibraryArchiver() {\n        unavailableTool(\"Static library archiver is not available\");\n        return null;\n    }","id":38448,"modified_method":"protected Compiler<?> createStaticLibraryArchiver() {\n        throw unavailableTool(\"Static library archiver is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected Compiler<?> createObjectiveCCompiler() {\n        unavailableTool(\"Obj-C compiler is not available\");\n        return null;\n    }","id":38449,"modified_method":"protected Compiler<?> createObjectiveCCompiler() {\n        throw unavailableTool(\"Obj-C compiler is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected Compiler<?> createLinker() {\n        unavailableTool(\"Linker is not available\");\n        return null;\n    }","id":38450,"modified_method":"protected Compiler<?> createLinker() {\n        throw unavailableTool(\"Linker is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected Compiler<?> createObjectiveCppCompiler() {\n        unavailableTool(\"Obj-C++ compiler is not available\");\n        return null;\n    }","id":38451,"modified_method":"protected Compiler<?> createObjectiveCppCompiler() {\n        throw unavailableTool(\"Obj-C++ compiler is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected Compiler<?> createAssembler() {\n        unavailableTool(\"Assembler is not available\");\n        return null;\n    }","id":38452,"modified_method":"protected Compiler<?> createAssembler() {\n        throw unavailableTool(\"Assembler is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected Compiler<?> createCCompiler() {\n        unavailableTool(\"C compiler is not available\");\n        return null;\n    }","id":38453,"modified_method":"protected Compiler<?> createCCompiler() {\n        throw unavailableTool(\"C compiler is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected Compiler<?> createWindowsResourceCompiler() {\n        unavailableTool(\"Windows resource compiler is not available\");\n        return null;\n    }","id":38454,"modified_method":"protected Compiler<?> createWindowsResourceCompiler() {\n        throw unavailableTool(\"Windows resource compiler is not available\");\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"protected final void unavailableTool(String message) {\n        throw new RuntimeException(message);\n    }","id":38455,"modified_method":"protected final RuntimeException unavailableTool(String message) {\n        return new RuntimeException(message);\n    }","commit_id":"f35e9e330fac2c359a7176e7212693131c88f117","url":"https://github.com/gradle/gradle"},{"original_method":"public EObject getIndexedJvmType(URI javaObjectURI, ResourceSet resourceSet) {\n\t\tif (resourceSet != null) {\n\t\t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(resourceSet);\n\t\t\tif (descriptions != null) {\n\t\t\t\tURI withoutFragment = javaObjectURI.trimFragment();\n\t\t\t\tString fqn = withoutFragment.segment(withoutFragment.segmentCount() - 1);\n\t\t\t\tString[] fqnSegments = fqn.split(\"\\\\.\");\n\t\t\t\tQualifiedName qualifiedName = QualifiedName.create(fqnSegments);\n\t\t\t\tIterable<IEObjectDescription> candidates = descriptions.getExportedObjects(TypesPackage.Literals.JVM_TYPE, qualifiedName, false);\n\t\t\t\tIterator<IEObjectDescription> iterator = candidates.iterator();\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tIEObjectDescription description = iterator.next();\n\t\t\t\t\tEObject typeProxy = description.getEObjectOrProxy();\n\t\t\t\t\tif (typeProxy.eIsProxy()) {\n\t\t\t\t\t\ttypeProxy = EcoreUtil.resolve(typeProxy, resourceSet);\n\t\t\t\t\t}\n\t\t\t\t\tif (!typeProxy.eIsProxy() && typeProxy instanceof JvmType) {\n\t\t\t\t\t\tEObject result = resolveJavaObject((JvmType)typeProxy, javaObjectURI.fragment());\n\t\t\t\t\t\tif (result != null)\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":38456,"modified_method":"public EObject getIndexedJvmType(URI javaObjectURI, ResourceSet resourceSet) {\n\t\tif (resourceSet != null) {\n\t\t\tURI withoutFragment = javaObjectURI.trimFragment();\n\t\t\tString fqn = withoutFragment.segment(withoutFragment.segmentCount() - 1);\n\t\t\tString[] fqnSegments = fqn.split(\"\\\\.\");\n\t\t\tQualifiedName qualifiedName = QualifiedName.create(fqnSegments);\n\t\t\treturn getIndexedJvmType(qualifiedName, javaObjectURI.fragment(), resourceSet);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"89f0090a7545284575f78225e980ae74ef64ae03","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Undoer execute(List<VertexRef> targets, OperationContext operationContext) {\n\t\tif (enabled(targets, operationContext)) {\n\t\t\tLoggerFactory.getLogger(this.getClass()).debug(\"switched addNodeWithoutLinks to: \" + !m_topologyProvider.isAddNodeWithoutLink());\n\t\t\tm_topologyProvider.setAddNodeWithoutLink(!m_topologyProvider.isAddNodeWithoutLink());\n\t\t\ttry {\n\t\t\t\tm_topologyProvider.load(null);\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t// TODO: Display the error in the UI\n\t\t\t\tLoggerFactory.getLogger(this.getClass()).error(e.getMessage(), e);\n\t\t\t} catch (JAXBException e) {\n\t\t\t\t// TODO: Display the error in the UI\n\t\t\t\tLoggerFactory.getLogger(this.getClass()).error(e.getMessage(), e);\n\t\t\t}\n\t\t\toperationContext.getGraphContainer().redoLayout();\n\t\t}\n\t\treturn null;\n\t}","id":38457,"modified_method":"@Override\n\tpublic Undoer execute(List<VertexRef> targets, OperationContext operationContext) {\n\t\tif (enabled(targets, operationContext)) {\n\t\t\texecute(operationContext.getGraphContainer());\n\t\t}\n\t\treturn null;\n\t}","commit_id":"47228ae6cb2b7f3495c73d573791b93753a67b95","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void applyHistory(GraphContainer context, Map<String, String> settings) {\n\t\tif (\"true\".equals(settings.get(this.getClass().getName()))) {\n\t\t\tif (m_topologyProvider.isAddNodeWithoutLink()) {\n\t\t\t\tm_topologyProvider.setAddNodeWithoutLink(false);\n\t\t\t} else {\n\t\t\t\t// Hiding is enabled and isAddNodeWithoutLink() is already false\n\t\t\t}\n\t\t} else {\n\t\t\tif (m_topologyProvider.isAddNodeWithoutLink()) {\n\t\t\t\t// Adding is enabled and isAddNodeWithoutLink() is already true\n\t\t\t} else {\n\t\t\t\tm_topologyProvider.setAddNodeWithoutLink(true);\n\t\t\t}\n\t\t}\n\t}","id":38458,"modified_method":"@Override\n\tpublic void applyHistory(GraphContainer container, Map<String, String> settings) {\n\t\tif (\"true\".equals(settings.get(this.getClass().getName()))) {\n\t\t\tif (m_topologyProvider.isAddNodeWithoutLink()) {\n\t\t\t\texecute(container);\n\t\t\t} else {\n\t\t\t\t// Hiding is enabled and isAddNodeWithoutLink() is already false\n\t\t\t}\n\t\t} else {\n\t\t\tif (m_topologyProvider.isAddNodeWithoutLink()) {\n\t\t\t\t// Adding is enabled and isAddNodeWithoutLink() is already true\n\t\t\t} else {\n\t\t\t\texecute(container);\n\t\t\t}\n\t\t}\n\t}","commit_id":"47228ae6cb2b7f3495c73d573791b93753a67b95","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getFragment() {\n        return \"(\" + m_szl + \"),\" + m_boundBox.fragment() + \",\" + m_boundBox.getCenter();\n    }","id":38459,"modified_method":"public String getFragment() {\n        StringBuffer retval = new StringBuffer().append(\"(\").append(m_szl).append(\"),\").append(m_boundBox.fragment()).append(\",\").append(m_boundBox.getCenter());\n        // Add a CRC of all of the key-value pairs in m_settings to make the fragment unique\n        CRC32 crc = new CRC32();\n        for (Map.Entry<String,String> entry : m_settings.entrySet()) {\n            try {\n                crc.update(entry.getKey().getBytes(\"UTF-8\"));\n                crc.update(entry.getValue().getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                // Impossible on modern JVMs\n            }\n        }\n        retval.append(String.format(\",(%X)\", crc.getValue()));\n        return retval.toString();\n    }","commit_id":"47228ae6cb2b7f3495c73d573791b93753a67b95","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected boolean isInferredJvmElement(URI elementURI) {\n\t\t// TODO implement a better strategy\n\t\treturn elementURI.fragment().startsWith(\"/1/\");\n\t}","id":38460,"modified_method":"protected boolean isInferredJvmElement(URI elementURI) {\n\t\tString fragment = elementURI.fragment();\n\t\treturn !fragment.startsWith(\"/0\") && !fragment.startsWith(\"//\") && !fragment.equals(\"/\");\n\t}","commit_id":"6b28b8c6a6e1d8c87bea3f7d71840b2032530175","url":"https://github.com/eclipse/xtext"},{"original_method":"public void contactSelected(ContactListEvent evt)\n    {\n        mainFrame.getContactListPanel()\n            .getContactList().removeExcContactListListener(this);\n        \n        if(moveAllContacts) {\n            new MoveAllSubcontactsThread(evt.getSourceContact()).start();\n        }\n        else if(contactToMove != null) {\n            new MoveSubcontactThread(evt.getSourceContact()).start();\n        }\n    }","id":38461,"modified_method":"/**\n     * Implements ContactListListener.contactSelected method in order\n     * to move the choosen subcontact when a meta contact is selected.\n     */\n    public void contactSelected(ContactListEvent evt)\n    {\n        this.moveContact(evt.getSourceContact());\n    }","commit_id":"c28f0a0d7e0bb834b004e6199af7c6ca908c5347","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void protocolContactSelected(ContactListEvent evt)\n    {\n        mainFrame.getContactListPanel()\n            .getContactList().removeExcContactListListener(this);\n        \n        if(moveAllContacts) {\n            new MoveAllSubcontactsThread(evt.getSourceContact()).start();\n        }\n        else if(contactToMove != null) {\n            new MoveSubcontactThread(evt.getSourceContact()).start();\n        }\n    }","id":38462,"modified_method":"/**\n     * Implements ContactListListener.contactSelected method in order\n     * to move the choosen subcontact when a meta contact is selected.\n     */\n    public void protocolContactSelected(ContactListEvent evt)\n    {\n        this.moveContact(evt.getSourceContact());\n    }","commit_id":"c28f0a0d7e0bb834b004e6199af7c6ca908c5347","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt>. Determines which menu item was\n     * selected and makes the appropriate operations.\n     */\n    public void actionPerformed(ActionEvent e){\n\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n        String itemText = menuItem.getText();\n\n        if (itemName.startsWith(addSubcontactPrefix)) {\n            \n            ProtocolProviderService pps\n                = mainFrame.getProtocolProviderForAccount(itemText);\n\n            if(pps != null) {\n                AddContactDialog dialog = new AddContactDialog(\n                        mainFrame,\n                        contactItem, pps);\n    \n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 250,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 100\n                        );\n    \n                dialog.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"sendMessage\")) {\n            ContactListPanel clistPanel = mainFrame.getContactListPanel();\n            SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(\n                    contactItem));\n        }\n        else if (itemName.equalsIgnoreCase(\"sendFile\")) {\n            // disabled\n        }\n        else if (itemName.equalsIgnoreCase(\"renameContact\")) {\n            RenameContactDialog dialog = new RenameContactDialog(\n                    mainFrame.getContactList(), contactItem);\n\n            dialog.setLocation(\n                    Toolkit.getDefaultToolkit().getScreenSize().width/2\n                        - 200,\n                    Toolkit.getDefaultToolkit().getScreenSize().height/2\n                        - 50\n                    );\n\n            dialog.setVisible(true);\n            \n            dialog.requestFocusInFiled();\n        }\n        else if (itemName.equalsIgnoreCase(\"viewHistory\")) {\n\n            HistoryWindow history = new HistoryWindow(\n                    this.mainFrame, this.contactItem);\n\n            history.setVisible(true);\n        }\n        else if (itemName.equalsIgnoreCase(\"userInfo\")) {\n            Contact defaultContact = contactItem.getDefaultContact();\n\n            ProtocolProviderService defaultProvider\n                = defaultContact.getProtocolProvider();\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfo(defaultProvider);\n\n            CrossPlatformBrowserLauncher.openURL(\n                    wContactInfo.getWebContactInfo(defaultContact)\n                        .toString());\n        }\n        else if (itemName.startsWith(moveToPrefix)) {\n            \n            MetaContactGroup group\n                = mainFrame.getGroupByID(\n                        itemName.substring(moveToPrefix.length()));\n\n            if(group != null) {\n                mainFrame.getContactList().moveMetaContact(contactItem, group);\n            }\n        }\n        else if (itemName.startsWith(removeContactPrefix)) {\n            \n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(removeContactPrefix.length()));\n\n            if(contact != null) {\n                if(Constants.REMOVE_CONTACT_ASK) {\n                    String message = \"<HTML>Are you sure you want to remove <B>\"\n                        + contact.getDisplayName()\n                        + \"<\/B><BR>from your contact list?<\/html>\";\n    \n                    MessageDialog dialog = new MessageDialog(this.mainFrame,\n                            message, Messages.getString(\"remove\"));\n    \n                    int returnCode = dialog.showDialog();\n    \n                    if (returnCode == MessageDialog.OK_RETURN_CODE) {\n                        new RemoveContactThread(contact).start();\n                    }\n                    else if (returnCode == MessageDialog.OK_DONT_ASK_CODE) {\n                        new RemoveContactThread(contact).start();\n    \n                        Constants.REMOVE_CONTACT_ASK = false;\n                    }\n                }\n                else {\n                    new RemoveContactThread(contact).start();\n                }\n            }\n            else {\n                if(Constants.REMOVE_CONTACT_ASK) {\n                    String message = \"<HTML>Are you sure you want to remove <B>\"\n                        + Messages.getString(\"allContacts\")\n                        + \"<\/B><BR>from your contact list?<\/html>\";\n    \n                    MessageDialog dialog = new MessageDialog(this.mainFrame,\n                            message, Messages.getString(\"remove\"));\n    \n                    int returnCode = dialog.showDialog();\n    \n                    if (returnCode == MessageDialog.OK_RETURN_CODE) {\n                        new RemoveAllContactsThread().start();\n                    }\n                    else if (returnCode == MessageDialog.OK_DONT_ASK_CODE) {\n                        new RemoveAllContactsThread().start();\n    \n                        Constants.REMOVE_CONTACT_ASK = false;\n                    }\n                }\n                else {\n                    new RemoveAllContactsThread().start();\n                }\n            }\n        }\n        else if(itemName.startsWith(moveSubcontactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(moveSubcontactPrefix.length()));\n\n            mainFrame.getContactListPanel()\n                .getContactList().addExcContactListListener(this);\n            \n            if(contact != null) {\n                this.contactToMove = contact;                \n            }\n            else {\n                this.moveAllContacts = true;\n            }\n        }\n    }","id":38463,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt>. Determines which menu item was\n     * selected and makes the appropriate operations.\n     */\n    public void actionPerformed(ActionEvent e){\n\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n        String itemText = menuItem.getText();\n\n        if (itemName.startsWith(addSubcontactPrefix)) {\n            \n            ProtocolProviderService pps\n                = mainFrame.getProtocolProviderForAccount(itemText);\n\n            if(pps != null) {\n                AddContactDialog dialog = new AddContactDialog(\n                        mainFrame,\n                        contactItem, pps);\n    \n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 250,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 100\n                        );\n    \n                dialog.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"sendMessage\")) {\n            ContactListPanel clistPanel = mainFrame.getContactListPanel();\n            SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(\n                    contactItem));\n        }\n        else if (itemName.equalsIgnoreCase(\"sendFile\")) {\n            // disabled\n        }\n        else if (itemName.equalsIgnoreCase(\"renameContact\")) {\n            RenameContactDialog dialog = new RenameContactDialog(\n                    mainFrame.getContactList(), contactItem);\n\n            dialog.setLocation(\n                    Toolkit.getDefaultToolkit().getScreenSize().width/2\n                        - 200,\n                    Toolkit.getDefaultToolkit().getScreenSize().height/2\n                        - 50\n                    );\n\n            dialog.setVisible(true);\n            \n            dialog.requestFocusInFiled();\n        }\n        else if (itemName.equalsIgnoreCase(\"viewHistory\")) {\n\n            HistoryWindow history = new HistoryWindow(\n                    this.mainFrame, this.contactItem);\n\n            history.setVisible(true);\n        }\n        else if (itemName.equalsIgnoreCase(\"userInfo\")) {\n            Contact defaultContact = contactItem.getDefaultContact();\n\n            ProtocolProviderService defaultProvider\n                = defaultContact.getProtocolProvider();\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfo(defaultProvider);\n\n            CrossPlatformBrowserLauncher.openURL(\n                    wContactInfo.getWebContactInfo(defaultContact)\n                        .toString());\n        }\n        else if (itemName.startsWith(moveToPrefix)) {\n            \n            MetaContactGroup group\n                = mainFrame.getGroupByID(\n                        itemName.substring(moveToPrefix.length()));\n\n            if(group != null) {\n                mainFrame.getContactList().moveMetaContact(contactItem, group);\n            }\n        }\n        else if (itemName.startsWith(removeContactPrefix)) {\n            \n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(removeContactPrefix.length()));\n\n            if(contact != null) {\n                if(Constants.REMOVE_CONTACT_ASK) {\n                    String message = \"<HTML>Are you sure you want to remove <B>\"\n                        + contact.getDisplayName()\n                        + \"<\/B><BR>from your contact list?<\/html>\";\n    \n                    MessageDialog dialog = new MessageDialog(this.mainFrame,\n                            message, Messages.getString(\"remove\"));\n    \n                    int returnCode = dialog.showDialog();\n    \n                    if (returnCode == MessageDialog.OK_RETURN_CODE) {\n                        new RemoveContactThread(contact).start();\n                    }\n                    else if (returnCode == MessageDialog.OK_DONT_ASK_CODE) {\n                        new RemoveContactThread(contact).start();\n    \n                        Constants.REMOVE_CONTACT_ASK = false;\n                    }\n                }\n                else {\n                    new RemoveContactThread(contact).start();\n                }\n            }\n            else {\n                if(Constants.REMOVE_CONTACT_ASK) {\n                    String message = \"<HTML>Are you sure you want to remove <B>\"\n                        + Messages.getString(\"allContacts\")\n                        + \"<\/B><BR>from your contact list?<\/html>\";\n    \n                    MessageDialog dialog = new MessageDialog(this.mainFrame,\n                            message, Messages.getString(\"remove\"));\n    \n                    int returnCode = dialog.showDialog();\n    \n                    if (returnCode == MessageDialog.OK_RETURN_CODE) {\n                        new RemoveAllContactsThread().start();\n                    }\n                    else if (returnCode == MessageDialog.OK_DONT_ASK_CODE) {\n                        new RemoveAllContactsThread().start();\n    \n                        Constants.REMOVE_CONTACT_ASK = false;\n                    }\n                }\n                else {\n                    new RemoveAllContactsThread().start();\n                }\n            }\n        }\n        else if(itemName.startsWith(moveSubcontactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(moveSubcontactPrefix.length()));\n\n            mainFrame.getContactListPanel()\n                .getContactList().addExcContactListListener(this);\n            \n            this.moveDialog = new MoveSubcontactMessageDialog(mainFrame);\n            \n            this.moveDialog.setVisible(true);\n                        \n            if(contact != null) {\n                this.contactToMove = contact;                \n            }\n            else {\n                this.moveAllContacts = true;\n            }\n        }\n    }","commit_id":"c28f0a0d7e0bb834b004e6199af7c6ca908c5347","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Makes the specified <tt>contact<\/tt> a child of the\n     * <tt>newParentMetaGroup<\/tt> MetaContactGroup. If <tt>contact<\/tt> was\n     * previously a child of a meta contact, it will be removed from its\n     * old parent and to a newly created one even if they both are in the same\n     * group. If the specified contact was the only child of its previous\n     * parent, then the meta contact will also be moved.\n     *\n     *\n     * @param contact the <tt>Contact<\/tt> to move to the\n     * @param newParentMetaGroup the MetaContactGroup where we'd like contact to\n     *  be moved.\n     * @throws MetaContactListException with an appropriate code if the\n     * operation fails for some reason.\n     */\n    public void moveContact(Contact contact,\n                            MetaContactGroup newParentMetaGroup)\n        throws MetaContactListException\n    {\n        if(contact.getPersistableAddress() == null)\n        {\n           logger.info(\"Contact cannot be moved! This contact doesn't have \" +\n                \"persistant address.\");\n           return;\n        }\n        /** first create the new meta contact */\n        MetaContactImpl metaContactImpl = new MetaContactImpl();\n\n        MetaContactGroupImpl newParentMetaGroupImpl\n            = (MetaContactGroupImpl)newParentMetaGroup;\n\n        newParentMetaGroupImpl.addMetaContact(metaContactImpl);\n\n        fireMetaContactEvent(metaContactImpl\n                             , newParentMetaGroupImpl\n                             , MetaContactEvent.META_CONTACT_ADDED);\n\n        /** then move the sub contactact to the new metacontact container */\n        try\n        {\n            moveContact(contact, metaContactImpl);\n        }\n        catch(MetaContactListException mex)\n        {\n            newParentMetaGroupImpl.removeMetaContact(metaContactImpl);\n            fireMetaContactEvent(metaContactImpl\n                , newParentMetaGroupImpl\n                , MetaContactEvent.META_CONTACT_REMOVED);\n\n            throw mex;\n        }\n    }","id":38464,"modified_method":"/**\n     * Makes the specified <tt>contact<\/tt> a child of the\n     * <tt>newParentMetaGroup<\/tt> MetaContactGroup. If <tt>contact<\/tt> was\n     * previously a child of a meta contact, it will be removed from its\n     * old parent and to a newly created one even if they both are in the same\n     * group. If the specified contact was the only child of its previous\n     * parent, then the meta contact will also be moved.\n     *\n     *\n     * @param contact the <tt>Contact<\/tt> to move to the\n     * @param newParentMetaGroup the MetaContactGroup where we'd like contact to\n     *  be moved.\n     * @throws MetaContactListException with an appropriate code if the\n     * operation fails for some reason.\n     */\n    public void moveContact(Contact contact,\n                            MetaContactGroup newParentMetaGroup)\n        throws MetaContactListException\n    {\n        if(contact.getPersistableAddress() == null)\n        {\n           logger.info(\"Contact cannot be moved! This contact doesn't have \" +\n                \"persistant address.\");\n           return;\n        }\n\n        if(contact.getPersistableAddress() == null)\n        {\n            logger.info(\"Contact cannot be moved! This contact doesn't have \" +\n                \"persistant address.\");\n            return;\n        }\n\n        ProtocolProviderService provider = contact.getProtocolProvider();\n\n        OperationSetMultiUserChat opSetMUC\n            = provider.getOperationSet(OperationSetMultiUserChat.class);\n\n        if(opSetMUC != null\n            && opSetMUC.isPrivateMessagingContact(contact.getAddress()))\n        {\n            MetaContactImpl metaContactImpl = new MetaContactImpl();\n            MetaContactGroupImpl newParentMetaGroupImpl\n                = (MetaContactGroupImpl)newParentMetaGroup;\n\n            newParentMetaGroupImpl.addMetaContact(metaContactImpl);\n\n            fireMetaContactEvent(metaContactImpl\n                                 , newParentMetaGroupImpl\n                                 , MetaContactEvent.META_CONTACT_ADDED);\n\n            addNewContactToMetaContact(provider, metaContactImpl,\n                contact.getPersistableAddress());\n            return;\n        }\n\n        //get a persistent  presence operation set\n        OperationSetPersistentPresence opSetPresence\n            = provider.getOperationSet(OperationSetPersistentPresence.class);\n\n        if (opSetPresence == null)\n        {\n            /** @todo handle non persistent presence operation sets */\n        }\n\n        MetaContactImpl currentParentMetaContact\n            = (MetaContactImpl)this.findMetaContactByContact(contact);\n\n        ContactGroup parentProtoGroup = resolveProtoPath(contact\n            .getProtocolProvider(), (MetaContactGroupImpl) newParentMetaGroup);\n\n        //if the contact is not currently in the proto group corresponding to\n        //its new metacontact group parent then move it\n        try\n        {\n            if(contact.getParentContactGroup() != parentProtoGroup\n                && opSetPresence != null)\n            {\n                opSetPresence.moveContactToGroup(contact, parentProtoGroup);\n            }\n\n            // remove the proto-contact only if move is successful\n            currentParentMetaContact.removeProtoContact(contact);\n        }\n        catch(OperationFailedException ex)\n        {\n            throw new MetaContactListException(ex.getMessage(),\n                MetaContactListException.CODE_MOVE_CONTACT_ERROR);\n        }\n\n        // first check if this has been already done on other place\n        // (SubscriptionListener.subscriptionMoved)\n        MetaContactImpl metaContactImpl = null;\n        synchronized(contact)\n        {\n            MetaContact checkContact = findMetaContactByContact(contact);\n\n            if(checkContact == null)\n            {\n                metaContactImpl = new MetaContactImpl();\n\n                ((MetaContactGroupImpl)newParentMetaGroup)\n                    .addMetaContact(metaContactImpl);\n\n                metaContactImpl.addProtoContact(contact);\n            }\n        }\n\n        if(metaContactImpl != null)\n        {\n            fireMetaContactEvent(metaContactImpl\n                , newParentMetaGroup\n                , MetaContactEvent.META_CONTACT_ADDED);\n\n            //fire an event telling everyone that contact has been added to its\n            //new parent.\n            fireProtoContactEvent(\n                contact,\n                ProtoContactEvent.PROTO_CONTACT_MOVED,\n                currentParentMetaContact,\n                metaContactImpl);\n        }\n\n        //if this was the last contact in the meta contact - remove it.\n        //it is true that in some cases the move would be followed by some kind\n        //of protocol provider events indicating the change which on its turn\n        //may trigger the removal of empty meta contacts. Yet in many cases\n        //particularly if parent groups were not changed in the protocol contact\n        //list no event would come and the meta contact will remain empty\n        //that's why we delete it here and if an event follows it would simply\n        //be ignored.\n        if (currentParentMetaContact.getContactCount() == 0)\n        {\n            MetaContactGroupImpl parentMetaGroup =\n                currentParentMetaContact.getParentGroup();\n            parentMetaGroup.removeMetaContact(currentParentMetaContact);\n\n            fireMetaContactEvent(currentParentMetaContact, parentMetaGroup\n                , MetaContactEvent.META_CONTACT_REMOVED);\n        }\n    }","commit_id":"513f617ea25ff550541c6d55abec3c16f5587d9c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Makes the specified <tt>contact<\/tt> a child of the <tt>newParent<\/tt>\n     * MetaContact.\n     *\n     * @param contact\n     *            the <tt>Contact<\/tt> to move to the\n     * @param newParentMetaContact\n     *            the MetaContact where we'd like contact to be moved.\n     * @throws MetaContactListException\n     *             with an appropriate code if the operation fails for some\n     *             reason.\n     */\n    public void moveContact(Contact contact,\n                            MetaContact newParentMetaContact) throws\n        MetaContactListException\n    {\n        if(contact.getPersistableAddress() == null)\n        {\n           logger.info(\"Contact cannot be moved! This contact doesn't have \" +\n                \"persistant address.\");\n           return;\n        }\n        \n        ProtocolProviderService provider = contact.getProtocolProvider();\n        \n        OperationSetMultiUserChat opSetMUC\n            = provider.getOperationSet(OperationSetMultiUserChat.class);\n        \n        if(opSetMUC != null\n           && opSetMUC.isPrivateMessagingContact(contact.getAddress()))\n        {\n            addNewContactToMetaContact(provider, newParentMetaContact, \n                contact.getPersistableAddress());\n            return;\n        }\n        \n        //get a persistent  presence operation set\n        OperationSetPersistentPresence opSetPresence\n            = provider.getOperationSet(OperationSetPersistentPresence.class);\n\n        if (opSetPresence == null)\n        {\n            /** @todo handle non persistent presence operation sets */\n        }\n        \n        \n        \n        if (! (newParentMetaContact instanceof MetaContactImpl))\n        {\n            throw new IllegalArgumentException(\n                newParentMetaContact + \" is not a MetaContactImpl instance.\");\n        }\n\n        MetaContactImpl currentParentMetaContact\n            = (MetaContactImpl)this.findMetaContactByContact(contact);\n\n        MetaContactGroup newParentGroup\n            = findParentMetaContactGroup(newParentMetaContact);\n\n        ContactGroup parentProtoGroup = resolveProtoPath(contact\n            .getProtocolProvider(), (MetaContactGroupImpl) newParentGroup);\n\n        //if the contact is not currently in the proto group corresponding to\n        //its new metacontact group parent then move it\n        try\n        {\n            if(contact.getParentContactGroup() != parentProtoGroup\n                && opSetPresence != null)\n            {\n                opSetPresence.moveContactToGroup(contact, parentProtoGroup);\n            }\n\n            // remove the proto-contact only if move is successful\n            currentParentMetaContact.removeProtoContact(contact);\n        }\n        catch(OperationFailedException ex)\n        {\n            throw new MetaContactListException(ex.getMessage(),\n                MetaContactListException.CODE_MOVE_CONTACT_ERROR);\n        }\n\n        ( (MetaContactImpl) newParentMetaContact).addProtoContact(contact);\n\n        //fire an event telling everyone that contact has been added to its new\n        //parent.\n        fireProtoContactEvent(contact, ProtoContactEvent.PROTO_CONTACT_MOVED\n            , currentParentMetaContact , newParentMetaContact);\n\n        //if this was the last contact in the meta contact - remove it.\n        //it is true that in some cases the move would be followed by some kind\n        //of protocol provider events indicating the change which on its turn\n        //may trigger the removal of empty meta contacts. Yet in many cases\n        //particularly if parent groups were not changed in the protocol contact\n        //list no event would come and the meta contact will remain empty\n        //that's why we delete it here and if an event follows it would simply\n        //be ignored.\n        if (currentParentMetaContact.getContactCount() == 0)\n        {\n            MetaContactGroupImpl parentMetaGroup =\n                currentParentMetaContact.getParentGroup();\n            parentMetaGroup.removeMetaContact(currentParentMetaContact);\n\n            fireMetaContactEvent(currentParentMetaContact, parentMetaGroup\n                                     , MetaContactEvent.META_CONTACT_REMOVED);\n        }\n    }","id":38465,"modified_method":"/**\n     * Makes the specified <tt>contact<\/tt> a child of the <tt>newParent<\/tt>\n     * MetaContact.\n     *\n     * @param contact\n     *            the <tt>Contact<\/tt> to move to the\n     * @param newParentMetaContact\n     *            the MetaContact where we'd like contact to be moved.\n     * @throws MetaContactListException\n     *             with an appropriate code if the operation fails for some\n     *             reason.\n     */\n    public void moveContact(Contact contact,\n                            MetaContact newParentMetaContact) throws\n        MetaContactListException\n    {\n        if(contact.getPersistableAddress() == null)\n        {\n           logger.info(\"Contact cannot be moved! This contact doesn't have \" +\n                \"persistant address.\");\n           return;\n        }\n        \n        ProtocolProviderService provider = contact.getProtocolProvider();\n        \n        OperationSetMultiUserChat opSetMUC\n            = provider.getOperationSet(OperationSetMultiUserChat.class);\n        \n        if(opSetMUC != null\n           && opSetMUC.isPrivateMessagingContact(contact.getAddress()))\n        {\n            addNewContactToMetaContact(provider, newParentMetaContact, \n                contact.getPersistableAddress());\n            return;\n        }\n        \n        //get a persistent  presence operation set\n        OperationSetPersistentPresence opSetPresence\n            = provider.getOperationSet(OperationSetPersistentPresence.class);\n\n        if (opSetPresence == null)\n        {\n            /** @todo handle non persistent presence operation sets */\n        }\n        \n        \n        \n        if (! (newParentMetaContact instanceof MetaContactImpl))\n        {\n            throw new IllegalArgumentException(\n                newParentMetaContact + \" is not a MetaContactImpl instance.\");\n        }\n\n        MetaContactImpl currentParentMetaContact\n            = (MetaContactImpl)this.findMetaContactByContact(contact);\n\n        MetaContactGroup newParentGroup\n            = findParentMetaContactGroup(newParentMetaContact);\n\n        ContactGroup parentProtoGroup = resolveProtoPath(contact\n            .getProtocolProvider(), (MetaContactGroupImpl) newParentGroup);\n\n        //if the contact is not currently in the proto group corresponding to\n        //its new metacontact group parent then move it\n        try\n        {\n            if(contact.getParentContactGroup() != parentProtoGroup\n                && opSetPresence != null)\n            {\n                opSetPresence.moveContactToGroup(contact, parentProtoGroup);\n            }\n\n            // remove the proto-contact only if move is successful\n            currentParentMetaContact.removeProtoContact(contact);\n        }\n        catch(OperationFailedException ex)\n        {\n            throw new MetaContactListException(ex.getMessage(),\n                MetaContactListException.CODE_MOVE_CONTACT_ERROR);\n        }\n\n        synchronized(contact)\n        {\n            MetaContact checkContact = findMetaContactByContact(contact);\n\n            if(checkContact == null)\n            {\n                ( (MetaContactImpl) newParentMetaContact)\n                    .addProtoContact(contact);\n            }\n        }\n\n        if(newParentMetaContact.containsContact(contact))\n        {\n            //fire an event telling everyone that contact has been added to its\n            //new parent.\n            fireProtoContactEvent(contact, ProtoContactEvent.PROTO_CONTACT_MOVED\n                , currentParentMetaContact , newParentMetaContact);\n        }\n\n        //if this was the last contact in the meta contact - remove it.\n        //it is true that in some cases the move would be followed by some kind\n        //of protocol provider events indicating the change which on its turn\n        //may trigger the removal of empty meta contacts. Yet in many cases\n        //particularly if parent groups were not changed in the protocol contact\n        //list no event would come and the meta contact will remain empty\n        //that's why we delete it here and if an event follows it would simply\n        //be ignored.\n        if (currentParentMetaContact.getContactCount() == 0)\n        {\n            MetaContactGroupImpl parentMetaGroup =\n                currentParentMetaContact.getParentGroup();\n            parentMetaGroup.removeMetaContact(currentParentMetaContact);\n\n            fireMetaContactEvent(currentParentMetaContact, parentMetaGroup\n                                     , MetaContactEvent.META_CONTACT_REMOVED);\n        }\n    }","commit_id":"513f617ea25ff550541c6d55abec3c16f5587d9c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Indicates that a contact/subscription has been moved from one server\n         * stored group to another. The way we handle the event depends on\n         * whether the source contact/subscription is the only proto contact\n         * found in its current MetaContact encapsulator or not.\n         * <p>\n         * If this is the case (the source contact has no siblings in its current\n         * meta contact list encapsulator) then we will move the whole meta\n         * contact to the meta contact group corresponding to the new parent\n         * ContactGroup of the source contact. In this case we would only fire\n         * a MetaContactMovedEvent containing the old and new parents of the\n         * MetaContact in question.\n         * <p>\n         * If, however, the MetaContact that currently encapsulates the source\n         * contact also encapsulates other proto contacts, then we will create\n         * a new MetaContact instance, place it in the MetaContactGroup\n         * corresponding to the new parent ContactGroup of the source contact\n         * and add the source contact inside it. In this case we would first\n         * fire a metacontact added event over the empty meta contact and then,\n         * once the proto contact has been moved inside it, we would also fire\n         * a ProtoContactEvent with event id PROTO_CONTACT_MOVED.\n         * <p>\n         * @param evt a reference to the SubscriptionMovedEvent containing previous\n         * and new parents as well as a ref to the source contact.\n         */\n        public void subscriptionMoved(SubscriptionMovedEvent evt)\n        {\n            if (logger.isTraceEnabled())\n                logger.trace(\"Subscription moved: \" + evt);\n\n            //ignore the event if the source contact is in the ignore list\n            if (isContactInEventIgnoreList(\n                     evt.getSourceContact()\n                   , evt.getSourceProvider()))\n            {\n                return;\n            }\n\n            MetaContactGroupImpl oldParentGroup = (MetaContactGroupImpl)\n                findMetaContactGroupByContactGroup(evt.getOldParentGroup());\n            MetaContactGroupImpl newParentGroup = (MetaContactGroupImpl)\n                findMetaContactGroupByContactGroup(evt.getNewParentGroup());\n\n            if (newParentGroup == null || oldParentGroup == null)\n            {\n                logger.error(\"Received a subscription for a group that we \"\n                             + \"hadn't seen before! \");\n                return;\n            }\n\n            MetaContactImpl currentMetaContact = (MetaContactImpl)\n                               findMetaContactByContact(evt.getSourceContact());\n\n            if(currentMetaContact == null)\n            {\n                logger.warn(\"Received a move event for a contact that is \"\n                            +\"not in our contact list.\"\n                            , new NullPointerException(\n                                    \"Received a move event for a contact that \"\n                                    +\"is not in our contact list.\"));\n                return;\n            }\n\n             //if the move was caused by us (when merging contacts) then chances\n            //are that the contact is already in the right group\n            MetaContactGroup currentParentGroup\n                = currentMetaContact.getParentMetaContactGroup();\n\n            if(currentParentGroup == newParentGroup)\n            {\n                return;\n            }\n\n            //if the meta contact does not have other children apart from the\n            //contact that we're currently moving then move the whole meta\n            //contact to the new parent group.\n            if( currentMetaContact.getContactCount() == 1 )\n            {\n                oldParentGroup.removeMetaContact(currentMetaContact);\n                newParentGroup.addMetaContact(currentMetaContact);\n                fireMetaContactEvent(new MetaContactMovedEvent(\n                    currentMetaContact, oldParentGroup, newParentGroup));\n            }\n            //if the source contact is not the only contact encapsulated by the\n            //currentMetaContact, then create a new meta contact in the new\n            //parent group and move the source contact to it.\n            else\n            {\n                MetaContactImpl newMetaContact = new MetaContactImpl();\n                newMetaContact.setDisplayName(evt\n                                          .getSourceContact().getDisplayName());\n                newParentGroup.addMetaContact(newMetaContact);\n\n                //fire an event notifying that a new meta contact was added.\n                fireMetaContactEvent(newMetaContact,\n                                     newParentGroup,\n                                     MetaContactEvent.META_CONTACT_ADDED);\n\n                //move the proto contact and fire the corresponding event\n                currentMetaContact.removeProtoContact(evt.getSourceContact());\n                newMetaContact.addProtoContact(evt.getSourceContact());\n\n                fireProtoContactEvent(evt.getSourceContact()\n                                      , ProtoContactEvent.PROTO_CONTACT_MOVED\n                                      , currentMetaContact\n                                      , newMetaContact);\n            }\n        }","id":38466,"modified_method":"/**\n         * Indicates that a contact/subscription has been moved from one server\n         * stored group to another. The way we handle the event depends on\n         * whether the source contact/subscription is the only proto contact\n         * found in its current MetaContact encapsulator or not.\n         * <p>\n         * If this is the case (the source contact has no siblings in its current\n         * meta contact list encapsulator) then we will move the whole meta\n         * contact to the meta contact group corresponding to the new parent\n         * ContactGroup of the source contact. In this case we would only fire\n         * a MetaContactMovedEvent containing the old and new parents of the\n         * MetaContact in question.\n         * <p>\n         * If, however, the MetaContact that currently encapsulates the source\n         * contact also encapsulates other proto contacts, then we will create\n         * a new MetaContact instance, place it in the MetaContactGroup\n         * corresponding to the new parent ContactGroup of the source contact\n         * and add the source contact inside it. In this case we would first\n         * fire a metacontact added event over the empty meta contact and then,\n         * once the proto contact has been moved inside it, we would also fire\n         * a ProtoContactEvent with event id PROTO_CONTACT_MOVED.\n         * <p>\n         * @param evt a reference to the SubscriptionMovedEvent containing previous\n         * and new parents as well as a ref to the source contact.\n         */\n        public void subscriptionMoved(SubscriptionMovedEvent evt)\n        {\n            if (logger.isTraceEnabled())\n                logger.trace(\"Subscription moved: \" + evt);\n\n            Contact sourceContact = evt.getSourceContact();\n\n            //ignore the event if the source contact is in the ignore list\n            if (isContactInEventIgnoreList(\n                     sourceContact\n                   , evt.getSourceProvider()))\n            {\n                return;\n            }\n\n            MetaContactGroupImpl oldParentGroup = (MetaContactGroupImpl)\n                findMetaContactGroupByContactGroup(evt.getOldParentGroup());\n            MetaContactGroupImpl newParentGroup = (MetaContactGroupImpl)\n                findMetaContactGroupByContactGroup(evt.getNewParentGroup());\n\n            if (newParentGroup == null || oldParentGroup == null)\n            {\n                logger.error(\"Received a subscription for a group that we \"\n                             + \"hadn't seen before! \");\n                return;\n            }\n\n            MetaContactImpl currentMetaContact = (MetaContactImpl)\n                               findMetaContactByContact(sourceContact);\n\n            if(currentMetaContact == null)\n            {\n                logger.warn(\"Received a move event for a contact that is \"\n                            +\"not in our contact list.\"\n                            , new NullPointerException(\n                                    \"Received a move event for a contact that \"\n                                    +\"is not in our contact list.\"));\n                return;\n            }\n\n             //if the move was caused by us (when merging contacts) then chances\n            //are that the contact is already in the right group\n            MetaContactGroup currentParentGroup\n                = currentMetaContact.getParentMetaContactGroup();\n\n            if(currentParentGroup == newParentGroup)\n            {\n                return;\n            }\n\n            //if the meta contact does not have other children apart from the\n            //contact that we're currently moving then move the whole meta\n            //contact to the new parent group.\n            if( currentMetaContact.getContactCount() == 1 )\n            {\n                oldParentGroup.removeMetaContact(currentMetaContact);\n                newParentGroup.addMetaContact(currentMetaContact);\n                fireMetaContactEvent(new MetaContactMovedEvent(\n                    currentMetaContact, oldParentGroup, newParentGroup));\n            }\n            //if the source contact is not the only contact encapsulated by the\n            //currentMetaContact, then create a new meta contact in the new\n            //parent group and move the source contact to it.\n            else\n            {\n\n                MetaContactImpl newMetaContact = null;\n\n                // first check whether a contact hasn't been already added to\n                // a metacontact\n                synchronized(sourceContact)\n                {\n                    //move the proto contact and fire the corresponding event\n                    currentMetaContact.removeProtoContact(sourceContact);\n\n                    MetaContact checkContact =\n                        findMetaContactByContact(sourceContact);\n                    if(checkContact == null)\n                    {\n                        newMetaContact = new MetaContactImpl();\n                        newMetaContact.setDisplayName(\n                            sourceContact.getDisplayName());\n\n                        newParentGroup.addMetaContact(newMetaContact);\n                        newMetaContact.addProtoContact(sourceContact);\n                    }\n                }\n                // new contact was created\n                if(newMetaContact != null)\n                {\n                    //fire an event notifying that a new meta contact was added.\n                    fireMetaContactEvent(newMetaContact,\n                        newParentGroup,\n                        MetaContactEvent.META_CONTACT_ADDED);\n\n                    fireProtoContactEvent(sourceContact\n                        , ProtoContactEvent.PROTO_CONTACT_MOVED\n                        , currentMetaContact\n                        , newMetaContact);\n                }\n            }\n        }","commit_id":"513f617ea25ff550541c6d55abec3c16f5587d9c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructor to create a new OpenCms object.<p>\n     *\n     * It reads the configurations from the <code>opencms.properties<\/code>\n     * file in the <code>config/<\/code> subdirectory. With the information\n     * from this file is inits a ResourceBroker (Database access module),\n     * various caching systems and other options.<p>\n     *\n     * This will only be done once per accessing class.\n     *\n     * @param configuration the configurations from the <code>opencms.properties<\/code> file\n     * @throws CmsInitException in case OpenCms can not be initialized\n     */\n    protected synchronized void initConfiguration(CmsParameterConfiguration configuration) throws CmsInitException {\n\n        String serverInfo = configuration.getString(\"context.servlet.container\", null);\n\n        // output startup message to log file\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(\n                \". \"\n                    + Messages.get().getBundle().key(\n                        Messages.GUI_SHELL_VERSION_1,\n                        OpenCms.getSystemInfo().getVersionNumber()));\n            for (int i = 0; i < Messages.COPYRIGHT_BY_ALKACON.length; i++) {\n                CmsLog.INIT.info(\". \" + Messages.COPYRIGHT_BY_ALKACON[i]);\n            }\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LINE_0));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_STARTUP_TIME_1, new Date(System.currentTimeMillis())));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_OPENCMS_VERSION_1,\n                    OpenCms.getSystemInfo().getVersionNumber() + \" [\" + OpenCms.getSystemInfo().getVersionId() + \"]\"));\n            if (serverInfo != null) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_SERVLET_CONTAINER_1, serverInfo));\n            }\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_WEBAPP_NAME_1, getSystemInfo().getWebApplicationName()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_SERVLET_PATH_1, getSystemInfo().getServletPath()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_OPENCMS_CONTEXT_1, getSystemInfo().getOpenCmsContext()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_WEBINF_PATH_1, getSystemInfo().getWebInfRfsPath()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_PROPERTY_FILE_1,\n                    getSystemInfo().getConfigurationFileRfsPath()));\n\n            String logFileRfsPath = getSystemInfo().getLogFileRfsPath();\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_LOG_FILE_1,\n                    logFileRfsPath != null ? logFileRfsPath : \"Managed by log4j\"));\n        }\n\n        String systemEncoding = null;\n        try {\n            systemEncoding = System.getProperty(\"file.encoding\");\n        } catch (@SuppressWarnings(\"unused\") SecurityException se) {\n            // security manager is active, but we will try other options before giving up\n        }\n        Security.addProvider(new CryptixCrypto());\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FILE_ENCODING_1, systemEncoding));\n        }\n\n        // read server ethernet address (MAC) and init UUID generator\n        String ethernetAddress = configuration.getString(\"server.ethernet.address\", CmsStringUtil.getEthernetAddress());\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_ETHERNET_ADDRESS_1, ethernetAddress));\n        }\n        CmsUUID.init(ethernetAddress);\n\n        // set the server name\n        String serverName = configuration.getString(\"server.name\", \"OpenCmsServer\");\n        getSystemInfo().setServerName(serverName);\n\n        // check the installed Java SDK\n        try {\n            if (CmsLog.INIT.isInfoEnabled()) {\n                String jdkinfo = System.getProperty(\"java.vm.name\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.version\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.info\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.vendor\") + \" \";\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_JAVA_VM_1, jdkinfo));\n                String osinfo = System.getProperty(\"os.name\") + \" \";\n                osinfo += System.getProperty(\"os.version\") + \" \";\n                osinfo += System.getProperty(\"os.arch\") + \" \";\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_OPERATING_SYSTEM_1, osinfo));\n            }\n        } catch (Exception e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_PROP_0), e);\n        }\n\n        // create the configuration manager instance\n        m_configurationManager = new CmsConfigurationManager(getSystemInfo().getConfigFolder());\n        // store the configuration read from \"opencms.properties\" in the configuration manager\n        m_configurationManager.setConfiguration(configuration);\n\n        // now load the XML configuration\n        try {\n            m_configurationManager.loadXmlConfiguration();\n        } catch (Exception e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_XML_0), e);\n        }\n\n        // get the system configuration\n        CmsSystemConfiguration systemConfiguration = (CmsSystemConfiguration)m_configurationManager.getConfiguration(\n            CmsSystemConfiguration.class);\n\n        // initialize the memory monitor\n        CmsMemoryMonitorConfiguration memoryMonitorConfiguration = systemConfiguration.getCmsMemoryMonitorConfiguration();\n        // initialize the memory monitor\n        try {\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(memoryMonitorConfiguration.getClassName())) {\n                m_memoryMonitor = (CmsMemoryMonitor)Class.forName(\n                    memoryMonitorConfiguration.getClassName()).newInstance();\n            } else {\n                m_memoryMonitor = new CmsMemoryMonitor();\n            }\n        } catch (Exception e) {\n            // we can not start without a valid memory monitor\n            throw new CmsInitException(\n                Messages.get().container(\n                    Messages.ERR_CRITICAL_INIT_MEMORY_MONITOR_1,\n                    memoryMonitorConfiguration.getClassName()),\n                e);\n        }\n        m_memoryMonitor.initialize(systemConfiguration);\n\n        // get the event manager from the configuration and initialize it with the events already registered\n        CmsEventManager configuredEventManager = systemConfiguration.getEventManager();\n        configuredEventManager.initialize(m_eventManager);\n        m_eventManager = configuredEventManager;\n\n        // check if the encoding setting is valid\n        String setEncoding = systemConfiguration.getDefaultContentEncoding();\n        String defaultEncoding = CmsEncoder.lookupEncoding(setEncoding, null);\n        if (defaultEncoding == null) {\n            // we can not start without a valid encoding setting\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_ENCODING_1, setEncoding));\n        }\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_OPENCMS_ENCODING_1, defaultEncoding));\n        }\n        getSystemInfo().setDefaultEncoding(defaultEncoding);\n\n        // set version history information\n        getSystemInfo().setVersionHistorySettings(\n            systemConfiguration.isHistoryEnabled(),\n            systemConfiguration.getHistoryVersions(),\n            systemConfiguration.getHistoryVersionsAfterDeletion());\n        // set mail configuration\n        getSystemInfo().setMailSettings(systemConfiguration.getMailSettings());\n        // set HTTP authentication settings\n        getSystemInfo().setHttpAuthenticationSettings(systemConfiguration.getHttpAuthenticationSettings());\n        getSystemInfo().setRestrictDetailContents(systemConfiguration.isRestrictDetailContents());\n\n        // set content notification settings\n        getSystemInfo().setNotificationTime(systemConfiguration.getNotificationTime());\n        getSystemInfo().setNotificationProject(systemConfiguration.getNotificationProject());\n        // set the scheduler manager\n        m_scheduleManager = systemConfiguration.getScheduleManager();\n        m_executor = new ScheduledThreadPoolExecutor(2);\n        // set resource init classes\n        m_resourceInitHandlers = systemConfiguration.getResourceInitHandlers();\n        // register request handler classes\n        Iterator<I_CmsRequestHandler> it = systemConfiguration.getRequestHandlers().iterator();\n        while (it.hasNext()) {\n            I_CmsRequestHandler handler = it.next();\n            addRequestHandler(handler);\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(\n                    Messages.get().getBundle().key(\n                        Messages.INIT_REQUEST_HANDLER_CLASS_1,\n                        handler.getClass().getName()));\n            }\n        }\n\n        // read the default user configuration\n        m_defaultUsers = systemConfiguration.getCmsDefaultUsers();\n\n        // get the site manager from the configuration\n        m_siteManager = systemConfiguration.getSiteManager();\n\n        // get the VFS / resource configuration\n        CmsVfsConfiguration vfsConfiguation = (CmsVfsConfiguration)m_configurationManager.getConfiguration(\n            CmsVfsConfiguration.class);\n        m_resourceManager = vfsConfiguation.getResourceManager();\n        m_xmlContentTypeManager = vfsConfiguation.getXmlContentTypeManager();\n        m_defaultFiles = vfsConfiguation.getDefaultFiles();\n\n        // initialize translation engines\n        m_resourceManager.setTranslators(\n            vfsConfiguation.getFolderTranslator(),\n            vfsConfiguation.getFileTranslator(),\n            vfsConfiguation.getXsdTranslator());\n\n        // try to initialize the flex cache\n        CmsFlexCache flexCache = null;\n        try {\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_STARTING_0));\n            }\n            // get the flex cache configuration from the SystemConfiguration\n            CmsFlexCacheConfiguration flexCacheConfiguration = systemConfiguration.getCmsFlexCacheConfiguration();\n            getSystemInfo().setDeviceSelector(flexCacheConfiguration.getDeviceSelector());\n            // pass configuration to flex cache for initialization\n            flexCache = new CmsFlexCache(flexCacheConfiguration);\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_FINISHED_0));\n            }\n        } catch (Exception e) {\n            if (CmsLog.INIT.isWarnEnabled()) {\n                CmsLog.INIT.warn(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_ERROR_1, e.getMessage()));\n            }\n        }\n\n        if (flexCache != null) {\n            // check all resource loaders if they require the Flex cache\n            Iterator<I_CmsResourceLoader> i = m_resourceManager.getLoaders().iterator();\n            while (i.hasNext()) {\n                Object o = i.next();\n                if (o instanceof I_CmsFlexCacheEnabledLoader) {\n                    // this resource loader requires the Flex cache\n                    ((I_CmsFlexCacheEnabledLoader)o).setFlexCache(flexCache);\n                }\n            }\n        }\n\n        // get the import/export configuration\n        CmsImportExportConfiguration importExportConfiguration = (CmsImportExportConfiguration)m_configurationManager.getConfiguration(\n            CmsImportExportConfiguration.class);\n        m_importExportManager = importExportConfiguration.getImportExportManager();\n        m_staticExportManager = importExportConfiguration.getStaticExportManager();\n        m_repositoryManager = importExportConfiguration.getRepositoryManager();\n\n        // get the search configuration\n        CmsSearchConfiguration searchConfiguration = (CmsSearchConfiguration)m_configurationManager.getConfiguration(\n            CmsSearchConfiguration.class);\n        m_searchManager = searchConfiguration.getSearchManager();\n\n        // get the workplace configuration\n        CmsWorkplaceConfiguration workplaceConfiguration = (CmsWorkplaceConfiguration)m_configurationManager.getConfiguration(\n            CmsWorkplaceConfiguration.class);\n        m_workplaceManager = workplaceConfiguration.getWorkplaceManager();\n        // add the export points from the workplace\n        addExportPoints(m_workplaceManager.getExportPoints());\n\n        // get the module configuration\n        CmsModuleConfiguration moduleConfiguration = (CmsModuleConfiguration)m_configurationManager.getConfiguration(\n            CmsModuleConfiguration.class);\n        m_moduleManager = moduleConfiguration.getModuleManager();\n\n        // get the password handler\n        m_passwordHandler = systemConfiguration.getPasswordHandler();\n\n        // get the validation handler\n        m_validationHandler = systemConfiguration.getValidationHandler();\n\n        // get the authorization handler\n        m_authorizationHandler = systemConfiguration.getAuthorizationHandler();\n\n        // get the login manager\n        m_loginManager = systemConfiguration.getLoginManager();\n\n        // initialize the publish engine\n        m_publishEngine = new CmsPublishEngine(systemConfiguration.getRuntimeInfoFactory());\n\n        // Credentials resolver - needs to be set before the driver manager is initialized\n        m_credentialsResolver = systemConfiguration.getCredentialsResolver();\n\n        // init the OpenCms security manager\n        m_securityManager = CmsSecurityManager.newInstance(\n            m_configurationManager,\n            systemConfiguration.getRuntimeInfoFactory(),\n            m_publishEngine);\n\n        // get the publish manager\n        m_publishManager = systemConfiguration.getPublishManager();\n\n        // get the subscription manager\n        m_subscriptionManager = systemConfiguration.getSubscriptionManager();\n\n        // initialize the role manager\n        m_roleManager = new CmsRoleManager(m_securityManager);\n\n        // initialize the organizational unit manager\n        m_orgUnitManager = new CmsOrgUnitManager(m_securityManager);\n\n        // initialize the Thread store\n        m_threadStore = new CmsThreadStore(m_securityManager);\n\n        // initialize the link manager\n        m_linkManager = new CmsLinkManager(m_staticExportManager.getLinkSubstitutionHandler());\n\n        m_aliasManager = new CmsAliasManager(m_securityManager);\n\n        // store the runtime properties\n        m_runtimeProperties.putAll(systemConfiguration.getRuntimeProperties());\n\n        // initialize the session storage provider\n        I_CmsSessionStorageProvider sessionStorageProvider = systemConfiguration.getSessionStorageProvider();\n\n        // get an Admin cms context object with site root set to \"/\"\n        CmsObject adminCms;\n        try {\n            adminCms = initCmsObject(null, null, getDefaultUsers().getUserAdmin(), (String)null, (String)null);\n        } catch (CmsException e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_ADMINCMS_0), e);\n        }\n\n        m_repositoryManager.initializeCms(adminCms);\n        // now initialize the other managers\n        try {\n            // initialize the scheduler\n            m_scheduleManager.initialize(initCmsObject(adminCms));\n\n            // initialize the locale manager\n            m_localeManager = systemConfiguration.getLocaleManager();\n            m_localeManager.initialize(initCmsObject(adminCms));\n\n            // initialize the site manager\n            m_siteManager.initialize(initCmsObject(adminCms));\n\n            // initialize the static export manager\n            m_staticExportManager.initialize(initCmsObject(adminCms));\n\n            // initialize the XML content type manager\n            m_xmlContentTypeManager.initialize(initCmsObject(adminCms));\n\n            m_orgUnitManager.initialize(initCmsObject(adminCms));\n\n            // initialize the module manager\n            m_moduleManager.initialize(initCmsObject(adminCms), m_configurationManager);\n\n            // initialize the resource manager\n            m_resourceManager.initialize(initCmsObject(adminCms));\n\n            // initialize the publish manager\n            m_publishManager.setPublishEngine(m_publishEngine);\n            m_publishManager.setSecurityManager(m_securityManager);\n            m_publishManager.setPublishListRemoveMode(systemConfiguration.getPublishListRemoveMode());\n            m_publishManager.initialize(initCmsObject(adminCms));\n\n            // initialize the search manager\n            m_searchManager.initialize(initCmsObject(adminCms));\n\n            // initialize the VFS bundle manager\n            m_vfsBundleManager = new CmsVfsBundleManager(adminCms);\n\n            // initialize the workplace manager\n            m_workplaceManager.initialize(initCmsObject(adminCms));\n\n            // initialize the session manager\n            m_sessionManager.initialize(sessionStorageProvider);\n            m_sessionManager.setUserSessionMode(systemConfiguration.getUserSessionMode(true));\n\n            // initialize the subscription manager\n            m_subscriptionManager.setSecurityManager(m_securityManager);\n            m_subscriptionManager.initialize(adminCms);\n\n            // initialize ade manager\n            // initialize the formatter configuration\n            CmsFormatterConfiguration.initialize(adminCms);\n            CmsPersistentLoginTokenHandler.setAdminCms(initCmsObject(adminCms));\n            CmsLoginUI.setAdminCmsObject(initCmsObject(adminCms));\n            //m_adeManager = new CmsADEManager(initCmsObject(adminCms), m_memoryMonitor, systemConfiguration);\n            m_adeManager = new CmsADEManager(initCmsObject(adminCms), m_memoryMonitor, systemConfiguration);\n            m_workplaceAppManager = new CmsWorkplaceAppManager(initCmsObject(adminCms));\n            m_workplaceAppManager.loadApps();\n            m_templateContextManager = new CmsTemplateContextManager(initCmsObject(adminCms));\n            m_workflowManager = systemConfiguration.getWorkflowManager();\n            if (m_workflowManager == null) {\n                m_workflowManager = new CmsDefaultWorkflowManager();\n                m_workflowManager.setParameters(new HashMap<String, String>());\n            }\n            m_workflowManager.initialize(initCmsObject(adminCms));\n        } catch (CmsException e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_MANAGERS_0), e);\n        }\n\n        try {\n            getEventManager().fireEvent(I_CmsEventListener.EVENT_CLEAR_CACHES);\n        } catch (Exception e) {\n            CmsLog.INIT.error(\"Problem with clearing caches after initialization: \" + e.getLocalizedMessage(), e);\n        }\n    }","id":38467,"modified_method":"/**\n     * Constructor to create a new OpenCms object.<p>\n     *\n     * It reads the configurations from the <code>opencms.properties<\/code>\n     * file in the <code>config/<\/code> subdirectory. With the information\n     * from this file is inits a ResourceBroker (Database access module),\n     * various caching systems and other options.<p>\n     *\n     * This will only be done once per accessing class.\n     *\n     * @param configuration the configurations from the <code>opencms.properties<\/code> file\n     * @throws CmsInitException in case OpenCms can not be initialized\n     */\n    protected synchronized void initConfiguration(CmsParameterConfiguration configuration) throws CmsInitException {\n\n        String serverInfo = configuration.getString(\"context.servlet.container\", null);\n\n        // output startup message to log file\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(\n                \". \"\n                    + Messages.get().getBundle().key(\n                        Messages.GUI_SHELL_VERSION_1,\n                        OpenCms.getSystemInfo().getVersionNumber()));\n            for (int i = 0; i < Messages.COPYRIGHT_BY_ALKACON.length; i++) {\n                CmsLog.INIT.info(\". \" + Messages.COPYRIGHT_BY_ALKACON[i]);\n            }\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LINE_0));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_STARTUP_TIME_1, new Date(System.currentTimeMillis())));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_OPENCMS_VERSION_1,\n                    OpenCms.getSystemInfo().getVersionNumber() + \" [\" + OpenCms.getSystemInfo().getVersionId() + \"]\"));\n            if (serverInfo != null) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_SERVLET_CONTAINER_1, serverInfo));\n            }\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_WEBAPP_NAME_1, getSystemInfo().getWebApplicationName()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_SERVLET_PATH_1, getSystemInfo().getServletPath()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_OPENCMS_CONTEXT_1, getSystemInfo().getOpenCmsContext()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_WEBINF_PATH_1, getSystemInfo().getWebInfRfsPath()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_PROPERTY_FILE_1,\n                    getSystemInfo().getConfigurationFileRfsPath()));\n\n            String logFileRfsPath = getSystemInfo().getLogFileRfsPath();\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_LOG_FILE_1,\n                    logFileRfsPath != null ? logFileRfsPath : \"Managed by log4j\"));\n        }\n\n        String systemEncoding = null;\n        try {\n            systemEncoding = System.getProperty(\"file.encoding\");\n        } catch (SecurityException se) {\n            // security manager is active, but we will try other options before giving up\n            LOG.debug(\"Security manager preventing access to file.encoding system property.\", se);\n        }\n        Security.addProvider(new CryptixCrypto());\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FILE_ENCODING_1, systemEncoding));\n        }\n\n        // read server ethernet address (MAC) and init UUID generator\n        String ethernetAddress = configuration.getString(\"server.ethernet.address\", CmsStringUtil.getEthernetAddress());\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_ETHERNET_ADDRESS_1, ethernetAddress));\n        }\n        CmsUUID.init(ethernetAddress);\n\n        // set the server name\n        String serverName = configuration.getString(\"server.name\", \"OpenCmsServer\");\n        getSystemInfo().setServerName(serverName);\n\n        // check the installed Java SDK\n        try {\n            if (CmsLog.INIT.isInfoEnabled()) {\n                String jdkinfo = System.getProperty(\"java.vm.name\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.version\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.info\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.vendor\") + \" \";\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_JAVA_VM_1, jdkinfo));\n                String osinfo = System.getProperty(\"os.name\") + \" \";\n                osinfo += System.getProperty(\"os.version\") + \" \";\n                osinfo += System.getProperty(\"os.arch\") + \" \";\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_OPERATING_SYSTEM_1, osinfo));\n            }\n        } catch (Exception e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_PROP_0), e);\n        }\n\n        // create the configuration manager instance\n        m_configurationManager = new CmsConfigurationManager(getSystemInfo().getConfigFolder());\n        // store the configuration read from \"opencms.properties\" in the configuration manager\n        m_configurationManager.setConfiguration(configuration);\n\n        // now load the XML configuration\n        try {\n            m_configurationManager.loadXmlConfiguration();\n        } catch (Exception e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_XML_0), e);\n        }\n\n        // get the system configuration\n        CmsSystemConfiguration systemConfiguration = (CmsSystemConfiguration)m_configurationManager.getConfiguration(\n            CmsSystemConfiguration.class);\n\n        // initialize the memory monitor\n        CmsMemoryMonitorConfiguration memoryMonitorConfiguration = systemConfiguration.getCmsMemoryMonitorConfiguration();\n        // initialize the memory monitor\n        try {\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(memoryMonitorConfiguration.getClassName())) {\n                m_memoryMonitor = (CmsMemoryMonitor)Class.forName(\n                    memoryMonitorConfiguration.getClassName()).newInstance();\n            } else {\n                m_memoryMonitor = new CmsMemoryMonitor();\n            }\n        } catch (Exception e) {\n            // we can not start without a valid memory monitor\n            throw new CmsInitException(\n                Messages.get().container(\n                    Messages.ERR_CRITICAL_INIT_MEMORY_MONITOR_1,\n                    memoryMonitorConfiguration.getClassName()),\n                e);\n        }\n        m_memoryMonitor.initialize(systemConfiguration);\n\n        // get the event manager from the configuration and initialize it with the events already registered\n        CmsEventManager configuredEventManager = systemConfiguration.getEventManager();\n        configuredEventManager.initialize(m_eventManager);\n        m_eventManager = configuredEventManager;\n\n        // check if the encoding setting is valid\n        String setEncoding = systemConfiguration.getDefaultContentEncoding();\n        String defaultEncoding = CmsEncoder.lookupEncoding(setEncoding, null);\n        if (defaultEncoding == null) {\n            // we can not start without a valid encoding setting\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_ENCODING_1, setEncoding));\n        }\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_OPENCMS_ENCODING_1, defaultEncoding));\n        }\n        getSystemInfo().setDefaultEncoding(defaultEncoding);\n\n        // set version history information\n        getSystemInfo().setVersionHistorySettings(\n            systemConfiguration.isHistoryEnabled(),\n            systemConfiguration.getHistoryVersions(),\n            systemConfiguration.getHistoryVersionsAfterDeletion());\n        // set mail configuration\n        getSystemInfo().setMailSettings(systemConfiguration.getMailSettings());\n        // set HTTP authentication settings\n        getSystemInfo().setHttpAuthenticationSettings(systemConfiguration.getHttpAuthenticationSettings());\n        getSystemInfo().setRestrictDetailContents(systemConfiguration.isRestrictDetailContents());\n\n        // set content notification settings\n        getSystemInfo().setNotificationTime(systemConfiguration.getNotificationTime());\n        getSystemInfo().setNotificationProject(systemConfiguration.getNotificationProject());\n        // set the scheduler manager\n        m_scheduleManager = systemConfiguration.getScheduleManager();\n        m_executor = new ScheduledThreadPoolExecutor(2);\n        // set resource init classes\n        m_resourceInitHandlers = systemConfiguration.getResourceInitHandlers();\n        // register request handler classes\n        Iterator<I_CmsRequestHandler> it = systemConfiguration.getRequestHandlers().iterator();\n        while (it.hasNext()) {\n            I_CmsRequestHandler handler = it.next();\n            addRequestHandler(handler);\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(\n                    Messages.get().getBundle().key(\n                        Messages.INIT_REQUEST_HANDLER_CLASS_1,\n                        handler.getClass().getName()));\n            }\n        }\n\n        // read the default user configuration\n        m_defaultUsers = systemConfiguration.getCmsDefaultUsers();\n\n        // get the site manager from the configuration\n        m_siteManager = systemConfiguration.getSiteManager();\n\n        // get the VFS / resource configuration\n        CmsVfsConfiguration vfsConfiguation = (CmsVfsConfiguration)m_configurationManager.getConfiguration(\n            CmsVfsConfiguration.class);\n        m_resourceManager = vfsConfiguation.getResourceManager();\n        m_xmlContentTypeManager = vfsConfiguation.getXmlContentTypeManager();\n        m_defaultFiles = vfsConfiguation.getDefaultFiles();\n\n        // initialize translation engines\n        m_resourceManager.setTranslators(\n            vfsConfiguation.getFolderTranslator(),\n            vfsConfiguation.getFileTranslator(),\n            vfsConfiguation.getXsdTranslator());\n\n        // try to initialize the flex cache\n        CmsFlexCache flexCache = null;\n        try {\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_STARTING_0));\n            }\n            // get the flex cache configuration from the SystemConfiguration\n            CmsFlexCacheConfiguration flexCacheConfiguration = systemConfiguration.getCmsFlexCacheConfiguration();\n            getSystemInfo().setDeviceSelector(flexCacheConfiguration.getDeviceSelector());\n            // pass configuration to flex cache for initialization\n            flexCache = new CmsFlexCache(flexCacheConfiguration);\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_FINISHED_0));\n            }\n        } catch (Exception e) {\n            if (CmsLog.INIT.isWarnEnabled()) {\n                CmsLog.INIT.warn(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_ERROR_1, e.getMessage()));\n            }\n        }\n\n        if (flexCache != null) {\n            // check all resource loaders if they require the Flex cache\n            Iterator<I_CmsResourceLoader> i = m_resourceManager.getLoaders().iterator();\n            while (i.hasNext()) {\n                Object o = i.next();\n                if (o instanceof I_CmsFlexCacheEnabledLoader) {\n                    // this resource loader requires the Flex cache\n                    ((I_CmsFlexCacheEnabledLoader)o).setFlexCache(flexCache);\n                }\n            }\n        }\n\n        // get the import/export configuration\n        CmsImportExportConfiguration importExportConfiguration = (CmsImportExportConfiguration)m_configurationManager.getConfiguration(\n            CmsImportExportConfiguration.class);\n        m_importExportManager = importExportConfiguration.getImportExportManager();\n        m_staticExportManager = importExportConfiguration.getStaticExportManager();\n        m_repositoryManager = importExportConfiguration.getRepositoryManager();\n\n        // get the search configuration\n        CmsSearchConfiguration searchConfiguration = (CmsSearchConfiguration)m_configurationManager.getConfiguration(\n            CmsSearchConfiguration.class);\n        m_searchManager = searchConfiguration.getSearchManager();\n\n        // get the workplace configuration\n        CmsWorkplaceConfiguration workplaceConfiguration = (CmsWorkplaceConfiguration)m_configurationManager.getConfiguration(\n            CmsWorkplaceConfiguration.class);\n        m_workplaceManager = workplaceConfiguration.getWorkplaceManager();\n        // add the export points from the workplace\n        addExportPoints(m_workplaceManager.getExportPoints());\n\n        // get the module configuration\n        CmsModuleConfiguration moduleConfiguration = (CmsModuleConfiguration)m_configurationManager.getConfiguration(\n            CmsModuleConfiguration.class);\n        m_moduleManager = moduleConfiguration.getModuleManager();\n\n        // get the password handler\n        m_passwordHandler = systemConfiguration.getPasswordHandler();\n\n        // get the validation handler\n        m_validationHandler = systemConfiguration.getValidationHandler();\n\n        // get the authorization handler\n        m_authorizationHandler = systemConfiguration.getAuthorizationHandler();\n\n        // get the login manager\n        m_loginManager = systemConfiguration.getLoginManager();\n\n        // initialize the publish engine\n        m_publishEngine = new CmsPublishEngine(systemConfiguration.getRuntimeInfoFactory());\n\n        // Credentials resolver - needs to be set before the driver manager is initialized\n        m_credentialsResolver = systemConfiguration.getCredentialsResolver();\n\n        // init the OpenCms security manager\n        m_securityManager = CmsSecurityManager.newInstance(\n            m_configurationManager,\n            systemConfiguration.getRuntimeInfoFactory(),\n            m_publishEngine);\n\n        // get the publish manager\n        m_publishManager = systemConfiguration.getPublishManager();\n\n        // get the subscription manager\n        m_subscriptionManager = systemConfiguration.getSubscriptionManager();\n\n        // initialize the role manager\n        m_roleManager = new CmsRoleManager(m_securityManager);\n\n        // initialize the organizational unit manager\n        m_orgUnitManager = new CmsOrgUnitManager(m_securityManager);\n\n        // initialize the Thread store\n        m_threadStore = new CmsThreadStore(m_securityManager);\n\n        // initialize the link manager\n        m_linkManager = new CmsLinkManager(m_staticExportManager.getLinkSubstitutionHandler());\n\n        m_aliasManager = new CmsAliasManager(m_securityManager);\n\n        // store the runtime properties\n        m_runtimeProperties.putAll(systemConfiguration.getRuntimeProperties());\n\n        // initialize the session storage provider\n        I_CmsSessionStorageProvider sessionStorageProvider = systemConfiguration.getSessionStorageProvider();\n\n        // get an Admin cms context object with site root set to \"/\"\n        CmsObject adminCms;\n        try {\n            adminCms = initCmsObject(null, null, getDefaultUsers().getUserAdmin(), (String)null, (String)null);\n        } catch (CmsException e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_ADMINCMS_0), e);\n        }\n\n        m_repositoryManager.initializeCms(adminCms);\n        // now initialize the other managers\n        try {\n            // initialize the scheduler\n            m_scheduleManager.initialize(initCmsObject(adminCms));\n\n            // initialize the locale manager\n            m_localeManager = systemConfiguration.getLocaleManager();\n            m_localeManager.initialize(initCmsObject(adminCms));\n\n            // initialize the site manager\n            m_siteManager.initialize(initCmsObject(adminCms));\n\n            // initialize the static export manager\n            m_staticExportManager.initialize(initCmsObject(adminCms));\n\n            // initialize the XML content type manager\n            m_xmlContentTypeManager.initialize(initCmsObject(adminCms));\n\n            m_orgUnitManager.initialize(initCmsObject(adminCms));\n\n            // initialize the module manager\n            m_moduleManager.initialize(initCmsObject(adminCms), m_configurationManager);\n\n            // initialize the resource manager\n            m_resourceManager.initialize(initCmsObject(adminCms));\n\n            // initialize the publish manager\n            m_publishManager.setPublishEngine(m_publishEngine);\n            m_publishManager.setSecurityManager(m_securityManager);\n            m_publishManager.setPublishListRemoveMode(systemConfiguration.getPublishListRemoveMode());\n            m_publishManager.initialize(initCmsObject(adminCms));\n\n            // initialize the search manager\n            m_searchManager.initialize(initCmsObject(adminCms));\n\n            // initialize the VFS bundle manager\n            m_vfsBundleManager = new CmsVfsBundleManager(adminCms);\n\n            // initialize the workplace manager\n            m_workplaceManager.initialize(initCmsObject(adminCms));\n\n            // initialize the session manager\n            m_sessionManager.initialize(sessionStorageProvider);\n            m_sessionManager.setUserSessionMode(systemConfiguration.getUserSessionMode(true));\n\n            // initialize the subscription manager\n            m_subscriptionManager.setSecurityManager(m_securityManager);\n            m_subscriptionManager.initialize(adminCms);\n\n            // initialize ade manager\n            // initialize the formatter configuration\n            CmsFormatterConfiguration.initialize(adminCms);\n            CmsPersistentLoginTokenHandler.setAdminCms(initCmsObject(adminCms));\n            CmsLoginUI.setAdminCmsObject(initCmsObject(adminCms));\n            //m_adeManager = new CmsADEManager(initCmsObject(adminCms), m_memoryMonitor, systemConfiguration);\n            m_adeManager = new CmsADEManager(initCmsObject(adminCms), m_memoryMonitor, systemConfiguration);\n            m_workplaceAppManager = new CmsWorkplaceAppManager(initCmsObject(adminCms));\n            m_workplaceAppManager.loadApps();\n            m_templateContextManager = new CmsTemplateContextManager(initCmsObject(adminCms));\n            m_workflowManager = systemConfiguration.getWorkflowManager();\n            if (m_workflowManager == null) {\n                m_workflowManager = new CmsDefaultWorkflowManager();\n                m_workflowManager.setParameters(new HashMap<String, String>());\n            }\n            m_workflowManager.initialize(initCmsObject(adminCms));\n        } catch (CmsException e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_MANAGERS_0), e);\n        }\n\n        try {\n            getEventManager().fireEvent(I_CmsEventListener.EVENT_CLEAR_CACHES);\n        } catch (Exception e) {\n            CmsLog.INIT.error(\"Problem with clearing caches after initialization: \" + e.getLocalizedMessage(), e);\n        }\n    }","commit_id":"4da4c8ed5bdd57afeeb5ca61da139b5bf531b702","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * This method performs the error handling for OpenCms.<p>\n     *\n     * @param cms the current cms context, might be null !\n     * @param req the client request\n     * @param res the client response\n     * @param t the exception that occurred\n     */\n    private void errorHandling(CmsObject cms, HttpServletRequest req, HttpServletResponse res, Throwable t) {\n\n        // remove the controller attribute from the request\n        CmsFlexController.removeController(req);\n\n        boolean canWrite = (!res.isCommitted() && !res.containsHeader(\"Location\"));\n        int status = -1;\n        boolean isGuest = true;\n\n        if (t instanceof ServletException) {\n            ServletException s = (ServletException)t;\n            if (s.getRootCause() != null) {\n                t = s.getRootCause();\n            }\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        } else if (t instanceof CmsSecurityException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // access error - display login dialog\n            if (canWrite) {\n                try {\n                    m_authorizationHandler.requestAuthorization(req, res, getLoginFormURL(req, res));\n                } catch (@SuppressWarnings(\"unused\") IOException ioe) {\n                    // there is nothing we can do about this\n                }\n                return;\n            }\n        } else if (t instanceof CmsDbEntryNotFoundException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // user or group does not exist\n            status = HttpServletResponse.SC_SERVICE_UNAVAILABLE;\n            isGuest = false;\n        } else if (t instanceof CmsVfsResourceNotFoundException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // file not found - display 404 error.\n            status = HttpServletResponse.SC_NOT_FOUND;\n        } else if (t instanceof CmsException) {\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            if (t.getCause() != null) {\n                t = t.getCause();\n            }\n        } else if (t.getClass().getName().equals(\"org.apache.catalina.connector.ClientAbortException\")) {\n            // only log to debug channel any exceptions caused by a client abort - this is tomcat specific\n            LOG.debug(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        } else {\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        }\n\n        if (status < 1) {\n            // error code not set - set \"internal server error\" (500)\n            status = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n        }\n        res.setStatus(status);\n\n        try {\n            if ((cms != null) && (cms.getRequestContext().getCurrentUser() != null)) {\n                isGuest = isGuest\n                    && (cms.getRequestContext().getCurrentUser().isGuestUser()\n                        || cms.userInGroup(\n                            cms.getRequestContext().getCurrentUser().getName(),\n                            OpenCms.getDefaultUsers().getGroupGuests()));\n            }\n        } catch (CmsException e) {\n            // result is false\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        if (canWrite) {\n            res.setContentType(\"text/html\");\n            CmsRequestUtil.setNoCacheHeaders(res);\n            if ((status != 404)\n                && !isGuest\n                && (cms != null)\n                && !cms.getRequestContext().getCurrentProject().isOnlineProject()) {\n                try {\n                    res.setStatus(HttpServletResponse.SC_OK);\n                    res.getWriter().print(CmsErrorUI.getBootstrapPage(cms, t, req));\n                } catch (IOException e) {\n                    // can be ignored\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            } else {\n                try {\n                    res.sendError(status, t.toString());\n                } catch (IOException e) {\n                    // can be ignored\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            }\n        }\n    }","id":38468,"modified_method":"/**\n     * This method performs the error handling for OpenCms.<p>\n     *\n     * @param cms the current cms context, might be null !\n     * @param req the client request\n     * @param res the client response\n     * @param t the exception that occurred\n     */\n    private void errorHandling(CmsObject cms, HttpServletRequest req, HttpServletResponse res, Throwable t) {\n\n        // remove the controller attribute from the request\n        CmsFlexController.removeController(req);\n\n        boolean canWrite = (!res.isCommitted() && !res.containsHeader(\"Location\"));\n        int status = -1;\n        boolean isGuest = true;\n\n        if (t instanceof ServletException) {\n            ServletException s = (ServletException)t;\n            if (s.getRootCause() != null) {\n                t = s.getRootCause();\n            }\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        } else if (t instanceof CmsSecurityException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // access error - display login dialog\n            if (canWrite) {\n                try {\n                    m_authorizationHandler.requestAuthorization(req, res, getLoginFormURL(req, res));\n                } catch (IOException ioe) {\n                    LOG.debug(\"Error calling authorization handler.\", ioe);\n                }\n                return;\n            }\n        } else if (t instanceof CmsDbEntryNotFoundException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // user or group does not exist\n            status = HttpServletResponse.SC_SERVICE_UNAVAILABLE;\n            isGuest = false;\n        } else if (t instanceof CmsVfsResourceNotFoundException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // file not found - display 404 error.\n            status = HttpServletResponse.SC_NOT_FOUND;\n        } else if (t instanceof CmsException) {\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            if (t.getCause() != null) {\n                t = t.getCause();\n            }\n        } else if (t.getClass().getName().equals(\"org.apache.catalina.connector.ClientAbortException\")) {\n            // only log to debug channel any exceptions caused by a client abort - this is tomcat specific\n            LOG.debug(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        } else {\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        }\n\n        if (status < 1) {\n            // error code not set - set \"internal server error\" (500)\n            status = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n        }\n        res.setStatus(status);\n\n        try {\n            if ((cms != null) && (cms.getRequestContext().getCurrentUser() != null)) {\n                isGuest = isGuest\n                    && (cms.getRequestContext().getCurrentUser().isGuestUser()\n                        || cms.userInGroup(\n                            cms.getRequestContext().getCurrentUser().getName(),\n                            OpenCms.getDefaultUsers().getGroupGuests()));\n            }\n        } catch (CmsException e) {\n            // result is false\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        if (canWrite) {\n            res.setContentType(\"text/html\");\n            CmsRequestUtil.setNoCacheHeaders(res);\n            if ((status != 404)\n                && !isGuest\n                && (cms != null)\n                && !cms.getRequestContext().getCurrentProject().isOnlineProject()) {\n                try {\n                    res.setStatus(HttpServletResponse.SC_OK);\n                    res.getWriter().print(CmsErrorUI.getBootstrapPage(cms, t, req));\n                } catch (IOException e) {\n                    // can be ignored\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            } else {\n                try {\n                    res.sendError(status, t.toString());\n                } catch (IOException e) {\n                    // can be ignored\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            }\n        }\n    }","commit_id":"4da4c8ed5bdd57afeeb5ca61da139b5bf531b702","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Tries to load the custom error page at the given rootPath.\n     * @param cms {@link CmsObject} used for reading the resource (site root and uri get adjusted!)\n     * @param req the current request\n     * @param res the current response\n     * @param rootPath the VFS root path to the error page resource\n     * @return a flag, indicating if the error page could be loaded\n     */\n    private boolean loadCustomErrorPage(\n        CmsObject cms,\n        HttpServletRequest req,\n        HttpServletResponse res,\n        String rootPath) {\n\n        try {\n\n            // get the site of the error page resource\n            CmsSite errorSite = OpenCms.getSiteManager().getSiteForRootPath(rootPath);\n            cms.getRequestContext().setSiteRoot(errorSite.getSiteRoot());\n            String relPath = cms.getRequestContext().removeSiteRoot(rootPath);\n            cms.getRequestContext().setUri(relPath);\n\n            OpenCms.getResourceManager().loadResource(cms, cms.readResource(relPath), req, res);\n            return true;\n        } catch (Throwable e) {\n            // something went wrong log the exception and return false\n            LOG.error(e.getMessage(), e);\n            return false;\n        }\n    }","id":38469,"modified_method":"/**\n     * Tries to load the custom error page at the given rootPath.\n     * @param cms {@link CmsObject} used for reading the resource (site root and uri get adjusted!)\n     * @param req the current request\n     * @param res the current response\n     * @param rootPath the VFS root path to the error page resource\n     * @return a flag, indicating if the error page could be loaded\n     */\n    private boolean loadCustomErrorPage(\n        CmsObject cms,\n        HttpServletRequest req,\n        HttpServletResponse res,\n        String rootPath) {\n\n        try {\n\n            // get the site of the error page resource\n            CmsSite errorSite = OpenCms.getSiteManager().getSiteForRootPath(rootPath);\n            cms.getRequestContext().setSiteRoot(errorSite.getSiteRoot());\n            String relPath = cms.getRequestContext().removeSiteRoot(rootPath);\n            if (cms.existsResource(relPath)) {\n                cms.getRequestContext().setUri(relPath);\n                OpenCms.getResourceManager().loadResource(cms, cms.readResource(relPath), req, res);\n                return true;\n            } else {\n                return false;\n            }\n        } catch (Throwable e) {\n            // something went wrong log the exception and return false\n            LOG.error(e.getMessage(), e);\n            return false;\n        }\n    }","commit_id":"4da4c8ed5bdd57afeeb5ca61da139b5bf531b702","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.main.I_CmsRequestHandler#handle(HttpServletRequest, HttpServletResponse, String)\n     */\n    public void handle(HttpServletRequest req, HttpServletResponse res, String name)\n    throws IOException, ServletException {\n\n        int errorCode;\n        try {\n            errorCode = Integer.valueOf(name).intValue();\n        } catch (@SuppressWarnings(\"unused\") NumberFormatException nf) {\n            res.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n        switch (errorCode) {\n            case 404:\n                CmsObject cms = null;\n                CmsStaticExportData exportData = null;\n                try {\n                    // this will be set in the root site\n                    cms = OpenCms.initCmsObject(OpenCms.getDefaultUsers().getUserExport());\n                    exportData = OpenCms.getStaticExportManager().getExportData(req, cms);\n                } catch (CmsException e) {\n                    // unlikely to happen\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(\n                            Messages.get().getBundle().key(\n                                Messages.LOG_INIT_CMSOBJECT_IN_HANDLER_2,\n                                name,\n                                OpenCmsCore.getInstance().getPathInfo(req)),\n                            e);\n                    }\n                }\n                if (exportData != null) {\n                    try {\n                        // generate a static export request wrapper\n                        CmsStaticExportRequest exportReq = new CmsStaticExportRequest(req, exportData);\n                        // export the resource and set the response status according to the result\n                        res.setStatus(OpenCms.getStaticExportManager().export(exportReq, res, cms, exportData));\n                    } catch (Throwable t) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().getBundle().key(Messages.LOG_ERROR_EXPORT_1, exportData), t);\n                        }\n                        openErrorHandler(req, res, errorCode);\n                    }\n                } else {\n                    openErrorHandler(req, res, errorCode);\n                }\n                break;\n            default:\n                openErrorHandler(req, res, errorCode);\n        }\n    }","id":38470,"modified_method":"/**\n     * @see org.opencms.main.I_CmsRequestHandler#handle(HttpServletRequest, HttpServletResponse, String)\n     */\n    public void handle(HttpServletRequest req, HttpServletResponse res, String name)\n    throws IOException, ServletException {\n\n        int errorCode;\n        try {\n            errorCode = Integer.valueOf(name).intValue();\n        } catch (NumberFormatException nf) {\n            res.sendError(HttpServletResponse.SC_FORBIDDEN);\n            LOG.debug(\"Error parsing handler name.\", nf);\n            return;\n        }\n        switch (errorCode) {\n            case 404:\n                CmsObject cms = null;\n                CmsStaticExportData exportData = null;\n                try {\n                    // this will be set in the root site\n                    cms = OpenCms.initCmsObject(OpenCms.getDefaultUsers().getUserExport());\n                    exportData = OpenCms.getStaticExportManager().getExportData(req, cms);\n                } catch (CmsException e) {\n                    // unlikely to happen\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(\n                            Messages.get().getBundle().key(\n                                Messages.LOG_INIT_CMSOBJECT_IN_HANDLER_2,\n                                name,\n                                OpenCmsCore.getInstance().getPathInfo(req)),\n                            e);\n                    }\n                }\n                if (exportData != null) {\n                    try {\n                        // generate a static export request wrapper\n                        CmsStaticExportRequest exportReq = new CmsStaticExportRequest(req, exportData);\n                        // export the resource and set the response status according to the result\n                        res.setStatus(OpenCms.getStaticExportManager().export(exportReq, res, cms, exportData));\n                    } catch (Throwable t) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().getBundle().key(Messages.LOG_ERROR_EXPORT_1, exportData), t);\n                        }\n                        openErrorHandler(req, res, errorCode);\n                    }\n                } else {\n                    openErrorHandler(req, res, errorCode);\n                }\n                break;\n            default:\n                openErrorHandler(req, res, errorCode);\n        }\n    }","commit_id":"4da4c8ed5bdd57afeeb5ca61da139b5bf531b702","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initialized the search request and sets the local parameter.<p>\n     *\n     * @param req the servlet request\n     * @param res the servlet response\n     *\n     * @throws CmsException if something goes wrong\n     * @throws Exception if something goes wrong\n     * @throws CmsSearchException if something goes wrong\n     * @throws IOException if something goes wrong\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Context initializeRequest(HttpServletRequest req, HttpServletResponse res)\n    throws CmsException, Exception, CmsSearchException, IOException {\n\n        Context context = new Context();\n        context.m_cms = getCmsObject(req);\n        context.m_params = CmsRequestUtil.createParameterMap(req.getParameterMap());\n        context.m_index = CmsSearchManager.getIndexSolr(context.m_cms, context.m_params);\n\n        if (context.m_index != null) {\n            context.m_query = new CmsSolrQuery(context.m_cms, context.m_params);\n        } else {\n            res.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            String indexName = context.m_params.get(PARAM_CORE) != null\n            ? context.m_params.get(PARAM_CORE)[0]\n            : (context.m_params.get(PARAM_INDEX) != null ? context.m_params.get(PARAM_INDEX)[0] : null);\n            String message = Messages.get().getBundle().key(Messages.GUI_SOLR_INDEX_NOT_FOUND_1, indexName);\n            res.getWriter().println(Messages.get().getBundle().key(Messages.GUI_SOLR_ERROR_HTML_1, message));\n        }\n\n        return context;\n    }","id":38471,"modified_method":"/**\n     * Initialized the search request and sets the local parameter.<p>\n     *\n     * @param req the servlet request\n     * @param res the servlet response\n     *\n     * @return the generated context\n     *\n     * @throws CmsException if something goes wrong\n     * @throws Exception if something goes wrong\n     * @throws CmsSearchException if something goes wrong\n     * @throws IOException if something goes wrong\n     */\n    protected Context initializeRequest(HttpServletRequest req, HttpServletResponse res)\n    throws CmsException, Exception, CmsSearchException, IOException {\n\n        Context context = new Context();\n        context.m_cms = getCmsObject(req);\n        context.m_params = CmsRequestUtil.createParameterMap(req.getParameterMap());\n        context.m_index = CmsSearchManager.getIndexSolr(context.m_cms, context.m_params);\n\n        if (context.m_index != null) {\n            context.m_query = new CmsSolrQuery(context.m_cms, context.m_params);\n        } else {\n            res.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            String indexName = context.m_params.get(PARAM_CORE) != null\n            ? context.m_params.get(PARAM_CORE)[0]\n            : (context.m_params.get(PARAM_INDEX) != null ? context.m_params.get(PARAM_INDEX)[0] : null);\n            String message = Messages.get().getBundle().key(Messages.GUI_SOLR_INDEX_NOT_FOUND_1, indexName);\n            res.getWriter().println(Messages.get().getBundle().key(Messages.GUI_SOLR_ERROR_HTML_1, message));\n        }\n\n        return context;\n    }","commit_id":"4da4c8ed5bdd57afeeb5ca61da139b5bf531b702","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the ade include HTML to insert in the page beginning.<p>\n     * \n     * @param cms the current cms context\n     * @param req the current request\n     *  \n     * @return the ade include HTML to insert in the page beginning\n     */\n    public static String getAdeIncludes(CmsObject cms, ServletRequest req) {\n\n        // check if the selected include file is available in the cache\n        CmsMemoryObjectCache cache = CmsMemoryObjectCache.getInstance();\n        CmsLinkManager linkMan = OpenCms.getLinkManager();\n\n        String headerInclude = (String)cache.getCachedObject(CmsJspTagEnableAde.class, INCLUDE_FILE);\n        if (headerInclude == null) {\n            // the file is not available in the cache\n            try {\n                CmsFile file = cms.readFile(INCLUDE_FILE);\n                // get the encoding for the resource\n                CmsProperty property = cms.readPropertyObject(\n                    file,\n                    CmsPropertyDefinition.PROPERTY_CONTENT_ENCODING,\n                    true);\n                String encoding = property.getValue(OpenCms.getSystemInfo().getDefaultEncoding());\n                // create a String with the right encoding\n                headerInclude = CmsEncoder.createString(file.getContents(), encoding);\n\n                // resolve macros in include header\n                CmsMacroResolver resolver = CmsMacroResolver.newInstance();\n                resolver.setKeepEmptyMacros(true); // be sure request macros stay there\n                String editorUri = linkMan.substituteLink(cms, EDITOR_URI);\n                resolver.addMacro(MACRO_EDITOR_URI, editorUri);\n                String serverUri = linkMan.substituteLink(cms, ADE_SERVER_URI);\n                resolver.addMacro(MACRO_SERVER_URI, serverUri);\n                String publishUri = linkMan.substituteLink(cms, PUBLISH_SERVER_URI);\n                resolver.addMacro(MACRO_PUBLISH_URI, publishUri);\n                String galleryServerUri = linkMan.substituteLink(cms, CmsGallerySearchServer.ADVANCED_GALLERY_PATH);\n                resolver.addMacro(MACRO_GALLERY_SERVER_URI, galleryServerUri);\n                resolver.addMacro(MACRO_GALLERY_SERVER_PATH, CmsGallerySearchServer.ADVANCED_GALLERY_PATH);\n\n                String skinUri = CmsWorkplace.getSkinUri();\n                resolver.addMacro(MACRO_SKIN_URI, skinUri);\n                resolver.addMacro(MACRO_MESSAGES_URI, linkMan.substituteLink(cms, ADE_MESSAGES_URI));\n\n                headerInclude = resolver.resolveMacros(headerInclude);\n\n                // store this in the cache\n                cache.putCachedObject(CmsJspTagEnableAde.class, INCLUDE_FILE, headerInclude);\n\n            } catch (CmsException e) {\n                // this should better not happen\n                headerInclude = \"\";\n                LOG.error(Messages.get().getBundle().key(Messages.LOG_DIRECT_EDIT_NO_HEADER_1, INCLUDE_FILE), e);\n            }\n        }\n\n        // these macros are request specific\n        CmsMacroResolver resolver = CmsMacroResolver.newInstance();\n        try {\n            String currentUri = cms.getRequestContext().getUri();\n\n            // get searchable types for gallery and lookup additional java-script for handling inside the advanced galleries\n            Iterator<CmsResource> resIt = OpenCms.getADEManager().getSearchableResourceTypes(cms, currentUri, req).iterator();\n            List<I_CmsResourceType> searchableTypes = new ArrayList<I_CmsResourceType>();\n            while (resIt.hasNext()) {\n                CmsResource resource = resIt.next();\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n                searchableTypes.add(type);\n            }\n            resolver.addMacro(\n                MACRO_GALLERY_ADDITIONAL_JAVASCRIPT,\n                CmsGallerySearchServer.getAdditionalJavascriptForTypes(searchableTypes));\n\n            CmsResource containerPage = cms.readResource(currentUri);\n            if (!CmsResourceTypeXmlContainerPage.isContainerPage(containerPage)) {\n                // container page is used as template\n                String cntPagePath = cms.readPropertyObject(\n                    containerPage,\n                    CmsPropertyDefinition.PROPERTY_TEMPLATE_ELEMENTS,\n                    true).getValue(\"\");\n                try {\n                    containerPage = cms.readResource(cntPagePath);\n                } catch (CmsException e) {\n                    if (!LOG.isDebugEnabled()) {\n                        LOG.warn(e.getLocalizedMessage());\n                    }\n                    LOG.debug(e.getLocalizedMessage(), e);\n                }\n            } else if (req.getParameter(CmsContainerPageBean.TEMPLATE_ELEMENT_PARAMETER) != null) {\n                CmsUUID id = new CmsUUID(req.getParameter(CmsContainerPageBean.TEMPLATE_ELEMENT_PARAMETER));\n                currentUri = cms.getSitePath(cms.readResource(id));\n            }\n            CmsProperty sitemapProperty = cms.readPropertyObject(\n                containerPage,\n                CmsPropertyDefinition.PROPERTY_SITEMAP,\n                true);\n            String sitemapUri = linkMan.substituteLink(cms, sitemapProperty.getValue());\n            resolver.addMacro(MACRO_SITEMAP_URI, sitemapUri);\n            String containerPageUri = cms.getSitePath(containerPage);\n            resolver.addMacro(MACRO_CURRENT_URI, currentUri);\n            resolver.addMacro(MACRO_CURRENT_CNTPAGE, containerPageUri);\n            String noEditReason = new CmsResourceUtil(cms, containerPage).getNoEditReason(OpenCms.getWorkplaceManager().getWorkplaceLocale(\n                cms));\n            resolver.addMacro(MACRO_NO_EDIT_REASON, CmsEncoder.escapeHtml(noEditReason));\n        } catch (Exception e) {\n            if (!LOG.isDebugEnabled()) {\n                LOG.warn(e.getLocalizedMessage());\n            }\n            LOG.debug(e.getLocalizedMessage(), e);\n        }\n        resolver.addMacro(MACRO_CURRENT_LOCALE, cms.getRequestContext().getLocale().toString());\n\n        headerInclude = resolver.resolveMacros(headerInclude);\n\n        return headerInclude;\n    }","id":38472,"modified_method":"/**\n     * Returns the ade include HTML to insert in the page beginning.<p>\n     * \n     * @param cms the current cms context\n     * @param req the current request\n     *  \n     * @return the ade include HTML to insert in the page beginning\n     */\n    public static String getAdeIncludes(CmsObject cms, ServletRequest req) {\n\n        // check if the selected include file is available in the cache\n        CmsMemoryObjectCache cache = CmsMemoryObjectCache.getInstance();\n        CmsLinkManager linkMan = OpenCms.getLinkManager();\n\n        String headerInclude = (String)cache.getCachedObject(CmsJspTagEnableAde.class, INCLUDE_FILE);\n        if (headerInclude == null) {\n            // the file is not available in the cache\n            try {\n                CmsFile file = cms.readFile(INCLUDE_FILE);\n                // get the encoding for the resource\n                CmsProperty property = cms.readPropertyObject(\n                    file,\n                    CmsPropertyDefinition.PROPERTY_CONTENT_ENCODING,\n                    true);\n                String encoding = property.getValue(OpenCms.getSystemInfo().getDefaultEncoding());\n                // create a String with the right encoding\n                headerInclude = CmsEncoder.createString(file.getContents(), encoding);\n\n                // resolve macros in include header\n                CmsMacroResolver resolver = CmsMacroResolver.newInstance();\n                resolver.setKeepEmptyMacros(true); // be sure request macros stay there\n                String editorUri = linkMan.substituteLink(cms, EDITOR_URI);\n                resolver.addMacro(MACRO_EDITOR_URI, editorUri);\n                String serverUri = linkMan.substituteLink(cms, ADE_SERVER_URI);\n                resolver.addMacro(MACRO_SERVER_URI, serverUri);\n                String publishUri = linkMan.substituteLink(cms, PUBLISH_SERVER_URI);\n                resolver.addMacro(MACRO_PUBLISH_URI, publishUri);\n                String galleryServerUri = linkMan.substituteLink(cms, CmsGallerySearchServer.ADVANCED_GALLERY_PATH);\n                resolver.addMacro(MACRO_GALLERY_SERVER_URI, galleryServerUri);\n                resolver.addMacro(MACRO_GALLERY_SERVER_PATH, CmsGallerySearchServer.ADVANCED_GALLERY_PATH);\n\n                String skinUri = CmsWorkplace.getSkinUri();\n                resolver.addMacro(MACRO_SKIN_URI, skinUri);\n                resolver.addMacro(MACRO_MESSAGES_URI, linkMan.substituteLink(cms, ADE_MESSAGES_URI));\n\n                headerInclude = resolver.resolveMacros(headerInclude);\n\n                // store this in the cache\n                cache.putCachedObject(CmsJspTagEnableAde.class, INCLUDE_FILE, headerInclude);\n\n            } catch (CmsException e) {\n                // this should better not happen\n                headerInclude = \"\";\n                LOG.error(Messages.get().getBundle().key(Messages.LOG_DIRECT_EDIT_NO_HEADER_1, INCLUDE_FILE), e);\n            }\n        }\n\n        // these macros are request specific\n        CmsMacroResolver resolver = CmsMacroResolver.newInstance();\n        try {\n            String currentUri = cms.getRequestContext().getUri();\n\n            // get searchable types for gallery and lookup additional java-script for handling inside the advanced galleries\n            Iterator<CmsResource> resIt = OpenCms.getADEManager().getSearchableResourceTypes(cms, currentUri, req).iterator();\n            List<I_CmsResourceType> searchableTypes = new ArrayList<I_CmsResourceType>();\n            while (resIt.hasNext()) {\n                CmsResource resource = resIt.next();\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(resource);\n                searchableTypes.add(type);\n            }\n            resolver.addMacro(\n                MACRO_GALLERY_ADDITIONAL_JAVASCRIPT,\n                CmsGallerySearchServer.getAdditionalJavascriptForTypes(searchableTypes));\n\n            CmsResource containerPage = cms.readResource(currentUri);\n            if (!CmsResourceTypeXmlContainerPage.isContainerPage(containerPage)) {\n                // container page is used as template\n                String cntPagePath = cms.readPropertyObject(\n                    containerPage,\n                    CmsPropertyDefinition.PROPERTY_TEMPLATE_ELEMENTS,\n                    true).getValue(\"\");\n                try {\n                    containerPage = cms.readResource(cntPagePath);\n                } catch (CmsException e) {\n                    if (!LOG.isDebugEnabled()) {\n                        LOG.warn(e.getLocalizedMessage());\n                    }\n                    LOG.debug(e.getLocalizedMessage(), e);\n                }\n            } else if (OpenCms.getSitemapManager().getRuntimeInfo(req) != null) {\n                CmsUUID id = OpenCms.getSitemapManager().getRuntimeInfo(req).getContentId();\n                if (id != null) {\n                    currentUri = cms.getSitePath(cms.readResource(id));\n                }\n            }\n            CmsProperty sitemapProperty = cms.readPropertyObject(\n                containerPage,\n                CmsPropertyDefinition.PROPERTY_SITEMAP,\n                true);\n            String sitemapUri = linkMan.substituteLink(cms, sitemapProperty.getValue());\n            resolver.addMacro(MACRO_SITEMAP_URI, sitemapUri);\n            String containerPageUri = cms.getSitePath(containerPage);\n            resolver.addMacro(MACRO_CURRENT_URI, currentUri);\n            resolver.addMacro(MACRO_CURRENT_CNTPAGE, containerPageUri);\n            String noEditReason = new CmsResourceUtil(cms, containerPage).getNoEditReason(OpenCms.getWorkplaceManager().getWorkplaceLocale(\n                cms));\n            resolver.addMacro(MACRO_NO_EDIT_REASON, CmsEncoder.escapeHtml(noEditReason));\n        } catch (Exception e) {\n            if (!LOG.isDebugEnabled()) {\n                LOG.warn(e.getLocalizedMessage());\n            }\n            LOG.debug(e.getLocalizedMessage(), e);\n        }\n        resolver.addMacro(MACRO_CURRENT_LOCALE, cms.getRequestContext().getLocale().toString());\n\n        headerInclude = resolver.resolveMacros(headerInclude);\n\n        return headerInclude;\n    }","commit_id":"de7829d11d50effa4dec5e197d383240ad5b71c5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a list box entry created from the given XML content using the configured rules of this content mapping.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param content the XML content to create the list box entry from\n     * @param locale the locale to use in the XML content\n     * \n     * @return a list box entry created from the given XML content using the configured rules of this content mapping\n     */\n    public CmsListBoxEntry getEntryFromXmlContent(CmsObject cms, CmsXmlContent content, Locale locale) {\n\n        if ((content == null) || (locale == null) || !content.hasLocale(locale)) {\n            // no entry can be created if input is silly\n            return null;\n        }\n\n        // get all configured mappings\n        Set<Map.Entry<String, CmsListBoxFieldMapping>> mappings = m_mappings.entrySet();\n        // create the empty syndication entry\n        CmsListBoxEntry result = new CmsListBoxEntry();\n        boolean hasTitle = false;\n\n        Iterator<Map.Entry<String, CmsListBoxFieldMapping>> i = mappings.iterator();\n        String link = null;\n        Date date = null;\n        while (i.hasNext()) {\n            Map.Entry<String, CmsListBoxFieldMapping> e = i.next();\n            String listBoxField = e.getKey();\n            CmsListBoxFieldMapping mapping = e.getValue();\n\n            I_CmsXmlContentValue xmlContentValue = null;\n            List<String> xmlFields = mapping.getXmlFields();\n            for (int j = 0, size = xmlFields.size(); j < size; j++) {\n                String xmlField = xmlFields.get(j);\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(xmlField)) {\n                    xmlContentValue = content.getValue(xmlField, locale);\n                    if (xmlContentValue != null) {\n                        // found a matching XML content node\n                        break;\n                    }\n                }\n            }\n            String value = null;\n            if (xmlContentValue != null) {\n                // value was found in the content\n                value = xmlContentValue.getStringValue(cms);\n            } else if (mapping.hasDefaultValue()) {\n                // value not found in content, use default value\n                value = mapping.getDefaultValue();\n            }\n            if (value != null) {\n                if (mapping.hasMaxLenghtLimit()) {\n                    // apply length restriction if required\n                    value = applyLengthRestriction(cms, xmlContentValue, value, mapping.getMaxLenght());\n                }\n                // a value to map was found\n                int pos = MAPPINGS_LIST.indexOf(listBoxField);\n                switch (pos) {\n                    case 0: // Title\n                        result.setTitle(value);\n                        hasTitle = true;\n                        break;\n                    case 1: // Author\n                        result.setAuthor(value);\n                        break;\n                    case 2: // Description\n                        result.setDescription(value);\n                        break;\n                    case 3: // Date\n                        date = convertToDate(cms, content.getFile(), xmlContentValue, value);\n                        if (date != null) {\n                            result.setDate(date);\n                        }\n                        break;\n                    case 4: // Link\n                        // use link as provided in content\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            link = OpenCms.getLinkManager().getServerLink(cms, value);\n                        }\n                        break;\n                    case 5: // Image\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            result.setImage(value);\n                        }\n                        break;\n                    default: // unknown, this cannot happen as all mappings are checked when created            \n                }\n            }\n        }\n\n        if (hasTitle) {\n            // we need at least an entry and an description\n            if (link == null) {\n                // calculate the link                \n                link = OpenCms.getLinkManager().getServerLink(cms, m_facade);\n                link = CmsRequestUtil.appendParameter(\n                    link,\n                    CmsContainerPageBean.TEMPLATE_ELEMENT_PARAMETER,\n                    content.getFile().getStructureId().toString());\n            }\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(link)) {\n                result.setLink(link);\n            }\n        } else {\n            // required mappings are not available\n            result = null;\n        }\n        return result;\n    }","id":38473,"modified_method":"/**\n     * Returns a list box entry created from the given XML content using the configured rules of this content mapping.<p>\n     * \n     * @param cms the current users OpenCms context\n     * @param content the XML content to create the list box entry from\n     * @param locale the locale to use in the XML content\n     * \n     * @return a list box entry created from the given XML content using the configured rules of this content mapping\n     */\n    public CmsListBoxEntry getEntryFromXmlContent(CmsObject cms, CmsXmlContent content, Locale locale) {\n\n        if ((content == null) || (locale == null) || !content.hasLocale(locale)) {\n            // no entry can be created if input is silly\n            return null;\n        }\n\n        // get all configured mappings\n        Set<Map.Entry<String, CmsListBoxFieldMapping>> mappings = m_mappings.entrySet();\n        // create the empty syndication entry\n        CmsListBoxEntry result = new CmsListBoxEntry();\n        boolean hasTitle = false;\n\n        Iterator<Map.Entry<String, CmsListBoxFieldMapping>> i = mappings.iterator();\n        String link = null;\n        Date date = null;\n        while (i.hasNext()) {\n            Map.Entry<String, CmsListBoxFieldMapping> e = i.next();\n            String listBoxField = e.getKey();\n            CmsListBoxFieldMapping mapping = e.getValue();\n\n            I_CmsXmlContentValue xmlContentValue = null;\n            List<String> xmlFields = mapping.getXmlFields();\n            for (int j = 0, size = xmlFields.size(); j < size; j++) {\n                String xmlField = xmlFields.get(j);\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(xmlField)) {\n                    xmlContentValue = content.getValue(xmlField, locale);\n                    if (xmlContentValue != null) {\n                        // found a matching XML content node\n                        break;\n                    }\n                }\n            }\n            String value = null;\n            if (xmlContentValue != null) {\n                // value was found in the content\n                value = xmlContentValue.getStringValue(cms);\n            } else if (mapping.hasDefaultValue()) {\n                // value not found in content, use default value\n                value = mapping.getDefaultValue();\n            }\n            if (value != null) {\n                if (mapping.hasMaxLenghtLimit()) {\n                    // apply length restriction if required\n                    value = applyLengthRestriction(cms, xmlContentValue, value, mapping.getMaxLenght());\n                }\n                // a value to map was found\n                int pos = MAPPINGS_LIST.indexOf(listBoxField);\n                switch (pos) {\n                    case 0: // Title\n                        result.setTitle(value);\n                        hasTitle = true;\n                        break;\n                    case 1: // Author\n                        result.setAuthor(value);\n                        break;\n                    case 2: // Description\n                        result.setDescription(value);\n                        break;\n                    case 3: // Date\n                        date = convertToDate(cms, content.getFile(), xmlContentValue, value);\n                        if (date != null) {\n                            result.setDate(date);\n                        }\n                        break;\n                    case 4: // Link\n                        // use link as provided in content\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            link = OpenCms.getLinkManager().getServerLink(cms, value);\n                        }\n                        break;\n                    case 5: // Image\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(value)) {\n                            result.setImage(value);\n                        }\n                        break;\n                    default: // unknown, this cannot happen as all mappings are checked when created            \n                }\n            }\n        }\n\n        if (hasTitle) {\n            // we need at least an entry and an description\n            if (link == null) {\n                // calculate the link                \n                link = OpenCms.getLinkManager().getServerLink(cms, m_facade);\n                link += content.getFile().getStructureId().toString() + \"/\";\n            }\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(link)) {\n                result.setLink(link);\n            }\n        } else {\n            // required mappings are not available\n            result = null;\n        }\n        return result;\n    }","commit_id":"de7829d11d50effa4dec5e197d383240ad5b71c5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Reads the current sitemap URI from the request.<p>\n     * \n     * @param req the servlet request\n     * \n     * @return the sitemap URI, or <code>null<\/code> if the sitemap is not used\n     */\n    public String getCurrentUri(ServletRequest req) {\n\n        return (String)req.getAttribute(ATTR_SITEMAP_CURRENT_URI);\n    }","id":38474,"modified_method":"/**\n     * Reads the current sitemap URI bean from the request.<p>\n     * \n     * @param req the servlet request\n     * \n     * @return the sitemap URI bean, or <code>null<\/code> if not found\n     */\n    public CmsSiteEntryBean getRuntimeInfo(ServletRequest req) {\n\n        return (CmsSiteEntryBean)req.getAttribute(ATTR_SITEMAP_ENTRY);\n    }","commit_id":"de7829d11d50effa4dec5e197d383240ad5b71c5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the site entry for the given URI, or <code>null<\/code> if not found.<p> \n     * \n     * @param cms the current CMS context\n     * @param uri the URI to look for\n     * \n     * @return the site entry for the given URI, or <code>null<\/code> if not found\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public CmsSiteEntryBean getEntryForUri(CmsObject cms, String uri) throws CmsException {\n\n        String path = cms.getRequestContext().addSiteRoot(uri);\n\n        // check the cache\n        boolean online = cms.getRequestContext().currentProject().isOnlineProject();\n        CmsSiteEntryBean uriEntry = m_cache.getUri(path, online);\n        if (uriEntry != null) {\n            // found in cache\n            return uriEntry;\n        }\n\n        // check the missed cache\n        if (m_cache.getMissingUri(path, online) != null) {\n            // already marked as not found\n            return null;\n        }\n\n        // get it\n        EntryData data = getEntry(cms, uri, online, false);\n        if (data == null) {\n            // cache the missed attempt\n            m_cache.setMissingUri(path, online);\n            return null;\n        }\n\n        // cache the found entry\n        uriEntry = data.getEntry();\n        m_cache.setUri(path, uriEntry, online);\n\n        return uriEntry;\n    }","id":38475,"modified_method":"/**\n     * Returns the site entry for the given URI, or <code>null<\/code> if not found.<p> \n     * \n     * @param cms the current CMS context\n     * @param uri the URI to look for\n     * \n     * @return the site entry for the given URI, or <code>null<\/code> if not found\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public CmsSiteEntryBean getEntryForUri(CmsObject cms, String uri) throws CmsException {\n\n        String path = cms.getRequestContext().addSiteRoot(uri);\n\n        // check the cache\n        boolean online = cms.getRequestContext().currentProject().isOnlineProject();\n        CmsSiteEntryBean uriEntry = m_cache.getUri(path, online);\n        if (uriEntry != null) {\n            // found in cache\n            return uriEntry;\n        }\n\n        // check the missed cache\n        if (m_cache.getMissingUri(path, online) != null) {\n            // already marked as not found\n            return null;\n        }\n\n        // get it\n        uriEntry = getEntry(cms, uri, online);\n        if (uriEntry == null) {\n            // cache the missed attempt\n            m_cache.setMissingUri(path, online);\n        } else {\n            // cache the found entry\n            m_cache.setUri(path, uriEntry, online);\n        }\n\n        return uriEntry;\n    }","commit_id":"de7829d11d50effa4dec5e197d383240ad5b71c5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the default sitemap properties.<p>\n     * \n     * @param cms the current cms context\n     * @param resource the resource, should a sitemap\n     * @param online if online or offline, the same as in the cms context, but just to not access it again\n     * \n     * @return the default sitemap properties\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected Map<String, String> getDefaultProperties(CmsObject cms, CmsResource resource, boolean online)\n    throws CmsException {\n\n        Map<String, String> defProps = m_cache.getDefaultProps(online);\n        if (defProps != null) {\n            return defProps;\n        }\n        defProps = CmsXmlContentProperty.mergeDefaults(cms, resource, Collections.<String, String> emptyMap());\n        m_cache.setDefaultProps(defProps, online);\n        return defProps;\n    }","id":38476,"modified_method":"/**\n     * Returns the default sitemap properties.<p>\n     * \n     * @param cms the current cms context\n     * \n     * @return the default sitemap properties\n     */\n    public Map<String, String> getDefaultProperties(CmsObject cms) {\n\n        boolean online = cms.getRequestContext().currentProject().isOnlineProject();\n        Map<String, String> defProps = m_cache.getDefaultProps(online);\n        if (defProps != null) {\n            return defProps;\n        }\n        // default properties are not resource dependent, \n        // they are system wide, defined in the XSD\n        // but we need a resource to get to the content handler\n        // so get the first sitemap we can find\n        List<CmsResource> sitemaps = new ArrayList<CmsResource>();\n        try {\n            sitemaps = cms.readResources(\n                \"/\",\n                CmsResourceFilter.requireType(CmsResourceTypeXmlSitemap.getStaticTypeId()),\n                true);\n        } catch (CmsException e) {\n            // should never happen\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n        if (sitemaps.isEmpty()) {\n            // should never happen\n            defProps = new HashMap<String, String>();\n        } else {\n            CmsResource resource = sitemaps.get(0);\n            defProps = CmsXmlContentProperty.mergeDefaults(cms, resource, Collections.<String, String> emptyMap());\n        }\n        m_cache.setDefaultProps(defProps, online);\n        return defProps;\n    }","commit_id":"de7829d11d50effa4dec5e197d383240ad5b71c5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the site entry for the given URI, or <code>null<\/code> if not found.<p> \n     * \n     * @param cms the current CMS context\n     * @param uri the URI to look for\n     * @param online if online or offline, the same than in the cms context, but just to not access it again\n     * @param collectProperties if to collect parent entries properties\n     * \n     * @return the site entry for the given URI, or <code>null<\/code> if not found\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected EntryData getEntry(CmsObject cms, String uri, boolean online, boolean collectProperties)\n    throws CmsException {\n\n        CmsUUID logId = null;\n        if (LOG.isDebugEnabled()) {\n            logId = new CmsUUID(); // unique id to identify the request\n            LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_ENTRY_3, logId, uri, Boolean.valueOf(online)).key());\n        }\n        // find the sitemap\n        CmsXmlSitemap sitemapXml = null;\n        String sitemapFolder = cms.getRequestContext().removeSiteRoot(uri);\n        String originalSitemapFolder = sitemapFolder;\n        while (sitemapFolder != null) {\n            if (cms.existsResource(sitemapFolder)) {\n                String prop = cms.readPropertyObject(sitemapFolder, CmsPropertyDefinition.PROPERTY_SITEMAP, true).getValue();\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(prop)) {\n                    if (cms.getRequestContext().getSiteRoot().equals(\"\")) {\n                        // adjust the property path, since it will be a site path, and we are in the root\n                        CmsSite site = OpenCms.getSiteManager().getSiteForRootPath(uri);\n                        if (site != null) {\n                            prop = site.getSiteRoot() + prop;\n                        }\n                    }\n                    if (cms.existsResource(prop)) {\n                        sitemapXml = CmsXmlSitemapFactory.unmarshal(cms, cms.readResource(prop));\n                        break;\n                    }\n                }\n            }\n            sitemapFolder = CmsResource.getParentFolder(sitemapFolder);\n        }\n        if ((sitemapXml == null) || (sitemapFolder == null)) {\n            // sitemap not found \n            return null;\n        }\n        CmsSitemapBean sitemap = sitemapXml.getSitemap(cms, cms.getRequestContext().getLocale());\n        if ((sitemap == null) || sitemap.getSiteEntries().isEmpty()) {\n            return null;\n        }\n        LinkedList<String> entryPaths = new LinkedList<String>(CmsStringUtil.splitAsList(\n            normalizePath(originalSitemapFolder.substring(sitemapFolder.length())),\n            \"/\"));\n        // property collection\n        Map<String, String> properties = new HashMap<String, String>();\n        if (collectProperties) {\n            // start with the root entry properties\n            properties.putAll(sitemap.getSiteEntries().get(0).getProperties());\n        }\n        // special case for '/'\n        if (entryPaths.isEmpty()) {\n            if (sitemap.getSiteEntries().isEmpty()) {\n                return null;\n            }\n            CmsSiteEntryBean entry = sitemap.getSiteEntries().get(0);\n            entry.setPosition(0);\n            LOG.debug(Messages.get().container(\n                Messages.LOG_DEBUG_SITEMAP_FOUND_3,\n                logId,\n                new Integer(0),\n                entry.getName()).key());\n            return new EntryData(entry, properties, sitemapXml);\n        }\n        // get started\n        String uriPath = cms.getRequestContext().getSiteRoot() + sitemapFolder;\n        List<CmsSiteEntryBean> subEntries = sitemap.getSiteEntries().get(0).getSubEntries();\n        boolean finished = false;\n        while (!finished) {\n            String name = entryPaths.removeFirst();\n            LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_ENTRY_CHECK_2, logId, uriPath).key());\n            uriPath += \"/\" + name;\n            // check the missed cache\n            if (m_cache.getMissingUri(uriPath, online) != null) {\n                // already marked as not found\n                LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_ENTRY_MISSING_2, logId, uriPath).key());\n                return null;\n            }\n            int position = 0;\n            int size = subEntries.size();\n            for (; position < size; position++) {\n                CmsSiteEntryBean entry = subEntries.get(position);\n                if (!entry.getName().equals(name)) {\n                    // no match\n                    LOG.debug(Messages.get().container(\n                        Messages.LOG_DEBUG_SITEMAP_NO_MATCH_3,\n                        logId,\n                        new Integer(position),\n                        entry.getName()).key());\n                    continue;\n                }\n                LOG.debug(Messages.get().container(\n                    Messages.LOG_DEBUG_SITEMAP_MATCH_3,\n                    logId,\n                    new Integer(position),\n                    entry.getName()).key());\n                if (collectProperties) {\n                    properties.putAll(entry.getProperties());\n                }\n                if (entryPaths.isEmpty()) {\n                    // if nothing left, we got a match\n                    LOG.debug(Messages.get().container(\n                        Messages.LOG_DEBUG_SITEMAP_FOUND_3,\n                        logId,\n                        new Integer(position),\n                        entry.getName()).key());\n                    entry.setPosition(position);\n                    return new EntryData(entry, properties, sitemapXml);\n                } else {\n                    // continue with sub-entries\n                    subEntries = entry.getSubEntries();\n                    if (subEntries.isEmpty()) {\n                        // check sitemap property\n                        String subSitemapId = entry.getProperties().get(CmsSitemapManager.PROPERTY_SITEMAP);\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(subSitemapId)) {\n                            // switch to sub-sitemap\n                            CmsResource subSitemap = cms.readResource(new CmsUUID(subSitemapId));\n                            LOG.debug(Messages.get().container(\n                                Messages.LOG_DEBUG_SITEMAP_SUBSITEMAP_2,\n                                logId,\n                                cms.getSitePath(subSitemap)).key());\n                            sitemapXml = CmsXmlSitemapFactory.unmarshal(cms, subSitemap);\n                            sitemap = sitemapXml.getSitemap(cms, cms.getRequestContext().getLocale());\n                            if (sitemap == null) {\n                                // no sitemap found\n                                return null;\n                            }\n                            subEntries = sitemap.getSiteEntries();\n                        }\n                    }\n                    finished = subEntries.isEmpty();\n                    if (finished) {\n                        LOG.debug(Messages.get().container(\n                            Messages.LOG_DEBUG_SITEMAP_NO_SUBENTRIES_3,\n                            logId,\n                            new Integer(position),\n                            entry.getName()).key());\n                    }\n                }\n                break;\n            }\n            if (position == size) {\n                // not found\n                finished = true;\n                LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_NOT_FOUND_2, logId, uriPath).key());\n            }\n        }\n\n        return null;\n    }","id":38477,"modified_method":"/**\n     * Returns the site entry for the given URI, or <code>null<\/code> if not found.<p> \n     * \n     * @param cms the current CMS context\n     * @param uri the URI to look for\n     * @param online if online or offline, the same than in the cms context, but just to not access it again\n     * \n     * @return the site entry for the given URI, or <code>null<\/code> if not found\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected CmsSiteEntryBean getEntry(CmsObject cms, String uri, boolean online) throws CmsException {\n\n        CmsUUID logId = null;\n        if (LOG.isDebugEnabled()) {\n            logId = new CmsUUID(); // unique id to identify the request\n            LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_ENTRY_3, logId, uri, Boolean.valueOf(online)).key());\n        }\n        // find the sitemap\n        CmsXmlSitemap sitemapXml = null;\n        String sitemapFolder = cms.getRequestContext().removeSiteRoot(uri);\n        String originalSitemapFolder = sitemapFolder;\n        boolean isRootSite = cms.getRequestContext().getSiteRoot().equals(\"\");\n        CmsSite site = null;\n        if (isRootSite) {\n            site = OpenCms.getSiteManager().getSiteForRootPath(uri);\n        }\n        while (sitemapFolder != null) {\n            if (cms.existsResource(sitemapFolder)) {\n                String prop = cms.readPropertyObject(sitemapFolder, CmsPropertyDefinition.PROPERTY_SITEMAP, true).getValue();\n                if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(prop)) {\n                    if (isRootSite && (site != null)) {\n                        // adjust the property path, since it will be a site path, and we are in the root\n                        prop = site.getSiteRoot() + prop;\n                    }\n                    if (cms.existsResource(prop)) {\n                        sitemapXml = CmsXmlSitemapFactory.unmarshal(cms, cms.readResource(prop));\n                        break;\n                    }\n                }\n            }\n            sitemapFolder = CmsResource.getParentFolder(sitemapFolder);\n        }\n        if ((sitemapXml == null) || (sitemapFolder == null)) {\n            // sitemap not found \n            return null;\n        }\n        CmsSitemapBean sitemap = sitemapXml.getSitemap(cms, cms.getRequestContext().getLocale());\n        if ((sitemap == null) || sitemap.getSiteEntries().isEmpty()) {\n            // sitemap is empty\n            return null;\n        }\n        LinkedList<String> entryPaths = new LinkedList<String>(CmsStringUtil.splitAsList(\n            normalizePath(originalSitemapFolder.substring(sitemapFolder.length())),\n            \"/\"));\n        // property collection\n        Map<String, String> properties = new HashMap<String, String>();\n        // start with the root entry properties\n        properties.putAll(sitemap.getSiteEntries().get(0).getProperties());\n        // special case for '/'\n        if (entryPaths.isEmpty()) {\n            CmsSiteEntryBean entry = sitemap.getSiteEntries().get(0);\n            entry.setPosition(0);\n            entry.setInheritedProperties(properties);\n            entry.setPrefix(sitemapFolder);\n            LOG.debug(Messages.get().container(\n                Messages.LOG_DEBUG_SITEMAP_FOUND_3,\n                logId,\n                new Integer(0),\n                entry.getUri()).key());\n            return entry;\n        }\n        // get started\n        String uriPath = cms.getRequestContext().getSiteRoot() + sitemapFolder;\n        List<CmsSiteEntryBean> subEntries = sitemap.getSiteEntries().get(0).getSubEntries();\n        boolean finished = false;\n        while (!finished) {\n            String name = entryPaths.removeFirst();\n            LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_ENTRY_CHECK_2, logId, uriPath).key());\n            uriPath += \"/\" + name;\n            // check the missed cache\n            if (m_cache.getMissingUri(uriPath, online) != null) {\n                // already marked as not found\n                LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_ENTRY_MISSING_2, logId, uriPath).key());\n                return null;\n            }\n            int position = 0;\n            int size = subEntries.size();\n            for (; position < size; position++) {\n                CmsSiteEntryBean entry = subEntries.get(position);\n                properties.putAll(entry.getProperties());\n                entry.setPosition(position);\n                entry.setInheritedProperties(properties);\n                entry.setPrefix(sitemapFolder);\n                // cache the found entry\n                m_cache.setUri(uri, entry, online);\n                if (!entry.getName().equals(name)) {\n                    // no match\n                    LOG.debug(Messages.get().container(\n                        Messages.LOG_DEBUG_SITEMAP_NO_MATCH_3,\n                        logId,\n                        new Integer(position),\n                        entry.getUri()).key());\n                    continue;\n                }\n                LOG.debug(Messages.get().container(\n                    Messages.LOG_DEBUG_SITEMAP_MATCH_3,\n                    logId,\n                    new Integer(position),\n                    entry.getUri()).key());\n                if (entryPaths.isEmpty()) {\n                    // if nothing left, we got a match\n                    LOG.debug(Messages.get().container(\n                        Messages.LOG_DEBUG_SITEMAP_FOUND_3,\n                        logId,\n                        new Integer(position),\n                        entry.getUri()).key());\n                    return entry;\n                } else {\n                    boolean changedSitemap = false;\n                    // continue with sub-entries\n                    subEntries = entry.getSubEntries();\n                    if (subEntries.isEmpty()) {\n                        // check sitemap property\n                        String subSitemapId = entry.getProperties().get(CmsSitemapManager.Property.SITEMAP.getName());\n                        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(subSitemapId)) {\n                            // switch to sub-sitemap\n                            CmsResource subSitemap = cms.readResource(new CmsUUID(subSitemapId));\n                            LOG.debug(Messages.get().container(\n                                Messages.LOG_DEBUG_SITEMAP_SUBSITEMAP_2,\n                                logId,\n                                cms.getSitePath(subSitemap)).key());\n                            sitemapXml = CmsXmlSitemapFactory.unmarshal(cms, subSitemap);\n                            sitemap = sitemapXml.getSitemap(cms, cms.getRequestContext().getLocale());\n                            if (sitemap == null) {\n                                // no sitemap found\n                                return null;\n                            }\n                            // continue with the sub-sitemap\n                            subEntries = sitemap.getSiteEntries();\n                            changedSitemap = true;\n                        }\n                    }\n                    finished = subEntries.isEmpty();\n                    if (finished) {\n                        if ((entryPaths.size() == 1) && CmsUUID.isValidUUID(entryPaths.get(0))) {\n                            // detail pages\n                            CmsUUID id = new CmsUUID(entryPaths.get(0));\n                            CmsResource contentRes = cms.readResource(id); // check that the content exists\n                            entry = new CmsSiteEntryBean(\n                                entry.getId(),\n                                entry.getOriginalUri(),\n                                entry.getResourceId(),\n                                id.toString(),\n                                cms.readPropertyObject(contentRes, CmsPropertyDefinition.PROPERTY_TITLE, false).getValue(\n                                    id.toString()),\n                                entry.getProperties(),\n                                null);\n                            entry.setInheritedProperties(properties);\n                            entry.setPrefix(sitemapFolder);\n                            entry.setContentId(id);\n                            LOG.debug(Messages.get().container(\n                                Messages.LOG_DEBUG_SITEMAP_FOUND_3,\n                                logId,\n                                new Integer(position),\n                                entry.getUri()).key());\n                            return entry;\n                        }\n                        LOG.debug(Messages.get().container(\n                            Messages.LOG_DEBUG_SITEMAP_NO_SUBENTRIES_3,\n                            logId,\n                            new Integer(position),\n                            entry.getUri()).key());\n                    }\n                    if (changedSitemap) {\n                        // adjust the sitemap folder\n                        sitemapFolder = cms.getRequestContext().removeSiteRoot(uriPath);\n                    }\n                }\n                break;\n            }\n            if (position == size) {\n                // not found\n                finished = true;\n                LOG.debug(Messages.get().container(Messages.LOG_DEBUG_SITEMAP_NOT_FOUND_2, logId, uriPath).key());\n            }\n        }\n\n        return null;\n    }","commit_id":"de7829d11d50effa4dec5e197d383240ad5b71c5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n   * Call the appropriate handler for handling the httprequest. 404 if path is not found. 405 if path is found but\n   * httpMethod does not match what's configured.\n   *\n   * @param request instance of {@code HttpRequest}\n   * @param responder instance of {@code HttpResponder} to handle the request.\n   */\n  public void handle(HttpRequest request, HttpResponder responder) {\n\n    if (urlRewriter != null) {\n      try {\n        request.setUri(URI.create(request.getUri()).normalize().toString());\n        urlRewriter.rewrite(request);\n      } catch (Throwable t) {\n        responder.sendError(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                            String.format(\"Caught exception processing request. Reason: %s\",\n                                          t.getMessage()));\n        LOG.error(\"Exception thrown during rewriting of uri {}\", request.getUri(), t);\n        return;\n      }\n    }\n\n    try {\n      String path = URI.create(request.getUri()).normalize().getPath();\n\n      List<RoutableDestination<HttpResourceModel>> routableDestinations = patternRouter.getDestinations(path);\n\n      RoutableDestination<HttpResourceModel> matchedDestination =\n        getMatchedDestination(routableDestinations, request.getMethod(), path);\n\n      if (matchedDestination != null) {\n        //Found a httpresource route to it.\n        HttpResourceModel httpResourceModel = matchedDestination.getDestination();\n\n        // Call preCall method of handler hooks.\n        boolean terminated = false;\n        HandlerInfo info = new HandlerInfo(httpResourceModel.getMethod().getDeclaringClass().getName(),\n                                           httpResourceModel.getMethod().getName());\n        for (HandlerHook hook : handlerHooks) {\n          if (!hook.preCall(request, responder, info)) {\n            // Terminate further request processing if preCall returns false.\n            terminated = true;\n            break;\n          }\n        }\n\n        // Call httpresource method\n        if (!terminated) {\n          // Wrap responder to make post hook calls.\n          responder = new WrappedHttpResponder(responder, handlerHooks, request, info);\n          httpResourceModel.handle(request, responder, matchedDestination.getGroupNameValues());\n        }\n      } else if (routableDestinations.size() > 0)  {\n        //Found a matching resource but could not find the right HttpMethod so return 405\n        responder.sendError(HttpResponseStatus.METHOD_NOT_ALLOWED,\n                            String.format(\"Problem accessing: %s. Reason: Method Not Allowed\", request.getUri()));\n      } else {\n        responder.sendError(HttpResponseStatus.NOT_FOUND, String.format(\"Problem accessing: %s. Reason: Not Found\",\n                                                                        request.getUri()));\n      }\n    } catch (Throwable t){\n      responder.sendError(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                          String.format(\"Caught exception processing request. Reason: %s\",\n                                        t.getMessage()));\n      LOG.error(\"Exception thrown during request processing for uri {}\", request.getUri(), t);\n    }\n  }","id":38478,"modified_method":"/**\n   * Call the appropriate handler for handling the httprequest. 404 if path is not found. 405 if path is found but\n   * httpMethod does not match what's configured.\n   *\n   * @param request instance of {@code HttpRequest}\n   * @param responder instance of {@code HttpResponder} to handle the request.\n   */\n  public void handle(HttpRequest request, HttpResponder responder) {\n\n    if (urlRewriter != null) {\n      try {\n        request.setUri(URI.create(request.getUri()).normalize().toString());\n        if (!urlRewriter.rewrite(request, responder)) {\n          return;\n        }\n      } catch (Throwable t) {\n        responder.sendError(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                            String.format(\"Caught exception processing request. Reason: %s\",\n                                          t.getMessage()));\n        LOG.error(\"Exception thrown during rewriting of uri {}\", request.getUri(), t);\n        return;\n      }\n    }\n\n    try {\n      String path = URI.create(request.getUri()).normalize().getPath();\n\n      List<RoutableDestination<HttpResourceModel>> routableDestinations = patternRouter.getDestinations(path);\n\n      RoutableDestination<HttpResourceModel> matchedDestination =\n        getMatchedDestination(routableDestinations, request.getMethod(), path);\n\n      if (matchedDestination != null) {\n        //Found a httpresource route to it.\n        HttpResourceModel httpResourceModel = matchedDestination.getDestination();\n\n        // Call preCall method of handler hooks.\n        boolean terminated = false;\n        HandlerInfo info = new HandlerInfo(httpResourceModel.getMethod().getDeclaringClass().getName(),\n                                           httpResourceModel.getMethod().getName());\n        for (HandlerHook hook : handlerHooks) {\n          if (!hook.preCall(request, responder, info)) {\n            // Terminate further request processing if preCall returns false.\n            terminated = true;\n            break;\n          }\n        }\n\n        // Call httpresource method\n        if (!terminated) {\n          // Wrap responder to make post hook calls.\n          responder = new WrappedHttpResponder(responder, handlerHooks, request, info);\n          httpResourceModel.handle(request, responder, matchedDestination.getGroupNameValues());\n        }\n      } else if (routableDestinations.size() > 0)  {\n        //Found a matching resource but could not find the right HttpMethod so return 405\n        responder.sendError(HttpResponseStatus.METHOD_NOT_ALLOWED,\n                            String.format(\"Problem accessing: %s. Reason: Method Not Allowed\", request.getUri()));\n      } else {\n        responder.sendError(HttpResponseStatus.NOT_FOUND, String.format(\"Problem accessing: %s. Reason: Not Found\",\n                                                                        request.getUri()));\n      }\n    } catch (Throwable t){\n      responder.sendError(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                          String.format(\"Caught exception processing request. Reason: %s\",\n                                        t.getMessage()));\n      LOG.error(\"Exception thrown during request processing for uri {}\", request.getUri(), t);\n    }\n  }","commit_id":"c52bb3ab3f78afd3e711e700349bf395c6170543","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void rewrite(HttpRequest request) {\n      if (request.getUri().startsWith(\"/rewrite/\")) {\n        request.setUri(request.getUri().replace(\"/rewrite/\", \"/\"));\n      }\n    }","id":38479,"modified_method":"@Override\n    public boolean rewrite(HttpRequest request, HttpResponder responder) {\n      if (request.getUri().startsWith(\"/rewrite/\")) {\n        request.setUri(request.getUri().replace(\"/rewrite/\", \"/\"));\n      }\n\n      if (request.getUri().startsWith(\"/redirect/\")) {\n        responder.sendStatus(HttpResponseStatus.MOVED_PERMANENTLY,\n                             ImmutableMultimap.of(\"Location\", request.getUri().replace(\"/redirect/\", \"/rewrite/\")));\n        return false;\n      }\n      return true;\n    }","commit_id":"c52bb3ab3f78afd3e711e700349bf395c6170543","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void rewrite(HttpRequest request) {\n    String hostHeader = HttpHeaders.getHost(request);\n    if (hostHeader == null) {\n      return;\n    }\n\n    String uri = jarHttpHandler.getServePath(hostHeader, request.getUri());\n    if (uri != null) {\n      request.setUri(uri);\n    }\n  }","id":38480,"modified_method":"@Override\n  public boolean rewrite(HttpRequest request, HttpResponder responder) {\n    String hostHeader = HttpHeaders.getHost(request);\n    if (hostHeader == null) {\n      return true;\n    }\n\n    String originalUri = request.getUri();\n    String uri = jarHttpHandler.getServePath(hostHeader, originalUri);\n    if (uri != null) {\n      // Redirect requests that map to index.html without a trailing slash to url/\n      if (!originalUri.endsWith(\"/\") && !originalUri.endsWith(\"index.html\") && uri.endsWith(\"index.html\")) {\n        responder.sendStatus(HttpResponseStatus.MOVED_PERMANENTLY,\n                             ImmutableMultimap.of(\"Location\", originalUri + \"/\"));\n        return false;\n      }\n      request.setUri(uri);\n    }\n\n    return true;\n  }","commit_id":"c52bb3ab3f78afd3e711e700349bf395c6170543","url":"https://github.com/caskdata/cdap"},{"original_method":"protected String exportToRSS(\n\t\t\tString name, String description, String type, double version,\n\t\t\tString displayStyle, String feedURL, String entryURL,\n\t\t\tList<BlogsEntry> blogsEntries, ThemeDisplay themeDisplay)\n\t\tthrows SystemException {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\t\tsyndFeed.setTitle(name);\n\t\tsyndFeed.setLink(feedURL);\n\t\tsyndFeed.setDescription(description);\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setUri(feedURL);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tfor (BlogsEntry entry : blogsEntries) {\n\t\t\tString author = PortalUtil.getUserName(entry);\n\n\t\t\tStringBundler link = new StringBundler(4);\n\n\t\t\tif (entryURL.endsWith(\"/blogs/rss\")) {\n\t\t\t\tlink.append(entryURL.substring(0, entryURL.length() - 3));\n\t\t\t\tlink.append(entry.getUrlTitle());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlink.append(entryURL);\n\n\t\t\t\tif (!entryURL.endsWith(StringPool.QUESTION)) {\n\t\t\t\t\tlink.append(StringPool.AMPERSAND);\n\t\t\t\t}\n\n\t\t\t\tlink.append(\"entryId=\");\n\t\t\t\tlink.append(entry.getEntryId());\n\t\t\t}\n\n\t\t\tString value = null;\n\n\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_ABSTRACT)) {\n\t\t\t\tString summary = entry.getDescription();\n\n\t\t\t\tif (Validator.isNull(summary)) {\n\t\t\t\t\tsummary = entry.getContent();\n\t\t\t\t}\n\n\t\t\t\tvalue = StringUtil.shorten(\n\t\t\t\t\tHtmlUtil.extractText(summary),\n\t\t\t\t\tPropsValues.BLOGS_RSS_ABSTRACT_LENGTH, StringPool.BLANK);\n\t\t\t}\n\t\t\telse if (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = StringUtil.replace(\n\t\t\t\t\tentry.getContent(),\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"href=\\\"/\", \"src=\\\"/\"\n\t\t\t\t\t},\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"href=\\\"\" + themeDisplay.getURLPortal() + \"/\",\n\t\t\t\t\t\t\"src=\\\"\" + themeDisplay.getURLPortal() + \"/\"\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tsyndEntry.setAuthor(author);\n\t\t\tsyndEntry.setTitle(entry.getTitle());\n\t\t\tsyndEntry.setLink(link.toString());\n\t\t\tsyndEntry.setUri(syndEntry.getLink());\n\t\t\tsyndEntry.setPublishedDate(entry.getCreateDate());\n\t\t\tsyndEntry.setUpdatedDate(entry.getModifiedDate());\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","id":38481,"modified_method":"protected String exportToRSS(\n\t\t\tString name, String description, String type, double version,\n\t\t\tString displayStyle, String feedURL, String entryURL,\n\t\t\tList<BlogsEntry> blogsEntries, ThemeDisplay themeDisplay)\n\t\tthrows SystemException {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setDescription(description);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tfor (BlogsEntry entry : blogsEntries) {\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tString author = PortalUtil.getUserName(entry);\n\n\t\t\tsyndEntry.setAuthor(author);\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\n\t\t\tString value = null;\n\n\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_ABSTRACT)) {\n\t\t\t\tString summary = entry.getDescription();\n\n\t\t\t\tif (Validator.isNull(summary)) {\n\t\t\t\t\tsummary = entry.getContent();\n\t\t\t\t}\n\n\t\t\t\tvalue = StringUtil.shorten(\n\t\t\t\t\tHtmlUtil.extractText(summary),\n\t\t\t\t\tPropsValues.BLOGS_RSS_ABSTRACT_LENGTH, StringPool.BLANK);\n\t\t\t}\n\t\t\telse if (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = StringUtil.replace(\n\t\t\t\t\tentry.getContent(),\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"href=\\\"/\", \"src=\\\"/\"\n\t\t\t\t\t},\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"href=\\\"\" + themeDisplay.getURLPortal() + \"/\",\n\t\t\t\t\t\t\"src=\\\"\" + themeDisplay.getURLPortal() + \"/\"\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tif (entryURL.endsWith(\"/blogs/rss\")) {\n\t\t\t\tsb.append(entryURL.substring(0, entryURL.length() - 3));\n\t\t\t\tsb.append(entry.getUrlTitle());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(entryURL);\n\n\t\t\t\tif (!entryURL.endsWith(StringPool.QUESTION)) {\n\t\t\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\t\t}\n\n\t\t\t\tsb.append(\"entryId=\");\n\t\t\t\tsb.append(entry.getEntryId());\n\t\t\t}\n\n\t\t\tString link = sb.toString();\n\n\t\t\tsyndEntry.setLink(link);\n\n\t\t\tsyndEntry.setPublishedDate(entry.getCreateDate());\n\t\t\tsyndEntry.setTitle(entry.getTitle());\n\t\t\tsyndEntry.setUpdatedDate(entry.getModifiedDate());\n\t\t\tsyndEntry.setUri(link);\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\t\tsyndFeed.setLink(feedURL);\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setTitle(name);\n\t\tsyndFeed.setUri(feedURL);\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","commit_id":"b00b650ad118a5da4a816bcedf5c468dfda8f726","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String exportToRSS(\n\t\t\tString name, String description, String type, double version,\n\t\t\tString displayStyle, String feedURL, String entryURL,\n\t\t\tList<MBMessage> messages, ThemeDisplay themeDisplay)\n\t\tthrows SystemException {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\t\tsyndFeed.setTitle(name);\n\t\tsyndFeed.setLink(feedURL);\n\t\tsyndFeed.setDescription(description);\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setUri(feedURL);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tString author = PortalUtil.getUserName(message);\n\n\t\t\tString value = null;\n\n\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_ABSTRACT)) {\n\t\t\t\tvalue = StringUtil.shorten(\n\t\t\t\t\tHtmlUtil.extractText(message.getBody()),\n\t\t\t\t\tPropsValues.MESSAGE_BOARDS_RSS_ABSTRACT_LENGTH,\n\t\t\t\t\tStringPool.BLANK);\n\t\t\t}\n\t\t\telse if (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = BBCodeTranslatorUtil.getHTML(message.getBody());\n\n\t\t\t\tvalue = StringUtil.replace(\n\t\t\t\t\tvalue,\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"@theme_images_path@\", \"href=\\\"/\", \"src=\\\"/\"\n\t\t\t\t\t},\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\tthemeDisplay.getURLPortal() +\n\t\t\t\t\t\t\tthemeDisplay.getPathThemeImages(),\n\t\t\t\t\t\t\"href=\\\"\" + themeDisplay.getURLPortal() + \"/\",\n\t\t\t\t\t\t\"src=\\\"\" + themeDisplay.getURLPortal() + \"/\"\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tif (!message.isAnonymous()) {\n\t\t\t\tsyndEntry.setAuthor(author);\n\t\t\t}\n\n\t\t\tsyndEntry.setTitle(message.getSubject());\n\t\t\tsyndEntry.setLink(\n\t\t\t\tentryURL + \"&messageId=\" + message.getMessageId());\n\t\t\tsyndEntry.setUri(syndEntry.getLink());\n\t\t\tsyndEntry.setPublishedDate(message.getCreateDate());\n\t\t\tsyndEntry.setUpdatedDate(message.getModifiedDate());\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","id":38482,"modified_method":"protected String exportToRSS(\n\t\t\tString name, String description, String type, double version,\n\t\t\tString displayStyle, String feedURL, String entryURL,\n\t\t\tList<MBMessage> messages, ThemeDisplay themeDisplay)\n\t\tthrows SystemException {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setDescription(description);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tif (!message.isAnonymous()) {\n\t\t\t\tString author = PortalUtil.getUserName(message);\n\n\t\t\t\tsyndEntry.setAuthor(author);\n\t\t\t}\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\n\t\t\tString value = null;\n\n\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_ABSTRACT)) {\n\t\t\t\tvalue = StringUtil.shorten(\n\t\t\t\t\tHtmlUtil.extractText(message.getBody()),\n\t\t\t\t\tPropsValues.MESSAGE_BOARDS_RSS_ABSTRACT_LENGTH,\n\t\t\t\t\tStringPool.BLANK);\n\t\t\t}\n\t\t\telse if (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = BBCodeTranslatorUtil.getHTML(message.getBody());\n\n\t\t\t\tvalue = StringUtil.replace(\n\t\t\t\t\tvalue,\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\"@theme_images_path@\", \"href=\\\"/\", \"src=\\\"/\"\n\t\t\t\t\t},\n\t\t\t\t\tnew String[] {\n\t\t\t\t\t\tthemeDisplay.getURLPortal() +\n\t\t\t\t\t\t\tthemeDisplay.getPathThemeImages(),\n\t\t\t\t\t\t\"href=\\\"\" + themeDisplay.getURLPortal() + \"/\",\n\t\t\t\t\t\t\"src=\\\"\" + themeDisplay.getURLPortal() + \"/\"\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tsyndEntry.setLink(\n\t\t\t\tentryURL + \"&messageId=\" + message.getMessageId());\n\t\t\tsyndEntry.setPublishedDate(message.getCreateDate());\n\t\t\tsyndEntry.setTitle(message.getSubject());\n\t\t\tsyndEntry.setUpdatedDate(message.getModifiedDate());\n\t\t\tsyndEntry.setUri(syndEntry.getLink());\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\t\tsyndFeed.setLink(feedURL);\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setTitle(name);\n\t\tsyndFeed.setUri(feedURL);\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","commit_id":"b00b650ad118a5da4a816bcedf5c468dfda8f726","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String exportToRSS(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse,\n\t\t\tString name, String description, String type, double version,\n\t\t\tString displayStyle, String linkBehavior,\n\t\t\tList<AssetEntry> assetEntries)\n\t\tthrows Exception {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\t\tsyndFeed.setTitle(name);\n\n\t\tString feedURL = getFeedURL(portletRequest);\n\n\t\tsyndFeed.setLink(feedURL);\n\t\tsyndFeed.setDescription(GetterUtil.getString(description, name));\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setUri(feedURL);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tfor (AssetEntry assetEntry : assetEntries) {\n\t\t\tString link = getEntryURL(\n\t\t\t\tportletRequest, portletResponse, linkBehavior, assetEntry);\n\n\t\t\tString author = PortalUtil.getUserName(assetEntry);\n\n\t\t\tString value = null;\n\n\t\t\tString languageId = LanguageUtil.getLanguageId(portletRequest);\n\n\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = assetEntry.getSummary(languageId, true);\n\t\t\t}\n\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tsyndEntry.setAuthor(author);\n\n\t\t\tsyndEntry.setTitle(assetEntry.getTitle(languageId, true));\n\n\t\t\tsyndEntry.setLink(link);\n\t\t\tsyndEntry.setUri(syndEntry.getLink());\n\t\t\tsyndEntry.setPublishedDate(assetEntry.getCreateDate());\n\t\t\tsyndEntry.setUpdatedDate(assetEntry.getModifiedDate());\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\treturn RSSUtil.export(syndFeed);\n\t}","id":38483,"modified_method":"protected String exportToRSS(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse,\n\t\t\tString name, String description, String type, double version,\n\t\t\tString displayStyle, String linkBehavior,\n\t\t\tList<AssetEntry> assetEntries)\n\t\tthrows Exception {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setDescription(GetterUtil.getString(description, name));\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tfor (AssetEntry assetEntry : assetEntries) {\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tString author = PortalUtil.getUserName(assetEntry);\n\n\t\t\tsyndEntry.setAuthor(author);\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\n\t\t\tString value = null;\n\n\t\t\tString languageId = LanguageUtil.getLanguageId(portletRequest);\n\n\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = assetEntry.getSummary(languageId, true);\n\t\t\t}\n\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tString link = getEntryURL(\n\t\t\t\tportletRequest, portletResponse, linkBehavior, assetEntry);\n\n\t\t\tsyndEntry.setLink(link);\n\n\t\t\tsyndEntry.setPublishedDate(assetEntry.getCreateDate());\n\t\t\tsyndEntry.setTitle(assetEntry.getTitle(languageId, true));\n\t\t\tsyndEntry.setUpdatedDate(assetEntry.getModifiedDate());\n\t\t\tsyndEntry.setUri(syndEntry.getLink());\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\n\t\tString feedURL = getFeedURL(portletRequest);\n\n\t\tsyndFeed.setLink(feedURL);\n\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setTitle(name);\n\t\tsyndFeed.setUri(feedURL);\n\n\t\treturn RSSUtil.export(syndFeed);\n\t}","commit_id":"b00b650ad118a5da4a816bcedf5c468dfda8f726","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String exportToRSS(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse,\n\t\t\tJournalFeed feed, String languageId, Layout layout,\n\t\t\tThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tResourceURL feedURL = resourceResponse.createResourceURL();\n\n\t\tfeedURL.setCacheability(ResourceURL.FULL);\n\t\tfeedURL.setParameter(\"struts_action\", \"/journal/rss\");\n\t\tfeedURL.setParameter(\"groupId\", String.valueOf(feed.getGroupId()));\n\t\tfeedURL.setParameter(\"feedId\", String.valueOf(feed.getFeedId()));\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setDescription(feed.getDescription());\n\t\tsyndFeed.setFeedType(feed.getFeedType() + \"_\" + feed.getFeedVersion());\n\t\tsyndFeed.setLink(feedURL.toString());\n\t\tsyndFeed.setTitle(feed.getName());\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setUri(feedURL.toString());\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tList<JournalArticle> articles = JournalRSSUtil.getArticles(feed);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Syndicating \" + articles.size() + \" articles\");\n\t\t}\n\n\t\tfor (JournalArticle article : articles) {\n\t\t\tString author = PortalUtil.getUserName(article);\n\t\t\tString link = getEntryURL(\n\t\t\t\tresourceRequest, feed, article, layout, themeDisplay);\n\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tsyndEntry.setAuthor(author);\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tString value = article.getDescription(languageId);\n\n\t\t\ttry {\n\t\t\t\tvalue = processContent(\n\t\t\t\t\tfeed, article, languageId, themeDisplay, syndEntry,\n\t\t\t\t\tsyndContent);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tsyndEntry.setLink(link);\n\t\t\tsyndEntry.setPublishedDate(article.getDisplayDate());\n\t\t\tsyndEntry.setTitle(article.getTitle(languageId));\n\t\t\tsyndEntry.setUpdatedDate(article.getModifiedDate());\n\t\t\tsyndEntry.setUri(syndEntry.getLink());\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","id":38484,"modified_method":"protected String exportToRSS(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse,\n\t\t\tJournalFeed feed, String languageId, Layout layout,\n\t\t\tThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setDescription(feed.getDescription());\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tList<JournalArticle> articles = JournalRSSUtil.getArticles(feed);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Syndicating \" + articles.size() + \" articles\");\n\t\t}\n\n\t\tfor (JournalArticle article : articles) {\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tString author = PortalUtil.getUserName(article);\n\n\t\t\tsyndEntry.setAuthor(author);\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\n\t\t\tString value = article.getDescription(languageId);\n\n\t\t\ttry {\n\t\t\t\tvalue = processContent(\n\t\t\t\t\tfeed, article, languageId, themeDisplay, syndEntry,\n\t\t\t\t\tsyndContent);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsyndContent.setValue(value);\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tString link = getEntryURL(\n\t\t\t\tresourceRequest, feed, article, layout, themeDisplay);\n\n\t\t\tsyndEntry.setLink(link);\n\n\t\t\tsyndEntry.setPublishedDate(article.getDisplayDate());\n\t\t\tsyndEntry.setTitle(article.getTitle(languageId));\n\t\t\tsyndEntry.setUpdatedDate(article.getModifiedDate());\n\t\t\tsyndEntry.setUri(link);\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\tsyndFeed.setFeedType(feed.getFeedType() + \"_\" + feed.getFeedVersion());\n\n\t\tResourceURL feedURL = resourceResponse.createResourceURL();\n\n\t\tfeedURL.setCacheability(ResourceURL.FULL);\n\t\tfeedURL.setParameter(\"struts_action\", \"/journal/rss\");\n\t\tfeedURL.setParameter(\"groupId\", String.valueOf(feed.getGroupId()));\n\t\tfeedURL.setParameter(\"feedId\", String.valueOf(feed.getFeedId()));\n\n\t\tString link = feedURL.toString();\n\n\t\tsyndFeed.setLink(link);\n\n\t\tsyndFeed.setTitle(feed.getName());\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setUri(feedURL.toString());\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","commit_id":"b00b650ad118a5da4a816bcedf5c468dfda8f726","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected byte[] getRSS(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tString feedTitle = ParamUtil.getString(resourceRequest, \"feedTitle\");\n\n\t\tsyndFeed.setDescription(feedTitle);\n\n\t\tsyndFeed.setFeedType(RSSUtil.FEED_TYPE_DEFAULT);\n\n\t\tString feedLink =\n\t\t\tPortalUtil.getLayoutFullURL(themeDisplay) +\n\t\t\t\tPortal.FRIENDLY_URL_SEPARATOR + \"activities/rss\";\n\n\t\tsyndFeed.setLink(feedLink);\n\n\t\tsyndFeed.setTitle(feedTitle);\n\n\t\tsyndFeed.setPublishedDate(new Date());\n\n\t\tsyndFeed.setUri(feedLink);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tList<SocialActivity> activities = getActivities(resourceRequest);\n\n\t\tfor (SocialActivity activity : activities) {\n\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\tSocialActivityInterpreterLocalServiceUtil.interpret(\n\t\t\t\t\tactivity, themeDisplay);\n\n\t\t\tif (activityFeedEntry == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.FEED_TYPE_DEFAULT);\n\t\t\tsyndContent.setValue(activityFeedEntry.getBody());\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tif (Validator.isNotNull(activityFeedEntry.getLink())) {\n\t\t\t\tsyndEntry.setLink(activityFeedEntry.getLink());\n\t\t\t}\n\n\t\t\tsyndEntry.setPublishedDate(new Date(activity.getCreateDate()));\n\t\t\tsyndEntry.setTitle(\n\t\t\t\tHtmlUtil.extractText(activityFeedEntry.getTitle()));\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\tString rss = StringPool.BLANK;\n\n\t\ttry {\n\t\t\trss = RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\n\t\treturn rss.getBytes(StringPool.UTF8);\n\t}","id":38485,"modified_method":"@Override\n\tprotected byte[] getRSS(\n\t\t\tResourceRequest resourceRequest, ResourceResponse resourceResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)resourceRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tString description = ParamUtil.getString(resourceRequest, \"feedTitle\");\n\n\t\tsyndFeed.setDescription(description);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tList<SocialActivity> activities = getActivities(resourceRequest);\n\n\t\tfor (SocialActivity activity : activities) {\n\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\tSocialActivityInterpreterLocalServiceUtil.interpret(\n\t\t\t\t\tactivity, themeDisplay);\n\n\t\t\tif (activityFeedEntry == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.FEED_TYPE_DEFAULT);\n\t\t\tsyndContent.setValue(activityFeedEntry.getBody());\n\n\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\tif (Validator.isNotNull(activityFeedEntry.getLink())) {\n\t\t\t\tsyndEntry.setLink(activityFeedEntry.getLink());\n\t\t\t}\n\n\t\t\tsyndEntry.setPublishedDate(new Date(activity.getCreateDate()));\n\t\t\tsyndEntry.setTitle(\n\t\t\t\tHtmlUtil.extractText(activityFeedEntry.getTitle()));\n\n\t\t\tsyndEntries.add(syndEntry);\n\t\t}\n\n\t\tsyndFeed.setFeedType(RSSUtil.FEED_TYPE_DEFAULT);\n\n\t\tString link =\n\t\t\tPortalUtil.getLayoutFullURL(themeDisplay) +\n\t\t\t\tPortal.FRIENDLY_URL_SEPARATOR + \"activities/rss\";\n\n\t\tsyndFeed.setLink(link);\n\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setTitle(description);\n\t\tsyndFeed.setUri(link);\n\n\t\tString rss = StringPool.BLANK;\n\n\t\ttry {\n\t\t\trss = RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\n\t\treturn rss.getBytes(StringPool.UTF8);\n\t}","commit_id":"b00b650ad118a5da4a816bcedf5c468dfda8f726","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String exportToRSS(\n\t\t\tlong companyId, String name, String description, String type,\n\t\t\tdouble version, String displayStyle, String feedURL,\n\t\t\tString entryURL, List<WikiPage> pages, boolean diff, Locale locale)\n\t\tthrows SystemException {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\t\tsyndFeed.setTitle(name);\n\t\tsyndFeed.setLink(feedURL);\n\t\tsyndFeed.setDescription(description);\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setUri(feedURL);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tWikiPage latestPage = null;\n\n\t\tStringBundler link = new StringBundler(7);\n\n\t\tfor (WikiPage page : pages) {\n\t\t\tString author = PortalUtil.getUserName(page);\n\t\t\tString title =\n\t\t\t\tpage.getTitle() + StringPool.SPACE + page.getVersion();\n\n\t\t\tif (page.isMinorEdit()) {\n\t\t\t\ttitle +=\n\t\t\t\t\tStringPool.SPACE + StringPool.OPEN_PARENTHESIS +\n\t\t\t\t\t\tLanguageUtil.get(locale, \"minor-edit\") +\n\t\t\t\t\t\t\tStringPool.CLOSE_PARENTHESIS;\n\t\t\t}\n\n\t\t\tlink.setIndex(0);\n\n\t\t\tlink.append(entryURL);\n\t\t\tlink.append(StringPool.AMPERSAND);\n\t\t\tlink.append(HttpUtil.encodeURL(page.getTitle()));\n\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tsyndEntry.setAuthor(author);\n\t\t\tsyndEntry.setTitle(title);\n\t\t\tsyndEntry.setPublishedDate(page.getCreateDate());\n\t\t\tsyndEntry.setUpdatedDate(page.getModifiedDate());\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\n\t\t\tif (diff) {\n\t\t\t\tif (latestPage != null) {\n\t\t\t\t\tlink.append(StringPool.QUESTION);\n\t\t\t\t\tlink.append(\n\t\t\t\t\t\tPortalUtil.getPortletNamespace(PortletKeys.WIKI));\n\t\t\t\t\tlink.append(\"version=\");\n\t\t\t\t\tlink.append(page.getVersion());\n\n\t\t\t\t\tString value = getPageDiff(\n\t\t\t\t\t\tcompanyId, latestPage, page, locale);\n\n\t\t\t\t\tsyndContent.setValue(value);\n\n\t\t\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\t\t\tsyndEntries.add(syndEntry);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString value = null;\n\n\t\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_ABSTRACT)) {\n\t\t\t\t\tvalue = StringUtil.shorten(\n\t\t\t\t\t\tHtmlUtil.extractText(page.getContent()),\n\t\t\t\t\t\tPropsValues.WIKI_RSS_ABSTRACT_LENGTH, StringPool.BLANK);\n\t\t\t\t}\n\t\t\t\telse if (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = page.getContent();\n\t\t\t\t}\n\n\t\t\t\tsyndContent.setValue(value);\n\n\t\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\t\tsyndEntries.add(syndEntry);\n\t\t\t}\n\n\t\t\tsyndEntry.setLink(link.toString());\n\t\t\tsyndEntry.setUri(syndEntry.getLink());\n\n\t\t\tlatestPage = page;\n\t\t}\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","id":38486,"modified_method":"protected String exportToRSS(\n\t\t\tlong companyId, String name, String description, String type,\n\t\t\tdouble version, String displayStyle, String feedURL,\n\t\t\tString entryURL, List<WikiPage> pages, boolean diff, Locale locale)\n\t\tthrows SystemException {\n\n\t\tSyndFeed syndFeed = new SyndFeedImpl();\n\n\t\tsyndFeed.setDescription(description);\n\n\t\tList<SyndEntry> syndEntries = new ArrayList<SyndEntry>();\n\n\t\tsyndFeed.setEntries(syndEntries);\n\n\t\tWikiPage latestPage = null;\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tfor (WikiPage page : pages) {\n\t\t\tSyndEntry syndEntry = new SyndEntryImpl();\n\n\t\t\tString author = PortalUtil.getUserName(page);\n\n\t\t\tsyndEntry.setAuthor(author);\n\n\t\t\tSyndContent syndContent = new SyndContentImpl();\n\n\t\t\tsyndContent.setType(RSSUtil.ENTRY_TYPE_DEFAULT);\n\n\t\t\tsb.setIndex(0);\n\n\t\t\tsb.append(entryURL);\n\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\tsb.append(HttpUtil.encodeURL(page.getTitle()));\n\n\t\t\tif (diff) {\n\t\t\t\tif (latestPage != null) {\n\t\t\t\t\tsb.append(StringPool.QUESTION);\n\t\t\t\t\tsb.append(PortalUtil.getPortletNamespace(PortletKeys.WIKI));\n\t\t\t\t\tsb.append(\"version=\");\n\t\t\t\t\tsb.append(page.getVersion());\n\n\t\t\t\t\tString value = getPageDiff(\n\t\t\t\t\t\tcompanyId, latestPage, page, locale);\n\n\t\t\t\t\tsyndContent.setValue(value);\n\n\t\t\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\t\t\tsyndEntries.add(syndEntry);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString value = null;\n\n\t\t\t\tif (displayStyle.equals(RSSUtil.DISPLAY_STYLE_ABSTRACT)) {\n\t\t\t\t\tvalue = StringUtil.shorten(\n\t\t\t\t\t\tHtmlUtil.extractText(page.getContent()),\n\t\t\t\t\t\tPropsValues.WIKI_RSS_ABSTRACT_LENGTH, StringPool.BLANK);\n\t\t\t\t}\n\t\t\t\telse if (displayStyle.equals(RSSUtil.DISPLAY_STYLE_TITLE)) {\n\t\t\t\t\tvalue = StringPool.BLANK;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = page.getContent();\n\t\t\t\t}\n\n\t\t\t\tsyndContent.setValue(value);\n\n\t\t\t\tsyndEntry.setDescription(syndContent);\n\n\t\t\t\tsyndEntries.add(syndEntry);\n\t\t\t}\n\n\t\t\tsyndEntry.setLink(sb.toString());\n\t\t\tsyndEntry.setPublishedDate(page.getCreateDate());\n\n\t\t\tString title =\n\t\t\t\tpage.getTitle() + StringPool.SPACE + page.getVersion();\n\n\t\t\tif (page.isMinorEdit()) {\n\t\t\t\ttitle +=\n\t\t\t\t\tStringPool.SPACE + StringPool.OPEN_PARENTHESIS +\n\t\t\t\t\t\tLanguageUtil.get(locale, \"minor-edit\") +\n\t\t\t\t\t\t\tStringPool.CLOSE_PARENTHESIS;\n\t\t\t}\n\n\t\t\tsyndEntry.setTitle(title);\n\n\t\t\tsyndEntry.setUpdatedDate(page.getModifiedDate());\n\t\t\tsyndEntry.setUri(sb.toString());\n\n\t\t\tlatestPage = page;\n\t\t}\n\n\t\tsyndFeed.setFeedType(RSSUtil.getFeedType(type, version));\n\t\tsyndFeed.setLink(feedURL);\n\t\tsyndFeed.setPublishedDate(new Date());\n\t\tsyndFeed.setTitle(name);\n\t\tsyndFeed.setUri(feedURL);\n\n\t\ttry {\n\t\t\treturn RSSUtil.export(syndFeed);\n\t\t}\n\t\tcatch (FeedException fe) {\n\t\t\tthrow new SystemException(fe);\n\t\t}\n\t}","commit_id":"b00b650ad118a5da4a816bcedf5c468dfda8f726","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void passThisReference(ConstructorCallExpression call) {\n        ClassNode cn = call.getType().redirect();\n        if (!shouldHandleImplicitThisForInnerClass(cn)) return;\n\n        boolean isInStaticContext = true;\n        if (currentMethod != null)\n            isInStaticContext = currentMethod.getVariableScope().isInStaticContext();\n        else if (currentField != null)\n            isInStaticContext = currentField.isStatic();\n        else if (processingObjInitStatements)\n            isInStaticContext = false;\n\n        // if constructor call is not in static context, return\n        if (isInStaticContext) {\n            // constructor call is in static context and the inner class is non-static - 1st arg is supposed to be \n            // passed as enclosing \"this\" instance\n            //\n            Expression args = call.getArguments();\n            if (args instanceof TupleExpression && ((TupleExpression) args).getExpressions().isEmpty()) {\n                addError(\"No enclosing instance passed in constructor call of a non-static inner class\", call);\n            }\n            return;\n        }\n\n        // calculate outer class which we need for this$0\n        ClassNode parent = classNode;\n        int level = 0;\n        for (; parent != null && parent != cn.getOuterClass(); parent = parent.getOuterClass()) {\n            level++;\n        }\n\n        // if constructor call is not in outer class, don't pass 'this' implicitly. Return.\n        if (parent == null) return;\n\n        //add this parameter to node\n        Expression argsExp = call.getArguments();\n        if (argsExp instanceof TupleExpression) {\n            TupleExpression argsListExp = (TupleExpression) argsExp;\n            Expression this0 = VariableExpression.THIS_EXPRESSION;\n            for (int i = 0; i != level; ++i)\n                this0 = new PropertyExpression(this0, \"this$0\");\n            argsListExp.getExpressions().add(0, this0);\n        }\n    }","id":38487,"modified_method":"private void passThisReference(ConstructorCallExpression call) {\n        ClassNode cn = call.getType().redirect();\n        if (!shouldHandleImplicitThisForInnerClass(cn)) return;\n\n        boolean isInStaticContext = true;\n        if (currentMethod != null)\n            isInStaticContext = currentMethod.getVariableScope().isInStaticContext();\n        else if (currentField != null)\n            isInStaticContext = currentField.isStatic();\n        else if (processingObjInitStatements)\n            isInStaticContext = false;\n\n        // if constructor call is not in static context, return\n        if (isInStaticContext) {\n            // constructor call is in static context and the inner class is non-static - 1st arg is supposed to be \n            // passed as enclosing \"this\" instance\n            //\n            Expression args = call.getArguments();\n            if (args instanceof TupleExpression && ((TupleExpression) args).getExpressions().isEmpty()) {\n                addError(\"No enclosing instance passed in constructor call of a non-static inner class\", call);\n            }\n            return;\n        }\n        insertThis0ToSuperCall(call, cn);\n\n    }","commit_id":"d353cd483ec7065e5ee40054b5228de477956493","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        boolean isStatic = isStaticThis(innerClass,scope);\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);\n        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;\n        outerClassType = outerClassType.getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setSynthetic(true);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }","id":38488,"modified_method":"@Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        ClassNode outerClass = innerClass.getOuterClass();\n        ClassNode superClass = innerClass.getSuperClass();\n        if (superClass instanceof InnerClassNode\n                && !superClass.isInterface()\n                && !(superClass.isStaticClass()||((superClass.getModifiers()&ACC_STATIC)==ACC_STATIC))) {\n            insertThis0ToSuperCall(call, innerClass);\n        }\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        boolean isStatic = isStaticThis(innerClass,scope);\n        ClassNode outerClassType = getClassNode(outerClass, isStatic);\n        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;\n        outerClassType = outerClassType.getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setSynthetic(true);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }","commit_id":"d353cd483ec7065e5ee40054b5228de477956493","url":"https://github.com/apache/groovy"},{"original_method":"private boolean isStaticThis(InnerClassNode innerClass, VariableScope scope) {\n        boolean ret = scope.isInStaticContext() || innerClass.isStaticClass();\n        if (innerClass.getEnclosingMethod()!=null) {\n            ret = ret || innerClass.getEnclosingMethod().isStatic();\n        }\n        return ret;\n    }","id":38489,"modified_method":"private boolean isStaticThis(InnerClassNode innerClass, VariableScope scope) {\n        if (inClosure) return false;\n        boolean ret = innerClass.isStaticClass();\n        if (    innerClass.getEnclosingMethod()!=null) {\n            ret = ret || innerClass.getEnclosingMethod().isStatic();\n        } else if (currentField!=null) {\n            ret = ret || currentField.isStatic();\n        } else if (currentMethod!=null && \"<clinit>\".equals(currentMethod.getName())) {\n            ret = true;\n        }\n        return ret;\n    }","commit_id":"288f3b15a76a3d83b39cd5ef9d38144e83eb63c6","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStaticThis(innerClass,scope)).getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }","id":38490,"modified_method":"@Override\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\n        super.visitConstructorCallExpression(call);\n        if (!call.isUsingAnonymousInnerClass()) {\n            passThisReference(call);\n            return;\n        }\n\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\n        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return;\n\n        VariableScope scope = innerClass.getVariableScope();\n        if (scope == null) return;\n\n        // expressions = constructor call arguments\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\n        // block = init code for the constructor we produce\n        BlockStatement block = new BlockStatement();\n        // parameters = parameters of the constructor\n        final int additionalParamCount = 1 + scope.getReferencedLocalVariablesCount();\n        List<Parameter> parameters = new ArrayList<Parameter>(expressions.size() + additionalParamCount);\n        // superCallArguments = arguments for the super call == the constructor call arguments\n        List<Expression> superCallArguments = new ArrayList<Expression>(expressions.size());\n\n        // first we add a super() call for all expressions given in the \n        // constructor call expression\n        int pCount = additionalParamCount;\n        for (Expression expr : expressions) {\n            pCount++;\n            // add one parameter for each expression in the\n            // constructor call\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE, \"p\" + pCount);\n            parameters.add(param);\n            // add to super call\n            superCallArguments.add(new VariableExpression(param));\n        }\n\n        // add the super call\n        ConstructorCallExpression cce = new ConstructorCallExpression(\n                ClassNode.SUPER,\n                new TupleExpression(superCallArguments)\n        );\n\n        block.addStatement(new ExpressionStatement(cce));\n\n        // we need to add \"this\" to access unknown methods/properties\n        // this is saved in a field named this$0\n        pCount = 0;\n        expressions.add(pCount, VariableExpression.THIS_EXPRESSION);\n        boolean isStatic = isStaticThis(innerClass,scope);\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);\n        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;\n        outerClassType = outerClassType.getPlainNodeReference();\n        Parameter thisParameter = new Parameter(outerClassType, \"p\" + pCount);\n        parameters.add(pCount, thisParameter);\n\n        thisField = innerClass.addField(\"this$0\", PUBLIC_SYNTHETIC, outerClassType, null);\n        addFieldInit(thisParameter, thisField, block);\n\n        // for each shared variable we add a reference and save it as field\n        for (Iterator it = scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\n            pCount++;\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\n            VariableExpression ve = new VariableExpression(var);\n            ve.setClosureSharedVariable(true);\n            ve.setUseReferenceDirectly(true);\n            expressions.add(pCount, ve);\n\n            ClassNode rawReferenceType = ClassHelper.REFERENCE_TYPE.getPlainNodeReference();\n            Parameter p = new Parameter(rawReferenceType, \"p\" + pCount);\n            parameters.add(pCount, p);\n            p.setOriginType(var.getOriginType());\n            final VariableExpression initial = new VariableExpression(p);\n            initial.setUseReferenceDirectly(true);\n            final FieldNode pField = innerClass.addFieldFirst(ve.getName(), PUBLIC_SYNTHETIC,rawReferenceType, initial);\n            pField.setHolder(true);\n            pField.setOriginType(ClassHelper.getWrapper(var.getOriginType()));\n        }\n\n        innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\n    }","commit_id":"288f3b15a76a3d83b39cd5ef9d38144e83eb63c6","url":"https://github.com/apache/groovy"},{"original_method":"protected boolean writeAICCall(ConstructorCallExpression call) {\n        if (!call.isUsingAnonymousInnerClass()) return false;\n        ConstructorNode cn = call.getType().getDeclaredConstructors().get(0);\n        OperandStack os = controller.getOperandStack();\n        \n        String ownerDescriptor = prepareConstructorCall(cn);\n        \n        List<Expression> args = makeArgumentList(call.getArguments()).getExpressions();\n        Parameter[] params = cn.getParameters(); \n        for (int i=0; i<params.length; i++) {\n            Parameter p = params[i];\n            Expression arg = args.get(i);\n            if (arg instanceof VariableExpression) {\n                VariableExpression var = (VariableExpression) arg;\n                loadVariableWithReference(var);\n            } else {\n                arg.visit(controller.getAcg());\n            }\n            os.doGroovyCast(p.getType());\n        }\n        \n        finnishConstructorCall(cn, ownerDescriptor, args.size());\n        return true;\n    }","id":38491,"modified_method":"protected boolean writeAICCall(ConstructorCallExpression call) {\n        if (!call.isUsingAnonymousInnerClass()) return false;\n        ConstructorNode cn = call.getType().getDeclaredConstructors().get(0);\n        OperandStack os = controller.getOperandStack();\n        \n        String ownerDescriptor = prepareConstructorCall(cn);\n        \n        List<Expression> args = makeArgumentList(call.getArguments()).getExpressions();\n        Parameter[] params = cn.getParameters();\n        // if a this appears as parameter here, then it should be\n        // not static, unless we are in a static method. But since \n        // ACG#visitVariableExpression does the opposite for this case, we\n        // push here an explicit this. This should not have any negative effect\n        // sine visiting a method call or property with implicit this will push\n        // a new value for this again.\n        controller.getCompileStack().pushImplicitThis(true);\n        for (int i=0; i<params.length; i++) {\n            Parameter p = params[i];\n            Expression arg = args.get(i);\n            if (arg instanceof VariableExpression) {\n                VariableExpression var = (VariableExpression) arg;\n                loadVariableWithReference(var);\n            } else {\n                arg.visit(controller.getAcg());\n            }\n            os.doGroovyCast(p.getType());\n        }\n        controller.getCompileStack().popImplicitThis();\n        finnishConstructorCall(cn, ownerDescriptor, args.size());\n        return true;\n    }","commit_id":"288f3b15a76a3d83b39cd5ef9d38144e83eb63c6","url":"https://github.com/apache/groovy"},{"original_method":"public InnerClassVisitor(CompilationUnit cu, SourceUnit su) {\r\n        compilationUnit = cu;\r\n        sourceUnit = su;\r\n    }","id":38492,"modified_method":"public InnerClassVisitor(CompilationUnit cu, SourceUnit su) {\r\n        sourceUnit = su;\r\n    }","commit_id":"e8b0c1027dfdf8e98bf9809d734df9bda42bb8b7","url":"https://github.com/apache/groovy"},{"original_method":"private void addDispatcherMethods() {\r\n        final int objectDistance = getObjectDistance(classNode);\r\n        \r\n        // since we added an anonymous inner class we should also\r\n        // add the dispatcher methods\r\n        \r\n        // add method dispatcher\r\n        Parameter[] parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n        MethodNode method = classNode.addSyntheticMethod(\r\n                \"this$dist$invoke$\"+objectDistance, \r\n                ACC_PUBLIC+ACC_BRIDGE+ACC_SYNTHETIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        List gStringStrings = new ArrayList();\r\n        gStringStrings.add(new ConstantExpression(\"\"));\r\n        gStringStrings.add(new ConstantExpression(\"\"));\r\n        List gStringValues = new ArrayList();\r\n        gStringValues.add(new VariableExpression(parameters[0]));\r\n        block.addStatement(\r\n                new ReturnStatement(\r\n                        new MethodCallExpression(\r\n                               VariableExpression.THIS_EXPRESSION,\r\n                               new GStringExpression(\"$name\",\r\n                                       gStringStrings,\r\n                                       gStringValues\r\n                               ),\r\n                               new ArgumentListExpression(\r\n                                       new SpreadExpression(new VariableExpression(parameters[1]))\r\n                               )\r\n                        )\r\n                )\r\n        );\r\n        method.setCode(block);\r\n        \r\n        // add property setter\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"value\")\r\n        };\r\n        method = classNode.addSyntheticMethod(\r\n                \"this$dist$set$\"+objectDistance, \r\n                ACC_PUBLIC+ACC_BRIDGE+ACC_SYNTHETIC, \r\n                ClassHelper.VOID_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        gStringStrings = new ArrayList();\r\n        gStringStrings.add(new ConstantExpression(\"\"));\r\n        gStringStrings.add(new ConstantExpression(\"\"));\r\n        gStringValues = new ArrayList();\r\n        gStringValues.add(new VariableExpression(parameters[0]));\r\n        block.addStatement(\r\n                new ExpressionStatement(\r\n                        new BinaryExpression(\r\n                                new AttributeExpression(\r\n                                        VariableExpression.THIS_EXPRESSION,\r\n                                        new GStringExpression(\"$name\",\r\n                                                gStringStrings,\r\n                                                gStringValues\r\n                                        )\r\n                                ),\r\n                                Token.newSymbol(Types.ASSIGN, -1, -1),\r\n                                new VariableExpression(parameters[1])\r\n                        )\r\n                )\r\n        );\r\n        method.setCode(block);\r\n\r\n        // add property getter\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n        method = classNode.addSyntheticMethod(\r\n                \"this$dist$get$\"+objectDistance, \r\n                ACC_PUBLIC+ACC_BRIDGE+ACC_SYNTHETIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        gStringStrings = new ArrayList();\r\n        gStringStrings.add(new ConstantExpression(\"\"));\r\n        gStringStrings.add(new ConstantExpression(\"\"));\r\n        gStringValues = new ArrayList();\r\n        gStringValues.add(new VariableExpression(parameters[0]));\r\n        block.addStatement(\r\n                new ReturnStatement(\r\n                        new AttributeExpression(\r\n                                VariableExpression.THIS_EXPRESSION,\r\n                                new GStringExpression(\"$name\",\r\n                                        gStringStrings,\r\n                                        gStringValues\r\n                                )\r\n                        )\r\n                )\r\n        );\r\n        method.setCode(block);\r\n    }","id":38493,"modified_method":"private void addDispatcherMethods() {\r\n        final int objectDistance = getObjectDistance(classNode);\r\n        \r\n        // since we added an anonymous inner class we should also\r\n        // add the dispatcher methods\r\n        \r\n        // add method dispatcher\r\n        Parameter[] parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n        MethodNode method = classNode.addSyntheticMethod(\r\n                \"this$dist$invoke$\"+objectDistance, \r\n                ACC_PUBLIC+ACC_BRIDGE+ACC_SYNTHETIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        setMethodDispatcherCode(block, VariableExpression.THIS_EXPRESSION, parameters);\r\n        method.setCode(block);\r\n        \r\n        // add property setter\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"value\")\r\n        };\r\n        method = classNode.addSyntheticMethod(\r\n                \"this$dist$set$\"+objectDistance, \r\n                ACC_PUBLIC+ACC_BRIDGE+ACC_SYNTHETIC, \r\n                ClassHelper.VOID_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setPropertySetDispatcher(block,VariableExpression.THIS_EXPRESSION,parameters);\r\n        method.setCode(block);\r\n\r\n        // add property getter\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n        method = classNode.addSyntheticMethod(\r\n                \"this$dist$get$\"+objectDistance, \r\n                ACC_PUBLIC+ACC_BRIDGE+ACC_SYNTHETIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        block = new BlockStatement();\r\n        setPropertyGetterDispatcher(block, VariableExpression.THIS_EXPRESSION, parameters);\r\n        method.setCode(block);\r\n    }","commit_id":"e8b0c1027dfdf8e98bf9809d734df9bda42bb8b7","url":"https://github.com/apache/groovy"},{"original_method":"private void addDefaultMethods(InnerClassNode node) {\r\n        if(node.getVariableScope()==null) return;\r\n        \r\n        final String classInternalName = BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = BytecodeHelper.getClassInternalName(node.getOuterClass());\r\n        final String outerClassDescriptor = BytecodeHelper.getTypeDescription(node.getOuterClass());\r\n        final int objectDistance = getObjectDistance(node.getOuterClass());\r\n        \r\n        // add method dispatcher\r\n        Parameter[] parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n        MethodNode method = node.addSyntheticMethod(\r\n                \"methodMissing\", \r\n                Opcodes.ACC_PUBLIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        block.addStatement(\r\n                new BytecodeSequence(new BytecodeInstruction() {\r\n                    public void visit(MethodVisitor mv) {\r\n                        mv.visitVarInsn(ALOAD, 0);\r\n                        mv.visitFieldInsn(GETFIELD, classInternalName, \"this$0\", outerClassDescriptor);\r\n                        mv.visitVarInsn(ALOAD, 1);\r\n                        mv.visitVarInsn(ALOAD, 2);\r\n                        mv.visitMethodInsn( INVOKEVIRTUAL, \r\n                                            outerClassInternalName, \r\n                                            \"this$dist$invoke$\"+objectDistance, \r\n                                            \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\");\r\n                        mv.visitInsn(ARETURN);\r\n                    }\r\n                })\r\n        );\r\n        method.setCode(block);\r\n        \r\n        // add property getter dispatcher\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n        method = node.addSyntheticMethod(\r\n                \"propertyMissing\", \r\n                Opcodes.ACC_PUBLIC, \r\n                ClassHelper.VOID_TYPE,\r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n        \r\n        block = new BlockStatement();\r\n        block.addStatement(\r\n                new BytecodeSequence(new BytecodeInstruction() {\r\n                    public void visit(MethodVisitor mv) {\r\n                        mv.visitVarInsn(ALOAD, 0);\r\n                        mv.visitFieldInsn(GETFIELD, classInternalName, \"this$0\", outerClassDescriptor);\r\n                        mv.visitVarInsn(ALOAD, 1);\r\n                        mv.visitVarInsn(ALOAD, 2);\r\n                        mv.visitMethodInsn( INVOKEVIRTUAL, \r\n                                            outerClassInternalName, \r\n                                            \"this$dist$set$\"+objectDistance,\r\n                                            \"(Ljava/lang/String;Ljava/lang/Object;)V\");\r\n                        mv.visitInsn(RETURN);\r\n                    }\r\n                })\r\n        );\r\n        method.setCode(block);\r\n        \r\n        // add property setter dispatcher\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n        method = node.addSyntheticMethod(\r\n                \"propertyMissing\", \r\n                Opcodes.ACC_PUBLIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n        \r\n        block = new BlockStatement();\r\n        block.addStatement(\r\n                new BytecodeSequence(new BytecodeInstruction() {\r\n                    public void visit(MethodVisitor mv) {\r\n                        mv.visitVarInsn(ALOAD, 0);\r\n                        mv.visitFieldInsn(GETFIELD, classInternalName, \"this$0\", outerClassDescriptor);\r\n                        mv.visitVarInsn(ALOAD, 1);\r\n                        mv.visitMethodInsn( INVOKEVIRTUAL, \r\n                                            outerClassInternalName, \r\n                                            \"this$dist$get$\"+objectDistance, \r\n                                            \"(Ljava/lang/String;)Ljava/lang/Object;\");\r\n                        mv.visitInsn(ARETURN);\r\n                    }\r\n                })\r\n        );\r\n        method.setCode(block);\r\n    }","id":38494,"modified_method":"private void addDefaultMethods(InnerClassNode node) {\r\n        if(node.getVariableScope()==null) return;\r\n        final boolean isStatic = node.getVariableScope().isInStaticContext();\r\n        \r\n        final String classInternalName = BytecodeHelper.getClassInternalName(node);\r\n        final String outerClassInternalName = getInternalName(node.getOuterClass(),isStatic);\r\n        final String outerClassDescriptor = getTypeDescriptor(node.getOuterClass(),isStatic);\r\n        final int objectDistance = getObjectDistance(node.getOuterClass());\r\n        \r\n        // add method dispatcher\r\n        Parameter[] parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"args\")\r\n        };\r\n        MethodNode method = node.addSyntheticMethod(\r\n                \"methodMissing\", \r\n                Opcodes.ACC_PUBLIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n\r\n        BlockStatement block = new BlockStatement();\r\n        if (isStatic) {\r\n        \tsetMethodDispatcherCode(block, new ClassExpression(node.getOuterClass()), parameters);\r\n        } else {\r\n\t        block.addStatement(\r\n\t                new BytecodeSequence(new BytecodeInstruction() {\r\n\t                    public void visit(MethodVisitor mv) {\r\n\t                        mv.visitVarInsn(ALOAD, 0);\r\n\t                        mv.visitFieldInsn(GETFIELD, classInternalName, \"this$0\", outerClassDescriptor);\r\n\t                        mv.visitVarInsn(ALOAD, 1);\r\n\t                        mv.visitVarInsn(ALOAD, 2);\r\n\t                        mv.visitMethodInsn( INVOKEVIRTUAL, \r\n\t                                            outerClassInternalName, \r\n\t                                            \"this$dist$invoke$\"+objectDistance, \r\n\t                                            \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;\");\r\n\t                        mv.visitInsn(ARETURN);\r\n\t                    }\r\n\t                })\r\n\t        );\r\n        }\r\n        method.setCode(block);\r\n        \r\n        // add property getter dispatcher\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\"),\r\n                new Parameter(ClassHelper.OBJECT_TYPE, \"val\")\r\n        };\r\n        method = node.addSyntheticMethod(\r\n                \"propertyMissing\", \r\n                Opcodes.ACC_PUBLIC, \r\n                ClassHelper.VOID_TYPE,\r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n        \r\n        block = new BlockStatement();\r\n        if (isStatic) {\r\n        \tsetPropertySetDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n\t    } else {\r\n\t        block.addStatement(\r\n\t                new BytecodeSequence(new BytecodeInstruction() {\r\n\t                    public void visit(MethodVisitor mv) {\r\n\t                        mv.visitVarInsn(ALOAD, 0);\r\n\t                        mv.visitFieldInsn(GETFIELD, classInternalName, \"this$0\", outerClassDescriptor);\r\n\t                        mv.visitVarInsn(ALOAD, 1);\r\n\t                        mv.visitVarInsn(ALOAD, 2);\r\n\t                        mv.visitMethodInsn( INVOKEVIRTUAL, \r\n\t                                            outerClassInternalName, \r\n\t                                            \"this$dist$set$\"+objectDistance,\r\n\t                                            \"(Ljava/lang/String;Ljava/lang/Object;)V\");\r\n\t                        mv.visitInsn(RETURN);\r\n\t                    }\r\n\t                })\r\n\t        );\r\n\t    }\r\n        method.setCode(block);\r\n        \r\n        // add property setter dispatcher\r\n        parameters = new Parameter[] {\r\n                new Parameter(ClassHelper.STRING_TYPE, \"name\")\r\n        };\r\n        method = node.addSyntheticMethod(\r\n                \"propertyMissing\", \r\n                Opcodes.ACC_PUBLIC, \r\n                ClassHelper.OBJECT_TYPE, \r\n                parameters, \r\n                ClassNode.EMPTY_ARRAY, \r\n                null\r\n        );\r\n        \r\n        block = new BlockStatement();\r\n\t    if (isStatic) {\r\n\t    \tsetPropertyGetterDispatcher(block, new ClassExpression(node.getOuterClass()), parameters);\r\n\t    } else {\r\n\t        block.addStatement(\r\n\t                new BytecodeSequence(new BytecodeInstruction() {\r\n\t                    public void visit(MethodVisitor mv) {\r\n\t                        mv.visitVarInsn(ALOAD, 0);\r\n\t                        mv.visitFieldInsn(GETFIELD, classInternalName, \"this$0\", outerClassDescriptor);\r\n\t                        mv.visitVarInsn(ALOAD, 1);\r\n\t                        mv.visitMethodInsn( INVOKEVIRTUAL, \r\n\t                                            outerClassInternalName, \r\n\t                                            \"this$dist$get$\"+objectDistance, \r\n\t                                            \"(Ljava/lang/String;)Ljava/lang/Object;\");\r\n\t                        mv.visitInsn(ARETURN);\r\n\t                    }\r\n\t                })\r\n\t        );\r\n\t    }\r\n        method.setCode(block);\r\n    }","commit_id":"e8b0c1027dfdf8e98bf9809d734df9bda42bb8b7","url":"https://github.com/apache/groovy"},{"original_method":"@Override\r\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\r\n        super.visitConstructorCallExpression(call);\r\n        if (!call.isUsingAnnonymousInnerClass()) return;\r\n        \r\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\r\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\r\n        if ((innerClass.getModifiers() & ACC_STATIC)!=0) return;\r\n        \r\n        VariableScope scope = innerClass.getVariableScope();\r\n        if (scope==null) return;\r\n        \r\n        // expressions = constructor call arguments\r\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\r\n        // block = init code for the constructor we produce\r\n        BlockStatement block = new BlockStatement();\r\n        // parameters = parameters of the constructor\r\n        List parameters = new ArrayList(expressions.size()+1+scope.getReferencedLocalVariablesCount());\r\n        // superCallArguments = arguments for the super call == the constructor call arguments\r\n        List superCallArguments = new ArrayList(expressions.size());\r\n        \r\n        // first we add a super() call for all expressions given in the \r\n        // constructor call expression\r\n        int pCount = 0;\r\n        for (Expression expr : expressions) {\r\n            pCount++;\r\n            // add one parameter for each expression in the \r\n            // constructor call\r\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE,\"p\"+pCount);\r\n            parameters.add(param);\r\n            // add to super call\r\n            superCallArguments.add(new VariableExpression(param));\r\n        }\r\n        \r\n        // add the super call\r\n        ConstructorCallExpression cce = new ConstructorCallExpression(\r\n                ClassNode.SUPER,\r\n                new TupleExpression(superCallArguments)\r\n        );\r\n        block.addStatement(new ExpressionStatement(cce));\r\n        \r\n        // we need to add \"this\" to access unknown methods/properties\r\n        // this is saved in a field named this$0\r\n        expressions.add(VariableExpression.THIS_EXPRESSION);\r\n        pCount++;\r\n        Parameter thisParameter = new Parameter(innerClass.getOuterClass(),\"p\"+pCount);\r\n        parameters.add(thisParameter);\r\n        int privateSynthetic = Opcodes.ACC_PRIVATE+Opcodes.ACC_SYNTHETIC;\r\n        FieldNode thisField = innerClass.addField(\"this$0\", privateSynthetic, innerClass.getOuterClass(), null);\r\n        addFieldInit(thisParameter,thisField,block,false);\r\n\r\n        // for each shared variable we add a reference and save it as field\r\n        for (Iterator it=scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\r\n            pCount++;\r\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\r\n            VariableExpression ve = new VariableExpression(var);\r\n            ve.setClosureSharedVariable(true);\r\n            ve.setUseReferenceDirectly(true);\r\n            expressions.add(ve);\r\n            \r\n            Parameter p = new Parameter(ClassHelper.REFERENCE_TYPE,\"p\"+pCount);\r\n            //p.setClosureSharedVariable(true);\r\n            parameters.add(p);\r\n            FieldNode pField = innerClass.addField(ve.getName(), privateSynthetic, ClassHelper.REFERENCE_TYPE, null);\r\n            pField.setHolder(true);\r\n            addFieldInit(p,pField,block,true);            \r\n        }\r\n        \r\n        innerClass.addConstructor(ACC_PUBLIC, (Parameter[]) parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\r\n        \r\n    }","id":38495,"modified_method":"@Override\r\n    public void visitConstructorCallExpression(ConstructorCallExpression call) {\r\n        super.visitConstructorCallExpression(call);\r\n        if (!call.isUsingAnnonymousInnerClass()) return;\r\n        \r\n        InnerClassNode innerClass = (InnerClassNode) call.getType();\r\n        if (!innerClass.getDeclaredConstructors().isEmpty()) return;\r\n        if ((innerClass.getModifiers() & ACC_STATIC)!=0) return;\r\n        \r\n        VariableScope scope = innerClass.getVariableScope();\r\n        if (scope==null) return;\r\n        \r\n        \r\n        boolean isStatic = scope.isInStaticContext();\r\n        // expressions = constructor call arguments\r\n        List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();\r\n        // block = init code for the constructor we produce\r\n        BlockStatement block = new BlockStatement();\r\n        // parameters = parameters of the constructor\r\n        List parameters = new ArrayList(expressions.size()+1+scope.getReferencedLocalVariablesCount());\r\n        // superCallArguments = arguments for the super call == the constructor call arguments\r\n        List superCallArguments = new ArrayList(expressions.size());\r\n        \r\n        // first we add a super() call for all expressions given in the \r\n        // constructor call expression\r\n        int pCount = 0;\r\n        for (Expression expr : expressions) {\r\n            pCount++;\r\n            // add one parameter for each expression in the \r\n            // constructor call\r\n            Parameter param = new Parameter(ClassHelper.OBJECT_TYPE,\"p\"+pCount);\r\n            parameters.add(param);\r\n            // add to super call\r\n            superCallArguments.add(new VariableExpression(param));\r\n        }\r\n        \r\n        // add the super call\r\n        ConstructorCallExpression cce = new ConstructorCallExpression(\r\n                ClassNode.SUPER,\r\n                new TupleExpression(superCallArguments)\r\n        );\r\n        block.addStatement(new ExpressionStatement(cce));\r\n        \r\n        // we need to add \"this\" to access unknown methods/properties\r\n        // this is saved in a field named this$0\r\n        expressions.add(VariableExpression.THIS_EXPRESSION);\r\n        pCount++;\r\n        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(),isStatic);\r\n        Parameter thisParameter = new Parameter(outerClassType,\"p\"+pCount);\r\n        parameters.add(thisParameter);\r\n        int privateSynthetic = Opcodes.ACC_PRIVATE+Opcodes.ACC_SYNTHETIC;\r\n        FieldNode thisField = innerClass.addField(\"this$0\", privateSynthetic, outerClassType, null);\r\n        addFieldInit(thisParameter,thisField,block,false);\r\n\r\n        // for each shared variable we add a reference and save it as field\r\n        for (Iterator it=scope.getReferencedLocalVariablesIterator(); it.hasNext();) {\r\n            pCount++;\r\n            org.codehaus.groovy.ast.Variable var = (org.codehaus.groovy.ast.Variable) it.next();\r\n            VariableExpression ve = new VariableExpression(var);\r\n            ve.setClosureSharedVariable(true);\r\n            ve.setUseReferenceDirectly(true);\r\n            expressions.add(ve);\r\n            \r\n            Parameter p = new Parameter(ClassHelper.REFERENCE_TYPE,\"p\"+pCount);\r\n            //p.setClosureSharedVariable(true);\r\n            parameters.add(p);\r\n            FieldNode pField = innerClass.addField(ve.getName(), privateSynthetic, ClassHelper.REFERENCE_TYPE, null);\r\n            pField.setHolder(true);\r\n            addFieldInit(p,pField,block,true);            \r\n        }\r\n        \r\n        innerClass.addConstructor(ACC_PUBLIC, (Parameter[]) parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);\r\n        \r\n    }","commit_id":"e8b0c1027dfdf8e98bf9809d734df9bda42bb8b7","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n\tpublic void changeState (State<E> newState) {\n\t\t// Keep a record of the previous state\n\t\tpreviousState = currentState;\n\n\t\t// Call the exit method of the existing state\n\t\tif (currentState != null) currentState.exit(owner);\n\n\t\t// Change state to the new state\n\t\tcurrentState = newState;\n\n\t\t// Call the entry method of the new state\n\t\tcurrentState.enter(owner);\n\t}","id":38496,"modified_method":"@Override\n\tpublic void changeState (State<E> newState) {\n\t\t// Keep a record of the previous state\n\t\tpreviousState = currentState;\n\n\t\t// Call the exit method of the existing state\n\t\tif (currentState != null) currentState.exit(owner);\n\n\t\t// Change state to the new state\n\t\tcurrentState = newState;\n\n\t\t// Call the entry method of the new state\n\t\tif (currentState != null) currentState.enter(owner);\n\t}","commit_id":"e422cddf219a995ead75a7428f96da9e48271ee4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public ERXJavaScript(String s, NSDictionary nsdictionary, WOElement woelement) {\n\t\tsuper(\"script\", nsdictionary, woelement);\n\t\t_scriptFile = (WOAssociation)_associations.removeObjectForKey(\"scriptFile\");\n\t\t_scriptString = (WOAssociation)_associations.removeObjectForKey(\"scriptString\");\n\t\t_scriptSource = (WOAssociation)_associations.removeObjectForKey(\"scriptSource\");\n\t\t_filename = (WOAssociation)_associations.removeObjectForKey(\"filename\");\n\t\t_language = (WOAssociation)_associations.removeObjectForKey(\"language\");\n\t\t_scriptKey = (WOAssociation)_associations.removeObjectForKey(\"scriptKey\");\n\t\t_hideInComment = (WOAssociation)_associations.removeObjectForKey(\"hideInComment\");\n\t\t_scriptFramework = (WOAssociation) _associations.removeObjectForKey(\"scriptFramework\");\n\t\t_framework = (WOAssociation) _associations.removeObjectForKey(\"framework\");\n\t\tif((_scriptFile != null && _scriptString != null) \n\t\t\t\t|| (_scriptFile != null && (_scriptSource != null || _filename != null)) \n\t\t\t\t|| (_scriptString != null && (_scriptSource != null || _filename != null))) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'scriptString' or 'scriptSource/filename' attributes can be specified.\");\n\t\t}\n\t\tif (_scriptFramework != null && _framework != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFramework' or 'framework' can be specified.\");\n\t\t}\n\t\tif (_scriptSource != null && _filename != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'filename' can be specified.\");\n\t\t}\n\t}","id":38497,"modified_method":"public ERXJavaScript(String s, NSDictionary<String, WOAssociation> nsdictionary, WOElement woelement) {\n\t\tsuper(\"script\", nsdictionary, woelement);\n\t\t_scriptFile = _associations.removeObjectForKey(\"scriptFile\");\n\t\t_scriptString = _associations.removeObjectForKey(\"scriptString\");\n\t\t_scriptSource = _associations.removeObjectForKey(\"scriptSource\");\n\t\t_filename = _associations.removeObjectForKey(\"filename\");\n\t\t_language = _associations.removeObjectForKey(\"language\");\n\t\t_scriptKey = _associations.removeObjectForKey(\"scriptKey\");\n\t\t_hideInComment = _associations.removeObjectForKey(\"hideInComment\");\n\t\t_scriptFramework = _associations.removeObjectForKey(\"scriptFramework\");\n\t\t_framework = _associations.removeObjectForKey(\"framework\");\n\t\tif((_scriptFile != null && _scriptString != null) \n\t\t\t\t|| (_scriptFile != null && (_scriptSource != null || _filename != null)) \n\t\t\t\t|| (_scriptString != null && (_scriptSource != null || _filename != null))) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'scriptString' or 'scriptSource/filename' attributes can be specified.\");\n\t\t}\n\t\tif (_scriptFramework != null && _framework != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFramework' or 'framework' can be specified.\");\n\t\t}\n\t\tif (_scriptSource != null && _filename != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'filename' can be specified.\");\n\t\t}\n\t}","commit_id":"780153af3a119913dfbe7c170a1219b5062572c3","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"<\");\n\t\tsb.append(getClass().getName());\n\t\tsb.append(\" scriptFile=\" + _scriptFile);\n\t\tsb.append(\" scriptString=\" + _scriptString);\n\t\tsb.append(\" scriptFramework=\" + _scriptFramework);\n\t\tsb.append(\" framework=\" + _framework);\n\t\tsb.append(\" scriptSource=\" + _scriptSource);\n\t\tsb.append(\" filename=\" + _filename);\n\t\tsb.append(\" hideInComment=\" + _hideInComment);\n\t\tsb.append(\" language=\" + _language);\n\t\tsb.append(\">\");\n\t\treturn sb.toString();\n\t}","id":38498,"modified_method":"@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"<\");\n\t\tsb.append(getClass().getName());\n\t\tsb.append(\" scriptFile=\" + _scriptFile);\n\t\tsb.append(\" scriptString=\" + _scriptString);\n\t\tsb.append(\" scriptFramework=\" + _scriptFramework);\n\t\tsb.append(\" framework=\" + _framework);\n\t\tsb.append(\" scriptSource=\" + _scriptSource);\n\t\tsb.append(\" filename=\" + _filename);\n\t\tsb.append(\" hideInComment=\" + _hideInComment);\n\t\tsb.append(\" language=\" + _language);\n\t\tsb.append(\">\");\n\t\treturn sb.toString();\n\t}","commit_id":"780153af3a119913dfbe7c170a1219b5062572c3","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void appendChildrenToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\t\tString script = \"\";\n\t\t\tboolean hideInComment = true;\n\t\t\tWOComponent wocomponent = wocontext.component();\n\t\t\tif(_hideInComment != null) {\n\t\t\t\thideInComment = _hideInComment.booleanValueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"<!--\");\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(_scriptFile != null) {\n\t\t\t\tString filename = (String) _scriptFile.valueInComponent(wocomponent);\n\t\t\t\tif(filename != null) {\n\t\t\t\t\tString framework = null;\n\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\tjava.net.URL url = WOApplication.application().resourceManager().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\turl = wocontext.component()._componentDefinition().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\t}\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : cannot find script file '\" + filename + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tscript = _NSStringUtilities.stringFromPathURL(url);\n\t\t\t\t\tif (ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\tscript = ERXResourceManager._completeURLForResource(script, null, wocontext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else if(_scriptString != null) {\n\t\t\t\tObject obj1 = _scriptString.valueInComponent(wocomponent);\n\t\t\t\tif(obj1 != null) {\n\t\t\t\t\tscript = obj1.toString();\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else {\n\t\t\t\tsuper.appendChildrenToResponse(woresponse, wocontext);\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"//-->\");\n\t\t\t}\n\t}","id":38499,"modified_method":"@Override\n\tpublic void appendChildrenToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\t\tString script = \"\";\n\t\t\tboolean hideInComment = ERXProperties.booleanForKeyWithDefault(\"er.extensions.ERXJavaScript.hideInComment\", true);\n\t\t\tWOComponent wocomponent = wocontext.component();\n\t\t\tif(_hideInComment != null) {\n\t\t\t\thideInComment = _hideInComment.booleanValueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"<!--\");\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(_scriptFile != null) {\n\t\t\t\tString filename = (String) _scriptFile.valueInComponent(wocomponent);\n\t\t\t\tif(filename != null) {\n\t\t\t\t\tString framework = null;\n\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\tjava.net.URL url = WOApplication.application().resourceManager().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\turl = wocontext.component()._componentDefinition().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\t}\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : cannot find script file '\" + filename + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tscript = _NSStringUtilities.stringFromPathURL(url);\n\t\t\t\t\tif (ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\tscript = ERXResourceManager._completeURLForResource(script, null, wocontext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else if(_scriptString != null) {\n\t\t\t\tObject obj1 = _scriptString.valueInComponent(wocomponent);\n\t\t\t\tif(obj1 != null) {\n\t\t\t\t\tscript = obj1.toString();\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else {\n\t\t\t\tsuper.appendChildrenToResponse(woresponse, wocontext);\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"//-->\");\n\t\t\t}\n\t}","commit_id":"780153af3a119913dfbe7c170a1219b5062572c3","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean disabledInComponent(WOComponent component) {\n\t\treturn _disabled != null && _disabled.booleanValueInComponent(component);\n\t}","id":38500,"modified_method":"/**\n\t * @deprecated use {@link #isDisabledInContext(WOContext)} instead\n\t */\n\t@Deprecated\n\tpublic boolean disabledInComponent(WOComponent component) {\n\t\treturn isDisabledInContext(component.context());\n\t}","commit_id":"fbc299e9a2b0f5e3caf5bd8183389bc530b01ca5","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void _fastTakeValuesFromRequest(WORequest worequest, WOContext wocontext) {\n\t\tWOComponent wocomponent = wocontext.component();\n\t\tif (_selections != null && !disabledInComponent(wocomponent) && wocontext.wasFormSubmitted()) {\n\t\t\tString s = nameInContext(wocontext, wocomponent);\n\t\t\tNSArray nsarray = worequest.formValuesForKey(s);\n\t\t\tint i = nsarray != null ? nsarray.count() : 0;\n\t\t\tNSMutableArray nsmutablearray = new NSMutableArray(i);\n\t\t\tList vector = null;\n\t\t\tif (i != 0) {\n\t\t\t\tNSArray nsarray1 = null;\n\t\t\t\tList vector1 = null;\n\t\t\t\tif (_list != null) {\n\t\t\t\t\tObject obj = _list.valueInComponent(wocomponent);\n\t\t\t\t\tif (obj != null) {\n\t\t\t\t\t\tif (obj instanceof NSArray) {\n\t\t\t\t\t\t\tnsarray1 = (NSArray) obj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (obj instanceof List) {\n\t\t\t\t\t\t\tvector1 = (List) obj;\n\t\t\t\t\t\t\tnsmutablearray = null;\n\t\t\t\t\t\t\tvector = new ArrayList(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"<\" + getClass().getName() + \"> Evaluating 'list' binding returned a \" + obj.getClass().getName() + \" when it should return either a com.webobjects.foundation.NSArray, or a java.lang.Vector .\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tString s1 = (String) nsarray.objectAtIndex(j);\n\t\t\t\t\tint k = Integer.parseInt(s1);\n\t\t\t\t\tif (nsarray1 != null) {\n\t\t\t\t\t\tObject obj2 = nsarray1.objectAtIndex(k);\n\t\t\t\t\t\tnsmutablearray.addObject(obj2);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tObject obj3 = vector1.get(k);\n\t\t\t\t\t\tvector.add(obj3);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tObject newValue = (nsmutablearray != null ? nsmutablearray: vector);\n\t\t\tsetSelectedValue(newValue, wocomponent);\n\t\t}\n\t}","id":38501,"modified_method":"private void _fastTakeValuesFromRequest(WORequest worequest, WOContext wocontext) {\n\t\tWOComponent wocomponent = wocontext.component();\n\t\tif (_selections != null && !isDisabledInContext(wocontext) && wocontext.wasFormSubmitted()) {\n\t\t\tString s = nameInContext(wocontext, wocomponent);\n\t\t\tNSArray nsarray = worequest.formValuesForKey(s);\n\t\t\tint i = nsarray != null ? nsarray.count() : 0;\n\t\t\tNSMutableArray nsmutablearray = new NSMutableArray(i);\n\t\t\tList vector = null;\n\t\t\tif (i != 0) {\n\t\t\t\tNSArray nsarray1 = null;\n\t\t\t\tList vector1 = null;\n\t\t\t\tif (_list != null) {\n\t\t\t\t\tObject obj = _list.valueInComponent(wocomponent);\n\t\t\t\t\tif (obj != null) {\n\t\t\t\t\t\tif (obj instanceof NSArray) {\n\t\t\t\t\t\t\tnsarray1 = (NSArray) obj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (obj instanceof List) {\n\t\t\t\t\t\t\tvector1 = (List) obj;\n\t\t\t\t\t\t\tnsmutablearray = null;\n\t\t\t\t\t\t\tvector = new ArrayList(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"<\" + getClass().getName() + \"> Evaluating 'list' binding returned a \" + obj.getClass().getName() + \" when it should return either a com.webobjects.foundation.NSArray, or a java.lang.Vector .\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tString s1 = (String) nsarray.objectAtIndex(j);\n\t\t\t\t\tint k = Integer.parseInt(s1);\n\t\t\t\t\tif (nsarray1 != null) {\n\t\t\t\t\t\tObject obj2 = nsarray1.objectAtIndex(k);\n\t\t\t\t\t\tnsmutablearray.addObject(obj2);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tObject obj3 = vector1.get(k);\n\t\t\t\t\t\tvector.add(obj3);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tObject newValue = (nsmutablearray != null ? nsmutablearray: vector);\n\t\t\tsetSelectedValue(newValue, wocomponent);\n\t\t}\n\t}","commit_id":"fbc299e9a2b0f5e3caf5bd8183389bc530b01ca5","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String toString() {\n\t\treturn \"<\" +getClass().getSimpleName() + \" list: \" + _list.toString() + \" item: \" + (_item == null ? \"null\" : _item.toString()) + \" string: \" + (_displayString == null ? \"null\" : _displayString.toString()) + \" selections: \" + (_selections == null ? \"null\" : _selections.toString()) + \" selectedValues: \" + (_selectedValues == null ? \"null\" : _selectedValues.toString()) + \" multiple: \" + (_multiple == null ? \"null\" : _multiple.toString()) + \" size: \" + (_size == null ? \"null\" : _size.toString()) + \" escapeHTML: \" + (_escapeHTML == null ? \"null\" : _escapeHTML.toString()) + \" >\";\n\t}","id":38502,"modified_method":"@Override\n\tpublic String toString() {\n\t\treturn new StringBuilder('<').append(getClass().getSimpleName()).append(\" list: \").append(_list)\n\t\t\t\t.append(\" item: \").append(_item).append(\" string: \").append(_displayString)\n\t\t\t\t.append(\" selections: \").append(_selections).append(\" selectedValues: \")\n\t\t\t\t.append(_selectedValues).append(\" multiple: \").append(_multiple)\n\t\t\t\t.append(\" size: \").append(_size).append(\" escapeHTML: \").append(_escapeHTML).append('>').toString();\n\t}","commit_id":"fbc299e9a2b0f5e3caf5bd8183389bc530b01ca5","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXWOBrowser(String s, NSDictionary nsdictionary, WOElement woelement) {\n\t\tsuper(\"select\", nsdictionary, null);\n\t\t_loggedSlow = false;\n\t\t_disabled = (WOAssociation) nsdictionary.objectForKey(\"disabled\");\n\t\t_list = (WOAssociation) _associations.removeObjectForKey(\"list\");\n\t\t_item = (WOAssociation) _associations.removeObjectForKey(\"item\");\n\t\t_displayString = (WOAssociation) _associations.removeObjectForKey(\"displayString\");\n\t\t_multiple = (WOAssociation) _associations.removeObjectForKey(\"multiple\");\n\t\t_size = (WOAssociation) _associations.removeObjectForKey(\"size\");\n\t\t_escapeHTML = (WOAssociation) _associations.removeObjectForKey(\"escapeHTML\");\n\t\tString suffix = (isBrowser() ? \"s\" : \"\");\n\t\t_selections = (WOAssociation) _associations.removeObjectForKey(\"selection\" + suffix);\n\t\t_selectedValues = (WOAssociation) _associations.removeObjectForKey(\"selectedValue\" + suffix);\n\t\tif (_list == null || (_value != null || _displayString != null) && (_item == null || !_item.isValueSettable()) || _selections != null && !_selections.isValueSettable()) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : Invalid attributes: 'list' must be present. 'item' must not be a constant if 'value' is present.  Cannot have 'displayString' or 'value' without 'item'.  'selection' must not be a constant if present. 'value' is not allowed anymore.\");\n\t\t}\n\t\tif (_selections != null && _selectedValues != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : Cannot have both selections and selectedValues.\");\n\t\t}\n\t}","id":38503,"modified_method":"public ERXWOBrowser(String s, NSDictionary nsdictionary, WOElement woelement) {\n\t\tsuper(\"select\", nsdictionary, null);\n\t\t_loggedSlow = false;\n\t\t_list = _associations.removeObjectForKey(\"list\");\n\t\t_item = _associations.removeObjectForKey(\"item\");\n\t\t_displayString = _associations.removeObjectForKey(\"displayString\");\n\t\t_multiple = _associations.removeObjectForKey(\"multiple\");\n\t\t_size = _associations.removeObjectForKey(\"size\");\n\t\tString suffix = (isBrowser() ? \"s\" : \"\");\n\t\t_selections = _associations.removeObjectForKey(\"selection\" + suffix);\n\t\t_selectedValues = _associations.removeObjectForKey(\"selectedValue\" + suffix);\n\t\tif (_list == null || (_value != null || _displayString != null) && (_item == null || !_item.isValueSettable()) || _selections != null && !_selections.isValueSettable()) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : Invalid attributes: 'list' must be present. 'item' must not be a constant if 'value' is present.  Cannot have 'displayString' or 'value' without 'item'.  'selection' must not be a constant if present. 'value' is not allowed anymore.\");\n\t\t}\n\t\tif (_selections != null && _selectedValues != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : Cannot have both selections and selectedValues.\");\n\t\t}\n\t}","commit_id":"fbc299e9a2b0f5e3caf5bd8183389bc530b01ca5","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void _slowTakeValuesFromRequest(WORequest worequest, WOContext wocontext) {\n\t\tWOComponent wocomponent = wocontext.component();\n\t\tif (_selections != null && !disabledInComponent(wocomponent) && wocontext.wasFormSubmitted()) {\n\t\t\tString s = nameInContext(wocontext, wocomponent);\n\t\t\tNSArray nsarray = worequest.formValuesForKey(s);\n\t\t\tint i = nsarray != null ? nsarray.count() : 0;\n\t\t\tint size = 0;\n\t\t\tNSMutableArray nsmutablearray = new NSMutableArray(i);\n\t\t\tList vector = null;\n\t\t\tif (i != 0) {\n\t\t\t\tNSArray nsarray1 = null;\n\t\t\t\tList vector1 = null;\n\t\t\t\tObject list = _list.valueInComponent(wocomponent);\n\t\t\t\tif (list != null) {\n\t\t\t\t\tif (list instanceof NSArray) {\n\t\t\t\t\t\tnsarray1 = (NSArray) list;\n\t\t\t\t\t\tsize = nsarray1.count();\n\t\t\t\t\t}\n\t\t\t\t\telse if (list instanceof List) {\n\t\t\t\t\t\tvector1 = (List) list;\n\t\t\t\t\t\tnsmutablearray = null;\n\t\t\t\t\t\tvector = new ArrayList();\n\t\t\t\t\t\tsize = vector1.size();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"<\" + getClass().getName() + \"> Evaluating 'list' binding returned a \" + list.getClass().getName() + \" when it should return either a com.webobjects.foundation.NSArray, or a java.lang.Vector .\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean flag = _multiple != null ? _multiple.booleanValueInComponent(wocomponent) : false;\n\t\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\t\tObject obj1 = nsarray1 == null ? vector1.get(k) : nsarray1.objectAtIndex(k);\n\t\t\t\t\t_item.setValue(obj1, wocomponent);\n\t\t\t\t\tObject obj2 = _value.valueInComponent(wocomponent);\n\t\t\t\t\tif (obj2 != null) {\n\t\t\t\t\t\tif (!nsarray.containsObject(obj2.toString())) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nsarray1 != null) {\n\t\t\t\t\t\t\tnsmutablearray.addObject(obj1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvector.add(obj1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!flag) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.debug(toString() + \" 'value' evaluated to null in component \" + wocomponent.toString() + \".\\n\" + \"Unable to select item \" + obj1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tObject newValue = (nsmutablearray != null ? nsmutablearray: vector);\n\t\t\tsetSelectedValue(newValue, wocomponent);\n\t\t}\n\t}","id":38504,"modified_method":"private void _slowTakeValuesFromRequest(WORequest worequest, WOContext wocontext) {\n\t\tWOComponent wocomponent = wocontext.component();\n\t\tif (_selections != null && !isDisabledInContext(wocontext) && wocontext.wasFormSubmitted()) {\n\t\t\tString s = nameInContext(wocontext, wocomponent);\n\t\t\tNSArray nsarray = worequest.formValuesForKey(s);\n\t\t\tint i = nsarray != null ? nsarray.count() : 0;\n\t\t\tint size = 0;\n\t\t\tNSMutableArray nsmutablearray = new NSMutableArray(i);\n\t\t\tList vector = null;\n\t\t\tif (i != 0) {\n\t\t\t\tNSArray nsarray1 = null;\n\t\t\t\tList vector1 = null;\n\t\t\t\tObject list = _list.valueInComponent(wocomponent);\n\t\t\t\tif (list != null) {\n\t\t\t\t\tif (list instanceof NSArray) {\n\t\t\t\t\t\tnsarray1 = (NSArray) list;\n\t\t\t\t\t\tsize = nsarray1.count();\n\t\t\t\t\t}\n\t\t\t\t\telse if (list instanceof List) {\n\t\t\t\t\t\tvector1 = (List) list;\n\t\t\t\t\t\tnsmutablearray = null;\n\t\t\t\t\t\tvector = new ArrayList();\n\t\t\t\t\t\tsize = vector1.size();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"<\" + getClass().getName() + \"> Evaluating 'list' binding returned a \" + list.getClass().getName() + \" when it should return either a com.webobjects.foundation.NSArray, or a java.lang.Vector .\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean flag = _multiple != null ? _multiple.booleanValueInComponent(wocomponent) : false;\n\t\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\t\tObject obj1 = nsarray1 == null ? vector1.get(k) : nsarray1.objectAtIndex(k);\n\t\t\t\t\t_item.setValue(obj1, wocomponent);\n\t\t\t\t\tObject obj2 = _value.valueInComponent(wocomponent);\n\t\t\t\t\tif (obj2 != null) {\n\t\t\t\t\t\tif (!nsarray.containsObject(obj2.toString())) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nsarray1 != null) {\n\t\t\t\t\t\t\tnsmutablearray.addObject(obj1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvector.add(obj1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!flag) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.debug(toString() + \" 'value' evaluated to null in component \" + wocomponent.toString() + \".\\n\" + \"Unable to select item \" + obj1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tObject newValue = (nsmutablearray != null ? nsmutablearray: vector);\n\t\t\tsetSelectedValue(newValue, wocomponent);\n\t\t}\n\t}","commit_id":"fbc299e9a2b0f5e3caf5bd8183389bc530b01ca5","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"<\");\n\t\tsb.append(getClass().getName());\n\t\tsb.append(\" scriptFile=\" + _scriptFile);\n\t\tsb.append(\" scriptString=\" + _scriptString);\n\t\tsb.append(\" scriptFramework=\" + _scriptFramework);\n\t\tsb.append(\" framework=\" + _framework);\n\t\tsb.append(\" scriptSource=\" + _scriptSource);\n\t\tsb.append(\" filename=\" + _filename);\n\t\tsb.append(\" hideInComment=\" + _hideInComment);\n\t\tsb.append(\" language=\" + _language);\n\t\tsb.append(\">\");\n\t\treturn sb.toString();\n\t}","id":38505,"modified_method":"@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"<\");\n\t\tsb.append(getClass().getName());\n\t\tsb.append(\" scriptFile=\" + _scriptFile);\n\t\tsb.append(\" scriptString=\" + _scriptString);\n\t\tsb.append(\" scriptFramework=\" + _scriptFramework);\n\t\tsb.append(\" framework=\" + _framework);\n\t\tsb.append(\" scriptSource=\" + _scriptSource);\n\t\tsb.append(\" filename=\" + _filename);\n\t\tsb.append(\" hideInComment=\" + _hideInComment);\n\t\tsb.append(\" language=\" + _language);\n\t\tsb.append(\">\");\n\t\treturn sb.toString();\n\t}","commit_id":"2c6eec2ca652520c32172c7a4a355af2fef79ec7","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void appendChildrenToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\t\tString script = \"\";\n\t\t\tboolean hideInComment = true;\n\t\t\tWOComponent wocomponent = wocontext.component();\n\t\t\tif(_hideInComment != null) {\n\t\t\t\thideInComment = _hideInComment.booleanValueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"<!--\");\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(_scriptFile != null) {\n\t\t\t\tString filename = (String) _scriptFile.valueInComponent(wocomponent);\n\t\t\t\tif(filename != null) {\n\t\t\t\t\tString framework = null;\n\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\tjava.net.URL url = WOApplication.application().resourceManager().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\turl = wocontext.component()._componentDefinition().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\t}\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : cannot find script file '\" + filename + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tscript = _NSStringUtilities.stringFromPathURL(url);\n\t\t\t\t\tif (ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\tscript = ERXResourceManager._completeURLForResource(script, null, wocontext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else if(_scriptString != null) {\n\t\t\t\tObject obj1 = _scriptString.valueInComponent(wocomponent);\n\t\t\t\tif(obj1 != null) {\n\t\t\t\t\tscript = obj1.toString();\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else {\n\t\t\t\tsuper.appendChildrenToResponse(woresponse, wocontext);\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"//-->\");\n\t\t\t}\n\t}","id":38506,"modified_method":"@Override\n\tpublic void appendChildrenToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\t\tString script = \"\";\n\t\t\tboolean hideInComment = ERXProperties.booleanForKeyWithDefault(\"er.extensions.ERXJavaScript.hideInComment\", true);\n\t\t\tWOComponent wocomponent = wocontext.component();\n\t\t\tif(_hideInComment != null) {\n\t\t\t\thideInComment = _hideInComment.booleanValueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"<!--\");\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(_scriptFile != null) {\n\t\t\t\tString filename = (String) _scriptFile.valueInComponent(wocomponent);\n\t\t\t\tif(filename != null) {\n\t\t\t\t\tString framework = null;\n\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\tjava.net.URL url = WOApplication.application().resourceManager().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\turl = wocontext.component()._componentDefinition().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\t}\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : cannot find script file '\" + filename + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tscript = _NSStringUtilities.stringFromPathURL(url);\n\t\t\t\t\tif (ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\tscript = ERXResourceManager._completeURLForResource(script, null, wocontext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else if(_scriptString != null) {\n\t\t\t\tObject obj1 = _scriptString.valueInComponent(wocomponent);\n\t\t\t\tif(obj1 != null) {\n\t\t\t\t\tscript = obj1.toString();\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else {\n\t\t\t\tsuper.appendChildrenToResponse(woresponse, wocontext);\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"//-->\");\n\t\t\t}\n\t}","commit_id":"2c6eec2ca652520c32172c7a4a355af2fef79ec7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXJavaScript(String s, NSDictionary nsdictionary, WOElement woelement) {\n\t\tsuper(\"script\", nsdictionary, woelement);\n\t\t_scriptFile = (WOAssociation)_associations.removeObjectForKey(\"scriptFile\");\n\t\t_scriptString = (WOAssociation)_associations.removeObjectForKey(\"scriptString\");\n\t\t_scriptSource = (WOAssociation)_associations.removeObjectForKey(\"scriptSource\");\n\t\t_filename = (WOAssociation)_associations.removeObjectForKey(\"filename\");\n\t\t_language = (WOAssociation)_associations.removeObjectForKey(\"language\");\n\t\t_scriptKey = (WOAssociation)_associations.removeObjectForKey(\"scriptKey\");\n\t\t_hideInComment = (WOAssociation)_associations.removeObjectForKey(\"hideInComment\");\n\t\t_scriptFramework = (WOAssociation) _associations.removeObjectForKey(\"scriptFramework\");\n\t\t_framework = (WOAssociation) _associations.removeObjectForKey(\"framework\");\n\t\tif((_scriptFile != null && _scriptString != null) \n\t\t\t\t|| (_scriptFile != null && (_scriptSource != null || _filename != null)) \n\t\t\t\t|| (_scriptString != null && (_scriptSource != null || _filename != null))) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'scriptString' or 'scriptSource/filename' attributes can be specified.\");\n\t\t}\n\t\tif (_scriptFramework != null && _framework != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFramework' or 'framework' can be specified.\");\n\t\t}\n\t\tif (_scriptSource != null && _filename != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'filename' can be specified.\");\n\t\t}\n\t}","id":38507,"modified_method":"public ERXJavaScript(String s, NSDictionary<String, WOAssociation> nsdictionary, WOElement woelement) {\n\t\tsuper(\"script\", nsdictionary, woelement);\n\t\t_scriptFile = _associations.removeObjectForKey(\"scriptFile\");\n\t\t_scriptString = _associations.removeObjectForKey(\"scriptString\");\n\t\t_scriptSource = _associations.removeObjectForKey(\"scriptSource\");\n\t\t_filename = _associations.removeObjectForKey(\"filename\");\n\t\t_language = _associations.removeObjectForKey(\"language\");\n\t\t_scriptKey = _associations.removeObjectForKey(\"scriptKey\");\n\t\t_hideInComment = _associations.removeObjectForKey(\"hideInComment\");\n\t\t_scriptFramework = _associations.removeObjectForKey(\"scriptFramework\");\n\t\t_framework = _associations.removeObjectForKey(\"framework\");\n\t\tif((_scriptFile != null && _scriptString != null) \n\t\t\t\t|| (_scriptFile != null && (_scriptSource != null || _filename != null)) \n\t\t\t\t|| (_scriptString != null && (_scriptSource != null || _filename != null))) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'scriptString' or 'scriptSource/filename' attributes can be specified.\");\n\t\t}\n\t\tif (_scriptFramework != null && _framework != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFramework' or 'framework' can be specified.\");\n\t\t}\n\t\tif (_scriptSource != null && _filename != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'filename' can be specified.\");\n\t\t}\n\t}","commit_id":"2c6eec2ca652520c32172c7a4a355af2fef79ec7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXOptGroupPopupButton(String name, NSDictionary associations, WOElement template)\n    {\n        super(name, associations, template);\n        group = (WOAssociation)_associations.removeObjectForKey(\"group\");\n        label = (WOAssociation)_associations.removeObjectForKey(\"label\");\n        \n        if (group == null)\n        {\n            throw new RuntimeException(\"Group is a required binding\");\n        }\n    }","id":38508,"modified_method":"public ERXOptGroupPopupButton(String name, NSDictionary associations, WOElement template)\n    {\n        super(name, associations, template);\n        group = _associations.removeObjectForKey(\"group\");\n        label = _associations.removeObjectForKey(\"label\");\n\n        if (group == null)\n        {\n            throw new RuntimeException(\"Group is a required binding\");\n        }\n    }","commit_id":"242db23344f7e64ffbb68de1736dcd5b4c41966f","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendChildrenToResponse(WOResponse response, WOContext context)\n    {\n         WOComponent parent = context.component();\n         \n         if (_noSelectionString != null)\n         {\n             Object noSelectionString = _noSelectionString.valueInComponent(parent);\n             if (noSelectionString != null)\n             {\n                 response.appendContentString(\"\\n<option value=\\\"WONoSelectionString\\\">\");\n                 response.appendContentHTMLString(noSelectionString.toString());\n                 response._appendContentAsciiString(\"<\/option>\");\n             } \n         }\n\n         \n        Object selectionValue = null;\n        Object selectedValue = null;\n        if (_selection != null)\n        {\n            selectionValue = _selection.valueInComponent(parent);\n        }\n        else if (_selectedValue != null)\n        {\n            selectedValue = _selectedValue.valueInComponent(parent);\n        }\n        \n        NSArray list = (NSArray) _list.valueInComponent(parent);\n        \n        Object previousGroup = null;\n        boolean didOpenOptionGroup = false;\n        boolean shouldEscapeHTML = _escapeHTML != null ? _escapeHTML.booleanValueInComponent(parent) : true;\n        \n        for(int i = 0; i < list.count(); i++)\n        {\n             Object listItem = list.objectAtIndex(i);\n             _item.setValue(listItem, parent);\n             \n             Object currentGroup = group.valueInComponent(parent);\n             if ( ! currentGroup.equals(previousGroup))\n             {\n                 previousGroup = currentGroup;\n\n                 if (didOpenOptionGroup)\n                 {\n                     response._appendContentAsciiString(\"\\n<\/optgroup>\");\n                 }\n                 \n                 response._appendContentAsciiString(\"\\n<optgroup label=\\\"\");\n                 if (label != null)\n                 {\n                     if (shouldEscapeHTML)\n                     {\n                         response.appendContentHTMLString(label.valueInComponent(parent).toString());\n                     }\n                     else\n                     {\n                         response.appendContentString(label.valueInComponent(parent).toString());\n                     }\n                 }\n\n                response._appendContentAsciiString(\"\\\">\");\n                didOpenOptionGroup = true;\n             }\n \n             response._appendContentAsciiString(\"\\n<option\");\n             \n             String valueAsString = null;\n             String displayStringAsString = null;\n             WOAssociation displayStringAssociation = null;\n             if(ERXKeyValueCodingUtilities.fieldForKey(this, \"_string\") != null) {\n            \t displayStringAssociation = (WOAssociation) ERXKeyValueCodingUtilities.privateValueForKey(this, \"_string\");\n             } else {\n            \t displayStringAssociation = (WOAssociation) ERXKeyValueCodingUtilities.privateValueForKey(this, \"_disabled\");\n             }\n\n             if (displayStringAssociation != null || _value != null) {\n\n\t\t\t\tif (displayStringAssociation != null) {\n                    Object displayString = displayStringAssociation.valueInComponent(parent);\n                    if (displayString != null)\n                    {\n                        displayStringAsString = displayString.toString();\n                        if (_value != null)\n                        {\n                            Object value = _value.valueInComponent(parent);\n                            if (value != null)\n                            {\n                                valueAsString = value.toString();\n                            }\n                        } \n                        else\n                        {\n                            valueAsString = displayStringAsString;\n                        }\n                   }\n                } \n                else\n                {\n                    Object value = _value.valueInComponent(parent);\n                    if (value != null)\n                    {\n                        valueAsString = value.toString();\n                        displayStringAsString = valueAsString;\n                    }\n               }\n           } \n           else\n           {\n               displayStringAsString = listItem.toString();\n               valueAsString = displayStringAsString;\n           }\n            \n            boolean isSelectedItem = false;\n            if (_selection != null)\n            {\n                isSelectedItem = selectionValue == null ? false : selectionValue.equals(listItem);\n            }\n            else if (_selectedValue != null)\n            {\n                if (_value != null)\n                {\n                    isSelectedItem = selectedValue == null ? false : selectedValue.equals(valueAsString);\n                }\n            }\n             \n            if (isSelectedItem)\n            {\n                response.appendContentCharacter(' ');\n                 response._appendContentAsciiString(\"selected\");\n            }\n             \n            if (_value != null)\n            {\n                response._appendTagAttributeAndValue(\"value\", valueAsString, true);\n            }\n            else\n            {\n                String indexAsValue = WOShared.unsignedIntString(i);\n                response._appendTagAttributeAndValue(\"value\", indexAsValue, false);\n            }\n             \n            response.appendContentCharacter('>');\n             \n            if (shouldEscapeHTML)\n            {\n                response.appendContentHTMLString(displayStringAsString);\n            }\n            else\n            {\n                response.appendContentString(displayStringAsString);\n            }\n              \n            response._appendContentAsciiString(\"<\/option>\");\n         }\n         \n         if (didOpenOptionGroup)\n         {\n             response._appendContentAsciiString(\"\\n<\/optgroup>\");\n         }\n    }","id":38509,"modified_method":"public void appendChildrenToResponse(WOResponse response, WOContext context)\n    {\n         WOComponent parent = context.component();\n\n         if (_noSelectionString != null)\n         {\n             Object noSelectionString = _noSelectionString.valueInComponent(parent);\n             if (noSelectionString != null)\n             {\n                 response.appendContentString(\"\\n<option value=\\\"WONoSelectionString\\\">\");\n                 response.appendContentHTMLString(noSelectionString.toString());\n                 response._appendContentAsciiString(\"<\/option>\");\n             }\n         }\n\n\n        Object selectionValue = null;\n        Object selectedValue = null;\n        if (_selection != null)\n        {\n            selectionValue = _selection.valueInComponent(parent);\n        }\n        else if (_selectedValue != null)\n        {\n            selectedValue = _selectedValue.valueInComponent(parent);\n        }\n\n        NSArray list = (NSArray) _list.valueInComponent(parent);\n\n        Object previousGroup = null;\n        boolean didOpenOptionGroup = false;\n        boolean shouldEscapeHTML = _escapeHTML != null ? _escapeHTML.booleanValueInComponent(parent) : true;\n\n        for(int i = 0; i < list.count(); i++)\n        {\n             Object listItem = list.objectAtIndex(i);\n             _item.setValue(listItem, parent);\n\n             Object currentGroup = group.valueInComponent(parent);\n             if ( ! currentGroup.equals(previousGroup))\n             {\n                 previousGroup = currentGroup;\n\n                 if (didOpenOptionGroup)\n                 {\n                     response._appendContentAsciiString(\"\\n<\/optgroup>\");\n                 }\n\n                 response._appendContentAsciiString(\"\\n<optgroup label=\\\"\");\n                 if (label != null)\n                 {\n                     if (shouldEscapeHTML)\n                     {\n                         response.appendContentHTMLString(label.valueInComponent(parent).toString());\n                     }\n                     else\n                     {\n                         response.appendContentString(label.valueInComponent(parent).toString());\n                     }\n                 }\n\n                response._appendContentAsciiString(\"\\\">\");\n                didOpenOptionGroup = true;\n             }\n\n             response._appendContentAsciiString(\"\\n<option\");\n\n             String valueAsString = null;\n             String displayStringAsString = null;\n             WOAssociation displayStringAssociation = null;\n             if(ERXKeyValueCodingUtilities.fieldForKey(this, \"_string\") != null) {\n            \t displayStringAssociation = (WOAssociation) ERXKeyValueCodingUtilities.privateValueForKey(this, \"_string\");\n             } else {\n            \t displayStringAssociation = (WOAssociation) ERXKeyValueCodingUtilities.privateValueForKey(this, \"_displayString\");\n             }\n\n             if (displayStringAssociation != null || _value != null) {\n\n\t\t\t\tif (displayStringAssociation != null) {\n                    Object displayString = displayStringAssociation.valueInComponent(parent);\n                    if (displayString != null)\n                    {\n                        displayStringAsString = displayString.toString();\n                        if (_value != null)\n                        {\n                            Object value = _value.valueInComponent(parent);\n                            if (value != null)\n                            {\n                                valueAsString = value.toString();\n                            }\n                        }\n                        else\n                        {\n                            valueAsString = displayStringAsString;\n                        }\n                   }\n                }\n                else\n                {\n                    Object value = _value.valueInComponent(parent);\n                    if (value != null)\n                    {\n                        valueAsString = value.toString();\n                        displayStringAsString = valueAsString;\n                    }\n               }\n           }\n           else\n           {\n               displayStringAsString = listItem.toString();\n               valueAsString = displayStringAsString;\n           }\n\n            boolean isSelectedItem = false;\n            if (_selection != null)\n            {\n                isSelectedItem = selectionValue == null ? false : selectionValue.equals(listItem);\n            }\n            else if (_selectedValue != null)\n            {\n                if (_value != null)\n                {\n                    isSelectedItem = selectedValue == null ? false : selectedValue.equals(valueAsString);\n                }\n            }\n\n            if (isSelectedItem)\n            {\n                response.appendContentCharacter(' ');\n                 response._appendContentAsciiString(\"selected\");\n            }\n\n            if (_value != null)\n            {\n                response._appendTagAttributeAndValue(\"value\", valueAsString, true);\n            }\n            else\n            {\n                String indexAsValue = WOShared.unsignedIntString(i);\n                response._appendTagAttributeAndValue(\"value\", indexAsValue, false);\n            }\n\n            response.appendContentCharacter('>');\n\n            if (shouldEscapeHTML)\n            {\n                response.appendContentHTMLString(displayStringAsString);\n            }\n            else\n            {\n                response.appendContentString(displayStringAsString);\n            }\n\n            response._appendContentAsciiString(\"<\/option>\");\n         }\n\n         if (didOpenOptionGroup)\n         {\n             response._appendContentAsciiString(\"\\n<\/optgroup>\");\n         }\n    }","commit_id":"242db23344f7e64ffbb68de1736dcd5b4c41966f","url":"https://github.com/wocommunity/wonder"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tpublic ERXWOForm(String name, NSDictionary associations, WOElement element) {\n\t\tsuper(\"form\", associations, element);\n\t\t_otherQueryAssociations = _NSDictionaryUtilities.extractObjectsForKeysWithPrefix(_associations, \"?\", true);\n\t\tif (_otherQueryAssociations.count() == 0) {\n\t\t\t_otherQueryAssociations = null;\n\t\t}\n\t\t_action = (WOAssociation) _associations.removeObjectForKey(\"action\");\n\t\t_href = (WOAssociation) _associations.removeObjectForKey(\"href\");\n\t\t_multipleSubmit = (WOAssociation) _associations.removeObjectForKey(\"multipleSubmit\");\n\t\tif (_multipleSubmit == null && ERXWOForm.multipleSubmitDefault) {\n\t\t\t_multipleSubmit = new WOConstantValueAssociation(Boolean.valueOf(multipleSubmitDefault));\n\t\t}\n\t\t_actionClass = (WOAssociation) _associations.removeObjectForKey(\"actionClass\");\n\t\t_queryDictionary = (WOAssociation) _associations.removeObjectForKey(\"queryDictionary\");\n\t\t_directActionName = (WOAssociation) _associations.removeObjectForKey(\"directActionName\");\n\t\t_formName = (WOAssociation) _associations.removeObjectForKey(\"name\");\n\t\tif (ERXWOForm.useIdInsteadOfNameTag && _id != null) {\n\t\t\t_formName = _id;\t// id takes precedence over name - then subsequently written as id\n\t\t\t_id = null;\n\t\t}\n\t\t_enctype = (WOAssociation) _associations.removeObjectForKey(\"enctype\");\n\t\t_fragmentIdentifier = (WOAssociation) _associations.removeObjectForKey(\"fragmentIdentifier\");\n\t\t_secure = (WOAssociation) _associations.removeObjectForKey(\"secure\");\n\t\t_disabled = (WOAssociation) _associations.removeObjectForKey(\"disabled\");\n\t\t_addDefaultSubmitButton = (WOAssociation) _associations.removeObjectForKey(\"addDefaultSubmitButton\");\n\t\t_embedded = (WOAssociation) _associations.removeObjectForKey(\"embedded\");\n\t\tif (_associations.objectForKey(\"method\") == null && _associations.objectForKey(\"Method\") == null && _associations.objectForKey(\"METHOD\") == null) {\n\t\t\t_associations.setObjectForKey(new WOConstantValueAssociation(\"post\"), \"method\");\n\t\t}\n\t\tif (_action != null && _href != null || _action != null && _directActionName != null || _href != null && _directActionName != null || _action != null && _actionClass != null || _href != null && _actionClass != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \">: At least two of these conflicting attributes are present: 'action', 'href', 'directActionName', 'actionClass'\");\n\t\t}\n\t\tif (_action != null && _action.isValueConstant()) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \">: 'action' is a constant.\");\n\t\t}\n\t}","id":38510,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tpublic ERXWOForm(String name, NSDictionary<String, WOAssociation> associations, WOElement element) {\n\t\tsuper(\"form\", associations, element);\n\t\t_otherQueryAssociations = _NSDictionaryUtilities.extractObjectsForKeysWithPrefix(_associations, \"?\", true);\n\t\tif (_otherQueryAssociations.count() == 0) {\n\t\t\t_otherQueryAssociations = null;\n\t\t}\n\t\t_action = _associations.removeObjectForKey(\"action\");\n\t\t_href = _associations.removeObjectForKey(\"href\");\n\t\t_multipleSubmit = _associations.removeObjectForKey(\"multipleSubmit\");\n\t\tif (_multipleSubmit == null && ERXWOForm.multipleSubmitDefault) {\n\t\t\t_multipleSubmit = new WOConstantValueAssociation(Boolean.valueOf(multipleSubmitDefault));\n\t\t}\n\t\t_actionClass = _associations.removeObjectForKey(\"actionClass\");\n\t\t_queryDictionary = _associations.removeObjectForKey(\"queryDictionary\");\n\t\t_directActionName = _associations.removeObjectForKey(\"directActionName\");\n\t\t_formName = _associations.removeObjectForKey(\"name\");\n\t\tif (ERXWOForm.useIdInsteadOfNameTag && _id != null) {\n\t\t\t_formName = _id;\t// id takes precedence over name - then subsequently written as id\n\t\t\t_id = null;\n\t\t}\n\t\t_enctype = _associations.removeObjectForKey(\"enctype\");\n\t\t_fragmentIdentifier = _associations.removeObjectForKey(\"fragmentIdentifier\");\n\t\t_secure = _associations.removeObjectForKey(\"secure\");\n\t\t_disabled = _associations.removeObjectForKey(\"disabled\");\n\t\t_addDefaultSubmitButton = _associations.removeObjectForKey(\"addDefaultSubmitButton\");\n\t\t_embedded = _associations.removeObjectForKey(\"embedded\");\n\t\tif (_associations.objectForKey(\"method\") == null && _associations.objectForKey(\"Method\") == null && _associations.objectForKey(\"METHOD\") == null) {\n\t\t\t_associations.setObjectForKey(new WOConstantValueAssociation(\"post\"), \"method\");\n\t\t}\n\t\tif (_action != null && _href != null || _action != null && _directActionName != null || _href != null && _directActionName != null || _action != null && _actionClass != null || _href != null && _actionClass != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \">: At least two of these conflicting attributes are present: 'action', 'href', 'directActionName', 'actionClass'\");\n\t\t}\n\t\tif (_action != null && _action.isValueConstant()) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \">: 'action' is a constant.\");\n\t\t}\n\t}","commit_id":"ca1aa427fe937b720d0716bcd4411eacc912fc7b","url":"https://github.com/wocommunity/wonder"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tpublic ERXLinkButton(String aName, NSDictionary<String, WOAssociation> associations, WOElement template) {\n\t\tsuper(\"a\", associations, template);\n\t\t\n\t\t_otherQueryAssociations = _NSDictionaryUtilities.extractObjectsForKeysWithPrefix(_associations, \"?\", true);\n\t\t_otherQueryAssociations = _otherQueryAssociations == null || _otherQueryAssociations.count() <= 0 ? null : _otherQueryAssociations;\n\t\t\n\t\t_action = (WOAssociation)_associations.removeObjectForKey(\"action\");\n\t\t_actionClass = (WOAssociation)_associations.removeObjectForKey(\"actionClass\");\n\t\t_directActionName = (WOAssociation)_associations.removeObjectForKey(\"directActionName\");\n\t\t_disabled = (WOAssociation)_associations.removeObjectForKey(\"disabled\");\n\t\t_escapeHTML = (WOAssociation)_associations.removeObjectForKey(\"escapeHTML\");\n\t\t_fragmentIdentifier = (WOAssociation)_associations.removeObjectForKey(\"fragmentIdentifier\");\n\t\t_href = (WOAssociation)_associations.removeObjectForKey(\"href\");\n\t\t_name = (WOAssociation)_associations.removeObjectForKey(\"name\");\n\t\t_pageName = (WOAssociation)_associations.removeObjectForKey(\"pageName\");\n\t\t_queryDictionary = (WOAssociation)_associations.removeObjectForKey(\"queryDictionary\");\n\t\t_rel = (WOAssociation)_associations.removeObjectForKey(\"rel\");\n\t\t_string = (WOAssociation)_associations.removeObjectForKey(\"string\");\n\t\t_submit = (WOAssociation)_associations.removeObjectForKey(\"submit\");\n\t\t_useIEConditionals = (WOAssociation)_associations.removeObjectForKey(\"useIEConditionals\");\n\t\t_value = (WOAssociation)_associations.removeObjectForKey(\"value\");\n\t\t\n\t\tif(_action == null && _href == null && _pageName == null && _directActionName == null && _actionClass == null) {\n\t\t\tthrow new WODynamicElementCreationException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> Missing required attribute: 'action' or 'href' or 'pageName' or 'directActionName' or 'actionClass'\").toString());\n\t\t}\n\t\tif(_action != null && _href != null || _action != null && _pageName != null || _href != null && _pageName != null || _action != null && _directActionName != null || _href != null && _directActionName != null || _pageName != null && _directActionName != null || _action != null && _actionClass != null) {\n\t\t\tthrow new WODynamicElementCreationException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> At least two of these conflicting attributes are present: 'action', 'href', 'pageName', 'directActionName', 'actionClass'.\").toString());\n\t\t}\n\t\tif(_action != null && _action.isValueConstant()) {\n\t\t\tthrow new WODynamicElementCreationException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> 'action' is a constant.\").toString());\n\t\t} else {\n\t\t\treturn;\n\t\t}\t\n\t}","id":38511,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tpublic ERXLinkButton(String aName, NSDictionary<String, WOAssociation> associations, WOElement template) {\n\t\tsuper(\"a\", associations, template);\n\t\t\n\t\t_otherQueryAssociations = _NSDictionaryUtilities.extractObjectsForKeysWithPrefix(_associations, \"?\", true);\n\t\t_otherQueryAssociations = _otherQueryAssociations == null || _otherQueryAssociations.count() <= 0 ? null : _otherQueryAssociations;\n\t\t\n\t\t_action = _associations.removeObjectForKey(\"action\");\n\t\t_actionClass = _associations.removeObjectForKey(\"actionClass\");\n\t\t_directActionName = _associations.removeObjectForKey(\"directActionName\");\n\t\t_disabled = _associations.removeObjectForKey(\"disabled\");\n\t\t_escapeHTML = _associations.removeObjectForKey(\"escapeHTML\");\n\t\t_fragmentIdentifier = _associations.removeObjectForKey(\"fragmentIdentifier\");\n\t\t_href = _associations.removeObjectForKey(\"href\");\n\t\t_name = _associations.removeObjectForKey(\"name\");\n\t\t_pageName = _associations.removeObjectForKey(\"pageName\");\n\t\t_queryDictionary = _associations.removeObjectForKey(\"queryDictionary\");\n\t\t_rel = _associations.removeObjectForKey(\"rel\");\n\t\t_string = _associations.removeObjectForKey(\"string\");\n\t\t_submit = _associations.removeObjectForKey(\"submit\");\n\t\t_useIEConditionals = _associations.removeObjectForKey(\"useIEConditionals\");\n\t\t_value = _associations.removeObjectForKey(\"value\");\n\t\t\n\t\tif(_action == null && _href == null && _pageName == null && _directActionName == null && _actionClass == null) {\n\t\t\tthrow new WODynamicElementCreationException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> Missing required attribute: 'action' or 'href' or 'pageName' or 'directActionName' or 'actionClass'\").toString());\n\t\t}\n\t\tif(_action != null && _href != null || _action != null && _pageName != null || _href != null && _pageName != null || _action != null && _directActionName != null || _href != null && _directActionName != null || _pageName != null && _directActionName != null || _action != null && _actionClass != null) {\n\t\t\tthrow new WODynamicElementCreationException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> At least two of these conflicting attributes are present: 'action', 'href', 'pageName', 'directActionName', 'actionClass'.\").toString());\n\t\t}\n\t\tif(_action != null && _action.isValueConstant()) {\n\t\t\tthrow new WODynamicElementCreationException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> 'action' is a constant.\").toString());\n\t\t}\t\n\t}","commit_id":"11736458925abf7fe64afd0e4d4555f3d923b3a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns the child string for the button supplied by the string or value attribute.\n\t * If submit is true, then the value binding is preferred. Otherwise, the string \n\t * binding is preferred.\n\t * @param context the current context\n\t * @return the child string value\n\t */\n\tprotected String childStringInContext(WOContext context) {\n\t\tObject value = null;\n\t\tWOComponent component = context.component();\n\t\tObject stringVal = _string == null?null:_string.valueInComponent(component);\n\t\tObject valueVal = valueInContext(context);\n\t\tif(submitInContext(context)) {\n\t\t\tvalue = valueVal == null?stringVal == null?\"Submit\":stringVal:valueVal;\n\t\t} else {\n\t\t\tvalue = stringVal == null?valueVal == null?\"Link\":valueVal:stringVal;\n\t\t}\n\t\treturn value.toString();\n\t}","id":38512,"modified_method":"/**\n\t * Returns the child string for the button supplied by the string or value attribute.\n\t * If submit is true, then the value binding is preferred. Otherwise, the string \n\t * binding is preferred.\n\t * @param context the current context\n\t * @return the child string value\n\t */\n\tprotected String childStringInContext(WOContext context) {\n\t\tObject value = null;\n\t\tWOComponent component = context.component();\n\t\tObject stringVal = _string == null?null:_string.valueInComponent(component);\n\t\tObject valueVal = valueInContext(context);\n\t\tif(submitInContext(context)) {\n\t\t\tvalue = valueVal == null?stringVal == null?\"Submit\":stringVal:valueVal;\n\t\t} else {\n\t\t\tvalue = stringVal == null?valueVal == null?\"\":valueVal:stringVal;\n\t\t}\n\t\treturn value.toString();\n\t}","commit_id":"11736458925abf7fe64afd0e4d4555f3d923b3a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String nameInContext(WOContext context) {\n\t\tif(_actionClass != null || _directActionName != null) {\n\t\t\treturn _actionClassAndName(context);\n\t\t}\n\t\tif(_name != null) {\n\t\t\tObject value = _name.valueInComponent(context.component());\n\t\t\tif(value != null) {\n\t\t\t\treturn value.toString();\n\t\t\t}\n\t\t}\n\t\tObject elementID = context.elementID();\n\t\tif(elementID != null) {\n\t\t\treturn elementID.toString();\n\t\t} else {\n\t\t\tthrow new IllegalStateException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> Cannot evaluate 'name' attribute, and context element ID is null.\").toString());\n\t\t}\n\t}","id":38513,"modified_method":"public String nameInContext(WOContext context) {\n\t\tif(_actionClass != null || _directActionName != null) {\n\t\t\treturn _actionClassAndName(context);\n\t\t}\n\t\tif(_name != null) {\n\t\t\tObject value = _name.valueInComponent(context.component());\n\t\t\tif(value != null) {\n\t\t\t\treturn value.toString();\n\t\t\t}\n\t\t}\n\t\tObject elementID = context.elementID();\n\t\tif(elementID != null) {\n\t\t\treturn elementID.toString();\n\t\t}\n\t\tthrow new IllegalStateException((new StringBuilder()).append(\"<\").append(getClass().getName()).append(\"> Cannot evaluate 'name' attribute, and context element ID is null.\").toString());\n\t}","commit_id":"11736458925abf7fe64afd0e4d4555f3d923b3a6","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void getchdb(List<String> image, IngestImageWorkerController controller){\n         \n        try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n            Map<String, Object> kvs = new LinkedHashMap<String, Object>(); \n            String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'History' AND parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            ChromeCount = FFSqlitedb.size();\n              \n            rs.close();\n            rs.getStatement().close();\n            int j = 0;\n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                 ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chquery);\n                  \n                   while(temprs.next()) \n                   {\n                       String domain = Util.extractDomain(temprs.getString(\"url\"));\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"\",temprs.getString(\"url\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Accessed\",temprs.getString(\"last_visit_time\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(),\"RecentActivity\",\"\",temprs.getString(\"from_visit\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                      bbart.addAttributes(bbattributes);\n                     \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n             \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n\t\t \n                j++;\n               dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        //COOKIES section\n          // This gets the cookie info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%Cookies%' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n             \n            rs.close();\n            rs.getStatement().close(); \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chcookiequery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_COOKIE);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      String domain = temprs.getString(\"host_key\");\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"\", temprs.getString(\"host_key\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(),\"RecentActivity\", \"Last Visited\",temprs.getString(\"last_access_utc\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(),\"RecentActivity\", \"\",temprs.getString(\"value\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"Title\",((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                     bbart.addAttributes(bbattributes);\n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        //BOokmarks section\n          // This gets the bm info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'Bookmarks' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n              \n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                try\n                {\n                    \n                    final JsonParser parser = new JsonParser();\n                     JsonElement jsonElement = parser.parse(new FileReader(temps));\n                    JsonObject test = jsonElement.getAsJsonObject();\n                    JsonObject whatever = test.get(\"roots\").getAsJsonObject();\n                    JsonObject whatever2 = whatever.get(\"bookmark_bar\").getAsJsonObject();\n                    JsonArray whatever3 = whatever2.getAsJsonArray(\"children\");\n                    \n //                    JsonArray results = parser.parse(new FileReader(temps)).getAsJsonObject().getAsJsonArray(\"roots\").getAsJsonObject().getAsJsonArray(\"bookmark_bar\").get(0).getAsJsonObject().getAsJsonArray(\"children\");\n                     for (JsonElement result : whatever3) {\n                                            \n                                            JsonObject address = result.getAsJsonObject();\n                                            String url = address.get(\"url\").getAsString();\n                                            String name = address.get(\"name\").getAsString();\n                                            String date = address.get(\"date_added\").getAsString();                   \n                                            String domain = Util.extractDomain(url);\n                    BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_BOOKMARK); \n                     Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",date));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",url));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\",name));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                     bbart.addAttributes(bbattributes);     \n                    } \n\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into the Bookmarks for Chrome.\" + ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK));\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n         \n          //Downloads section\n          // This gets the downloads info\n         try \n         {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'History' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chdownloadquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_DOWNLOAD); \n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      String domain = Util.extractDomain(temprs.getString(\"url\"));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",temprs.getString(\"start_time\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"\")));\n                     //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\").replaceAll(\"'\", \"''\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), \"Recent Activity\", \"\", temprs.getString(\"full_path\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD)); \n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n         \n          //Login/Password section\n          // This gets the user info\n         try \n         {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'signons.sqlite' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chloginquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY); \n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",temprs.getString(\"start_time\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",((temprs.getString(\"origin_url\") != null) ? temprs.getString(\"origin_url\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USERNAME.getTypeID(), \"RecentActivity\",\"\", ((temprs.getString(\"username_value\") != null) ? temprs.getString(\"username_value\").replaceAll(\"'\", \"''\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(), \"Recent Activity\", \"\", temprs.getString(\"signon_realm\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",Util.extractDomain(((temprs.getString(\"origin_url\") != null) ? temprs.getString(\"origin_url\") : \"\"))));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n         \n    }","id":38514,"modified_method":"public void getchdb(List<String> image, IngestImageWorkerController controller){\n         \n        try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n            Map<String, Object> kvs = new LinkedHashMap<String, Object>(); \n            String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'History' AND parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            ChromeCount = FFSqlitedb.size();\n              \n            rs.close();\n            rs.getStatement().close();\n            int j = 0;\n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                 ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chquery);\n                  \n                   while(temprs.next()) \n                   {\n                       String domain = Util.extractDomain(temprs.getString(\"url\"));\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"\",temprs.getString(\"url\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Accessed\",temprs.getLong(\"last_visit_time\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(),\"RecentActivity\",\"\",temprs.getString(\"from_visit\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                      bbart.addAttributes(bbattributes);\n                     \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n             \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n\t\t \n                j++;\n               dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        //COOKIES section\n          // This gets the cookie info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%Cookies%' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n             \n            rs.close();\n            rs.getStatement().close(); \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chcookiequery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_COOKIE);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      String domain = temprs.getString(\"host_key\");\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"\", temprs.getString(\"host_key\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(),\"RecentActivity\", \"Last Visited\",temprs.getLong(\"last_access_utc\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(),\"RecentActivity\", \"\",temprs.getString(\"value\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"Title\",((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                     bbart.addAttributes(bbattributes);\n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        //BOokmarks section\n          // This gets the bm info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'Bookmarks' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n              \n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                try\n                {\n                    \n                    final JsonParser parser = new JsonParser();\n                     JsonElement jsonElement = parser.parse(new FileReader(temps));\n                    JsonObject test = jsonElement.getAsJsonObject();\n                    JsonObject whatever = test.get(\"roots\").getAsJsonObject();\n                    JsonObject whatever2 = whatever.get(\"bookmark_bar\").getAsJsonObject();\n                    JsonArray whatever3 = whatever2.getAsJsonArray(\"children\");\n                    \n //                    JsonArray results = parser.parse(new FileReader(temps)).getAsJsonObject().getAsJsonArray(\"roots\").getAsJsonObject().getAsJsonArray(\"bookmark_bar\").get(0).getAsJsonObject().getAsJsonArray(\"children\");\n                     for (JsonElement result : whatever3) {\n                                            \n                                            JsonObject address = result.getAsJsonObject();\n                                            String url = address.get(\"url\").getAsString();\n                                            String name = address.get(\"name\").getAsString();\n                                            Long date = address.get(\"date_added\").getAsLong();                   \n                                            String domain = Util.extractDomain(url);\n                    BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_BOOKMARK); \n                     Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",date));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",url));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\",name));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                     bbart.addAttributes(bbattributes);     \n                    } \n\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into the Bookmarks for Chrome.\" + ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK));\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n         \n          //Downloads section\n          // This gets the downloads info\n         try \n         {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            List<FsContent> FFSqlitedb;  \n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'History' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chdownloadquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_DOWNLOAD); \n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      String domain = Util.extractDomain(temprs.getString(\"url\"));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",temprs.getLong(\"start_time\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"\")));\n                     //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\").replaceAll(\"'\", \"''\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), \"Recent Activity\", \"\", temprs.getString(\"full_path\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD)); \n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n         \n          //Login/Password section\n          // This gets the user info\n         try \n         {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'signons.sqlite' and parent_path LIKE '%Chrome%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(chloginquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY); \n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",temprs.getString(\"start_time\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",((temprs.getString(\"origin_url\") != null) ? temprs.getString(\"origin_url\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USERNAME.getTypeID(), \"RecentActivity\",\"\", ((temprs.getString(\"username_value\") != null) ? temprs.getString(\"username_value\").replaceAll(\"'\", \"''\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(), \"Recent Activity\", \"\", temprs.getString(\"signon_realm\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",Util.extractDomain(((temprs.getString(\"origin_url\") != null) ? temprs.getString(\"origin_url\") : \"\"))));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Chrome\"));\n                     bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Chrome SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n         \n    }","commit_id":"cbc57ad2a76b92fbbce34bb0d626c6ef52e5a770","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void parsePascoResults() {\n        if (pascoFound == false)\n            return;\n        // First thing we want to do is check to make sure the results directory\n        // is not empty.\n        File rFile = new File(PASCO_RESULTS_PATH);\n\n\n        //Let's make sure our list and lut are empty.\n        //PASCO_RESULTS_LIST.clear();\n\n        if (rFile.exists()) {\n            //Give me a list of pasco results in that directory\n            File[] pascoFiles = rFile.listFiles();\n\n            if (pascoFiles.length > 0) {\n                try {\n                    for (File file : pascoFiles) {\n                       String fileName = file.getName();\n                       long artObjId = Long.parseLong(fileName.substring(fileName.indexOf(\".\")+1, fileName.lastIndexOf(\".\")));\n                        //bbartname = bbartname.substring(0, 4);\n\n                        // Make sure the file the is not empty or the Scanner will\n                        // throw a \"No Line found\" Exception\n                        if (file != null && file.length() > 0) {\n                            Scanner fileScanner = new Scanner(new FileInputStream(file.toString()));\n                            //Skip the first three lines\n                            fileScanner.nextLine();\n                            fileScanner.nextLine();\n                            fileScanner.nextLine();\n                          //  long inIndexId = 0;\n\n                            while (fileScanner.hasNext()) {\n                                //long bbartId = Long.parseLong(bbartname + inIndexId++);\n\n                                String line = fileScanner.nextLine();\n\n                                //Need to change this pattern a bit because there might\n                                //be instances were \"V\" might not apply.\n                                String pattern = \"(?)URL(\\\\s)(V|\\\\:)\";\n                                Pattern p = Pattern.compile(pattern);\n                                Matcher m = p.matcher(line);\n                                if (m.find()) {\n                                    try {\n                                        String[] lineBuff = line.split(\"\\\\t\");\n                                        PASCO_RESULTS_LUT = new HashMap<String, Object>();\n                                        String url[] = lineBuff[1].split(\"@\",2);\n                                        String ddtime = lineBuff[2];\n                                        String actime = lineBuff[3];\n                                        String user = \"\";\n                                        String realurl = \"\";\n                                        String domain = \"\";\n                                      if(url.length > 1)\n                                      {\n                                       user = url[0];\n                                       user = user.replace(\"Visited:\", \"\");\n                                       user = user.replace(\":Host:\", \"\");\n                                       user = user.replaceAll(\"(:)(.*?)(:)\", \"\");\n                                       user = user.trim();\n                                       realurl = url[1];\n                                       realurl = realurl.replace(\"Visited:\", \"\");\n                                       realurl = realurl.replaceAll(\":(.*?):\", \"\");\n                                       realurl = realurl.replace(\":Host:\", \"\");\n                                       realurl = realurl.trim();\n                                       domain = Util.extractDomain(realurl);\n                                      }\n                                      if(!ddtime.isEmpty()){\n                                          ddtime = ddtime.replace(\"T\",\" \");\n                                          ddtime = ddtime.substring(ddtime.length()-5);\n                                      }\n                                        if(!actime.isEmpty()){\n                                        try{\n                                        Long epochtime = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\").parse(actime).getTime();\n                                        actime = epochtime.toString();\n                                        }\n                                        catch(ParseException e){\n                                              logger.log(Level.SEVERE, \"ExtractIE::parsePascosResults() -> \", e.getMessage());\n                                        }\n                                      }\n                                       \n                                        // TODO: Need to fix this so we have the right obj_id\n                                        BlackboardArtifact bbart = tempDb.getContentById(artObjId).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"\", realurl));\n                                       \n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", \"\", actime));\n                                        \n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(), \"RecentActivity\", \"\", \"\"));\n                                   \n                                     //   bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", \"\", ddtime));\n                                       \n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Internet Explorer\"));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USERNAME.getTypeID(),\"RecentActivity\",\"\",user));\n                                        bbart.addAttributes(bbattributes);\n\n                                        //KeyValueThing\n                                        //This will be redundant in terms IE.name() because of\n                                        //the way they implemented KeyValueThing\n                                        IE_OBJ = new LinkedHashMap<String, Object>();\n                                        IE_OBJ.put(BrowserType.IE.name(), PASCO_RESULTS_LUT);\n                                        IE_PASCO_LUT.addMap(IE_OBJ);\n\n                                        PASCO_RESULTS_LIST.add(PASCO_RESULTS_LUT);\n                                    } catch (TskException ex) {\n                                        Exceptions.printStackTrace(ex);\n                                    } \n                                }\n\n                            }\n                        }\n                        //TODO: Fix Delete issue\n                        boolean bDelete = file.delete();\n                    }\n                } catch (IOException ioex) {\n                    logger.log(Level.SEVERE, \"ExtractIE::parsePascosResults() -> \", ioex.getMessage());\n                }\n\n            }\n        }\n        \n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n    }","id":38515,"modified_method":"public void parsePascoResults() {\n        if (pascoFound == false)\n            return;\n        // First thing we want to do is check to make sure the results directory\n        // is not empty.\n        File rFile = new File(PASCO_RESULTS_PATH);\n\n\n        //Let's make sure our list and lut are empty.\n        //PASCO_RESULTS_LIST.clear();\n\n        if (rFile.exists()) {\n            //Give me a list of pasco results in that directory\n            File[] pascoFiles = rFile.listFiles();\n\n            if (pascoFiles.length > 0) {\n                try {\n                    for (File file : pascoFiles) {\n                       String fileName = file.getName();\n                       long artObjId = Long.parseLong(fileName.substring(fileName.indexOf(\".\")+1, fileName.lastIndexOf(\".\")));\n                        //bbartname = bbartname.substring(0, 4);\n\n                        // Make sure the file the is not empty or the Scanner will\n                        // throw a \"No Line found\" Exception\n                        if (file != null && file.length() > 0) {\n                            Scanner fileScanner = new Scanner(new FileInputStream(file.toString()));\n                            //Skip the first three lines\n                            fileScanner.nextLine();\n                            fileScanner.nextLine();\n                            fileScanner.nextLine();\n                          //  long inIndexId = 0;\n\n                            while (fileScanner.hasNext()) {\n                                //long bbartId = Long.parseLong(bbartname + inIndexId++);\n\n                                String line = fileScanner.nextLine();\n\n                                //Need to change this pattern a bit because there might\n                                //be instances were \"V\" might not apply.\n                                String pattern = \"(?)URL(\\\\s)(V|\\\\:)\";\n                                Pattern p = Pattern.compile(pattern);\n                                Matcher m = p.matcher(line);\n                                if (m.find()) {\n                                    try {\n                                        String[] lineBuff = line.split(\"\\\\t\");\n                                        PASCO_RESULTS_LUT = new HashMap<String, Object>();\n                                        String url[] = lineBuff[1].split(\"@\",2);\n                                        String ddtime = lineBuff[2];\n                                        String actime = lineBuff[3];\n                                        Long ftime = (long)0;\n                                        String user = \"\";\n                                        String realurl = \"\";\n                                        String domain = \"\";\n                                      if(url.length > 1)\n                                      {\n                                       user = url[0];\n                                       user = user.replace(\"Visited:\", \"\");\n                                       user = user.replace(\":Host:\", \"\");\n                                       user = user.replaceAll(\"(:)(.*?)(:)\", \"\");\n                                       user = user.trim();\n                                       realurl = url[1];\n                                       realurl = realurl.replace(\"Visited:\", \"\");\n                                       realurl = realurl.replaceAll(\":(.*?):\", \"\");\n                                       realurl = realurl.replace(\":Host:\", \"\");\n                                       realurl = realurl.trim();\n                                       domain = Util.extractDomain(realurl);\n                                      }\n                                      if(!ddtime.isEmpty()){\n                                          ddtime = ddtime.replace(\"T\",\" \");\n                                          ddtime = ddtime.substring(ddtime.length()-5);\n                                      }\n                                        if(!actime.isEmpty()){\n                                        try{\n                                        Long epochtime = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\").parse(actime).getTime();\n                                        ftime = epochtime.longValue();\n                                        }\n                                        catch(ParseException e){\n                                              logger.log(Level.SEVERE, \"ExtractIE::parsePascosResults() -> \", e.getMessage());\n                                        }\n                                      }\n                                       \n                                        // TODO: Need to fix this so we have the right obj_id\n                                        BlackboardArtifact bbart = tempDb.getContentById(artObjId).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"\", realurl));\n                                       \n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", \"\", ftime));\n                                        \n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(), \"RecentActivity\", \"\", \"\"));\n                                   \n                                     //   bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", \"\", ddtime));\n                                       \n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"Internet Explorer\"));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",domain));\n                                        bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_USERNAME.getTypeID(),\"RecentActivity\",\"\",user));\n                                        bbart.addAttributes(bbattributes);\n\n                                        //KeyValueThing\n                                        //This will be redundant in terms IE.name() because of\n                                        //the way they implemented KeyValueThing\n                                        IE_OBJ = new LinkedHashMap<String, Object>();\n                                        IE_OBJ.put(BrowserType.IE.name(), PASCO_RESULTS_LUT);\n                                        IE_PASCO_LUT.addMap(IE_OBJ);\n\n                                        PASCO_RESULTS_LIST.add(PASCO_RESULTS_LUT);\n                                    } catch (TskException ex) {\n                                        Exceptions.printStackTrace(ex);\n                                    } \n                                }\n\n                            }\n                        }\n                        //TODO: Fix Delete issue\n                        boolean bDelete = file.delete();\n                    }\n                } catch (IOException ioex) {\n                    logger.log(Level.SEVERE, \"ExtractIE::parsePascosResults() -> \", ioex.getMessage());\n                }\n\n            }\n        }\n        \n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n    }","commit_id":"cbc57ad2a76b92fbbce34bb0d626c6ef52e5a770","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void getffdb(List<String> image, IngestImageWorkerController controller){\n         //Make these seperate, this is for history\n        try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }     \n            List<FsContent> FFSqlitedb;  \n\n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%places.sqlite%' and parent_path LIKE '%Firefox%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            Statement s = rs.getStatement();\n            rs.close();\n            if (s != null)\n                s.close();\n                    FireFoxCount = FFSqlitedb.size();\n                      \n            rs.close();\n            rs.getStatement().close();\n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n\n            {         \n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                \n                try\n                {\n                   \n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffquery);  \n                   while(temprs.next()) \n                   {    \n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                       Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",((temprs.getString(\"visit_date\") != null) ? temprs.getString(\"visit_date\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"ref\") != null) ? temprs.getString(\"ref\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\"));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",(Util.extractDomain((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"\"))));\n                       bbart.addAttributes(bbattributes);\n                      \n                   }\n                   temprs.close(); \n                   tempdbconnect.closeConnection();\n \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                \n                   try\n                {\n                   \n                   \n                    dbconnect tempdbconnect2 = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet tempbm = tempdbconnect2.executeQry(ffbookmarkquery);  \n                   while(tempbm.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_BOOKMARK);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"\",((tempbm.getString(\"url\") != null) ? tempbm.getString(\"url\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\", ((tempbm.getString(\"title\") != null) ? tempbm.getString(\"title\").replaceAll(\"'\", \"''\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\")); \n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",Util.extractDomain(tempbm.getString(\"url\"))));\n                     bbart.addAttributes(bbattributes);\n                   } \n                   tempbm.close();\n                   tempdbconnect2.closeConnection();\n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                \n              \n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        \n        //COOKIES section\n          // This gets the cookie info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n\n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%cookies.sqlite%' and parent_path LIKE '%Firefox%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);   \n            rs.close();\n            rs.getStatement().close();  \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffcookiequery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_COOKIE);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"\", temprs.getString(\"host\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", \"Last Visited\", temprs.getString(\"lastAccessed\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", \"\", temprs.getString(\"value\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"Title\",((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\"));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",temprs.getString(\"host\")));\n                       bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n         \n         \n          //Downloads section\n          // This gets the downloads info\n         try \n         {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'downloads.sqlite' and parent_path LIKE '%Firefox%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffdownloadquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_DOWNLOAD); \n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",temprs.getString(\"startTime\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",((temprs.getString(\"source\") != null) ? temprs.getString(\"source\") : \"\")));\n                     //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\").replaceAll(\"'\", \"''\") : \"\")));\n                     String urldecodedtarget = URLDecoder.decode(temprs.getString(\"target\").replaceAll(\"file:///\", \"\"), \"UTF-8\");\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), \"Recent Activity\", \"\", urldecodedtarget));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",Util.extractDomain(temprs.getString(\"source\"))));\n\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\"));\n                     bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get FireFox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n   }","id":38516,"modified_method":"public void getffdb(List<String> image, IngestImageWorkerController controller){\n         //Make these seperate, this is for history\n        try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }     \n            List<FsContent> FFSqlitedb;  \n\n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%places.sqlite%' and parent_path LIKE '%Firefox%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            Statement s = rs.getStatement();\n            rs.close();\n            if (s != null)\n                s.close();\n                    FireFoxCount = FFSqlitedb.size();\n                      \n            rs.close();\n            rs.getStatement().close();\n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n\n            {         \n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                \n                try\n                {\n                   \n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffquery);  \n                   while(temprs.next()) \n                   {    \n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_HISTORY);\n                       Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",temprs.getLong(\"visit_date\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"ref\") != null) ? temprs.getString(\"ref\") : \"\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\"RecentActivity\",\"\",((temprs.getString(\"title\") != null) ? temprs.getString(\"title\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\"));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",(Util.extractDomain((temprs.getString(\"url\") != null) ? temprs.getString(\"url\") : \"\"))));\n                       bbart.addAttributes(bbattributes);\n                      \n                   }\n                   temprs.close(); \n                   tempdbconnect.closeConnection();\n \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                \n                   try\n                {\n                   \n                   \n                    dbconnect tempdbconnect2 = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet tempbm = tempdbconnect2.executeQry(ffbookmarkquery);  \n                   while(tempbm.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_BOOKMARK);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\"RecentActivity\",\"\",((tempbm.getString(\"url\") != null) ? tempbm.getString(\"url\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\", ((tempbm.getString(\"title\") != null) ? tempbm.getString(\"title\").replaceAll(\"'\", \"''\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\")); \n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",Util.extractDomain(tempbm.getString(\"url\"))));\n                     bbart.addAttributes(bbattributes);\n                   } \n                   tempbm.close();\n                   tempdbconnect2.closeConnection();\n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                \n              \n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY)); \n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n        \n        \n        //COOKIES section\n          // This gets the cookie info\n         try \n        {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n            String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n\n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE '%cookies.sqlite%' and parent_path LIKE '%Firefox%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);   \n            rs.close();\n            rs.getStatement().close();  \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + File.separator + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffcookiequery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_COOKIE);\n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\", \"\", temprs.getString(\"host\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", \"Last Visited\", temprs.getLong(\"lastAccessed\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", \"\", temprs.getString(\"value\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"Title\",((temprs.getString(\"name\") != null) ? temprs.getString(\"name\") : \"\")));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\"));\n                      bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",temprs.getString(\"host\")));\n                       bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get Firefox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        }\n         \n         \n          //Downloads section\n          // This gets the downloads info\n         try \n         {   \n            Case currentCase = Case.getCurrentCase(); // get the most updated case\n            SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n             String allFS = new String();\n            for(int i = 0; i < image.size(); i++) {\n                if(i == 0)\n                    allFS += \" AND (0\";\n                allFS += \" OR fs_obj_id = '\" + image.get(i) + \"'\";\n                if(i == image.size()-1)\n                    allFS += \")\";\n            }\n            List<FsContent> FFSqlitedb;  \n            ResultSet rs = tempDb.runQuery(\"select * from tsk_files where name LIKE 'downloads.sqlite' and parent_path LIKE '%Firefox%'\" + allFS);\n            FFSqlitedb = tempDb.resultSetToFsContents(rs);\n            rs.close();\n            rs.getStatement().close();  \n            \n            int j = 0;\n     \n            while (j < FFSqlitedb.size())\n            {\n                String temps = currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\";\n                String connectionString = \"jdbc:sqlite:\" + temps;\n                ContentUtils.writeToFile(FFSqlitedb.get(j), new File(currentCase.getTempDirectory() + \"\\\\\" + FFSqlitedb.get(j).getName().toString() + j + \".db\"));\n                File dbFile = new File(temps);\n                if (controller.isCancelled() ) {\n                 dbFile.delete();\n                 break;\n                }  \n                 try\n                {\n                   dbconnect tempdbconnect = new dbconnect(\"org.sqlite.JDBC\",connectionString);\n                   ResultSet temprs = tempdbconnect.executeQry(ffdownloadquery);  \n                   while(temprs.next()) \n                   {\n                      BlackboardArtifact bbart = FFSqlitedb.get(j).newArtifact(ARTIFACT_TYPE.TSK_WEB_DOWNLOAD); \n                      Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(),\"RecentActivity\",\"Last Visited\",temprs.getLong(\"startTime\")));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_URL.getTypeID(), \"RecentActivity\",\"\",((temprs.getString(\"source\") != null) ? temprs.getString(\"source\") : \"\")));\n                     //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\",\"\", ((temprs.getString(\"title\") != null) ? temprs.getString(\"title\").replaceAll(\"'\", \"''\") : \"\")));\n                     String urldecodedtarget = URLDecoder.decode(temprs.getString(\"target\").replaceAll(\"file:///\", \"\"), \"UTF-8\");\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), \"Recent Activity\", \"\", urldecodedtarget));\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(),\"RecentActivity\",\"\",Util.extractDomain(temprs.getString(\"source\"))));\n\n                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\"RecentActivity\",\"\",\"FireFox\"));\n                     bbart.addAttributes(bbattributes);\n                      \n                   } \n                   tempdbconnect.closeConnection();\n                   temprs.close();\n                    \n                 }\n                 catch (Exception ex)\n                 {\n                    logger.log(Level.WARNING, \"Error while trying to read into a sqlite db.\" + connectionString, ex);      \n                 }\n                j++;\n                dbFile.delete();\n            }\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(\"Recent Activity\", BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD)); \n        }\n        catch (SQLException ex) \n        {\n           logger.log(Level.WARNING, \"Error while trying to get FireFox SQLite db.\", ex);\n        }\n        catch(IOException ioex)\n        {   \n            logger.log(Level.WARNING, \"Error while trying to write to the file system.\", ioex);\n        } \n   }","commit_id":"cbc57ad2a76b92fbbce34bb0d626c6ef52e5a770","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static void findCallLogsInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n            return;\n        }\n\n        try {\n            resultSet = statement.executeQuery(\n                    \"SELECT number,date,duration,type, name FROM calls ORDER BY date DESC;\");\n\n            BlackboardArtifact bba;\n\n            while (resultSet.next()) {\n                // name of person dialed or called. null if unregistered\n                String name = resultSet.getString(\"name\");\n                String number = resultSet.getString(\"number\");\n                //duration of call in seconds\n                Long duration = Long.valueOf(resultSet.getString(\"duration\"));\n                Long date = Long.valueOf(resultSet.getString(\"date\")) / 1000;\n\n                String direction = \"\";\n                switch (Integer.valueOf(resultSet.getString(\"type\"))) {\n                    case 1:\n                        direction = \"Incoming\";\n                        break;\n                    case 2:\n                        direction = \"Outgoing\";\n                        break;\n                    case 3:\n                        direction = \"Missed\";\n                        break;\n                }\n\n                bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG); //create a call log and then add attributes from result set.\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(), moduleName, number));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID(), moduleName, date));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID(), moduleName, duration + date));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, direction));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, name));\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Call logs to the Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing the database\", e);\n            }\n        }\n\n    }","id":38517,"modified_method":"private static void findCallLogsInDB(String DatabasePath, AbstractFile f) {\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try (Connection connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n             Statement statement = connection.createStatement();) {\n\n            for (String tableName : tableNames) {\n                try (ResultSet resultSet = statement.executeQuery(\n                        \"SELECT number,date,duration,type, name FROM \" + tableName + \" ORDER BY date DESC;\");) {\n                    logger.log(Level.INFO, \"Reading call log from table {0} in db {1}\", new Object[]{tableName, DatabasePath});\n                    while (resultSet.next()) {\n                        Long date = resultSet.getLong(\"date\") / 1000;\n                        final CallDirection direction = CallDirection.fromType(resultSet.getInt(\"type\"));\n                        String directionString = direction != null ? direction.getDisplayName() : \"\";\n                        final String number = resultSet.getString(\"number\");\n                        final long duration = resultSet.getLong(\"duration\");//duration of call is in seconds\n                        final String name = resultSet.getString(\"name\");// name of person dialed or called. null if unregistered\n\n                        try {\n                            BlackboardArtifact bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG); //create a call log and then add attributes from result set.\n                            bba.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(), moduleName, number));\n                            bba.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID(), moduleName, date));\n                            bba.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID(), moduleName, duration + date));\n                            bba.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, directionString));\n                            bba.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, name));\n                        } catch (TskCoreException ex) {\n                            logger.log(Level.SEVERE, \"Error posting call log record to the Blackboard\", ex);\n                        }\n                    }\n                } catch (SQLException e) {\n                    logger.log(Level.WARNING, \"Could not read table {0} in db {1}\", new Object[]{tableName, DatabasePath});\n                }\n            }\n        } catch (SQLException e) {\n            logger.log(Level.SEVERE, \"Could not parse call log; error connecting to db \" + DatabasePath, e);\n        }\n    }","commit_id":"a9e823d62b5e2fab494ff7443c0feac2668d0a59","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static void findCallLogs() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='contacts2.db' OR name ='contacts.db'\"); //get exact file names \n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile abstractFile : absFiles) {\n                try {\n                    File jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n\n                    findCallLogsInDB(jFile.toString(), abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Call logs\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Call logs\", e);\n        }\n    }","id":38518,"modified_method":"public static void findCallLogs() {\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n\n            for (AbstractFile abstractFile : skCase.findAllFilesWhere(fileNameQuery)) {\n                try {\n                    File file = new File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, file);\n                    findCallLogsInDB(file.toString(), abstractFile);\n                } catch (IOException e) {\n                    logger.log(Level.SEVERE, \"Error writing temporary call log db to disk\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding call logs\", e);\n        }\n    }","commit_id":"a9e823d62b5e2fab494ff7443c0feac2668d0a59","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public TimeSeriesResolution getTimeSeriesResolution() {\n      return resolution;\n    }","id":38519,"modified_method":"@Override\n    public int getTimeSeriesResolution() {\n      return resolution;\n    }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"public MetricsRequestImpl(URI requestURI, String contextPrefix, String runId, String metricPrefix, String tagPrefix,\n                              long startTime, long endTime, Type type, TimeSeriesResolution resolution,\n                              int count, MetricsScope scope, Interpolator interpolator) {\n      Preconditions.checkNotNull(scope);\n      this.contextPrefix = contextPrefix;\n      this.requestURI = requestURI;\n      this.runId = runId;\n      this.metricPrefix = metricPrefix;\n      this.tagPrefix = tagPrefix;\n      this.startTime = startTime;\n      this.endTime = endTime;\n      this.type = type;\n      this.count = count;\n      this.scope = scope;\n      this.interpolator = interpolator;\n      this.resolution = resolution;\n    }","id":38520,"modified_method":"public MetricsRequestImpl(URI requestURI, String contextPrefix, String runId, String metricPrefix, String tagPrefix,\n                              long startTime, long endTime, Type type, int resolution,\n                              int count, MetricsScope scope, Interpolator interpolator) {\n      Preconditions.checkNotNull(scope);\n      this.contextPrefix = contextPrefix;\n      this.requestURI = requestURI;\n      this.runId = runId;\n      this.metricPrefix = metricPrefix;\n      this.tagPrefix = tagPrefix;\n      this.startTime = startTime;\n      this.endTime = endTime;\n      this.type = type;\n      this.count = count;\n      this.scope = scope;\n      this.interpolator = interpolator;\n      this.resolution = resolution;\n    }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"MetricsRequestBuilder setTimeSeriesResolution(MetricsRequest.TimeSeriesResolution resolution) {\n    this.resolution = resolution;\n    return this;\n  }","id":38521,"modified_method":"MetricsRequestBuilder setTimeSeriesResolution(int resolution) {\n    this.resolution = resolution;\n    return this;\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"private void computeProcessBusyness(MetricsRequest metricsRequest, TimeSeriesResponse.Builder builder)\n    throws OperationException {\n    int resolution = metricsRequest.getTimeSeriesResolution().getResolution();\n    long start = metricsRequest.getStartTime() / resolution * resolution;\n    long end = (metricsRequest.getEndTime() / resolution) * resolution;\n    MetricsScanQuery scanQuery = new MetricsScanQueryBuilder()\n      .setContext(metricsRequest.getContextPrefix())\n      .setMetric(\"process.tuples.read\")\n      .build(start, end);\n    MetricsScope scope = metricsRequest.getScope();\n\n    PeekingIterator<TimeValue> tuplesReadItor =\n      Iterators.peekingIterator(queryTimeSeries(scope, scanQuery, metricsRequest.getInterpolator(),\n                                                metricsRequest.getTimeSeriesResolution().getResolution()));\n\n    scanQuery = new MetricsScanQueryBuilder()\n      .setContext(metricsRequest.getContextPrefix())\n      .setMetric(\"process.events.processed\")\n      .build(metricsRequest.getStartTime(), metricsRequest.getEndTime());\n\n    PeekingIterator<TimeValue> eventsProcessedItor =\n      Iterators.peekingIterator(queryTimeSeries(scope, scanQuery, metricsRequest.getInterpolator(),\n                                                metricsRequest.getTimeSeriesResolution().getResolution()));\n    long resultTimeStamp = start;\n\n    for (int i = 0; i < metricsRequest.getCount(); i++) {\n      long tupleRead = 0;\n      long eventProcessed = 0;\n      if (tuplesReadItor.hasNext() && tuplesReadItor.peek().getTime() == resultTimeStamp) {\n        tupleRead = tuplesReadItor.next().getValue();\n      }\n      if (eventsProcessedItor.hasNext() && eventsProcessedItor.peek().getTime() == resultTimeStamp) {\n        eventProcessed = eventsProcessedItor.next().getValue();\n      }\n      if (eventProcessed != 0) {\n        int busyness = (int) ((float) tupleRead / eventProcessed * 100);\n        builder.addData(resultTimeStamp, busyness > 100 ? 100 : busyness);\n      } else {\n        // If the scan result doesn't have value for a timestamp, we add 0 to the returned result for that timestamp.\n        builder.addData(resultTimeStamp, 0);\n      }\n      resultTimeStamp += metricsRequest.getTimeSeriesResolution().getResolution();\n    }\n  }","id":38522,"modified_method":"private void computeProcessBusyness(MetricsRequest metricsRequest, TimeSeriesResponse.Builder builder)\n    throws OperationException {\n    int resolution = metricsRequest.getTimeSeriesResolution();\n    long start = metricsRequest.getStartTime() / resolution * resolution;\n    long end = (metricsRequest.getEndTime() / resolution) * resolution;\n    MetricsScanQuery scanQuery = new MetricsScanQueryBuilder()\n      .setContext(metricsRequest.getContextPrefix())\n      .setMetric(\"process.tuples.read\")\n      .build(start, end);\n    MetricsScope scope = metricsRequest.getScope();\n\n    PeekingIterator<TimeValue> tuplesReadItor =\n      Iterators.peekingIterator(queryTimeSeries(scope, scanQuery, metricsRequest.getInterpolator(),\n                                                metricsRequest.getTimeSeriesResolution()));\n\n    scanQuery = new MetricsScanQueryBuilder()\n      .setContext(metricsRequest.getContextPrefix())\n      .setMetric(\"process.events.processed\")\n      .build(metricsRequest.getStartTime(), metricsRequest.getEndTime());\n\n    PeekingIterator<TimeValue> eventsProcessedItor =\n      Iterators.peekingIterator(queryTimeSeries(scope, scanQuery, metricsRequest.getInterpolator(),\n                                                metricsRequest.getTimeSeriesResolution()));\n    long resultTimeStamp = start;\n\n    for (int i = 0; i < metricsRequest.getCount(); i++) {\n      long tupleRead = 0;\n      long eventProcessed = 0;\n      if (tuplesReadItor.hasNext() && tuplesReadItor.peek().getTime() == resultTimeStamp) {\n        tupleRead = tuplesReadItor.next().getValue();\n      }\n      if (eventsProcessedItor.hasNext() && eventsProcessedItor.peek().getTime() == resultTimeStamp) {\n        eventProcessed = eventsProcessedItor.next().getValue();\n      }\n      if (eventProcessed != 0) {\n        int busyness = (int) ((float) tupleRead / eventProcessed * 100);\n        builder.addData(resultTimeStamp, busyness > 100 ? 100 : busyness);\n      } else {\n        // If the scan result doesn't have value for a timestamp, we add 0 to the returned result for that timestamp.\n        builder.addData(resultTimeStamp, 0);\n      }\n      resultTimeStamp += metricsRequest.getTimeSeriesResolution();\n    }\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"private Iterator<TimeValue> queryTimeSeries(MetricsScope scope, MetricsScanQuery scanQuery,\n                                              Interpolator interpolator, int resolution) throws OperationException {\n    Map<TimeseriesId, Iterable<TimeValue>> timeValues = Maps.newHashMap();\n    MetricsScanner scanner = timeSeriesTables.getTable(scope, resolution).scan(scanQuery);\n    while (scanner.hasNext()) {\n      MetricsScanResult res = scanner.next();\n      // if we get multiple scan results for the same logical timeseries, concatenate them together.\n      // Needed if we need to interpolate across scan results.  Using the fact that the is a scan\n      // over an ordered table, so the earlier timeseries is guaranteed to come first.\n      TimeseriesId timeseriesId = new TimeseriesId(res.getContext(), res.getMetric(), res.getTag(), res.getRunId());\n      if (!timeValues.containsKey(timeseriesId)) {\n        timeValues.put(timeseriesId, res);\n      } else {\n        timeValues.put(timeseriesId, Iterables.concat(timeValues.get(timeseriesId), res));\n      }\n    }\n\n    return new TimeValueAggregator(timeValues.values(), interpolator).iterator();\n  }","id":38523,"modified_method":"private Iterator<TimeValue> queryTimeSeries(MetricsScope scope, MetricsScanQuery scanQuery,\n                                              Interpolator interpolator, int resolution) throws OperationException {\n    Map<TimeseriesId, Iterable<TimeValue>> timeValues = Maps.newHashMap();\n    MetricsScanner scanner = timeSeriesTables.scan(scope, resolution, scanQuery);\n    while (scanner.hasNext()) {\n      MetricsScanResult res = scanner.next();\n      // if we get multiple scan results for the same logical timeseries, concatenate them together.\n      // Needed if we need to interpolate across scan results.  Using the fact that the is a scan\n      // over an ordered table, so the earlier timeseries is guaranteed to come first.\n      TimeseriesId timeseriesId = new TimeseriesId(res.getContext(), res.getMetric(), res.getTag(), res.getRunId());\n      if (!timeValues.containsKey(timeseriesId)) {\n        timeValues.put(timeseriesId, res);\n      } else {\n        timeValues.put(timeseriesId, Iterables.concat(timeValues.get(timeseriesId), res));\n      }\n    }\n\n    return new TimeValueAggregator(timeValues.values(), interpolator).iterator();\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"public JsonElement executeQuery(MetricsRequest metricsRequest) throws IOException, OperationException {\n\n    // Pretty ugly logic now. Need to refactor\n    Object resultObj = null;\n    if (metricsRequest.getType() == MetricsRequest.Type.TIME_SERIES) {\n      TimeSeriesResponse.Builder builder = TimeSeriesResponse.builder(metricsRequest.getStartTime(),\n                                                                      metricsRequest.getEndTime());\n      // Special metrics handle that requires computation from multiple time series.\n      if (\"process.busyness\".equals(metricsRequest.getMetricPrefix())) {\n        computeProcessBusyness(metricsRequest, builder);\n      } else {\n        MetricsScanQuery scanQuery = createScanQuery(metricsRequest);\n\n        PeekingIterator<TimeValue> timeValueItor = Iterators.peekingIterator(\n          queryTimeSeries(metricsRequest.getScope(),\n                          scanQuery,\n                          metricsRequest.getInterpolator(),\n                          metricsRequest.getTimeSeriesResolution().getResolution()));\n\n        // if this is an interpolated timeseries, we might have extended the \"start\" in order to interpolate.\n        // so fast forward the iterator until we we're inside the actual query time window.\n        if (metricsRequest.getInterpolator() != null) {\n          while (timeValueItor.hasNext() &&\n            ((timeValueItor.peek().getTime() +\n              metricsRequest.getTimeSeriesResolution().getResolution()) <= metricsRequest.getStartTime())) {\n            timeValueItor.next();\n          }\n        }\n        long resolution = metricsRequest.getTimeSeriesResolution().getResolution();\n        long resultTimeStamp = (metricsRequest.getStartTime() / resolution) * resolution;\n\n        for (int i = 0; i < metricsRequest.getCount(); i++) {\n          if (timeValueItor.hasNext() && timeValueItor.peek().getTime() == resultTimeStamp) {\n            builder.addData(resultTimeStamp, timeValueItor.next().getValue());\n          } else {\n            // If the scan result doesn't have value for a timestamp, we add 0 to the result-returned for that timestamp\n            builder.addData(resultTimeStamp, 0);\n          }\n          resultTimeStamp += metricsRequest.getTimeSeriesResolution().getResolution();\n        }\n      }\n      resultObj = builder.build();\n\n    } else if (metricsRequest.getType() == MetricsRequest.Type.AGGREGATE) {\n      // Special metrics handle that requires computation from multiple aggregates results.\n      if (\"process.events.pending\".equals(metricsRequest.getMetricPrefix())) {\n        resultObj = computeQueueLength(metricsRequest);\n      } else {\n        resultObj = getAggregates(metricsRequest);\n      }\n    }\n\n    return GSON.toJsonTree(resultObj);\n  }","id":38524,"modified_method":"public JsonElement executeQuery(MetricsRequest metricsRequest) throws IOException, OperationException {\n\n    // Pretty ugly logic now. Need to refactor\n    Object resultObj = null;\n    if (metricsRequest.getType() == MetricsRequest.Type.TIME_SERIES) {\n      TimeSeriesResponse.Builder builder = TimeSeriesResponse.builder(metricsRequest.getStartTime(),\n                                                                      metricsRequest.getEndTime());\n      // Special metrics handle that requires computation from multiple time series.\n      if (\"process.busyness\".equals(metricsRequest.getMetricPrefix())) {\n        computeProcessBusyness(metricsRequest, builder);\n      } else {\n        MetricsScanQuery scanQuery = createScanQuery(metricsRequest);\n\n        PeekingIterator<TimeValue> timeValueItor = Iterators.peekingIterator(\n          queryTimeSeries(metricsRequest.getScope(),\n                          scanQuery,\n                          metricsRequest.getInterpolator(),\n                          metricsRequest.getTimeSeriesResolution()));\n\n        // if this is an interpolated timeseries, we might have extended the \"start\" in order to interpolate.\n        // so fast forward the iterator until we we're inside the actual query time window.\n        if (metricsRequest.getInterpolator() != null) {\n          while (timeValueItor.hasNext() &&\n            ((timeValueItor.peek().getTime() +\n              metricsRequest.getTimeSeriesResolution()) <= metricsRequest.getStartTime())) {\n            timeValueItor.next();\n          }\n        }\n        long resolution = metricsRequest.getTimeSeriesResolution();\n        long resultTimeStamp = (metricsRequest.getStartTime() / resolution) * resolution;\n\n        for (int i = 0; i < metricsRequest.getCount(); i++) {\n          if (timeValueItor.hasNext() && timeValueItor.peek().getTime() == resultTimeStamp) {\n            builder.addData(resultTimeStamp, timeValueItor.next().getValue());\n          } else {\n            // If the scan result doesn't have value for a timestamp, we add 0 to the result-returned for that timestamp\n            builder.addData(resultTimeStamp, 0);\n          }\n          resultTimeStamp += metricsRequest.getTimeSeriesResolution();\n        }\n      }\n      resultObj = builder.build();\n\n    } else if (metricsRequest.getType() == MetricsRequest.Type.AGGREGATE) {\n      // Special metrics handle that requires computation from multiple aggregates results.\n      if (\"process.events.pending\".equals(metricsRequest.getMetricPrefix())) {\n        resultObj = computeQueueLength(metricsRequest);\n      } else {\n        resultObj = getAggregates(metricsRequest);\n      }\n    }\n\n    return GSON.toJsonTree(resultObj);\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"private MetricsScanQuery createScanQuery(MetricsRequest request) {\n    int resolution = request.getTimeSeriesResolution().getResolution();\n    long start = request.getStartTime() / resolution * resolution;\n    long end = (request.getEndTime() / resolution) * resolution;\n\n    // if we're interpolating, expand the time window a little to allow interpolation at the start and end.\n    // Before returning the results, we'll make sure to only return what the client requested.\n    Interpolator interpolator = request.getInterpolator();\n    if (interpolator != null) {\n      // try and expand the window by the max allowed gap for interpolation, but cap it so we dont have\n      // super big windows.  The worry being that somebody sets the max allowed gap to Long.MAX_VALUE\n      // to tell us to always interpolate.\n      long expandCap = Math.max(Interpolators.DEFAULT_MAX_ALLOWED_GAP, (end - start) / 4);\n      start -= Math.min(interpolator.getMaxAllowedGap(), expandCap);\n      end += Math.min(interpolator.getMaxAllowedGap(), expandCap);\n      // no use going past the current time\n      end = Math.min(end, TimeUnit.SECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS));\n    }\n\n    return new MetricsScanQueryBuilder()\n      .setContext(request.getContextPrefix())\n      .setMetric(request.getMetricPrefix())\n      .setTag(request.getTagPrefix())\n      .setRunId(request.getRunId())\n      .build(start, end);\n  }","id":38525,"modified_method":"private MetricsScanQuery createScanQuery(MetricsRequest request) {\n    int resolution = request.getTimeSeriesResolution();\n    long start = request.getStartTime() / resolution * resolution;\n    long end = (request.getEndTime() / resolution) * resolution;\n\n    // if we're interpolating, expand the time window a little to allow interpolation at the start and end.\n    // Before returning the results, we'll make sure to only return what the client requested.\n    Interpolator interpolator = request.getInterpolator();\n    if (interpolator != null) {\n      // try and expand the window by the max allowed gap for interpolation, but cap it so we dont have\n      // super big windows.  The worry being that somebody sets the max allowed gap to Long.MAX_VALUE\n      // to tell us to always interpolate.\n      long expandCap = Math.max(Interpolators.DEFAULT_MAX_ALLOWED_GAP, (end - start) / 4);\n      start -= Math.min(interpolator.getMaxAllowedGap(), expandCap);\n      end += Math.min(interpolator.getMaxAllowedGap(), expandCap);\n      // no use going past the current time\n      end = Math.min(end, TimeUnit.SECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS));\n    }\n\n    return new MetricsScanQueryBuilder()\n      .setContext(request.getContextPrefix())\n      .setMetric(request.getMetricPrefix())\n      .setTag(request.getTagPrefix())\n      .setRunId(request.getRunId())\n      .build(start, end);\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"private static void parseTimeseries(Map<String, List<String>> queryParams, MetricsRequestBuilder builder) {\n    int count;\n    long startTime;\n    long endTime;\n    int resolution = 1;\n    long now = TimeUnit.SECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n\n    if (queryParams.containsKey(RESOLUTION)) {\n      try {\n        MetricsRequest.TimeSeriesResolution resolutionInterval = MetricsRequest.TimeSeriesResolution.valueOf(\n          queryParams.get(RESOLUTION).get(0).toUpperCase());\n        builder.setTimeSeriesResolution(resolutionInterval);\n        resolution = resolutionInterval.getResolution();\n      } catch (IllegalArgumentException e) {\n        builder.setTimeSeriesResolution(MetricsRequest.TimeSeriesResolution.SECOND);\n      }\n    } else {\n      builder.setTimeSeriesResolution(MetricsRequest.TimeSeriesResolution.SECOND);\n    }\n\n    if (queryParams.containsKey(START_TIME) && queryParams.containsKey(END_TIME)) {\n      startTime = TimeMathParser.parseTime(now, queryParams.get(START_TIME).get(0));\n      endTime = TimeMathParser.parseTime(now, queryParams.get(END_TIME).get(0));\n      if (!queryParams.containsKey(RESOLUTION)) {\n        // determine resolution, based on difference.\n        MetricsRequest.TimeSeriesResolution autoResolution = getResolution(endTime - startTime);\n        builder.setTimeSeriesResolution(autoResolution);\n        resolution = autoResolution.getResolution();\n      }\n      if (queryParams.containsKey(COUNT)) {\n        count = Integer.parseInt(queryParams.get(COUNT).get(0));\n      } else {\n        count = (int) (((endTime / resolution * resolution) - (startTime / resolution * resolution)) / resolution + 1);\n      }\n    } else if (queryParams.containsKey(COUNT)) {\n      count = Integer.parseInt(queryParams.get(COUNT).get(0));\n      // both start and end times are inclusive, which is the reason for the +-1.\n      if (queryParams.containsKey(START_TIME)) {\n        startTime = TimeMathParser.parseTime(now, queryParams.get(START_TIME).get(0));\n        endTime = startTime + (count * resolution) - resolution;\n      } else if (queryParams.containsKey(END_TIME)) {\n        endTime = TimeMathParser.parseTime(now, queryParams.get(END_TIME).get(0));\n        startTime = endTime - (count * resolution) + resolution;\n      } else {\n        // if only count is specified, assume the current time is desired as the end.\n        endTime = now - MetricsConstants.QUERY_SECOND_DELAY;\n        startTime = endTime - (count * resolution) + resolution;\n      }\n    } else {\n      throw new IllegalArgumentException(\"must specify 'count', or both 'start' and 'end'\");\n    }\n\n    builder.setStartTime(startTime);\n    builder.setEndTime(endTime);\n    builder.setCount(count);\n    builder.setType(MetricsRequest.Type.TIME_SERIES);\n    setInterpolator(queryParams, builder);\n  }","id":38526,"modified_method":"private static void parseTimeseries(Map<String, List<String>> queryParams, MetricsRequestBuilder builder) {\n    int count;\n    long startTime;\n    long endTime;\n    int resolution = 1;\n    long now = TimeUnit.SECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n\n    if (queryParams.containsKey(RESOLUTION)) {\n\n        resolution = TimeMathParser.resolutionInSeconds(queryParams.get(RESOLUTION).get(0));\n        if ((resolution == 3600) || (resolution == 60) || (resolution == 1)) {\n          builder.setTimeSeriesResolution(resolution);\n        } else {\n          throw new IllegalArgumentException(\"Resolution interval not supported, only 1 second, 1 minute and \" +\n                                               \"1 hour resolutions are supported currently\");\n        }\n\n    } else {\n      // if resolution is not provided set 1\n      builder.setTimeSeriesResolution(1);\n    }\n\n    if (queryParams.containsKey(START_TIME) && queryParams.containsKey(END_TIME)) {\n      startTime = TimeMathParser.parseTime(now, queryParams.get(START_TIME).get(0));\n      endTime = TimeMathParser.parseTime(now, queryParams.get(END_TIME).get(0));\n      if (!queryParams.containsKey(RESOLUTION)) {\n        // determine resolution, based on difference.\n        MetricsRequest.TimeSeriesResolution autoResolution = getResolution(endTime - startTime);\n        builder.setTimeSeriesResolution(autoResolution.getResolution());\n        resolution = autoResolution.getResolution();\n      }\n      if (queryParams.containsKey(COUNT)) {\n        count = Integer.parseInt(queryParams.get(COUNT).get(0));\n      } else {\n        count = (int) (((endTime / resolution * resolution) - (startTime / resolution * resolution)) / resolution + 1);\n      }\n    } else if (queryParams.containsKey(COUNT)) {\n      count = Integer.parseInt(queryParams.get(COUNT).get(0));\n      // both start and end times are inclusive, which is the reason for the +-1.\n      if (queryParams.containsKey(START_TIME)) {\n        startTime = TimeMathParser.parseTime(now, queryParams.get(START_TIME).get(0));\n        endTime = startTime + (count * resolution) - resolution;\n      } else if (queryParams.containsKey(END_TIME)) {\n        endTime = TimeMathParser.parseTime(now, queryParams.get(END_TIME).get(0));\n        startTime = endTime - (count * resolution) + resolution;\n      } else {\n        // if only count is specified, assume the current time is desired as the end.\n        endTime = now - MetricsConstants.QUERY_SECOND_DELAY;\n        startTime = endTime - (count * resolution) + resolution;\n      }\n    } else {\n      throw new IllegalArgumentException(\"must specify 'count', or both 'start' and 'end'\");\n    }\n\n    builder.setStartTime(startTime);\n    builder.setEndTime(endTime);\n    builder.setCount(count);\n    builder.setType(MetricsRequest.Type.TIME_SERIES);\n    setInterpolator(queryParams, builder);\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testQueryArgs() throws MetricsPathException {\n    MetricsRequest request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?count=60\"));\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertEquals(60, request.getCount());\n\n    request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?summary=true\"));\n    Assert.assertEquals(MetricsRequest.Type.SUMMARY, request.getType());\n\n    request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?aggregate=true\"));\n    Assert.assertEquals(MetricsRequest.Type.AGGREGATE, request.getType());\n\n    request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&\" +\n                                                      \"resolution=second\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.TimeSeriesResolution.SECOND, request.getTimeSeriesResolution());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&resolution=minute\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertEquals(MetricsRequest.TimeSeriesResolution.MINUTE, request.getTimeSeriesResolution());\n    Assert.assertNull(request.getInterpolator());\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?start=1&end=61&resolution=hour\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertEquals(MetricsRequest.TimeSeriesResolution.HOUR, request.getTimeSeriesResolution());\n    Assert.assertNull(request.getInterpolator());\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&interpolate=step\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertTrue(request.getInterpolator() instanceof Interpolators.Step);\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&interpolate=linear\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertTrue(request.getInterpolator() instanceof Interpolators.Linear);\n  }","id":38527,"modified_method":"@Test\n  public void testQueryArgs() throws MetricsPathException {\n    MetricsRequest request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?count=60\"));\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertEquals(60, request.getCount());\n\n    request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?summary=true\"));\n    Assert.assertEquals(MetricsRequest.Type.SUMMARY, request.getType());\n\n    request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?aggregate=true\"));\n    Assert.assertEquals(MetricsRequest.Type.AGGREGATE, request.getType());\n\n    request = MetricsRequestParser.parse(URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&\" +\n                                                      \"resolution=1s\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.TimeSeriesResolution.SECOND.getResolution(), request.getTimeSeriesResolution());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&resolution=1m\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertEquals(MetricsRequest.TimeSeriesResolution.MINUTE.getResolution(), request.getTimeSeriesResolution());\n    Assert.assertNull(request.getInterpolator());\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?start=1&end=61&resolution=60m\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertEquals(MetricsRequest.TimeSeriesResolution.HOUR.getResolution(), request.getTimeSeriesResolution());\n    Assert.assertNull(request.getInterpolator());\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&interpolate=step\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertTrue(request.getInterpolator() instanceof Interpolators.Step);\n\n    request = MetricsRequestParser.parse(\n      URI.create(\"/system/apps/app1/reads?count=60&start=1&end=61&interpolate=linear\"));\n    Assert.assertEquals(1, request.getStartTime());\n    Assert.assertEquals(61, request.getEndTime());\n    Assert.assertEquals(MetricsRequest.Type.TIME_SERIES, request.getType());\n    Assert.assertTrue(request.getInterpolator() instanceof Interpolators.Linear);\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void process(MetricsScope scope, Iterator<MetricsRecord> records) {\n    try {\n      List<MetricsRecord> metricsRecords = Lists.newArrayList();\n      while (records.hasNext()) {\n        metricsRecords.add(records.next());\n        if (metricsRecords.size() == MAX_RECORDLIST_SIZE || !records.hasNext()) {\n          timeSeriesTables.save(scope, metricsRecords.iterator());\n          metricsRecords.clear();\n        }\n      }\n    } catch (OperationException e) {\n      LOG.error(\"Failed to write to time series table: {}\", e.getMessage(), e);\n    }\n  }","id":38528,"modified_method":"@Override\n  public void process(MetricsScope scope, Iterator<MetricsRecord> records) {\n    try {\n      List<MetricsRecord> metricsRecords = Lists.newArrayList();\n      while (records.hasNext()) {\n        metricsRecords.add(records.next());\n        if (metricsRecords.size() == MAX_RECORDLIST_SIZE || !records.hasNext()) {\n          timeSeriesTables.save(scope, metricsRecords);\n          metricsRecords.clear();\n        }\n      }\n    } catch (OperationException e) {\n      LOG.error(\"Failed to write to time series table: {}\", e.getMessage(), e);\n    }\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"public void save(MetricsScope scope, Iterator<MetricsRecord> iterator) throws OperationException {\n    for (int resolution : timeSeriesResolutions) {\n      metricsTableCaches.get(scope).getUnchecked(resolution).save(iterator);\n    }\n  }","id":38529,"modified_method":"public void save(MetricsScope scope, List<MetricsRecord> records) throws OperationException {\n    for (int resolution : timeSeriesResolutions) {\n      metricsTableCaches.get(scope).getUnchecked(resolution).save(records.iterator());\n    }\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"public TimeSeriesTable getTable(MetricsScope scope, int resolution) {\n    return metricsTableCaches.get(scope).getUnchecked(resolution);\n  }","id":38530,"modified_method":"public MetricsScanner scan(MetricsScope scope, int resolution, MetricsScanQuery scanQuery) throws OperationException {\n    return metricsTableCaches.get(scope).getUnchecked(resolution).scan(scanQuery);\n  }","commit_id":"8304d14814caa995ec72b0c957c203e8be2d0650","url":"https://github.com/caskdata/cdap"},{"original_method":"private static boolean equalityExpressionIsPointless(GrExpression lhs,\n                                                       GrExpression rhs) {\n    return isTrue(lhs) || isTrue(rhs) || isFalse(lhs) || isFalse(rhs);\n  }","id":38531,"modified_method":"private static boolean equalityExpressionIsPointless(GrExpression lhs,\n                                                       GrExpression rhs) {\n    return (isTrue(lhs) || isFalse(lhs)) && isBoolean(rhs)\n           || (isTrue(rhs) || isFalse(rhs)) && isBoolean(lhs);\n  }","commit_id":"e9b0a7a2be354b19334f9fc78860456eaf2535aa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyBinaryExpression(PyBinaryExpression node) {\n      super.visitPyBinaryExpression(node);\n      final PyElementType operator = node.getOperator();\n      final PyExpression rightExpression = node.getRightExpression();\n      if (rightExpression == null) {\n        return;\n      }\n      final String leftExpressionText = node.getLeftExpression().getText();\n      final String rightExpressionText = rightExpression.getText();\n      if (\"True\".equals(leftExpressionText) ||\n          \"False\".equals(leftExpressionText) ||\n          \"True\".equals(rightExpressionText) ||\n          \"False\".equals(rightExpressionText)) {\n        if (PyTokenTypes.EQUALITY_OPERATIONS.contains(operator)) {\n          registerProblem(node);\n        }\n      }\n    }","id":38532,"modified_method":"@Override\n    public void visitPyBinaryExpression(PyBinaryExpression node) {\n      super.visitPyBinaryExpression(node);\n      final PyElementType operator = node.getOperator();\n      final PyExpression rightExpression = node.getRightExpression();\n      if (rightExpression == null) {\n        return;\n      }\n      final String leftExpressionText = node.getLeftExpression().getText();\n      final String rightExpressionText = rightExpression.getText();\n      if (\"True\".equals(leftExpressionText) ||\n          \"False\".equals(leftExpressionText) ||\n          \"0\".equals(leftExpressionText) ||\n          \"[]\".equals(leftExpressionText) ||\n          \"True\".equals(rightExpressionText) ||\n          \"False\".equals(rightExpressionText) ||\n          \"0\".equals(rightExpressionText) ||\n          \"[]\".equals(rightExpressionText)) {\n        if (PyTokenTypes.EQUALITY_OPERATIONS.contains(operator)) {\n          registerProblem(node);\n        }\n      }\n    }","commit_id":"9fb60e06b03e6235cf136f26af37f2086aa57fb1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement element = descriptor.getPsiElement();\n    if (element instanceof PyBinaryExpression) {\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      PyBinaryExpression binaryExpression = (PyBinaryExpression)element;\n      PyExpression resultExpression;\n      final PyExpression leftExpression = binaryExpression.getLeftExpression();\n      final PyExpression rightExpression = binaryExpression.getRightExpression();\n      boolean positiveCondition = !TokenSet.create(PyTokenTypes.NE, PyTokenTypes.NE_OLD).contains(binaryExpression.getOperator());\n      positiveCondition ^= isFalse(leftExpression) || isFalse(rightExpression);\n      if (isTrue(leftExpression) || isFalse(leftExpression)) {\n        resultExpression = rightExpression;\n      } else {\n        resultExpression = leftExpression;\n      }\n      String text = ((positiveCondition) ? \"\" : \"not \") + resultExpression.getText();\n      binaryExpression.replace(elementGenerator.createExpressionFromText(text));\n    }\n  }","id":38533,"modified_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement element = descriptor.getPsiElement();\n    if (element instanceof PyBinaryExpression) {\n    PyElementGenerator elementGenerator = PyElementGenerator.getInstance(project);\n      PyBinaryExpression binaryExpression = (PyBinaryExpression)element;\n      PyExpression resultExpression;\n      final PyExpression leftExpression = binaryExpression.getLeftExpression();\n      final PyExpression rightExpression = binaryExpression.getRightExpression();\n      boolean positiveCondition = !TokenSet.create(PyTokenTypes.NE, PyTokenTypes.NE_OLD).contains(binaryExpression.getOperator());\n      positiveCondition ^= isFalse(leftExpression) || isFalse(rightExpression) || isNull(rightExpression) || isNull(leftExpression)\n                           || isEmpty(rightExpression) || isEmpty(leftExpression);\n      if (isTrue(leftExpression) || isFalse(leftExpression) || isNull(leftExpression) || isEmpty(leftExpression)) {\n        resultExpression = rightExpression;\n      } else {\n        resultExpression = leftExpression;\n      }\n      String text = ((positiveCondition) ? \"\" : \"not \") + resultExpression.getText();\n      binaryExpression.replace(elementGenerator.createExpressionFromText(text));\n    }\n  }","commit_id":"9fb60e06b03e6235cf136f26af37f2086aa57fb1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Creates a where clause string \" someKey IN ( someValue1,...)\".\n     */\n    public static String sqlWhereClauseStringForKey(EOSQLExpression e, String key, NSArray valueArray) {\n        if(valueArray.count() == 0) {\n            return \"0=1\";\n        }\n        StringBuffer sb = new StringBuffer();\n        EOAttribute attribute = e.entity().attributeNamed(key);\n        if (attribute == null) {\n            EORelationship relationship = e.entity().relationshipNamed(key);\n            if (relationship == null) { throw new IllegalArgumentException(key + \" is neither an attribute nor a relationship of entity \"\n                    + e.entity().name()); }\n            if (relationship.isFlattened()) {\n                //FIXME!\n            } else {\n                attribute = ((EOJoin) relationship.joins().lastObject()).sourceAttribute();\n            }\n        }\n        sb.append(e.sqlStringForAttribute(attribute));\n        sb.append(\" IN \");\n        sb.append(\"(\");\n        for (int i = 0; i < valueArray.count(); i++) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            Object value = valueArray.objectAtIndex(i);\n            value = e.formatValueForAttribute(value, attribute);\n            sb.append(value);\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }","id":38534,"modified_method":"/**\n     * Creates a where clause string \" someKey IN ( someValue1,...)\".\n     */\n    public static String sqlWhereClauseStringForKey(EOSQLExpression e, String key, NSArray valueArray) {\n        if(valueArray.count() == 0) {\n            return \"0=1\";\n        }\n        StringBuffer sb = new StringBuffer();\n        EOAttribute attribute = e.entity().attributeNamed(key);\n        if (attribute == null) {\n            EORelationship relationship = e.entity().relationshipNamed(key);\n            if (relationship == null) { throw new IllegalArgumentException(key + \" is neither an attribute nor a relationship of entity \"\n                    + e.entity().name()); }\n            if (relationship.isFlattened()) {\n                //FIXME!\n            } else {\n                attribute = ((EOJoin) relationship.joins().lastObject()).sourceAttribute();\n            }\n        }\n        sb.append(e.sqlStringForAttribute(attribute));\n        sb.append(\" IN \");\n        sb.append(\"(\");\n        for (int i = 0; i < valueArray.count(); i++) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            Object value = valueArray.objectAtIndex(i);\n            // The Postgres Expression has a problem using bind variables so we have to get the formatted\n            // SQL string for a value instead.  All Apple provided plugins must use the bind variables\n            // however.  Frontbase can go either way\n            boolean isPostgres = e.getClass().getName().equals(\"com.webobjects.jdbcadaptor.PostgresqlExpression\");\n            value = isPostgres ? e.formatValueForAttribute(value, attribute) : e.sqlStringForValue(value, key);\n            sb.append(value);\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }","commit_id":"e6551260cc81ee368366ec11932f2da62643e3a3","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * This is Kelly Hawks' fix for the missing to one relationship. \n     * Delegate on EODatabaseContext that gets called when a to-one fault cannot find its data in\n     * the database. The object that is returned is a cleared fault.\n     * We raise here to restore the functionality that existed prior to WebObjects 4.5.\n     * Whenever a fault fails for a globalID (i.e. the object is NOT found in the database), we raise\n     * an {@link com.webobjects.eoaccess.EOObjectNotAvailableException EOObjectNotAvailableException}. <br>\n     * If you have entities you don't really care about, you can set the system property\n     * <code>er.extensions.ERXDatabaseContextDelegate.tolerantEntityPattern<\/code> to a regular expression\n     * that will be tested against the GID entity name. If it matches, then only an error will be logged\n     * but no exception will be thrown.\n     * \n     * @param context database context\n     * @param object object that is firing the fault for a given to-one relationship\n     * @param gid global id that wasn't found in the database.\n     */\n    public boolean databaseContextFailedToFetchObject(EODatabaseContext context, Object object, EOGlobalID gid) {\n    \tString tolerantEntityPattern = ERXProperties.stringForKey(\"er.extensions.ERXDatabaseContextDelegate.tolerantEntityPattern\");\n    \tboolean raiseException = true;\n    \tif(tolerantEntityPattern != null && (gid instanceof EOKeyGlobalID)) {\n    \t\tif(((EOKeyGlobalID)gid).entityName().matches(tolerantEntityPattern)) {\n    \t\t\traiseException = false;\n    \t\t}\n    \t}\n        if (object!=null) {\n            EOEditingContext ec = ((EOEnterpriseObject)object).editingContext();\n\n            // we need to refault the object before raising, otherwise, if the caller traps\n            // the exception, it will be a successful lookup the next time a fault with the\n            // same global id fires.  NOTE: refaulting in a sharedEditingContext is illegal,\n            // so we specifically check for that special case.\n\n            if (!(ec instanceof EOSharedEditingContext) && raiseException) {\n                context.refaultObject((EOEnterpriseObject)object, gid, ec);\n            }\n        }\n        String gidString;\n        if(gid instanceof EOKeyGlobalID) {\n            // ak: when you use 24 byte PKs, the output is unreadable otherwise \n            EOKeyGlobalID kgid = (EOKeyGlobalID)gid;\n            gidString = \"<\" +  kgid.entityName() + \": [\" ;\n            EOEntity entity = ERXEOAccessUtilities.entityNamed(null, kgid.entityName());\n            NSArray pks = entity.primaryKeyAttributes();\n            NSArray values = kgid.keyValuesArray();\n            EOSQLExpression expression = context.database().adaptor().expressionFactory().expressionForEntity(entity);\n            for(int i = 0; i < pks.count(); i++) {\n                Object value = values.objectAtIndex(i);\n                EOAttribute attribute = (EOAttribute) pks.objectAtIndex(i);\n                // ak: only Postgres seems to return reasonable values here...\n                String stringValue = expression.formatValueForAttribute(value, attribute);\n                if(\"NULL\".equals(stringValue)) {\n                    stringValue = \"\" + value;\n                }\n                gidString += attribute.name() + \": \\'\" +  stringValue + \"\\'\"\n                + (i == pks.count() - 1 ? \"\" : \", \");\n            }\n            gidString += \"] >\";\n            \n        } else {\n            gidString = gid.toString();\n        }\n        NSNotificationCenter.defaultCenter().postNotification(DatabaseContextFailedToFetchObject, object);\n        if(raiseException) {\n        \tthrow new ObjectNotAvailableException(\"No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gidString, gid); \n        } else {\n        \tlog.error(\"No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gidString + \"\\n\" + ERXUtilities.stackTrace()); \n        }\n        return false;\n    }","id":38535,"modified_method":"/**\n     * This is Kelly Hawks' fix for the missing to one relationship. \n     * Delegate on EODatabaseContext that gets called when a to-one fault cannot find its data in\n     * the database. The object that is returned is a cleared fault.\n     * We raise here to restore the functionality that existed prior to WebObjects 4.5.\n     * Whenever a fault fails for a globalID (i.e. the object is NOT found in the database), we raise\n     * an {@link com.webobjects.eoaccess.EOObjectNotAvailableException EOObjectNotAvailableException}. <br>\n     * If you have entities you don't really care about, you can set the system property\n     * <code>er.extensions.ERXDatabaseContextDelegate.tolerantEntityPattern<\/code> to a regular expression\n     * that will be tested against the GID entity name. If it matches, then only an error will be logged\n     * but no exception will be thrown.\n     * \n     * @param context database context\n     * @param object object that is firing the fault for a given to-one relationship\n     * @param gid global id that wasn't found in the database.\n     */\n    public boolean databaseContextFailedToFetchObject(EODatabaseContext context, Object object, EOGlobalID gid) {\n    \tString tolerantEntityPattern = ERXProperties.stringForKey(\"er.extensions.ERXDatabaseContextDelegate.tolerantEntityPattern\");\n    \tboolean raiseException = true;\n    \tif(tolerantEntityPattern != null && (gid instanceof EOKeyGlobalID)) {\n    \t\tif(((EOKeyGlobalID)gid).entityName().matches(tolerantEntityPattern)) {\n    \t\t\traiseException = false;\n    \t\t}\n    \t}\n        if (object!=null) {\n            EOEditingContext ec = ((EOEnterpriseObject)object).editingContext();\n\n            // we need to refault the object before raising, otherwise, if the caller traps\n            // the exception, it will be a successful lookup the next time a fault with the\n            // same global id fires.  NOTE: refaulting in a sharedEditingContext is illegal,\n            // so we specifically check for that special case.\n\n            if (!(ec instanceof EOSharedEditingContext) && raiseException) {\n                context.refaultObject((EOEnterpriseObject)object, gid, ec);\n            }\n        }\n        String gidString;\n        if(gid instanceof EOKeyGlobalID) {\n            // ak: when you use 24 byte PKs, the output is unreadable otherwise \n            EOKeyGlobalID kgid = (EOKeyGlobalID)gid;\n            gidString = \"<\" +  kgid.entityName() + \": [\" ;\n            EOEntity entity = ERXEOAccessUtilities.entityNamed(null, kgid.entityName());\n            NSArray pks = entity.primaryKeyAttributes();\n            NSArray values = kgid.keyValuesArray();\n            EOSQLExpressionFactory expressionFactory = context.database().adaptor().expressionFactory();\n            EOSQLExpression expression = null;\n            if (expressionFactory != null) {\n            \texpression = expressionFactory.expressionForEntity(entity);\n            }\n            for(int i = 0; i < pks.count(); i++) {\n                Object value = values.objectAtIndex(i);\n                EOAttribute attribute = (EOAttribute) pks.objectAtIndex(i);\n                // ak: only Postgres seems to return reasonable values here...\n                String stringValue = \"\" + value;\n                if (expression != null) {\n                \tstringValue = expression.formatValueForAttribute(value, attribute);\n                }\n                if(\"NULL\".equals(stringValue)) {\n                    stringValue = \"\" + value;\n                }\n                gidString += attribute.name() + \": \\'\" +  stringValue + \"\\'\"\n                + (i == pks.count() - 1 ? \"\" : \", \");\n            }\n            gidString += \"] >\";\n            \n        } else {\n            gidString = gid.toString();\n        }\n        NSNotificationCenter.defaultCenter().postNotification(DatabaseContextFailedToFetchObject, object);\n        if(raiseException) {\n        \tthrow new ObjectNotAvailableException(\"No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gidString, gid); \n        } else {\n        \tlog.error(\"No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gidString + \"\\n\" + ERXUtilities.stackTrace()); \n        }\n        return false;\n    }","commit_id":"3b5a88c4829ca89117dc6c842efc39d51507b2be","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * This is Kelly Hawks' fix for the missing to one relationship. \n     * Delegate on EODatabaseContext that gets called when a to-one fault cannot find its data in\n     * the database. The object that is returned is a cleared fault.\n     * We raise here to restore the functionality that existed prior to WebObjects 4.5.\n     * Whenever a fault fails for a globalID (i.e. the object is NOT found in the database), we raise\n     * an {@link com.webobjects.eoaccess.EOObjectNotAvailableException EOObjectNotAvailableException}.\n     * @param context database context\n     * @param object object that is firing the fault for a given to-one relationship\n     * @param gid global id that wasn't found in the database.\n     */\n    public boolean databaseContextFailedToFetchObject(EODatabaseContext context, Object object, EOGlobalID gid) {\n        if (object!=null) {\n            EOEditingContext ec = ((EOEnterpriseObject)object).editingContext();\n\n            // we need to refault the object before raising, otherwise, if the caller traps\n            // the exception, it will be a successful lookup the next time a fault with the\n            // same global id fires.  NOTE: refaulting in a sharedEditingContext is illegal,\n            // so we specifically check for that special case.\n\n            if (!(ec instanceof EOSharedEditingContext)) {\n                context.refaultObject((EOEnterpriseObject)object, gid, ec);\n            }\n        }\n        String gidString;\n        if(gid instanceof EOKeyGlobalID) {\n            // ak: when you use 24 byte PKs, the output is unreadable otherwise \n            EOKeyGlobalID kgid = (EOKeyGlobalID)gid;\n            gidString = \"<\" +  kgid.entityName() + \": [\" ;\n            EOEntity entity = ERXEOAccessUtilities.entityNamed(null, kgid.entityName());\n            NSArray pks = entity.primaryKeyAttributes();\n            NSArray values = kgid.keyValuesArray();\n            EOSQLExpression expression = context.database().adaptor().expressionFactory().expressionForEntity(entity);\n            for(int i = 0; i < pks.count(); i++) {\n                Object value = values.objectAtIndex(i);\n                EOAttribute attribute = (EOAttribute) pks.objectAtIndex(i);\n                gidString += attribute.name() + \": \\'\" +  expression.formatValueForAttribute(value, attribute) + \"\\'\"\n                + (i == pks.count() - 1 ? \"\" : \", \");\n            }\n            gidString += \"] >\";\n            \n        } else {\n            gidString = gid.toString();\n        }\n        throw new EOObjectNotAvailableException(\"No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gidString);            \n    }","id":38536,"modified_method":"/**\n     * This is Kelly Hawks' fix for the missing to one relationship. \n     * Delegate on EODatabaseContext that gets called when a to-one fault cannot find its data in\n     * the database. The object that is returned is a cleared fault.\n     * We raise here to restore the functionality that existed prior to WebObjects 4.5.\n     * Whenever a fault fails for a globalID (i.e. the object is NOT found in the database), we raise\n     * an {@link com.webobjects.eoaccess.EOObjectNotAvailableException EOObjectNotAvailableException}.\n     * @param context database context\n     * @param object object that is firing the fault for a given to-one relationship\n     * @param gid global id that wasn't found in the database.\n     */\n    public boolean databaseContextFailedToFetchObject(EODatabaseContext context, Object object, EOGlobalID gid) {\n        if (object!=null) {\n            EOEditingContext ec = ((EOEnterpriseObject)object).editingContext();\n\n            // we need to refault the object before raising, otherwise, if the caller traps\n            // the exception, it will be a successful lookup the next time a fault with the\n            // same global id fires.  NOTE: refaulting in a sharedEditingContext is illegal,\n            // so we specifically check for that special case.\n\n            if (!(ec instanceof EOSharedEditingContext)) {\n                context.refaultObject((EOEnterpriseObject)object, gid, ec);\n            }\n        }\n        String gidString;\n        if(gid instanceof EOKeyGlobalID) {\n            // ak: when you use 24 byte PKs, the output is unreadable otherwise \n            EOKeyGlobalID kgid = (EOKeyGlobalID)gid;\n            gidString = \"<\" +  kgid.entityName() + \": [\" ;\n            EOEntity entity = ERXEOAccessUtilities.entityNamed(null, kgid.entityName());\n            NSArray pks = entity.primaryKeyAttributes();\n            NSArray values = kgid.keyValuesArray();\n            EOSQLExpression expression = context.database().adaptor().expressionFactory().expressionForEntity(entity);\n            for(int i = 0; i < pks.count(); i++) {\n                Object value = values.objectAtIndex(i);\n                EOAttribute attribute = (EOAttribute) pks.objectAtIndex(i);\n                // ak: only Postgres seems to return reasonable values here...\n                String stringValue = expression.formatValueForAttribute(value, attribute);\n                if(\"NULL\".equals(stringValue)) {\n                    stringValue = \"\" + value;\n                }\n                gidString += attribute.name() + \": \\'\" +  stringValue + \"\\'\"\n                + (i == pks.count() - 1 ? \"\" : \", \");\n            }\n            gidString += \"] >\";\n            \n        } else {\n            gidString = gid.toString();\n        }\n        throw new EOObjectNotAvailableException(\"No \" + (object!=null ? object.getClass().getName() : \"N/A\") + \" found with globalID: \" + gidString);            \n    }","commit_id":"3e46c49dd751504e2c684ed525e1f983ab49e270","url":"https://github.com/wocommunity/wonder"},{"original_method":"public List<IConstructorLinkingCandidate> getLinkingCandidates(XConstructorCall constructorCall) {\n\t\tIConstructorLinkingCandidate result = resolvedTypes.getConstructor(constructorCall);\n\t\tif (result != null) {\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tEObject proxyOrResolved = (EObject) constructorCall.eGet(XbasePackage.Literals.XCONSTRUCTOR_CALL__CONSTRUCTOR, false);\n\t\tif (!proxyOrResolved.eIsProxy()) {\n\t\t\tresult = createResolvedLink(constructorCall, (JvmConstructor) proxyOrResolved);\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tIterable<IEObjectDescription> descriptions = reentrantTypeResolver.getScopeProviderAccess().getCandidateDescriptions(\n\t\t\t\tconstructorCall, XbasePackage.Literals.XCONSTRUCTOR_CALL__CONSTRUCTOR, proxyOrResolved, featureScopeSession, resolvedTypes);\n\t\tList<IConstructorLinkingCandidate> resultList = Lists.newArrayList();\n\t\tfor(IEObjectDescription description: descriptions) {\n\t\t\tresultList.add(createCandidate(constructorCall, toIdentifiableDescription(description)));\n\t\t}\n\t\tif (resultList.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"Linking candidates may not be empty\");\n\t\t}\n\t\treturn resultList;\n\t}","id":38537,"modified_method":"public List<IConstructorLinkingCandidate> getLinkingCandidates(XConstructorCall constructorCall) {\n\t\tIConstructorLinkingCandidate result = resolvedTypes.getConstructor(constructorCall);\n\t\tif (result != null) {\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tEObject proxyOrResolved = (EObject) constructorCall.eGet(XbasePackage.Literals.XCONSTRUCTOR_CALL__CONSTRUCTOR, false);\n\t\tif (proxyOrResolved == null) {\n\t\t\tresult = new NullLinkingCandidate(constructorCall);\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tif (!proxyOrResolved.eIsProxy()) {\n\t\t\tresult = createResolvedLink(constructorCall, (JvmConstructor) proxyOrResolved);\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tIterable<IEObjectDescription> descriptions = reentrantTypeResolver.getScopeProviderAccess().getCandidateDescriptions(\n\t\t\t\tconstructorCall, XbasePackage.Literals.XCONSTRUCTOR_CALL__CONSTRUCTOR, proxyOrResolved, featureScopeSession, resolvedTypes);\n\t\tList<IConstructorLinkingCandidate> resultList = Lists.newArrayList();\n\t\tfor(IEObjectDescription description: descriptions) {\n\t\t\tresultList.add(createCandidate(constructorCall, toIdentifiableDescription(description)));\n\t\t}\n\t\tif (resultList.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"Linking candidates may not be empty\");\n\t\t}\n\t\treturn resultList;\n\t}","commit_id":"0419c82c27fe9a29946f4901ba90da624af26228","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<IFeatureLinkingCandidate> getLinkingCandidates(XAbstractFeatureCall featureCall) {\n\t\tIFeatureLinkingCandidate result = resolvedTypes.getFeature(featureCall);\n\t\tif (result != null) {\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tEObject proxyOrResolved = (EObject) featureCall.eGet(XbasePackage.Literals.XABSTRACT_FEATURE_CALL__FEATURE, false);\n\t\tif (!proxyOrResolved.eIsProxy()) {\n\t\t\tresult = createResolvedLink(featureCall, (JvmIdentifiableElement) proxyOrResolved);\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tStackedResolvedTypes demandComputedTypes = resolvedTypes.pushTypes();\n\t\tfinal AbstractTypeComputationState forked = withNonVoidExpectation(demandComputedTypes);\n\t\tForwardingResolvedTypes demandResolvedTypes = new ForwardingResolvedTypes() {\n\t\t\t@Override\n\t\t\tprotected IResolvedTypes delegate() {\n\t\t\t\treturn forked.getResolvedTypes();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic LightweightTypeReference getActualType(XExpression expression) {\n\t\t\t\tLightweightTypeReference type = super.getActualType(expression);\n\t\t\t\tif (type == null) {\n\t\t\t\t\tITypeComputationResult result = forked.computeTypes(expression);\n\t\t\t\t\treturn result.getActualExpressionType();\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t}\n\t\t};\n\t\tIterable<IEObjectDescription> descriptions = reentrantTypeResolver.getScopeProviderAccess().getCandidateDescriptions(\n\t\t\t\tfeatureCall, XbasePackage.Literals.XABSTRACT_FEATURE_CALL__FEATURE, proxyOrResolved, featureScopeSession, demandResolvedTypes);\n\t\tList<IFeatureLinkingCandidate> resultList = Lists.newArrayList();\n\t\tfor(IEObjectDescription description: descriptions) {\n\t\t\tresultList.add(createCandidate(featureCall, demandComputedTypes, toIdentifiableDescription(description)));\n\t\t}\n\t\tif (resultList.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"Linking candidates may not be empty\");\n\t\t}\n\t\treturn resultList;\n\t}","id":38538,"modified_method":"public List<IFeatureLinkingCandidate> getLinkingCandidates(XAbstractFeatureCall featureCall) {\n\t\tIFeatureLinkingCandidate result = resolvedTypes.getFeature(featureCall);\n\t\tif (result != null) {\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tEObject proxyOrResolved = (EObject) featureCall.eGet(XbasePackage.Literals.XABSTRACT_FEATURE_CALL__FEATURE, false);\n\t\tif (proxyOrResolved == null) {\n\t\t\tresult = new NullLinkingCandidate(featureCall);\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tif (!proxyOrResolved.eIsProxy()) {\n\t\t\tresult = createResolvedLink(featureCall, (JvmIdentifiableElement) proxyOrResolved);\n\t\t\treturn Collections.singletonList(result);\n\t\t}\n\t\tStackedResolvedTypes demandComputedTypes = resolvedTypes.pushTypes();\n\t\tfinal AbstractTypeComputationState forked = withNonVoidExpectation(demandComputedTypes);\n\t\tForwardingResolvedTypes demandResolvedTypes = new ForwardingResolvedTypes() {\n\t\t\t@Override\n\t\t\tprotected IResolvedTypes delegate() {\n\t\t\t\treturn forked.getResolvedTypes();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic LightweightTypeReference getActualType(XExpression expression) {\n\t\t\t\tLightweightTypeReference type = super.getActualType(expression);\n\t\t\t\tif (type == null) {\n\t\t\t\t\tITypeComputationResult result = forked.computeTypes(expression);\n\t\t\t\t\treturn result.getActualExpressionType();\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t}\n\t\t};\n\t\tIterable<IEObjectDescription> descriptions = reentrantTypeResolver.getScopeProviderAccess().getCandidateDescriptions(\n\t\t\t\tfeatureCall, XbasePackage.Literals.XABSTRACT_FEATURE_CALL__FEATURE, proxyOrResolved, featureScopeSession, demandResolvedTypes);\n\t\tList<IFeatureLinkingCandidate> resultList = Lists.newArrayList();\n\t\tfor(IEObjectDescription description: descriptions) {\n\t\t\tresultList.add(createCandidate(featureCall, demandComputedTypes, toIdentifiableDescription(description)));\n\t\t}\n\t\tif (resultList.isEmpty()) {\n\t\t\tthrow new IllegalStateException(\"Linking candidates may not be empty\");\n\t\t}\n\t\treturn resultList;\n\t}","commit_id":"0419c82c27fe9a29946f4901ba90da624af26228","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void resolveArgumentType(XExpression argument, @Nullable LightweightTypeReference declaredType, ITypeComputationState argumentState) {\n\t\tif (argument == getSyntacticReceiver()) {\n\t\t\tLightweightTypeReference receiverType = getSyntacticReceiverType();\n\t\t\tif (receiverType == null) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot determine the receiver's type\");\n\t\t\t}\n\t\t\tresolveKnownArgumentType(argument, receiverType, declaredType, argumentState);\n\t\t} else if (argument == description.getImplicitFirstArgument()) {\n\t\t\tLightweightTypeReference argumentType = getImplicitFirstArgumentType();\n\t\t\tif (argumentType == null) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot determine the implicit argument's type\");\n\t\t\t}\n\t\t\tresolveKnownArgumentType(argument, argumentType, declaredType, argumentState);\n\t\t} else {\n\t\t\tsuper.resolveArgumentType(argument, declaredType, argumentState);\n\t\t}\n\t}","id":38539,"modified_method":"@Override\n\tprotected void resolveArgumentType(XExpression argument, @Nullable LightweightTypeReference declaredType, ITypeComputationState argumentState) {\n\t\tif (argument == getSyntacticReceiver()) {\n\t\t\tLightweightTypeReference receiverType = getSyntacticReceiverType();\n\t\t\tif (receiverType != null) {\n\t\t\t\tresolveKnownArgumentType(argument, receiverType, declaredType, argumentState);\n\t\t\t}\n\t\t} else if (argument == description.getImplicitFirstArgument()) {\n\t\t\tLightweightTypeReference argumentType = getImplicitFirstArgumentType();\n\t\t\tif (argumentType != null) {\n\t\t\t\tresolveKnownArgumentType(argument, argumentType, declaredType, argumentState);\n\t\t\t}\n\t\t} else {\n\t\t\tsuper.resolveArgumentType(argument, declaredType, argumentState);\n\t\t}\n\t}","commit_id":"0419c82c27fe9a29946f4901ba90da624af26228","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic JvmTypeReference getEquivalent() {\n\t\tif (equivalent == null) {\n\t\t\tIJvmTypeReferenceProvider provider = getTypeProvider();\n\t\t\tif (provider != null) {\n\t\t\t\tJvmTypeReference result = provider.getTypeReference(this);\n\t\t\t\tif (result != null && (result.eResource() != null || result.eContainer() != null)) {\n\t\t\t\t\tJvmDelegateTypeReference delegate = TypesFactory.eINSTANCE.createJvmDelegateTypeReference();\n\t\t\t\t\tdelegate.setDelegate(result);\n\t\t\t\t\tresult = delegate;\n\t\t\t\t}\n\t\t\t\tif (result != null) {\n\t\t\t\t\tboolean wasDeliver = eDeliver();\n\t\t\t\t\ttry {\n\t\t\t\t\t\teSetDeliver(false);\n\t\t\t\t\t\tsetEquivalent(result);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\teSetDeliver(wasDeliver);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tequivalent = null;\n\t\t\t}\n\t\t}\n\t\treturn equivalent;\n\t\t\n\t}","id":38540,"modified_method":"@Override\n\tpublic JvmTypeReference getEquivalent() {\n\t\tif (equivalent == null) {\n\t\t\tIJvmTypeReferenceProvider provider = getTypeProvider();\n\t\t\tif (provider != null) {\n\t\t\t\tJvmTypeReference result = provider.getTypeReference(this);\n\t\t\t\tif (equivalent == null || equivalent != result) {\n\t\t\t\t\tif (result != null && (result.eResource() != null || result.eContainer() != null)) {\n\t\t\t\t\t\tJvmDelegateTypeReference delegate = TypesFactory.eINSTANCE.createJvmDelegateTypeReference();\n\t\t\t\t\t\tdelegate.setDelegate(result);\n\t\t\t\t\t\tresult = delegate;\n\t\t\t\t\t}\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\tboolean wasDeliver = eDeliver();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\teSetDeliver(false);\n\t\t\t\t\t\t\tsetEquivalent(result);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\teSetDeliver(wasDeliver);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tequivalent = null;\n\t\t\t}\n\t\t}\n\t\treturn equivalent;\n\t\t\n\t}","commit_id":"0419c82c27fe9a29946f4901ba90da624af26228","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean hasSideEffects(XAbstractFeatureCall featureCall, boolean inspectContents) {\n\t\tif (featureCall instanceof XAssignment) {\n\t\t\treturn true;\n\t\t}\n\t\tfinal JvmIdentifiableElement feature = featureCall.getFeature();\n\t\tif (feature.eIsProxy())\n\t\t\treturn true; // linking problems ... could be anything\n\t\tif (feature instanceof JvmConstructor) { //super() and this()\n\t\t\treturn true;\n\t\t}\n\t\tif (feature instanceof JvmOperation) {\n\t\t\tJvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\tif (findPureAnnotation(jvmOperation) == null) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif(inspectContents) {\n\t\t\t\t\tfor (XExpression param : featureCall.getActualArguments()) {\n\t\t\t\t\t\tif (hasSideEffects(param))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":38541,"modified_method":"public boolean hasSideEffects(XAbstractFeatureCall featureCall, boolean inspectContents) {\n\t\tif (featureCall instanceof XAssignment) {\n\t\t\treturn true;\n\t\t}\n\t\tfinal JvmIdentifiableElement feature = featureCall.getFeature();\n\t\tif (feature == null || feature.eIsProxy())\n\t\t\treturn true; // linking problems ... could be anything\n\t\tif (feature instanceof JvmConstructor) { //super() and this()\n\t\t\treturn true;\n\t\t}\n\t\tif (feature instanceof JvmOperation) {\n\t\t\tJvmOperation jvmOperation = (JvmOperation) feature;\n\t\t\tif (findPureAnnotation(jvmOperation) == null) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif(inspectContents) {\n\t\t\t\t\tfor (XExpression param : featureCall.getActualArguments()) {\n\t\t\t\t\t\tif (hasSideEffects(param))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"0419c82c27fe9a29946f4901ba90da624af26228","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic ITypeArgumentContext getTypeArgumentContext(XAbstractFeatureCall featureCall,\n\t\t\tList<XExpression> actualArguments, Provider<JvmTypeReference> receiverTypeProvider,\n\t\t\tJvmIdentifiableElement feature) {\n\t\tthrow new UnsupportedOperationException();\n\t}","id":38542,"modified_method":"@Override\n\tpublic ITypeArgumentContext getTypeArgumentContext(XAbstractFeatureCall featureCall,\n\t\t\tList<XExpression> actualArguments, Provider<JvmTypeReference> receiverTypeProvider,\n\t\t\tJvmIdentifiableElement feature) {\n\t\treturn null;\n\t}","commit_id":"0419c82c27fe9a29946f4901ba90da624af26228","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic JvmTypeReference getType(XExpression expression, boolean rawType) {\n\t\treturn getResolvedTypes(expression).getActualType(expression).toTypeReference();\n\t}","id":38543,"modified_method":"@Override\n\tpublic JvmTypeReference getType(XExpression expression, boolean rawType) {\n\t\tLightweightTypeReference actualType = getResolvedTypes(expression).getActualType(expression);\n\t\tif (actualType == null)\n\t\t\treturn null;\n\t\treturn actualType.toTypeReference();\n\t}","commit_id":"0419c82c27fe9a29946f4901ba90da624af26228","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void convertFunctionType(JvmTypeReference expectedType, final JvmTypeReference functionType,\n\t\t\tITreeAppendable appendable, Later expression, XExpression context) {\n\t\tif (expectedType.getIdentifier().equals(Object.class.getName())\n\t\t\t\t|| EcoreUtil.equals(expectedType.getType(), functionType.getType())\n\t\t\t\t|| ((expectedType instanceof JvmSynonymTypeReference) \n\t\t\t\t\t&& Iterables.any(((JvmSynonymTypeReference)expectedType).getReferences(), new Predicate<JvmTypeReference>() {\n\t\t\t\t\t\tpublic boolean apply(@Nullable JvmTypeReference ref) {\n\t\t\t\t\t\t\treturn EcoreUtil.equals(ref.getType(), functionType.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t}))) {\n\t\t\t// same raw type but different type parameters\n\t\t\t// at this point we know that we are compatible so we have to convince the Java compiler about that ;-)\n\t\t\tif (!getTypeConformanceComputer().isConformant(expectedType, functionType)) {\n\t\t\t\t// insert a cast\n\t\t\t\tappendable.append(\"(\");\n\t\t\t\tserialize(expectedType, context, appendable);\n\t\t\t\tappendable.append(\")\");\n\t\t\t}\n\t\t\texpression.exec(appendable);\n\t\t\treturn;\n\t\t}\n\t\tJvmOperation operation = getClosures().findImplementingOperation(expectedType, context.eResource());\n\t\tif (operation == null) {\n\t\t\tthrow new IllegalStateException(\"expected type \" + expectedType + \" not mappable from \" + functionType);\n\t\t}\n\t\tappendable.append(\"new \");\n\t\tStandardTypeReferenceOwner owner = new StandardTypeReferenceOwner(services, context.eResource().getResourceSet());\n\t\tLightweightTypeReference lightweightExpectedType = new OwnedConverter(owner).toLightweightReference(expectedType);\n\t\tFunctionTypeReference functionTypeReference = lightweightExpectedType.tryConvertToFunctionTypeReference(false);\n\t\tif (functionTypeReference == null)\n\t\t\tthrow new IllegalStateException(\"Expected type does not seem to be a SAM type\");\n\t\tJvmTypeReference convertedExpectedType = functionTypeReference.toInstanceTypeReference().toTypeReference();\n\t\tserialize(convertedExpectedType, context, appendable, false, false);\n\t\tappendable.append(\"() {\");\n\t\tappendable.increaseIndentation().increaseIndentation();\n\t\tappendable.newLine().append(\"public \");\n\t\tLightweightTypeReference returnType = functionTypeReference.getReturnType();\n\t\tif (returnType == null)\n\t\t\tthrow new IllegalStateException(\"Could not find return type\");\n\t\tserialize(returnType.toTypeReference(), context, appendable, false, false);\n\t\tappendable.append(\" \").append(operation.getSimpleName()).append(\"(\");\n\t\tList<JvmFormalParameter> params = operation.getParameters();\n\t\tfor (int i = 0; i < params.size(); i++) {\n\t\t\tif (i != 0)\n\t\t\t\tappendable.append(\",\");\n\t\t\tJvmFormalParameter p = params.get(i);\n\t\t\tfinal String name = p.getName();\n\t\t\tserialize(functionTypeReference.getParameterTypes().get(i).toTypeReference(), context, appendable, false, false);\n\t\t\tappendable.append(\" \").append(name);\n\t\t}\n\t\tappendable.append(\") {\");\n\t\tappendable.increaseIndentation();\n\t\tif (!getTypeReferences().is(operation.getReturnType(), Void.TYPE))\n\t\t\tappendable.newLine().append(\"return \");\n\t\telse\n\t\t\tappendable.newLine();\n\t\texpression.exec(appendable);\n\t\tappendable.append(\".\");\n\t\tJvmOperation actualOperation = getClosures().findImplementingOperation(functionType, context.eResource());\n\t\tappendable.append(actualOperation.getSimpleName());\n\t\tappendable.append(\"(\");\n\t\tfor (Iterator<JvmFormalParameter> iterator = params.iterator(); iterator.hasNext();) {\n\t\t\tJvmFormalParameter p = iterator.next();\n\t\t\tfinal String name = p.getName();\n\t\t\tappendable.append(name);\n\t\t\tif (iterator.hasNext())\n\t\t\t\tappendable.append(\",\");\n\t\t}\n\t\tappendable.append(\");\");\n\t\tappendable.decreaseIndentation();\n\t\tappendable.newLine().append(\"}\");\n\t\tappendable.decreaseIndentation().decreaseIndentation();\n\t\tappendable.newLine().append(\"}\");\n\t}","id":38544,"modified_method":"@Override\n\tprotected void convertFunctionType(JvmTypeReference expectedType, final JvmTypeReference functionType,\n\t\t\tITreeAppendable appendable, Later expression, XExpression context) {\n\t\tif (expectedType.getIdentifier().equals(Object.class.getName())\n\t\t\t\t|| EcoreUtil.equals(expectedType.getType(), functionType.getType())\n\t\t\t\t|| ((expectedType instanceof JvmSynonymTypeReference) \n\t\t\t\t\t&& Iterables.any(((JvmSynonymTypeReference)expectedType).getReferences(), new Predicate<JvmTypeReference>() {\n\t\t\t\t\t\tpublic boolean apply(@Nullable JvmTypeReference ref) {\n\t\t\t\t\t\t\tif (ref == null) {\n\t\t\t\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn EcoreUtil.equals(ref.getType(), functionType.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t}))) {\n\t\t\t// same raw type but different type parameters\n\t\t\t// at this point we know that we are compatible so we have to convince the Java compiler about that ;-)\n\t\t\tif (!getTypeConformanceComputer().isConformant(expectedType, functionType)) {\n\t\t\t\t// insert a cast\n\t\t\t\tappendable.append(\"(\");\n\t\t\t\tserialize(expectedType, context, appendable);\n\t\t\t\tappendable.append(\")\");\n\t\t\t}\n\t\t\texpression.exec(appendable);\n\t\t\treturn;\n\t\t}\n\t\tJvmOperation operation = getClosures().findImplementingOperation(expectedType, context.eResource());\n\t\tif (operation == null) {\n\t\t\tthrow new IllegalStateException(\"expected type \" + expectedType + \" not mappable from \" + functionType);\n\t\t}\n\t\tappendable.append(\"new \");\n\t\tStandardTypeReferenceOwner owner = new StandardTypeReferenceOwner(services, context.eResource().getResourceSet());\n\t\tLightweightTypeReference lightweightExpectedType = new OwnedConverter(owner).toLightweightReference(expectedType);\n\t\tFunctionTypeReference functionTypeReference = lightweightExpectedType.tryConvertToFunctionTypeReference(false);\n\t\tif (functionTypeReference == null)\n\t\t\tthrow new IllegalStateException(\"Expected type does not seem to be a SAM type\");\n\t\tJvmTypeReference convertedExpectedType = functionTypeReference.toInstanceTypeReference().toTypeReference();\n\t\tserialize(convertedExpectedType, context, appendable, false, false);\n\t\tappendable.append(\"() {\");\n\t\tappendable.increaseIndentation().increaseIndentation();\n\t\tappendable.newLine().append(\"public \");\n\t\tLightweightTypeReference returnType = functionTypeReference.getReturnType();\n\t\tif (returnType == null)\n\t\t\tthrow new IllegalStateException(\"Could not find return type\");\n\t\tserialize(returnType.toTypeReference(), context, appendable, false, false);\n\t\tappendable.append(\" \").append(operation.getSimpleName()).append(\"(\");\n\t\tList<JvmFormalParameter> params = operation.getParameters();\n\t\tfor (int i = 0; i < params.size(); i++) {\n\t\t\tif (i != 0)\n\t\t\t\tappendable.append(\",\");\n\t\t\tJvmFormalParameter p = params.get(i);\n\t\t\tfinal String name = p.getName();\n\t\t\tserialize(functionTypeReference.getParameterTypes().get(i).toTypeReference(), context, appendable, false, false);\n\t\t\tappendable.append(\" \").append(name);\n\t\t}\n\t\tappendable.append(\") {\");\n\t\tappendable.increaseIndentation();\n\t\tif (!getTypeReferences().is(operation.getReturnType(), Void.TYPE))\n\t\t\tappendable.newLine().append(\"return \");\n\t\telse\n\t\t\tappendable.newLine();\n\t\texpression.exec(appendable);\n\t\tappendable.append(\".\");\n\t\tJvmOperation actualOperation = getClosures().findImplementingOperation(functionType, context.eResource());\n\t\tappendable.append(actualOperation.getSimpleName());\n\t\tappendable.append(\"(\");\n\t\tfor (Iterator<JvmFormalParameter> iterator = params.iterator(); iterator.hasNext();) {\n\t\t\tJvmFormalParameter p = iterator.next();\n\t\t\tfinal String name = p.getName();\n\t\t\tappendable.append(name);\n\t\t\tif (iterator.hasNext())\n\t\t\t\tappendable.append(\",\");\n\t\t}\n\t\tappendable.append(\");\");\n\t\tappendable.decreaseIndentation();\n\t\tappendable.newLine().append(\"}\");\n\t\tappendable.decreaseIndentation().decreaseIndentation();\n\t\tappendable.newLine().append(\"}\");\n\t}","commit_id":"69589b41724a9597d4364a24bfcecca909821c68","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void computeTypes(XAnnotation annotation, JvmOperation operation, XExpression value,\n\t\t\tITypeComputationState state) {\n\t\tLightweightTypeReference expectation = operation.eIsProxy() ? null : state.getConverter().toLightweightReference(operation.getReturnType());\n\t\tif (expectation != null && expectation.isArray()) {\n\t\t\tLightweightTypeReference componentType = expectation.getComponentType();\n\t\t\tif (componentType == null) {\n\t\t\t\tthrow new IllegalStateException(\"Array without component type: \" + operation.getReturnType());\n\t\t\t}\n\t\t\tITypeComputationResult result = state.withExpectation(componentType).computeTypes(value);\n\t\t\tif (!result.getConformanceHints().contains(ConformanceHint.SUCCESS)) {\n\t\t\t\tif (value instanceof XAnnotationValueArray) {\n\t\t\t\t\t// our children are incompatible so let's mark the array itself as compatible.\n\t\t\t\t\tstate.refineExpectedType(value, result.getActualExpressionType());\n\t\t\t\t} else {\n\t\t\t\t\tCompoundTypeReference bothExpectations = new CompoundTypeReference(state.getReferenceOwner(), true);\n\t\t\t\t\tbothExpectations.addComponent(componentType);\n\t\t\t\t\tbothExpectations.addComponent(expectation);\n\t\t\t\t\tstate.refineExpectedType(value, bothExpectations);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (expectation == null) {\n\t\t\tstate.withNonVoidExpectation().computeTypes(value);\n\t\t} else {\n\t\t\tITypeComputationResult valueType = state.withExpectation(expectation).computeTypes(value);\n\t\t\tif (valueType.getConformanceHints().contains(ConformanceHint.SUCCESS)) {\n\t\t\t\tif (value instanceof XAnnotationValueArray) {\n\t\t\t\t\tString simpleName = valueType.getActualExpressionType().getSimpleName();\n\t\t\t\t\tstate.addDiagnostic(new EObjectDiagnosticImpl(\n\t\t\t\t\t\t\tSeverity.ERROR, \n\t\t\t\t\t\t\tIssueCodes.INCOMPATIBLE_TYPES, \n\t\t\t\t\t\t\t\"Type mismatch: cannot convert from \" + simpleName + \"[] to \" + simpleName, \n\t\t\t\t\t\t\tannotation, \n\t\t\t\t\t\t\tXAnnotationsPackage.Literals.XANNOTATION__VALUE, \n\t\t\t\t\t\t\t-1, null));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":38545,"modified_method":"protected void computeTypes(XAnnotation annotation, JvmOperation operation, XExpression value,\n\t\t\tITypeComputationState state) {\n\t\tLightweightTypeReference expectation = operation == null || operation.eIsProxy() ? null : state.getConverter().toLightweightReference(operation.getReturnType());\n\t\tif (expectation != null && expectation.isArray()) {\n\t\t\tLightweightTypeReference componentType = expectation.getComponentType();\n\t\t\tif (componentType == null) {\n\t\t\t\tthrow new IllegalStateException(\"Array without component type: \" + operation.getReturnType());\n\t\t\t}\n\t\t\tITypeComputationResult result = state.withExpectation(componentType).computeTypes(value);\n\t\t\tif (!result.getConformanceHints().contains(ConformanceHint.SUCCESS)) {\n\t\t\t\tif (value instanceof XAnnotationValueArray) {\n\t\t\t\t\t// our children are incompatible so let's mark the array itself as compatible.\n\t\t\t\t\tstate.refineExpectedType(value, result.getActualExpressionType());\n\t\t\t\t} else {\n\t\t\t\t\tCompoundTypeReference bothExpectations = new CompoundTypeReference(state.getReferenceOwner(), true);\n\t\t\t\t\tbothExpectations.addComponent(componentType);\n\t\t\t\t\tbothExpectations.addComponent(expectation);\n\t\t\t\t\tstate.refineExpectedType(value, bothExpectations);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (expectation == null) {\n\t\t\tstate.withNonVoidExpectation().computeTypes(value);\n\t\t} else {\n\t\t\tITypeComputationResult valueType = state.withExpectation(expectation).computeTypes(value);\n\t\t\tif (valueType.getConformanceHints().contains(ConformanceHint.SUCCESS)) {\n\t\t\t\tif (value instanceof XAnnotationValueArray) {\n\t\t\t\t\tString simpleName = valueType.getActualExpressionType().getSimpleName();\n\t\t\t\t\tstate.addDiagnostic(new EObjectDiagnosticImpl(\n\t\t\t\t\t\t\tSeverity.ERROR, \n\t\t\t\t\t\t\tIssueCodes.INCOMPATIBLE_TYPES, \n\t\t\t\t\t\t\t\"Type mismatch: cannot convert from \" + simpleName + \"[] to \" + simpleName, \n\t\t\t\t\t\t\tannotation, \n\t\t\t\t\t\t\tXAnnotationsPackage.Literals.XANNOTATION__VALUE, \n\t\t\t\t\t\t\t-1, null));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"69589b41724a9597d4364a24bfcecca909821c68","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected XtextBrowserInformationControlInput getHoverInfo(EObject element, IRegion hoverRegion,\n\t\t\tXtextBrowserInformationControlInput previous) {\n\t\tEObject objectToView = getObjectToView(element);\n\t\tif(objectToView.eIsProxy())\n\t\t\treturn null;\n\t\tIJavaElement javaElement = null;\n\t\tif (objectToView != element && objectToView instanceof JvmIdentifiableElement) {\n\t\t\tjavaElement = javaElementFinder.findElementFor((JvmIdentifiableElement) objectToView);\n\t\t}\n\t\tString html = getHoverInfoAsHtml(element, objectToView, hoverRegion);\n\t\tif (html != null) {\n\t\t\tStringBuffer buffer = new StringBuffer(html);\n\t\t\tHTMLPrinter.insertPageProlog(buffer, 0, getStyleSheet());\n\t\t\tHTMLPrinter.addPageEpilog(buffer);\n\t\t\thtml = buffer.toString();\n\t\t\treturn new XbaseInformationControlInput(previous, objectToView, javaElement, html, labelProvider);\n\t\t}\n\t\treturn null;\n\t}","id":38546,"modified_method":"@Override\n\tprotected XtextBrowserInformationControlInput getHoverInfo(EObject element, IRegion hoverRegion,\n\t\t\tXtextBrowserInformationControlInput previous) {\n\t\tEObject objectToView = getObjectToView(element);\n\t\tif(objectToView == null || objectToView.eIsProxy())\n\t\t\treturn null;\n\t\tIJavaElement javaElement = null;\n\t\tif (objectToView != element && objectToView instanceof JvmIdentifiableElement) {\n\t\t\tjavaElement = javaElementFinder.findElementFor((JvmIdentifiableElement) objectToView);\n\t\t}\n\t\tString html = getHoverInfoAsHtml(element, objectToView, hoverRegion);\n\t\tif (html != null) {\n\t\t\tStringBuffer buffer = new StringBuffer(html);\n\t\t\tHTMLPrinter.insertPageProlog(buffer, 0, getStyleSheet());\n\t\t\tHTMLPrinter.addPageEpilog(buffer);\n\t\t\thtml = buffer.toString();\n\t\t\treturn new XbaseInformationControlInput(previous, objectToView, javaElement, html, labelProvider);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"f45b3e7ad10b9eccafde8b046bbd3c7f14779c0a","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * Computes the effective type of the modified type.\n     */\n    @Override\n    public void enter(NodeState before, NodeState after)\n            throws CommitFailedException {\n        if (after.getProperty(JCR_PRIMARYTYPE) == null && node != null) {\n            node.setProperty(JCR_PRIMARYTYPE, defaultType, Type.NAME);\n        }\n        computeEffectiveType(after);\n\n        // find matching entry in the parent node's effective type\n        // TODO: this should be in childNodeAdded()\n        if (parent != null && parent.effective.getDefinition(\n                nodeName, effective.getTypeNames()) == null) {\n            throw constraintViolation(\n                    1, \"Incorrect node type of child node \" + nodeName);\n        }\n    }","id":38547,"modified_method":"/**\n     * Computes the effective type of the modified type.\n     */\n    @Override\n    public void enter(NodeState before, NodeState after)\n            throws CommitFailedException {\n        if (after.getProperty(JCR_PRIMARYTYPE) == null && node != null) {\n            node.setProperty(JCR_PRIMARYTYPE, defaultType, Type.NAME);\n        }\n        computeEffectiveType(after);\n\n        // find matching entry in the parent node's effective type\n        // TODO: this should be in childNodeAdded()\n        if (parent != null && parent.effective.getDefinition(\n                nodeName, effective.getTypeNames()) == null) {\n            Set<String> parentTypes = parent.effective.getTypeNames();\n            throw constraintViolation(\n                    1, \"No matching child node definition found for child node \"\n                    + nodeName + \" in any of the parent types \" + parentTypes);\n        }\n    }","commit_id":"2c8df739651a40109d307807e1a276c06beb3c69","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private CommitFailedException constraintViolation(int code, String message) {\n        return new CommitFailedException(\n                CONSTRAINT, code, getPath() + \": \" + message + \" \" + typeNames);\n    }","id":38548,"modified_method":"private CommitFailedException constraintViolation(int code, String message) {\n        return new CommitFailedException(\n                CONSTRAINT, code, getPath() + typeNames + \": \" + message);\n    }","commit_id":"2c8df739651a40109d307807e1a276c06beb3c69","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Copies the full content from the source to the target repository.\n     * <p>\n     * The source repository <strong>must not be modified<\/strong> while\n     * the copy operation is running to avoid an inconsistent copy.\n     * <p>\n     * This method leaves the search indexes of the target repository in\n     * an \n     * Note that both the source and the target repository must be closed\n     * during the copy operation as this method requires exclusive access\n     * to the repositories.\n     *\n     * @throws RepositoryException if the copy operation fails\n     */\n    public void copy() throws RepositoryException {\n        RepositoryConfig config = source.getRepositoryConfig();\n        logger.info(\n                \"Copying repository content from {} to Oak\", config.getHomeDir());\n        try {\n            NodeBuilder builder = target.getRoot().builder();\n\n            // init target repository first\n            new InitialContent().initialize(builder);\n\n            Map<String, String> uriToPrefix = newHashMap();\n            Map<Integer, String> idxToPrefix = newHashMap();\n            copyNamespaces(builder, uriToPrefix, idxToPrefix);\n            copyNodeTypes(builder);\n            copyPrivileges(builder);\n            copyVersionStore(builder, uriToPrefix, idxToPrefix);\n            copyWorkspaces(builder, uriToPrefix, idxToPrefix);\n\n            String groupsPath;\n            UserManagerConfig userConfig = config.getSecurityConfig().getSecurityManagerConfig().getUserManagerConfig();\n            if (userConfig != null) {\n                groupsPath = userConfig.getParameters().getProperty(UserManagerImpl.PARAM_GROUPS_PATH, UserConstants.DEFAULT_GROUP_PATH);\n            } else {\n                groupsPath = UserConstants.DEFAULT_GROUP_PATH;\n            }\n            // TODO: default hooks?\n            CommitHook hook = new CompositeHook(\n                    new EditorHook(new GroupEditorProvider(groupsPath)),\n                    new EditorHook(new CompositeEditorProvider(\n                            new TypeEditorProvider(),\n                            new IndexUpdateProvider(new CompositeIndexEditorProvider(\n                                    new ReferenceEditorProvider(),\n                                    new PropertyIndexEditorProvider())))));\n            target.merge(builder, hook, CommitInfo.EMPTY);\n        } catch (Exception e) {\n            throw new RepositoryException(\"Failed to copy content\", e);\n        }\n    }","id":38549,"modified_method":"/**\n     * Copies the full content from the source to the target repository.\n     * <p>\n     * The source repository <strong>must not be modified<\/strong> while\n     * the copy operation is running to avoid an inconsistent copy.\n     * <p>\n     * This method leaves the search indexes of the target repository in\n     * an \n     * Note that both the source and the target repository must be closed\n     * during the copy operation as this method requires exclusive access\n     * to the repositories.\n     *\n     * @throws RepositoryException if the copy operation fails\n     */\n    public void copy() throws RepositoryException {\n        RepositoryConfig config = source.getRepositoryConfig();\n        logger.info(\n                \"Copying repository content from {} to Oak\", config.getHomeDir());\n        try {\n            NodeBuilder builder = target.getRoot().builder();\n\n            // init target repository first\n            new InitialContent().initialize(builder);\n\n            Map<String, String> uriToPrefix = newHashMap();\n            Map<Integer, String> idxToPrefix = newHashMap();\n            copyNamespaces(builder, uriToPrefix, idxToPrefix);\n            copyNodeTypes(builder);\n            copyPrivileges(builder);\n            copyVersionStore(builder, uriToPrefix, idxToPrefix);\n            copyWorkspaces(builder, uriToPrefix, idxToPrefix);\n\n            String groupsPath;\n            UserManagerConfig userConfig = config.getSecurityConfig().getSecurityManagerConfig().getUserManagerConfig();\n            if (userConfig != null) {\n                groupsPath = userConfig.getParameters().getProperty(UserManagerImpl.PARAM_GROUPS_PATH, UserConstants.DEFAULT_GROUP_PATH);\n            } else {\n                groupsPath = UserConstants.DEFAULT_GROUP_PATH;\n            }\n            // TODO: default hooks?\n            CommitHook hook = new CompositeHook(\n                    new EditorHook(new GroupEditorProvider(groupsPath)),\n                    new EditorHook(new CompositeEditorProvider(\n                            new TypeEditorProvider(false),\n                            new IndexUpdateProvider(new CompositeIndexEditorProvider(\n                                    new ReferenceEditorProvider(),\n                                    new PropertyIndexEditorProvider())))));\n            target.merge(builder, hook, CommitInfo.EMPTY);\n        } catch (Exception e) {\n            throw new RepositoryException(\"Failed to copy content\", e);\n        }\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public TypeEditor childNodeChanged(\n            String name, NodeState before, NodeState after)\n            throws CommitFailedException {\n        String primary = after.getName(JCR_PRIMARYTYPE);\n        Iterable<String> mixins = after.getNames(JCR_MIXINTYPES);\n\n        NodeBuilder childBuilder = builder.getChildNode(name);\n        if (primary == null) {\n            // no primary type defined, find and apply a default type\n            primary = effective.getDefaultType(name);\n            if (primary != null) {\n                builder.setProperty(JCR_PRIMARYTYPE, primary, NAME);\n            } else {\n                throw constraintViolation(\n                        4, \"No default primary type available \"\n                        + \" for child node \" + name);\n            }\n        }\n\n        TypeEditor editor =\n                new TypeEditor(this, name, primary, mixins, childBuilder);\n        if (!effective.isValidChildNode(name, editor.effective)) {\n            throw constraintViolation(\n                    1, \"No matching definition found for child node \" + name\n                    + \" with effective type \" + editor.effective);\n        }\n\n        return editor;\n    }","id":38550,"modified_method":"@Override\n    public TypeEditor childNodeChanged(\n            String name, NodeState before, NodeState after)\n            throws CommitFailedException {\n        String primary = after.getName(JCR_PRIMARYTYPE);\n        Iterable<String> mixins = after.getNames(JCR_MIXINTYPES);\n\n        NodeBuilder childBuilder = builder.getChildNode(name);\n        if (primary == null) {\n            // no primary type defined, find and apply a default type\n            primary = effective.getDefaultType(name);\n            if (primary != null) {\n                builder.setProperty(JCR_PRIMARYTYPE, primary, NAME);\n            } else {\n                constraintViolation(\n                        4, \"No default primary type available \"\n                        + \" for child node \" + name);\n            }\n        }\n\n        TypeEditor editor =\n                new TypeEditor(this, name, primary, mixins, childBuilder);\n        if (!effective.isValidChildNode(name, editor.effective)) {\n            constraintViolation(\n                    1, \"No matching definition found for child node \" + name\n                    + \" with effective type \" + editor.effective);\n        }\n\n        return editor;\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Editor childNodeAdded(String name, NodeState after)\n            throws CommitFailedException {\n        TypeEditor editor = childNodeChanged(name, MISSING_NODE, after);\n\n        // TODO: add any auto-created items that are still missing\n\n        // verify the presence of all mandatory items\n        for (String property : editor.effective.getMandatoryProperties()) {\n            if (!after.hasProperty(property)) {\n                throw editor.constraintViolation(\n                        21, \"Mandatory property \" + property\n                        + \" not found in a new node\");\n            }\n        }\n        for (String child : editor.effective.getMandatoryChildNodes()) {\n            if (!after.hasChildNode(child)) {\n                throw editor.constraintViolation(\n                        25, \"Mandatory child node \" + child\n                        + \" not found in a new node\");\n            }\n        }\n\n        return editor;\n    }","id":38551,"modified_method":"@Override\n    public Editor childNodeAdded(String name, NodeState after)\n            throws CommitFailedException {\n        TypeEditor editor = childNodeChanged(name, MISSING_NODE, after);\n\n        // TODO: add any auto-created items that are still missing\n\n        // verify the presence of all mandatory items\n        for (String property : editor.effective.getMandatoryProperties()) {\n            if (!after.hasProperty(property)) {\n                editor.constraintViolation(\n                        21, \"Mandatory property \" + property\n                        + \" not found in a new node\");\n            }\n        }\n        for (String child : editor.effective.getMandatoryChildNodes()) {\n            if (!after.hasChildNode(child)) {\n                editor.constraintViolation(\n                        25, \"Mandatory child node \" + child\n                        + \" not found in a new node\");\n            }\n        }\n\n        return editor;\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private CommitFailedException constraintViolation(\n            int code, String message) {\n        if (effective != null) {\n            return effective.constraintViolation(code, getPath(), message);\n        } else {\n            return new CommitFailedException(\n                    CONSTRAINT, 0, getPath() + \": \" + message);\n        }\n    }","id":38552,"modified_method":"/**\n     * Throws or logs the specified constraint violation.\n     *\n     * @param code code of this violation\n     * @param message description of the violation\n     * @throws CommitFailedException the constraint violation\n     */\n    private void constraintViolation(int code, String message)\n            throws CommitFailedException {\n        String path = getPath();\n        if (effective != null) {\n            path = path + \"[\" + effective + \"]\";\n        }\n        CommitFailedException exception = new CommitFailedException(\n                CONSTRAINT, code, path + \": \" + message);\n        if (strict) {\n            throw exception;\n        } else {\n            log.warn(exception.getMessage());\n        }\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"TypeEditor(\n            NodeState types,\n            String primary, Iterable<String> mixins, NodeBuilder builder)\n            throws CommitFailedException {\n        this.parent = null;\n        this.nodeName = null;\n        this.types = checkNotNull(types);\n        this.effective = getEffectiveType(null, null, primary, mixins);\n        this.builder = checkNotNull(builder);\n    }","id":38553,"modified_method":"TypeEditor(\n            boolean strict, NodeState types,\n            String primary, Iterable<String> mixins, NodeBuilder builder)\n            throws CommitFailedException {\n        this.strict = strict;\n        this.parent = null;\n        this.nodeName = null;\n        this.types = checkNotNull(types);\n        this.effective = getEffectiveType(null, null, primary, mixins);\n        this.builder = checkNotNull(builder);\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Editor childNodeDeleted(String name, NodeState before)\n            throws CommitFailedException {\n        if (effective.isMandatoryChildNode(name)) {\n            throw constraintViolation(\n                     26, \"Mandatory child node \" + name + \" can not be removed\");\n        } else {\n            return null; // no further checking needed for the removed subtree\n        }\n    }","id":38554,"modified_method":"@Override\n    public Editor childNodeDeleted(String name, NodeState before)\n            throws CommitFailedException {\n        if (effective.isMandatoryChildNode(name)) {\n            constraintViolation(\n                     26, \"Mandatory child node \" + name + \" can not be removed\");\n        }\n        return null; // no further checking needed for the removed subtree\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private EffectiveType getEffectiveType(\n            EffectiveType parent, String name,\n            String primary, Iterable<String> mixins)\n            throws CommitFailedException {\n        List<NodeState> list = Lists.newArrayList();\n\n        NodeState type = types.getChildNode(primary);\n        if (!type.exists()) {\n            throw constraintViolation(\n                    1, \"The primary type \" + primary + \" does not exist\");\n        } else if (type.getBoolean(JCR_ISMIXIN)) {\n            throw constraintViolation(\n                    2, \"Mixin type \" + primary + \" used as the primary type\");\n        } else {\n            if (type.getBoolean(JCR_IS_ABSTRACT)) {\n                if (parent != null && primary.equals(parent.getDefaultType(name))) {\n                    // OAK-1013: Allow (with a warning) an abstract primary\n                    // type if it's the default type implied by the parent node\n                    log.warn(\"Abstract type \" + primary\n                            + \" used as the default primary type of node \"\n                            + getPath());\n                } else {\n                    throw constraintViolation(\n                            2, \"Abstract type \" + primary + \" used as the primary type\");\n                }\n            }\n            list.add(type);\n        }\n\n        // mixin types\n        for (String mixin : mixins) {\n            type = types.getChildNode(mixin);\n            if (!type.exists()) {\n                throw constraintViolation(\n                        5, \"The mixin type \" + mixin + \" does not exist\");\n            } else if (!type.getBoolean(JCR_ISMIXIN)) {\n                throw constraintViolation(\n                        6, \"Primary type \" + mixin + \" used as a mixin type\");\n            } else if (type.getBoolean(JCR_IS_ABSTRACT)) {\n                throw constraintViolation(\n                        7, \"Abstract type \" + mixin + \" used as a mixin type\");\n            } else {\n                list.add(type);\n            }\n        }\n\n        return new EffectiveType(list);\n    }","id":38555,"modified_method":"private EffectiveType getEffectiveType(\n            EffectiveType parent, String name,\n            String primary, Iterable<String> mixins)\n            throws CommitFailedException {\n        List<NodeState> list = Lists.newArrayList();\n\n        NodeState type = types.getChildNode(primary);\n        if (!type.exists()) {\n            constraintViolation(\n                    1, \"The primary type \" + primary + \" does not exist\");\n        } else if (type.getBoolean(JCR_ISMIXIN)) {\n            constraintViolation(\n                    2, \"Mixin type \" + primary + \" used as the primary type\");\n        } else {\n            if (type.getBoolean(JCR_IS_ABSTRACT)) {\n                if (parent != null && primary.equals(parent.getDefaultType(name))) {\n                    // OAK-1013: Allow (with a warning) an abstract primary\n                    // type if it's the default type implied by the parent node\n                    log.warn(\"Abstract type \" + primary\n                            + \" used as the default primary type of node \"\n                            + getPath());\n                } else {\n                    constraintViolation(\n                            2, \"Abstract type \" + primary + \" used as the primary type\");\n                }\n            }\n            list.add(type);\n        }\n\n        // mixin types\n        for (String mixin : mixins) {\n            type = types.getChildNode(mixin);\n            if (!type.exists()) {\n                constraintViolation(\n                        5, \"The mixin type \" + mixin + \" does not exist\");\n            } else if (!type.getBoolean(JCR_ISMIXIN)) {\n                constraintViolation(\n                        6, \"Primary type \" + mixin + \" used as a mixin type\");\n            } else if (type.getBoolean(JCR_IS_ABSTRACT)) {\n                constraintViolation(\n                        7, \"Abstract type \" + mixin + \" used as a mixin type\");\n            } else {\n                list.add(type);\n            }\n        }\n\n        return new EffectiveType(list);\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after)\n            throws CommitFailedException {\n        NodeState definition = effective.getDefinition(after);\n        if (definition == null) {\n            throw constraintViolation(\n                    4, \"No matching property definition found for \" + after);\n        } else if (JCR_UUID.equals(after.getName())\n                && effective.isNodeType(MIX_REFERENCEABLE)) {\n            // special handling for the jcr:uuid property of mix:referenceable\n            // TODO: this should be done in a pluggable extension\n            if (!isValidUUID(after.getValue(Type.STRING))) {\n                throw constraintViolation(\n                        12, \"Invalid UUID value in the jcr:uuid property\");\n            }\n        } else {\n            checkValueConstraints(definition, after);\n        }\n    }","id":38556,"modified_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after)\n            throws CommitFailedException {\n        NodeState definition = effective.getDefinition(after);\n        if (definition == null) {\n            constraintViolation(\n                    4, \"No matching property definition found for \" + after);\n        } else if (JCR_UUID.equals(after.getName())\n                && effective.isNodeType(MIX_REFERENCEABLE)) {\n            // special handling for the jcr:uuid property of mix:referenceable\n            // TODO: this should be done in a pluggable extension\n            if (!isValidUUID(after.getValue(Type.STRING))) {\n                constraintViolation(\n                        12, \"Invalid UUID value in the jcr:uuid property\");\n            }\n        } else {\n            checkValueConstraints(definition, after);\n        }\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyDeleted(PropertyState before)\n            throws CommitFailedException {\n        String name = before.getName();\n        if (effective.isMandatoryProperty(name)) {\n            throw constraintViolation(\n                    22, \"Mandatory property \" + name + \" can not be removed\");\n        }\n    }","id":38557,"modified_method":"@Override\n    public void propertyDeleted(PropertyState before)\n            throws CommitFailedException {\n        String name = before.getName();\n        if (effective.isMandatoryProperty(name)) {\n            constraintViolation(\n                    22, \"Mandatory property \" + name + \" can not be removed\");\n        }\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Test constructor.\n     */\n    TypeEditor(EffectiveType effective) {\n        this.parent = null;\n        this.nodeName = null;\n        this.types = EMPTY_NODE;\n        this.effective = checkNotNull(effective);\n        this.builder = EMPTY_NODE.builder();\n    }","id":38558,"modified_method":"/**\n     * Test constructor.\n     */\n    TypeEditor(EffectiveType effective) {\n        this.strict = true;\n        this.parent = null;\n        this.nodeName = null;\n        this.types = EMPTY_NODE;\n        this.effective = checkNotNull(effective);\n        this.builder = EMPTY_NODE.builder();\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private TypeEditor(\n            TypeEditor parent, String name,\n            String primary, Iterable<String> mixins, NodeBuilder builder)\n            throws CommitFailedException {\n        this.parent = checkNotNull(parent);\n        this.nodeName = checkNotNull(name);\n        this.types = parent.types;\n        this.effective =\n                getEffectiveType(parent.effective, name, primary, mixins);\n        this.builder = checkNotNull(builder);\n    }","id":38559,"modified_method":"private TypeEditor(\n            TypeEditor parent, String name,\n            String primary, Iterable<String> mixins, NodeBuilder builder)\n            throws CommitFailedException {\n        this.strict = parent.strict;\n        this.parent = checkNotNull(parent);\n        this.nodeName = checkNotNull(name);\n        this.types = parent.types;\n        this.effective =\n                getEffectiveType(parent.effective, name, primary, mixins);\n        this.builder = checkNotNull(builder);\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void checkValueConstraints(\n            NodeState definition, PropertyState property)\n            throws CommitFailedException {\n        if (property.count() == 0) {\n            return;\n        }\n\n        PropertyState constraints =\n                definition.getProperty(JCR_VALUECONSTRAINTS);\n        if (constraints == null || constraints.count() == 0) {\n            return;\n        }\n\n        PropertyState required = definition.getProperty(JCR_REQUIREDTYPE);\n        if (required == null) {\n            return;\n        }\n\n        int type;\n        String value = required.getValue(STRING);\n        if (\"BINARY\".equals(value)) {\n            type = PropertyType.BINARY;\n        } else if (\"BOOLEAN\".equals(value)) {\n            type = PropertyType.BOOLEAN;\n        } else if (\"DATE\".equals(value)) {\n            type = PropertyType.DATE;\n        } else if (\"DECIMAL\".equals(value)) {\n            type = PropertyType.DECIMAL;\n        } else if (\"DOUBLE\".equals(value)) {\n            type = PropertyType.DOUBLE;\n        } else if (\"LONG\".equals(value)) {\n            type = PropertyType.LONG;\n        } else if (\"NAME\".equals(value)) {\n            type = PropertyType.NAME;\n        } else if (\"PATH\".equals(value)) {\n            type = PropertyType.PATH;\n        } else if (\"REFERENCE\".equals(value)) {\n            type = PropertyType.REFERENCE;\n        } else if (\"STRING\".equals(value)) {\n            type = PropertyType.STRING;\n        } else if (\"URI\".equals(value)) {\n            type = PropertyType.URI;\n        } else if (\"WEAKREFERENCE\".equals(value)) {\n            type = PropertyType.WEAKREFERENCE;\n        } else {\n            return;\n        }\n\n        for (String constraint : constraints.getValue(STRINGS)) {\n            Predicate<Value> predicate = valueConstraint(type, constraint);\n            for (Value v : ValueFactoryImpl.createValues(property, null)) {\n                if (predicate.apply(v)) {\n                    return;\n                }\n            }\n        }\n        throw constraintViolation(5, \"Value constraint violation in \" + property);\n    }","id":38560,"modified_method":"private void checkValueConstraints(\n            NodeState definition, PropertyState property)\n            throws CommitFailedException {\n        if (property.count() == 0) {\n            return;\n        }\n\n        PropertyState constraints =\n                definition.getProperty(JCR_VALUECONSTRAINTS);\n        if (constraints == null || constraints.count() == 0) {\n            return;\n        }\n\n        PropertyState required = definition.getProperty(JCR_REQUIREDTYPE);\n        if (required == null) {\n            return;\n        }\n\n        int type;\n        String value = required.getValue(STRING);\n        if (\"BINARY\".equals(value)) {\n            type = PropertyType.BINARY;\n        } else if (\"BOOLEAN\".equals(value)) {\n            type = PropertyType.BOOLEAN;\n        } else if (\"DATE\".equals(value)) {\n            type = PropertyType.DATE;\n        } else if (\"DECIMAL\".equals(value)) {\n            type = PropertyType.DECIMAL;\n        } else if (\"DOUBLE\".equals(value)) {\n            type = PropertyType.DOUBLE;\n        } else if (\"LONG\".equals(value)) {\n            type = PropertyType.LONG;\n        } else if (\"NAME\".equals(value)) {\n            type = PropertyType.NAME;\n        } else if (\"PATH\".equals(value)) {\n            type = PropertyType.PATH;\n        } else if (\"REFERENCE\".equals(value)) {\n            type = PropertyType.REFERENCE;\n        } else if (\"STRING\".equals(value)) {\n            type = PropertyType.STRING;\n        } else if (\"URI\".equals(value)) {\n            type = PropertyType.URI;\n        } else if (\"WEAKREFERENCE\".equals(value)) {\n            type = PropertyType.WEAKREFERENCE;\n        } else {\n            return;\n        }\n\n        for (String constraint : constraints.getValue(STRINGS)) {\n            Predicate<Value> predicate = valueConstraint(type, constraint);\n            for (Value v : ValueFactoryImpl.createValues(property, null)) {\n                if (predicate.apply(v)) {\n                    return;\n                }\n            }\n        }\n        constraintViolation(5, \"Value constraint violation in \" + property);\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Editor getRootEditor(\n            NodeState before, NodeState after, NodeBuilder builder,\n            CommitInfo info) throws CommitFailedException {\n        NodeState beforeTypes =\n                before.getChildNode(JCR_SYSTEM).getChildNode(JCR_NODE_TYPES);\n        NodeState afterTypes =\n                after.getChildNode(JCR_SYSTEM).getChildNode(JCR_NODE_TYPES);\n\n        Set<String> modifiedTypes = Collections.emptySet();\n        TypeRegistration registration = new TypeRegistration();\n        afterTypes.compareAgainstBaseState(beforeTypes, registration);\n        if (registration.isModified()) {\n            afterTypes = registration.apply(builder);\n            modifiedTypes = registration.getModifiedTypes(beforeTypes);\n        }\n\n        String primary = after.getName(JCR_PRIMARYTYPE);\n        Iterable<String> mixins = after.getNames(JCR_MIXINTYPES);\n\n        if (primary == null && afterTypes.hasChildNode(\"rep:root\")) {\n            // no primary type on the root node, set the hardcoded default\n            primary = \"rep:root\";\n            builder.setProperty(JCR_PRIMARYTYPE, primary, NAME);\n        }\n\n        Editor editor = new VisibleEditor(\n                new TypeEditor(afterTypes, primary, mixins, builder));\n        if (modifiedTypes.isEmpty()) {\n            return editor;\n        } else {\n            // Some node types were modified, so scan the entire repository\n            // to make sure that the modified type definitions still apply.\n            // TODO: Only check the content that uses the modified node types.\n            CommitFailedException exception =\n                    EditorDiff.process(editor, MISSING_NODE, after);\n            if (exception != null) {\n                throw exception;\n            }\n            return null;\n        }\n    }","id":38561,"modified_method":"@Override\n    public Editor getRootEditor(\n            NodeState before, NodeState after, NodeBuilder builder,\n            CommitInfo info) throws CommitFailedException {\n        NodeState beforeTypes =\n                before.getChildNode(JCR_SYSTEM).getChildNode(JCR_NODE_TYPES);\n        NodeState afterTypes =\n                after.getChildNode(JCR_SYSTEM).getChildNode(JCR_NODE_TYPES);\n\n        Set<String> modifiedTypes = Collections.emptySet();\n        TypeRegistration registration = new TypeRegistration();\n        afterTypes.compareAgainstBaseState(beforeTypes, registration);\n        if (registration.isModified()) {\n            afterTypes = registration.apply(builder);\n            modifiedTypes = registration.getModifiedTypes(beforeTypes);\n        }\n\n        String primary = after.getName(JCR_PRIMARYTYPE);\n        Iterable<String> mixins = after.getNames(JCR_MIXINTYPES);\n\n        if (primary == null && afterTypes.hasChildNode(\"rep:root\")) {\n            // no primary type on the root node, set the hardcoded default\n            primary = \"rep:root\";\n            builder.setProperty(JCR_PRIMARYTYPE, primary, NAME);\n        }\n\n        Editor editor = new VisibleEditor(\n                new TypeEditor(strict, afterTypes, primary, mixins, builder));\n        if (modifiedTypes.isEmpty()) {\n            return editor;\n        } else {\n            // Some node types were modified, so scan the entire repository\n            // to make sure that the modified type definitions still apply.\n            // TODO: Only check the content that uses the modified node types.\n            CommitFailedException exception =\n                    EditorDiff.process(editor, MISSING_NODE, after);\n            if (exception != null) {\n                throw exception;\n            }\n            return null;\n        }\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test(expected = CommitFailedException.class)\n    public void removeMandatoryProperty() throws CommitFailedException {\n        EffectiveType effective = createControl().createMock(EffectiveType.class);\n        expect(effective.isMandatoryProperty(\"mandatory\")).andReturn(true);\n        expect(effective.constraintViolation(\n                22, \"/\", \"Mandatory property mandatory can not be removed\"))\n                .andReturn(new CommitFailedException(\"\", 0, \"\"));\n\n        replay(effective);\n\n        TypeEditor editor = new TypeEditor(effective);\n        editor.propertyDeleted(PropertyStates.createProperty(\"mandatory\", \"\"));\n    }","id":38562,"modified_method":"@Test(expected = CommitFailedException.class)\n    public void removeMandatoryProperty() throws CommitFailedException {\n        EffectiveType effective = createControl().createMock(EffectiveType.class);\n        expect(effective.isMandatoryProperty(\"mandatory\")).andReturn(true);\n\n        replay(effective);\n\n        TypeEditor editor = new TypeEditor(effective);\n        editor.propertyDeleted(PropertyStates.createProperty(\"mandatory\", \"\"));\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test(expected = CommitFailedException.class)\n    public void removeMandatoryChildNode() throws CommitFailedException {\n        EffectiveType effective = createControl().createMock(EffectiveType.class);\n        expect(effective.isMandatoryChildNode(\"mandatory\")).andReturn(true);\n        expect(effective.constraintViolation(\n                26, \"/\", \"Mandatory child node mandatory can not be removed\"))\n                .andReturn(new CommitFailedException(\"\", 0, \"\"));\n\n        replay(effective);\n\n        TypeEditor editor = new TypeEditor(effective);\n        editor.childNodeDeleted(\"mandatory\", EMPTY_NODE);\n    }","id":38563,"modified_method":"@Test(expected = CommitFailedException.class)\n    public void removeMandatoryChildNode() throws CommitFailedException {\n        EffectiveType effective = createControl().createMock(EffectiveType.class);\n        expect(effective.isMandatoryChildNode(\"mandatory\")).andReturn(true);\n\n        replay(effective);\n\n        TypeEditor editor = new TypeEditor(effective);\n        editor.childNodeDeleted(\"mandatory\", EMPTY_NODE);\n    }","commit_id":"223b240c7b4cef44d8c34b829a3c78c2335a763f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\r\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\r\n\t\tif (event.getType() == GameEvent.EventType.ZONE_CHANGE) {\r\n\t\t\tZoneChangeEvent zEvent = (ZoneChangeEvent) event;\r\n\t\t\tif (zEvent.getFromZone() == Constants.Zone.BATTLEFIELD && zEvent.getToZone() == Constants.Zone.GRAVEYARD) {\r\n\t\t\t\tPermanent p = (Permanent) game.getLastKnownInformation(event.getTargetId(), Constants.Zone.BATTLEFIELD);\r\n\t\t\t\tif (p.getDealtDamageByThisTurn().contains(this.sourceId)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":38564,"modified_method":"@Override\r\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\r\n\t\tif (event.getType() == GameEvent.EventType.ZONE_CHANGE) {\r\n\t\t\tZoneChangeEvent zEvent = (ZoneChangeEvent) event;\r\n\t\t\tif (zEvent.getFromZone() == Constants.Zone.BATTLEFIELD && zEvent.getToZone() == Constants.Zone.GRAVEYARD) {\r\n\t\t\t\tCard card = game.getLastKnownInformation(event.getTargetId(), Constants.Zone.BATTLEFIELD);\r\n\t\t\t\tif (card instanceof Permanent && ((Permanent)card).getDealtDamageByThisTurn().contains(this.sourceId)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"8b415e2296654b65fd89a7e545db3ff48ab243f8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n    if (game.getPlayer(this.getControllerId()).hasOpponent(event.getPlayerId(), game)) {\r\n            MageObject object = game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);\r\n            if (object instanceof Permanent && !(object instanceof PermanentToken) ) {\r\n                for (Effect effect : getEffects()) {\r\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":38565,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n    if (game.getPlayer(getControllerId()).hasOpponent(event.getPlayerId(), game)) {\r\n            Permanent permanent = (Permanent) game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);\r\n            if (permanent != null && !(permanent instanceof PermanentToken) ) {\r\n                for (Effect effect : getEffects()) {\r\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"73cddda79cc0e22a5b610c95769327e7270ca4a5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean moveToZone(Zone toZone, UUID sourceId, Game game, boolean flag, ArrayList<UUID> appliedEffects) {\n        Zone fromZone = game.getState().getZone(objectId);\n        Player controller = game.getPlayer(controllerId);\n        if (controller != null && controller.removeFromBattlefield(this, game)) {\n            Card originalCard = game.getCard(this.getId());\n            ZoneChangeEvent event = new ZoneChangeEvent(this, sourceId, controllerId, fromZone, toZone, appliedEffects);\n            if (!game.replaceEvent(event)) {\n                Player owner = game.getPlayer(ownerId);\n                game.rememberLKI(objectId, Zone.BATTLEFIELD, this);\n                if (owner != null) {\n                    this.setControllerId(ownerId); // neccessary for e.g. abilities in graveyard or hand to not have a controller != owner\n                    if (originalCard != null) {\n                        originalCard.updateZoneChangeCounter();\n                    }\n                    switch (event.getToZone()) {\n                        case GRAVEYARD:\n                            owner.putInGraveyard(card, game, !flag);\n                            break;\n                        case HAND:\n                            owner.getHand().add(card);\n                            break;\n                        case EXILED:\n                            game.getExile().getPermanentExile().add(card);\n                            break;\n                        case COMMAND:\n                            game.addCommander(new Commander(card));\n                            break;\n                        case LIBRARY:\n                            if (flag) {\n                                owner.getLibrary().putOnTop(card, game);\n                            } else {\n                                owner.getLibrary().putOnBottom(card, game);\n                            }\n                            break;\n                        case BATTLEFIELD:\n                            //should never happen\n                            break;\n                    }\n                    game.setZone(objectId, event.getToZone());\n                    game.addSimultaneousEvent(event);\n                    return game.getState().getZone(objectId) == toZone;\n                }\n            }\n        }\n        return false;\n    }","id":38566,"modified_method":"@Override\n    public boolean moveToZone(Zone toZone, UUID sourceId, Game game, boolean flag, ArrayList<UUID> appliedEffects) {\n        Zone fromZone = game.getState().getZone(objectId);\n        Player controller = game.getPlayer(controllerId);\n        if (controller != null && controller.removeFromBattlefield(this, game)) {\n            Card originalCard = game.getCard(this.getId());\n            ZoneChangeEvent event = new ZoneChangeEvent(this, sourceId, controllerId, fromZone, toZone, appliedEffects);\n            if (!game.replaceEvent(event)) {\n                Player owner = game.getPlayer(ownerId);\n                game.rememberLKI(objectId, Zone.BATTLEFIELD, this);\n                if (owner != null) {\n                    if (originalCard != null) {\n                        originalCard.updateZoneChangeCounter();\n                    }\n                    switch (event.getToZone()) {\n                        case GRAVEYARD:\n                            owner.putInGraveyard(card, game, !flag);\n                            break;\n                        case HAND:\n                            owner.getHand().add(card);\n                            break;\n                        case EXILED:\n                            game.getExile().getPermanentExile().add(card);\n                            break;\n                        case COMMAND:\n                            game.addCommander(new Commander(card));\n                            break;\n                        case LIBRARY:\n                            if (flag) {\n                                owner.getLibrary().putOnTop(card, game);\n                            } else {\n                                owner.getLibrary().putOnBottom(card, game);\n                            }\n                            break;\n                        case BATTLEFIELD:\n                            //should never happen\n                            break;\n                    }\n                    game.setZone(objectId, event.getToZone());\n                    game.addSimultaneousEvent(event);\n                    return game.getState().getZone(objectId) == toZone;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"73cddda79cc0e22a5b610c95769327e7270ca4a5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourcePermanent = game.getPermanent(source.getFirstTarget());\r\n        if (sourcePermanent == null) {\r\n            game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);\r\n        }\r\n\r\n        Permanent targetPermanent = (Permanent) game.getPermanent(source.getTargets().get(1).getFirstTarget());\r\n        if (sourcePermanent != null && targetPermanent != null) {\r\n            targetPermanent.damage(sourcePermanent.getPower().getValue(), sourcePermanent.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":38567,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent sourcePermanent = game.getPermanent(source.getFirstTarget());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = (Permanent) game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);\r\n        }\r\n\r\n        Permanent targetPermanent = (Permanent) game.getPermanent(source.getTargets().get(1).getFirstTarget());\r\n        if (sourcePermanent != null && targetPermanent != null) {\r\n            targetPermanent.damage(sourcePermanent.getPower().getValue(), sourcePermanent.getId(), game, true, false);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"f31fc9d9aace4c54d82763fa07d2891743750d47","url":"https://github.com/magefree/mage"},{"original_method":"public WingPunctureEffect() {\r\n        super(Outcome.Damage);\r\n        staticText = \"Target creature you control deals damage equal to its power to target creature with flying.\";\r\n     }","id":38568,"modified_method":"public WingPunctureEffect() {\r\n        super(Outcome.Damage);\r\n        staticText = \"Target creature you control deals damage equal to its power to target creature with flying\";\r\n     }","commit_id":"f31fc9d9aace4c54d82763fa07d2891743750d47","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n  public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir,\n                              @NotNull GithubTagInfo tag, @NotNull Module module) {\n    try {\n      unpackToDir(project, new File(baseDir.getPath()), tag);\n    }\n    catch (GeneratorException e) {\n      showErrorMessage(e.getMessage());\n    }\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        baseDir.refresh(true, true);\n      }\n    });\n  }","id":38569,"modified_method":"@Override\n  public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir,\n                              @NotNull GithubTagInfo tag, @NotNull Module module) {\n    try {\n      unpackToDir(project, new File(baseDir.getPath()), tag);\n    }\n    catch (GeneratorException e) {\n      showErrorMessage(null, e.getMessage());\n    }\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        baseDir.refresh(true, true);\n      }\n    });\n  }","commit_id":"02da50f1a3010b153ed239eef4bf7c296464b77c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showErrorMessage(@NotNull String message) {\n    String fullMessage = \"Error creating \" + getDisplayName() + \" project. \" + message;\n    String title = \"Create \" + getDisplayName() + \" Project\";\n    Project project = null;\n    Messages.showErrorDialog(project, fullMessage, title);\n  }","id":38570,"modified_method":"private void showErrorMessage(@Nullable Project project, @NotNull String message) {\n    String fullMessage = \"Error creating \" + getDisplayName() + \" project. \" + message;\n    String title = \"Create \" + getDisplayName() + \" Project\";\n    Messages.showErrorDialog(project, fullMessage, title);\n  }","commit_id":"02da50f1a3010b153ed239eef4bf7c296464b77c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void unzipEntryToDir(@Nullable ProgressIndicator progress,\n                                      @NotNull final ZipEntry zipEntry,\n                                      @NotNull final File extractToDir,\n                                      ZipInputStream stream,\n                                      @Nullable NullableFunction<String, String> pathConvertor,\n                                      @Nullable ContentProcessor contentProcessor) throws IOException {\n    String relativeExtractPath = createRelativeExtractPath(zipEntry);\n    if (pathConvertor != null) {\n      relativeExtractPath = pathConvertor.fun(relativeExtractPath);\n      if (relativeExtractPath == null) {\n        // should be skipped\n        return;\n      }\n    }\n    File child = new File(extractToDir, relativeExtractPath);\n    File dir = zipEntry.isDirectory() ? child : child.getParentFile();\n    if (!dir.exists() && !dir.mkdirs()) {\n      throw new IOException(\"Unable to create dir: '\" + dir + \"'!\");\n    }\n    if (zipEntry.isDirectory()) {\n      return;\n    }\n    if (progress != null) {\n      progress.setText(\"Extracting \" + relativeExtractPath + \" ...\");\n    }\n    if (contentProcessor == null) {\n      FileOutputStream fileOutputStream = new FileOutputStream(child);\n      try {\n        FileUtil.copy(stream, fileOutputStream);\n      }\n      finally {\n        fileOutputStream.close();\n      }\n    }\n    else {\n      byte[] content = contentProcessor.processContent(FileUtil.loadBytes(stream), child);\n      if (content != null) {\n        FileOutputStream fileOutputStream = new FileOutputStream(child);\n        try {\n          fileOutputStream.write(content);\n        }\n        finally {\n          fileOutputStream.close();\n        }\n      }\n    }\n    LOG.info(\"Extract: \" + relativeExtractPath);\n  }","id":38571,"modified_method":"private static void unzipEntryToDir(@Nullable ProgressIndicator progress,\n                                      @NotNull final ZipEntry zipEntry,\n                                      @NotNull final InputStream entryContentStream,\n                                      @NotNull final File extractToDir,\n                                      @Nullable NullableFunction<String, String> pathConvertor,\n                                      @Nullable ContentProcessor contentProcessor) throws IOException {\n    String relativeExtractPath = createRelativeExtractPath(zipEntry);\n    if (pathConvertor != null) {\n      relativeExtractPath = pathConvertor.fun(relativeExtractPath);\n      if (relativeExtractPath == null) {\n        // should be skipped\n        return;\n      }\n    }\n    File child = new File(extractToDir, relativeExtractPath);\n    File dir = zipEntry.isDirectory() ? child : child.getParentFile();\n    if (!dir.exists() && !dir.mkdirs()) {\n      throw new IOException(\"Unable to create dir: '\" + dir + \"'!\");\n    }\n    if (zipEntry.isDirectory()) {\n      return;\n    }\n    if (progress != null) {\n      progress.setText(\"Extracting \" + relativeExtractPath + \" ...\");\n    }\n    if (contentProcessor == null) {\n      FileOutputStream fileOutputStream = new FileOutputStream(child);\n      try {\n        FileUtil.copy(entryContentStream, fileOutputStream);\n      }\n      finally {\n        fileOutputStream.close();\n      }\n    }\n    else {\n      byte[] content = contentProcessor.processContent(FileUtil.loadBytes(entryContentStream), child);\n      if (content != null) {\n        FileOutputStream fileOutputStream = new FileOutputStream(child);\n        try {\n          fileOutputStream.write(content);\n        }\n        finally {\n          fileOutputStream.close();\n        }\n      }\n    }\n    LOG.info(\"Extract: \" + relativeExtractPath);\n  }","commit_id":"02da50f1a3010b153ed239eef4bf7c296464b77c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void unzipWithProgressSynchronously(\n    @Nullable Project project,\n    @NotNull String progressTitle,\n    @NotNull final File zipArchive,\n    @NotNull final File extractToDir,\n    final boolean unwrapSingleTopLevelFolder) throws GeneratorException\n  {\n    final Outcome<Boolean> outcome = DownloadUtil.provideDataWithProgressSynchronously(\n      project, progressTitle, \"Unpacking ...\",\n      new Callable<Boolean>() {\n        @Override\n        public Boolean call() throws IOException {\n          ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n          ZipInputStream stream = new ZipInputStream(new FileInputStream(zipArchive));\n          try {\n            unzip(progress, extractToDir, stream, null, null, unwrapSingleTopLevelFolder);\n          }\n          finally {\n            stream.close();\n          }\n          return true;\n        }\n      },\n      new Producer<Boolean>() {\n        @Override\n        public Boolean produce() {\n          return false;\n        }\n      }\n    );\n    Boolean result = outcome.get();\n    if (result == null) {\n      @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n      Exception e = outcome.getException();\n      if (e != null) {\n        throw new GeneratorException(\"Unpacking failed, downloaded archive is broken\");\n      }\n      throw new GeneratorException(\"Unpacking was cancelled\");\n    }\n  }","id":38572,"modified_method":"public static void unzipWithProgressSynchronously(\n    @Nullable Project project,\n    @NotNull String progressTitle,\n    @NotNull final File zipArchive,\n    @NotNull final File extractToDir,\n    final boolean unwrapSingleTopLevelFolder) throws GeneratorException\n  {\n    final Outcome<Boolean> outcome = DownloadUtil.provideDataWithProgressSynchronously(\n      project, progressTitle, \"Unpacking ...\",\n      new Callable<Boolean>() {\n        @Override\n        public Boolean call() throws IOException {\n          ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n          unzip(progress, extractToDir, zipArchive, null, null, unwrapSingleTopLevelFolder);\n          return true;\n        }\n      },\n      new Producer<Boolean>() {\n        @Override\n        public Boolean produce() {\n          return false;\n        }\n      }\n    );\n    Boolean result = outcome.get();\n    if (result == null) {\n      @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n      Exception e = outcome.getException();\n      if (e != null) {\n        throw new GeneratorException(\"Unpacking failed, downloaded archive is broken\");\n      }\n      throw new GeneratorException(\"Unpacking was cancelled\");\n    }\n  }","commit_id":"02da50f1a3010b153ed239eef4bf7c296464b77c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void unzip(@Nullable ProgressIndicator progress,\n                           @NotNull File targetDir,\n                           @NotNull ZipInputStream stream,\n                           @Nullable NullableFunction<String, String> pathConvertor,\n                           @Nullable ContentProcessor contentProcessor,\n                           boolean unwrapSingleTopLevelFolder) throws IOException {\n    if (progress != null) {\n      progress.setText(\"Extracting...\");\n    }\n    File unzipToDir = targetDir;\n    if (unwrapSingleTopLevelFolder) {\n      unzipToDir = FileUtil.createTempDirectory(\"unzip-dir-\", null);\n    }\n\n    ZipEntry entry;\n    while ((entry = stream.getNextEntry()) != null) {\n      unzipEntryToDir(progress, entry, unzipToDir, stream, pathConvertor, contentProcessor);\n    }\n\n    if (unwrapSingleTopLevelFolder) {\n      File[] topLevelFiles = unzipToDir.listFiles();\n      File dirToMove;\n      if (topLevelFiles != null && topLevelFiles.length == 1 && topLevelFiles[0].isDirectory()) {\n        dirToMove = topLevelFiles[0];\n      }\n      else {\n        dirToMove = unzipToDir;\n      }\n      if (!FileUtil.moveDirWithContent(dirToMove, targetDir)) {\n        FileUtil.copyDirContent(dirToMove, targetDir);\n      }\n      FileUtil.delete(unzipToDir);\n    }\n  }","id":38573,"modified_method":"public static void unzip(@Nullable ProgressIndicator progress,\n                           @NotNull File targetDir,\n                           @NotNull ZipInputStream stream,\n                           @Nullable NullableFunction<String, String> pathConvertor,\n                           @Nullable ContentProcessor contentProcessor,\n                           boolean unwrapSingleTopLevelFolder) throws IOException {\n    File unzipToDir = getUnzipToDir(progress, targetDir, unwrapSingleTopLevelFolder);\n    ZipEntry entry;\n    while ((entry = stream.getNextEntry()) != null) {\n      unzipEntryToDir(progress, entry, stream, unzipToDir,  pathConvertor, contentProcessor);\n    }\n    doUnwrapSingleTopLevelFolder(unwrapSingleTopLevelFolder, unzipToDir, targetDir);\n  }","commit_id":"02da50f1a3010b153ed239eef4bf7c296464b77c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir,\n                              @NotNull GithubTagInfo tag, @NotNull Module module) {\n    try {\n      unpackToDir(project, new File(baseDir.getPath()), tag);\n    }\n    catch (GeneratorException e) {\n      showErrorMessage(e.getMessage());\n    }\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        baseDir.refresh(false, true);\n      }\n    });\n  }","id":38574,"modified_method":"@Override\n  public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir,\n                              @NotNull GithubTagInfo tag, @NotNull Module module) {\n    try {\n      unpackToDir(project, new File(baseDir.getPath()), tag);\n    }\n    catch (GeneratorException e) {\n      showErrorMessage(e.getMessage());\n    }\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        baseDir.refresh(true, true);\n      }\n    });\n  }","commit_id":"14bc26151a10af0df81e565938af7a5712eb6cfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void unpackToDir(@Nullable Project project,\n                           @NotNull File extractToDir,\n                           @NotNull GithubTagInfo tag) throws GeneratorException {\n    File zipArchiveFile = getCacheFile(tag);\n    boolean brokenZip = true;\n    if (zipArchiveFile.isFile()) {\n      try {\n        ZipUtil.unzipWithProgressSynchronously(project, getTitle(), zipArchiveFile, extractToDir);\n        brokenZip = false;\n      }\n      catch (GeneratorException ignored) {\n      }\n    }\n    if (brokenZip) {\n      String primaryUrl = getPrimaryZipArchiveUrlForDownload(tag);\n      boolean downloaded = false;\n      if (primaryUrl != null) {\n        try {\n          downloadAndUnzip(project, primaryUrl, zipArchiveFile, extractToDir, false);\n          downloaded = true;\n        } catch (GeneratorException e) {\n          LOG.info(\"Can't download \" + primaryUrl, e);\n          FileUtil.delete(zipArchiveFile);\n        }\n      }\n      if (!downloaded) {\n        downloadAndUnzip(project, tag.getZipballUrl(), zipArchiveFile, extractToDir, true);\n      }\n    }\n  }","id":38575,"modified_method":"private void unpackToDir(@Nullable Project project,\n                           @NotNull File extractToDir,\n                           @NotNull GithubTagInfo tag) throws GeneratorException {\n    File zipArchiveFile = getCacheFile(tag);\n    boolean brokenZip = true;\n    if (zipArchiveFile.isFile()) {\n      try {\n        ZipUtil.unzipWithProgressSynchronously(project, getTitle(), zipArchiveFile, extractToDir, true);\n        brokenZip = false;\n      }\n      catch (GeneratorException ignored) {\n      }\n    }\n    if (brokenZip) {\n      String primaryUrl = getPrimaryZipArchiveUrlForDownload(tag);\n      boolean downloaded = false;\n      if (primaryUrl != null) {\n        try {\n          downloadAndUnzip(project, primaryUrl, zipArchiveFile, extractToDir, false);\n          downloaded = true;\n        } catch (GeneratorException e) {\n          LOG.info(\"Can't download \" + primaryUrl, e);\n          FileUtil.delete(zipArchiveFile);\n        }\n      }\n      if (!downloaded) {\n        downloadAndUnzip(project, tag.getZipballUrl(), zipArchiveFile, extractToDir, true);\n      }\n    }\n  }","commit_id":"14bc26151a10af0df81e565938af7a5712eb6cfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void downloadAndUnzip(@Nullable Project project,\n                                @NotNull String url,\n                                @NotNull File zipArchiveFile,\n                                @NotNull File extractToDir,\n                                boolean retryOnError) throws GeneratorException {\n    GithubDownloadUtil.downloadContentToFileWithProgressSynchronously(\n      project,\n      url,\n      getTitle(),\n      zipArchiveFile,\n      getGithubUserName(),\n      getGithubRepositoryName(),\n      retryOnError\n    );\n    LOG.info(\"Content of \" + url + \" has been successfully downloaded to \" + zipArchiveFile.getAbsolutePath()\n             + \", size \" + zipArchiveFile.length() + \" bytes\");\n    ZipUtil.unzipWithProgressSynchronously(project, getTitle(), zipArchiveFile, extractToDir);\n  }","id":38576,"modified_method":"private void downloadAndUnzip(@Nullable Project project,\n                                @NotNull String url,\n                                @NotNull File zipArchiveFile,\n                                @NotNull File extractToDir,\n                                boolean retryOnError) throws GeneratorException {\n    GithubDownloadUtil.downloadContentToFileWithProgressSynchronously(\n      project,\n      url,\n      getTitle(),\n      zipArchiveFile,\n      getGithubUserName(),\n      getGithubRepositoryName(),\n      retryOnError\n    );\n    LOG.info(\"Content of \" + url + \" has been successfully downloaded to \" + zipArchiveFile.getAbsolutePath()\n             + \", size \" + zipArchiveFile.length() + \" bytes\");\n    ZipUtil.unzipWithProgressSynchronously(project, getTitle(), zipArchiveFile, extractToDir, true);\n  }","commit_id":"14bc26151a10af0df81e565938af7a5712eb6cfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void unzip(final @Nullable String projectName, String path, final boolean moduleMode) {\n    File dir = new File(path);\n    ZipInputStream zipInputStream = null;\n    final WizardInputField basePackage = getBasePackageField();\n    try {\n      zipInputStream = myTemplate.getStream();\n      NullableFunction<String, String> pathConvertor = new NullableFunction<String, String>() {\n        @Nullable\n        @Override\n        public String fun(String path) {\n          if (moduleMode && path.contains(\".idea\")) return null;\n          if (basePackage != null) {\n            return path.replace(getPathFragment(basePackage.getDefaultValue()), getPathFragment(basePackage.getValue()));\n          }\n          return path;\n        }\n      };\n      ZipUtil.unzip(ProgressManager.getInstance().getProgressIndicator(), dir, zipInputStream, pathConvertor, new ZipUtil.ContentProcessor() {\n        @Override\n        public byte[] processContent(byte[] content, File file) throws IOException {\n          FileType fileType = FileTypeManager.getInstance().getFileTypeByExtension(FileUtilRt.getExtension(file.getName()));\n          return fileType.isBinary() ? content : processTemplates(projectName, new String(content), file);\n        }\n      });\n      String iml = ContainerUtil.find(dir.list(), new Condition<String>() {\n        @Override\n        public boolean value(String s) {\n          return s.endsWith(\".iml\");\n        }\n      });\n      if (moduleMode) {\n        File from = new File(path, iml);\n        File to = new File(getModuleFilePath());\n        if (!from.renameTo(to)) {\n          throw new IOException(\"Can't rename \" + from + \" to \" + to);\n        }\n      }\n      VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(dir);\n      if (virtualFile == null) {\n        throw new IOException(\"Can't find \" + dir);\n      }\n      RefreshQueue.getInstance().refresh(false, true, null, virtualFile);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    finally {\n      StreamUtil.closeStream(zipInputStream);\n    }\n  }","id":38577,"modified_method":"private void unzip(final @Nullable String projectName, String path, final boolean moduleMode) {\n    File dir = new File(path);\n    ZipInputStream zipInputStream = null;\n    final WizardInputField basePackage = getBasePackageField();\n    try {\n      zipInputStream = myTemplate.getStream();\n      NullableFunction<String, String> pathConvertor = new NullableFunction<String, String>() {\n        @Nullable\n        @Override\n        public String fun(String path) {\n          if (moduleMode && path.contains(\".idea\")) return null;\n          if (basePackage != null) {\n            return path.replace(getPathFragment(basePackage.getDefaultValue()), getPathFragment(basePackage.getValue()));\n          }\n          return path;\n        }\n      };\n      ZipUtil.unzip(ProgressManager.getInstance().getProgressIndicator(), dir, zipInputStream, pathConvertor, new ZipUtil.ContentProcessor() {\n        @Override\n        public byte[] processContent(byte[] content, File file) throws IOException {\n          FileType fileType = FileTypeManager.getInstance().getFileTypeByExtension(FileUtilRt.getExtension(file.getName()));\n          return fileType.isBinary() ? content : processTemplates(projectName, new String(content), file);\n        }\n      }, false);\n      String iml = ContainerUtil.find(dir.list(), new Condition<String>() {\n        @Override\n        public boolean value(String s) {\n          return s.endsWith(\".iml\");\n        }\n      });\n      if (moduleMode) {\n        File from = new File(path, iml);\n        File to = new File(getModuleFilePath());\n        if (!from.renameTo(to)) {\n          throw new IOException(\"Can't rename \" + from + \" to \" + to);\n        }\n      }\n      VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(dir);\n      if (virtualFile == null) {\n        throw new IOException(\"Can't find \" + dir);\n      }\n      RefreshQueue.getInstance().refresh(false, true, null, virtualFile);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    finally {\n      StreamUtil.closeStream(zipInputStream);\n    }\n  }","commit_id":"14bc26151a10af0df81e565938af7a5712eb6cfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void unzipEntryToDir(@Nullable ProgressIndicator progress,\n                                      @NotNull final ZipEntry zipEntry,\n                                      @NotNull final File extractToDir,\n                                      ZipInputStream stream,\n                                      @Nullable NullableFunction<String, String> pathConvertor,\n                                      @Nullable ContentProcessor contentProcessor) throws IOException {\n\n    String relativeExtractPath = createRelativeExtractPath(zipEntry);\n    if (pathConvertor != null) {\n      relativeExtractPath = pathConvertor.fun(relativeExtractPath);\n      if (relativeExtractPath == null) {\n        // should be skipped\n        return;\n      }\n    }\n    File child = new File(extractToDir, relativeExtractPath);\n    File dir = zipEntry.isDirectory() ? child : child.getParentFile();\n    if (!dir.exists() && !dir.mkdirs()) {\n      throw new IOException(\"Unable to create dir: '\" + dir + \"'!\");\n    }\n    if (zipEntry.isDirectory()) {\n      return;\n    }\n    if (progress != null) {\n      progress.setText(\"Extracting \" + relativeExtractPath + \" ...\");\n    }\n    FileOutputStream fileOutputStream = null;\n    try {\n      if (contentProcessor == null) {\n        fileOutputStream = new FileOutputStream(child);\n        FileUtil.copy(stream, fileOutputStream);\n      }\n      else {\n        byte[] content = contentProcessor.processContent(FileUtil.loadBytes(stream), child);\n        if (content != null) {\n          fileOutputStream = new FileOutputStream(child);\n          fileOutputStream.write(content);\n        }\n      }\n    } finally {\n      if (fileOutputStream != null) {\n        fileOutputStream.close();\n      }\n    }\n    LOG.info(\"Extract: \" + relativeExtractPath);\n  }","id":38578,"modified_method":"@Nullable\n  private static File unzipEntryToDir(@Nullable ProgressIndicator progress,\n                                      @NotNull final ZipEntry zipEntry,\n                                      @NotNull final File extractToDir,\n                                      ZipInputStream stream,\n                                      @Nullable NullableFunction<String, String> pathConvertor,\n                                      @Nullable ContentProcessor contentProcessor) throws IOException {\n    String relativeExtractPath = createRelativeExtractPath(zipEntry);\n    if (pathConvertor != null) {\n      relativeExtractPath = pathConvertor.fun(relativeExtractPath);\n      if (relativeExtractPath == null) {\n        // should be skipped\n        return null;\n      }\n    }\n    File child = new File(extractToDir, relativeExtractPath);\n    File dir = zipEntry.isDirectory() ? child : child.getParentFile();\n    if (!dir.exists() && !dir.mkdirs()) {\n      throw new IOException(\"Unable to create dir: '\" + dir + \"'!\");\n    }\n    if (zipEntry.isDirectory()) {\n      return dir;\n    }\n    if (progress != null) {\n      progress.setText(\"Extracting \" + relativeExtractPath + \" ...\");\n    }\n    FileOutputStream fileOutputStream = null;\n    try {\n      if (contentProcessor == null) {\n        fileOutputStream = new FileOutputStream(child);\n        FileUtil.copy(stream, fileOutputStream);\n      }\n      else {\n        byte[] content = contentProcessor.processContent(FileUtil.loadBytes(stream), child);\n        if (content != null) {\n          fileOutputStream = new FileOutputStream(child);\n          fileOutputStream.write(content);\n        }\n      }\n    } finally {\n      if (fileOutputStream != null) {\n        fileOutputStream.close();\n      }\n    }\n    LOG.info(\"Extract: \" + relativeExtractPath);\n    return child;\n  }","commit_id":"14bc26151a10af0df81e565938af7a5712eb6cfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void unzipWithProgressSynchronously(\n    @Nullable Project project,\n    @NotNull String progressTitle,\n    @NotNull final File zipArchive,\n    @NotNull final File extractToDir) throws GeneratorException\n  {\n    Outcome<Boolean> outcome = DownloadUtil.provideDataWithProgressSynchronously(\n      project, progressTitle, \"Unpacking ...\",\n      new Callable<Boolean>() {\n        @Override\n        public Boolean call() throws IOException {\n          ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n          ZipInputStream stream = new ZipInputStream(new FileInputStream(zipArchive));\n          unzip(progress, extractToDir, stream, null, null);\n          return true;\n        }\n      },\n      new Producer<Boolean>() {\n        @Override\n        public Boolean produce() {\n          return false;\n        }\n      }\n    );\n    Boolean result = outcome.get();\n    if (result == null) {\n      @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n      Exception e = outcome.getException();\n      if (e != null) {\n        throw new GeneratorException(\"Unpacking failed, downloaded archive is broken\");\n      }\n      throw new GeneratorException(\"Unpacking was cancelled\");\n    }\n  }","id":38579,"modified_method":"public static void unzipWithProgressSynchronously(\n    @Nullable Project project,\n    @NotNull String progressTitle,\n    @NotNull final File zipArchive,\n    @NotNull final File extractToDir,\n    final boolean unwrapSingleTopLevelFolder) throws GeneratorException\n  {\n    final Outcome<Boolean> outcome = DownloadUtil.provideDataWithProgressSynchronously(\n      project, progressTitle, \"Unpacking ...\",\n      new Callable<Boolean>() {\n        @Override\n        public Boolean call() throws IOException {\n          ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n          ZipInputStream stream = new ZipInputStream(new FileInputStream(zipArchive));\n          try {\n            unzip(progress, extractToDir, stream, null, null, unwrapSingleTopLevelFolder);\n          }\n          finally {\n            stream.close();\n          }\n          return true;\n        }\n      },\n      new Producer<Boolean>() {\n        @Override\n        public Boolean produce() {\n          return false;\n        }\n      }\n    );\n    Boolean result = outcome.get();\n    if (result == null) {\n      @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n      Exception e = outcome.getException();\n      if (e != null) {\n        throw new GeneratorException(\"Unpacking failed, downloaded archive is broken\");\n      }\n      throw new GeneratorException(\"Unpacking was cancelled\");\n    }\n  }","commit_id":"14bc26151a10af0df81e565938af7a5712eb6cfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void unzip(@Nullable ProgressIndicator progress,\n                           File extractToDir,\n                           ZipInputStream stream,\n                           @Nullable NullableFunction<String, String> pathConvertor,\n                           @Nullable ContentProcessor contentProcessor) throws IOException {\n    if (progress != null) {\n      progress.setText(\"Extracting...\");\n    }\n    try {\n      ZipEntry entry;\n      while ((entry = stream.getNextEntry()) != null) {\n        unzipEntryToDir(progress, entry, extractToDir, stream, pathConvertor, contentProcessor);\n      }\n    } finally {\n      stream.close();\n    }\n  }","id":38580,"modified_method":"public static void unzip(@Nullable ProgressIndicator progress,\n                           @NotNull File extractToDir,\n                           @NotNull ZipInputStream stream,\n                           @Nullable NullableFunction<String, String> pathConvertor,\n                           @Nullable ContentProcessor contentProcessor,\n                           boolean unwrapSingleTopLevelFolder) throws IOException {\n    if (progress != null) {\n      progress.setText(\"Extracting...\");\n    }\n    SingleTopLevelFolderUnwrapper singleTopLevelFolderUnwrapper = null;\n    File unzipToDir = extractToDir;\n    if (unwrapSingleTopLevelFolder) {\n      unzipToDir = FileUtil.createTempDirectory(\"unzip-dir-\", null);\n      singleTopLevelFolderUnwrapper = new SingleTopLevelFolderUnwrapper(unzipToDir);\n    }\n    ZipEntry entry;\n    while ((entry = stream.getNextEntry()) != null) {\n      File child = unzipEntryToDir(progress, entry, unzipToDir, stream, pathConvertor, contentProcessor);\n      if (singleTopLevelFolderUnwrapper != null && child != null) {\n        singleTopLevelFolderUnwrapper.onFileUnzipped(child);\n      }\n    }\n    if (singleTopLevelFolderUnwrapper != null) {\n      singleTopLevelFolderUnwrapper.unwrap(extractToDir);\n    }\n  }","commit_id":"14bc26151a10af0df81e565938af7a5712eb6cfb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void unzip(@Nullable ProgressIndicator progress,\n                           @NotNull File extractToDir,\n                           @NotNull ZipInputStream stream,\n                           @Nullable NullableFunction<String, String> pathConvertor,\n                           @Nullable ContentProcessor contentProcessor,\n                           boolean unwrapSingleTopLevelFolder) throws IOException {\n    if (progress != null) {\n      progress.setText(\"Extracting...\");\n    }\n    SingleTopLevelFolderUnwrapper singleTopLevelFolderUnwrapper = null;\n    File unzipToDir = extractToDir;\n    if (unwrapSingleTopLevelFolder) {\n      unzipToDir = FileUtil.createTempDirectory(\"unzip-dir-\", null);\n      singleTopLevelFolderUnwrapper = new SingleTopLevelFolderUnwrapper(unzipToDir);\n    }\n    ZipEntry entry;\n    while ((entry = stream.getNextEntry()) != null) {\n      File child = unzipEntryToDir(progress, entry, unzipToDir, stream, pathConvertor, contentProcessor);\n      if (singleTopLevelFolderUnwrapper != null && child != null) {\n        singleTopLevelFolderUnwrapper.onFileUnzipped(child);\n      }\n    }\n    if (singleTopLevelFolderUnwrapper != null) {\n      singleTopLevelFolderUnwrapper.unwrap(extractToDir);\n    }\n  }","id":38581,"modified_method":"public static void unzip(@Nullable ProgressIndicator progress,\n                           @NotNull File targetDir,\n                           @NotNull ZipInputStream stream,\n                           @Nullable NullableFunction<String, String> pathConvertor,\n                           @Nullable ContentProcessor contentProcessor,\n                           boolean unwrapSingleTopLevelFolder) throws IOException {\n    if (progress != null) {\n      progress.setText(\"Extracting...\");\n    }\n    File unzipToDir = targetDir;\n    if (unwrapSingleTopLevelFolder) {\n      unzipToDir = FileUtil.createTempDirectory(\"unzip-dir-\", null);\n    }\n\n    ZipEntry entry;\n    while ((entry = stream.getNextEntry()) != null) {\n      unzipEntryToDir(progress, entry, unzipToDir, stream, pathConvertor, contentProcessor);\n    }\n\n    if (unwrapSingleTopLevelFolder) {\n      File[] topLevelFiles = unzipToDir.listFiles();\n      File dirToMove;\n      if (topLevelFiles != null && topLevelFiles.length == 1 && topLevelFiles[0].isDirectory()) {\n        dirToMove = topLevelFiles[0];\n      }\n      else {\n        dirToMove = unzipToDir;\n      }\n      if (!FileUtil.moveDirWithContent(dirToMove, targetDir)) {\n        FileUtil.copyDirContent(dirToMove, targetDir);\n      }\n      FileUtil.delete(unzipToDir);\n    }\n  }","commit_id":"d1b339de17495ade167719d5f987ba588068f0dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static File unzipEntryToDir(@Nullable ProgressIndicator progress,\n                                      @NotNull final ZipEntry zipEntry,\n                                      @NotNull final File extractToDir,\n                                      ZipInputStream stream,\n                                      @Nullable NullableFunction<String, String> pathConvertor,\n                                      @Nullable ContentProcessor contentProcessor) throws IOException {\n    String relativeExtractPath = createRelativeExtractPath(zipEntry);\n    if (pathConvertor != null) {\n      relativeExtractPath = pathConvertor.fun(relativeExtractPath);\n      if (relativeExtractPath == null) {\n        // should be skipped\n        return null;\n      }\n    }\n    File child = new File(extractToDir, relativeExtractPath);\n    File dir = zipEntry.isDirectory() ? child : child.getParentFile();\n    if (!dir.exists() && !dir.mkdirs()) {\n      throw new IOException(\"Unable to create dir: '\" + dir + \"'!\");\n    }\n    if (zipEntry.isDirectory()) {\n      return dir;\n    }\n    if (progress != null) {\n      progress.setText(\"Extracting \" + relativeExtractPath + \" ...\");\n    }\n    FileOutputStream fileOutputStream = null;\n    try {\n      if (contentProcessor == null) {\n        fileOutputStream = new FileOutputStream(child);\n        FileUtil.copy(stream, fileOutputStream);\n      }\n      else {\n        byte[] content = contentProcessor.processContent(FileUtil.loadBytes(stream), child);\n        if (content != null) {\n          fileOutputStream = new FileOutputStream(child);\n          fileOutputStream.write(content);\n        }\n      }\n    } finally {\n      if (fileOutputStream != null) {\n        fileOutputStream.close();\n      }\n    }\n    LOG.info(\"Extract: \" + relativeExtractPath);\n    return child;\n  }","id":38582,"modified_method":"private static void unzipEntryToDir(@Nullable ProgressIndicator progress,\n                                      @NotNull final ZipEntry zipEntry,\n                                      @NotNull final File extractToDir,\n                                      ZipInputStream stream,\n                                      @Nullable NullableFunction<String, String> pathConvertor,\n                                      @Nullable ContentProcessor contentProcessor) throws IOException {\n    String relativeExtractPath = createRelativeExtractPath(zipEntry);\n    if (pathConvertor != null) {\n      relativeExtractPath = pathConvertor.fun(relativeExtractPath);\n      if (relativeExtractPath == null) {\n        // should be skipped\n        return;\n      }\n    }\n    File child = new File(extractToDir, relativeExtractPath);\n    File dir = zipEntry.isDirectory() ? child : child.getParentFile();\n    if (!dir.exists() && !dir.mkdirs()) {\n      throw new IOException(\"Unable to create dir: '\" + dir + \"'!\");\n    }\n    if (zipEntry.isDirectory()) {\n      return;\n    }\n    if (progress != null) {\n      progress.setText(\"Extracting \" + relativeExtractPath + \" ...\");\n    }\n    FileOutputStream fileOutputStream = null;\n    try {\n      if (contentProcessor == null) {\n        fileOutputStream = new FileOutputStream(child);\n        FileUtil.copy(stream, fileOutputStream);\n      }\n      else {\n        byte[] content = contentProcessor.processContent(FileUtil.loadBytes(stream), child);\n        if (content != null) {\n          fileOutputStream = new FileOutputStream(child);\n          fileOutputStream.write(content);\n        }\n      }\n    } finally {\n      if (fileOutputStream != null) {\n        fileOutputStream.close();\n      }\n    }\n    LOG.info(\"Extract: \" + relativeExtractPath);\n  }","commit_id":"d1b339de17495ade167719d5f987ba588068f0dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testSimpleUnzip() throws Exception {\n    File tempDir = FileUtil.createTempDirectory(\"unzip-test-\", null);\n    File simpleZipFile = new File(getZipParentDir(), \"simple.zip\");\n    ZipInputStream stream = new ZipInputStream(new FileInputStream(simpleZipFile));\n    try {\n      ZipUtil.unzip(null, tempDir, stream, null, null, true);\n      checkFileStructure(tempDir, new String[] {\"a.txt\", \"dir/b.txt\"});\n    }\n    finally {\n      stream.close();\n    }\n  }","id":38583,"modified_method":"@Test\n  public void testSimpleUnzip() throws Exception {\n    File tempDir = FileUtil.createTempDirectory(\"unzip-test-\", null);\n    File simpleZipFile = new File(getZipParentDir(), \"simple.zip\");\n    ZipInputStream stream = new ZipInputStream(new FileInputStream(simpleZipFile));\n    try {\n      ZipUtil.unzip(null, tempDir, stream, null, null, true);\n      checkFileStructure(tempDir,\n                         fs()\n                           .file(\"a.txt\")\n                           .dir(\"dir\").file(\"b.txt\"));\n    }\n    finally {\n      stream.close();\n    }\n  }","commit_id":"d1b339de17495ade167719d5f987ba588068f0dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testSingleRootDirUnzip() throws Exception {\n    File tempDir = FileUtil.createTempDirectory(\"unzip-test-\", null);\n    File simpleZipFile = new File(getZipParentDir(), \"single-root-dir-archive.zip\");\n    ZipInputStream stream = new ZipInputStream(new FileInputStream(simpleZipFile));\n    try {\n      ZipUtil.unzip(null, tempDir, stream, null, null, true);\n      checkFileStructure(tempDir, new String[] {\"a.txt\", \"dir/b.txt\"});\n    }\n    finally {\n      stream.close();\n    }\n  }","id":38584,"modified_method":"@Test\n  public void testSingleRootDirUnzip() throws Exception {\n    File tempDir = FileUtil.createTempDirectory(\"unzip-test-\", null);\n    File simpleZipFile = new File(getZipParentDir(), \"single-root-dir-archive.zip\");\n    ZipInputStream stream = new ZipInputStream(new FileInputStream(simpleZipFile));\n    try {\n      ZipUtil.unzip(null, tempDir, stream, null, null, true);\n      checkFileStructure(tempDir,\n                         fs()\n                           .file(\"a.txt\")\n                           .dir(\"dir\").file(\"b.txt\"));\n    }\n    finally {\n      stream.close();\n    }\n  }","commit_id":"d1b339de17495ade167719d5f987ba588068f0dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkFileStructure(@NotNull File parentDir, @NotNull String[] expectedPaths) {\n    List<String> paths = ContainerUtil.newArrayList();\n    collectPaths(parentDir, paths, \"\");\n    String[] actualPaths = ArrayUtil.toStringArray(paths);\n\n    Arrays.sort(expectedPaths);\n    Arrays.sort(actualPaths);\n    Assert.assertArrayEquals(expectedPaths, actualPaths);\n  }","id":38585,"modified_method":"private static void checkFileStructure(@NotNull File parentDir, @NotNull TestFileSystemBuilder expected) {\n    expected.build().assertDirectoryEqual(parentDir);\n  }","commit_id":"d1b339de17495ade167719d5f987ba588068f0dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Main()\n   {\n      mainFrame = new JFrame(\"Drools Sudoku Example\");\n      for (String sampleName : SudokuGridSamples.getInstance().getSampleNames())\n      {\n         JMenuItem menuItem = new JMenuItem(sampleName);\n         menuItem.addActionListener(this);\n         samplesMenu.add(menuItem);\n      }\n      fileMenu.add(samplesMenu);\n      openMenuItem.addActionListener(this);\n      // fileMenu.add(openMenuItem);\n      exitMenuItem.addActionListener(this);\n      fileMenu.add(exitMenuItem);\n      menuBar.add(fileMenu);\n      mainFrame.setJMenuBar(menuBar);\n      sudokuGridView = new SudokuGridView();\n      droolsSudokuGridModel = new DroolsSudokuGridModel(SudokuGridSamples.getInstance().getSample(\"Simple\"));\n      mainFrame.setLayout(borderLayout);\n      mainFrame.add(BorderLayout.CENTER, sudokuGridView);\n      // buttonPanel.add(fireOneRuleButton);\n      buttonPanel.add(solveButton);\n      solveButton.addActionListener(this);\n      mainFrame.add(BorderLayout.SOUTH, buttonPanel);\n      mainFrame.setSize(400,400);\n      mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n      mainFrame.setVisible(true);\n      sudokuGridView.setModel(droolsSudokuGridModel);\n   }","id":38586,"modified_method":"public Main() throws Exception{\n        mainFrame = new JFrame(\"Drools Sudoku Example\");\n        for (String sampleName : SudokuGridSamples.getInstance().getSampleNames()){\n            JMenuItem menuItem = new JMenuItem(sampleName);\n            menuItem.addActionListener(this);\n            samplesMenu.add(menuItem);\n        }\n        fileMenu.add(samplesMenu);\n        openMenuItem.addActionListener(this);\n        // fileMenu.add(openMenuItem);\n        exitMenuItem.addActionListener(this);\n        fileMenu.add(exitMenuItem);\n        menuBar.add(fileMenu);\n        mainFrame.setJMenuBar(menuBar);\n        sudokuGridView = new SudokuGridView();\n\n        KnowledgeBase kBase = DroolsUtil.readKnowledgeBase( \"/org/drools/examples/sudoku/sudoku.drl\" );\n        sudoku = new Sudoku( kBase );\n\n        mainFrame.setLayout(borderLayout);\n        mainFrame.add(BorderLayout.CENTER, sudokuGridView);\n        buttonPanel.add(solveButton);\n        solveButton.addActionListener(this);\n        buttonPanel.add(stepButton);\n        stepButton.addActionListener(this);\n        mainFrame.add(BorderLayout.SOUTH, buttonPanel);\n        mainFrame.setSize(400,400);\n        mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        mainFrame.setVisible(true);\n        sudokuGridView.setModel( sudoku );\n\n        sudoku.setCellValues( SudokuGridSamples.getInstance().getSample(\"Simple\") );\n    }","commit_id":"68774548e92a9dd04b62809cf3c896a0e7796e28","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void actionPerformed(ActionEvent ev)\n   {\n      if (ev.getSource().equals(solveButton))\n      {\n         long startTime = System.currentTimeMillis();\n\n         if (droolsSudokuGridModel.solve())\n         {\n            solveButton.setText(\"Solved (\"+(System.currentTimeMillis()-startTime)+\" ms)\");\n            solveButton.setEnabled(false);\n         }\n         else\n         {\n            solveButton.setText(\"Unsolved (\"+(System.currentTimeMillis()-startTime)+\" ms)\");\n            solveButton.setEnabled(false);            \n         }\n      }\n      else if (ev.getSource().equals(openMenuItem))\n      {\n         if (fileChooser == null)\n         {\n            fileChooser = new JFileChooser();\n         }\n         \n         try\n         {\n            if (fileChooser.showOpenDialog(mainFrame) == JFileChooser.APPROVE_OPTION)\n            {\n               System.out.println(fileChooser.getSelectedFile().getCanonicalPath());\n            }\n         }\n         catch (IOException ex)\n         {\n            ex.printStackTrace();\n         }\n      }\n      else if (ev.getSource().equals(exitMenuItem))\n      {\n         System.exit(0);\n      }\n      else if (ev.getSource() instanceof JMenuItem)\n      {\n         JMenuItem menuItem = (JMenuItem) ev.getSource();\n         droolsSudokuGridModel = new DroolsSudokuGridModel(SudokuGridSamples.getInstance().getSample(menuItem.getText()));\n         sudokuGridView.setModel(droolsSudokuGridModel);\n         solveButton.setText(\"Solve\");\n         solveButton.setEnabled(true);\n      }\n      else\n      {\n         //\n      }\n   }","id":38587,"modified_method":"public void actionPerformed(ActionEvent ev){\n        if( ev.getSource().equals(solveButton) ){\n            long startTime = System.currentTimeMillis();\n            sudoku.solve();\n            \n        } else  if( ev.getSource().equals(stepButton) ){\n            sudoku.step();\n           \n        } else if (ev.getSource().equals(openMenuItem)) {\n            if( fileChooser == null ){\n                fileChooser = new JFileChooser();\n            }\n\n            try {\n                if( fileChooser.showOpenDialog(mainFrame) == JFileChooser.APPROVE_OPTION ){\n                    System.out.println(fileChooser.getSelectedFile().getCanonicalPath());\n                }\n            } catch( IOException ex ){\n                ex.printStackTrace();\n            }\n            \n        } else if( ev.getSource().equals( exitMenuItem ) ){\n            System.exit(0);\n            \n        } else if( ev.getSource() instanceof JMenuItem ){\n            JMenuItem menuItem = (JMenuItem) ev.getSource();\n            sudoku.setCellValues( SudokuGridSamples.getInstance().getSample(menuItem.getText()) );\n        } else {\n            //\n        }\n    }","commit_id":"68774548e92a9dd04b62809cf3c896a0e7796e28","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void timeDownsampling(int reps) {\n        for(int i = 0; i < reps; i++) {\n            SAMFileReader reader = new SAMFileReader(inputFile);\n            ReadProperties readProperties = new ReadProperties(Collections.<SAMReaderID>singletonList(new SAMReaderID(inputFile,new Tags())),\n                                                               reader.getFileHeader(),\n                                                               false,\n                                                               SAMFileReader.ValidationStringency.SILENT,\n                                                               0,\n                                                               downsampling.create(),\n                                                               new ValidationExclusion(Collections.singletonList(ValidationExclusion.TYPE.ALL)),\n                                                               Collections.<ReadFilter>emptyList(),\n                                                               false,\n                                                               false,\n                                                               BAQ.CalculationMode.OFF,\n                                                               BAQ.QualityMode.DONT_MODIFY,\n                                                               null,\n                                                               (byte)0);\n\n            GenomeLocParser genomeLocParser = new GenomeLocParser(reader.getFileHeader().getSequenceDictionary());\n            SampleDataSource sampleDataSource = new SampleDataSource().addSamples(reader.getFileHeader());\n\n            // Filter unmapped reads.  TODO: is this always strictly necessary?  Who in the GATK normally filters these out?\n            Iterator<SAMRecord> readIterator = new FilteringIterator(reader.iterator(),new UnmappedReadFilter());\n            LocusIteratorByState locusIteratorByState = new LocusIteratorByState(readIterator,readProperties,genomeLocParser,sampleDataSource);\n            while(locusIteratorByState.hasNext()) {\n                locusIteratorByState.next().getLocation();\n            }\n            reader.close();\n        }\n    }","id":38588,"modified_method":"public void timeDownsampling(int reps) {\n        for(int i = 0; i < reps; i++) {\n            SAMFileReader reader = new SAMFileReader(inputFile);\n            ReadProperties readProperties = new ReadProperties(Collections.<SAMReaderID>singletonList(new SAMReaderID(inputFile,new Tags())),\n                                                               reader.getFileHeader(),\n                                                               false,\n                                                               SAMFileReader.ValidationStringency.SILENT,\n                                                               0,\n                                                               downsampling.create(),\n                                                               new ValidationExclusion(Collections.singletonList(ValidationExclusion.TYPE.ALL)),\n                                                               Collections.<ReadFilter>emptyList(),\n                                                               false,\n                                                               false,\n                                                               BAQ.CalculationMode.OFF,\n                                                               BAQ.QualityMode.DONT_MODIFY,\n                                                               null,\n                                                               (byte)0);\n\n            GenomeLocParser genomeLocParser = new GenomeLocParser(reader.getFileHeader().getSequenceDictionary());\n            SampleDataSource sampleDataSource = new SampleDataSource().addSamples(reader.getFileHeader());\n\n            // Filter unmapped reads.  TODO: is this always strictly necessary?  Who in the GATK normally filters these out?\n            Iterator<SAMRecord> readIterator = new FilteringIterator(reader.iterator(),new UnmappedReadFilter());\n            LocusIteratorByState locusIteratorByState = new LocusIteratorByState(readIterator,readProperties,genomeLocParser,sampleDataSource.getSampleNames());\n            while(locusIteratorByState.hasNext()) {\n                locusIteratorByState.next().getLocation();\n            }\n            reader.close();\n        }\n    }","commit_id":"9458f01409b5307981992bdeb7f26d460465f01f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testGetPileupForSample() {\n        Sample sample1 = new Sample(\"sample1\", null);\n        Sample sample2 = new Sample(\"sample2\", null);\n\n        SAMReadGroupRecord readGroupOne = new SAMReadGroupRecord(\"rg1\");\n        readGroupOne.setSample(sample1.getID());\n        SAMReadGroupRecord readGroupTwo = new SAMReadGroupRecord(\"rg2\");\n        readGroupTwo.setSample(sample2.getID());\n\n        SAMFileHeader header = ArtificialSAMUtils.createArtificialSamHeader(1,1,1000);\n        header.addReadGroup(readGroupOne);\n        header.addReadGroup(readGroupTwo);\n\n        SAMRecord read1 = ArtificialSAMUtils.createArtificialRead(header,\"read1\",0,1,10);\n        read1.setAttribute(\"RG\",readGroupOne.getId());\n        SAMRecord read2 = ArtificialSAMUtils.createArtificialRead(header,\"read2\",0,1,10);\n        read2.setAttribute(\"RG\",readGroupTwo.getId());\n\n        Map<Sample,ReadBackedPileupImpl> sampleToPileupMap = new HashMap<Sample,ReadBackedPileupImpl>();\n        sampleToPileupMap.put(sample1,new ReadBackedPileupImpl(null,Collections.singletonList(read1),0));\n        sampleToPileupMap.put(sample2,new ReadBackedPileupImpl(null,Collections.singletonList(read2),0));\n\n        ReadBackedPileup pileup = new ReadBackedPileupImpl(null,sampleToPileupMap);\n\n        ReadBackedPileup sample2Pileup = pileup.getPileupForSampleName(sample2.getID());\n        Assert.assertEquals(sample2Pileup.size(),1,\"Sample 2 pileup has wrong number of elements\");\n        Assert.assertEquals(sample2Pileup.getReads().get(0),read2,\"Sample 2 pileup has incorrect read\");\n\n        ReadBackedPileup missingSamplePileup = pileup.getPileupForSampleName(\"missing\");\n        Assert.assertNull(missingSamplePileup,\"Pileup for sample 'missing' should be null but isn't\");\n\n        missingSamplePileup = pileup.getPileupForSampleName(\"not here\");\n        Assert.assertNull(missingSamplePileup,\"Pileup for sample 'not here' should be null but isn't\");\n    }","id":38589,"modified_method":"@Test\n    public void testGetPileupForSample() {\n        String sample1 = \"sample1\";\n        String sample2 = \"sample2\";\n\n        SAMReadGroupRecord readGroupOne = new SAMReadGroupRecord(\"rg1\");\n        readGroupOne.setSample(sample1);\n        SAMReadGroupRecord readGroupTwo = new SAMReadGroupRecord(\"rg2\");\n        readGroupTwo.setSample(sample2);\n\n        SAMFileHeader header = ArtificialSAMUtils.createArtificialSamHeader(1,1,1000);\n        header.addReadGroup(readGroupOne);\n        header.addReadGroup(readGroupTwo);\n\n        SAMRecord read1 = ArtificialSAMUtils.createArtificialRead(header,\"read1\",0,1,10);\n        read1.setAttribute(\"RG\",readGroupOne.getId());\n        SAMRecord read2 = ArtificialSAMUtils.createArtificialRead(header,\"read2\",0,1,10);\n        read2.setAttribute(\"RG\",readGroupTwo.getId());\n\n        Map<String,ReadBackedPileupImpl> sampleToPileupMap = new HashMap<String,ReadBackedPileupImpl>();\n        sampleToPileupMap.put(sample1,new ReadBackedPileupImpl(null,Collections.singletonList(read1),0));\n        sampleToPileupMap.put(sample2,new ReadBackedPileupImpl(null,Collections.singletonList(read2),0));\n\n        ReadBackedPileup pileup = new ReadBackedPileupImpl(null,sampleToPileupMap);\n\n        ReadBackedPileup sample2Pileup = pileup.getPileupForSampleName(sample2);\n        Assert.assertEquals(sample2Pileup.size(),1,\"Sample 2 pileup has wrong number of elements\");\n        Assert.assertEquals(sample2Pileup.getReads().get(0),read2,\"Sample 2 pileup has incorrect read\");\n\n        ReadBackedPileup missingSamplePileup = pileup.getPileupForSampleName(\"missing\");\n        Assert.assertNull(missingSamplePileup,\"Pileup for sample 'missing' should be null but isn't\");\n\n        missingSamplePileup = pileup.getPileupForSampleName(\"not here\");\n        Assert.assertNull(missingSamplePileup,\"Pileup for sample 'not here' should be null but isn't\");\n    }","commit_id":"9458f01409b5307981992bdeb7f26d460465f01f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Ensure that splitting read groups still works when dealing with a sample-split pileup.\n     */\n    @Test\n    public void testSplitBySample() {\n        SAMReadGroupRecord readGroupOne = new SAMReadGroupRecord(\"rg1\");\n        readGroupOne.setSample(\"sample1\");\n        SAMReadGroupRecord readGroupTwo = new SAMReadGroupRecord(\"rg2\");\n        readGroupTwo.setSample(\"sample2\");\n\n        SAMFileHeader header = ArtificialSAMUtils.createArtificialSamHeader(1,1,1000);\n        header.addReadGroup(readGroupOne);\n        header.addReadGroup(readGroupTwo);\n\n        SAMRecord read1 = ArtificialSAMUtils.createArtificialRead(header,\"read1\",0,1,10);\n        read1.setAttribute(\"RG\",readGroupOne.getId());\n        SAMRecord read2 = ArtificialSAMUtils.createArtificialRead(header,\"read2\",0,1,10);\n        read2.setAttribute(\"RG\",readGroupTwo.getId());\n        SAMRecord read3 = ArtificialSAMUtils.createArtificialRead(header,\"read3\",0,1,10);\n        read3.setAttribute(\"RG\",readGroupOne.getId());\n        SAMRecord read4 = ArtificialSAMUtils.createArtificialRead(header,\"read4\",0,1,10);\n        read4.setAttribute(\"RG\",readGroupTwo.getId());\n\n        ReadBackedPileupImpl sample1Pileup = new ReadBackedPileupImpl(null,\n                                                                      Arrays.asList(read1,read3),\n                                                                      Arrays.asList(1,1));\n        ReadBackedPileupImpl sample2Pileup = new ReadBackedPileupImpl(null,\n                                                                      Arrays.asList(read2,read4),\n                                                                      Arrays.asList(1,1));\n        Map<Sample,ReadBackedPileupImpl> sampleToPileupMap = new HashMap<Sample,ReadBackedPileupImpl>();\n        sampleToPileupMap.put(new Sample(readGroupOne.getSample(), null),sample1Pileup);\n        sampleToPileupMap.put(new Sample(readGroupTwo.getSample(), null),sample2Pileup);\n\n        ReadBackedPileup compositePileup = new ReadBackedPileupImpl(null,sampleToPileupMap);\n\n        ReadBackedPileup rg1Pileup = compositePileup.getPileupForReadGroup(\"rg1\");\n        List<SAMRecord> rg1Reads = rg1Pileup.getReads();\n\n        Assert.assertEquals(rg1Reads.size(), 2, \"Wrong number of reads in read group rg1\");\n        Assert.assertEquals(rg1Reads.get(0), read1, \"Read \" + read1.getReadName() + \" should be in rg1 but isn't\");\n        Assert.assertEquals(rg1Reads.get(1), read3, \"Read \" + read3.getReadName() + \" should be in rg1 but isn't\");\n\n        ReadBackedPileup rg2Pileup = compositePileup.getPileupForReadGroup(\"rg2\");\n        List<SAMRecord> rg2Reads = rg2Pileup.getReads();\n\n        Assert.assertEquals(rg1Reads.size(), 2, \"Wrong number of reads in read group rg2\");\n        Assert.assertEquals(rg2Reads.get(0), read2, \"Read \" + read2.getReadName() + \" should be in rg2 but isn't\");\n        Assert.assertEquals(rg2Reads.get(1), read4, \"Read \" + read4.getReadName() + \" should be in rg2 but isn't\");\n    }","id":38590,"modified_method":"/**\n     * Ensure that splitting read groups still works when dealing with a sample-split pileup.\n     */\n    @Test\n    public void testSplitBySample() {\n        SAMReadGroupRecord readGroupOne = new SAMReadGroupRecord(\"rg1\");\n        readGroupOne.setSample(\"sample1\");\n        SAMReadGroupRecord readGroupTwo = new SAMReadGroupRecord(\"rg2\");\n        readGroupTwo.setSample(\"sample2\");\n\n        SAMFileHeader header = ArtificialSAMUtils.createArtificialSamHeader(1,1,1000);\n        header.addReadGroup(readGroupOne);\n        header.addReadGroup(readGroupTwo);\n\n        SAMRecord read1 = ArtificialSAMUtils.createArtificialRead(header,\"read1\",0,1,10);\n        read1.setAttribute(\"RG\",readGroupOne.getId());\n        SAMRecord read2 = ArtificialSAMUtils.createArtificialRead(header,\"read2\",0,1,10);\n        read2.setAttribute(\"RG\",readGroupTwo.getId());\n        SAMRecord read3 = ArtificialSAMUtils.createArtificialRead(header,\"read3\",0,1,10);\n        read3.setAttribute(\"RG\",readGroupOne.getId());\n        SAMRecord read4 = ArtificialSAMUtils.createArtificialRead(header,\"read4\",0,1,10);\n        read4.setAttribute(\"RG\",readGroupTwo.getId());\n\n        ReadBackedPileupImpl sample1Pileup = new ReadBackedPileupImpl(null,\n                                                                      Arrays.asList(read1,read3),\n                                                                      Arrays.asList(1,1));\n        ReadBackedPileupImpl sample2Pileup = new ReadBackedPileupImpl(null,\n                                                                      Arrays.asList(read2,read4),\n                                                                      Arrays.asList(1,1));\n        Map<String,ReadBackedPileupImpl> sampleToPileupMap = new HashMap<String,ReadBackedPileupImpl>();\n        sampleToPileupMap.put(readGroupOne.getSample(),sample1Pileup);\n        sampleToPileupMap.put(readGroupTwo.getSample(),sample2Pileup);\n\n        ReadBackedPileup compositePileup = new ReadBackedPileupImpl(null,sampleToPileupMap);\n\n        ReadBackedPileup rg1Pileup = compositePileup.getPileupForReadGroup(\"rg1\");\n        List<SAMRecord> rg1Reads = rg1Pileup.getReads();\n\n        Assert.assertEquals(rg1Reads.size(), 2, \"Wrong number of reads in read group rg1\");\n        Assert.assertEquals(rg1Reads.get(0), read1, \"Read \" + read1.getReadName() + \" should be in rg1 but isn't\");\n        Assert.assertEquals(rg1Reads.get(1), read3, \"Read \" + read3.getReadName() + \" should be in rg1 but isn't\");\n\n        ReadBackedPileup rg2Pileup = compositePileup.getPileupForReadGroup(\"rg2\");\n        List<SAMRecord> rg2Reads = rg2Pileup.getReads();\n\n        Assert.assertEquals(rg1Reads.size(), 2, \"Wrong number of reads in read group rg2\");\n        Assert.assertEquals(rg2Reads.get(0), read2, \"Read \" + read2.getReadName() + \" should be in rg2 but isn't\");\n        Assert.assertEquals(rg2Reads.get(1), read4, \"Read \" + read4.getReadName() + \" should be in rg2 but isn't\");\n    }","commit_id":"9458f01409b5307981992bdeb7f26d460465f01f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n\t\t * @see org.apache.wicket.markup.html.form.Form#onSubmit()\n\t\t */\n\t\tpublic final void onSubmit()\n\t\t{\n\t\t\tif (signIn(getUsername(), getPassword()))\n\t\t\t{\n\t\t\t\t// If login has been called because the user was not yet\n\t\t\t\t// logged in, than continue to the original destination,\n\t\t\t\t// otherwise to the Home page\n\t\t\t\tif (!continueToOriginalDestination())\n\t\t\t\t{\n\t\t\t\t\tsetResponsePage(getApplication().getSessionSettings().getPageFactory().newPage(\n\t\t\t\t\t\t\tgetApplication().getHomePage(), (PageParameters)null));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Try the component based localizer first. If not found try the\n\t\t\t\t// application localizer. Else use the default\n\t\t\t\tfinal String errmsg = getLocalizer().getString(\"loginError\", this,\n\t\t\t\t\t\t\"Unable to sign you in\");\n\n\t\t\t\terror(errmsg);\n\t\t\t}\n\t\t}","id":38591,"modified_method":"/**\n\t\t * @see org.apache.wicket.markup.html.form.Form#onSubmit()\n\t\t */\n\t\tpublic final void onSubmit()\n\t\t{\n\t\t\tif (signIn(getUsername(), getPassword()))\n\t\t\t{\n\t\t\t\t// If login has been called because the user was not yet\n\t\t\t\t// logged in, than continue to the original destination,\n\t\t\t\t// otherwise to the Home page\n\t\t\t\tif (!continueToOriginalDestination())\n\t\t\t\t{\n\t\t\t\t\tsetResponsePage(getApplication().getHomePage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Try the component based localizer first. If not found try the\n\t\t\t\t// application localizer. Else use the default\n\t\t\t\tfinal String errmsg = getLocalizer().getString(\"loginError\", this,\n\t\t\t\t\t\t\"Unable to sign you in\");\n\n\t\t\t\terror(errmsg);\n\t\t\t}\n\t\t}","commit_id":"c82dac387af28314a94243bc8d0a49a48827b19a","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Called when sign in was successful\n\t */\n\tprotected void onSignInSucceeded()\n\t{\n\t\t// If login has been called because the user was not yet logged in, than continue to the\n\t\t// original destination, otherwise to the Home page\n\t\tif (!continueToOriginalDestination())\n\t\t{\n\t\t\tsetResponsePage(getApplication().getSessionSettings().getPageFactory().newPage(\n\t\t\t\tgetApplication().getHomePage()));\n\t\t}\n\t}","id":38592,"modified_method":"/**\n\t * Called when sign in was successful\n\t */\n\tprotected void onSignInSucceeded()\n\t{\n\t\t// If login has been called because the user was not yet logged in, than continue to the\n\t\t// original destination, otherwise to the Home page\n\t\tif (!continueToOriginalDestination())\n\t\t{\n\t\t\tsetResponsePage(getApplication().getHomePage());\n\t\t}\n\t}","commit_id":"3de9d5dcd22086b054593dc510cfc93b0224e06d","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n  protected XContentBuilder getMapping() throws IOException {\n    XContentBuilder mapping = jsonBuilder().startObject()\n      .startObject(this.getType())\n      .field(\"dynamic\", true)\n      .startObject(\"properties\");\n\n    addMatchField(mapping, RuleField.KEY.key(), \"string\");\n    addMatchField(mapping, RuleField.REPOSITORY.key(), \"string\");\n    addMatchField(mapping, RuleField.SEVERITY.key(), \"string\");\n    addMatchField(mapping, RuleField.STATUS.key(), \"string\");\n\n    mapping.startObject(RuleField.NAME.key())\n        .field(\"type\", \"multi_field\")\n        .startObject(\"fields\")\n          .startObject(RuleField.NAME.key())\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n          .endObject()\n          .startObject(\"search\")\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n            .field(\"index_analyzer\", \"rule_name\")\n            .field(\"search_analyzer\", \"standard\")\n          .endObject()\n        .endObject()\n      .endObject();\n\n    mapping.startObject(\"active\")\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    mapping.startObject(\"params\")\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    return mapping.endObject()\n      .endObject().endObject();\n  }","id":38593,"modified_method":"@Override\n  protected XContentBuilder getMapping() throws IOException {\n    XContentBuilder mapping = jsonBuilder().startObject()\n      .startObject(this.getType())\n      .field(\"dynamic\", true)\n      .startObject(\"properties\");\n\n    addMatchField(mapping, RuleField.KEY.key(), \"string\");\n    addMatchField(mapping, RuleField.REPOSITORY.key(), \"string\");\n    addMatchField(mapping, RuleField.SEVERITY.key(), \"string\");\n    addMatchField(mapping, RuleField.STATUS.key(), \"string\");\n\n    mapping.startObject(RuleField.NAME.key())\n        .field(\"type\", \"multi_field\")\n        .startObject(\"fields\")\n          .startObject(RuleField.NAME.key())\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n          .endObject()\n          .startObject(\"search\")\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n            .field(\"index_analyzer\", \"rule_name\")\n            .field(\"search_analyzer\", \"standard\")\n          .endObject()\n        .endObject()\n      .endObject();\n\n    mapping.startObject(RuleField.ACTIVE.key())\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    mapping.startObject(RuleField.PARAMS.key())\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    return mapping.endObject()\n      .endObject().endObject();\n  }","commit_id":"2f413656329e579ebc61ce9fbbf034755d5c69c4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public XContentBuilder normalize(RuleDto rule) throws IOException {\n    XContentBuilder document = jsonBuilder().startObject();\n    indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n    indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n    indexField(RuleField.NAME.key(), rule.getName(), document);\n    indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n    indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n    indexField(RuleField.DESCRIPTION.key(), rule.getDescription(), document);\n    indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n    indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n    indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n    indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n    indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n\n    /* Normalize the tags */\n    List<RuleRuleTagDto> tags = ruleDao.selectTagsByRuleId(rule.getId());\n    if (!tags.isEmpty()) {\n      XContentBuilder sysTags = document.startArray(RuleField.SYSTEM_TAGS.key());\n      XContentBuilder adminTags = document.startArray(RuleField.TAGS.key());\n\n      for (RuleRuleTagDto tag : tags) {\n        switch (tag.getType()) {\n          case SYSTEM:\n            sysTags.startObject(tag.getTag()).endObject();\n            break;\n          case ADMIN:\n            adminTags.startObject(tag.getTag()).endObject();\n            break;\n        }\n      }\n      sysTags.endArray();\n      adminTags.endArray();\n    }\n\n    /* Normalize the params */\n    List<RuleParamDto> params = ruleDao.selectParametersByRuleId(rule.getId());\n    if (!params.isEmpty()) {\n      document.startArray(RuleField.PARAMS.key());\n      for (RuleParamDto param :params) {\n        document.startObject();\n        indexField(RuleParamField.NAME.key(), param.getName(), document);\n        indexField(RuleParamField.TYPE.key(), param.getType(), document);\n        indexField(RuleParamField.DESCRIPTION.key(), param.getDescription(), document);\n        indexField(RuleParamField.DEFAULT_VALUE.key(), param.getDefaultValue(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Normalize activeRules */\n    List<ActiveRuleDto> activeRules = activeRuleDao.selectByRuleId(rule.getId());\n    if(!activeRules.isEmpty()) {\n      document.startArray(RuleField.ACTIVE.key());\n      for (ActiveRuleDto activeRule : activeRules) {\n        document.startObject();\n        indexField(ActiveRuleField.OVERRIDE.key(), activeRule.doesOverride(), document);\n        indexField(ActiveRuleField.INHERITANCE.key(), activeRule.getInheritance(), document);\n        indexField(ActiveRuleField.NOTE_CREATED.key(), activeRule.getNoteCreatedAt(), document);\n        indexField(ActiveRuleField.NOTE_UPDATED.key(), activeRule.getNoteUpdatedAt(), document);\n        indexField(ActiveRuleField.NOTE_DATA.key(), activeRule.getNoteData(), document);\n        indexField(ActiveRuleField.NOTE_USER.key(), activeRule.getNoteUserLogin(), document);\n        indexField(ActiveRuleField.PROFILE_ID.key(), activeRule.getProfileId(), document);\n        indexField(ActiveRuleField.SEVERITY.key(), activeRule.getSeverityString(), document);\n        indexField(ActiveRuleField.PARENT_ID.key(), activeRule.getParentId(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Done normalizing for Rule */\n    return document.endObject();\n  }","id":38594,"modified_method":"@Override\n  public XContentBuilder normalize(RuleDto rule) throws IOException {\n    XContentBuilder document = jsonBuilder().startObject();\n    indexField(RuleField.KEY.key(), rule.getRuleKey(), document);\n    indexField(RuleField.REPOSITORY.key(), rule.getRepositoryKey(), document);\n    indexField(RuleField.NAME.key(), rule.getName(), document);\n    indexField(RuleField.CREATED_AT.key(), rule.getCreatedAt(), document);\n    indexField(RuleField.UPDATED_AT.key(), rule.getUpdatedAt(), document);\n    indexField(RuleField.DESCRIPTION.key(), rule.getDescription(), document);\n    indexField(RuleField.SEVERITY.key(), rule.getSeverityString(), document);\n    indexField(RuleField.STATUS.key(), rule.getStatus(), document);\n    indexField(RuleField.LANGUAGE.key(), rule.getLanguage(), document);\n    indexField(RuleField.INTERNAL_KEY.key(), rule.getConfigKey(), document);\n    indexField(RuleField.TEMPLATE.key(), rule.getCardinality() == Cardinality.MULTIPLE, document);\n\n\n    /* Normalize the tags */\n    List<RuleRuleTagDto> tags = ruleDao.selectTagsByRuleId(rule.getId());\n    if (tags != null && !tags.isEmpty()) {\n      ArrayList<String> sys = new ArrayList<String>();\n      ArrayList<String> admin = new ArrayList<String>();\n      for (RuleRuleTagDto tag : tags) {\n        if (tag.getType().equals(RuleTagType.SYSTEM)) {\n          sys.add(tag.getTag());\n        } else {\n          admin.add(tag.getTag());\n        }\n      }\n      if (!admin.isEmpty()) {\n        document.array(RuleField.TAGS.key(), admin.toArray(new String[admin.size()]));\n      }\n      if (!sys.isEmpty()) {\n        document.array(RuleField.SYSTEM_TAGS.key(), sys.toArray(new String[sys.size()]));\n      }\n    }\n\n    /* Normalize the params */\n    List<RuleParamDto> params = ruleDao.selectParametersByRuleId(rule.getId());\n    if (!params.isEmpty()) {\n      document.startArray(RuleField.PARAMS.key());\n      for (RuleParamDto param : params) {\n        document.startObject();\n        indexField(RuleParamField.NAME.key(), param.getName(), document);\n        indexField(RuleParamField.TYPE.key(), param.getType(), document);\n        indexField(RuleParamField.DESCRIPTION.key(), param.getDescription(), document);\n        indexField(RuleParamField.DEFAULT_VALUE.key(), param.getDefaultValue(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Normalize activeRules */\n    List<ActiveRuleDto> activeRules = activeRuleDao.selectByRuleId(rule.getId());\n    if (!activeRules.isEmpty()) {\n      document.startArray(RuleField.ACTIVE.key());\n      for (ActiveRuleDto activeRule : activeRules) {\n        document.startObject();\n        indexField(ActiveRuleField.OVERRIDE.key(), activeRule.doesOverride(), document);\n        indexField(ActiveRuleField.INHERITANCE.key(), activeRule.getInheritance(), document);\n        indexField(ActiveRuleField.NOTE_CREATED.key(), activeRule.getNoteCreatedAt(), document);\n        indexField(ActiveRuleField.NOTE_UPDATED.key(), activeRule.getNoteUpdatedAt(), document);\n        indexField(ActiveRuleField.NOTE_DATA.key(), activeRule.getNoteData(), document);\n        indexField(ActiveRuleField.NOTE_USER.key(), activeRule.getNoteUserLogin(), document);\n        indexField(ActiveRuleField.PROFILE_ID.key(), activeRule.getProfileId(), document);\n        indexField(ActiveRuleField.SEVERITY.key(), activeRule.getSeverityString(), document);\n        indexField(ActiveRuleField.PARENT_ID.key(), activeRule.getParentId(), document);\n        document.endObject();\n      }\n      document.endArray();\n    }\n\n    /* Done normalizing for Rule */\n    return document.endObject();\n  }","commit_id":"2f413656329e579ebc61ce9fbbf034755d5c69c4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void handleEvent (NativeEvent e) {\r\n\t\tif (e.getType().equals(\"mousedown\")) {\r\n\t\t\tif (!e.getEventTarget().equals(canvas) || touched[0]) {\r\n\t\t\t\tfloat mouseX = (int)getRelativeX(e, canvas);\r\n\t\t\t\tfloat mouseY = (int)getRelativeY(e, canvas);\r\n\t\t\t\tif (mouseX < 0 || mouseX > Gdx.graphics.getWidth() || mouseY < 0 || mouseY > Gdx.graphics.getHeight()) {\r\n\t\t\t\t\thasFocus = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thasFocus = true;\r\n\t\t\tthis.justTouched = true;\r\n\t\t\tthis.touched[0] = true;\r\n\t\t\tthis.pressedButtons.add(getButton(e.getButton()));\r\n\t\t\tthis.deltaX[0] = 0;\r\n\t\t\tthis.deltaY[0] = 0;\r\n\t\t\tif (isCursorCatched()) {\r\n\t\t\t\tthis.touchX[0] += getMovementXJSNI(e);\r\n\t\t\t\tthis.touchY[0] += getMovementYJSNI(e);\r\n\t\t\t} else {\r\n\t\t\t\tthis.touchX[0] = (int)getRelativeX(e, canvas);\r\n\t\t\t\tthis.touchY[0] = (int)getRelativeY(e, canvas);\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\tif (processor != null) processor.touchDown(touchX[0], touchY[0], 0, getButton(e.getButton()));\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"mousemove\")) {\r\n\t\t\tif (isCursorCatched()) {\r\n\t\t\t\tthis.deltaX[0] = (int)getMovementXJSNI(e);\r\n\t\t\t\tthis.deltaY[0] = (int)getMovementYJSNI(e);\r\n\t\t\t\tthis.touchX[0] += getMovementXJSNI(e);\r\n\t\t\t\tthis.touchY[0] += getMovementYJSNI(e);\r\n\t\t\t} else {\r\n\t\t\t\tthis.deltaX[0] = (int)getRelativeX(e, canvas) - touchX[0];\r\n\t\t\t\tthis.deltaY[0] = (int)getRelativeY(e, canvas) - touchY[0];\r\n\t\t\t\tthis.touchX[0] = (int)getRelativeX(e, canvas);\r\n\t\t\t\tthis.touchY[0] = (int)getRelativeY(e, canvas);\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tif (touched[0])\r\n\t\t\t\t\tprocessor.touchDragged(touchX[0], touchY[0], 0);\r\n\t\t\t\telse\r\n\t\t\t\t\tprocessor.mouseMoved(touchX[0], touchY[0]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"mouseup\")) {\r\n\t\t\tif (!touched[0]) return;\r\n\t\t\tthis.pressedButtons.remove(getButton(e.getButton()));\r\n\t\t\tthis.touched[0] = pressedButtons.size > 0;\r\n\t\t\tif (isCursorCatched()) {\r\n\t\t\t\tthis.deltaX[0] = (int)getMovementXJSNI(e);\r\n\t\t\t\tthis.deltaY[0] = (int)getMovementYJSNI(e);\r\n\t\t\t\tthis.touchX[0] += getMovementXJSNI(e);\r\n\t\t\t\tthis.touchY[0] += getMovementYJSNI(e);\r\n\t\t\t} else {\r\n\t\t\t\tthis.deltaX[0] = (int)getRelativeX(e, canvas) - touchX[0];\r\n\t\t\t\tthis.deltaY[0] = (int)getRelativeY(e, canvas) - touchY[0];\r\n\t\t\t\tthis.touchX[0] = (int)getRelativeX(e, canvas);\r\n\t\t\t\tthis.touchY[0] = (int)getRelativeY(e, canvas);\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\tthis.touched[0] = false;\r\n\t\t\tif (processor != null) processor.touchUp(touchX[0], touchY[0], 0, getButton(e.getButton()));\r\n\t\t}\r\n\t\tif (e.getType().equals(getMouseWheelEvent())) {\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tprocessor.scrolled((int) getMouseWheelVelocity(e));\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"keydown\") && hasFocus) {\r\n\t\t\t//System.out.println(\"keydown\");\r\n\t\t\tint code = keyForCode(e.getKeyCode());\r\n\t\t\tif (code == 67) {\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.keyDown(code);\r\n\t\t\t\t\tprocessor.keyTyped('\\b');\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!pressedKeys[code]) {\r\n\t\t\t\t\tpressedKeyCount++;\r\n\t\t\t\t\tpressedKeys[code] = true;\r\n\t\t\t\t\tkeyJustPressed = true;\r\n\t\t\t\t\tjustPressedKeys[code] = true;\r\n\t\t\t\t\tif (processor != null) {\r\n\t\t\t\t\t\tprocessor.keyDown(code);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"keypress\") && hasFocus) {\r\n\t\t\t//System.out.println(\"keypress\");\r\n\t\t\tchar c = (char)e.getCharCode();\r\n\t\t\tif (processor != null) processor.keyTyped(c);\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"keyup\") && hasFocus) {\r\n\t\t\t//System.out.println(\"keyup\");\r\n\t\t\tint code = keyForCode(e.getKeyCode());\r\n\t\t\tif (pressedKeys[code]) {\r\n\t\t\t\tpressedKeyCount--;\r\n\t\t\t\tpressedKeys[code] = false;\r\n\t\t\t}\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tprocessor.keyUp(code);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"touchstart\")) {\r\n\t\t\tthis.justTouched = true;\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\ttouched[touchId] = true;\r\n\t\t\t\ttouchX[touchId] = touch.getRelativeX(canvas);\r\n\t\t\t\ttouchY[touchId] = touch.getRelativeY(canvas);\r\n\t\t\t\tdeltaX[touchId] = 0;\r\n\t\t\t\tdeltaY[touchId] = 0;\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchDown(touchX[touchId], touchY[touchId], touchId, Buttons.LEFT);\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"touchmove\")) {\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\tdeltaX[touchId] = touch.getRelativeX(canvas) - touchX[touchId];\r\n\t\t\t\tdeltaY[touchId] = touch.getRelativeY(canvas) - touchY[touchId];\r\n\t\t\t\ttouchX[touchId] = touch.getRelativeX(canvas);\r\n\t\t\t\ttouchY[touchId] = touch.getRelativeY(canvas);\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchDragged(touchX[touchId], touchY[touchId], touchId);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"touchcancel\")) {\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\ttouched[touchId] = false;\r\n\t\t\t\tdeltaX[touchId] = touch.getRelativeX(canvas) - touchX[touchId];\r\n\t\t\t\tdeltaY[touchId] = touch.getRelativeY(canvas) - touchY[touchId];\t\t\t\t\r\n\t\t\t\ttouchX[touchId] = touch.getRelativeX(canvas);\r\n\t\t\t\ttouchY[touchId] = touch.getRelativeY(canvas);\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchUp(touchX[touchId], touchY[touchId], touchId, Buttons.LEFT);\r\n\t\t\t\t}\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"touchend\")) {\t\t\t\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\ttouched[touchId] = false;\r\n\t\t\t\tdeltaX[touchId] = touch.getRelativeX(canvas) - touchX[touchId];\r\n\t\t\t\tdeltaY[touchId] = touch.getRelativeY(canvas) - touchY[touchId];\t\t\t\t\r\n\t\t\t\ttouchX[touchId] = touch.getRelativeX(canvas);\r\n\t\t\t\ttouchY[touchId] = touch.getRelativeY(canvas);\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchUp(touchX[touchId], touchY[touchId], touchId, Buttons.LEFT);\r\n\t\t\t\t}\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n// if(hasFocus) e.preventDefault();\r\n\t}","id":38595,"modified_method":"private void handleEvent (NativeEvent e) {\r\n\t\tif (e.getType().equals(\"mousedown\")) {\r\n\t\t\tif (!e.getEventTarget().equals(canvas) || touched[0]) {\r\n\t\t\t\tfloat mouseX = getRelativeX(e, canvas);\r\n\t\t\t\tfloat mouseY = getRelativeY(e, canvas);\r\n\t\t\t\tif (mouseX < 0 || mouseX > Gdx.graphics.getWidth() || mouseY < 0 || mouseY > Gdx.graphics.getHeight()) {\r\n\t\t\t\t\thasFocus = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thasFocus = true;\r\n\t\t\tthis.justTouched = true;\r\n\t\t\tthis.touched[0] = true;\r\n\t\t\tthis.pressedButtons.add(getButton(e.getButton()));\r\n\t\t\tthis.deltaX[0] = 0;\r\n\t\t\tthis.deltaY[0] = 0;\r\n\t\t\tif (isCursorCatched()) {\r\n\t\t\t\tthis.touchX[0] += getMovementXJSNI(e);\r\n\t\t\t\tthis.touchY[0] += getMovementYJSNI(e);\r\n\t\t\t} else {\r\n\t\t\t\tthis.touchX[0] = getRelativeX(e, canvas);\r\n\t\t\t\tthis.touchY[0] = getRelativeY(e, canvas);\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\tif (processor != null) processor.touchDown(touchX[0], touchY[0], 0, getButton(e.getButton()));\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"mousemove\")) {\r\n\t\t\tif (isCursorCatched()) {\r\n\t\t\t\tthis.deltaX[0] = (int)getMovementXJSNI(e);\r\n\t\t\t\tthis.deltaY[0] = (int)getMovementYJSNI(e);\r\n\t\t\t\tthis.touchX[0] += getMovementXJSNI(e);\r\n\t\t\t\tthis.touchY[0] += getMovementYJSNI(e);\r\n\t\t\t} else {\r\n\t\t\t\tthis.deltaX[0] = getRelativeX(e, canvas) - touchX[0];\r\n\t\t\t\tthis.deltaY[0] = getRelativeY(e, canvas) - touchY[0];\r\n\t\t\t\tthis.touchX[0] = getRelativeX(e, canvas);\r\n\t\t\t\tthis.touchY[0] = getRelativeY(e, canvas);\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tif (touched[0])\r\n\t\t\t\t\tprocessor.touchDragged(touchX[0], touchY[0], 0);\r\n\t\t\t\telse\r\n\t\t\t\t\tprocessor.mouseMoved(touchX[0], touchY[0]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"mouseup\")) {\r\n\t\t\tif (!touched[0]) return;\r\n\t\t\tthis.pressedButtons.remove(getButton(e.getButton()));\r\n\t\t\tthis.touched[0] = pressedButtons.size > 0;\r\n\t\t\tif (isCursorCatched()) {\r\n\t\t\t\tthis.deltaX[0] = (int)getMovementXJSNI(e);\r\n\t\t\t\tthis.deltaY[0] = (int)getMovementYJSNI(e);\r\n\t\t\t\tthis.touchX[0] += getMovementXJSNI(e);\r\n\t\t\t\tthis.touchY[0] += getMovementYJSNI(e);\r\n\t\t\t} else {\r\n\t\t\t\tthis.deltaX[0] = getRelativeX(e, canvas) - touchX[0];\r\n\t\t\t\tthis.deltaY[0] = getRelativeY(e, canvas) - touchY[0];\r\n\t\t\t\tthis.touchX[0] = getRelativeX(e, canvas);\r\n\t\t\t\tthis.touchY[0] = getRelativeY(e, canvas);\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\tthis.touched[0] = false;\r\n\t\t\tif (processor != null) processor.touchUp(touchX[0], touchY[0], 0, getButton(e.getButton()));\r\n\t\t}\r\n\t\tif (e.getType().equals(getMouseWheelEvent())) {\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tprocessor.scrolled((int)getMouseWheelVelocity(e));\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"keydown\") && hasFocus) {\r\n\t\t\t// System.out.println(\"keydown\");\r\n\t\t\tint code = keyForCode(e.getKeyCode());\r\n\t\t\tif (code == 67) {\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.keyDown(code);\r\n\t\t\t\t\tprocessor.keyTyped('\\b');\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!pressedKeys[code]) {\r\n\t\t\t\t\tpressedKeyCount++;\r\n\t\t\t\t\tpressedKeys[code] = true;\r\n\t\t\t\t\tkeyJustPressed = true;\r\n\t\t\t\t\tjustPressedKeys[code] = true;\r\n\t\t\t\t\tif (processor != null) {\r\n\t\t\t\t\t\tprocessor.keyDown(code);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"keypress\") && hasFocus) {\r\n\t\t\t// System.out.println(\"keypress\");\r\n\t\t\tchar c = (char)e.getCharCode();\r\n\t\t\tif (processor != null) processor.keyTyped(c);\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"keyup\") && hasFocus) {\r\n\t\t\t// System.out.println(\"keyup\");\r\n\t\t\tint code = keyForCode(e.getKeyCode());\r\n\t\t\tif (pressedKeys[code]) {\r\n\t\t\t\tpressedKeyCount--;\r\n\t\t\t\tpressedKeys[code] = false;\r\n\t\t\t}\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tprocessor.keyUp(code);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (e.getType().equals(\"touchstart\")) {\r\n\t\t\tthis.justTouched = true;\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\ttouched[touchId] = true;\r\n\t\t\t\ttouchX[touchId] = getRelativeX(touch, canvas);\r\n\t\t\t\ttouchY[touchId] = getRelativeY(touch, canvas);\r\n\t\t\t\tdeltaX[touchId] = 0;\r\n\t\t\t\tdeltaY[touchId] = 0;\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchDown(touchX[touchId], touchY[touchId], touchId, Buttons.LEFT);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"touchmove\")) {\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\tdeltaX[touchId] = getRelativeX(touch, canvas) - touchX[touchId];\r\n\t\t\t\tdeltaY[touchId] = getRelativeY(touch, canvas) - touchY[touchId];\r\n\t\t\t\ttouchX[touchId] = getRelativeX(touch, canvas);\r\n\t\t\t\ttouchY[touchId] = getRelativeY(touch, canvas);\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchDragged(touchX[touchId], touchY[touchId], touchId);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"touchcancel\")) {\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\ttouched[touchId] = false;\r\n\t\t\t\tdeltaX[touchId] = getRelativeX(touch, canvas) - touchX[touchId];\r\n\t\t\t\tdeltaY[touchId] = getRelativeY(touch, canvas) - touchY[touchId];\r\n\t\t\t\ttouchX[touchId] = getRelativeX(touch, canvas);\r\n\t\t\t\ttouchY[touchId] = getRelativeY(touch, canvas);\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchUp(touchX[touchId], touchY[touchId], touchId, Buttons.LEFT);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\t\tif (e.getType().equals(\"touchend\")) {\r\n\t\t\tJsArray<Touch> touches = e.getChangedTouches();\r\n\t\t\tfor (int i = 0, j = touches.length(); i < j; i++) {\r\n\t\t\t\tTouch touch = touches.get(i);\r\n\t\t\t\tint touchId = touch.getIdentifier();\r\n\t\t\t\ttouched[touchId] = false;\r\n\t\t\t\tdeltaX[touchId] = getRelativeX(touch, canvas) - touchX[touchId];\r\n\t\t\t\tdeltaY[touchId] = getRelativeY(touch, canvas) - touchY[touchId];\r\n\t\t\t\ttouchX[touchId] = getRelativeX(touch, canvas);\r\n\t\t\t\ttouchY[touchId] = getRelativeY(touch, canvas);\r\n\t\t\t\tif (processor != null) {\r\n\t\t\t\t\tprocessor.touchUp(touchX[touchId], touchY[touchId], touchId, Buttons.LEFT);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.currentEventTimeStamp = TimeUtils.nanoTime();\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n// if(hasFocus) e.preventDefault();\r\n\t}","commit_id":"4cda8e7946b7c0a821ab584865ba4407722c616c","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Kindly borrowed from PlayN. **/\r\n\tprotected static float getRelativeX (NativeEvent e, Element target) {\r\n\t\treturn e.getClientX() - target.getAbsoluteLeft() + target.getScrollLeft() + target.getOwnerDocument().getScrollLeft();\r\n\t}","id":38596,"modified_method":"/** Kindly borrowed from PlayN. **/\r\n\tprotected int getRelativeX (NativeEvent e, CanvasElement target) {\r\n\t\tfloat xScaleRatio = target.getWidth() * 1f / target.getClientWidth(); // Correct for canvas CSS scaling\r\n\t\treturn Math.round(xScaleRatio\r\n\t\t\t* (e.getClientX() - target.getAbsoluteLeft() + target.getScrollLeft() + target.getOwnerDocument().getScrollLeft()));\r\n\t}","commit_id":"4cda8e7946b7c0a821ab584865ba4407722c616c","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Kindly borrowed from PlayN. **/\r\n\tprotected static float getRelativeY (NativeEvent e, Element target) {\r\n\t\treturn e.getClientY() - target.getAbsoluteTop() + target.getScrollTop() + target.getOwnerDocument().getScrollTop();\r\n\t}","id":38597,"modified_method":"/** Kindly borrowed from PlayN. **/\r\n\tprotected int getRelativeY (NativeEvent e, CanvasElement target) {\r\n\t\tfloat yScaleRatio = target.getHeight() * 1f / target.getClientHeight(); // Correct for canvas CSS scaling\r\n\t\treturn Math.round(yScaleRatio\r\n\t\t\t* (e.getClientY() - target.getAbsoluteTop() + target.getScrollTop() + target.getOwnerDocument().getScrollTop()));\r\n\t}","commit_id":"4cda8e7946b7c0a821ab584865ba4407722c616c","url":"https://github.com/libgdx/libgdx"},{"original_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if( stratifiedContexts.size() == 0 )\n            return null;\n\n        int countNBaseSolid = 0;\n        int countRegularBaseSolid = 0;\n\n        for( final AlignmentContext context : stratifiedContexts.values() ) {\n            if ( context.hasBasePileup() ) { // must be called as getBasePileup may throw error when pileup has no bases\n                for( final PileupElement p : context.getBasePileup()) {\n                    if( p.getRead().getReadGroup().getPlatform().toUpperCase().contains(\"SOLID\") ) {\n                        if( BaseUtils.isNBase( p.getBase() ) ) {\n                            countNBaseSolid++;\n                        } else if( BaseUtils.isRegularBase( p.getBase() ) ) {\n                            countRegularBaseSolid++;\n                        }\n                    }\n                }\n            }\n        }\n        final Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", (double)countNBaseSolid / (double)(countNBaseSolid + countRegularBaseSolid + 1)));\n        return map;\n    }","id":38598,"modified_method":"public Map<String, Object> annotate(RefMetaDataTracker tracker, AnnotatorCompatibleWalker walker, ReferenceContext ref, Map<String, AlignmentContext> stratifiedContexts, VariantContext vc) {\n        if( stratifiedContexts.size() == 0 )\n            return null;\n\n        int countNBaseSolid = 0;\n        int countRegularBaseSolid = 0;\n\n        for( final AlignmentContext context : stratifiedContexts.values() ) {\n            if ( context.hasBasePileup() ) { // must be called as getBasePileup may throw error when pileup has no bases\n                for( final PileupElement p : context.getBasePileup()) {\n                    final String platform = p.getRead().getReadGroup().getPlatform();\n                    if( platform != null && platform.toUpperCase().contains(\"SOLID\") ) {\n                        if( BaseUtils.isNBase( p.getBase() ) ) {\n                            countNBaseSolid++;\n                        } else if( BaseUtils.isRegularBase( p.getBase() ) ) {\n                            countRegularBaseSolid++;\n                        }\n                    }\n                }\n            }\n        }\n        final Map<String, Object> map = new HashMap<String, Object>();\n        map.put(getKeyNames().get(0), String.format(\"%.4f\", (double)countNBaseSolid / (double)(countNBaseSolid + countRegularBaseSolid + 1)));\n        return map;\n    }","commit_id":"e3c48af289f5147924563c82975469a4404faf40","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For each read at this locus get the various covariate values and increment that location in the map based on\n     *   whether or not the base matches the reference at this particular location\n     * @param tracker The reference metadata tracker\n     * @param ref The reference context\n     * @param context The alignment context\n     * @return Returns 1, but this value isn't used in the reduce step\n     */\n    public Integer map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        // Pull out data for this locus for all the input RODs and check if this is a known variant site in any of them\n        boolean isSNP = false;\n        for( ReferenceOrderedDatum rod : tracker.getAllRods() ) {\n            if( rod != null && rod instanceof Variation && ((Variation)rod).isSNP() ) {\n                isSNP = true; // At least one of the rods says this is a snp site\n                break;\n            }\n        }\n\n        // Only use data from non-dbsnp sites\n        // Assume every mismatch at a non-dbsnp site is indicitive of poor quality\n        if( !isSNP && ( ++numUnprocessed >= PROCESS_EVERY_NTH_LOCUS ) ) {\n            numUnprocessed = 0; // Reset the counter because we are processing this very locus\n\n            SAMRecord read;\n            int offset;\n            byte refBase;\n            byte[] bases;\n\n            // For each read at this locus\n            for( PileupElement p : context.getPileup() ) {\n                read = p.getRead();\n                offset = p.getOffset();\n\n                RecalDataManager.parseSAMRecord( read, RAC );\n                RecalDataManager.parseColorSpace( read );\n\n                // Skip if base quality is zero\n                if( read.getBaseQualities()[offset] > 0 ) {\n\n                    bases = read.getReadBases();\n                    refBase = (byte)ref.getBase();\n\n                    // Skip if this base is an 'N' or etc.\n                    if( BaseUtils.isRegularBase( (char)(bases[offset]) ) ) {\n\n                        // SOLID bams have inserted the reference base into the read if the color space in inconsistent with the read base so skip it\n                        if( !read.getReadGroup().getPlatform().equalsIgnoreCase(\"SOLID\") || RAC.SOLID_RECAL_MODE.equalsIgnoreCase(\"DO_NOTHING\") || !RecalDataManager.isInconsistentColorSpace( read, offset ) ) {\n\n                            // This base finally passed all the checks for a good base, so add it to the big data hashmap\n                            updateDataFromRead( read, offset, refBase );\n\n                        } else { // calculate SOLID reference insertion rate\n                            if( ref.getBase() == (char)bases[offset] ) {\n                                solidInsertedReferenceBases++;\n                            } else {\n                                otherColorSpaceInconsistency++;\n                            }\n                        }\n                    }\n                }\n            }\n            countedSites++;\n        } else { // We skipped over the dbSNP site, and we are only processing every Nth locus\n            skippedSites++;\n            if( isSNP ) {\n                updateMismatchCounts(dbSNP_counts, context, ref.getBase()); // For sanity check to ensure novel mismatch rate vs dnsnp mismatch rate is reasonable\n            }\n        }\n\n        // Do a dbSNP sanity check every so often\n        if( ++lociSinceLastDbsnpCheck == DBSNP_VALIDATION_CHECK_FREQUENCY ) {\n            lociSinceLastDbsnpCheck = 0;\n            validateDbsnpMismatchRate();\n        }\n\n        return 1; // This value isn't actually used anywhere\n    }","id":38599,"modified_method":"/**\n     * For each read at this locus get the various covariate values and increment that location in the map based on\n     *   whether or not the base matches the reference at this particular location\n     * @param tracker The reference metadata tracker\n     * @param ref The reference context\n     * @param context The alignment context\n     * @return Returns 1, but this value isn't used in the reduce step\n     */\n    public Integer map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        // Pull out data for this locus for all the input RODs and check if this is a known variant site in any of them\n        boolean isSNP = false;\n        for( ReferenceOrderedDatum rod : tracker.getAllRods() ) {\n            if( rod != null && rod instanceof Variation && ((Variation)rod).isSNP() ) {\n                isSNP = true; // At least one of the rods says this is a snp site\n                break;\n            }\n        }\n\n        // Only use data from non-dbsnp sites\n        // Assume every mismatch at a non-dbsnp site is indicitive of poor quality\n        if( !isSNP && ( ++numUnprocessed >= PROCESS_EVERY_NTH_LOCUS ) ) {\n            numUnprocessed = 0; // Reset the counter because we are processing this very locus\n\n            SAMRecord read;\n            int offset;\n            byte refBase;\n            byte[] bases;\n\n            // For each read at this locus\n            for( PileupElement p : context.getPileup() ) {\n                read = p.getRead();\n                offset = p.getOffset();\n\n                RecalDataManager.parseSAMRecord( read, RAC );\n                RecalDataManager.parseColorSpace( read );\n\n                // Skip if base quality is zero\n                if( read.getBaseQualities()[offset] > 0 ) {\n\n                    bases = read.getReadBases();\n                    refBase = (byte)ref.getBase();\n\n                    // Skip if this base is an 'N' or etc.\n                    if( BaseUtils.isRegularBase( (char)(bases[offset]) ) ) {\n\n                        // SOLID bams have inserted the reference base into the read if the color space in inconsistent with the read base so skip it\n                        if( !read.getReadGroup().getPlatform().toUpperCase().contains(\"SOLID\") || RAC.SOLID_RECAL_MODE.equalsIgnoreCase(\"DO_NOTHING\") || !RecalDataManager.isInconsistentColorSpace( read, offset ) ) {\n\n                            // This base finally passed all the checks for a good base, so add it to the big data hashmap\n                            updateDataFromRead( read, offset, refBase );\n\n                        } else { // calculate SOLID reference insertion rate\n                            if( ref.getBase() == (char)bases[offset] ) {\n                                solidInsertedReferenceBases++;\n                            } else {\n                                otherColorSpaceInconsistency++;\n                            }\n                        }\n                    }\n                }\n            }\n            countedSites++;\n        } else { // We skipped over the dbSNP site, and we are only processing every Nth locus\n            skippedSites++;\n            if( isSNP ) {\n                updateMismatchCounts(dbSNP_counts, context, ref.getBase()); // For sanity check to ensure novel mismatch rate vs dnsnp mismatch rate is reasonable\n            }\n        }\n\n        // Do a dbSNP sanity check every so often\n        if( ++lociSinceLastDbsnpCheck == DBSNP_VALIDATION_CHECK_FREQUENCY ) {\n            lociSinceLastDbsnpCheck = 0;\n            validateDbsnpMismatchRate();\n        }\n\n        return 1; // This value isn't actually used anywhere\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        int cycle = 1;\n\n        //-----------------------------\n        // ILLUMINA and SOLID\n        //-----------------------------\n\n        if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"ILLUMINA\" ) || read.getReadGroup().getPlatform().equalsIgnoreCase( \"SLX\" ) ||\n                read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) ) { // Some bams have \"illumina\" and others have \"SLX\"\n            cycle = offset + 1;\n\t        if( read.getReadNegativeStrandFlag() ) {\n\t            cycle = read.getReadLength() - offset;\n\t        }\n        }\n\n        //-----------------------------\n        // 454\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().contains( \"454\" ) ) { // Some bams have \"LS454\" and others have just \"454\"\n            final byte[] bases = read.getReadBases();\n\n            // BUGBUG: Consider looking at degradation of base quality scores in homopolymer runs to detect when the cycle incremented even though the nucleotide didn't change\n            // For example, AAAAAAA was probably read in two flow cycles but here we count it as one\n            if( !read.getReadNegativeStrandFlag() ) { // Forward direction\n                int iii = 0;\n                while( iii <= offset )\n                {\n                    while( iii <= offset && bases[iii] == (byte)'T' ) { iii++; }\n                    while( iii <= offset && bases[iii] == (byte)'A' ) { iii++; }\n                    while( iii <= offset && bases[iii] == (byte)'C' ) { iii++; }\n                    while( iii <= offset && bases[iii] == (byte)'G' ) { iii++; }\n                    if( iii <= offset ) { cycle++; }\n                    if( iii <= offset && !BaseUtils.isRegularBase(bases[iii]) ) { iii++; }\n\n                }\n            } else { // Negative direction\n                int iii = bases.length-1;\n                while( iii >= offset )\n                {\n                    while( iii >= offset && bases[iii] == (byte)'T' ) { iii--; }\n                    while( iii >= offset && bases[iii] == (byte)'A' ) { iii--; }\n                    while( iii >= offset && bases[iii] == (byte)'C' ) { iii--; }\n                    while( iii >= offset && bases[iii] == (byte)'G' ) { iii--; }\n                    if( iii >= offset ) { cycle++; }\n                    if( iii >= offset && !BaseUtils.isRegularBase(bases[iii]) ) { iii--; }\n                }\n            }\n        }\n\n        //-----------------------------\n        // SOLID (unused), only to be used in conjunction with PrimerRoundCovariate\n        //-----------------------------\n\n        //else if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) ) {\n        //    // The ligation cycle according to http://www3.appliedbiosystems.com/cms/groups/mcb_marketing/documents/generaldocuments/cms_057511.pdf\n        //    int pos = offset + 1;\n\t    //    if( read.getReadNegativeStrandFlag() ) {\n\t    //        pos = read.getReadLength() - offset;\n\t    //    }\n        //\tcycle = pos / 5; // integer division\n        //}\n\n        //-----------------------------\n        // UNRECOGNIZED PLATFORM\n        //-----------------------------\n\n        else { // Platform is unrecognized so revert to the default platform but warn the user first\n        \tif( !warnedUserBadPlatform ) {\n                if( defaultPlatform != null) { // The user set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to \" + defaultPlatform + \" definition of machine cycle.\" );\n                } else { // The user did not set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to Illumina definition of machine cycle. Users may set the default platform using the --default_platform <String> argument.\" );\n                    defaultPlatform = \"Illumina\";\n                }\n                warnedUserBadPlatform = true;\n            }\n            read.getReadGroup().setPlatform( defaultPlatform );\n            return getValue( read, offset ); // A recursive call\n        }\n\n        // Differentiate between first and second of pair.\n        // The sequencing machine cycle keeps incrementing for the second read in a pair. So it is possible for a read group\n        // to have an error affecting quality at a particular cycle on the first of pair which carries over to the second of pair.\n        // Therefore the cycle covariate must differentiate between first and second of pair reads.\n        // This effect can not be corrected by pulling out the first of pair and second of pair flags into a separate covariate because\n        //   the current sequential model would consider the effects independently instead of jointly.\n        if( read.getReadPairedFlag() && read.getSecondOfPairFlag() ) {\n            cycle *= -1;\n        }\n\n        return cycle;\n    }","id":38600,"modified_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        int cycle = 1;\n\n        //-----------------------------\n        // ILLUMINA and SOLID\n        //-----------------------------\n\n        if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"ILLUMINA\" ) || read.getReadGroup().getPlatform().equalsIgnoreCase( \"SLX\" ) || // Some bams have \"illumina\" and others have \"SLX\"\n            read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) || read.getReadGroup().getPlatform().equalsIgnoreCase( \"ABI_SOLID\" )) { // Some bams have \"solid\" and others have \"ABI_SOLID\"\n            cycle = offset + 1;\n\t        if( read.getReadNegativeStrandFlag() ) {\n\t            cycle = read.getReadLength() - offset;\n\t        }\n        }\n\n        //-----------------------------\n        // 454\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().contains( \"454\" ) ) { // Some bams have \"LS454\" and others have just \"454\"\n            final byte[] bases = read.getReadBases();\n\n            // BUGBUG: Consider looking at degradation of base quality scores in homopolymer runs to detect when the cycle incremented even though the nucleotide didn't change\n            // For example, AAAAAAA was probably read in two flow cycles but here we count it as one\n            if( !read.getReadNegativeStrandFlag() ) { // Forward direction\n                int iii = 0;\n                while( iii <= offset )\n                {\n                    while( iii <= offset && bases[iii] == (byte)'T' ) { iii++; }\n                    while( iii <= offset && bases[iii] == (byte)'A' ) { iii++; }\n                    while( iii <= offset && bases[iii] == (byte)'C' ) { iii++; }\n                    while( iii <= offset && bases[iii] == (byte)'G' ) { iii++; }\n                    if( iii <= offset ) { cycle++; }\n                    if( iii <= offset && !BaseUtils.isRegularBase(bases[iii]) ) { iii++; }\n\n                }\n            } else { // Negative direction\n                int iii = bases.length-1;\n                while( iii >= offset )\n                {\n                    while( iii >= offset && bases[iii] == (byte)'T' ) { iii--; }\n                    while( iii >= offset && bases[iii] == (byte)'A' ) { iii--; }\n                    while( iii >= offset && bases[iii] == (byte)'C' ) { iii--; }\n                    while( iii >= offset && bases[iii] == (byte)'G' ) { iii--; }\n                    if( iii >= offset ) { cycle++; }\n                    if( iii >= offset && !BaseUtils.isRegularBase(bases[iii]) ) { iii--; }\n                }\n            }\n        }\n\n        //-----------------------------\n        // SOLID (unused), only to be used in conjunction with PrimerRoundCovariate\n        //-----------------------------\n\n        //else if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) ) {\n        //    // The ligation cycle according to http://www3.appliedbiosystems.com/cms/groups/mcb_marketing/documents/generaldocuments/cms_057511.pdf\n        //    int pos = offset + 1;\n\t    //    if( read.getReadNegativeStrandFlag() ) {\n\t    //        pos = read.getReadLength() - offset;\n\t    //    }\n        //\tcycle = pos / 5; // integer division\n        //}\n\n        //-----------------------------\n        // UNRECOGNIZED PLATFORM\n        //-----------------------------\n\n        else { // Platform is unrecognized so revert to the default platform but warn the user first\n        \tif( !warnedUserBadPlatform ) {\n                if( defaultPlatform != null) { // The user set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to platform = \" + defaultPlatform + \". Users may set the default platform using the --default_platform <String> argument.\" );\n                } else { // The user did not set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to platform = Illumina. Users may set the default platform using the --default_platform <String> argument.\" );\n                    defaultPlatform = \"Illumina\";\n                }\n                warnedUserBadPlatform = true;\n            }\n            read.getReadGroup().setPlatform( defaultPlatform );\n            return getValue( read, offset ); // A recursive call\n        }\n\n        // Differentiate between first and second of pair.\n        // The sequencing machine cycle keeps incrementing for the second read in a pair. So it is possible for a read group\n        // to have an error affecting quality at a particular cycle on the first of pair which carries over to the second of pair.\n        // Therefore the cycle covariate must differentiate between first and second of pair reads.\n        // This effect can not be corrected by pulling out the first of pair and second of pair flags into a separate covariate because\n        //   the current sequential model would consider the effects independently instead of jointly.\n        if( read.getReadPairedFlag() && read.getSecondOfPairFlag() ) {\n            cycle *= -1;\n        }\n\n        return cycle;\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize( final RecalibrationArgumentCollection RAC ) {\n        if( RAC.DEFAULT_PLATFORM.equalsIgnoreCase( \"SLX\" ) || RAC.DEFAULT_PLATFORM.equalsIgnoreCase( \"ILLUMINA\" ) ||\n            RAC.DEFAULT_PLATFORM.contains( \"454\" ) || RAC.DEFAULT_PLATFORM.equalsIgnoreCase( \"SOLID\" ) ) {\n            defaultPlatform = RAC.DEFAULT_PLATFORM;\n        } else {\n            throw new StingException( \"The requested default platform (\" + RAC.DEFAULT_PLATFORM +\") is not a recognized platform. Implemented options are illumina, 454, and solid\");\n        }\n    }","id":38601,"modified_method":"public void initialize( final RecalibrationArgumentCollection RAC ) {\n        if( RAC.DEFAULT_PLATFORM.equalsIgnoreCase( \"SLX\" ) || RAC.DEFAULT_PLATFORM.equalsIgnoreCase( \"ILLUMINA\" ) ||\n            RAC.DEFAULT_PLATFORM.contains( \"454\" ) || RAC.DEFAULT_PLATFORM.equalsIgnoreCase( \"SOLID\" ) || RAC.DEFAULT_PLATFORM.equalsIgnoreCase( \"ABI_SOLID\" ) ) {\n            defaultPlatform = RAC.DEFAULT_PLATFORM;\n        } else {\n            throw new StingException( \"The requested default platform (\" + RAC.DEFAULT_PLATFORM +\") is not a recognized platform. Implemented options are illumina, 454, and solid\");\n        }\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Perform the SET_Q_ZERO solid recalibration. Inconsistent color space bases and their previous base are set to quality zero\n     * @param read The SAMRecord to recalibrate\n     * @param readBases The bases in the read which have been RC'd if necessary\n     * @param inconsistency The array of 1/0 that says if this base is inconsistent with its color\n     * @param originalQualScores The array of original quality scores to set to zero if needed\n     * @param refBases The reference which has been RC'd if necessary\n     * @param setBaseN Should we also set the base to N as well as quality zero in order to visualize in IGV or something similar\n     * @return The byte array of original quality scores some of which might have been set to zero\n     */\n    private static byte[] solidRecalSetToQZero( final SAMRecord read, byte[] readBases, final int[] inconsistency, final byte[] originalQualScores,\n                                                final char[] refBases, final boolean setBaseN ) {\n\n        final boolean negStrand = read.getReadNegativeStrandFlag();\n        for( int iii = 1; iii < originalQualScores.length - 1; iii++ ) {\n            if( inconsistency[iii] == 1 ) {\n                if( (char)readBases[iii] == refBases[iii] ) {\n                    if( negStrand ) { originalQualScores[originalQualScores.length-(iii+1)] = (byte)0; }\n                    else { originalQualScores[iii] = (byte)0; }\n                    if( setBaseN ) { readBases[iii] = (byte)'N'; }\n                }\n                // Set the prev base to Q0 as well\n                if( (char)readBases[iii-1] == refBases[iii-1] ) {\n                    if( negStrand ) { originalQualScores[originalQualScores.length-iii] = (byte)0; }\n                    else { originalQualScores[iii-1] = (byte)0; }\n                    if( setBaseN ) { readBases[iii-1] = (byte)'N'; }\n                }\n            }\n        }\n        if( negStrand ) {\n            readBases = BaseUtils.simpleReverseComplement( readBases.clone() ); // Put the bases back in reverse order to stuff them back in the read\n        }\n        read.setReadBases( readBases );\n\n        return originalQualScores;\n    }","id":38602,"modified_method":"/**\n     * Perform the SET_Q_ZERO solid recalibration. Inconsistent color space bases and their previous base are set to quality zero\n     * @param read The SAMRecord to recalibrate\n     * @param readBases The bases in the read which have been RC'd if necessary\n     * @param inconsistency The array of 1/0 that says if this base is inconsistent with its color\n     * @param originalQualScores The array of original quality scores to set to zero if needed\n     * @param refBases The reference which has been RC'd if necessary\n     * @param setBaseN Should we also set the base to N as well as quality zero in order to visualize in IGV or something similar\n     * @return The byte array of original quality scores some of which might have been set to zero\n     */\n    private static byte[] solidRecalSetToQZero( final SAMRecord read, byte[] readBases, final int[] inconsistency, final byte[] originalQualScores,\n                                                final char[] refBases, final boolean setBaseN ) {\n\n        final boolean negStrand = read.getReadNegativeStrandFlag();\n        for( int iii = 1; iii < originalQualScores.length; iii++ ) {\n            if( inconsistency[iii] == 1 ) {\n                if( (char)readBases[iii] == refBases[iii] ) {\n                    if( negStrand ) { originalQualScores[originalQualScores.length-(iii+1)] = (byte)0; }\n                    else { originalQualScores[iii] = (byte)0; }\n                    if( setBaseN ) { readBases[iii] = (byte)'N'; }\n                }\n                // Set the prev base to Q0 as well\n                if( (char)readBases[iii-1] == refBases[iii-1] ) {\n                    if( negStrand ) { originalQualScores[originalQualScores.length-iii] = (byte)0; }\n                    else { originalQualScores[iii-1] = (byte)0; }\n                    if( setBaseN ) { readBases[iii-1] = (byte)'N'; }\n                }\n            }\n        }\n        if( negStrand ) {\n            readBases = BaseUtils.simpleReverseComplement( readBases.clone() ); // Put the bases back in reverse order to stuff them back in the read\n        }\n        read.setReadBases( readBases );\n\n        return originalQualScores;\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Parse through the color space of the read and add a new tag to the SAMRecord that says which bases are inconsistent with the color space\n     * @param read The SAMRecord to parse\n     */\n    public static void parseColorSpace( final SAMRecord read ) {\n\n        // If this is a SOLID read then we have to check if the color space is inconsistent. This is our only sign that SOLID has inserted the reference base\n        if( read.getReadGroup().getPlatform().equalsIgnoreCase(\"SOLID\") ) {\n            if( read.getAttribute(RecalDataManager.COLOR_SPACE_INCONSISTENCY_TAG) == null ) { // Haven't calculated the inconsistency array yet for this read\n                final Object attr = read.getAttribute(RecalDataManager.COLOR_SPACE_ATTRIBUTE_TAG);\n                if( attr != null ) {\n                    char[] colorSpace;\n                    if( attr instanceof String ) {\n                        colorSpace = ((String)attr).toCharArray();\n                    } else {\n                        throw new StingException(String.format(\"Value encoded by %s in %s isn't a string!\", RecalDataManager.COLOR_SPACE_ATTRIBUTE_TAG, read.getReadName()));\n                    }\n\n                    // Loop over the read and calculate first the infered bases from the color and then check if it is consistent with the read\n                    byte[] readBases = read.getReadBases();\n                    if( read.getReadNegativeStrandFlag() ) {\n                        readBases = BaseUtils.simpleReverseComplement( read.getReadBases() );\n                    }\n                    final byte[] inconsistency = new byte[readBases.length];\n                    int iii;\n                    byte prevBase = (byte) colorSpace[0]; // The sentinel\n                    for( iii = 0; iii < readBases.length; iii++ ) {\n                        final byte thisBase = (byte)getNextBaseFromColor( (char)prevBase, colorSpace[iii + 1] );\n                        inconsistency[iii] = (byte)( thisBase == readBases[iii] ? 0 : 1 );\n                        prevBase = readBases[iii];\n                    }\n                    read.setAttribute( RecalDataManager.COLOR_SPACE_INCONSISTENCY_TAG, inconsistency );\n\n                } else if ( !warnUserNoColorSpace ) { // Warn the user if we can't find the color space tag\n                    Utils.warnUser(\"Unable to find color space information in SOLiD read. First observed at read with name = \" + read.getReadName());\n                    Utils.warnUser(\"This calculation is critically dependent on being able to know when reference bases were inserted into SOLiD reads. Are you sure you want to proceed?\");\n                    warnUserNoColorSpace = true;\n                }\n            }\n        }\n    }","id":38603,"modified_method":"/**\n     * Parse through the color space of the read and add a new tag to the SAMRecord that says which bases are inconsistent with the color space\n     * @param read The SAMRecord to parse\n     */\n    public static void parseColorSpace( final SAMRecord read ) {\n\n        // If this is a SOLID read then we have to check if the color space is inconsistent. This is our only sign that SOLID has inserted the reference base\n        if( read.getReadGroup().getPlatform().toUpperCase().contains(\"SOLID\") ) {\n            if( read.getAttribute(RecalDataManager.COLOR_SPACE_INCONSISTENCY_TAG) == null ) { // Haven't calculated the inconsistency array yet for this read\n                final Object attr = read.getAttribute(RecalDataManager.COLOR_SPACE_ATTRIBUTE_TAG);\n                if( attr != null ) {\n                    char[] colorSpace;\n                    if( attr instanceof String ) {\n                        colorSpace = ((String)attr).toCharArray();\n                    } else {\n                        throw new StingException(String.format(\"Value encoded by %s in %s isn't a string!\", RecalDataManager.COLOR_SPACE_ATTRIBUTE_TAG, read.getReadName()));\n                    }\n\n                    // Loop over the read and calculate first the infered bases from the color and then check if it is consistent with the read\n                    byte[] readBases = read.getReadBases();\n                    if( read.getReadNegativeStrandFlag() ) {\n                        readBases = BaseUtils.simpleReverseComplement( read.getReadBases() );\n                    }\n                    final byte[] inconsistency = new byte[readBases.length];\n                    int iii;\n                    byte prevBase = (byte) colorSpace[0]; // The sentinel\n                    for( iii = 0; iii < readBases.length; iii++ ) {\n                        final byte thisBase = (byte)getNextBaseFromColor( (char)prevBase, colorSpace[iii + 1] );\n                        inconsistency[iii] = (byte)( thisBase == readBases[iii] ? 0 : 1 );\n                        prevBase = readBases[iii];\n                    }\n                    read.setAttribute( RecalDataManager.COLOR_SPACE_INCONSISTENCY_TAG, inconsistency );\n\n                } else if ( !warnUserNoColorSpace ) { // Warn the user if we can't find the color space tag\n                    Utils.warnUser(\"Unable to find color space information in SOLiD read. First observed at read with name = \" + read.getReadName());\n                    Utils.warnUser(\"This calculation is critically dependent on being able to know when reference bases were inserted into SOLiD reads. Are you sure you want to proceed?\");\n                    warnUserNoColorSpace = true;\n                }\n            }\n        }\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testTableRecalibrator1() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"NA12892.SLX.SRP000031.2009_06.selected.bam\", \"6c59d291c37d053e0f188b762f3060a5\" );\n        e.put( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SOLID.bam\", \"e06f1397b9c40f75e96cd3df76730ee0\");\n        e.put( validationDataLocation + \"NA12873.454.SRP000031.2009_06.chr1.10_20mb.bam\", \"7ebdce416b72679e1cf88cc9886a5edc\" );\n        e.put( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\", \"48ddc93cae054f9423f3a7ed9f36540e\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String bam = entry.getKey();\n            String md5 = entry.getValue();\n            String paramsFile = paramsFiles.get(bam);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", bam, paramsFile);\n            if ( paramsFile != null ) {\n                WalkerTestSpec spec = new WalkerTestSpec(\n                        \"-R \" + oneKGLocation + \"reference/human_b36_both.fasta\" +\n                                \" -T TableRecalibration\" +\n                                \" -I \" + bam +\n                                ( bam.equals( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" )\n                                    ? \" -L 1:10,800,000-10,810,000\" : \" -L 1:10,100,000-10,300,000\" ) +\n                                \" -outputBam %s\" +\n                                \" --no_pg_tag\" +\n                                \" --solid_recal_mode SET_Q_ZERO\" +\n                                \" -recalFile \" + paramsFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                executeTest(\"testTableRecalibrator1\", spec);\n            }\n        }\n    }","id":38604,"modified_method":"@Test\n    public void testTableRecalibrator1() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"NA12892.SLX.SRP000031.2009_06.selected.bam\", \"6c59d291c37d053e0f188b762f3060a5\" );\n        e.put( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SOLID.bam\", \"d0e902b071831bc10cc396e7e082b3c1\");\n        e.put( validationDataLocation + \"NA12873.454.SRP000031.2009_06.chr1.10_20mb.bam\", \"7ebdce416b72679e1cf88cc9886a5edc\" );\n        e.put( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\", \"467c7304cd049d1629c3675fdd61fc00\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String bam = entry.getKey();\n            String md5 = entry.getValue();\n            String paramsFile = paramsFiles.get(bam);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", bam, paramsFile);\n            if ( paramsFile != null ) {\n                WalkerTestSpec spec = new WalkerTestSpec(\n                        \"-R \" + oneKGLocation + \"reference/human_b36_both.fasta\" +\n                                \" -T TableRecalibration\" +\n                                \" -I \" + bam +\n                                ( bam.equals( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" )\n                                    ? \" -L 1:10,800,000-10,810,000\" : \" -L 1:10,100,000-10,300,000\" ) +\n                                \" -outputBam %s\" +\n                                \" --no_pg_tag\" +\n                                \" --solid_recal_mode SET_Q_ZERO\" +\n                                \" -recalFile \" + paramsFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                executeTest(\"testTableRecalibrator1\", spec);\n            }\n        }\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testTableRecalibratorNoReadGroups() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"NA12762.SOLID.SRP000031.2009_07.chr1.10_20mb.bam\", \"32ad300e8c094ed2c1ec6c531180fe70\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String bam = entry.getKey();\n            String md5 = entry.getValue();\n            String paramsFile = paramsFilesNoReadGroupTest.get(bam);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", bam, paramsFile);\n            if ( paramsFile != null ) {\n                WalkerTestSpec spec = new WalkerTestSpec(\n                        \"-R \" + oneKGLocation + \"reference/human_b36_both.fasta\" +\n                                \" -T TableRecalibration\" +\n                                \" -I \" + bam +\n                                \" -L 1:10,100,000-10,300,000\" +\n                                \" -outputBam %s\" +\n                                \" --no_pg_tag\" +\n                                \" --solid_recal_mode SET_Q_ZERO\" +\n                                \" --default_platform illumina\" +\n                                \" -recalFile \" + paramsFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                executeTest(\"testTableRecalibratorNoReadGroups\", spec);\n            }\n        }\n    }","id":38605,"modified_method":"@Test\n    public void testTableRecalibratorNoReadGroups() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"NA12762.SOLID.SRP000031.2009_07.chr1.10_20mb.bam\", \"474e05b5a0f13776daebeb964a5e0e2b\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String bam = entry.getKey();\n            String md5 = entry.getValue();\n            String paramsFile = paramsFilesNoReadGroupTest.get(bam);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", bam, paramsFile);\n            if ( paramsFile != null ) {\n                WalkerTestSpec spec = new WalkerTestSpec(\n                        \"-R \" + oneKGLocation + \"reference/human_b36_both.fasta\" +\n                                \" -T TableRecalibration\" +\n                                \" -I \" + bam +\n                                \" -L 1:10,100,000-10,300,000\" +\n                                \" -outputBam %s\" +\n                                \" --no_pg_tag\" +\n                                \" --solid_recal_mode SET_Q_ZERO\" +\n                                \" --default_platform illumina\" +\n                                \" -recalFile \" + paramsFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                executeTest(\"testTableRecalibratorNoReadGroups\", spec);\n            }\n        }\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testTableRecalibratorMaxQ70() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SOLID.bam\", \"665711dfb81d67582b28faea24e26160\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String bam = entry.getKey();\n            String md5 = entry.getValue();\n            String paramsFile = paramsFiles.get(bam);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", bam, paramsFile);\n            if ( paramsFile != null ) {\n                WalkerTestSpec spec = new WalkerTestSpec(\n                        \"-R \" + oneKGLocation + \"reference/human_b36_both.fasta\" +\n                                \" -T TableRecalibration\" +\n                                \" -I \" + bam +\n                                ( bam.equals( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" )\n                                    ? \" -L 1:10,800,000-10,810,000\" : \" -L 1:10,100,000-10,300,000\" ) +\n                                \" -outputBam %s\" +\n                                \" --no_pg_tag\" +\n                                \" -maxQ 70\" +\n                                \" --solid_recal_mode SET_Q_ZERO\" +\n                                \" -recalFile \" + paramsFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                executeTest(\"testTableRecalibratorMaxQ70\", spec);\n            }\n        }\n    }","id":38606,"modified_method":"@Test\n    public void testTableRecalibratorMaxQ70() {\n        HashMap<String, String> e = new HashMap<String, String>();\n        e.put( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.SOLID.bam\", \"e7e6443bc4debc26e5e06b8765b60042\" );\n\n        for ( Map.Entry<String, String> entry : e.entrySet() ) {\n            String bam = entry.getKey();\n            String md5 = entry.getValue();\n            String paramsFile = paramsFiles.get(bam);\n            System.out.printf(\"PARAMS FOR %s is %s%n\", bam, paramsFile);\n            if ( paramsFile != null ) {\n                WalkerTestSpec spec = new WalkerTestSpec(\n                        \"-R \" + oneKGLocation + \"reference/human_b36_both.fasta\" +\n                                \" -T TableRecalibration\" +\n                                \" -I \" + bam +\n                                ( bam.equals( validationDataLocation + \"NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\" )\n                                    ? \" -L 1:10,800,000-10,810,000\" : \" -L 1:10,100,000-10,300,000\" ) +\n                                \" -outputBam %s\" +\n                                \" --no_pg_tag\" +\n                                \" -maxQ 70\" +\n                                \" --solid_recal_mode SET_Q_ZERO\" +\n                                \" -recalFile \" + paramsFile,\n                        1, // just one output file\n                        Arrays.asList(md5));\n                executeTest(\"testTableRecalibratorMaxQ70\", spec);\n            }\n        }\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For each base in the read calculate a new recalibrated quality score and replace the quality scores in the read\n     * @param refBases References bases over the length of the read\n     * @param read The read to be recalibrated\n     * @return The read with quality scores replaced\n     */\n    public SAMRecord map( char[] refBases, SAMRecord read ) {\n\n        RecalDataManager.parseSAMRecord( read, RAC );\n        \n        byte[] originalQuals = read.getBaseQualities();\n        final byte[] recalQuals = originalQuals.clone();\n\n        final String platform = read.getReadGroup().getPlatform();\n        if( platform.equalsIgnoreCase(\"SOLID\") && !RAC.SOLID_RECAL_MODE.equalsIgnoreCase(\"DO_NOTHING\") ) {\n            originalQuals = RecalDataManager.calcColorSpace( read, originalQuals, RAC.SOLID_RECAL_MODE, coinFlip, refBases );\n        }\n\n        final Object[] fullCovariateKey = new Object[requestedCovariates.size()];\n\n        // For each base in the read\n        final int readLength = read.getReadLength();\n        for( int offset = 0; offset < readLength; offset++ ) {\n\n            // Loop through the list of requested covariates and pick out the value from the read and offset\n            int iii = 0;\n            for( Covariate covariate : requestedCovariates ) {\n                fullCovariateKey[iii++] = covariate.getValue( read, offset );\n            }\n\n            recalQuals[offset] = performSequentialQualityCalculation( fullCovariateKey );\n        }\n\n        preserveQScores( originalQuals, recalQuals ); // Overwrite the work done if original quality score is too low\n\n        read.setBaseQualities( recalQuals ); // Overwrite old qualities with new recalibrated qualities\n        if ( read.getAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG) == null ) { // Save the old qualities if the tag isn't already taken in the read\n            read.setAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG, QualityUtils.phredToFastq(originalQuals));\n        }\n        if (read.getAttribute(SAMTag.UQ.name()) != null) {\n            // TODO - When refBases is switches to byte[], call the appropriate overload in SAM-JDK, and remove char[] overload from SAM-JDK.\n            read.setAttribute(SAMTag.UQ.name(), SequenceUtil.sumQualitiesOfMismatches(read, refBases, read.getAlignmentStart() - 1));\n        }\n\n        return read;\n    }","id":38607,"modified_method":"/**\n     * For each base in the read calculate a new recalibrated quality score and replace the quality scores in the read\n     * @param refBases References bases over the length of the read\n     * @param read The read to be recalibrated\n     * @return The read with quality scores replaced\n     */\n    public SAMRecord map( char[] refBases, SAMRecord read ) {\n\n        RecalDataManager.parseSAMRecord( read, RAC );\n        \n        byte[] originalQuals = read.getBaseQualities();\n        final byte[] recalQuals = originalQuals.clone();\n\n        final String platform = read.getReadGroup().getPlatform();\n        if( platform.toUpperCase().contains(\"SOLID\") && !RAC.SOLID_RECAL_MODE.equalsIgnoreCase(\"DO_NOTHING\") ) {\n            originalQuals = RecalDataManager.calcColorSpace( read, originalQuals, RAC.SOLID_RECAL_MODE, coinFlip, refBases );\n        }\n\n        final Object[] fullCovariateKey = new Object[requestedCovariates.size()];\n\n        // For each base in the read\n        final int readLength = read.getReadLength();\n        for( int offset = 0; offset < readLength; offset++ ) {\n\n            // Loop through the list of requested covariates and pick out the value from the read and offset\n            int iii = 0;\n            for( Covariate covariate : requestedCovariates ) {\n                fullCovariateKey[iii++] = covariate.getValue( read, offset );\n            }\n\n            recalQuals[offset] = performSequentialQualityCalculation( fullCovariateKey );\n        }\n\n        preserveQScores( originalQuals, recalQuals ); // Overwrite the work done if original quality score is too low\n\n        read.setBaseQualities( recalQuals ); // Overwrite old qualities with new recalibrated qualities\n        if ( read.getAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG) == null ) { // Save the old qualities if the tag isn't already taken in the read\n            read.setAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG, QualityUtils.phredToFastq(originalQuals));\n        }\n        if (read.getAttribute(SAMTag.UQ.name()) != null) {\n            // TODO - When refBases is switches to byte[], call the appropriate overload in SAM-JDK, and remove char[] overload from SAM-JDK.\n            read.setAttribute(SAMTag.UQ.name(), SequenceUtil.sumQualitiesOfMismatches(read, refBases, read.getAlignmentStart() - 1));\n        }\n\n        return read;\n    }","commit_id":"c98df0a8627db70e9806bb7534c344d402155f5d","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static String getVersion() {\n    Properties prop = new Properties();\n    try {\n      URL resource = UpgradeTool.class.getResource(\"/etl.properties\");\n      try (InputStream in = UpgradeTool.class.getResourceAsStream(\"/etl.properties\")) {\n        prop.load(in);\n      }\n      return prop.getProperty(\"version\");\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error determining version. Please check that the jar was built correctly.\", e);\n    }\n  }","id":38608,"modified_method":"private static String getVersion() {\n    Properties prop = new Properties();\n    try {\n      try (InputStream in = UpgradeTool.class.getResourceAsStream(\"/etl.properties\")) {\n        prop.load(in);\n      }\n      return prop.getProperty(\"version\");\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error determining version. Please check that the jar was built correctly.\", e);\n    }\n  }","commit_id":"87785fae5f9f4959189772515b31db834cb50bb0","url":"https://github.com/caskdata/cdap"},{"original_method":"private static void convertFile(String configFilePath) throws IOException {\n    File configFile = new File(configFilePath);\n    if (!configFile.exists()) {\n      throw new IllegalArgumentException(configFilePath + \" does not exist.\");\n    }\n    if (!configFile.isFile()) {\n      throw new IllegalArgumentException(configFilePath + \" is not a file.\");\n    }\n    String fileContents = new String(Files.readAllBytes(configFile.toPath()), StandardCharsets.UTF_8);\n\n    ETLAppRequest artifactFile = GSON.fromJson(fileContents, ETLAppRequest.class);\n    if (!shouldUpgrade(artifactFile.artifact)) {\n      throw new IllegalArgumentException(\n        \"Cannot update for artifact \" + artifactFile.artifact + \". \" +\n          \"Please check the artifact is cdap-etl-batch or cdap-etl-realtime in the system scope of version 3.2.x.\");\n    }\n\n    String version = getVersion();\n\n    if (BATCH_NAME.equals(artifactFile.artifact.getName())) {\n      ArtifactSummary artifact = new ArtifactSummary(BATCH_NAME, version, ArtifactScope.SYSTEM);\n      OldETLBatchConfig oldConfig = GSON.fromJson(artifactFile.config, OldETLBatchConfig.class);\n      AppRequest<ETLBatchConfig> updated = new AppRequest<>(artifact, oldConfig.getNewConfig());\n      System.out.println(GSON.toJson(updated));\n    } else {\n      ArtifactSummary artifact = new ArtifactSummary(REALTIME_NAME, version, ArtifactScope.SYSTEM);\n      OldETLRealtimeConfig oldConfig = GSON.fromJson(artifactFile.config, OldETLRealtimeConfig.class);\n      AppRequest<ETLRealtimeConfig> updated = new AppRequest<>(artifact, oldConfig.getNewConfig());\n      System.out.println(GSON.toJson(updated));\n    }\n  }","id":38609,"modified_method":"private static void convertFile(String configFilePath, String outputFilePath) throws IOException {\n    File configFile = new File(configFilePath);\n    if (!configFile.exists()) {\n      throw new IllegalArgumentException(configFilePath + \" does not exist.\");\n    }\n    if (!configFile.isFile()) {\n      throw new IllegalArgumentException(configFilePath + \" is not a file.\");\n    }\n    String fileContents = new String(Files.readAllBytes(configFile.toPath()), StandardCharsets.UTF_8);\n\n    ETLAppRequest artifactFile = GSON.fromJson(fileContents, ETLAppRequest.class);\n    if (!shouldUpgrade(artifactFile.artifact)) {\n      throw new IllegalArgumentException(\n        \"Cannot update for artifact \" + artifactFile.artifact + \". \" +\n          \"Please check the artifact is cdap-etl-batch or cdap-etl-realtime in the system scope of version 3.2.x.\");\n    }\n\n    String version = getVersion();\n\n    File outputFile = new File(outputFilePath);\n    if (BATCH_NAME.equals(artifactFile.artifact.getName())) {\n      ArtifactSummary artifact = new ArtifactSummary(BATCH_NAME, version, ArtifactScope.SYSTEM);\n      OldETLBatchConfig oldConfig = GSON.fromJson(artifactFile.config, OldETLBatchConfig.class);\n      AppRequest<ETLBatchConfig> updated = new AppRequest<>(artifact, oldConfig.getNewConfig());\n      System.out.println(GSON.toJson(updated));\n      try (BufferedWriter writer = Files.newBufferedWriter(outputFile.toPath(), StandardCharsets.UTF_8)) {\n        writer.write(GSON.toJson(updated));\n      }\n    } else {\n      ArtifactSummary artifact = new ArtifactSummary(REALTIME_NAME, version, ArtifactScope.SYSTEM);\n      OldETLRealtimeConfig oldConfig = GSON.fromJson(artifactFile.config, OldETLRealtimeConfig.class);\n      AppRequest<ETLRealtimeConfig> updated = new AppRequest<>(artifact, oldConfig.getNewConfig());\n      try (BufferedWriter writer = Files.newBufferedWriter(outputFile.toPath(), StandardCharsets.UTF_8)) {\n        writer.write(GSON.toJson(updated));\n      }\n    }\n\n    System.out.println(\"Successfully converted application details from file \" + configFilePath + \". \" +\n                         \"Results have been written to \" + outputFilePath);\n  }","commit_id":"87785fae5f9f4959189772515b31db834cb50bb0","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void main(String[] args) throws Exception {\n\n    Options options = new Options()\n      .addOption(new Option(\"h\", \"help\", false, \"Print this usage message.\"))\n      .addOption(new Option(\"u\", \"uri\", true, \"CDAP instance URI to interact with in the format \" +\n        \"[http[s]://]<hostname>:<port>. Defaults to localhost:10000.\"))\n      .addOption(new Option(\"a\", \"accesstoken\", true, \"File containing the access token to use when interacting \" +\n        \"with a secure CDAP instance.\"))\n      .addOption(new Option(\"t\", \"timeout\", true, \"Timeout in milliseconds to use when interacting with the \" +\n        \"CDAP RESTful APIs. Defaults to \" + DEFAULT_READ_TIMEOUT + \".\"))\n      .addOption(new Option(\"n\", \"namespace\", true, \"Namespace to perform the upgrade in. If none is given, \" +\n        \"pipelines in all namespaces will be upgraded.\"))\n      .addOption(new Option(\"p\", \"pipeline\", true, \"Name of the pipeline to upgrade. If specified, a namespace \" +\n        \"must also be given.\"))\n      .addOption(new Option(\"f\", \"configfile\", true, \"File containing old application details to update. \" +\n        \"The file contents are expected to be in the same format as the request body for creating an \" +\n        \"ETL application from one of the etl artifacts. \" +\n        \"It is expected to be a JSON Object containing 'artifact' and 'config' fields.\" +\n        \"The value for 'artifact' must be a JSON Object that specifies the artifact scope, name, and version. \" +\n        \"The value for 'config' must be a JSON Object specifies the source, transforms, and sinks of the pipeline, \" +\n        \"as expected by older versions of the etl artifacts.\"));\n\n    CommandLineParser parser = new BasicParser();\n    CommandLine commandLine = parser.parse(options, args);\n\n    if (commandLine.hasOption(\"h\")) {\n      HelpFormatter helpFormatter = new HelpFormatter();\n      helpFormatter.printHelp(UpgradeTool.class.getName(), \"Upgrades Hydrator pipelines created for 3.2.x versions\" +\n        \"of the cdap-etl-batch and cdap-etl-realtime artifacts into pipelines compatible with 3.3.x versions of \" +\n        \"cdap-etl-batch and cdap-etl-realtime. Connects to an instance of CDAP to find any 3.2.x pipelines, then \" +\n        \"upgrades those pipelines.\", options, \"\");\n      System.exit(0);\n    }\n\n    if (commandLine.hasOption(\"f\")) {\n      convertFile(commandLine.getOptionValue(\"f\"));\n      System.exit(0);\n    }\n\n    UpgradeTool upgradeTool = new UpgradeTool(getClientConfig(commandLine));\n\n    String namespace = commandLine.getOptionValue(\"n\");\n    String pipelineName = commandLine.getOptionValue(\"p\");\n\n    if (pipelineName != null) {\n      if (namespace == null) {\n        throw new IllegalArgumentException(\"Must specify a namespace when specifying a pipeline.\");\n      }\n      Id.Application appId = Id.Application.from(namespace, pipelineName);\n      upgradeTool.upgrade(appId);\n      System.out.println(\"Successfully upgraded pipeline \" + appId);\n      System.exit(0);\n    }\n\n    if (namespace != null) {\n      upgradeTool.upgrade(Id.Namespace.from(namespace));\n      System.out.println(\"Successfully upgraded all pipelines in namespace \" + namespace);\n      System.exit(0);\n    }\n\n    upgradeTool.upgrade();\n    System.out.println(\"Successfully upgraded all pipelines.\");\n  }","id":38610,"modified_method":"public static void main(String[] args) throws Exception {\n\n    Options options = new Options()\n      .addOption(new Option(\"h\", \"help\", false, \"Print this usage message.\"))\n      .addOption(new Option(\"u\", \"uri\", true, \"CDAP instance URI to interact with in the format \" +\n        \"[http[s]://]<hostname>:<port>. Defaults to localhost:10000.\"))\n      .addOption(new Option(\"a\", \"accesstoken\", true, \"File containing the access token to use when interacting \" +\n        \"with a secure CDAP instance.\"))\n      .addOption(new Option(\"t\", \"timeout\", true, \"Timeout in milliseconds to use when interacting with the \" +\n        \"CDAP RESTful APIs. Defaults to \" + DEFAULT_READ_TIMEOUT_MILLIS + \".\"))\n      .addOption(new Option(\"n\", \"namespace\", true, \"Namespace to perform the upgrade in. If none is given, \" +\n        \"pipelines in all namespaces will be upgraded.\"))\n      .addOption(new Option(\"p\", \"pipeline\", true, \"Name of the pipeline to upgrade. If specified, a namespace \" +\n        \"must also be given.\"))\n      .addOption(new Option(\"f\", \"configfile\", true, \"File containing old application details to update. \" +\n        \"The file contents are expected to be in the same format as the request body for creating an \" +\n        \"ETL application from one of the etl artifacts. \" +\n        \"It is expected to be a JSON Object containing 'artifact' and 'config' fields.\" +\n        \"The value for 'artifact' must be a JSON Object that specifies the artifact scope, name, and version. \" +\n        \"The value for 'config' must be a JSON Object specifies the source, transforms, and sinks of the pipeline, \" +\n        \"as expected by older versions of the etl artifacts.\"))\n      .addOption(new Option(\"o\", \"outputfile\", true, \"File to write the converted application details provided in \" +\n        \"the configfile option. If none is given, results will be written to the input file + '.converted'. \" +\n        \"The contents of this file can be sent directly to CDAP to update or create an application.\"));\n\n    CommandLineParser parser = new BasicParser();\n    CommandLine commandLine = parser.parse(options, args);\n\n    if (commandLine.hasOption(\"h\")) {\n      HelpFormatter helpFormatter = new HelpFormatter();\n      helpFormatter.printHelp(UpgradeTool.class.getName(), \"Upgrades Hydrator pipelines created for 3.2.x versions\" +\n        \"of the cdap-etl-batch and cdap-etl-realtime artifacts into pipelines compatible with 3.3.x versions of \" +\n        \"cdap-etl-batch and cdap-etl-realtime. Connects to an instance of CDAP to find any 3.2.x pipelines, then \" +\n        \"upgrades those pipelines.\", options, \"\");\n      System.exit(0);\n    }\n\n    if (commandLine.hasOption(\"f\")) {\n      String inputFilePath = commandLine.getOptionValue(\"f\");\n      String outputFilePath = commandLine.hasOption(\"o\") ? commandLine.getOptionValue(\"o\") : inputFilePath + \".new\";\n      convertFile(inputFilePath, outputFilePath);\n      System.exit(0);\n    }\n\n    UpgradeTool upgradeTool = new UpgradeTool(getClientConfig(commandLine));\n\n    String namespace = commandLine.getOptionValue(\"n\");\n    String pipelineName = commandLine.getOptionValue(\"p\");\n\n    if (pipelineName != null) {\n      if (namespace == null) {\n        throw new IllegalArgumentException(\"Must specify a namespace when specifying a pipeline.\");\n      }\n      Id.Application appId = Id.Application.from(namespace, pipelineName);\n      if (upgradeTool.upgrade(appId)) {\n        System.out.println(\"Successfully upgraded \" + appId);\n      } else {\n        System.out.println(appId + \" did not need to be upgraded.\");\n      }\n      System.exit(0);\n    }\n\n    if (namespace != null) {\n      printUpgraded(upgradeTool.upgrade(Id.Namespace.from(namespace)));\n      System.exit(0);\n    }\n\n    printUpgraded(upgradeTool.upgrade());\n  }","commit_id":"87785fae5f9f4959189772515b31db834cb50bb0","url":"https://github.com/caskdata/cdap"},{"original_method":"private static ClientConfig getClientConfig(CommandLine commandLine) throws IOException {\n    String uriStr = commandLine.hasOption(\"u\") ? commandLine.getOptionValue(\"u\") : \"localhost:10000\";\n    if (!uriStr.contains(\"://\")) {\n      uriStr = \"http://\" + uriStr;\n    }\n    URI uri = URI.create(uriStr);\n    String hostname = uri.getHost();\n    int port = uri.getPort();\n    boolean sslEnabled = \"https\".equals(uri.getScheme());\n    ConnectionConfig connectionConfig = ConnectionConfig.builder()\n      .setHostname(hostname)\n      .setPort(port)\n      .setSSLEnabled(sslEnabled)\n      .build();\n\n    int readTimeout = commandLine.hasOption(\"t\") ?\n      Integer.parseInt(commandLine.getOptionValue(\"t\")) : DEFAULT_READ_TIMEOUT;\n    ClientConfig.Builder clientConfigBuilder = ClientConfig.builder()\n      .setDefaultReadTimeout(readTimeout)\n      .setConnectionConfig(connectionConfig);\n\n    if (commandLine.hasOption(\"a\")) {\n      String tokenFilePath = commandLine.getOptionValue(\"a\");\n      File tokenFile = new File(tokenFilePath);\n      if (!tokenFile.exists()) {\n        throw new IllegalArgumentException(\"Access token file \" + tokenFilePath + \" does not exist.\");\n      }\n      if (!tokenFile.isFile()) {\n        throw new IllegalArgumentException(\"Access token file \" + tokenFilePath + \" is not a file.\");\n      }\n      String tokenValue = new String(Files.readAllBytes(tokenFile.toPath()), StandardCharsets.UTF_8).trim();\n      AccessToken accessToken = new AccessToken(tokenValue, 82000L, \"Bearer\");\n      clientConfigBuilder.setAccessToken(accessToken);\n    }\n\n    return clientConfigBuilder.build();\n  }","id":38611,"modified_method":"private static ClientConfig getClientConfig(CommandLine commandLine) throws IOException {\n    String uriStr = commandLine.hasOption(\"u\") ? commandLine.getOptionValue(\"u\") : \"localhost:10000\";\n    if (!uriStr.contains(\"://\")) {\n      uriStr = \"http://\" + uriStr;\n    }\n    URI uri = URI.create(uriStr);\n    String hostname = uri.getHost();\n    int port = uri.getPort();\n    boolean sslEnabled = \"https\".equals(uri.getScheme());\n    ConnectionConfig connectionConfig = ConnectionConfig.builder()\n      .setHostname(hostname)\n      .setPort(port)\n      .setSSLEnabled(sslEnabled)\n      .build();\n\n    int readTimeout = commandLine.hasOption(\"t\") ?\n      Integer.parseInt(commandLine.getOptionValue(\"t\")) : DEFAULT_READ_TIMEOUT_MILLIS;\n    ClientConfig.Builder clientConfigBuilder = ClientConfig.builder()\n      .setDefaultReadTimeout(readTimeout)\n      .setConnectionConfig(connectionConfig);\n\n    if (commandLine.hasOption(\"a\")) {\n      String tokenFilePath = commandLine.getOptionValue(\"a\");\n      File tokenFile = new File(tokenFilePath);\n      if (!tokenFile.exists()) {\n        throw new IllegalArgumentException(\"Access token file \" + tokenFilePath + \" does not exist.\");\n      }\n      if (!tokenFile.isFile()) {\n        throw new IllegalArgumentException(\"Access token file \" + tokenFilePath + \" is not a file.\");\n      }\n      String tokenValue = new String(Files.readAllBytes(tokenFile.toPath()), StandardCharsets.UTF_8).trim();\n      AccessToken accessToken = new AccessToken(tokenValue, 82000L, \"Bearer\");\n      clientConfigBuilder.setAccessToken(accessToken);\n    }\n\n    return clientConfigBuilder.build();\n  }","commit_id":"87785fae5f9f4959189772515b31db834cb50bb0","url":"https://github.com/caskdata/cdap"},{"original_method":"private void upgrade(Id.Namespace namespace) throws Exception {\n    Set<String> artifactNames = ImmutableSet.of(BATCH_NAME, REALTIME_NAME);\n    for (ApplicationRecord appRecord : appClient.list(namespace, artifactNames, null)) {\n      Id.Application appId = Id.Application.from(namespace, appRecord.getName());\n      upgrade(appId);\n    }\n  }","id":38612,"modified_method":"private Set<Id.Application> upgrade(Id.Namespace namespace) throws Exception {\n    Set<Id.Application> upgraded = new HashSet<>();\n    Set<String> artifactNames = ImmutableSet.of(BATCH_NAME, REALTIME_NAME);\n    for (ApplicationRecord appRecord : appClient.list(namespace, artifactNames, null)) {\n      Id.Application appId = Id.Application.from(namespace, appRecord.getName());\n      if (upgrade(appId)) {\n        upgraded.add(appId);\n      }\n    }\n    return upgraded;\n  }","commit_id":"87785fae5f9f4959189772515b31db834cb50bb0","url":"https://github.com/caskdata/cdap"},{"original_method":"private void upgrade() throws Exception {\n    for (NamespaceMeta namespaceMeta : namespaceClient.list()) {\n      Id.Namespace namespace = Id.Namespace.from(namespaceMeta.getName());\n      upgrade(namespace);\n    }\n  }","id":38613,"modified_method":"private Set<Id.Application> upgrade() throws Exception {\n    Set<Id.Application> upgraded = new HashSet<>();\n    for (NamespaceMeta namespaceMeta : namespaceClient.list()) {\n      Id.Namespace namespace = Id.Namespace.from(namespaceMeta.getName());\n      upgraded.addAll(upgrade(namespace));\n    }\n    return upgraded;\n  }","commit_id":"87785fae5f9f4959189772515b31db834cb50bb0","url":"https://github.com/caskdata/cdap"},{"original_method":"private void upgrade(Id.Application appId) throws Exception {\n    ApplicationDetail appDetail = appClient.get(appId);\n\n    if (!shouldUpgrade(appDetail.getArtifact())) {\n      return;\n    }\n\n    if (BATCH_NAME.equals(appDetail.getArtifact().getName())) {\n      OldETLBatchConfig oldConfig = GSON.fromJson(appDetail.getConfiguration(), OldETLBatchConfig.class);\n      ETLBatchConfig newConfig = oldConfig.getNewConfig();\n      AppRequest<ETLBatchConfig> updateRequest = new AppRequest<>(batchArtifact, newConfig);\n      appClient.update(appId, updateRequest);\n    } else {\n      OldETLRealtimeConfig oldConfig = GSON.fromJson(appDetail.getConfiguration(), OldETLRealtimeConfig.class);\n      ETLRealtimeConfig newConfig = oldConfig.getNewConfig();\n      AppRequest<ETLRealtimeConfig> updateRequest = new AppRequest<>(realtimeArtifact, newConfig);\n      appClient.update(appId, updateRequest);\n    }\n  }","id":38614,"modified_method":"private boolean upgrade(Id.Application appId) throws Exception {\n    ApplicationDetail appDetail = appClient.get(appId);\n\n    if (!shouldUpgrade(appDetail.getArtifact())) {\n      return false;\n    }\n\n    if (BATCH_NAME.equals(appDetail.getArtifact().getName())) {\n      OldETLBatchConfig oldConfig = GSON.fromJson(appDetail.getConfiguration(), OldETLBatchConfig.class);\n      ETLBatchConfig newConfig = oldConfig.getNewConfig();\n      AppRequest<ETLBatchConfig> updateRequest = new AppRequest<>(batchArtifact, newConfig);\n      appClient.update(appId, updateRequest);\n    } else {\n      OldETLRealtimeConfig oldConfig = GSON.fromJson(appDetail.getConfiguration(), OldETLRealtimeConfig.class);\n      ETLRealtimeConfig newConfig = oldConfig.getNewConfig();\n      AppRequest<ETLRealtimeConfig> updateRequest = new AppRequest<>(realtimeArtifact, newConfig);\n      appClient.update(appId, updateRequest);\n    }\n    return true;\n  }","commit_id":"87785fae5f9f4959189772515b31db834cb50bb0","url":"https://github.com/caskdata/cdap"},{"original_method":"public void add(SAMRecord read, char [] ref) {\r\n\r\n                if ( read.getAlignmentStart() < start ) return; // silently ignore reads starting before the window start\r\n\r\n                ExpandedSAMRecord er = new ExpandedSAMRecord(read,ref,read.getAlignmentStart()-start,this);\r\n                //TODO duplicate records may actually indicate a problem with input bam file; throw an exception when the bug in CleanedReadInjector is fixed\r\n                if ( reads.contains(er)) return; // ignore duplicate records\r\n                reads.add(er);\r\n            }","id":38615,"modified_method":"public void add(SAMRecord read, byte [] ref) {\r\n\r\n                if ( read.getAlignmentStart() < start ) return; // silently ignore reads starting before the window start\r\n\r\n                ExpandedSAMRecord er = new ExpandedSAMRecord(read,ref,read.getAlignmentStart()-start,this);\r\n                //TODO duplicate records may actually indicate a problem with input bam file; throw an exception when the bug in CleanedReadInjector is fixed\r\n                if ( reads.contains(er)) return; // ignore duplicate records\r\n                reads.add(er);\r\n            }","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Output indel calls up to the specified position and shift the window: after this method is executed, the                                     \r\n         * first element of the window maps onto 'position', if possible, or at worst a few bases to the left of 'position' if we may need more \r\n         * reads to get full NQS-style statistics for an indel in the close proximity of 'position'.  \r\n         *                                                                                                \r\n         * @param position\r\n         */\r\n   private void emit(long position, boolean force) {\r\n\r\n            long adjustedPosition = adjustPosition(position);\r\n\r\n            if ( adjustedPosition == -1 ) {\r\n                // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                normal_context.shift((int)(position-normal_context.getStart()));\r\n                return;\r\n            }\r\n            long move_to = adjustedPosition;\r\n\r\n            for ( long pos = normal_context.getStart() ; pos < Math.min(adjustedPosition,normal_context.getStop()+1) ; pos++ ) {\r\n\r\n                if ( normal_context.indelsAt(pos).size() == 0 ) continue; // no indels\r\n\r\n                IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n                if ( normalCall.getCoverage() < minCoverage ) {\r\n                    if ( DEBUG ) {\r\n                        System.out.println(\"DEBUG>> Indel at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                    }\r\n                    continue; // low coverage\r\n                }\r\n\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> Indel at \"+pos);\r\n\r\n                long left = Math.max( pos-NQS_WIDTH, normal_context.getStart() );\r\n                long right = pos+normalCall.getVariant().lengthOnRef()+NQS_WIDTH-1;\r\n\r\n                if ( right >= adjustedPosition && ! force) {\r\n                    // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                    // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                    // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                    move_to = adjustPosition(left);\r\n                    if ( move_to == -1 ) {\r\n                        // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                        normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                        return;\r\n                    }\r\n                    if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                    break;\r\n                }\r\n\r\n                // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right:\r\n                if ( right > normal_context.getStop() ) right = normal_context.getStop();\r\n\r\n                location = GenomeLocParser.setStart(location,pos);\r\n                location = GenomeLocParser.setStop(location,pos); // retrieve annotation data\r\n                RODRecordList annotationList = (refseqIterator == null ? null : refseqIterator.seekForward(location));\r\n\r\n                if ( normalCall.failsNQSMismatch() ) {\r\n                    String fullRecord = makeFullRecord(normalCall);\r\n                    String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n                    out.println(fullRecord+\r\n                    \"SAMPLE_TOO_DIRTY\\t\"+annotationString);\r\n                    normal_context.indelsAt(pos).clear();\r\n                        // we dealt with this indel; don't want to see it again\r\n                        // (we might otherwise in the case when 1) there is another indel that follows\r\n                        // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n                    continue; // too dirty\r\n                }\r\n\r\n                if ( normalCall.isCall() ) {\r\n                    normalCallsMade++;\r\n                    String message = normalCall.makeBedLine(output);\r\n                    String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n\r\n                    StringBuilder fullRecord = new StringBuilder();\r\n                    fullRecord.append(makeFullRecord(normalCall));\r\n\r\n                    if ( verbose ) {\r\n                        if ( refseqIterator == null ) out.println(fullRecord + \"\\t\");\r\n                        else out.println(fullRecord + \"\\t\"+ annotationString);\r\n                    }\r\n                }\r\n\r\n                normal_context.indelsAt(pos).clear();\r\n                    // we dealt with this indel; don't want to see it again\r\n                    // (we might otherwise in the case when 1) there is another indel that follows\r\n                    // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n            }\r\n\r\n            if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n            normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","id":38616,"modified_method":"/** Output indel calls up to the specified position and shift the window: after this method is executed, the\r\n    * first element of the window maps onto 'position', if possible, or at worst a few bases to the left of 'position' if we may need more\r\n    * reads to get full NQS-style statistics for an indel in the close proximity of 'position'.\r\n    *\r\n    * @param position\r\n    */\r\n   private void emit(long position, boolean force) {\r\n\r\n            long adjustedPosition = adjustPosition(position);\r\n\r\n            if ( adjustedPosition == -1 ) {\r\n                // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                normal_context.shift((int)(position-normal_context.getStart()));\r\n                return;\r\n            }\r\n            long move_to = adjustedPosition;\r\n\r\n            for ( long pos = normal_context.getStart() ; pos < Math.min(adjustedPosition,normal_context.getStop()+1) ; pos++ ) {\r\n\r\n                if ( normal_context.indelsAt(pos).size() == 0 ) continue; // no indels\r\n\r\n                IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n                if ( normalCall.getCoverage() < minCoverage ) {\r\n                    if ( DEBUG ) {\r\n                        System.out.println(\"DEBUG>> Indel at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                    }\r\n                    continue; // low coverage\r\n                }\r\n\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> Indel at \"+pos);\r\n\r\n                long left = Math.max( pos-NQS_WIDTH, normal_context.getStart() );\r\n                long right = pos+normalCall.getVariant().lengthOnRef()+NQS_WIDTH-1;\r\n\r\n                if ( right >= adjustedPosition && ! force) {\r\n                    // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                    // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                    // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                    move_to = adjustPosition(left);\r\n                    if ( move_to == -1 ) {\r\n                        // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                        normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                        return;\r\n                    }\r\n                    if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                    break;\r\n                }\r\n\r\n                // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right:\r\n                if ( right > normal_context.getStop() ) right = normal_context.getStop();\r\n\r\n                location = GenomeLocParser.setStart(location,pos);\r\n                location = GenomeLocParser.setStop(location,pos); // retrieve annotation data\r\n\r\n                if ( normalCall.isCall() ) {\r\n                    normalCallsMade++;\r\n                    printVCFLine(vcf_writer,normalCall);\r\n                    if ( bedWriter != null ) normalCall.printBedLine(bedWriter);\r\n\r\n                    if ( verboseWriter != null ) {\r\n\r\n                        RODRecordList annotationList = (refseqIterator == null ? null : refseqIterator.seekForward(location));\r\n                        String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n\r\n                        StringBuilder fullRecord = new StringBuilder();\r\n                        fullRecord.append(makeFullRecord(normalCall));\r\n                        fullRecord.append(annotationString);\r\n                        try {\r\n                            verboseWriter.write(fullRecord.toString());\r\n                        } catch (IOException e) {\r\n                            throw new StingException(\"Write failed (verbose writer). \"+e.getMessage());\r\n                        }\r\n                    }\r\n                }\r\n\r\n                normal_context.indelsAt(pos).clear();\r\n                    // we dealt with this indel; don't want to see it again\r\n                    // (we might otherwise in the case when 1) there is another indel that follows\r\n                    // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n            }\r\n\r\n            if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n            normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\r\n\tpublic Integer map(ReferenceContext ref, SAMRecord read, ReadMetaDataTracker metaDataTracker) {\r\n\r\n    //        if ( read.getReadName().equals(\"428EFAAXX090610:2:36:1384:639#0\") ) System.out.println(\"GOT READ\");\r\n\r\n            if ( DEBUG ) {\r\n                //            System.out.println(\"DEBUG>> read at \"+ read.getAlignmentStart()+\"-\"+read.getAlignmentEnd()+\r\n                //                    \"(\"+read.getCigarString()+\")\");\r\n                if ( read.getDuplicateReadFlag() ) System.out.println(\"DEBUG>> Duplicated read (IGNORED)\");\r\n            }\r\n\r\n            if ( AlignmentUtils.isReadUnmapped(read) ||\r\n\t\t\t read.getDuplicateReadFlag() ||\r\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\r\n\t\t\t read.getMappingQuality() == 0 ) {\r\n\t\t\treturn 0; // we do not need those reads!\r\n            }\r\n\r\n            if ( read.getReferenceIndex() != currentContigIndex ) {\r\n                // we just jumped onto a new contig\r\n                if ( DEBUG ) System.out.println(\"DEBUG>>> Moved to contig \"+read.getReferenceName());\r\n                if ( read.getReferenceIndex() < currentContigIndex ) // paranoidal\r\n                    throw new StingException(\"Read \"+read.getReadName()+\": contig is out of order; input BAM file is unsorted\");\r\n\r\n                // print remaining indels from the previous contig (if any);\r\n                if ( call_somatic ) emit_somatic(1000000000, true);\r\n                else emit(1000000000,true);\r\n\r\n                currentContigIndex = read.getReferenceIndex();\r\n                currentPosition = read.getAlignmentStart();\r\n                refName = new String(read.getReferenceName());\r\n\r\n                location = GenomeLocParser.setContig(location,refName);\r\n                contigLength = GenomeLocParser.getContigInfo(refName).getSequenceLength();\r\n                outOfContigUserWarned = false;\r\n\r\n                normal_context.clear(); // reset coverage window; this will also set reference position to 0\r\n                if ( call_somatic) tumor_context.clear();\r\n            }\r\n\r\n            // we have reset the window to the new contig if it was required and emitted everything we collected\r\n            // on a previous contig. At this point we are guaranteed that we are set up properly for working\r\n            // with the contig of the current read.\r\n\r\n            // NOTE: all the sanity checks and error messages below use normal_context only. We make sure that normal_context and\r\n            // tumor_context are synchronized exactly (windows are always shifted together by emit_somatic), so it's safe\r\n\r\n            if ( read.getAlignmentStart() < currentPosition ) // oops, read out of order?\r\n                throw new StingException(\"Read \"+read.getReadName() +\" out of order on the contig\\n\"+\r\n                                         \"Read starts at \"+refName+\":\"+read.getAlignmentStart()+\"; last read seen started at \"+refName+\":\"+currentPosition\r\n\t\t\t\t\t+\"\\nLast read was: \"+lastRead.getReadName()+\" RG=\"+lastRead.getAttribute(\"RG\")+\" at \"+lastRead.getAlignmentStart()+\"-\"\r\n\t\t\t\t\t+lastRead.getAlignmentEnd()+\" cigar=\"+lastRead.getCigarString());\r\n\r\n            currentPosition = read.getAlignmentStart();\r\n            lastRead = read;\r\n\r\n            if ( read.getAlignmentEnd() > contigLength  ) {\r\n                if ( ! outOfContigUserWarned ) {\r\n                    System.out.println(\"WARNING: Reads aligned past contig length on \"+ location.getContig()+\"; all such reads will be skipped\");\r\n                    outOfContigUserWarned = true;\r\n                }\r\n                return 0;\r\n            }\r\n\r\n            long alignmentEnd = read.getAlignmentEnd();\r\n            Cigar c = read.getCigar();\r\n            int lastNonClippedElement = 0; // reverse offset to the last unclipped element\r\n            CigarOperator op = null;\r\n            // moving backwards from the end of the cigar, skip trailing S or H cigar elements:\r\n            do {\r\n                lastNonClippedElement++;\r\n                op = c.getCigarElement( c.numCigarElements()-lastNonClippedElement ).getOperator();\r\n            } while ( op == CigarOperator.H || op == CigarOperator.S );\r\n\r\n            // now op is the last non-S/H operator in the cigar.\r\n\r\n            // a little trick here: we want to make sure that current read completely fits into the current\r\n            // window so that we can accumulate indel observations over the whole length of the read.\r\n            // The ::getAlignmentEnd() method returns the last position on the reference where bases from the\r\n            // read actually match (M cigar elements). After our cleaning procedure, we can have reads that end\r\n            // with I element, which is not gonna be counted into alignment length on the reference. On the other hand,\r\n            // in this program we assign insertions, internally, to the first base *after* the insertion position.\r\n            // Hence, we have to make sure that that extra base is already in the window or we will get IndexOutOfBounds.\r\n\r\n            if ( op == CigarOperator.I) alignmentEnd++;\r\n\r\n            if ( alignmentEnd > normal_context.getStop()) {\r\n\r\n                // we don't emit anything until we reach a read that does not fit into the current window.\r\n                // At that point we try shifting the window to the start of that read (or reasonably close) and emit everything prior to\r\n                // that position. This is legitimate, since the reads are sorted and  we are not gonna see any more coverage at positions\r\n                // below the current read's start.\r\n                // Clearly, we assume here that window is large enough to accomodate any single read, so simply shifting\r\n                // the window to around the read's start will ensure that the read fits...\r\n\r\n                if ( DEBUG) System.out.println(\"DEBUG>> Window at \"+normal_context.getStart()+\"-\"+normal_context.getStop()+\", read at \"+\r\n                                read.getAlignmentStart()+\": trying to emit and shift\" );\r\n                if ( call_somatic ) emit_somatic( read.getAlignmentStart(), false );\r\n                else emit( read.getAlignmentStart(), false );\r\n\r\n                // let's double check now that the read fits after the shift\r\n                if ( read.getAlignmentEnd() > normal_context.getStop()) {\r\n                    // ooops, looks like the read does not fit into the window even after the latter was shifted!!\r\n                    throw new StingException(\"Read \"+read.getReadName()+\": out of coverage window bounds. Probably window is too small.\\n\"+\r\n                                             \"Read length=\"+read.getReadLength()+\"; cigar=\"+read.getCigarString()+\"; start=\"+\r\n                                             read.getAlignmentStart()+\"; end=\"+read.getAlignmentEnd()+\r\n                                             \"; window start (after trying to accomodate the read)=\"+normal_context.getStart()+\r\n\t\t\t\t\t\"; window end=\"+normal_context.getStop());\r\n                }\r\n            }\r\n\r\n            if ( call_somatic ) {\r\n\r\n                String rg = (String)read.getAttribute(\"RG\");\r\n                if ( rg == null ) throw new StingException(\"Read \"+read.getReadName()+\" has no read group in merged stream. RG is required for somatic calls.\");\r\n\r\n                if ( normalReadGroups.contains(rg) ) {\r\n                    normal_context.add(read,ref.getBasesAsChars());\r\n                } else if ( tumorReadGroups.contains(rg) ) {\r\n                    tumor_context.add(read,ref.getBasesAsChars());\r\n                } else {\r\n                    throw new StingException(\"Unrecognized read group in merged stream: \"+rg);\r\n                }\r\n                if ( tumor_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+tumor_context.getStart()+'-'+tumor_context.getStop()+\" in tumor sample. The whole window will be dropped.\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\" in normal sample. The whole window will be dropped\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n\r\n\r\n            } else {\r\n                normal_context.add(read, ref.getBasesAsChars());\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\". The whole window will be dropped\");\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n            }\r\n\r\n            return 1;\r\n\t}","id":38617,"modified_method":"@Override\r\n\tpublic Integer map(ReferenceContext ref, SAMRecord read, ReadMetaDataTracker metaDataTracker) {\r\n\r\n    //        if ( read.getReadName().equals(\"428EFAAXX090610:2:36:1384:639#0\") ) System.out.println(\"GOT READ\");\r\n\r\n            if ( DEBUG ) {\r\n                //            System.out.println(\"DEBUG>> read at \"+ read.getAlignmentStart()+\"-\"+read.getAlignmentEnd()+\r\n                //                    \"(\"+read.getCigarString()+\")\");\r\n                if ( read.getDuplicateReadFlag() ) System.out.println(\"DEBUG>> Duplicated read (IGNORED)\");\r\n            }\r\n\r\n            if ( AlignmentUtils.isReadUnmapped(read) ||\r\n\t\t\t read.getDuplicateReadFlag() ||\r\n\t\t\t read.getNotPrimaryAlignmentFlag() ||\r\n\t\t\t read.getMappingQuality() == 0 ) {\r\n\t\t\treturn 0; // we do not need those reads!\r\n            }\r\n\r\n            if ( read.getReferenceIndex() != currentContigIndex ) {\r\n                // we just jumped onto a new contig\r\n                if ( DEBUG ) System.out.println(\"DEBUG>>> Moved to contig \"+read.getReferenceName());\r\n                if ( read.getReferenceIndex() < currentContigIndex ) // paranoidal\r\n                    throw new StingException(\"Read \"+read.getReadName()+\": contig is out of order; input BAM file is unsorted\");\r\n\r\n                // print remaining indels from the previous contig (if any);\r\n                if ( call_somatic ) emit_somatic(1000000000, true);\r\n                else emit(1000000000,true);\r\n\r\n                currentContigIndex = read.getReferenceIndex();\r\n                currentPosition = read.getAlignmentStart();\r\n                refName = new String(read.getReferenceName());\r\n\r\n                location = GenomeLocParser.setContig(location,refName);\r\n                contigLength = GenomeLocParser.getContigInfo(refName).getSequenceLength();\r\n                outOfContigUserWarned = false;\r\n\r\n                normal_context.clear(); // reset coverage window; this will also set reference position to 0\r\n                if ( call_somatic) tumor_context.clear();\r\n\r\n                refBases = new String(refData.getReference().getSequence(read.getReferenceName()).getBases()).toUpperCase().getBytes();\r\n            }\r\n\r\n            // we have reset the window to the new contig if it was required and emitted everything we collected\r\n            // on a previous contig. At this point we are guaranteed that we are set up properly for working\r\n            // with the contig of the current read.\r\n\r\n            // NOTE: all the sanity checks and error messages below use normal_context only. We make sure that normal_context and\r\n            // tumor_context are synchronized exactly (windows are always shifted together by emit_somatic), so it's safe\r\n\r\n            if ( read.getAlignmentStart() < currentPosition ) // oops, read out of order?\r\n                throw new StingException(\"Read \"+read.getReadName() +\" out of order on the contig\\n\"+\r\n                                         \"Read starts at \"+refName+\":\"+read.getAlignmentStart()+\"; last read seen started at \"+refName+\":\"+currentPosition\r\n\t\t\t\t\t+\"\\nLast read was: \"+lastRead.getReadName()+\" RG=\"+lastRead.getAttribute(\"RG\")+\" at \"+lastRead.getAlignmentStart()+\"-\"\r\n\t\t\t\t\t+lastRead.getAlignmentEnd()+\" cigar=\"+lastRead.getCigarString());\r\n\r\n            currentPosition = read.getAlignmentStart();\r\n            lastRead = read;\r\n\r\n            if ( read.getAlignmentEnd() > contigLength  ) {\r\n                if ( ! outOfContigUserWarned ) {\r\n                    System.out.println(\"WARNING: Reads aligned past contig length on \"+ location.getContig()+\"; all such reads will be skipped\");\r\n                    outOfContigUserWarned = true;\r\n                }\r\n                return 0;\r\n            }\r\n\r\n            long alignmentEnd = read.getAlignmentEnd();\r\n            Cigar c = read.getCigar();\r\n            int lastNonClippedElement = 0; // reverse offset to the last unclipped element\r\n            CigarOperator op = null;\r\n            // moving backwards from the end of the cigar, skip trailing S or H cigar elements:\r\n            do {\r\n                lastNonClippedElement++;\r\n                op = c.getCigarElement( c.numCigarElements()-lastNonClippedElement ).getOperator();\r\n            } while ( op == CigarOperator.H || op == CigarOperator.S );\r\n\r\n            // now op is the last non-S/H operator in the cigar.\r\n\r\n            // a little trick here: we want to make sure that current read completely fits into the current\r\n            // window so that we can accumulate indel observations over the whole length of the read.\r\n            // The ::getAlignmentEnd() method returns the last position on the reference where bases from the\r\n            // read actually match (M cigar elements). After our cleaning procedure, we can have reads that end\r\n            // with I element, which is not gonna be counted into alignment length on the reference. On the other hand,\r\n            // in this program we assign insertions, internally, to the first base *after* the insertion position.\r\n            // Hence, we have to make sure that that extra base is already in the window or we will get IndexOutOfBounds.\r\n\r\n            if ( op == CigarOperator.I) alignmentEnd++;\r\n\r\n            if ( alignmentEnd > normal_context.getStop()) {\r\n\r\n                // we don't emit anything until we reach a read that does not fit into the current window.\r\n                // At that point we try shifting the window to the start of that read (or reasonably close) and emit everything prior to\r\n                // that position. This is legitimate, since the reads are sorted and  we are not gonna see any more coverage at positions\r\n                // below the current read's start.\r\n                // Clearly, we assume here that window is large enough to accomodate any single read, so simply shifting\r\n                // the window to around the read's start will ensure that the read fits...\r\n\r\n                if ( DEBUG) System.out.println(\"DEBUG>> Window at \"+normal_context.getStart()+\"-\"+normal_context.getStop()+\", read at \"+\r\n                                read.getAlignmentStart()+\": trying to emit and shift\" );\r\n                if ( call_somatic ) emit_somatic( read.getAlignmentStart(), false );\r\n                else emit( read.getAlignmentStart(), false );\r\n\r\n                // let's double check now that the read fits after the shift\r\n                if ( read.getAlignmentEnd() > normal_context.getStop()) {\r\n                    // ooops, looks like the read does not fit into the window even after the latter was shifted!!\r\n                    throw new StingException(\"Read \"+read.getReadName()+\": out of coverage window bounds. Probably window is too small.\\n\"+\r\n                                             \"Read length=\"+read.getReadLength()+\"; cigar=\"+read.getCigarString()+\"; start=\"+\r\n                                             read.getAlignmentStart()+\"; end=\"+read.getAlignmentEnd()+\r\n                                             \"; window start (after trying to accomodate the read)=\"+normal_context.getStart()+\r\n\t\t\t\t\t\"; window end=\"+normal_context.getStop());\r\n                }\r\n            }\r\n\r\n            if ( call_somatic ) {\r\n\r\n                String rg = (String)read.getAttribute(\"RG\");\r\n                if ( rg == null ) throw new StingException(\"Read \"+read.getReadName()+\" has no read group in merged stream. RG is required for somatic calls.\");\r\n\r\n                if ( normalReadGroups.contains(rg) ) {\r\n                    normal_context.add(read,ref.getBases());\r\n                } else if ( tumorReadGroups.contains(rg) ) {\r\n                    tumor_context.add(read,ref.getBases());\r\n                } else {\r\n                    throw new StingException(\"Unrecognized read group in merged stream: \"+rg);\r\n                }\r\n                if ( tumor_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+tumor_context.getStart()+'-'+tumor_context.getStop()+\" in tumor sample. The whole window will be dropped.\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\" in normal sample. The whole window will be dropped\");\r\n                    tumor_context.shift(WINDOW_SIZE);\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n\r\n\r\n            } else {\r\n                normal_context.add(read, ref.getBases());\r\n                if ( normal_context.getReads().size() > MAX_READ_NUMBER ) {\r\n                    System.out.println(\"WARNING: a count of \"+MAX_READ_NUMBER+\" reads reached in a window \"+\r\n                            refName+':'+normal_context.getStart()+'-'+normal_context.getStop()+\". The whole window will be dropped\");\r\n                    normal_context.shift(WINDOW_SIZE);\r\n                }\r\n            }\r\n\r\n            return 1;\r\n\t}","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String makeBedLine(java.io.Writer bedOutput) {\r\n            int event_length = consensus_indel.lengthOnRef();\r\n            if ( event_length < 0 ) event_length = 0;\r\n            StringBuffer message = new StringBuffer();\r\n            message.append(refName+\"\\t\"+(pos-1)+\"\\t\");\r\n            if ( FORMAT_1KG )\r\n                message.append(consensus_indel.getBases().length() + \"\\t\" + (event_length > 0 ? \"D\" : \"I\") + \"\\t\" +\r\n                        consensus_indel.getBases() + \"\\t\" + consensus_indel.getSamples());\r\n            else\r\n                message.append((pos-1+event_length)+\"\\t\"+(event_length>0? \"-\":\"+\")+consensus_indel.getBases() +\":\"+all_indel_count+\"/\"+total_coverage);\r\n\r\n            if ( bedOutput != null ) {\r\n                try {\r\n                    bedOutput.write(message.toString()+\"\\n\");\r\n                } catch (IOException e) {\r\n                    System.out.println(e.getMessage());\r\n                    e.printStackTrace();\r\n                    throw new StingException(\"Error encountered while writing into output BED file\");\r\n                }\r\n            }\r\n            return message.toString();\r\n        }","id":38618,"modified_method":"public void printBedLine(Writer bed) {\r\n            int event_length = consensus_indel.lengthOnRef();\r\n            if ( event_length < 0 ) event_length = 0;\r\n\r\n            StringBuffer message = new StringBuffer();\r\n            message.append(refName+\"\\t\"+(pos-1)+\"\\t\");\r\n            message.append((pos-1+event_length)+\"\\t\"+(event_length>0? \"-\":\"+\")+consensus_indel.getBases() +\":\"+all_indel_count+\"/\"+total_coverage);\r\n\r\n           try {\r\n                bed.write(message.toString()+\"\\n\");\r\n           } catch (IOException e) {\r\n                throw new StingException(\"Error encountered while writing into output BED file\");\r\n           }\r\n        }","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\r\n\tpublic void initialize() {\r\n\t\tnormal_context = new WindowContext(0,WINDOW_SIZE);\r\n\r\n\t\tif ( RefseqFileName != null ) {\r\n\t\t\tTribbleRMDTrackBuilder builder = new TribbleRMDTrackBuilder();\r\n            FeatureSource refseq = builder.createFeatureReader(RefSeqCodec.class,new File(RefseqFileName)).first;\r\n\r\n            try {\r\n                refseqIterator = new SeekableRODIterator(new FeatureToGATKFeatureIterator(refseq.iterator(),\"refseq\"));\r\n            } catch (IOException e) {\r\n                throw new StingException(\"Unable to open file \" + RefseqFileName, e);\r\n            }\r\n            logger.info(\"Using RefSeq annotations from \"+RefseqFileName);\r\n\t\t}\r\n\r\n\t\tif ( refseqIterator == null ) logger.info(\"No annotations available\");\r\n\r\n\t\tint nSams = getToolkit().getArguments().samFiles.size();\r\n\r\n\t\tlocation = GenomeLocParser.createGenomeLoc(0,1);\r\n\r\n\t\tList<Set<String>> readGroupSets = getToolkit().getMergedReadGroupsByReaders();\r\n\r\n\t\tif ( call_somatic ) {\r\n\t\t\tif ( nSams != 2 ) {\r\n\t\t\t\tSystem.out.println(\"In --somatic mode two input bam files must be specified (normal/tumor)\");\r\n\t\t\t\tSystem.exit(1);\r\n\t\t\t}\r\n\t\t\ttumor_context = new WindowContext(0,WINDOW_SIZE);\r\n\r\n\t\t\tnormalReadGroups = readGroupSets.get(0); // first -I option must specify normal.bam\r\n                        System.out.println(normalReadGroups.size() + \" normal read groups\");\r\n                        //for ( String rg : normalReadGroups ) System.out.println(\"Normal RG: \"+rg);\r\n\r\n\t\t\ttumorReadGroups = readGroupSets.get(1); // second -I option must specify tumor.bam\r\n                        System.out.println(tumorReadGroups.size() + \" tumor read groups\");\r\n                        // for ( String rg : tumorReadGroups ) System.out.println(\"Tumor RG: \"+rg);\r\n\t\t} else {\r\n\t\t\tif ( nSams != 1 ) System.out.println(\"WARNING: multiple input files specified. \\n\"+\r\n\t\t\t\t\t\"WARNING: Without --somatic option they will be merged and processed as a single sample\");\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\toutput = new java.io.FileWriter(bed_file);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new StingException(\"Failed to open file for writing BED output\");\r\n\t\t}\r\n\t}","id":38619,"modified_method":"@Override\r\n\tpublic void initialize() {\r\n\t\tnormal_context = new WindowContext(0,WINDOW_SIZE);\r\n\r\n        if ( bedOutput != null && output_file != null ) {\r\n            throw new StingException(\"-O option is deprecated and -bed option replaces it; you can not use both at the same time\");\r\n        }\r\n\r\n\t\tif ( RefseqFileName != null ) {\r\n            logger.info(\"Using RefSeq annotations from \"+RefseqFileName);\r\n\r\n\t\t\tTribbleRMDTrackBuilder builder = new TribbleRMDTrackBuilder();\r\n            FeatureSource refseq = builder.createFeatureReader(RefSeqCodec.class,new File(RefseqFileName)).first;\r\n\r\n            try {\r\n                refseqIterator = new SeekableRODIterator(new FeatureToGATKFeatureIterator(refseq.iterator(),\"refseq\"));\r\n            } catch (IOException e) {\r\n                throw new StingException(\"Unable to open file \" + RefseqFileName, e);\r\n            }\r\n\t\t}\r\n\r\n\t\tif ( refseqIterator == null ) logger.info(\"No gene annotations available\");\r\n\r\n\t\tint nSams = getToolkit().getArguments().samFiles.size();\r\n\r\n\t\tlocation = GenomeLocParser.createGenomeLoc(0,1);\r\n\r\n\t\tList<Set<String>> readGroupSets = getToolkit().getMergedReadGroupsByReaders();\r\n\r\n\t\tif ( call_somatic ) {\r\n\t\t\tif ( nSams != 2 ) {\r\n\t\t\t\tSystem.out.println(\"In --somatic mode two input bam files must be specified (normal/tumor)\");\r\n\t\t\t\tSystem.exit(1);\r\n\t\t\t}\r\n\t\t\ttumor_context = new WindowContext(0,WINDOW_SIZE);\r\n\r\n\t\t\tnormalReadGroups = readGroupSets.get(0); // first -I option must specify normal.bam\r\n                        System.out.println(normalReadGroups.size() + \" normal read groups\");\r\n                        //for ( String rg : normalReadGroups ) System.out.println(\"Normal RG: \"+rg);\r\n\r\n\t\t\ttumorReadGroups = readGroupSets.get(1); // second -I option must specify tumor.bam\r\n                        System.out.println(tumorReadGroups.size() + \" tumor read groups\");\r\n                        // for ( String rg : tumorReadGroups ) System.out.println(\"Tumor RG: \"+rg);\r\n\t\t} else {\r\n\t\t\tif ( nSams != 1 ) System.out.println(\"WARNING: multiple input files specified. \\n\"+\r\n\t\t\t\t\t\"WARNING: Without --somatic option they will be merged and processed as a single sample\");\r\n\t\t}\r\n\r\n        try {\r\n            // we already checked that bedOutput and output_file are not set simultaneously\r\n            if ( bedOutput != null ) bedWriter = new FileWriter(bedOutput);\r\n            if ( output_file != null ) bedWriter = new FileWriter(output_file);\r\n        } catch (java.io.IOException e) {\r\n            throw new StingException(\"Failed to open BED file for writing. \"+ e.getMessage());\r\n        }\r\n        try {\r\n            if ( verboseOutput != null ) verboseWriter = new FileWriter(verboseOutput);\r\n        } catch (java.io.IOException e) {\r\n            throw new StingException(\"Failed to open verbose file for writing. \"+ e.getMessage());\r\n        }\r\n\r\n        vcf_writer.writeHeader(new VCFHeader(getVCFHeaderInfo(), SampleUtils.getSAMFileSamples(getToolkit().getSAMFileHeader()))) ;\r\n        refData = new ReferenceDataSource(getToolkit().getArguments().referenceFile);\r\n\t}","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean isCall() {\r\n            boolean ret = ! failsNQSMismatch() && ( consensus_indel_count >= minIndelCount &&\r\n                    (double)consensus_indel_count > minFraction * total_coverage &&\r\n                    (double) consensus_indel_count > minConsensusFraction*all_indel_count );\r\n            if ( DEBUG && ! ret ) System.out.println(\"DEBUG>>  NOT a call: count=\"+consensus_indel_count+\r\n                        \" total_count=\"+all_indel_count+\" cov=\"+total_coverage+\r\n                \" minConsensusF=\"+((double)consensus_indel_count)/all_indel_count+\r\n                    \" minF=\"+((double)consensus_indel_count)/total_coverage);\r\n            return ret;\r\n\r\n        }","id":38620,"modified_method":"public boolean isCall() {\r\n            boolean ret =  ( consensus_indel_count >= minIndelCount &&\r\n                    (double)consensus_indel_count > minFraction * total_coverage &&\r\n                    (double) consensus_indel_count > minConsensusFraction*all_indel_count );\r\n            if ( DEBUG && ! ret ) System.out.println(\"DEBUG>>  NOT a call: count=\"+consensus_indel_count+\r\n                        \" total_count=\"+all_indel_count+\" cov=\"+total_coverage+\r\n                \" minConsensusF=\"+((double)consensus_indel_count)/all_indel_count+\r\n                    \" minF=\"+((double)consensus_indel_count)/total_coverage);\r\n            return ret;\r\n\r\n        }","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\r\n    public void onTraversalDone(Integer result) {\r\n        if ( call_somatic ) emit_somatic(1000000000, true);\r\n        else emit(1000000000,true); // emit everything we might have left\r\n\r\n        if ( metricsWriter != null ) {\r\n            metricsWriter.println(String.format(\"Normal calls made     %d\", normalCallsMade));\r\n            metricsWriter.println(String.format(\"Tumor calls made      %d\", tumorCallsMade));\r\n        }\r\n\r\n        try {\r\n            output.close();\r\n        } catch (IOException e) {\r\n            System.out.println(\"Failed to close output BED file gracefully, data may be lost\");\r\n            e.printStackTrace();\r\n        }\r\n        super.onTraversalDone(result);\r\n    }","id":38621,"modified_method":"@Override\r\n    public void onTraversalDone(Integer result) {\r\n        if ( call_somatic ) emit_somatic(1000000000, true);\r\n        else emit(1000000000,true); // emit everything we might have left\r\n\r\n        if ( metricsWriter != null ) {\r\n            metricsWriter.println(String.format(\"Normal calls made     %d\", normalCallsMade));\r\n            metricsWriter.println(String.format(\"Tumor calls made      %d\", tumorCallsMade));\r\n            metricsWriter.close();\r\n        }\r\n\r\n        try {\r\n            if ( bedWriter != null ) bedWriter.close();\r\n            if ( verboseWriter != null ) verboseWriter.close();\r\n        } catch (IOException e) {\r\n            System.out.println(\"Failed to close output BED file gracefully, data may be lost\");\r\n            e.printStackTrace();\r\n        }\r\n        super.onTraversalDone(result);\r\n    }","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Output somatic indel calls up to the specified position and shift the coverage array(s): after this method is executed\r\n     * first elements of the coverage arrays map onto 'position', or a few bases prior to the specified position\r\n     * if there is an indel in close proximity to 'position' so that we may get more coverage around it later.\r\n     *\r\n     * @param position\r\n     */\r\n    private void emit_somatic(long position, boolean force) {\r\n\r\n        long adjustedPosition = adjustPosition(position);\r\n        if ( adjustedPosition == -1 ) {\r\n            // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n            normal_context.shift((int)(position-normal_context.getStart()));\r\n            tumor_context.shift((int)(position-tumor_context.getStart()));\r\n            return;\r\n        }\r\n        long move_to = adjustedPosition;\r\n\r\n        for ( long pos = tumor_context.getStart() ; pos < Math.min(adjustedPosition,tumor_context.getStop()+1) ; pos++ ) {\r\n\r\n            if ( tumor_context.indelsAt(pos).size() == 0 ) continue; // no indels in tumor\r\n\r\n            IndelPrecall tumorCall = new IndelPrecall(tumor_context,pos,NQS_WIDTH);\r\n            IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n            if ( tumorCall.getCoverage() < minCoverage ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in tumor=\"+tumorCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n            if ( normalCall.getCoverage() < minNormalCoverage ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n\r\n            if ( DEBUG ) System.out.println(\"DEBUG>> Indel in tumor at \"+pos);\r\n\r\n            long left = Math.max( pos-NQS_WIDTH, tumor_context.getStart() );\r\n            long right = pos+tumorCall.getVariant().lengthOnRef()+NQS_WIDTH-1;\r\n\r\n            if ( right >= adjustedPosition && ! force) {\r\n                // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                move_to = adjustPosition(left);\r\n                if ( move_to == -1 ) {\r\n                    // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                    normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                    tumor_context.shift((int)(adjustedPosition-tumor_context.getStart()));\r\n                    return;\r\n                }\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                break;\r\n            }\r\n\r\n            if ( right > tumor_context.getStop() ) right = tumor_context.getStop(); // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right\r\n\r\n            location = GenomeLocParser.setStart(location,pos);\r\n            location = GenomeLocParser.setStop(location,pos); // retrieve annotation data\r\n            RODRecordList annotationList = (refseqIterator == null ? null : refseqIterator.seekForward(location));\r\n\r\n            if ( normalCall.failsNQSMismatch() ) {\r\n                String fullRecord = makeFullRecord(normalCall,tumorCall);\r\n                String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n                out.println(fullRecord+\r\n                \"NORMAL_TOO_DIRTY\\t\"+annotationString);\r\n                tumor_context.indelsAt(pos).clear();\r\n                normal_context.indelsAt(pos).clear();\r\n                    // we dealt with this indel; don't want to see it again\r\n                    // (we might otherwise in the case when 1) there is another indel that follows\r\n                    // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n                continue; // too dirty\r\n            }\r\n            if ( tumorCall.failsNQSMismatch() ) {\r\n                String fullRecord = makeFullRecord(normalCall,tumorCall);\r\n                String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n                out.println(fullRecord+\r\n                \"TUMOR_TOO_DIRTY\\t\"+annotationString);\r\n                tumor_context.indelsAt(pos).clear();\r\n                normal_context.indelsAt(pos).clear();\r\n                    // we dealt with this indel; don't want to see it again\r\n                    // (we might otherwise in the case when 1) there is another indel that follows\r\n                    // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n                continue; // too dirty\r\n            }\r\n\r\n            if ( tumorCall.isCall() ) {\r\n                tumorCallsMade++;\r\n                String message = tumorCall.makeBedLine(output);\r\n                String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n\r\n                StringBuilder fullRecord = new StringBuilder();\r\n                fullRecord.append(makeFullRecord(normalCall,tumorCall));\r\n\r\n                if ( normalCall.getVariant() == null ) {\r\n                    fullRecord.append(\"SOMATIC\");\r\n                } else {\r\n                    fullRecord.append(\"GERMLINE\");\r\n                }\r\n                if ( verbose ) {\r\n                    if ( refseqIterator == null ) out.println(fullRecord + \"\\t\");\r\n                    else out.println(fullRecord + \"\\t\"+ annotationString);\r\n                }\r\n            }\r\n\r\n            tumor_context.indelsAt(pos).clear();\r\n            normal_context.indelsAt(pos).clear();\r\n                // we dealt with this indel; don't want to see it again\r\n                // (we might otherwise in the case when 1) there is another indel that follows\r\n                // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n        }\r\n\r\n        if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n        tumor_context.shift((int)(move_to - tumor_context.getStart() ) );\r\n        normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","id":38622,"modified_method":"/** Output somatic indel calls up to the specified position and shift the coverage array(s): after this method is executed\r\n     * first elements of the coverage arrays map onto 'position', or a few bases prior to the specified position\r\n     * if there is an indel in close proximity to 'position' so that we may get more coverage around it later.\r\n     *\r\n     * @param position\r\n     */\r\n    private void emit_somatic(long position, boolean force) {\r\n\r\n        long adjustedPosition = adjustPosition(position);\r\n        if ( adjustedPosition == -1 ) {\r\n            // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n            normal_context.shift((int)(position-normal_context.getStart()));\r\n            tumor_context.shift((int)(position-tumor_context.getStart()));\r\n            return;\r\n        }\r\n        long move_to = adjustedPosition;\r\n\r\n        for ( long pos = tumor_context.getStart() ; pos < Math.min(adjustedPosition,tumor_context.getStop()+1) ; pos++ ) {\r\n\r\n            if ( tumor_context.indelsAt(pos).size() == 0 ) continue; // no indels in tumor\r\n\r\n            IndelPrecall tumorCall = new IndelPrecall(tumor_context,pos,NQS_WIDTH);\r\n            IndelPrecall normalCall = new IndelPrecall(normal_context,pos,NQS_WIDTH);\r\n\r\n            if ( tumorCall.getCoverage() < minCoverage ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in tumor=\"+tumorCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n            if ( normalCall.getCoverage() < minNormalCoverage ) {\r\n                if ( DEBUG ) {\r\n                    System.out.println(\"DEBUG>> Indel in tumor at \"+pos+\"; coverare in normal=\"+normalCall.getCoverage()+\" (SKIPPED)\");\r\n                }\r\n                continue; // low coverage\r\n            }\r\n\r\n            if ( DEBUG ) System.out.println(\"DEBUG>> Indel in tumor at \"+pos);\r\n\r\n            long left = Math.max( pos-NQS_WIDTH, tumor_context.getStart() );\r\n            long right = pos+tumorCall.getVariant().lengthOnRef()+NQS_WIDTH-1;\r\n\r\n            if ( right >= adjustedPosition && ! force) {\r\n                // we are not asked to force-shift, and there is more coverage around the current indel that we still need to collect\r\n\r\n                // we are not asked to force-shift, and there's still additional coverage to the right of current indel, so its too early to emit it;\r\n                // instead we shift only up to current indel pos - MISMATCH_WIDTH, so that we could keep collecting that coverage\r\n                move_to = adjustPosition(left);\r\n                if ( move_to == -1 ) {\r\n                    // failed to find appropriate shift position, the data are probably to messy anyway so we drop them altogether\r\n                    normal_context.shift((int)(adjustedPosition-normal_context.getStart()));\r\n                    tumor_context.shift((int)(adjustedPosition-tumor_context.getStart()));\r\n                    return;\r\n                }\r\n                if ( DEBUG ) System.out.println(\"DEBUG>> waiting for coverage; actual shift performed to \"+ move_to);\r\n                break;\r\n            }\r\n\r\n            if ( right > tumor_context.getStop() ) right = tumor_context.getStop(); // if indel is too close to the end of the window but we need to emit anyway (force-shift), adjust right\r\n\r\n            location = GenomeLocParser.setStart(location,pos);\r\n            location = GenomeLocParser.setStop(location,pos); // retrieve annotation data\r\n\r\n            if ( tumorCall.isCall() ) {\r\n                tumorCallsMade++;\r\n\r\n                printVCFLine(vcf_writer,normalCall,tumorCall);\r\n\r\n                if ( bedWriter != null ) tumorCall.printBedLine(bedWriter);\r\n\r\n                if ( verboseWriter != null ) {\r\n                    RODRecordList annotationList = (refseqIterator == null ? null : refseqIterator.seekForward(location));\r\n                    String annotationString = (refseqIterator == null ? \"\" : getAnnotationString(annotationList));\r\n\r\n                    StringBuilder fullRecord = new StringBuilder();\r\n                    fullRecord.append(makeFullRecord(normalCall,tumorCall));\r\n\r\n                    if ( normalCall.getVariant() == null ) {\r\n                        fullRecord.append(\"SOMATIC\");\r\n                    } else {\r\n                        fullRecord.append(\"GERMLINE\");\r\n                    }\r\n                    try {\r\n                        verboseWriter.write(fullRecord + \"\\t\"+ annotationString);\r\n                    } catch (IOException e) {\r\n                        throw new StingException(\"Write failed (verbose writer). \"+e.getMessage());\r\n                    }\r\n                }\r\n            }\r\n            tumor_context.indelsAt(pos).clear();\r\n            normal_context.indelsAt(pos).clear();\r\n                // we dealt with this indel; don't want to see it again\r\n                // (we might otherwise in the case when 1) there is another indel that follows\r\n                // within MISMATCH_WIDTH bases and 2) we'd need to wait for more coverage for that next indel)\r\n\r\n//\t\t\tfor ( IndelVariant var : variants ) {\r\n//\t\t\t\tSystem.out.print(\"\\t\"+var.getType()+\"\\t\"+var.getBases()+\"\\t\"+var.getCount());\r\n//\t\t\t}\r\n        }\r\n\r\n        if ( DEBUG ) System.out.println(\"DEBUG>> Actual shift to \" + move_to + \" (\"+adjustedPosition+\")\");\r\n        tumor_context.shift((int)(move_to - tumor_context.getStart() ) );\r\n        normal_context.shift((int)(move_to - normal_context.getStart() ) );\r\n    }","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ExpandedSAMRecord(SAMRecord r, char [] ref, long offset, IndelListener l) {\r\n\r\n            read = r;\r\n            final long rStart = read.getAlignmentStart();\r\n            final long rStop = read.getAlignmentEnd();\r\n            final String readBases = read.getReadString().toUpperCase();\r\n\r\n            mismatch_flags = new byte[(int)(rStop-rStart+1)];\r\n            expanded_quals = new byte[(int)(rStop-rStart+1)];\r\n\r\n            // now let's extract indels:\r\n\r\n            Cigar c = read.getCigar();\r\n            final int nCigarElems = c.numCigarElements();\r\n\r\n            int posOnRead = 0;\r\n            int posOnRef = 0; // the chunk of reference ref[] that we have access to is aligned with the read:\r\n                              // its start on the actual full reference contig is r.getAlignmentStart()\r\n            for ( int i = 0 ; i < nCigarElems ; i++ ) {\r\n\r\n                final CigarElement ce = c.getCigarElement(i);\r\n                IndelVariant.Type type = null;\r\n                String bases = null;\r\n                int eventPosition = posOnRef;\r\n\r\n                switch(ce.getOperator()) {\r\n                case H: break; // hard clipped reads do not have clipped bases in their sequence, so we just ignore the H element...\r\n                case I:\r\n                    type = IndelVariant.Type.I;\r\n                    bases = readBases.substring(posOnRead,posOnRead+ce.getLength());\r\n                    // will increment position on the read below, there's no 'break' statement yet...\r\n                case S:\r\n                    // here we also skip soft-clipped bases on the read; according to SAM format specification,\r\n                    // alignment start position on the reference points to where the actually aligned\r\n                    // (not clipped) bases go, so we do not need to increment reference position here\r\n                    posOnRead += ce.getLength();\r\n                    break;\r\n                case D:\r\n                    type = IndelVariant.Type.D;\r\n                    bases = new String( ref, posOnRef, ce.getLength() );\r\n                    for( int k = 0 ; k < ce.getLength(); k++, posOnRef++ ) mismatch_flags[posOnRef] = expanded_quals[posOnRef] = -1;\r\n\r\n                    break;\r\n                case M:\r\n                    for ( int k = 0; k < ce.getLength(); k++, posOnRef++, posOnRead++ ) {\r\n                        if ( readBases.charAt(posOnRead) != //note: readBases was uppercased above!\r\n                             Character.toUpperCase(ref[posOnRef]) ) { // mismatch!\r\n                            mms++;\r\n                            mismatch_flags[posOnRef] = 1;\r\n                        }\r\n                        expanded_quals[posOnRef] = read.getBaseQualities()[posOnRead];\r\n                    }\r\n                    break; // advance along the gapless block in the alignment\r\n                default :\r\n                    throw new IllegalArgumentException(\"Unexpected operator in cigar string: \"+ce.getOperator());\r\n                }\r\n\r\n                if ( type == null ) continue; // element was not an indel, go grab next element...\r\n\r\n                // we got an indel if we are here...\r\n                if ( i == 0 ) logger.debug(\"Indel at the start of the read \"+read.getReadName());\r\n                if ( i == nCigarElems - 1) logger.debug(\"Indel at the end of the read \"+read.getReadName());\r\n\r\n                // note that here we will be assigning indels to the first deleted base or to the first\r\n                // base after insertion, not to the last base before the event!\r\n                l.addObservation((int)(offset+eventPosition), type, bases, this);\r\n            }\r\n        }","id":38623,"modified_method":"public ExpandedSAMRecord(SAMRecord r, byte [] ref, long offset, IndelListener l) {\r\n\r\n            read = r;\r\n            final long rStart = read.getAlignmentStart();\r\n            final long rStop = read.getAlignmentEnd();\r\n            final byte[] readBases = read.getReadString().toUpperCase().getBytes();\r\n\r\n            ref = new String(ref).toUpperCase().getBytes();\r\n\r\n            mismatch_flags = new byte[(int)(rStop-rStart+1)];\r\n            expanded_quals = new byte[(int)(rStop-rStart+1)];\r\n\r\n            // now let's extract indels:\r\n\r\n            Cigar c = read.getCigar();\r\n            final int nCigarElems = c.numCigarElements();\r\n\r\n            int posOnRead = 0;\r\n            int posOnRef = 0; // the chunk of reference ref[] that we have access to is aligned with the read:\r\n                              // its start on the actual full reference contig is r.getAlignmentStart()\r\n            for ( int i = 0 ; i < nCigarElems ; i++ ) {\r\n\r\n                final CigarElement ce = c.getCigarElement(i);\r\n                IndelVariant.Type type = null;\r\n                String indel_bases = null;\r\n                int eventPosition = posOnRef;\r\n\r\n                switch(ce.getOperator()) {\r\n                case H: break; // hard clipped reads do not have clipped indel_bases in their sequence, so we just ignore the H element...\r\n                case I:\r\n                    type = IndelVariant.Type.I;\r\n                    indel_bases = read.getReadString().substring(posOnRead,posOnRead+ce.getLength());\r\n                    // will increment position on the read below, there's no 'break' statement yet...\r\n                case S:\r\n                    // here we also skip soft-clipped indel_bases on the read; according to SAM format specification,\r\n                    // alignment start position on the reference points to where the actually aligned\r\n                    // (not clipped) indel_bases go, so we do not need to increment reference position here\r\n                    posOnRead += ce.getLength();\r\n                    break;\r\n                case D:\r\n                    type = IndelVariant.Type.D;\r\n                    indel_bases = new String( ref, posOnRef, ce.getLength() );\r\n                    for( int k = 0 ; k < ce.getLength(); k++, posOnRef++ ) mismatch_flags[posOnRef] = expanded_quals[posOnRef] = -1;\r\n\r\n                    break;\r\n                case M:\r\n                    for ( int k = 0; k < ce.getLength(); k++, posOnRef++, posOnRead++ ) {\r\n                        if ( readBases[posOnRead] != ref[posOnRef] )  { // mismatch!\r\n                            mms++;\r\n                            mismatch_flags[posOnRef] = 1;\r\n                        }\r\n                        expanded_quals[posOnRef] = read.getBaseQualities()[posOnRead];\r\n                    }\r\n                    break; // advance along the gapless block in the alignment\r\n                default :\r\n                    throw new IllegalArgumentException(\"Unexpected operator in cigar string: \"+ce.getOperator());\r\n                }\r\n\r\n                if ( type == null ) continue; // element was not an indel, go grab next element...\r\n\r\n                // we got an indel if we are here...\r\n                if ( i == 0 ) logger.debug(\"Indel at the start of the read \"+read.getReadName());\r\n                if ( i == nCigarElems - 1) logger.debug(\"Indel at the end of the read \"+read.getReadName());\r\n\r\n                // note that here we will be assigning indels to the first deleted base or to the first\r\n                // base after insertion, not to the last base before the event!\r\n                l.addObservation((int)(offset+eventPosition), type, indel_bases, this);\r\n            }\r\n        }","commit_id":"9b3ffa5f64cbdd8eb043e5adb2152f442f1567e4","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Collection<HgChange> process(ChangelistBuilder builder, Collection<FilePath> files) {\n    final Set<HgChange> hgChanges = new HashSet<HgChange>();\n    for (Map.Entry<VirtualFile, Collection<FilePath>> entry : HgUtil.groupFilePathsByHgRoots(myProject, files).entrySet()) {\n      VirtualFile repo = entry.getKey();\n\n      final HgRevisionNumber workingRevision = new HgWorkingCopyRevisionsCommand(myProject).identify(repo);\n      final HgRevisionNumber parentRevision = new HgWorkingCopyRevisionsCommand(myProject).firstParent(repo);\n      final Map<HgFile, HgResolveStatusEnum> list = new HgResolveCommand(myProject).getListSynchronously(repo);\n\n      hgChanges.addAll(new HgStatusCommand(myProject).execute(repo, entry.getValue()));\n      sendChanges(builder, hgChanges, list, workingRevision, parentRevision);\n    }\n    return hgChanges;\n  }","id":38624,"modified_method":"private Collection<HgChange> process(ChangelistBuilder builder, Collection<FilePath> files) {\n    final Set<HgChange> hgChanges = new HashSet<HgChange>();\n    for (Map.Entry<VirtualFile, Collection<FilePath>> entry : HgUtil.groupFilePathsByHgRoots(myProject, files).entrySet()) {\n      VirtualFile repo = entry.getKey();\n\n      final HgRevisionNumber workingRevision = new HgWorkingCopyRevisionsCommand(myProject).identify(repo).getFirst();\n      final HgRevisionNumber parentRevision = new HgWorkingCopyRevisionsCommand(myProject).firstParent(repo);\n      final Map<HgFile, HgResolveStatusEnum> list = new HgResolveCommand(myProject).getListSynchronously(repo);\n\n      hgChanges.addAll(new HgStatusCommand(myProject).execute(repo, entry.getValue()));\n      sendChanges(builder, hgChanges, list, workingRevision, parentRevision);\n    }\n    return hgChanges;\n  }","commit_id":"8de6d09113f6791b1ca76fef2cc170cb55bab56d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ItemLatestState getLastRevision(FilePath filePath) {\n    VirtualFile vcsRoot = VcsUtil.getVcsRootFor(project, filePath);\n    if (vcsRoot == null) {\n      return null;\n    }\n\n    HgWorkingCopyRevisionsCommand command = new HgWorkingCopyRevisionsCommand(project);\n    HgRevisionNumber currentRevision = command.identify(vcsRoot);\n    if (currentRevision == null) {\n      return null;\n    }\n\n    boolean fileExists = filePath.getIOFile().exists();\n    if (currentRevision.isWorkingVersion()) {\n      return new ItemLatestState(command.firstParent(vcsRoot), fileExists, true);\n    }\n\n    return new ItemLatestState(currentRevision, fileExists, true);\n  }","id":38625,"modified_method":"public ItemLatestState getLastRevision(FilePath filePath) {\n    VirtualFile vcsRoot = VcsUtil.getVcsRootFor(project, filePath);\n    if (vcsRoot == null) {\n      return null;\n    }\n\n    HgWorkingCopyRevisionsCommand command = new HgWorkingCopyRevisionsCommand(project);\n    HgRevisionNumber currentRevision = command.identify(vcsRoot).getFirst();\n    if (currentRevision == null) {\n      return null;\n    }\n\n    boolean fileExists = filePath.getIOFile().exists();\n    if (currentRevision.isWorkingVersion()) {\n      return new ItemLatestState(command.firstParent(vcsRoot), fileExists, true);\n    }\n\n    return new ItemLatestState(currentRevision, fileExists, true);\n  }","commit_id":"8de6d09113f6791b1ca76fef2cc170cb55bab56d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void disableOtherHeadsChoice() {\n    otherHeadLabel.setVisible(false);\n    otherHeadRadioButton.setVisible(false);\n  }","id":38626,"modified_method":"private void disableOtherHeadsChoice() {\n    UIUtil.invokeLaterIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        otherHeadLabel.setVisible(false);\n        otherHeadRadioButton.setVisible(false);\n      }\n    });\n  }","commit_id":"8de6d09113f6791b1ca76fef2cc170cb55bab56d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void loadHeads(final VirtualFile root) {\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        final List<HgRevisionNumber> heads = new HgHeadsCommand(project, root).execute();\n        if (heads.size() != 2) {\n          disableOtherHeadsChoice();\n          return;\n        }\n\n        otherHeadRadioButton.setVisible(true);\n        otherHeadLabel.setVisible(true);\n\n        HgRevisionNumber currentParent = new HgWorkingCopyRevisionsCommand(project).identify(root);\n        heads.remove(currentParent);\n\n        if (heads.size() == 1) {\n          otherHead = heads.get(0);\n          otherHeadLabel.setText(HgVcsMessages.message(\"hg4idea.integrate.other.head\", otherHead.asString()));\n        } else {\n          //apparently we are not at one of the heads\n          disableOtherHeadsChoice();\n        }\n      }\n    });\n  }","id":38627,"modified_method":"private void loadHeads(final VirtualFile root) {\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      @Override\n      public void run() {\n        final List<HgRevisionNumber> heads = new HgHeadsCommand(project, root).execute();\n        if (heads.size() != 2) {\n          disableOtherHeadsChoice();\n          return;\n        }\n\n        HgRevisionNumber currentParent = new HgWorkingCopyRevisionsCommand(project).identify(root).getFirst();\n        for (Iterator<HgRevisionNumber> it = heads.iterator() ; it.hasNext(); ) {\n          final HgRevisionNumber rev = it.next();\n          if (rev.getRevisionNumber().equals(currentParent.getRevisionNumber())) {\n            it.remove();\n          }\n        }\n\n        if (heads.size() == 1) {\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              otherHeadRadioButton.setVisible(true);\n              otherHeadLabel.setVisible(true);\n              otherHead = heads.get(0);\n              otherHeadLabel.setText(HgVcsMessages.message(\"hg4idea.integrate.other.head\", otherHead.asString()));\n            }\n          });\n        } else {\n          //apparently we are not at one of the heads\n          disableOtherHeadsChoice();\n        }\n      }\n    });\n  }","commit_id":"8de6d09113f6791b1ca76fef2cc170cb55bab56d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the numeric part of the revision, i. e. the revision without trailing '+' if one exists. \n   */\n  private String getRevisionNumber() {\n    if (isWorkingVersion) {\n      return revision.substring(0, revision.length()-1);\n    }\n    return revision;\n  }","id":38628,"modified_method":"/**\n   * Returns the numeric part of the revision, i. e. the revision without trailing '+' if one exists. \n   */\n  public String getRevisionNumber() {\n    if (isWorkingVersion) {\n      return revision.substring(0, revision.length()-1);\n    }\n    return revision;\n  }","commit_id":"8de6d09113f6791b1ca76fef2cc170cb55bab56d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void updateShouldNotMergeIfMultipleHeadsBeforeUpdate() throws Exception {\n    changeFile_A_AndCommitInRemoteRepository();\n    createAndCommitNewFileInLocalRepository();\n\n    //create multiple heads locally\n    HgUpdateCommand updateCommand = new HgUpdateCommand(myProject, projectRepoVirtualFile);\n    HgRevisionNumber parent = new HgParentsCommand(myProject).execute(projectRepoVirtualFile).get(0);\n    HgParentsCommand parentsCommand = new HgParentsCommand(myProject);\n    parentsCommand.setRevision(parent);\n    List<HgRevisionNumber> parents = parentsCommand.execute(projectRepoVirtualFile);\n    updateCommand.setRevision(parents.get(0).getChangeset());\n    updateCommand.execute();\n\n    createFileInCommand(projectRepoVirtualFile.findChild(\"com\"),\"c.txt\", \"updated content\");\n    runHg(projectRepo, \"commit\", \"-m\", \"creating new local head\");\n\n    List<HgRevisionNumber> branchHeads = new HgHeadsCommand(myProject, projectRepoVirtualFile).execute();\n    assertEquals(branchHeads.size(), 2);\n\n    HgRevisionNumber parentBeforeUpdate = new HgWorkingCopyRevisionsCommand(myProject).identify(projectRepoVirtualFile);\n    assertUpdateThroughPluginFails();\n    HgRevisionNumber parentAfterUpdate = new HgWorkingCopyRevisionsCommand(myProject).identify(projectRepoVirtualFile);\n    List<HgRevisionNumber> branchHeadsAfterUpdate = new HgHeadsCommand(myProject, projectRepoVirtualFile).execute();\n\n    assertEquals(branchHeadsAfterUpdate.size(), 3);\n    assertEquals(parentBeforeUpdate, parentAfterUpdate);\n  }","id":38629,"modified_method":"@Test\n  public void updateShouldNotMergeIfMultipleHeadsBeforeUpdate() throws Exception {\n    changeFile_A_AndCommitInRemoteRepository();\n    createAndCommitNewFileInLocalRepository();\n\n    //create multiple heads locally\n    HgUpdateCommand updateCommand = new HgUpdateCommand(myProject, projectRepoVirtualFile);\n    HgRevisionNumber parent = new HgParentsCommand(myProject).execute(projectRepoVirtualFile).get(0);\n    HgParentsCommand parentsCommand = new HgParentsCommand(myProject);\n    parentsCommand.setRevision(parent);\n    List<HgRevisionNumber> parents = parentsCommand.execute(projectRepoVirtualFile);\n    updateCommand.setRevision(parents.get(0).getChangeset());\n    updateCommand.execute();\n\n    createFileInCommand(projectRepoVirtualFile.findChild(\"com\"),\"c.txt\", \"updated content\");\n    runHg(projectRepo, \"commit\", \"-m\", \"creating new local head\");\n\n    List<HgRevisionNumber> branchHeads = new HgHeadsCommand(myProject, projectRepoVirtualFile).execute();\n    assertEquals(branchHeads.size(), 2);\n\n    HgRevisionNumber parentBeforeUpdate = new HgWorkingCopyRevisionsCommand(myProject).identify(projectRepoVirtualFile).getFirst();\n    assertUpdateThroughPluginFails();\n    HgRevisionNumber parentAfterUpdate = new HgWorkingCopyRevisionsCommand(myProject).identify(projectRepoVirtualFile).getFirst();\n    List<HgRevisionNumber> branchHeadsAfterUpdate = new HgHeadsCommand(myProject, projectRepoVirtualFile).execute();\n\n    assertEquals(branchHeadsAfterUpdate.size(), 3);\n    assertEquals(parentBeforeUpdate, parentAfterUpdate);\n  }","commit_id":"8de6d09113f6791b1ca76fef2cc170cb55bab56d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public HgRevisionNumber identify(@NotNull VirtualFile repo) {\n    HgCommandExecutor commandExecutor = new HgCommandExecutor(myProject);\n    commandExecutor.setSilent(true);\n    HgCommandResult result = commandExecutor.executeInCurrentThread(repo, \"identify\", Arrays.asList(\"--num\", \"--id\"));\n    if (result == null) {\n      return HgRevisionNumber.NULL_REVISION_NUMBER;\n    }\n    final List<String> lines = result.getOutputLines();\n    if (lines != null && !lines.isEmpty()) {\n      String[] parts = StringUtils.split(lines.get(0), ' ');\n      if (parts.length >= 2) {\n        return HgRevisionNumber.getInstance(parts[1], parts[0]);\n      }\n    }\n    return HgRevisionNumber.NULL_REVISION_NUMBER;\n  }","id":38630,"modified_method":"/**\n   * Returns the result of 'hg id' execution, i.e. current state of the repository.\n   * @return one or two revision numbers. Two revisions is the case of unresolved merge. In other cases there are only one revision.\n   */\n  @NotNull\n  public Pair<HgRevisionNumber, HgRevisionNumber> identify(@NotNull VirtualFile repo) {\n    HgCommandExecutor commandExecutor = new HgCommandExecutor(myProject);\n    commandExecutor.setSilent(true);\n    HgCommandResult result = commandExecutor.executeInCurrentThread(repo, \"identify\", Arrays.asList(\"--num\", \"--id\"));\n    if (result == null) {\n      return Pair.create(HgRevisionNumber.NULL_REVISION_NUMBER, null);\n    }\n\n    final List<String> lines = result.getOutputLines();\n    if (lines != null && !lines.isEmpty()) {\n      String[] parts = StringUtils.split(lines.get(0), ' ');\n      String changesets = parts[0];\n      String revisions = parts[1];\n      if (parts.length >= 2) {\n        if (changesets.indexOf('+') != changesets.lastIndexOf('+')) {\n          // in the case of unresolved merge we have 2 revisions at once, both current, so with \"+\"\n          // 9f2e6c02913c+b311eb4eb004+ 186+183+\n          String[] chsets = StringUtils.split(changesets, \"+\");\n          String[] revs = StringUtils.split(revisions, \"+\");\n          return Pair.create(HgRevisionNumber.getInstance(revs[0] + \"+\", chsets[0] + \"+\"), HgRevisionNumber.getInstance(revs[1] + \"+\", chsets[1] + \"+\"));\n        } else {\n          return Pair.create(HgRevisionNumber.getInstance(revisions, changesets), null);\n        }\n      }\n    }\n    return Pair.create(HgRevisionNumber.NULL_REVISION_NUMBER, null);\n  }","commit_id":"8de6d09113f6791b1ca76fef2cc170cb55bab56d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isImplemented(JetNamedDeclaration declaration) {\n        if (declaration.hasModifier(JetTokens.ABSTRACT_KEYWORD)) return true;\n\n        PsiElement parent = declaration.getParent();\n        if (parent instanceof JetClass) {\n            return ((JetClass) parent).isTrait();\n        }\n\n        return false;\n    }","id":38631,"modified_method":"public static boolean isImplemented(JetNamedDeclaration declaration) {\n        if (declaration.hasModifier(JetTokens.ABSTRACT_KEYWORD)) return true;\n\n        PsiElement parent = declaration.getParent();\n        parent = (parent instanceof JetClassBody) ? parent.getParent() : parent;\n\n        if (parent instanceof JetClass) {\n            return ((JetClass) parent).isTrait() &&\n                   (!(declaration instanceof JetDeclarationWithBody) || !((JetDeclarationWithBody)declaration).hasBody()) &&\n                   (!(declaration instanceof JetWithExpressionInitializer) || !((JetWithExpressionInitializer)declaration).hasInitializer());\n        }\n\n        return false;\n    }","commit_id":"f0e7435254d6c3867abdacb6c6626609f5f4998d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static FqName kotlinFqNameToJavaFqName(@NotNull FqNameUnsafe kotlinFqName) {\n        return kotlinFqNameToJavaFqName(kotlinFqName, false);\n    }","id":38632,"modified_method":"@NotNull\n    public static FqName kotlinFqNameToJavaFqName(@NotNull FqNameUnsafe kotlinFqName) {\n        List<Name> segments = kotlinFqName.pathSegments();\n        List<String> correctedSegments = new ArrayList<String>(segments.size());\n        for (Name segment : segments) {\n            correctedSegments.add(isClassObjectName(segment) ? JvmAbi.CLASS_OBJECT_CLASS_NAME : segment.getIdentifier());\n        }\n        return FqName.fromSegments(correctedSegments);\n    }","commit_id":"4c49c39f8d61cbda4b8dbfd0aa1a8907e22d655d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static FqName getContainerFqName(@NotNull DeclarationDescriptor referencedDescriptor) {\n        ClassOrPackageFragmentDescriptor\n                containerDescriptor = DescriptorUtils.getParentOfType(referencedDescriptor, ClassOrPackageFragmentDescriptor.class, false);\n        if (containerDescriptor instanceof PackageFragmentDescriptor) {\n            return PackageClassUtils.getPackageClassFqName(getFqName(containerDescriptor).toSafe());\n        }\n        if (containerDescriptor instanceof ClassDescriptor) {\n            return DeserializedResolverUtils.kotlinFqNameToJavaFqName(getFqName(containerDescriptor), isTrait(containerDescriptor));\n        }\n        return null;\n    }","id":38633,"modified_method":"@Nullable\n    public static FqName getContainerFqName(@NotNull DeclarationDescriptor referencedDescriptor) {\n        ClassOrPackageFragmentDescriptor\n                containerDescriptor = DescriptorUtils.getParentOfType(referencedDescriptor, ClassOrPackageFragmentDescriptor.class, false);\n        if (containerDescriptor instanceof PackageFragmentDescriptor) {\n            return PackageClassUtils.getPackageClassFqName(getFqName(containerDescriptor).toSafe());\n        }\n        if (containerDescriptor instanceof ClassDescriptor) {\n            FqName fqName = DeserializedResolverUtils.kotlinFqNameToJavaFqName(getFqName(containerDescriptor));\n            if (isTrait(containerDescriptor)) {\n                return fqName.parent().child(Name.identifier(fqName.shortName() + JvmAbi.TRAIT_IMPL_SUFFIX));\n            }\n            return fqName;\n        }\n        return null;\n    }","commit_id":"4c49c39f8d61cbda4b8dbfd0aa1a8907e22d655d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  public boolean hasModifierProperty(@NotNull String name) {\n    return PsiModifier.ABSTRACT.equals(name) && GrTraitUtil.isTrait(getContainingClass()) || super.hasModifierProperty(name);\n  }","id":38634,"modified_method":"@Override\n  public boolean hasModifierProperty(@NotNull String name) {\n    if (GrTraitUtil.isTrait(getContainingClass())) {\n      if (PsiModifier.ABSTRACT.equals(name)) return true;\n      if (PsiModifier.FINAL.equals(name)) return false;\n    }\n    return super.hasModifierProperty(name);\n  }","commit_id":"4e1d9e1ff39f517b76b1ff4ac56bdfcf9272d509","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void awaitConnection() {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Awaiting Connection event from Zookeeper cluster {}\", configuration.getConnectString());\n        }\n        try {\n            connectionLatch.await();\n        } catch (InterruptedException e) {\n            ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","id":38635,"modified_method":"public void awaitConnection() {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Awaiting Connection event from Zookeeper cluster {}\", configuration.getConnectString());\n        }\n        try {\n            connectionLatch.await();\n        } catch (InterruptedException e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"public ZooKeeper getZooKeeper() {\n        if (zookeeper != null) {\n            return zookeeper;\n        }\n        if (configuration.getConnectString() == null) {\n            throw new RuntimeCamelException(\"Cannot create ZooKeeper connection as connection string is null. Have servers been configured?\");\n        }\n        try {\n            if (configuration.getSessionId() > 0 && configuration.getSessionPassword() != null) {\n                zookeeper = new ZooKeeper(configuration.getConnectString(), configuration.getTimeout(), this, configuration.getSessionId(), configuration.getSessionPassword());\n            } else {\n                zookeeper = new ZooKeeper(configuration.getConnectString(), configuration.getTimeout(), this);\n            }\n        } catch (Exception e) {\n            ObjectHelper.wrapRuntimeCamelException(e);\n        }\n        awaitConnection();\n        return zookeeper;\n    }","id":38636,"modified_method":"public ZooKeeper getZooKeeper() {\n        if (zookeeper != null) {\n            return zookeeper;\n        }\n        if (configuration.getConnectString() == null) {\n            throw new RuntimeCamelException(\"Cannot create ZooKeeper connection as connection string is null. Have servers been configured?\");\n        }\n        try {\n            zookeeper = new ZooKeeper(configuration.getConnectString(), configuration.getTimeout(), this);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n        awaitConnection();\n        return zookeeper;\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"public boolean listChildren() {\n        return listChildren;\n    }","id":38637,"modified_method":"public boolean isListChildren() {\n        return listChildren;\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"private void initializeChildListingConsumer(String node) {\n        if (!shuttingDown) {\n            if (log.isDebugEnabled()) {\n                log.debug(String.format(\"Initailizing child listing of node '%s'\", node));\n            }\n            addBasicChildListingSequence(node);\n        }\n    }","id":38638,"modified_method":"private void initializeChildListingConsumer(String node) {\n        if (!shuttingDown) {\n            if (log.isDebugEnabled()) {\n                log.debug(String.format(\"Initializing child listing of node '%s'\", node));\n            }\n            addBasicChildListingSequence(node);\n        }\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"private void initializeConsumer() {\n        String node = configuration.getPath();\n        if (configuration.listChildren()) {\n            initializeChildListingConsumer(node);\n        } else {\n            initializeDataConsumer(node);\n        }\n    }","id":38639,"modified_method":"private void initializeConsumer() {\n        String node = configuration.getPath();\n        if (configuration.isListChildren()) {\n            initializeChildListingConsumer(node);\n        } else {\n            initializeDataConsumer(node);\n        }\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"public void run() {\n            while (isRunAllowed()) {\n\n                try {\n                    current = operations.take();\n                    if (log.isTraceEnabled()) {\n                        log.trace(String.format(\"Processing '%s' operation\", current.getClass().getSimpleName()));\n                    }\n                } catch (InterruptedException e) {\n                    continue;\n                }\n                String node = current.getNode();\n                try {\n                    OperationResult result = current.get();\n                    if (ZooKeeperUtils.hasWatchedEvent(current)) {\n                        watchedEvent = ZooKeeperUtils.getWatchedEvent(current);\n                    }\n                    if (result != null && current.shouldProduceExchange()) {\n                        getProcessor().process(createExchange(node, result, watchedEvent));\n                        watchedEvent = null;\n                    }\n                } catch (Exception e) {\n                    handleException(e);\n                    backoffAndThenRestart();\n                } finally {\n                    if (configuration.shouldRepeat()) {\n                        try {\n                            operations.offer(current.createCopy());\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                            backoffAndThenRestart();\n                        }\n                    }\n                }\n            }\n        }","id":38640,"modified_method":"public void run() {\n            while (isRunAllowed()) {\n\n                try {\n                    current = operations.take();\n                    if (log.isTraceEnabled()) {\n                        log.trace(String.format(\"Processing '%s' operation\", current.getClass().getSimpleName()));\n                    }\n                } catch (InterruptedException e) {\n                    continue;\n                }\n                String node = current.getNode();\n                try {\n                    OperationResult result = current.get();\n                    if (ZooKeeperUtils.hasWatchedEvent(current)) {\n                        watchedEvent = ZooKeeperUtils.getWatchedEvent(current);\n                    }\n                    if (result != null && current.shouldProduceExchange()) {\n                        getProcessor().process(createExchange(node, result, watchedEvent));\n                        watchedEvent = null;\n                    }\n                } catch (Exception e) {\n                    handleException(e);\n                    backoffAndThenRestart();\n                } finally {\n                    if (configuration.shouldRepeat()) {\n                        try {\n                            operations.offer(current.createCopy());\n                        } catch (Exception e) {\n                            backoffAndThenRestart();\n                        }\n                    }\n                }\n            }\n        }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"private void initializeDataConsumer(String node) {\n        if (!shuttingDown) {\n            if (log.isDebugEnabled()) {\n                log.debug(String.format(\"Initailizing consumption of data on node '%s'\", node));\n            }\n            addBasicDataConsumeSequence(node);\n        }\n    }","id":38641,"modified_method":"private void initializeDataConsumer(String node) {\n        if (!shuttingDown) {\n            if (log.isDebugEnabled()) {\n                log.debug(String.format(\"Initializing consumption of data on node '%s'\", node));\n            }\n            addBasicDataConsumeSequence(node);\n        }\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"@ManagedAttribute\n    public boolean getListChildren() {\n        return getConfiguration().listChildren();\n    }","id":38642,"modified_method":"@ManagedAttribute\n    public boolean isListChildren() {\n        return getConfiguration().isListChildren();\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n\n        ZooKeeper connection = zkm.getConnection();\n        ProductionContext context = new ProductionContext(connection, exchange);\n\n        String operation = exchange.getIn().getHeader(ZooKeeperMessage.ZOOKEEPER_OPERATION, String.class);\n        boolean isDelete = ZK_OPERATION_DELETE.equals(operation);\n        \n        if (ExchangeHelper.isOutCapable(exchange)) {\n            if (isDelete) {\n                if (log.isDebugEnabled()) {\n                    log.debug(format(\"Deleting znode '%s', waiting for confirmation\", context.node));\n                }\n\n                OperationResult result = synchronouslyDelete(context);\n                if (configuration.listChildren()) {\n                    result = listChildren(context);\n                }\n                updateExchangeWithResult(context, result);\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(format(\"Storing data to znode '%s', waiting for confirmation\", context.node));\n                }\n\n                OperationResult result = synchronouslySetData(context);\n                if (configuration.listChildren()) {\n                    result = listChildren(context);\n                }\n                updateExchangeWithResult(context, result);\n            }\n        } else {\n            if (isDelete) {\n                asynchronouslyDeleteNode(connection, context);\n            } else {\n                asynchronouslySetDataOnNode(connection, context);\n            }\n        }\n    }","id":38643,"modified_method":"public void process(Exchange exchange) throws Exception {\n\n        ZooKeeper connection = zkm.getConnection();\n        ProductionContext context = new ProductionContext(connection, exchange);\n\n        String operation = exchange.getIn().getHeader(ZooKeeperMessage.ZOOKEEPER_OPERATION, String.class);\n        boolean isDelete = ZK_OPERATION_DELETE.equals(operation);\n        \n        if (ExchangeHelper.isOutCapable(exchange)) {\n            if (isDelete) {\n                if (log.isDebugEnabled()) {\n                    log.debug(format(\"Deleting znode '%s', waiting for confirmation\", context.node));\n                }\n\n                OperationResult result = synchronouslyDelete(context);\n                if (configuration.isListChildren()) {\n                    result = listChildren(context);\n                }\n                updateExchangeWithResult(context, result);\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(format(\"Storing data to znode '%s', waiting for confirmation\", context.node));\n                }\n\n                OperationResult result = synchronouslySetData(context);\n                if (configuration.isListChildren()) {\n                    result = listChildren(context);\n                }\n                updateExchangeWithResult(context, result);\n            }\n        } else {\n            if (isDelete) {\n                asynchronouslyDeleteNode(connection, context);\n            } else {\n                asynchronouslySetDataOnNode(connection, context);\n            }\n        }\n    }","commit_id":"90d0f62a83e173af2d4a621a7f77ffbd90d8d448","url":"https://github.com/apache/camel"},{"original_method":"@PostConstruct\n    @Override\n    public void start() {\n        try {\n            super.start();\n        } catch (Exception e) {\n            ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","id":38644,"modified_method":"@PostConstruct\n    @Override\n    public void start() {\n        try {\n            super.start();\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","commit_id":"f4bbb916b33ae7a471e48d298f2f86b32b54b612","url":"https://github.com/apache/camel"},{"original_method":"@PreDestroy\n    @Override\n    public void stop() {\n        try {\n            super.stop();\n        } catch (Exception e) {\n            ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","id":38645,"modified_method":"@PreDestroy\n    @Override\n    public void stop() {\n        try {\n            super.stop();\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","commit_id":"f4bbb916b33ae7a471e48d298f2f86b32b54b612","url":"https://github.com/apache/camel"},{"original_method":"public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    final HighlightSeverity that = (HighlightSeverity)o;\n\n    if (!myName.equals(that.myName)) return false;\n\n    return true;\n  }","id":38646,"modified_method":"public boolean equals(final Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    final HighlightSeverity that = (HighlightSeverity)o;\n\n    return myName.equals(that.myName);\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fillList(final HighlightSeverity severity) {\n    DefaultListModel model = new DefaultListModel();\n    model.removeAllElements();\n    final List<SeverityRegistrar.SeverityBasedTextAttributes> infoTypes = new ArrayList<SeverityRegistrar.SeverityBasedTextAttributes>();\n    infoTypes.addAll(mySeverityRegistrar.getRegisteredHighlightingInfoTypes());\n    Collections.sort(infoTypes, new Comparator<SeverityRegistrar.SeverityBasedTextAttributes>() {\n      public int compare(SeverityBasedTextAttributes attributes1,\n                         SeverityBasedTextAttributes attributes2) {\n        return -mySeverityRegistrar.compare(attributes1.getSeverity(), attributes2.getSeverity());\n      }\n    });\n    SeverityBasedTextAttributes preselection = null;\n    for (SeverityBasedTextAttributes type : infoTypes) {\n      model.addElement(type);\n      if (type.getSeverity().equals(severity)) {\n        preselection = type;\n      }\n    }\n    myOptionsList.setModel(model);\n    myOptionsList.setSelectedValue(preselection, true);\n  }","id":38647,"modified_method":"private void fillList(final HighlightSeverity severity) {\n    DefaultListModel model = new DefaultListModel();\n    model.removeAllElements();\n    final List<SeverityRegistrar.SeverityBasedTextAttributes> infoTypes = new ArrayList<SeverityRegistrar.SeverityBasedTextAttributes>();\n    infoTypes.addAll(mySeverityRegistrar.getRegisteredHighlightingInfoTypes());\n    Collections.sort(infoTypes, new Comparator<SeverityRegistrar.SeverityBasedTextAttributes>() {\n      @Override\n      public int compare(SeverityBasedTextAttributes attributes1,\n                         SeverityBasedTextAttributes attributes2) {\n        return -mySeverityRegistrar.compare(attributes1.getSeverity(), attributes2.getSeverity());\n      }\n    });\n    SeverityBasedTextAttributes preselection = null;\n    for (SeverityBasedTextAttributes type : infoTypes) {\n      model.addElement(type);\n      if (type.getSeverity().equals(severity)) {\n        preselection = type;\n      }\n    }\n    myOptionsList.setModel(model);\n    myOptionsList.setSelectedValue(preselection, true);\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction() {\n    apply((SeverityBasedTextAttributes)myOptionsList.getSelectedValue());\n    final Collection<SeverityRegistrar.SeverityBasedTextAttributes> infoTypes =\n      new HashSet<SeverityRegistrar.SeverityBasedTextAttributes>(mySeverityRegistrar.getRegisteredHighlightingInfoTypes());\n    final ListModel listModel = myOptionsList.getModel();\n    final List<String> order = new ArrayList<String>();\n    for (int i = listModel.getSize() - 1; i >= 0; i--) {\n      final SeverityBasedTextAttributes info =\n        (SeverityBasedTextAttributes)listModel.getElementAt(i);\n      order.add(info.getSeverity().myName);\n      if (!mySeverityRegistrar.isDefaultSeverity(info.getSeverity())) {\n        infoTypes.remove(info);\n        final Color stripeColor = info.getAttributes().getErrorStripeColor();\n        mySeverityRegistrar.registerSeverity(info, stripeColor != null ? stripeColor : LightColors.YELLOW);\n      }\n    }\n    for (SeverityBasedTextAttributes info : infoTypes) {\n      mySeverityRegistrar.unregisterSeverity(info.getSeverity());\n    }\n    mySeverityRegistrar.setOrder(order);\n    super.doOKAction();\n  }","id":38648,"modified_method":"@Override\n  protected void doOKAction() {\n    apply((SeverityBasedTextAttributes)myOptionsList.getSelectedValue());\n    final Collection<SeverityRegistrar.SeverityBasedTextAttributes> infoTypes =\n      new HashSet<SeverityRegistrar.SeverityBasedTextAttributes>(mySeverityRegistrar.getRegisteredHighlightingInfoTypes());\n    final ListModel listModel = myOptionsList.getModel();\n    final List<HighlightSeverity> order = new ArrayList<HighlightSeverity>();\n    for (int i = listModel.getSize() - 1; i >= 0; i--) {\n      final SeverityBasedTextAttributes info =\n        (SeverityBasedTextAttributes)listModel.getElementAt(i);\n      order.add(info.getSeverity());\n      if (!mySeverityRegistrar.isDefaultSeverity(info.getSeverity())) {\n        infoTypes.remove(info);\n        final Color stripeColor = info.getAttributes().getErrorStripeColor();\n        mySeverityRegistrar.registerSeverity(info, stripeColor != null ? stripeColor : LightColors.YELLOW);\n      }\n    }\n    for (SeverityBasedTextAttributes info : infoTypes) {\n      mySeverityRegistrar.unregisterSeverity(info.getSeverity());\n    }\n    mySeverityRegistrar.setOrder(order);\n    super.doOKAction();\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SeverityEditorDialog(final JComponent parent, final HighlightSeverity severity, final SeverityRegistrar severityRegistrar) {\n    super(parent, true);\n    mySeverityRegistrar = severityRegistrar;\n    myOptionsList.setCellRenderer(new DefaultListCellRenderer() {\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        final Component rendererComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        if (value instanceof SeverityBasedTextAttributes) {\n          setText(((SeverityBasedTextAttributes)value).getSeverity().toString());\n        }\n        return rendererComponent;\n      }\n    });\n    myOptionsList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        if (myCurrentSelection != null) {\n          apply(myCurrentSelection);\n        }\n        myCurrentSelection = (SeverityBasedTextAttributes)myOptionsList.getSelectedValue();\n        if (myCurrentSelection != null) {\n          reset(myCurrentSelection);\n          myCard.show(myRightPanel, mySeverityRegistrar.isDefaultSeverity(myCurrentSelection.getSeverity()) ? DEFAULT : EDITABLE);\n        }\n      }\n    });\n    myOptionsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    JPanel leftPanel = ToolbarDecorator.createDecorator(myOptionsList)\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final String name = Messages.showInputDialog(myPanel, InspectionsBundle.message(\"highlight.severity.create.dialog.name.label\"),\n                                                       InspectionsBundle.message(\"highlight.severity.create.dialog.title\"),\n                                                       Messages.getQuestionIcon(),\n                                                       \"\", new InputValidator() {\n            public boolean checkInput(final String inputString) {\n              final ListModel listModel = myOptionsList.getModel();\n              for (int i = 0; i < listModel.getSize(); i++) {\n                final String severityName = ((SeverityBasedTextAttributes)listModel.getElementAt(i)).getSeverity().myName;\n                if (Comparing.strEqual(severityName, inputString)) return false;\n              }\n              return true;\n            }\n\n            public boolean canClose(final String inputString) {\n              return checkInput(inputString);\n            }\n          });\n          if (name == null) return;\n          final TextAttributes textAttributes = CodeInsightColors.WARNINGS_ATTRIBUTES.getDefaultAttributes();\n          HighlightInfoType.HighlightInfoTypeImpl info = new HighlightInfoType.HighlightInfoTypeImpl(new HighlightSeverity(name, 50),\n                                                                                                     TextAttributesKey\n                                                                                                       .createTextAttributesKey(name));\n\n          SeverityBasedTextAttributes newSeverityBasedTextAttributes = new SeverityBasedTextAttributes(textAttributes.clone(), info);\n          ((DefaultListModel)myOptionsList.getModel()).addElement(newSeverityBasedTextAttributes);\n\n          myOptionsList.clearSelection();\n          ListScrollingUtil.selectItem(myOptionsList, newSeverityBasedTextAttributes);\n        }\n      }).setUpAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          apply(myCurrentSelection);\n          ListUtil.moveSelectedItemsUp(myOptionsList);\n        }\n      }).setDownAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          apply(myCurrentSelection);\n          ListUtil.moveSelectedItemsDown(myOptionsList);\n        }\n      }).createPanel();\n    ToolbarDecorator.findRemoveButton(leftPanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        return !mySeverityRegistrar\n          .isDefaultSeverity(((SeverityBasedTextAttributes)myOptionsList.getSelectedValue()).getSeverity());\n      }\n    });\n    ToolbarDecorator.findUpButton(leftPanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        boolean canMove = ListUtil.canMoveSelectedItemsUp(myOptionsList);\n        if (canMove) {\n          SeverityBasedTextAttributes pair =\n            (SeverityBasedTextAttributes)myOptionsList.getSelectedValue();\n          if (pair != null && mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n            final int newPosition = myOptionsList.getSelectedIndex() - 1;\n            pair = (SeverityBasedTextAttributes)myOptionsList.getModel().getElementAt(newPosition);\n            if (mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n              canMove = false;\n            }\n          }\n        }\n\n        return canMove;\n      }\n    });\n    ToolbarDecorator.findDownButton(leftPanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        boolean canMove = ListUtil.canMoveSelectedItemsDown(myOptionsList);\n        if (canMove) {\n          SeverityBasedTextAttributes pair =\n            (SeverityBasedTextAttributes)myOptionsList.getSelectedValue();\n          if (pair != null && mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n            final int newPosition = myOptionsList.getSelectedIndex() + 1;\n            pair = (SeverityBasedTextAttributes)myOptionsList.getModel().getElementAt(newPosition);\n            if (mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n              canMove = false;\n            }\n          }\n        }\n\n        return canMove;\n      }\n    });\n\n    myPanel = new JPanel(new BorderLayout());\n    myPanel.add(leftPanel, BorderLayout.CENTER);\n    myCard = new CardLayout();\n    myRightPanel = new JPanel(myCard);\n    final JPanel disabled = new JPanel(new GridBagLayout());\n    final JButton button = new JButton(InspectionsBundle.message(\"severities.default.settings.message\"));\n    button.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        editColorsAndFonts();\n      }\n    });\n    disabled.add(button,\n                 new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0,\n                                        0));\n    myRightPanel.add(DEFAULT, disabled);\n    myRightPanel.add(EDITABLE, myOptionsPanel);\n    myCard.show(myRightPanel, EDITABLE);\n    myPanel.add(myRightPanel, BorderLayout.EAST);\n    fillList(severity);\n    init();\n    setTitle(InspectionsBundle.message(\"severities.editor.dialog.title\"));\n    reset((SeverityBasedTextAttributes)myOptionsList.getSelectedValue());\n  }","id":38649,"modified_method":"public SeverityEditorDialog(final JComponent parent, final HighlightSeverity severity, final SeverityRegistrar severityRegistrar) {\n    super(parent, true);\n    mySeverityRegistrar = severityRegistrar;\n    myOptionsList.setCellRenderer(new DefaultListCellRenderer() {\n      @Override\n      public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n        final Component rendererComponent = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        if (value instanceof SeverityBasedTextAttributes) {\n          setText(((SeverityBasedTextAttributes)value).getSeverity().toString());\n        }\n        return rendererComponent;\n      }\n    });\n    myOptionsList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        if (myCurrentSelection != null) {\n          apply(myCurrentSelection);\n        }\n        myCurrentSelection = (SeverityBasedTextAttributes)myOptionsList.getSelectedValue();\n        if (myCurrentSelection != null) {\n          reset(myCurrentSelection);\n          myCard.show(myRightPanel, mySeverityRegistrar.isDefaultSeverity(myCurrentSelection.getSeverity()) ? DEFAULT : EDITABLE);\n        }\n      }\n    });\n    myOptionsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    JPanel leftPanel = ToolbarDecorator.createDecorator(myOptionsList)\n      .setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final String name = Messages.showInputDialog(myPanel, InspectionsBundle.message(\"highlight.severity.create.dialog.name.label\"),\n                                                       InspectionsBundle.message(\"highlight.severity.create.dialog.title\"),\n                                                       Messages.getQuestionIcon(),\n                                                       \"\", new InputValidator() {\n            @Override\n            public boolean checkInput(final String inputString) {\n              final ListModel listModel = myOptionsList.getModel();\n              for (int i = 0; i < listModel.getSize(); i++) {\n                final String severityName = ((SeverityBasedTextAttributes)listModel.getElementAt(i)).getSeverity().myName;\n                if (Comparing.strEqual(severityName, inputString)) return false;\n              }\n              return true;\n            }\n\n            @Override\n            public boolean canClose(final String inputString) {\n              return checkInput(inputString);\n            }\n          });\n          if (name == null) return;\n          final TextAttributes textAttributes = CodeInsightColors.WARNINGS_ATTRIBUTES.getDefaultAttributes();\n          HighlightInfoType.HighlightInfoTypeImpl info = new HighlightInfoType.HighlightInfoTypeImpl(new HighlightSeverity(name, 50),\n                                                                                                     TextAttributesKey\n                                                                                                       .createTextAttributesKey(name));\n\n          SeverityBasedTextAttributes newSeverityBasedTextAttributes = new SeverityBasedTextAttributes(textAttributes.clone(), info);\n          ((DefaultListModel)myOptionsList.getModel()).addElement(newSeverityBasedTextAttributes);\n\n          myOptionsList.clearSelection();\n          ListScrollingUtil.selectItem(myOptionsList, newSeverityBasedTextAttributes);\n        }\n      }).setUpAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          apply(myCurrentSelection);\n          ListUtil.moveSelectedItemsUp(myOptionsList);\n        }\n      }).setDownAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          apply(myCurrentSelection);\n          ListUtil.moveSelectedItemsDown(myOptionsList);\n        }\n      }).createPanel();\n    ToolbarDecorator.findRemoveButton(leftPanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        return !mySeverityRegistrar\n          .isDefaultSeverity(((SeverityBasedTextAttributes)myOptionsList.getSelectedValue()).getSeverity());\n      }\n    });\n    ToolbarDecorator.findUpButton(leftPanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        boolean canMove = ListUtil.canMoveSelectedItemsUp(myOptionsList);\n        if (canMove) {\n          SeverityBasedTextAttributes pair =\n            (SeverityBasedTextAttributes)myOptionsList.getSelectedValue();\n          if (pair != null && mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n            final int newPosition = myOptionsList.getSelectedIndex() - 1;\n            pair = (SeverityBasedTextAttributes)myOptionsList.getModel().getElementAt(newPosition);\n            if (mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n              canMove = false;\n            }\n          }\n        }\n\n        return canMove;\n      }\n    });\n    ToolbarDecorator.findDownButton(leftPanel).addCustomUpdater(new AnActionButtonUpdater() {\n      @Override\n      public boolean isEnabled(AnActionEvent e) {\n        boolean canMove = ListUtil.canMoveSelectedItemsDown(myOptionsList);\n        if (canMove) {\n          SeverityBasedTextAttributes pair =\n            (SeverityBasedTextAttributes)myOptionsList.getSelectedValue();\n          if (pair != null && mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n            final int newPosition = myOptionsList.getSelectedIndex() + 1;\n            pair = (SeverityBasedTextAttributes)myOptionsList.getModel().getElementAt(newPosition);\n            if (mySeverityRegistrar.isDefaultSeverity(pair.getSeverity())) {\n              canMove = false;\n            }\n          }\n        }\n\n        return canMove;\n      }\n    });\n\n    myPanel = new JPanel(new BorderLayout());\n    myPanel.add(leftPanel, BorderLayout.CENTER);\n    myCard = new CardLayout();\n    myRightPanel = new JPanel(myCard);\n    final JPanel disabled = new JPanel(new GridBagLayout());\n    final JButton button = new JButton(InspectionsBundle.message(\"severities.default.settings.message\"));\n    button.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) {\n        editColorsAndFonts();\n      }\n    });\n    disabled.add(button,\n                 new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0,\n                                        0));\n    myRightPanel.add(DEFAULT, disabled);\n    myRightPanel.add(EDITABLE, myOptionsPanel);\n    myCard.show(myRightPanel, EDITABLE);\n    myPanel.add(myRightPanel, BorderLayout.EAST);\n    fillList(severity);\n    init();\n    setTitle(InspectionsBundle.message(\"severities.editor.dialog.title\"));\n    reset((SeverityBasedTextAttributes)myOptionsList.getSelectedValue());\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void editColorsAndFonts() {\n    final String toConfigure = getSelectedType().getSeverity(null).myName;\n    doOKAction();\n    myOptionsList.clearSelection();\n    final DataContext dataContext = DataManager.getInstance().getDataContext(myPanel);\n    final OptionsEditor optionsEditor = OptionsEditor.KEY.getData(dataContext);\n    if (optionsEditor != null) {\n      final ColorAndFontOptions colorAndFontOptions = optionsEditor.findConfigurable(ColorAndFontOptions.class);\n      assert colorAndFontOptions != null;\n      final SearchableConfigurable javaPage = colorAndFontOptions.findSubConfigurable(InspectionColorSettingsPage.class);\n      LOG.assertTrue(javaPage != null);\n      optionsEditor.select(javaPage).doWhenDone(new Runnable() {\n        public void run() {\n          final Runnable runnable = javaPage.enableSearch(toConfigure);\n          if (runnable != null) {\n            SwingUtilities.invokeLater(runnable);\n          }\n        }\n      });\n    }\n    else {\n      ColorAndFontOptions colorAndFontOptions = new ColorAndFontOptions();\n      final Configurable[] configurables = colorAndFontOptions.buildConfigurables();\n      try {\n        final SearchableConfigurable javaPage = colorAndFontOptions.findSubConfigurable(InspectionColorSettingsPage.class);\n        LOG.assertTrue(javaPage != null);\n        ShowSettingsUtil.getInstance().editConfigurable(PlatformDataKeys.PROJECT.getData(dataContext), javaPage);\n      }\n      finally {\n        for (Configurable configurable : configurables) {\n          configurable.disposeUIResources();\n        }\n        colorAndFontOptions.disposeUIResources();\n      }\n    }\n  }","id":38650,"modified_method":"private void editColorsAndFonts() {\n    final String toConfigure = getSelectedType().getSeverity(null).myName;\n    doOKAction();\n    myOptionsList.clearSelection();\n    final DataContext dataContext = DataManager.getInstance().getDataContext(myPanel);\n    final OptionsEditor optionsEditor = OptionsEditor.KEY.getData(dataContext);\n    if (optionsEditor != null) {\n      final ColorAndFontOptions colorAndFontOptions = optionsEditor.findConfigurable(ColorAndFontOptions.class);\n      assert colorAndFontOptions != null;\n      final SearchableConfigurable javaPage = colorAndFontOptions.findSubConfigurable(InspectionColorSettingsPage.class);\n      LOG.assertTrue(javaPage != null);\n      optionsEditor.select(javaPage).doWhenDone(new Runnable() {\n        @Override\n        public void run() {\n          final Runnable runnable = javaPage.enableSearch(toConfigure);\n          if (runnable != null) {\n            SwingUtilities.invokeLater(runnable);\n          }\n        }\n      });\n    }\n    else {\n      ColorAndFontOptions colorAndFontOptions = new ColorAndFontOptions();\n      final Configurable[] configurables = colorAndFontOptions.buildConfigurables();\n      try {\n        final SearchableConfigurable javaPage = colorAndFontOptions.findSubConfigurable(InspectionColorSettingsPage.class);\n        LOG.assertTrue(javaPage != null);\n        ShowSettingsUtil.getInstance().editConfigurable(PlatformDataKeys.PROJECT.getData(dataContext), javaPage);\n      }\n      finally {\n        for (Configurable configurable : configurables) {\n          configurable.disposeUIResources();\n        }\n        colorAndFontOptions.disposeUIResources();\n      }\n    }\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int compare(final HighlightSeverity s1, final HighlightSeverity s2) {\n    return getOrder().indexOf(s1.myName) - getOrder().indexOf(s2.myName);\n  }","id":38651,"modified_method":"@Override\n  public int compare(final HighlightSeverity s1, final HighlightSeverity s2) {\n    TObjectIntHashMap<HighlightSeverity> order = getOrder();\n    return order.get(s1) - order.get(s2);\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<String> getDefaultOrder() {\n    Collection<SeverityBasedTextAttributes> values = ourMap.values();\n    List<HighlightSeverity> order = new ArrayList<HighlightSeverity>(STANDARD_SEVERITIES.size() + values.size());\n    for (HighlightInfoType type : STANDARD_SEVERITIES.values()) {\n      order.add(type.getSeverity(null));\n    }\n    for (SeverityBasedTextAttributes attributes : values) {\n      order.add(attributes.getSeverity());\n    }\n    ContainerUtil.sort(order);\n    List<String> result = new ArrayList<String>(order.size());\n    for (HighlightSeverity severity : order) {\n      result.add(severity.toString());\n    }\n    return result;\n  }","id":38652,"modified_method":"@NotNull\n  private List<HighlightSeverity> getDefaultOrder() {\n    Collection<SeverityBasedTextAttributes> values = ourMap.values();\n    List<HighlightSeverity> order = new ArrayList<HighlightSeverity>(STANDARD_SEVERITIES.size() + values.size());\n    for (HighlightInfoType type : STANDARD_SEVERITIES.values()) {\n      order.add(type.getSeverity(null));\n    }\n    for (SeverityBasedTextAttributes attributes : values) {\n      order.add(attributes.getSeverity());\n    }\n    ContainerUtil.sort(order);\n    return order;\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void writeExternal(Element element) throws WriteExternalException {\n    for (String severity : getOrder()) {\n      Element info = new Element(INFO);\n      final SeverityBasedTextAttributes infoType = ourMap.get(severity);\n      if (infoType != null) {\n        infoType.writeExternal(info);\n        final Color color = ourRendererColors.get(severity);\n        if (color != null) {\n          info.setAttribute(COLOR, Integer.toString(color.getRGB() & 0xFFFFFF, 16));\n        }\n        element.addContent(info);\n      }\n    }\n    if (myReadOrder != null && !myReadOrder.isEmpty()) {\n      myReadOrder.writeExternal(element);\n    }\n    else {\n      if (!getDefaultOrder().equals(getOrder())) {\n        getOrder().writeExternal(element);\n      }\n    }\n  }","id":38653,"modified_method":"@Override\n  public void writeExternal(Element element) throws WriteExternalException {\n    List<HighlightSeverity> list = getOrderAsList();\n    for (HighlightSeverity s : list) {\n      Element info = new Element(INFO);\n      String severity = s.toString();\n      final SeverityBasedTextAttributes infoType = ourMap.get(severity);\n      if (infoType != null) {\n        infoType.writeExternal(info);\n        final Color color = ourRendererColors.get(severity);\n        if (color != null) {\n          info.setAttribute(COLOR, Integer.toString(color.getRGB() & 0xFFFFFF, 16));\n        }\n        element.addContent(info);\n      }\n    }\n\n    if (myReadOrder != null && !myReadOrder.isEmpty()) {\n      myReadOrder.writeExternal(element);\n    }\n    else if (!getDefaultOrder().equals(list)) {\n      final JDOMExternalizableStringList ext = new JDOMExternalizableStringList(Collections.nCopies(myOrder.size(), \"\"));\n      myOrder.forEachEntry(new TObjectIntProcedure<HighlightSeverity>() {\n        @Override\n        public boolean execute(HighlightSeverity orderSeverity, int oIdx) {\n          ext.set(oIdx, orderSeverity.toString());\n          return true;\n        }\n      });\n      ext.writeExternal(element);\n    }\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JDOMExternalizableStringList getOrder() {\n    if (myOrder.isEmpty()) {\n      myOrder.addAll(getDefaultOrder());\n    }\n    return myOrder;\n  }","id":38654,"modified_method":"@NotNull\n  private TObjectIntHashMap<HighlightSeverity> getOrder() {\n    if (myOrder.isEmpty()) {\n      List<HighlightSeverity> order = getDefaultOrder();\n      setFromList(order);\n    }\n    return myOrder;\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getSeverityIdx(@NotNull HighlightSeverity severity) {\n    return getOrder().indexOf(severity.toString());\n  }","id":38655,"modified_method":"public int getSeverityIdx(@NotNull HighlightSeverity severity) {\n    return getOrder().get(severity);\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    ourMap.clear();\n    ourRendererColors.clear();\n    final List children = element.getChildren(INFO);\n    if (children != null){\n      for (Object child : children) {\n        final Element infoElement = (Element)child;\n\n        final SeverityBasedTextAttributes highlightInfo = new SeverityBasedTextAttributes();\n        highlightInfo.readExternal(infoElement);\n\n        Color color = null;\n        final String colorStr = infoElement.getAttributeValue(COLOR);\n        if (colorStr != null){\n          color = new Color(Integer.parseInt(colorStr, 16));\n        }\n        registerSeverity(highlightInfo, color);\n      }\n    }\n    myOrder.clear();\n    myOrder.readExternal(element);\n\n    myReadOrder = new JDOMExternalizableStringList();\n    myReadOrder.addAll(myOrder);\n\n    final List<String> knownSeverities = getDefaultOrder();\n    myOrder.retainAll(knownSeverities);\n\n    if (myOrder.isEmpty()) {\n      myOrder.addAll(knownSeverities);\n    }\n    //enforce include all known\n    for (int i = 0; i < knownSeverities.size(); i++) {\n      String stdSeverity = knownSeverities.get(i);\n      if (!myOrder.contains(stdSeverity)) {\n        for (int oIdx = 0; oIdx < myOrder.size(); oIdx++) {\n          final String orderSeverity = myOrder.get(oIdx);\n          final HighlightInfoType type = STANDARD_SEVERITIES.get(orderSeverity);\n          if (type != null && knownSeverities.indexOf(type.getSeverity(null).toString()) > i) {\n            myOrder.add(oIdx, stdSeverity);\n            myReadOrder = null;\n            break;\n          }\n        }\n      }\n    }\n  }","id":38656,"modified_method":"@Override\n  public void readExternal(Element element) throws InvalidDataException {\n    ourMap.clear();\n    ourRendererColors.clear();\n    final List children = element.getChildren(INFO);\n    if (children != null){\n      for (Object child : children) {\n        final Element infoElement = (Element)child;\n\n        final SeverityBasedTextAttributes highlightInfo = new SeverityBasedTextAttributes();\n        highlightInfo.readExternal(infoElement);\n\n        Color color = null;\n        final String colorStr = infoElement.getAttributeValue(COLOR);\n        if (colorStr != null){\n          color = new Color(Integer.parseInt(colorStr, 16));\n        }\n        registerSeverity(highlightInfo, color);\n      }\n    }\n    myOrder.clear();\n\n    myReadOrder = new JDOMExternalizableStringList();\n    myReadOrder.readExternal(element);\n    for (int i = 0; i < myReadOrder.size(); i++) {\n      String name = myReadOrder.get(i);\n      HighlightSeverity severity = getSeverity(name);\n      if (severity == null) continue;\n      myOrder.put(severity, i);\n    }\n    final List<HighlightSeverity> knownSeverities = getDefaultOrder();\n    myOrder.retainEntries(new TObjectIntProcedure<HighlightSeverity>() {\n      @Override\n      public boolean execute(HighlightSeverity severity, int order) {\n        return knownSeverities.contains(severity);\n      }\n    });\n\n    if (myOrder.isEmpty()) {\n      setFromList(knownSeverities);\n    }\n    //enforce include all known\n    List<HighlightSeverity> list = getOrderAsList();\n    for (int i = 0; i < knownSeverities.size(); i++) {\n      HighlightSeverity stdSeverity = knownSeverities.get(i);\n      if (!list.contains(stdSeverity)) {\n        for (int oIdx = 0; oIdx < list.size(); oIdx++) {\n          HighlightSeverity orderSeverity = list.get(oIdx);\n          HighlightInfoType type = STANDARD_SEVERITIES.get(orderSeverity.toString());\n          if (type != null && knownSeverities.indexOf(type.getSeverity(null)) > i) {\n            list.add(oIdx, stdSeverity);\n            myReadOrder = null;\n            break;\n          }\n        }\n      }\n    }\n    setFromList(list);\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setOrder(List<String> order) {\n    myOrder.clear();\n    myOrder.addAll(order);\n\n    myReadOrder = null;\n  }","id":38657,"modified_method":"public void setOrder(@NotNull List<HighlightSeverity> order) {\n    setFromList(order);\n    myReadOrder = null;\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HighlightSeverity getSeverityByIndex(final int i) {\n    return getSeverity(getOrder().get(i));\n  }","id":38658,"modified_method":"public HighlightSeverity getSeverityByIndex(final int i) {\n    final HighlightSeverity[] found = new HighlightSeverity[1];\n    getOrder().forEachEntry(new TObjectIntProcedure<HighlightSeverity>() {\n      @Override\n      public boolean execute(HighlightSeverity severity, int order) {\n        if (order == i) {\n          found[0] = severity;\n          return false;\n        }\n        return true;\n      }\n    });\n    return found[0];\n  }","commit_id":"79bbc37f1674e00e835e54c3ea8271b9deb3939c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Map<String, Object> toMap(Extractor extractor) {\n        Map<String, Object> map = Maps.newHashMap();\n\n        map.put(Extractor.FIELD_ID, extractor.getId());\n        map.put(Extractor.FIELD_TITLE, extractor.getTitle());\n        map.put(Extractor.FIELD_TYPE, extractor.getType().toString().toLowerCase());\n        map.put(Extractor.FIELD_CURSOR_STRATEGY, extractor.getCursorStrategy().toString().toLowerCase());\n        map.put(Extractor.FIELD_SOURCE_FIELD, extractor.getSourceField());\n        map.put(Extractor.FIELD_TARGET_FIELD, extractor.getTargetField());\n        map.put(Extractor.FIELD_EXTRACTOR_CONFIG, extractor.getExtractorConfig());\n        map.put(Extractor.FIELD_CREATOR_USER_ID, extractor.getCreatorUserId());\n        map.put(Extractor.FIELD_CONVERTERS, extractor.converterConfigMap());\n        map.put(Extractor.FIELD_CONDITION_TYPE, extractor.getConditionType().toString().toLowerCase());\n        map.put(Extractor.FIELD_CONDITION_VALUE, extractor.getConditionValue());\n        map.put(Extractor.FIELD_ORDER, extractor.getOrder());\n\n        map.put(\"exceptions\", extractor.getExceptionCount());\n        map.put(\"converter_exceptions\", extractor.getConverterExceptionCount());\n\n        Map<String, Object> metrics = Maps.newHashMap();\n        metrics.put(\"total\", MetricUtils.buildTimerMap(metricRegistry.getTimers().get(extractor.getTotalTimerName())));\n        metrics.put(\"converters\", MetricUtils.buildTimerMap(metricRegistry.getTimers().get(extractor.getConverterTimerName())));\n        map.put(\"metrics\", metrics);\n\n        return map;\n    }","id":38659,"modified_method":"private ExtractorSummary toMap(Extractor extractor) {\n        final ExtractorMetrics metrics = ExtractorMetrics.create(MetricUtils.buildTimerMap(metricRegistry.getTimers().get(extractor.getTotalTimerName())),\n                MetricUtils.buildTimerMap(metricRegistry.getTimers().get(extractor.getConverterTimerName())));\n\n        return ExtractorSummary.create(extractor.getId(), extractor.getTitle(), extractor.getType().toString().toLowerCase(), extractor.getCursorStrategy().toString().toLowerCase(),\n                extractor.getSourceField(), extractor.getTargetField(), extractor.getExtractorConfig(), extractor.getCreatorUserId(), extractor.converterConfigMap(),\n                extractor.getConditionType().toString().toLowerCase(), extractor.getConditionValue(), extractor.getOrder(), extractor.getExceptionCount(),\n                extractor.getConverterExceptionCount(), metrics);\n    }","commit_id":"209959a7bfedaa6b1e01bdfa7ad357e41ac0f363","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public int getSeverityIdx(@NotNull HighlightSeverity severity) {\n    final OrderMap order = getOrder();\n    if (!order.contains(severity)) return -1;\n    return order.get(severity);\n  }","id":38660,"modified_method":"public int getSeverityIdx(@NotNull HighlightSeverity severity) {\n    return getOrder().getOrder(severity, -1);\n  }","commit_id":"95f7e8e5223647b3fb2199efc222606816f97b9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"boolean isShowing() {\r\n        \tif (IconPref.getHierarchyIconValue())\r\n        \t\treturn mLWC.hasChildren();\r\n        \telse\r\n        \t\treturn false;\r\n        }","id":38661,"modified_method":"boolean isShowing() {\r\n            // TODO performance: getting complicated: compute in layout (and check for all text nodes, not just first)\r\n            // Will need to make sure layout() is called when removing items from nodes: only appears to be called upon adding\r\n            if (IconPref.getHierarchyIconValue()) {\r\n                if (mLWC.hasChildren()) {\r\n                    if (mLWC.numChildren() == 1 && mLWC.getChild(0).isTextNode())\r\n                        return false;\r\n                    else\r\n                        return true;\r\n                }\r\n            }\r\n            return false;\r\n        }","commit_id":"0f56f0eea5dacbe4de24576c125ef30202a1896a","url":"https://github.com/VUE/VUE"},{"original_method":"private String getChildHtml(LWComponent c, int indent)\r\n        {\r\n            // todo perf: use StringBuffer\r\n            String label = null;\r\n            if (indent == 1)\r\n                label = \"&nbsp;<b>\" + c.getDisplayLabel() + \"<\/b>\";\r\n            else\r\n                label = c.getDisplayLabel();\r\n            \r\n            String html = label + RightMargin + \"<br>\";\r\n\r\n            if (!(c instanceof LWContainer))\r\n                return html;\r\n            \r\n            Iterator i = ((LWContainer)c).getChildIterator();\r\n            int n = 0;\r\n            while (i.hasNext()) {\r\n                LWComponent child = (LWComponent) i.next();\r\n                //if (n++ > 0) html += \"<br>\";\r\n                for (int x = 0; x < indent; x++)\r\n                    html += Indent;\r\n                if (indent % 2 == 0)\r\n                    html += \"- \";\r\n                else\r\n                    html += \"+ \";\r\n                html += getChildHtml(child, indent + 1);\r\n            }\r\n            return html;\r\n        }","id":38662,"modified_method":"private String getChildHtml(LWComponent c, int indent)\r\n        {\r\n            // todo perf: use StringBuffer\r\n            String label = null;\r\n            if (indent == 1)\r\n                label = \"&nbsp;<b>\" + c.getDisplayLabel() + \"<\/b>\";\r\n            else\r\n                label = c.getDisplayLabel();\r\n            \r\n            String html = label + RightMargin + \"<br>\";\r\n\r\n            if (!(c instanceof LWContainer))\r\n                return html;\r\n            \r\n            //int n = 0;\r\n            for (LWComponent child : c.getChildren()) {\r\n                if (child.isTextNode())\r\n                    continue;\r\n                //if (n++ > 0) html += \"<br>\";\r\n                for (int x = 0; x < indent; x++)\r\n                    html += Indent;\r\n                if (indent % 2 == 0)\r\n                    html += \"- \";\r\n                else\r\n                    html += \"+ \";\r\n                html += getChildHtml(child, indent + 1);\r\n            }\r\n            return html;\r\n        }","commit_id":"0f56f0eea5dacbe4de24576c125ef30202a1896a","url":"https://github.com/VUE/VUE"},{"original_method":"protected void layout()\n    {\n        if (inLayout) {\n            new Throwable(\"ALREADY IN LAYOUT \" + this).printStackTrace();\n            return;\n        }\n        inLayout = true;\n        if (DEBUG_LAYOUT) System.out.println(\"*** LAYOUT \" + this);\n\n        float oldWidth = getWidth();\n        float oldHeight = getHeight();\n\n        //if (isAutoSized() || hasChildren())\n        //setPreferredSize(!isAutoSized());\n\n        boolean growOnly = false;//for non-autosized\n        Dimension text = getLabelBox().getPreferredSize(); // may be important to use pref size -- keep for now\n        float width = text.width;\n        //float width = s.width + PadX;\n        //float height = s.height + PadY;\n        //float height = getLabelBox().getHeight() + IconHeight/3f;\n        //float height = getLabelBox().getHeight() + IconDescent;\n        float height = PadTop + text.height;\n        \n        if (getLabelBox().getHeight() != text.height) {\n            // NOTE: prefHeight often a couple of pixels less than getHeight\n            System.err.println(\"prefHeight != height in \" + this);\n            System.err.println(\"\\tpref=\" + text.height);\n            System.err.println(\"\\treal=\" + getLabelBox().getHeight());\n        }\n        \n        //-------------------------------------------------------\n        // resource icon\n        //-------------------------------------------------------\n        \n        if (iconShowing()) {\n            double dividerY = PadTop + text.height;\n            \n            float iconWidth = IconWidth;\n            float iconHeight = IconHeight;\n            double iconX = IconPadLeft;\n            double iconY = dividerY - IconAscent;\n\n            if (iconY < IconMinY) {\n                // this can happen if font size is very small\n                iconY = IconMinY;\n                dividerY = iconY + IconAscent;\n            }\n            \n            //if (hasNotes()) iconHeight *= 2;\n            genIcon.setFrame(iconX, iconY, iconWidth, iconHeight);\n\n            double stubX = relativeLabelX() + text.width + DividerStubPadX;\n            double stubHeight = DividerStubAscent;\n            \n            dividerLine.setLine(0, dividerY, stubX, dividerY);\n            dividerStub.setLine(stubX, dividerY, stubX, dividerY - stubHeight);\n\n            height = PadTop + (float)dividerY + IconDescent;\n            width = (float)stubX + IconPadLeft; // be symmetrical with left padding\n        } else {\n            width += 12;\n        }\n\n        //-------------------------------------------------------\n        // set size (was setPreferredSize)\n        //-------------------------------------------------------\n\n        if (hasChildren()) {\n            float[] size = new float[2];\n            layoutChildren(size);\n            float childrenWidth = size[0];\n            float childrenHeight = size[1];\n            if (width < childOffsetX() + childrenWidth + ChildPadX)\n                width = childOffsetX() + childrenWidth + ChildPadX;\n            height += childrenHeight;\n            height += ChildOffsetY + ChildrenPadBottom; // additional space below last child before bottom of node\n        } else if (iconShowing()) {\n            height += IconPadBottom;\n        }\n        //else add pad or make sure vertical centering the plain label\n        \n        setSizeNoLayout(width, height);\n\n        /*\n        if (growOnly) {\n            if (this.width > width)\n                width = this.width;\n            if (this.height > height)\n                height = this.height;\n            if (width > this.width || height > this.height)\n                setSizeNoLayout(width, height);\n        } else\n            setSizeNoLayout(width, height);\n        */\n        \n\n        // todo: handle thru event?\n        if (getParent() != null && (oldWidth != getWidth() || oldHeight != getHeight())) {\n            //new Throwable(\"LAYING OUT PARENT \" + this).printStackTrace();\n            getParent().layout();\n        }\n\n        inLayout = false;\n    }","id":38663,"modified_method":"protected void layout()\n    {\n        if (inLayout) {\n            new Throwable(\"ALREADY IN LAYOUT \" + this).printStackTrace();\n            return;\n        }\n        inLayout = true;\n        if (DEBUG_LAYOUT) System.out.println(\"*** LAYOUT \" + this);\n\n        float oldWidth = getWidth();\n        float oldHeight = getHeight();\n\n        //if (isAutoSized() || hasChildren())\n        //setPreferredSize(!isAutoSized());\n\n        boolean growOnly = false;//for non-autosized\n        Dimension text = getLabelBox().getPreferredSize(); // may be important to use pref size -- keep for now\n        float width = text.width;\n        //float width = s.width + PadX;\n        //float height = s.height + PadY;\n        //float height = getLabelBox().getHeight() + IconHeight/3f;\n        //float height = getLabelBox().getHeight() + IconDescent;\n        float height = EdgePadY + text.height + EdgePadY;\n        \n        if (getLabelBox().getHeight() != text.height) {\n            // NOTE: prefHeight often a couple of pixels less than getHeight\n            System.err.println(\"prefHeight != height in \" + this);\n            System.err.println(\"\\tpref=\" + text.height);\n            System.err.println(\"\\treal=\" + getLabelBox().getHeight());\n        }\n\n        // *** set icon Y position in all cases to a centered vertical\n        // position, but never such that baseline is below bottom of\n        // first icon -- this is tricky tho, as first icon can move\n        // down a bit to be centered with the label!\n\n        if (!iconShowing()) {\n            width += LabelPadLeft * 2 + TextWidthFudgeAmount; // adjust for scaled fonts understating their width\n        } else {\n            float dividerY = EdgePadY + text.height;\n            // GAK: relativeLabelX barely safe to call here,but only cause it\n            // only computes horizontal centering when NOT displaying an icon\n            double stubX = LabelPositionXWhenIconShowing + text.width + TextWidthFudgeAmount;\n            double stubHeight = DividerStubAscent;\n            \n            //dividerUnderline.setLine(0, dividerY, stubX, dividerY);\n            dividerUnderline.setLine(IconMargin, dividerY, stubX, dividerY);\n            dividerStub.setLine(stubX, dividerY, stubX, dividerY - stubHeight);\n\n            ////height = PadTop + (float)dividerY + IconDescent; // for aligning 1st icon with label bottom\n            width = (float)stubX + IconPadLeft; // be symmetrical with left padding\n            //width += IconPadLeft;\n        }\n        \n        //-------------------------------------------------------\n        // set size (was setPreferredSize)\n        //-------------------------------------------------------\n\n        if (hasChildren()) {\n            float[] size = new float[2];\n            layoutChildren(size);\n            float childrenWidth = size[0];\n            float childrenHeight = size[1];\n            if (width < childOffsetX() + childrenWidth + ChildPadX)\n                width = childOffsetX() + childrenWidth + ChildPadX;\n            height += childrenHeight;\n            height += ChildOffsetY + ChildrenPadBottom; // additional space below last child before bottom of node\n        }\n        //        else if (iconShowing()) {\n        //            height += IconPadBottom;\n        //        }\n        //else add pad or make sure vertical centering the plain label\n\n        //-------------------------------------------------------\n        // display any icons\n        //-------------------------------------------------------\n        \n        if (iconShowing()) {\n            float iconWidth = IconWidth;\n            float iconHeight = IconHeight;\n            float iconX = IconPadLeft;\n            //float iconY = dividerY - IconAscent;\n            //float iconY = dividerY - iconHeight; // align bottom of 1st icon with bottom of label\n            //float iconY = PadTop;\n\n            /*\n            if (iconY < IconMinY) {\n                // this can happen if font size is very small when\n                // alignining the first icon with the bottom of the text label\n                iconY = IconMinY;\n                dividerY = iconY + IconAscent;\n            }\n            */\n\n            this.iconPillarX = iconX;\n            this.iconPillarY = IconPillarPadY;\n            //this.iconPillarY = EdgePadY;\n            \n            int icons = 0;\n            if (hasResource()) icons++;\n            if (hasNotes()) icons++;\n            if (hasMetaData()) icons++;\n            if (inPathway()) icons++;\n\n            float iconPillarHeight = icons * IconHeight + IconPillarPadY * 2;\n\n            if (height < iconPillarHeight)\n                height += iconPillarHeight - height;\n            else {\n                // special case prettification -- if vertically centering\n                // the icon stack would only drop it down by up to a few\n                // pixels, go ahead and do so because it's so much nicer\n                // to look at.\n                float totalIconHeight = icons * IconHeight;\n                float centerY = (height - totalIconHeight) / 2;\n                if (centerY > IconPillarPadY+3)\n                    centerY = IconPillarPadY+3;\n                this.iconPillarY = centerY;\n            }\n            \n            float y = this.iconPillarY;\n            if (hasResource()) {\n                resourceIcon.setFrame(iconX, y, iconWidth, iconHeight);\n                y += resourceIcon.getHeight();\n            }\n            if (hasNotes()) {\n                notesIcon.setFrame(iconX, y, iconWidth, iconHeight);\n                y += notesIcon.getHeight();\n            }\n\n\n        }\n        \n        setSizeNoLayout(width, height);\n        dividerMarginLine.setLine(IconMargin, MarginLinePadY, IconMargin, height-MarginLinePadY);\n\n        /*\n        if (growOnly) {\n            if (this.width > width)\n                width = this.width;\n            if (this.height > height)\n                height = this.height;\n            if (width > this.width || height > this.height)\n                setSizeNoLayout(width, height);\n        } else\n            setSizeNoLayout(width, height);\n        */\n        \n\n        // todo: handle thru event?\n        if (getParent() != null && (oldWidth != getWidth() || oldHeight != getHeight())) {\n            //new Throwable(\"LAYING OUT PARENT \" + this).printStackTrace();\n            getParent().layout();\n        }\n\n        inLayout = false;\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"private float relativeLabelX()\n    {\n        float offset;\n        if (iconShowing()) {\n            //offset = (float) (PadX*1.5 + genIcon.getWidth());\n            //offset = (float) genIcon.getWidth() + 7;\n            offset = IconMargin;\n        } else {\n            // Center if no resource icon\n            int w = getLabelBox().getPreferredSize().width;\n            offset = (this.width - w) / 2;\n            offset++;\n            //offset = 7;\n        }\n        return offset;\n    }","id":38664,"modified_method":"private float relativeLabelX()\n    {\n        float offset;\n        if (iconShowing()) {\n            //offset = (float) (PadX*1.5 + genIcon.getWidth());\n            //offset = (float) genIcon.getWidth() + 7;\n            //offset = IconMargin + LabelPadLeft;\n            return LabelPositionXWhenIconShowing;\n        } else {\n            // horizontally center if no resource icon\n            int w = getLabelBox().getPreferredSize().width;\n            offset = (this.width - w) / 2;\n            offset++;\n            //offset = 7;\n        }\n        return offset;\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"public void draw(DrawContext dc)\n    {\n        Graphics2D g = dc.g;\n        \n        g.translate(getX(), getY());\n        float scale = getScale();\n        if (scale != 1f) g.scale(scale, scale);\n\n        //-------------------------------------------------------\n        // Fill the shape (if it's not transparent)\n        //-------------------------------------------------------\n        \n        if (imageIcon != null) {\n            // experimental\n            //imageIcon.paintIcon(null, g, (int)getX(), (int)getY());\n            imageIcon.paintIcon(null, g, 0, 0);\n        } else {\n            Color fillColor = getFillColor();\n            if (fillColor != null) { // transparent if null\n                g.setColor(fillColor);\n                //g.setColor(new Color(128,128,128,128));\n                if (isZoomedFocus())\n                    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.8f));\n                g.fill(drawnShape);\n            }\n        }\n\n        //-------------------------------------------------------\n        // Draw the indicated border if any\n        //-------------------------------------------------------\n        if (false&&isRollover()) {\n            // temporary debug\n            //g.setColor(new Color(0,0,128));\n            g.setColor(Color.blue);\n            g.draw(drawnShape);\n        }\n        else if (isIndicated()) {\n            // todo: okay, it is GROSS to handle the indication here --\n            // do it all in the viewer!\n            g.setColor(COLOR_INDICATION);\n            if (STROKE_INDICATION.getLineWidth() > getStrokeWidth())\n                g.setStroke(STROKE_INDICATION);\n            else\n                g.setStroke(this.stroke);\n            g.draw(drawnShape);\n        }\n        else if (getStrokeWidth() > 0) {\n            //if (LWSelection.DEBUG_SELECTION && isSelected())\n            if (isSelected())\n                g.setColor(COLOR_SELECTION);\n            else\n                g.setColor(getStrokeColor());\n            g.setStroke(this.stroke);\n            g.draw(drawnShape);\n        }\n\n\n        //-------------------------------------------------------\n        // Draw the generated icon\n        //-------------------------------------------------------\n\n        // Here we'll check the zoom level, and if iit's say,\n        // over 800%, we could draw the resource string in a tiny\n        // font right in the icon.\n\n        if (iconShowing())\n            drawUnderlineAndIcon(dc);\n\n        // todo: create drawLabel, drawBorder & drawBody\n        // LWComponent methods so can automatically turn\n        // this off in MapViewer, adjust stroke color for\n        // selection, etc.\n        \n        // TODO BUG: label sometimes getting \"set\" w/out sending layout event --\n        // has to do with case where we pre-fill a textbox with \"label\", and\n        // if they type nothing we don't set a label, but that's not working\n        // entirely -- it manages to not trigger an update event, but somehow\n        // this.label is still getting set -- maybe we have to null it out\n        // manually (and maybe labelBox also)\n        \n        if (hasLabel() && this.labelBox != null && this.labelBox.getParent() == null) {\n            // if parent is not null, this box is an active edit on the map\n            // and we don't want to paint it here as AWT/Swing is handling\n            // that at the moment (and at a possibly slightly different offset)\n            float lx = relativeLabelX();\n            float ly = relativeLabelY();\n            g.translate(lx, ly);\n            this.labelBox.draw(g);\n            g.translate(-lx, -ly);\n\n            // todo: this (and in LWLink) is a hack -- can't we\n            // do this relative to the node?\n            //this.labelBox.setMapLocation(getX() + lx, getY() + ly);\n        }\n        \n        //-------------------------------------------------------\n        // Restore graphics context\n        //-------------------------------------------------------\n\n        // todo arch: consider not restoring the scale before we draw\n        // the children, and maybe even handling this in LWContainer,\n        // as a way to see if we could get rid of all the confusing \"x\n        // * getScale()\" code & awkward recursive setScale code.\n        // Actually, we couldn't attempt this unless we also fully\n        // changed the children be drawn in a translated GC, and the\n        // hit-detection was compensated for more at search time\n        // instead of by resizing the object by having getHeight, etc,\n        // auto multiply by the scale factor, and actually resizing\n        // the bounds-shape when we scale an object.\n        \n        if (scale != 1f) g.scale(1/scale, 1/scale);\n        g.translate(-getX(), -getY());\n\n        //-------------------------------------------------------\n        // Draw any children\n        //-------------------------------------------------------\n\n        // This produces the cleanest code in all above -- don't\n        // need to manage scaling if we translate to a region\n        // where all the nodes will lie within, and then their\n        // positioning auto-collapses as their scaled down...\n        if (hasChildren()) {\n            //g.translate(childBaseX * ChildScale, childBaseY * ChildScale);\n            //g.scale(ChildScale, ChildScale);\n            //super.draw(dc.createScaled(ChildScale)); // not using this\n            //g.setComposite(childComposite);\n            super.draw(dc);\n        }\n    }","id":38665,"modified_method":"public void draw(DrawContext dc)\n    {\n        Graphics2D g = dc.g;\n        \n        g.translate(getX(), getY());\n        float scale = getScale();\n        if (scale != 1f) g.scale(scale, scale);\n\n        //-------------------------------------------------------\n        // Fill the shape (if it's not transparent)\n        //-------------------------------------------------------\n        \n        if (imageIcon != null) {\n            // experimental\n            //imageIcon.paintIcon(null, g, (int)getX(), (int)getY());\n            imageIcon.paintIcon(null, g, 0, 0);\n        } else {\n            Color fillColor = getFillColor();\n            if (fillColor != null) { // transparent if null\n                g.setColor(fillColor);\n                //g.setColor(new Color(128,128,128,128));\n                if (isZoomedFocus())\n                    g.setComposite(ZoomTransparency);\n                g.fill(drawnShape);\n                if (isZoomedFocus())\n                    g.setComposite(AlphaComposite.Src);\n            }\n        }\n\n        //-------------------------------------------------------\n        // Draw the indicated border if any\n        //-------------------------------------------------------\n        if (false&&isRollover()) {\n            // temporary debug\n            //g.setColor(new Color(0,0,128));\n            g.setColor(Color.blue);\n            g.draw(drawnShape);\n        }\n        else if (isIndicated()) {\n            // todo: okay, it is GROSS to handle the indication here --\n            // do it all in the viewer!\n            g.setColor(COLOR_INDICATION);\n            if (STROKE_INDICATION.getLineWidth() > getStrokeWidth())\n                g.setStroke(STROKE_INDICATION);\n            else\n                g.setStroke(this.stroke);\n            g.draw(drawnShape);\n        }\n        else if (getStrokeWidth() > 0) {\n            //if (LWSelection.DEBUG_SELECTION && isSelected())\n            if (isSelected())\n                g.setColor(COLOR_SELECTION);\n            else\n                g.setColor(getStrokeColor());\n            g.setStroke(this.stroke);\n            g.draw(drawnShape);\n        }\n\n\n        //-------------------------------------------------------\n        // Draw the generated icon\n        //-------------------------------------------------------\n\n        drawNodeDecorations(dc);\n\n        // todo: create drawLabel, drawBorder & drawBody\n        // LWComponent methods so can automatically turn\n        // this off in MapViewer, adjust stroke color for\n        // selection, etc.\n        \n        // TODO BUG: label sometimes getting \"set\" w/out sending layout event --\n        // has to do with case where we pre-fill a textbox with \"label\", and\n        // if they type nothing we don't set a label, but that's not working\n        // entirely -- it manages to not trigger an update event, but somehow\n        // this.label is still getting set -- maybe we have to null it out\n        // manually (and maybe labelBox also)\n        \n        if (hasLabel() && this.labelBox != null && this.labelBox.getParent() == null) {\n            // if parent is not null, this box is an active edit on the map\n            // and we don't want to paint it here as AWT/Swing is handling\n            // that at the moment (and at a possibly slightly different offset)\n            float lx = relativeLabelX();\n            float ly = relativeLabelY();\n            g.translate(lx, ly);\n            this.labelBox.draw(dc);\n            g.translate(-lx, -ly);\n\n            // todo: this (and in LWLink) is a hack -- can't we\n            // do this relative to the node?\n            //this.labelBox.setMapLocation(getX() + lx, getY() + ly);\n        }\n        \n        //-------------------------------------------------------\n        // Restore graphics context\n        //-------------------------------------------------------\n\n        // todo arch: consider not restoring the scale before we draw\n        // the children, and maybe even handling this in LWContainer,\n        // as a way to see if we could get rid of all the confusing \"x\n        // * getScale()\" code & awkward recursive setScale code.\n        // Actually, we couldn't attempt this unless we also fully\n        // changed the children be drawn in a translated GC, and the\n        // hit-detection was compensated for more at search time\n        // instead of by resizing the object by having getHeight, etc,\n        // auto multiply by the scale factor, and actually resizing\n        // the bounds-shape when we scale an object.\n        \n        if (scale != 1f) g.scale(1/scale, 1/scale);\n        g.translate(-getX(), -getY());\n\n        //-------------------------------------------------------\n        // Draw any children\n        //-------------------------------------------------------\n\n        // This produces the cleanest code in all above -- don't\n        // need to manage scaling if we translate to a region\n        // where all the nodes will lie within, and then their\n        // positioning auto-collapses as their scaled down...\n        if (hasChildren()) {\n            //g.translate(childBaseX * ChildScale, childBaseY * ChildScale);\n            //g.scale(ChildScale, ChildScale);\n            //super.draw(dc.createScaled(ChildScale)); // not using this\n            //g.setComposite(childComposite);\n            if (isZoomedFocus())\n                g.setComposite(ZoomTransparency);\n            super.draw(dc);\n        }\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"private float relativeLabelY()\n    {\n        if (iconShowing() || hasChildren()) {\n            if (iconShowing())\n                return (float) dividerLine.getY1() - getLabelBox().getPreferredSize().height;\n            else\n                return PadTop;\n        }\n        else // center vertically\n            return (this.height - getLabelBox().getPreferredSize().height) / 2;\n    }","id":38666,"modified_method":"private float relativeLabelY()\n    {\n        //return EdgePadY;\n        \n        if (hasChildren())\n            return EdgePadY;\n        else {\n            // only need this in case of small font sizes and an icon\n            // is showing -- if so, center label vertically in row with the first icon\n            // Actually, no: center in whole node -- gak, we really want both,\n            // but only to a certian threshold -- what a hack!\n            float textHeight = getLabelBox().getPreferredSize().height;\n            return (this.height - textHeight) / 2;\n\n            /*\n            float textHeight = getLabelBox().getPreferredSize().height;\n            if (iconShowing() && textHeight < IconHeight)\n                return iconPillarY + (IconHeight - textHeight) / 2;\n            else\n                return EdgePadY;\n            */\n        }\n        \n        /*\n          // for single resource icon style layout\n        if (iconShowing() || hasChildren()) {\n            if (iconShowing())\n                return (float) dividerUnderline.getY1() - getLabelBox().getPreferredSize().height;\n            else\n                return PadTop;\n        }\n        else // center vertically\n            return (this.height - getLabelBox().getPreferredSize().height) / 2;\n        */\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean handleDoubleClick(MapMouseEvent e)\n    {\n        //System.out.println(\"*** handleDoubleClick \" + e + \" \" + this);\n\n        // need to get mapmouseevent here so can ask viewer\n        // to activate label edit.\n\n        float cx = e.getComponentX();\n        float cy = e.getComponentY();\n\n        if (textBoxHit(cx, cy)) {\n            e.getViewer().activateLabelEdit(this);\n        } else {\n            // by default, a double-click anywhere else in\n            // node opens the resource\n            \n            if (getResource() != null) {\n                getResource().displayContent();\n                // todo: some kind of animation or something to show\n                // we're \"opening\" this node -- maybe an indication\n                // flash -- we'll need another thread for that.\n                \n                //mme.getViewer().setIndicated(this); or\n                //mme.getComponent().paintImmediately(mapToScreenRect(getBounds()));\n                //or mme.repaint(this)\n                // now open resource, and then clear indication\n                //clearIndicated();\n                //repaint();\n            }\n        }\n        return true;\n    }","id":38667,"modified_method":"public boolean handleDoubleClick(MapMouseEvent e)\n    {\n        //System.out.println(\"*** handleDoubleClick \" + e + \" \" + this);\n\n        // need to get mapmouseevent here so can ask viewer\n        // to activate label edit.\n\n        float cx = e.getComponentX();\n        float cy = e.getComponentY();\n\n        if (textBoxHit(cx, cy)) {\n            e.getViewer().activateLabelEdit(this);\n        } else {\n            // by default, a double-click anywhere else in\n            // node opens the resource\n            \n            if (hasResource()) {\n                getResource().displayContent();\n                // todo: some kind of animation or something to show\n                // we're \"opening\" this node -- maybe an indication\n                // flash -- we'll need another thread for that.\n                \n                //mme.getViewer().setIndicated(this); or\n                //mme.getComponent().paintImmediately(mapToScreenRect(getBounds()));\n                //or mme.repaint(this)\n                // now open resource, and then clear indication\n                //clearIndicated();\n                //repaint();\n            }\n        }\n        return true;\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"protected void layoutChildrenGrid(float baseX, float baseY, float[] size)\n    {\n        float y = baseY;\n        float totalWidth = 0;\n        float maxHeight = 0;\n        \n        Column[] cols = new Column[nColumn];\n        java.util.Iterator i = getChildIterator();\n        int curCol = 0;\n        while (i.hasNext()) {\n            LWComponent c = (LWComponent) i.next();\n            if (cols[curCol] == null)\n                cols[curCol] = new Column();\n            cols[curCol].add(c);\n            if (++curCol >= nColumn)\n                curCol = 0;\n        }\n\n        float colX = baseX;\n        float colY = baseY;\n        for (int x = 0; x < cols.length; x++) {\n            Column col = cols[x];\n            if (col == null)\n                break;\n            col.layout(colX, colY);\n            colX += col.width + ChildHorizontalGap;\n            totalWidth += col.width + ChildHorizontalGap;\n            if (col.height > maxHeight)\n                maxHeight = col.height;\n        }\n        totalWidth -= ChildHorizontalGap;\n\n        if (size != null) {\n            size[0] = totalWidth;\n            size[1] = maxHeight;\n        }\n    }","id":38668,"modified_method":"protected void layoutChildrenGrid(float baseX, float baseY, float[] size, int nColumn)\n    {\n        float y = baseY;\n        float totalWidth = 0;\n        float maxHeight = 0;\n        \n        Column[] cols = new Column[nColumn];\n        java.util.Iterator i = getChildIterator();\n        int curCol = 0;\n        while (i.hasNext()) {\n            LWComponent c = (LWComponent) i.next();\n            if (cols[curCol] == null)\n                cols[curCol] = new Column();\n            cols[curCol].add(c);\n            if (++curCol >= nColumn)\n                curCol = 0;\n        }\n\n        float colX = baseX;\n        float colY = baseY;\n        for (int x = 0; x < cols.length; x++) {\n            Column col = cols[x];\n            if (col == null)\n                break;\n            col.layout(colX, colY);\n            colX += col.width + ChildHorizontalGap;\n            totalWidth += col.width + ChildHorizontalGap;\n            if (col.height > maxHeight)\n                maxHeight = col.height;\n        }\n        totalWidth -= ChildHorizontalGap;\n\n        if (size != null) {\n            size[0] = totalWidth;\n            size[1] = maxHeight;\n        }\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"public LWComponent duplicate()\n    {\n        LWNode newNode = (LWNode) super.duplicate();\n        newNode.autoSized = this.autoSized;\n        // TODO: do this as a class and we don't have to keep handling the newInstance everywhere we setNodeShape\n        if (getShape() != null)\n            newNode.setShape((RectangularShape)((RectangularShape)getShape()).clone());\n        else if (getNodeShape() != null) // todo: for backward compat only \n            newNode.setNodeShape(getNodeShape());\n        return newNode;\n    }","id":38669,"modified_method":"public LWComponent duplicate()\n    {\n        LWNode newNode = (LWNode) super.duplicate();\n        newNode.autoSized = this.autoSized;\n        // TODO: do this as a class and we don't have to keep handling the newInstance everywhere we setNodeShape\n        if (getShape() != null)\n            newNode.setShape((RectangularShape)((RectangularShape)getShape()).clone());\n        //else if (getNodeShape() != null) // todo: for backward compat only \n        //newNode.setNodeShape(getNodeShape());\n        return newNode;\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"private boolean textBoxHit(float cx, float cy)\n    {\n        float lx = relativeLabelX() - IconPadRight;\n        float ly = relativeLabelY() - PadTop;\n        float height = getLabelBox().getHeight() + PadTop;\n        float width = IconPadRight + getLabelBox().getWidth() + DividerStubPadX;\n\n        return\n            cx >= lx &&\n            cy >= ly &&\n            cx <= lx + width &&\n            cy <= ly + height;\n    }","id":38670,"modified_method":"private boolean textBoxHit(float cx, float cy)\n    {\n        float lx = relativeLabelX() - IconPadRight;\n        float ly = relativeLabelY() - PadTop;\n        float height = getLabelBox().getHeight() + PadTop;\n        float width = IconPadRight + getLabelBox().getWidth() + TextWidthFudgeAmount;\n\n        return\n            cx >= lx &&\n            cy >= ly &&\n            cx <= lx + width &&\n            cy <= ly + height;\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean contains(float x, float y)\n    {\n        if (imageIcon != null)\n            return super.contains(x,y);\n        else {\n            if (isRectShape) {\n                return boundsShape.contains(x, y);\n            } else {\n                float cx = x - getX();\n                float cy = y - getY();\n                return boundsShape.contains(x, y)\n                    || textBoxHit(cx, cy)\n                    || genIcon.contains(cx, cy);\n            }\n        }\n        // if shape is not rectangular, check textBoxHit & genIcon hit\n        \n        // to compensate for stroke width here, could get mathy here\n        // and move the x/y strokeWidth units along a line toward\n        // the center of the object, which wouldn't be perfect\n        // but would be reasonable.\n    }","id":38671,"modified_method":"public boolean contains(float x, float y)\n    {\n        if (imageIcon != null)\n            return super.contains(x,y);\n        else {\n            if (isRectShape) {\n                return boundsShape.contains(x, y);\n            } else {\n                float cx = x - getX();\n                float cy = y - getY();\n                return boundsShape.contains(x, y)\n                    || textBoxHit(cx, cy)\n                    || resourceIcon.contains(cx, cy);\n            }\n        }\n        // if shape is not rectangular, check textBoxHit & genIcon hit\n        \n        // to compensate for stroke width here, could get mathy here\n        // and move the x/y strokeWidth units along a line toward\n        // the center of the object, which wouldn't be perfect\n        // but would be reasonable.\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"private boolean iconShowing()\n    {\n        return AlwaysShowIcon || getResource() != null;\n    }","id":38672,"modified_method":"private boolean iconShowing()\n    {\n        return AlwaysShowIcon || hasResource() || hasNotes() || hasMetaData() || inPathway();\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"protected void layoutChildren(float[] size)\n    {\n        if (!hasChildren())\n            return;\n\n        float baseX = childOffsetX() * getScale();\n        float baseY = 0;\n        if (iconShowing()) {\n            baseY = (float) (genIcon.getY() + IconHeight + ChildOffsetY);\n        } else {\n            baseY = relativeLabelY() + getLabelBox().getHeight();\n        }\n        baseY *= getScale();\n        baseX += getX();\n        baseY += getY();\n\n        //System.out.println(\"layoutChildren \" + this);\n\n        childBaseX = baseX;\n        childBaseY = baseY;\n        // for relative-to-parent child layouts\n        //baseX = baseY = 0;\n        \n        //layoutChildrenSingleColumn(baseX, baseY, size);\n        layoutChildrenGrid(baseX, baseY, size);\n\n        if (size != null) {\n            size[0] /= getScale();\n            size[1] /= getScale();\n            //size[0] *= ChildScale;\n            //size[1] *= ChildScale;\n        }\n        \n    }","id":38673,"modified_method":"/**\n     * Need to be able to do this seperately from layout -- this\n     * get's called everytime a node's location is changed so\n     * that's it's children will follow along with it.\n     *\n     * Children are laid out relative to the parent, but given\n     * absolute map coordinates.  Note that because if this, anytime\n     * we're computing a location for a child, we have to factor in\n     * the current scale factor of the parent.\n     */\n    \n    //private float childBaseX = 0;\n    //private float childBaseY = 0;\n    protected void layoutChildren(float[] size)\n    {\n        if (!hasChildren())\n            return;\n\n        float baseX = childOffsetX() * getScale();\n        float baseY = 0;\n        if (iconShowing()) {\n            //baseY = (float) (resourceIcon.getY() + IconHeight + ChildOffsetY);\n            baseY = (float) dividerUnderline.getY1();\n        } else {\n            baseY = relativeLabelY() + getLabelBox().getHeight();\n        }\n        baseY += ChildOffsetY;\n        baseY *= getScale();\n        baseX += getX();\n        baseY += getY();\n\n        //System.out.println(\"layoutChildren \" + this);\n\n        //childBaseX = baseX;\n        //childBaseY = baseY;\n        // for relative-to-parent child layouts\n        //baseX = baseY = 0;\n        \n        if (true)\n            layoutChildrenSingleColumn(baseX, baseY, size);\n        else\n            layoutChildrenGrid(baseX, baseY, size, 2);\n\n        if (size != null) {\n            size[0] /= getScale();\n            size[1] /= getScale();\n        }\n        \n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"LWNode(String label, float x, float y, RectangularShape shape)\n    {\n        super.label = label; // todo: this for debugging\n        setFillColor(COLOR_NODE_DEFAULT);\n        if (shape == null)\n            setNodeShape(StandardShapes[4]);\n        else\n            setShape(shape);\n        setStrokeWidth(1f);// todo\n        setLocation(x, y);\n        //if (getAbsoluteWidth() < 10 || getAbsoluteHeight() < 10)\n        setSize(10,10);\n        setLabel(label);\n        setFont(FONT_NODE_DEFAULT);\n    }","id":38674,"modified_method":"LWNode(String label, float x, float y, RectangularShape shape)\n    {\n        super.label = label; // todo: this for debugging\n        setFillColor(COLOR_NODE_DEFAULT);\n        if (shape == null)\n            setNodeShape(StandardShapes[4]);\n        else\n            setShape(shape);\n        setStrokeWidth(NODE_DEFAULT_STROKE_WIDTH);\n        setStrokeColor(NODE_DEFAULT_STROKE_COLOR);\n        setLocation(x, y);\n        //if (getAbsoluteWidth() < 10 || getAbsoluteHeight() < 10)\n        setSize(10,10);\n        setLabel(label);\n        setFont(FONT_NODE_DEFAULT);\n    }","commit_id":"8c1945d86a6f9aaa7e7d1ca387c4e4b6cc0f5a5f","url":"https://github.com/VUE/VUE"},{"original_method":"boolean isShowing() {\r\n            // TODO performance: getting complicated: compute in layout (and check for all text nodes, not just first)\r\n            // Will need to make sure layout() is called when removing items from nodes: only appears to be called upon adding\r\n            if (IconPref.getHierarchyIconValue()) {\r\n                if (mLWC.hasChildren() && mLWC.numChildren() == 1) {\r\n                    LWComponent child0 = mLWC.getChild(0);\r\n                    if (child0.isTextNode() || LWNode.isImageNode(mLWC))\r\n                        return false;\r\n                    else\r\n                        return true;\r\n                }\r\n            }\r\n            return false;\r\n        }","id":38675,"modified_method":"boolean isShowing() {\r\n            // TODO performance: getting complicated: compute in layout (and check for all text nodes, not just first)\r\n            // Will need to make sure layout() is called when removing items from nodes: only appears to be called upon adding\r\n            if (IconPref.getHierarchyIconValue()) {\r\n                if (mLWC.numChildren() == 1) {\r\n                    LWComponent child0 = mLWC.getChild(0);\r\n                    if (child0.isTextNode() || LWNode.isImageNode(mLWC))\r\n                        return false;\r\n                    else\r\n                        return true;\r\n                } else if (mLWC.hasChildren())\r\n                    return true;\r\n            }\r\n            return false;\r\n        }","commit_id":"46d9ab2522967186b8d01cb76802f85ce4fd9b50","url":"https://github.com/VUE/VUE"},{"original_method":"public AddLanguagePage enterSearchLanguage(String language) {\n        log.info(\"Enter language {}\", language);\n        WebElementUtil.searchAutocomplete(getDriver(),\n                \"localeAutocomplete\", language);\n        return new AddLanguagePage(getDriver());\n    }","id":38676,"modified_method":"public AddLanguagePage enterSearchLanguage(String language) {\n        log.info(\"Enter language {}\", language);\n        WebElementUtil.searchAutocomplete(getDriver(),\n                \"localeAutocomplete\", language);\n        // Pause for a moment, as quick actions can break here\n        slightPause();\n        return new AddLanguagePage(getDriver());\n    }","commit_id":"0e9518c4810f0eaa303db868f46ae04132401143","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The administrator can add a disabled language to Zanata\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 181709)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void addLanguageAsDisabled() throws Exception {\n        String language = \"Klingon\";\n        String languageDisplayName = \"klingon[Klingon]\";\n        ManageLanguagePage manageLanguagePage = new BasicWorkFlow()\n                .goToHome()\n                .goToHomePage()\n                .goToAdministration()\n                .goToManageLanguagePage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .doesNotContain(language)\n                .as(\"The language is not listed\");\n\n        manageLanguagePage = manageLanguagePage\n                .clickMoreActions()\n                .addNewLanguage()\n                .enterSearchLanguage(language)\n                .disableLanguageByDefault()\n                .saveLanguage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .contains(language)\n                .as(\"The language is listed\");\n        assertThat(manageLanguagePage.languageIsEnabled(language))\n                .isFalse()\n                .as(\"The language is disabled by default\");\n\n        List<String> enabledLocaleList = manageLanguagePage.goToHomePage()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .waitForLocaleListVisible()\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(languageDisplayName)\n                .as(\"The language is disabled by default\");\n    }","id":38677,"modified_method":"@Feature(summary = \"The administrator can add a disabled language to Zanata\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 181709)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void addLanguageAsDisabled() throws Exception {\n        String language = \"Klingon\";\n        String languageDisplayName = \"klingon[Klingon]\";\n        ManageLanguagePage manageLanguagePage = new BasicWorkFlow()\n                .goToHome()\n                .goToHomePage()\n                .goToAdministration()\n                .goToManageLanguagePage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .doesNotContain(language)\n                .as(\"The language is not listed\");\n\n        manageLanguagePage = manageLanguagePage\n                .clickMoreActions()\n                .addNewLanguage()\n                .enterSearchLanguage(language)\n                .waitForPluralsWarning()\n                .disableLanguageByDefault()\n                .saveLanguage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .contains(language)\n                .as(\"The language is listed\");\n        assertThat(manageLanguagePage.languageIsEnabled(language))\n                .isFalse()\n                .as(\"The language is disabled by default\");\n\n        List<String> enabledLocaleList = manageLanguagePage.goToHomePage()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .waitForLocaleListVisible()\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .doesNotContain(languageDisplayName)\n                .as(\"The language is disabled by default\");\n    }","commit_id":"0e9518c4810f0eaa303db868f46ae04132401143","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The administrator can add a language to Zanata\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 181709)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void addLanguageAsEnabled() throws Exception {\n        String language = \"Goa'uld\";\n        String languageDisplayName = \"goa'uld[Goa'uld]\";\n        ManageLanguagePage manageLanguagePage = new BasicWorkFlow()\n                .goToHome()\n                .goToAdministration()\n                .goToManageLanguagePage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .doesNotContain(language)\n                .as(\"The language is not listed\");\n\n        manageLanguagePage = manageLanguagePage\n                .clickMoreActions()\n                .addNewLanguage()\n                .enterSearchLanguage(language)\n                .saveLanguage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .contains(language)\n                .as(\"The language is listed\");\n\n        assertThat(manageLanguagePage.languageIsEnabled(language))\n                .isTrue()\n                .as(\"The language is enabled by default\");\n\n        List<String> enabledLocaleList = manageLanguagePage\n                .goToHomePage()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .waitForLocaleListVisible()\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(languageDisplayName)\n                .as(\"The language is enabled by default\");\n    }","id":38678,"modified_method":"@Feature(summary = \"The administrator can add a language to Zanata\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 181709)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void addLanguageAsEnabled() throws Exception {\n        String language = \"Goa'uld\";\n        String languageDisplayName = \"goa'uld[Goa'uld]\";\n        ManageLanguagePage manageLanguagePage = new BasicWorkFlow()\n                .goToHome()\n                .goToAdministration()\n                .goToManageLanguagePage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .doesNotContain(language)\n                .as(\"The language is not listed\");\n\n        manageLanguagePage = manageLanguagePage\n                .clickMoreActions()\n                .addNewLanguage()\n                .enterSearchLanguage(language)\n                .waitForPluralsWarning()\n                .saveLanguage();\n\n        assertThat(manageLanguagePage.getLanguageLocales())\n                .contains(language)\n                .as(\"The language is listed\");\n\n        assertThat(manageLanguagePage.languageIsEnabled(language))\n                .isTrue()\n                .as(\"The language is enabled by default\");\n\n        List<String> enabledLocaleList = manageLanguagePage\n                .goToHomePage()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .waitForLocaleListVisible()\n                .getEnabledLocaleList();\n\n        assertThat(enabledLocaleList)\n                .contains(languageDisplayName)\n                .as(\"The language is enabled by default\");\n    }","commit_id":"0e9518c4810f0eaa303db868f46ae04132401143","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean languageIsEnabled(String localeId) {\n        log.info(\"Query is language enabled {}\", localeId);\n        return findRowByLocale(localeId)\n                .findElements(By.className(\"i--cancel\"))\n                .size() > 0;\n    }","id":38679,"modified_method":"public boolean languageIsEnabled(String localeId) {\n        log.info(\"Query is language enabled {}\", localeId);\n        // Search for visibility of the disabled icon\n        for (WebElement langDisabled : findRowByLocale(localeId)\n                .findElements(disabledIcon)) {\n            if (langDisabled.isDisplayed()) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"0e9518c4810f0eaa303db868f46ae04132401143","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected static List<WebElement> getWebElements(\n\t\tWebDriver webDriver, String locator, String timeout) {\n\n\t\tif (timeout != null) {\n\t\t\tsetTimeoutImplicit(webDriver, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\treturn webDriver.findElements(getBy(locator));\n\t\t}\n\t\tfinally {\n\t\t\tif (timeout != null) {\n\t\t\t\tsetDefaultTimeoutImplicit(webDriver);\n\t\t\t}\n\t\t}\n\t}","id":38680,"modified_method":"protected static List<WebElement> getWebElements(\n\t\tWebDriver webDriver, String locator, String timeout) {\n\n\t\tif (timeout != null) {\n\t\t\tsetTimeoutImplicit(webDriver, timeout);\n\t\t}\n\n\t\ttry {\n\t\t\tList<WebElement> webElements = webDriver.findElements(\n\t\t\t\tgetBy(locator));\n\n\t\t\tList<WebElement> webElementWrappers = new ArrayList<>();\n\n\t\t\tif (webElements != null) {\n\t\t\t\tfor (WebElement webElement : webElements) {\n\t\t\t\t\twebElementWrappers.add(\n\t\t\t\t\t\tnew WebElementWrapper(locator, webElement));\n\t\t\t\t}\n\n\t\t\t\treturn webElementWrappers;\n\t\t\t}\n\n\t\t\treturn webElementWrappers;\n\t\t}\n\t\tfinally {\n\t\t\tif (timeout != null) {\n\t\t\t\tsetDefaultTimeoutImplicit(webDriver);\n\t\t\t}\n\t\t}\n\t}","commit_id":"48a58208b54b186d380ba2642b9595de9ae9998a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean sourceDocumentsContains(String document) {\n        gotoDocumentTab();\n        List<WebElement> documentList = getDriver()\n                .findElement(By.id(\"settings-document_form\"))\n                .findElement(By.tagName(\"ul\"))\n                .findElements(By.tagName(\"li\"));\n        for (WebElement tableRow : documentList) {\n            if (tableRow.findElement(By.tagName(\"label\"))\n                    .getText().contains(document)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":38681,"modified_method":"public boolean sourceDocumentsContains(String document) {\n\n        List<WebElement> documentLabelList =\n                getDriver()\n                        .findElement(By.id(\"settings-document_form\"))\n                        .findElement(By.tagName(\"ul\"))\n                        .findElements(\n                                By.xpath(\".//li/label[@class='form__checkbox__label']\"));\n        for (WebElement label : documentLabelList) {\n            if (label.getText().contains(document)) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"33c275cefe2008d45606c68be27e9b356d44eff6","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean sourceDocumentsContains(String document) {\n        gotoDocumentTab();\n        List<WebElement> documentList = getLanguageTabDocumentList();\n        for (WebElement tableRow : documentList) {\n            if (tableRow.getText().contains(document)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":38682,"modified_method":"public boolean sourceDocumentsContains(String document) {\n        gotoDocumentTab();\n        List<WebElement> documentList = getLanguageTabDocumentList();\n        for (final WebElement tableRow : documentList) {\n            if (tableRow.findElement(By.className(\"list__title\")).getText()\n                    .contains(document)) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"33c275cefe2008d45606c68be27e9b356d44eff6","url":"https://github.com/zanata/zanata-server"},{"original_method":"private List<WebElement> getLanguageTabDocumentList() {\n        waitForTenSec().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getDriver()\n                        .findElement(By.id(\"documents-document_list\"))\n                        .isDisplayed();\n            }\n        });\n\n        return getDriver().findElement(By.id(\"documents-document_list\"))\n                .findElements(By.tagName(\"li\"));\n    }","id":38683,"modified_method":"private List<WebElement> getLanguageTabDocumentList() {\n\n        waitForTenSec().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getDriver()\n                        .findElement(By.id(\"documents-document_list\"))\n                        .isDisplayed();\n            }\n        });\n\n        List<WebElement> rows =\n                getDriver().findElement(By.id(\"documents-document_list\"))\n                        .findElements(By.xpath(\"./li\"));\n        return rows;\n    }","commit_id":"33c275cefe2008d45606c68be27e9b356d44eff6","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void inlineCall(MethodNode node) {\n        generateClosuresBodies();\n\n        List<ParameterInfo> realParams = new ArrayList<ParameterInfo>(actualParameters);\n\n        putClosureParametersOnStack();\n\n        List<CapturedParamInfo> captured = getAllCaptured();\n\n        Parameters parameters = new Parameters(realParams, Parameters.shiftAndAddStubs(captured, realParams.size()));\n\n        InliningContext info =\n                new InliningContext(expressionMap, null, null, null, state,\n                                 codegen.getInlineNameGenerator().subGenerator(functionDescriptor.getName().asString()),\n                                 codegen.getContext(), call, Collections.<String, String>emptyMap());\n\n        MethodInliner inliner = new MethodInliner(node, parameters, info, null, new LambdaFieldRemapper(), isSameModule); //with captured\n\n        VarRemapper.ParamRemapper remapper = new VarRemapper.ParamRemapper(parameters, initialFrameSize);\n\n        inliner.doInline(codegen.v, remapper);\n    }","id":38684,"modified_method":"private InlineResult inlineCall(MethodNode node) {\n        generateClosuresBodies();\n\n        List<ParameterInfo> realParams = new ArrayList<ParameterInfo>(actualParameters);\n\n        putClosureParametersOnStack();\n\n        List<CapturedParamInfo> captured = getAllCaptured();\n\n        Parameters parameters = new Parameters(realParams, Parameters.shiftAndAddStubs(captured, realParams.size()));\n\n        InliningContext info =\n                new InliningContext(expressionMap, null, null, null, state,\n                                 codegen.getInlineNameGenerator().subGenerator(functionDescriptor.getName().asString()),\n                                 codegen.getContext(), call, Collections.<String, String>emptyMap(), false);\n\n        MethodInliner inliner = new MethodInliner(node, parameters, info, null, new LambdaFieldRemapper(), isSameModule); //with captured\n\n        VarRemapper.ParamRemapper remapper = new VarRemapper.ParamRemapper(parameters, initialFrameSize);\n\n        return inliner.doInline(codegen.v, remapper);\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void genCall(CallableMethod callableMethod, ResolvedCall<?> resolvedCall, int mask, ExpressionCodegen codegen) {\n        assert mask == 0 : \"Default method invocation couldn't be inlined \" + resolvedCall;\n\n        MethodNode node = null;\n\n        try {\n            node = createMethodNode(callableMethod);\n            inlineCall(node);\n        }\n        catch (CompilationException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            String text = getNodeText(node);\n            PsiElement element = BindingContextUtils.descriptorToDeclaration(bindingContext, this.codegen.getContext().getContextDescriptor());\n            throw new CompilationException(\"Couldn't inline method call '\" +\n                                       functionDescriptor.getName() +\n                                       \"' into \\n\" + (element != null ? element.getText() : \"null psi element \" + this.codegen.getContext().getContextDescriptor()) +\n                                       \"\\ncause: \" +\n                                       text, e, call.getCallElement());\n        }\n\n        leaveTemps();\n    }","id":38685,"modified_method":"@Override\n    public void genCall(CallableMethod callableMethod, ResolvedCall<?> resolvedCall, int mask, ExpressionCodegen codegen) {\n        assert mask == 0 : \"Default method invocation couldn't be inlined \" + resolvedCall;\n\n        MethodNode node = null;\n\n        try {\n            node = createMethodNode(callableMethod);\n            endCall(inlineCall(node));\n        }\n        catch (CompilationException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            String text = getNodeText(node);\n            PsiElement element = BindingContextUtils.descriptorToDeclaration(bindingContext, this.codegen.getContext().getContextDescriptor());\n            throw new CompilationException(\"Couldn't inline method call '\" +\n                                       functionDescriptor.getName() +\n                                       \"' into \\n\" + (element != null ? element.getText() : \"null psi element \" + this.codegen.getContext().getContextDescriptor()) +\n                                       \"\\ncause: \" +\n                                       text, e, call.getCallElement());\n        }\n\n\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InliningContext(\n            Map<Integer, LambdaInfo> map,\n            List<InvokeCall> accesses,\n            List<ConstructorInvocation> invocation,\n            VarRemapper remapper,\n            GenerationState state,\n            NameGenerator nameGenerator,\n            CodegenContext startContext,\n            Call call,\n            Map<String, String> typeMapping\n    ) {\n        expresssionMap = map;\n        invokeCalls = accesses;\n        constructorInvocation = invocation;\n        this.remapper = remapper;\n        this.state = state;\n        this.nameGenerator = nameGenerator;\n        this.startContext = startContext;\n        this.call = call;\n        this.typeMapping = typeMapping;\n    }","id":38686,"modified_method":"public InliningContext(\n            Map<Integer, LambdaInfo> map,\n            List<InvokeCall> accesses,\n            List<ConstructorInvocation> invocation,\n            VarRemapper remapper,\n            GenerationState state,\n            NameGenerator nameGenerator,\n            CodegenContext startContext,\n            Call call,\n            Map<String, String> typeMapping,\n            boolean isInliningLambda\n    ) {\n        expressionMap = map;\n        invokeCalls = accesses;\n        constructorInvocation = invocation;\n        this.remapper = remapper;\n        this.state = state;\n        this.nameGenerator = nameGenerator;\n        this.startContext = startContext;\n        this.call = call;\n        this.typeMapping = typeMapping;\n        this.isInliningLambda = isInliningLambda;\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public InliningContext subInline(NameGenerator generator, Map<String, String> additionalTypeMappings) {\n        HashMap<String, String> newTypeMappings = new HashMap<String, String>(typeMapping);\n        newTypeMappings.putAll(additionalTypeMappings);\n        return new InliningContext(expresssionMap, invokeCalls, constructorInvocation, remapper, state, generator, startContext, call,\n                                newTypeMappings);\n    }","id":38687,"modified_method":"public InliningContext subInline(NameGenerator generator, Map<String, String> additionalTypeMappings) {\n        return subInline(generator, additionalTypeMappings, isInliningLambda);\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void doTransform(ConstructorInvocation invocation) {\n        ClassBuilder classBuilder = createClassBuilder();\n\n        //TODO: public visibility for inline function\n        classBuilder.defineClass(null,\n                                 V1_6,\n                                 classAccess,\n                                 newLambdaType.getInternalName(),\n                                 signature,\n                                 superName,\n                                 interfaces\n        );\n        ParametersBuilder builder = ParametersBuilder.newBuilder();\n        Parameters parameters = getLambdaParameters(builder, invocation);\n\n        MethodVisitor invokeVisitor = newMethod(classBuilder, invoke);\n        RegeneratedLambdaFieldRemapper\n                remapper = new RegeneratedLambdaFieldRemapper(oldLambdaType.getInternalName(), newLambdaType.getInternalName(), parameters, invocation.getCapturedLambdasToInline());\n        MethodInliner inliner = new MethodInliner(invoke, parameters, info.subInline(info.nameGenerator.subGenerator(\"lambda\")), oldLambdaType,\n                                                  remapper, isSameModule);\n        inliner.doInline(invokeVisitor, new VarRemapper.ParamRemapper(parameters, 0), remapper, false);\n        invokeVisitor.visitMaxs(-1, -1);\n\n        generateConstructorAndFields(classBuilder, builder, invocation);\n\n        if (bridge != null) {\n            MethodVisitor invokeBridge = newMethod(classBuilder, bridge);\n            bridge.accept(new MethodVisitor(ASM4, invokeBridge) {\n                @Override\n                public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n                    if (owner.equals(oldLambdaType.getInternalName())) {\n                        super.visitMethodInsn(opcode, newLambdaType.getInternalName(), name, desc);\n                    } else {\n                        super.visitMethodInsn(opcode, owner, name, desc);\n                    }\n                }\n            });\n        }\n\n        classBuilder.done();\n\n        invocation.setNewLambdaType(newLambdaType);\n    }","id":38688,"modified_method":"public InlineResult doTransform(ConstructorInvocation invocation) {\n        ClassBuilder classBuilder = createClassBuilder();\n\n        //TODO: public visibility for inline function\n        classBuilder.defineClass(null,\n                                 V1_6,\n                                 classAccess,\n                                 newLambdaType.getInternalName(),\n                                 signature,\n                                 superName,\n                                 interfaces\n        );\n        ParametersBuilder builder = ParametersBuilder.newBuilder();\n        Parameters parameters = getLambdaParameters(builder, invocation);\n\n        MethodVisitor invokeVisitor = newMethod(classBuilder, invoke);\n        RegeneratedLambdaFieldRemapper\n                remapper = new RegeneratedLambdaFieldRemapper(oldLambdaType.getInternalName(), newLambdaType.getInternalName(), parameters, invocation.getCapturedLambdasToInline());\n        MethodInliner inliner = new MethodInliner(invoke, parameters, info.subInline(info.nameGenerator.subGenerator(\"lambda\")), oldLambdaType,\n                                                  remapper, isSameModule);\n        InlineResult result = inliner.doInline(invokeVisitor, new VarRemapper.ParamRemapper(parameters, 0), remapper, false);\n        invokeVisitor.visitMaxs(-1, -1);\n\n        generateConstructorAndFields(classBuilder, builder, invocation);\n\n        if (bridge != null) {\n            MethodVisitor invokeBridge = newMethod(classBuilder, bridge);\n            bridge.accept(new MethodVisitor(ASM4, invokeBridge) {\n                @Override\n                public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n                    if (owner.equals(oldLambdaType.getInternalName())) {\n                        super.visitMethodInsn(opcode, newLambdaType.getInternalName(), name, desc);\n                    } else {\n                        super.visitMethodInsn(opcode, owner, name, desc);\n                    }\n                }\n            });\n        }\n\n        classBuilder.done();\n\n        invocation.setNewLambdaType(newLambdaType);\n        return result;\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private MethodNode doInline(MethodNode node, final LambdaFieldRemapper capturedRemapper) {\n\n        final Deque<InvokeCall> currentInvokes = new LinkedList<InvokeCall>(invokeCalls);\n\n        MethodNode resultNode = new MethodNode(node.access, node.name, node.desc, node.signature, null);\n\n        final Iterator<ConstructorInvocation> iterator = constructorInvocations.iterator();\n\n        RemappingMethodAdapter remappingMethodAdapter = new RemappingMethodAdapter(resultNode.access, resultNode.desc, resultNode,\n                                                                                   new TypeRemapper(currentTypeMapping));\n\n        InlineAdapter inliner = new InlineAdapter(remappingMethodAdapter, parameters.totalSize()) {\n\n            private ConstructorInvocation invocation;\n            @Override\n            public void anew(Type type) {\n                if (isLambdaConstructorCall(type.getInternalName(), \"<init>\")) {\n                    invocation = iterator.next();\n\n                    if (invocation.shouldRegenerate()) {\n                        //TODO: need poping of type but what to do with local funs???\n                        Type newLambdaType = Type.getObjectType(parent.nameGenerator.genLambdaClassName());\n                        currentTypeMapping.put(invocation.getOwnerInternalName(), newLambdaType.getInternalName());\n                        LambdaTransformer transformer = new LambdaTransformer(invocation.getOwnerInternalName(),\n                                                                              parent.subInline(parent.nameGenerator, currentTypeMapping),\n                                                                              isSameModule, newLambdaType);\n\n                        transformer.doTransform(invocation);\n                    }\n                }\n\n                //in case of regenerated invocation type would be remapped to new one via remappingMethodAdapter\n                super.anew(type);\n            }\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n                if (/*INLINE_RUNTIME.equals(owner) &&*/ isInvokeOnLambda(owner, name)) { //TODO add method\n                    assert !currentInvokes.isEmpty();\n                    InvokeCall invokeCall = currentInvokes.remove();\n                    LambdaInfo info = invokeCall.lambdaInfo;\n\n                    if (info == null) {\n                        //noninlinable lambda\n                        super.visitMethodInsn(opcode, owner, name, desc);\n                        return;\n                    }\n\n                    int valueParamShift = getNextLocalIndex();//NB: don't inline cause it changes\n                    putStackValuesIntoLocals(info.getParamsWithoutCapturedValOrVar(), valueParamShift, this, desc);\n\n                    Parameters lambdaParameters = info.addAllParameters(capturedRemapper);\n\n                    setInlining(true);\n                    MethodInliner inliner = new MethodInliner(info.getNode(), lambdaParameters, parent.subInline(parent.nameGenerator.subGenerator(\"lambda\")), info.getLambdaClassType(),\n                                                              capturedRemapper, true /*cause all calls in same module as lambda*/);\n\n                    VarRemapper.ParamRemapper remapper = new VarRemapper.ParamRemapper(lambdaParameters, valueParamShift);\n                    inliner.doInline(this.mv, remapper); //TODO add skipped this and receiver\n\n                    //return value boxing/unboxing\n                    Method bridge = typeMapper.mapSignature(ClosureCodegen.getInvokeFunction(info.getFunctionDescriptor())).getAsmMethod();\n                    Method delegate = typeMapper.mapSignature(info.getFunctionDescriptor()).getAsmMethod();\n                    StackValue.onStack(delegate.getReturnType()).put(bridge.getReturnType(), this);\n                    setInlining(false);\n                }\n                else if (isLambdaConstructorCall(owner, name)) { //TODO add method\n                    assert invocation != null : \"<init> call not corresponds to new call\" + owner + \" \" + name;\n                    if (invocation.shouldRegenerate()) {\n                        //put additional captured parameters on stack\n                        List<CapturedParamInfo> recaptured = invocation.getAllRecapturedParameters();\n                        List<CapturedParamInfo> contextCaptured = MethodInliner.this.parameters.getCaptured();\n                        for (CapturedParamInfo capturedParamInfo : recaptured) {\n                            CapturedParamInfo result = null;\n                            for (CapturedParamInfo info : contextCaptured) {\n                                //TODO more sophisticated check\n                                if (info.getFieldName().equals(capturedParamInfo.getFieldName())) {\n                                    result = info;\n                                }\n                            }\n                            if (result == null) {\n                                throw new UnsupportedOperationException(\n                                        \"Unsupported operation: could not transform non-inline lambda inside inlined one: \" +\n                                        owner + \".\" + name);\n                            }\n                            super.visitVarInsn(capturedParamInfo.getType().getOpcode(Opcodes.ILOAD), result.getIndex());\n                        }\n                        super.visitMethodInsn(opcode, invocation.getNewLambdaType().getInternalName(), name, invocation.getNewConstructorDescriptor());\n                        invocation = null;\n                    } else {\n                        super.visitMethodInsn(opcode, changeOwnerForExternalPackage(owner, opcode), name, desc);\n                    }\n                }\n                else {\n                    super.visitMethodInsn(opcode, changeOwnerForExternalPackage(owner, opcode), name, desc);\n                }\n            }\n        };\n\n        node.accept(inliner);\n\n        return resultNode;\n    }","id":38689,"modified_method":"private MethodNode doInline(MethodNode node, final LambdaFieldRemapper capturedRemapper) {\n\n        final Deque<InvokeCall> currentInvokes = new LinkedList<InvokeCall>(invokeCalls);\n\n        MethodNode resultNode = new MethodNode(node.access, node.name, node.desc, node.signature, null);\n\n        final Iterator<ConstructorInvocation> iterator = constructorInvocations.iterator();\n\n        RemappingMethodAdapter remappingMethodAdapter = new RemappingMethodAdapter(resultNode.access, resultNode.desc, resultNode,\n                                                                                   new TypeRemapper(currentTypeMapping));\n\n        InlineAdapter inliner = new InlineAdapter(remappingMethodAdapter, parameters.totalSize()) {\n\n            private ConstructorInvocation invocation;\n            @Override\n            public void anew(Type type) {\n                if (isLambdaConstructorCall(type.getInternalName(), \"<init>\")) {\n                    invocation = iterator.next();\n\n                    if (invocation.shouldRegenerate()) {\n                        //TODO: need poping of type but what to do with local funs???\n                        Type newLambdaType = Type.getObjectType(parent.nameGenerator.genLambdaClassName());\n                        currentTypeMapping.put(invocation.getOwnerInternalName(), newLambdaType.getInternalName());\n                        LambdaTransformer transformer = new LambdaTransformer(invocation.getOwnerInternalName(),\n                                                                              parent.subInline(parent.nameGenerator, currentTypeMapping),\n                                                                              isSameModule, newLambdaType);\n\n                        transformer.doTransform(invocation);\n\n                        if (parent.isInliningLambda) {\n                            //this class is transformed and original not used so we should remove original one after inlining\n                            result.addClassToRemove(invocation.getOwnerInternalName());\n                        }\n                    }\n                }\n\n                //in case of regenerated invocation type would be remapped to new one via remappingMethodAdapter\n                super.anew(type);\n            }\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n                if (/*INLINE_RUNTIME.equals(owner) &&*/ isInvokeOnLambda(owner, name)) { //TODO add method\n                    assert !currentInvokes.isEmpty();\n                    InvokeCall invokeCall = currentInvokes.remove();\n                    LambdaInfo info = invokeCall.lambdaInfo;\n\n                    if (info == null) {\n                        //noninlinable lambda\n                        super.visitMethodInsn(opcode, owner, name, desc);\n                        return;\n                    }\n\n                    int valueParamShift = getNextLocalIndex();//NB: don't inline cause it changes\n                    putStackValuesIntoLocals(info.getParamsWithoutCapturedValOrVar(), valueParamShift, this, desc);\n\n                    Parameters lambdaParameters = info.addAllParameters(capturedRemapper);\n\n                    setInlining(true);\n                    MethodInliner inliner = new MethodInliner(info.getNode(), lambdaParameters, parent.subInlineLambda(\n                            parent.nameGenerator.subGenerator(\"lambda\")), info.getLambdaClassType(),\n                                                              capturedRemapper, true /*cause all calls in same module as lambda*/\n                    );\n\n                    VarRemapper.ParamRemapper remapper = new VarRemapper.ParamRemapper(lambdaParameters, valueParamShift);\n                    InlineResult lambdaResult = inliner.doInline(this.mv, remapper);//TODO add skipped this and receiver\n                    result.addAllClassesToRemove(lambdaResult);\n\n                    //return value boxing/unboxing\n                    Method bridge = typeMapper.mapSignature(ClosureCodegen.getInvokeFunction(info.getFunctionDescriptor())).getAsmMethod();\n                    Method delegate = typeMapper.mapSignature(info.getFunctionDescriptor()).getAsmMethod();\n                    StackValue.onStack(delegate.getReturnType()).put(bridge.getReturnType(), this);\n                    setInlining(false);\n                }\n                else if (isLambdaConstructorCall(owner, name)) { //TODO add method\n                    assert invocation != null : \"<init> call not corresponds to new call\" + owner + \" \" + name;\n                    if (invocation.shouldRegenerate()) {\n                        //put additional captured parameters on stack\n                        List<CapturedParamInfo> recaptured = invocation.getAllRecapturedParameters();\n                        List<CapturedParamInfo> contextCaptured = MethodInliner.this.parameters.getCaptured();\n                        for (CapturedParamInfo capturedParamInfo : recaptured) {\n                            CapturedParamInfo result = null;\n                            for (CapturedParamInfo info : contextCaptured) {\n                                //TODO more sophisticated check\n                                if (info.getFieldName().equals(capturedParamInfo.getFieldName())) {\n                                    result = info;\n                                }\n                            }\n                            if (result == null) {\n                                throw new UnsupportedOperationException(\n                                        \"Unsupported operation: could not transform non-inline lambda inside inlined one: \" +\n                                        owner + \".\" + name);\n                            }\n                            super.visitVarInsn(capturedParamInfo.getType().getOpcode(Opcodes.ILOAD), result.getIndex());\n                        }\n                        super.visitMethodInsn(opcode, invocation.getNewLambdaType().getInternalName(), name, invocation.getNewConstructorDescriptor());\n                        invocation = null;\n                    } else {\n                        super.visitMethodInsn(opcode, changeOwnerForExternalPackage(owner, opcode), name, desc);\n                    }\n                }\n                else {\n                    super.visitMethodInsn(opcode, changeOwnerForExternalPackage(owner, opcode), name, desc);\n                }\n            }\n        };\n\n        node.accept(inliner);\n\n        return resultNode;\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void doInline(\n            MethodVisitor adapter,\n            VarRemapper.ParamRemapper remapper,\n            LambdaFieldRemapper capturedRemapper, boolean remapReturn\n    ) {\n        //analyze body\n        MethodNode transformedNode = node;\n        try {\n            transformedNode = markPlacesForInlineAndRemoveInlinable(transformedNode);\n        }\n        catch (AnalyzerException e) {\n            throw UtilsPackage.rethrow(e);\n        }\n\n        transformedNode = doInline(transformedNode, capturedRemapper);\n        removeClosureAssertions(transformedNode);\n        transformedNode.instructions.resetLabels();\n\n        Label end = new Label();\n        RemapVisitor visitor = new RemapVisitor(adapter, end, remapper, remapReturn);\n        transformedNode.accept(visitor);\n        visitor.visitLabel(end);\n\n    }","id":38690,"modified_method":"public InlineResult doInline(\n            MethodVisitor adapter,\n            VarRemapper.ParamRemapper remapper,\n            LambdaFieldRemapper capturedRemapper, boolean remapReturn\n    ) {\n        //analyze body\n        MethodNode transformedNode = node;\n        try {\n            transformedNode = markPlacesForInlineAndRemoveInlinable(transformedNode);\n        }\n        catch (AnalyzerException e) {\n            throw UtilsPackage.rethrow(e);\n        }\n\n        transformedNode = doInline(transformedNode, capturedRemapper);\n        removeClosureAssertions(transformedNode);\n        transformedNode.instructions.resetLabels();\n\n        Label end = new Label();\n        RemapVisitor visitor = new RemapVisitor(adapter, end, remapper, remapReturn);\n        transformedNode.accept(visitor);\n        visitor.visitLabel(end);\n\n        return result;\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void doInline(MethodVisitor adapter, VarRemapper.ParamRemapper remapper) {\n        doInline(adapter, remapper, new LambdaFieldRemapper(), true);\n    }","id":38691,"modified_method":"public InlineResult doInline(MethodVisitor adapter, VarRemapper.ParamRemapper remapper) {\n        return doInline(adapter, remapper, new LambdaFieldRemapper(), true);\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public MethodInliner(\n            @NotNull MethodNode node,\n            @NotNull Parameters parameters,\n            @NotNull InliningContext parent,\n            @Nullable Type lambdaType,\n            LambdaFieldRemapper lambdaFieldRemapper,\n            boolean isSameModule\n    ) {\n        this.node = node;\n        this.parameters = parameters;\n        this.parent = parent;\n        this.lambdaType = lambdaType;\n        this.lambdaFieldRemapper = lambdaFieldRemapper;\n        this.isSameModule = isSameModule;\n        this.typeMapper = parent.state.getTypeMapper();\n    }","id":38692,"modified_method":"public MethodInliner(\n            @NotNull MethodNode node,\n            @NotNull Parameters parameters,\n            @NotNull InliningContext parent,\n            @Nullable Type lambdaType,\n            LambdaFieldRemapper lambdaFieldRemapper,\n            boolean isSameModule\n    ) {\n        this.node = node;\n        this.parameters = parameters;\n        this.parent = parent;\n        this.lambdaType = lambdaType;\n        this.lambdaFieldRemapper = lambdaFieldRemapper;\n        this.isSameModule = isSameModule;\n        this.typeMapper = parent.state.getTypeMapper();\n        this.result = InlineResult.create();\n    }","commit_id":"00764d0ae176b2a9e0395f46cd1ec926767d62e5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n         * Creates a comparator that will resolve the {@link CmsResource} related values with the given macro\n         * expression.\n         * <p>\n         * \n         * @param cms will be cloned and used for macro - resolution\n         * @param comparatorMacro the macro to use to find the resource related strings to compare.\n         * \n         * @throws CmsException if something goes wrong\n         * \n         * @see CmsMacroResolver\n         */\n        CmsResourceSelectWidgetOptionComparator(CmsObject cms, String comparatorMacro)\n        throws CmsException {\n\n            if (CmsStringUtil.isEmpty(comparatorMacro)) {\n                m_comparatorMacro = I_CmsMacroResolver.MACRO_DELIMITER\n                    + \"\"\n                    + I_CmsMacroResolver.MACRO_START\n                    + \"opencms.filename)\";\n            } else {\n                m_comparatorMacro = comparatorMacro;\n            }\n            m_macroCmsObjectInner = OpenCms.initCmsObject(cms);\n            m_macroCmsObjectInner.getRequestContext().setSiteRoot(\"/\");\n            m_macroResolverInner = new CmsMacroResolver();\n            m_macroResolverInner.setCmsObject(m_macroCmsObjectInner);\n        }","id":38693,"modified_method":"/**\n         * Creates a comparator that will resolve the {@link CmsResource} related values with the given macro\n         * expression.\n         * <p>\n         * \n         * @param cms\n         *            will be cloned and used for macro - resolvation.\n         * \n         * @param comparatorMacro\n         *            the macro to use to find the resource related strings to compare.\n         * \n         * @throws CmsException\n         *             if sth. goes wrong.\n         * \n         * @see CmsMacroResolver\n         */\n        CmsResourceSelectWidgetOptionComparator(CmsObject cms, String comparatorMacro)\n        throws CmsException {\n\n            if (CmsStringUtil.isEmpty(comparatorMacro)) {\n                m_comparatorMacro = \"%(opencms.filename)\";\n            } else {\n                m_comparatorMacro = comparatorMacro;\n            }\n            m_macroCmsObjectInner = OpenCms.initCmsObject(cms);\n            m_macroCmsObjectInner.getRequestContext().setSiteRoot(\"/\");\n            m_macroResolverInner = new CmsMacroResolver();\n            m_macroResolverInner.setCmsObject(m_macroCmsObjectInner);\n        }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)\n         */\n        public int compare(Object o1, Object o2) {\n\n            CmsResourceSelectWidgetOption option1 = (CmsResourceSelectWidgetOption)o1;\n            CmsResourceSelectWidgetOption option2 = (CmsResourceSelectWidgetOption)o2;\n            CmsResource resource1 = option1.getResource();\n            CmsResource resource2 = option2.getResource();\n\n            String sort1, sort2;\n\n            // fool the macro resolver:\n            CmsRequestContext requestContext = m_macroCmsObjectInner.getRequestContext();\n            requestContext.setUri(resource1.getRootPath());\n            // implant the resource name for macro \"%(opencms.filename):\n            m_macroResolverInner.setResourceName(resource1.getName());\n            sort1 = m_macroResolverInner.resolveMacros(m_comparatorMacro);\n            requestContext.setUri(resource2.getRootPath());\n            m_macroResolverInner.setResourceName(resource2.getName());\n            sort2 = m_macroResolverInner.resolveMacros(m_comparatorMacro);\n            return sort1.compareTo(sort2);\n        }","id":38694,"modified_method":"/**\n         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)\n         */\n        public int compare(Object option1, Object option2) {\n\n            CmsResourceSelectWidgetOption op1 = (CmsResourceSelectWidgetOption)option1;\n            CmsResourceSelectWidgetOption op2 = (CmsResourceSelectWidgetOption)option2;\n\n            CmsResource resource1 = op1.getResource();\n            CmsResource resource2 = op2.getResource();\n\n            String sort1, sort2;\n\n            // fool the macro resolver:\n            CmsRequestContext requestContext = m_macroCmsObjectInner.getRequestContext();\n            requestContext.setUri(resource1.getRootPath());\n            // implant the resource name for macro \"%(opencms.filename}):\n            m_macroResolverInner.setResourceName(resource1.getName());\n            sort1 = m_macroResolverInner.resolveMacros(m_comparatorMacro);\n            requestContext.setUri(resource2.getRootPath());\n            m_macroResolverInner.setResourceName(resource2.getName());\n            sort2 = m_macroResolverInner.resolveMacros(m_comparatorMacro);\n            return sort1.compareTo(sort2);\n        }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Creates a select option with the resource to select, the resource's name as the display text and no help text\n         * that is potentially the default selection (argument isDefault).<p>\n         * \n         * @param resource the resource of this selection\n         * @param isDefault true, if this option is the default option (preselected)\n         * \n         */\n        public CmsResourceSelectWidgetOption(CmsResource resource, boolean isDefault) {\n\n            this(resource, isDefault, resource.getName());\n\n        }","id":38695,"modified_method":"/**\n         * Creates a select option with the resource to select, the resource's name as the display text and no help text\n         * that is potentially the default selection (argument isDefault).\n         * <p>\n         * \n         * @param cms\n         *            needed to remove the site root from the resource path.\n         * \n         * @param resource\n         *            The resource of this selection.\n         * \n         * @param isDefault\n         *            true, if this option is the default option (preselected.\n         * \n         */\n        public CmsResourceSelectWidgetOption(CmsObject cms, CmsResource resource, boolean isDefault) {\n\n            this(cms, resource, isDefault, resource.getName());\n\n        }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Creates a select option with the resource to select, the given optionText as the display text and the given\n         * help text that is potentially the default selection (argument isDefault).\n         * <p>\n         * \n         * @param resource the resource of this selection\n         * @param isDefault true, if this option is the default option (preselected)\n         * @param optionText the text to display for this option\n         * @param helpText the help text to display\n         */\n        public CmsResourceSelectWidgetOption(CmsResource resource, boolean isDefault, String optionText, String helpText) {\n\n            super(resource.getRootPath(), isDefault, optionText, helpText);\n            m_resource = resource;\n\n        }","id":38696,"modified_method":"/**\n         * Creates a select option with the resource to select, the given optionText as the display text and the given\n         * help text that is potentially the default selection (argument isDefault).\n         * <p>\n         * \n         * @param cms\n         *            needed to remove the site root from the resource path.\n         * \n         * @param resource\n         *            The resource of this selection.\n         * \n         * @param isDefault\n         *            true, if this option is the default option (preselected.\n         * \n         * @param optionText\n         *            the text to display for this option.\n         * \n         * @param helpText\n         *            The help text to display.\n         */\n        public CmsResourceSelectWidgetOption(\n            CmsObject cms,\n            CmsResource resource,\n            boolean isDefault,\n            String optionText,\n            String helpText) {\n\n            super(cms.getRequestContext().removeSiteRoot(resource.getRootPath()), isDefault, optionText, helpText);\n            m_resource = resource;\n\n        }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Parses the configuration and puts it to the member variables.\n     * <p>\n     * \n     * Only invoked if options were not parsed before in this instance.\n     * <p>\n     * \n     * @param configuration\n     *            the configuration (with resolved macros).\n     * \n     * @param cms\n     *            needed to read the resource folder to use.\n     * \n     * @param param\n     *            allows to access the resource currently being rendered.\n     * \n     * \n     * @throws CmsIllegalArgumentException\n     *             if the configuration is invalid.\n     * \n     */\n    private void parseConfigurationInternal(String configuration, CmsObject cms, I_CmsWidgetParameter param) {\n\n        // prepare for macro resolvation of property value against the resource currently\n        // rendered\n        // implant the uri to the special cms object for resolving macros from the\n        // collected xml contents:\n        CmsFile file = ((I_CmsXmlContentValue)param).getDocument().getFile();\n        m_macroCmsObject.getRequestContext().setUri(file.getRootPath());\n        List mappings = CmsStringUtil.splitAsList(configuration, '|');\n        Iterator itMappings = mappings.iterator();\n        String mapping;\n        String[] keyValue;\n        String key;\n        String value;\n        boolean displayMacroFound = false, sortMacroFound = false, folderFound = false, typeFound = false;\n        while (itMappings.hasNext()) {\n            mapping = (String)itMappings.next();\n            keyValue = CmsStringUtil.splitAsArray(mapping, '=');\n            if (keyValue.length != 2) {\n                throw new CmsIllegalArgumentException(Messages.get().container(\n                    Messages.ERR_SELECTWIDGET_CONFIGURATION_KEYVALUE_LENGTH_1,\n                    mapping));\n            }\n            key = keyValue[0].trim();\n            value = keyValue[1].trim();\n\n            // implant the resource for macro \"%(opencms.filename)\"\n            m_macroResolver.setResourceName(file.getName());\n            // check key\n            if (CONFIGURATION_OPTION_DISPLAY_MACRO.equals(key)) {\n                if (displayMacroFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n\n                m_displayOptionMacro = value;\n                displayMacroFound = true;\n            } else if (CONFIGURATION_OPTION_SORT_MACRO.equals(key)) {\n                if (sortMacroFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n                m_sortMacro = value;\n                sortMacroFound = true;\n\n            } else if (CONFIGURATION_RESOURCETYPENAME.equals(key)) {\n                if (typeFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n                // check if resource type name is OK\n                // if setResourceType will be implemented copy here and invoke that one\n                try {\n                    m_resourceTypeID = OpenCms.getResourceManager().getResourceType(value).getTypeId();\n                } catch (CmsLoaderException e) {\n                    throw new CmsIllegalArgumentException(org.opencms.file.Messages.get().container(\n                        org.opencms.file.Messages.ERR_UNKNOWN_RESOURCE_TYPE_1,\n                        value), e);\n                }\n                typeFound = true;\n\n            } else if (CONFIGURATION_TOPFOLDER.equals(key)) {\n                if (folderFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n\n                // allow collector path to contain macros relative to the current resource:\n                value = m_macroResolver.resolveMacros(value);\n\n                try {\n                    CmsRequestContext context = cms.getRequestContext();\n                    String oldSiteRoot = context.getSiteRoot();\n                    context.setSiteRoot(\"/\");\n                    CmsResource resource = cms.readResource(value);\n                    context.setSiteRoot(oldSiteRoot);\n                    if (resource.isFile()) {\n                        throw new CmsIllegalArgumentException(Messages.get().container(\n                            Messages.ERR_SELECTWIDGET_CONFIGURATION_RESOURCE_NOFOLDER_2,\n                            value,\n                            configuration));\n                    }\n                    m_resourceFolder = resource;\n                } catch (CmsException e) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_RESOURCE_INVALID_2,\n                        value,\n                        configuration), e);\n                }\n\n                folderFound = true;\n            } else {\n                // a property=value definition???\n\n                CmsPropertyDefinition propDef;\n                try {\n                    propDef = cms.readPropertyDefinition(key);\n                } catch (CmsException e) {\n\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_UNKNOWN_2,\n                        key,\n                        getClass().getName()), e);\n                }\n                if (propDef != null) {\n                    // a valid property - value combination to filter resources for:\n                    // value is potentially a macro that will be compared to the current xml content\n                    // resource!\n                    value = m_macroResolver.resolveMacros(value);\n                    m_filterProperties.put(key, value);\n\n                } else {\n\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_UNKNOWN_2,\n                        key,\n                        getClass().getName()));\n                }\n            }\n        }\n\n        // final check wether all has been set\n        if (!displayMacroFound) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_MISSING_3,\n                CONFIGURATION_OPTION_DISPLAY_MACRO,\n                configuration,\n                getClass().getName()));\n        }\n        if (!folderFound) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_MISSING_3,\n                CONFIGURATION_TOPFOLDER,\n                configuration,\n                getClass().getName()));\n        }\n        if (!typeFound) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_MISSING_3,\n                CONFIGURATION_RESOURCETYPENAME,\n                configuration,\n                getClass().getName()));\n        }\n    }","id":38697,"modified_method":"/**\n     * Parses the configuration and puts it to the member variables.\n     * <p>\n     * \n     * Only invoked if options were not parsed before in this instance.\n     * <p>\n     * \n     * @param configuration\n     *            the configuration (with resolved macros).\n     * \n     * @param cms\n     *            needed to read the resource folder to use.\n     * \n     * @param param\n     *            allows to access the resource currently being rendered.\n     * \n     * \n     * @throws CmsIllegalArgumentException\n     *             if the configuration is invalid.\n     * \n     */\n    private void parseConfigurationInternal(String configuration, CmsObject cms, I_CmsWidgetParameter param) {\n\n        // prepare for macro resolvation of property value against the resource currently\n        // rendered implant the uri to the special cms object for resolving macros from the\n        // collected xml contents:\n        CmsFile file = ((I_CmsXmlContentValue)param).getDocument().getFile();\n        m_macroCmsObject.getRequestContext().setUri(file.getRootPath());\n        List mappings = CmsStringUtil.splitAsList(configuration, '|');\n        Iterator itMappings = mappings.iterator();\n        String mapping;\n        String[] keyValue;\n        String key;\n        String value;\n        boolean displayMacroFound = false, sortMacroFound = false, folderFound = false, typeFound = false;\n        LOG.info(\"Setting macro %(currentsite) to: \" + cms.getRequestContext().getSiteRoot());\n        m_macroResolver.addMacro(MACROKEY_CURRENT_SITE, cms.getRequestContext().getSiteRoot());\n        while (itMappings.hasNext()) {\n            mapping = (String)itMappings.next();\n            keyValue = CmsStringUtil.splitAsArray(mapping, '=');\n            if (keyValue.length != 2) {\n                throw new CmsIllegalArgumentException(Messages.get().container(\n                    Messages.ERR_SELECTWIDGET_CONFIGURATION_KEYVALUE_LENGTH_1,\n                    mapping));\n            }\n            key = keyValue[0].trim();\n            value = keyValue[1].trim();\n\n            // implant the resource for macro \"%(opencms.filename)\"\n            m_macroResolver.setResourceName(file.getName());\n            // check key\n            if (CONFIGURATION_OPTION_DISPLAY_MACRO.equals(key)) {\n                if (displayMacroFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n\n                m_displayOptionMacro = value;\n                displayMacroFound = true;\n            } else if (CONFIGURATION_OPTION_SORT_MACRO.equals(key)) {\n                if (sortMacroFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n                m_sortMacro = value;\n                sortMacroFound = true;\n\n            } else if (CONFIGURATION_RESOURCETYPENAME.equals(key)) {\n                if (typeFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n                // check if resource type name is OK\n                // if setResourceType will be implemented copy here and invoke that one\n                String resType = \"n/a\";\n                try {\n                    this.m_resourceTypeIDs = new LinkedList();\n                    List types = CmsStringUtil.splitAsList(value, ',');\n                    Iterator itTypes = types.iterator();\n                    while (itTypes.hasNext()) {\n                        resType = (String)itTypes.next();\n                        this.m_resourceTypeIDs.add(new Integer(\n                            OpenCms.getResourceManager().getResourceType(resType).getTypeId()));\n                    }\n                } catch (CmsLoaderException e) {\n                    throw new CmsIllegalArgumentException(org.opencms.file.Messages.get().container(\n                        org.opencms.file.Messages.ERR_UNKNOWN_RESOURCE_TYPE_1,\n                        resType), e);\n                }\n                typeFound = true;\n\n            } else if (CONFIGURATION_TOPFOLDER.equals(key)) {\n                if (folderFound) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_DUPLICATE_2,\n                        key,\n                        configuration));\n                }\n\n                // allow collector path to contain macros relative to the current resource:\n                value = m_macroResolver.resolveMacros(value);\n\n                try {\n                    CmsRequestContext context = cms.getRequestContext();\n                    String oldSiteRoot = context.getSiteRoot();\n                    context.setSiteRoot(\"/\");\n                    CmsResource resource = cms.readResource(value);\n                    context.setSiteRoot(oldSiteRoot);\n                    if (resource.isFile()) {\n                        throw new CmsIllegalArgumentException(Messages.get().container(\n                            Messages.ERR_SELECTWIDGET_CONFIGURATION_RESOURCE_NOFOLDER_2,\n                            value,\n                            configuration));\n                    }\n                    m_resourceFolder = resource;\n                } catch (CmsException e) {\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_RESOURCE_INVALID_2,\n                        value,\n                        configuration), e);\n                }\n\n                folderFound = true;\n            } else if (CONFIGURATION_IGNORE_LOCALE_MATCH.equals(key)) {\n                m_ignoreLocaleMatching = Boolean.valueOf(value).booleanValue();\n\n            } else {\n                // a property=value definition???\n\n                CmsPropertyDefinition propDef;\n                try {\n                    propDef = cms.readPropertyDefinition(key);\n                } catch (CmsException e) {\n\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_UNKNOWN_2,\n                        key,\n                        getClass().getName()), e);\n                }\n                if (propDef != null) {\n                    // a valid property - value combination to filter resources for:\n                    // value is potentially a macro that will be compared to the current xml content\n                    // resource!\n                    value = m_macroResolver.resolveMacros(value);\n                    m_filterProperties.put(key, value);\n\n                } else {\n\n                    throw new CmsIllegalArgumentException(Messages.get().container(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_UNKNOWN_2,\n                        key,\n                        getClass().getName()));\n                }\n            }\n        }\n\n        // final check wether all has been set\n        if (!displayMacroFound) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_MISSING_3,\n                CONFIGURATION_OPTION_DISPLAY_MACRO,\n                configuration,\n                getClass().getName()));\n        }\n        if (!folderFound) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_MISSING_3,\n                CONFIGURATION_TOPFOLDER,\n                configuration,\n                getClass().getName()));\n        }\n        if (!typeFound) {\n            throw new CmsIllegalArgumentException(Messages.get().container(\n                Messages.ERR_SELECTWIDGET_CONFIGURATION_KEY_MISSING_3,\n                CONFIGURATION_RESOURCETYPENAME,\n                configuration,\n                getClass().getName()));\n        }\n    }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * \n     * Resolves xpath macros of the form <code>\"%(xpath.XPATHEXPRESSION)\"<\/code> by the field value of the XML content\n     * denoted by the given resource.\n     * <p>\n     * \n     * File laoding and unmarshalling is only done if the given String contains xpath macros.\n     * <p>\n     * \n     * @param cms\n     *            to access values in the cmsobject\n     * @param resource\n     *            the resource pointing to an xmlcontent containing the macro values to resolve\n     * @param value\n     *            the unresolved macro string\n     * \n     * @return a String with resolved xpath macros that have been read from the xmlcontent\n     * \n     * @throws CmsException\n     *             if somehting goes wrong\n     */\n    private String resolveXpathMacros(CmsObject cms, CmsResource resource, String value) throws CmsException {\n\n        StringBuffer result = new StringBuffer();\n        int startmacro = value.indexOf(I_CmsMacroResolver.MACRO_DELIMITER\n            + \"\"\n            + I_CmsMacroResolver.MACRO_START\n            + \"xpath.\");\n        int stopmacro = 0;\n        String xpath;\n        if (startmacro != -1) {\n\n            // for the option value we have to unmarshal...\n            CmsXmlContent xmlcontent = CmsXmlContentFactory.unmarshal(cms, cms.readFile(resource));\n            // we read the locale node of the xmlcontent instance matching the resources\n            // locale property (or top level locale).\n            Locale locale = CmsLocaleManager.getLocale(cms.readPropertyObject(\n                xmlcontent.getFile(),\n                CmsPropertyDefinition.PROPERTY_LOCALE,\n                true).getValue());\n\n            while (startmacro != -1) {\n                stopmacro = value.indexOf(I_CmsMacroResolver.MACRO_END);\n                if (stopmacro == 0) {\n                    // TODO: complain about missing closing macro bracket!\n                }\n\n                // first cut the prefix of the macro to put it to the result:\n                result.append(value.substring(0, startmacro));\n                // now replace the macro:\n                xpath = value.substring(startmacro + 8, stopmacro);\n                // Foreign languages will be invisible!!!\n                // List locales = content.getLocales();\n                // if (!locales.contains(locale)) {\n                // locale = (Locale)locales.get(0);\n                // }\n                try {\n                    result.append(xmlcontent.getValue(xpath, locale).getPlainText(cms));\n                } catch (Exception ex) {\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(Messages.get().getBundle().key(\n                            Messages.LOG_ERR_SELECTWIDGET_XPATH_INVALID_4,\n                            new Object[] {\n                                xpath,\n                                locale.toString(),\n                                xmlcontent.getFile().getRootPath(),\n                                ex.getLocalizedMessage()}));\n                    }\n                }\n                // skip over the consumed String of value:\n                value = value.substring(stopmacro + 1);\n\n                // take a new start for macro:\n                startmacro = value.indexOf(I_CmsMacroResolver.MACRO_DELIMITER\n                    + \"\"\n                    + I_CmsMacroResolver.MACRO_START\n                    + \"xpath.\");\n            }\n        }\n        // append trailing value\n        result.append(value);\n        return result.toString();\n    }","id":38698,"modified_method":"/**\n     * \n     * Resolves xpath macros of the form <code>\"%(xpath.XPATHEXPRESSION)\"<\/code> by the field value of the XML content\n     * denoted by the given resource.\n     * <p>\n     * \n     * File loading and unmarshalling is only done if the given String contains xpath macros.\n     * <p>\n     * \n     * @param cms\n     *            to access values in the cmsobject.\n     * \n     * @param resource\n     *            the resource pointing to an xmlcontent containing the macro values to resolve.\n     * \n     * @param value\n     *            the unresolved macro string.\n     * \n     * @return a String with resolved xpath macros that have been read from the xmlcontent.\n     * \n     * @throws CmsException\n     *             if sth. goes wrong\n     */\n    private String resolveXpathMacros(CmsObject cms, CmsResource resource, final String value) throws CmsException {\n\n        String work = value;\n        StringBuffer result = new StringBuffer();\n\n        String startMacro = new StringBuffer(I_CmsMacroResolver.MACRO_DELIMITER + \"\").append(\n            I_CmsMacroResolver.MACRO_START).append(\"xpath.\").toString();\n\n        int startmacroIndex = work.indexOf(startMacro);\n        int stopmacro = 0;\n        String xpath;\n        if (startmacroIndex != -1) {\n\n            // for the option value we have to unmarshal...\n            CmsXmlContent xmlcontent = CmsXmlContentFactory.unmarshal(cms, cms.readFile(resource));\n            // we read the locale node of the xmlcontent instance matching the resources\n            // locale property (or top level locale).\n            Locale locale = CmsLocaleManager.getLocale(cms.readPropertyObject(\n                xmlcontent.getFile(),\n                CmsPropertyDefinition.PROPERTY_LOCALE,\n                true).getValue());\n\n            while (startmacroIndex != -1) {\n                stopmacro = work.indexOf(I_CmsMacroResolver.MACRO_END);\n                if (stopmacro == 0) {\n                    // TODO: complain about missing closing macro bracket!\n                }\n\n                // first cut the prefix of the macro to put it to the result:\n                result.append(work.substring(0, startmacroIndex));\n                // now replace the macro:\n                xpath = work.substring(startmacroIndex + 8, stopmacro);\n                try {\n                    result.append(xmlcontent.getValue(xpath, locale).getPlainText(cms));\n                } catch (Exception ex) {\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(Messages.get().getBundle().key(\n                            Messages.LOG_ERR_SELECTWIDGET_XPATH_INVALID_4,\n                            new Object[] {\n                                xpath,\n                                locale.toString(),\n                                xmlcontent.getFile().getRootPath(),\n                                ex.getLocalizedMessage()}));\n                    }\n                }\n                // skip over the consumed String of value:\n                work = work.substring(stopmacro + 1);\n\n                // take a new start for macro:\n                startmacroIndex = work.indexOf(startMacro);\n            }\n        }\n        // append trailing value\n        result.append(work);\n        return result.toString();\n\n    }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the list of configured select options, parsing the configuration String if required.\n     * <p>\n     * \n     * @param cms the current users OpenCms context\n     * @param widgetDialog the dialog of this widget\n     * @param param the widget parameter of this dialog\n     * \n     * @see org.opencms.widgets.A_CmsSelectWidget#parseSelectOptions(org.opencms.file.CmsObject,\n     *      org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     * \n     * @return the list of configured select options.\n     * \n     * @throws CmsIllegalArgumentException if the \"folder\" property of the configuration does not denote a folder within the VFS\n     */\n    protected List parseSelectOptions(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param)\n    throws CmsIllegalArgumentException {\n\n        Locale dialogContentLocale = ((I_CmsXmlContentValue)param).getLocale();\n        Locale resourceLocale;\n        if (m_macroCmsObject == null) {\n            try {\n                m_macroCmsObject = OpenCms.initCmsObject(cms);\n                m_macroCmsObject.getRequestContext().setSiteRoot(\"/\");\n            } catch (CmsException e) {\n                // should never happen\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(Messages.get().getBundle().key(\n                        Messages.ERR_SELECTWIDGET_INTERNAL_CONFIGURATION_2,\n                        new Object[] {getClass().getName(), getConfiguration()}));\n                }\n                return Collections.EMPTY_LIST;\n\n            }\n        }\n        if (m_macroResolver == null) {\n            m_macroResolver = new CmsMacroResolver();\n            m_macroResolver.setCmsObject(m_macroCmsObject);\n            m_macroResolver.setKeepEmptyMacros(true);\n        }\n\n        List selectOptions = getSelectOptions();\n        if (selectOptions == null) {\n            String configuration = getConfiguration();\n            if (configuration == null) {\n                // workaround: use the default value to parse the options\n                configuration = param.getDefault(cms);\n            }\n            try {\n                // parse configuration to members\n                parseConfigurationInternal(configuration, cms, param);\n\n                // build the set of sorted options\n                SortedSet sortOptions = new TreeSet(new CmsResourceSelectWidgetOptionComparator(\n                    m_macroCmsObject,\n                    m_sortMacro));\n                CmsSelectWidgetOption option;\n                List resources;\n                // collect all subresources of resource folder\n                CmsResourceFilter filter = CmsResourceFilter.DEFAULT.addRequireType(getResourceTypeID());\n                CmsRequestContext context = cms.getRequestContext();\n                String oldSiteroot = context.getSiteRoot();\n                context.setSiteRoot(\"/\");\n                resources = cms.readResources(m_resourceFolder.getRootPath(), filter, true);\n                context.setSiteRoot(oldSiteroot);\n                if (resources.size() == 0) {\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(Messages.get().getBundle().key(\n                            Messages.LOG_ERR_SELECTWIDGET_NO_RESOURCES_FOUND_3,\n                            configuration,\n                            m_resourceFolder.getRootPath(),\n                            OpenCms.getResourceManager().getResourceType(getResourceTypeID()).getTypeName()));\n                    }\n                }\n\n                Iterator itResources = resources.iterator();\n                CmsResource resource;\n\n                String displayName;\n                // inner loop vars :\n                while (itResources.hasNext()) {\n\n                    resource = (CmsResource)itResources.next();\n                    // don't make resources selectable that have a different locale than the current editor language.\n                    // we read the locale node of the xmlcontent instance matching the resources\n                    // locale property (or top level locale).\n                    resourceLocale = CmsLocaleManager.getLocale(cms.readPropertyObject(\n                        resource,\n                        CmsPropertyDefinition.PROPERTY_LOCALE,\n                        true).getValue());\n\n                    // Only show select options for resources that are in the same locale as the current\n                    // editor locale (e.g. when switching to german, offer the german siblings)\n                    if (dialogContentLocale.equals(resourceLocale)) {\n                        // macro resolvation within hasFilterProperty will resolve values to the\n                        // current request\n                        if (hasFilterProperty(resource, cms)) {\n\n                            // implant the uri to the special cms object for resolving macros from\n                            // the collected xml contents:\n                            m_macroCmsObject.getRequestContext().setUri(resource.getRootPath());\n                            // implant the resource for macro \"%(opencms.filename)\"\n                            m_macroResolver.setResourceName(resource.getName());\n                            // implant the messages\n                            m_macroResolver.setMessages(widgetDialog.getMessages());\n                            // filter out unwanted resources - if no filter properties are defined,\n                            // every resource collected here is ok:\n                            displayName = m_macroResolver.resolveMacros(getDisplayOptionMacro());\n                            // deal with a bug of the macro resolver: it will return \"\" if it gets\n                            // \"%(unknown.thing)\":\n                            if (CmsStringUtil.isEmptyOrWhitespaceOnly(displayName)) {\n                                // it was a \"%(xpath.field)\" expression only and swallowed by macro\n                                // resolver:\n                                displayName = resolveXpathMacros(cms, resource, getDisplayOptionMacro());\n                            } else {\n                                // there was more than one xpath macro: allow further replacements\n                                // within partly resolved macro:\n                                displayName = resolveXpathMacros(cms, resource, displayName);\n                            }\n                            // final check:\n                            if (CmsStringUtil.isEmpty(displayName)) {\n                                displayName = resource.getName();\n                            }\n\n                            displayName = resolveXpathMacros(cms, resource, displayName);\n\n                            if (!CmsStringUtil.isEmpty(displayName)) {\n\n                                // now everything required is there:\n                                option = new CmsResourceSelectWidgetOption(resource, false, displayName);\n                                sortOptions.add(option);\n                            }\n                        }\n                    }\n                }\n                selectOptions = new LinkedList(sortOptions);\n\n            } catch (Exception e) {\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(Messages.get().getBundle().key(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_2,\n                        getClass(),\n                        configuration), e);\n                }\n            }\n\n            if ((selectOptions == Collections.EMPTY_LIST) || (selectOptions == null)) {\n                selectOptions = new ArrayList();\n            }\n\n            // no method to add the parsed option list....\n            // Caution: if it is decided to return a copy of the list we are doomed unless\n            // setSelectOptions is set to protected!\n            List pOptions = getSelectOptions();\n            if (pOptions != null) {\n                pOptions.clear();\n            }\n            Iterator it = selectOptions.iterator();\n            while (it.hasNext()) {\n                addSelectOption((CmsSelectWidgetOption)it.next());\n            }\n        }\n\n        return selectOptions;\n    }","id":38699,"modified_method":"/**\n     * Returns the list of configured select options, parsing the configuration String if required.\n     * <p>\n     * \n     * @param cms\n     *            the current users OpenCms context.\n     * \n     * @param widgetDialog\n     *            the dialog of this widget.\n     * \n     * @param param\n     *            the widget parameter of this dialog.\n     * \n     * @see org.opencms.widgets.A_CmsSelectWidget#parseSelectOptions(org.opencms.file.CmsObject,\n     *      org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     * \n     * @return the list of configured select options.\n     * \n     * @throws CmsIllegalArgumentException\n     *             if the \"folder\" property of the configuration does not denote a folder within the VFS.\n     */\n    protected List parseSelectOptions(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param)\n    throws CmsIllegalArgumentException {\n\n        Locale dialogContentLocale = ((I_CmsXmlContentValue)param).getLocale();\n        Locale resourceLocale;\n        if (m_macroCmsObject == null) {\n            try {\n                m_macroCmsObject = OpenCms.initCmsObject(cms);\n                m_macroCmsObject.getRequestContext().setSiteRoot(\"/\");\n            } catch (CmsException e) {\n                // should never happen\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(Messages.get().getBundle().key(\n                        Messages.ERR_SELECTWIDGET_INTERNAL_CONFIGURATION_2,\n                        new Object[] {getClass().getName(), getConfiguration()}));\n                }\n                return Collections.EMPTY_LIST;\n\n            }\n        }\n        if (m_macroResolver == null) {\n            m_macroResolver = new CmsMacroResolver();\n            m_macroResolver.setCmsObject(m_macroCmsObject);\n            m_macroResolver.setKeepEmptyMacros(true);\n        }\n\n        List selectOptions = getSelectOptions();\n        if (selectOptions == null) {\n            String configuration = getConfiguration();\n            if (configuration == null) {\n                // workaround: use the default value to parse the options\n                configuration = param.getDefault(cms);\n            }\n            try {\n                // parse configuration to members\n                parseConfigurationInternal(configuration, cms, param);\n\n                // build the set of sorted options\n                SortedSet sortOptions = new TreeSet(new CmsResourceSelectWidgetOptionComparator(\n                    m_macroCmsObject,\n                    m_sortMacro));\n                CmsResourceSelectWidgetOption option;\n                List resources;\n                List allResources = new LinkedList();\n                // collect all subresources of resource folder.\n                // As a CmsResourceFilter is somewhat limited we have to do several reads\n                // for each resourceType we allow:\n                int resType;\n                Iterator itResTypes = this.m_resourceTypeIDs.iterator();\n                while (itResTypes.hasNext()) {\n                    resType = ((Integer)itResTypes.next()).intValue();\n                    CmsResourceFilter filter = CmsResourceFilter.ALL.addRequireType(resType);\n                    CmsRequestContext context = cms.getRequestContext();\n                    String oldSiteroot = context.getSiteRoot();\n                    context.setSiteRoot(\"/\");\n                    resources = cms.readResources(m_resourceFolder.getRootPath(), filter, true);\n                    context.setSiteRoot(oldSiteroot);\n                    if (resources.size() == 0) {\n                        if (LOG.isErrorEnabled()) {\n                            LOG.error(Messages.get().getBundle().key(\n                                Messages.LOG_ERR_SELECTWIDGET_NO_RESOURCES_FOUND_3,\n                                configuration,\n                                m_resourceFolder.getRootPath(),\n                                OpenCms.getResourceManager().getResourceType(resType).getTypeName()));\n                        }\n                    } else {\n                        allResources.addAll(resources);\n                    }\n\n                }\n\n                Iterator itResources = allResources.iterator();\n                CmsResource resource;\n\n                String displayName;\n                // inner loop vars :\n                while (itResources.hasNext()) {\n\n                    resource = (CmsResource)itResources.next();\n                    // don't make resources selectable that have a different locale than the\n                    // we read the locale node of the xmlcontent instance matching the resources\n                    // locale property (or top level locale).\n                    CmsProperty resourceLocaleProperty = cms.readPropertyObject(\n                        resource,\n                        CmsPropertyDefinition.PROPERTY_LOCALE,\n                        true);\n                    resourceLocale = CmsLocaleManager.getLocale(resourceLocaleProperty.getValue());\n\n                    // We allow all resources without locale property and only the\n                    // resources with locale property that match the current XML content editor locale.\n                    if (isIgnoreLocaleMatching()\n                        || ((resourceLocaleProperty.isNullProperty() && containsLocale(\n                            cms,\n                            resource,\n                            dialogContentLocale)) || dialogContentLocale.equals(resourceLocale))) {\n                        // macro resolvation within hasFilterProperty will resolve values to the\n                        // current request\n                        if (hasFilterProperty(resource, cms)) {\n\n                            // implant the uri to the special cms object for resolving macros from\n                            // the collected xml contents:\n                            m_macroCmsObject.getRequestContext().setUri(resource.getRootPath());\n                            // implant the resource for macro \"%(opencms.filename)\"\n                            m_macroResolver.setResourceName(resource.getName());\n                            // implant the messages\n                            m_macroResolver.setMessages(widgetDialog.getMessages());\n                            // filter out unwanted resources - if no filter properties are defined,\n                            // every\n                            // resource collected here is ok:\n                            displayName = m_macroResolver.resolveMacros(getDisplayOptionMacro());\n                            // deal with a bug of the macro resolver: it will return \"\" if it gets\n                            // \"%(unknown.thin)\":\n                            if (CmsStringUtil.isEmptyOrWhitespaceOnly(displayName)) {\n                                // it was a \"%(xpath.field})\" expression only and swallowed by macro\n                                // resolver:\n                                displayName = resolveXpathMacros(cms, resource, getDisplayOptionMacro());\n                            } else {\n                                // there was more than one xpath macro: allow further replacements\n                                // within partly resolved macro:\n                                displayName = resolveXpathMacros(cms, resource, displayName);\n                            }\n                            // final check:\n                            if (CmsStringUtil.isEmpty(displayName)) {\n                                displayName = resource.getName();\n                            }\n\n                            displayName = resolveXpathMacros(cms, resource, displayName);\n\n                            if (!CmsStringUtil.isEmpty(displayName)) {\n\n                                // now everything required is there:\n                                option = new CmsResourceSelectWidgetOption(cms, resource, false, displayName);\n                                sortOptions.add(option);\n                            }\n                        }\n                    }\n                }\n                selectOptions = new LinkedList(sortOptions);\n\n            } catch (Exception e) {\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(Messages.get().getBundle().key(\n                        Messages.ERR_SELECTWIDGET_CONFIGURATION_2,\n                        getClass(),\n                        configuration), e);\n                }\n            }\n\n            if (selectOptions == null || selectOptions == Collections.EMPTY_LIST) {\n                selectOptions = new ArrayList();\n            }\n\n            // no method to add the parsed option list....\n            // Caution: if it is decided to return a copy of the list we are doomed unless\n            // setSelectOptions is set to protected!\n            List pOptions = getSelectOptions();\n            if (pOptions != null) {\n                pOptions.clear();\n            }\n            Iterator it = selectOptions.iterator();\n            while (it.hasNext()) {\n                addSelectOption((CmsSelectWidgetOption)it.next());\n            }\n        }\n\n        return selectOptions;\n    }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Creates a non-default select option with the resource to select, the resource's name as the display text and\n         * no help text.\n         * <p>\n         * \n         * @param resource the resource of this selection\n         * \n         */\n        public CmsResourceSelectWidgetOption(CmsResource resource) {\n\n            this(resource, false);\n\n        }","id":38700,"modified_method":"/**\n         * Creates a non-default select option with the resource to select, the resource's name as the display text and\n         * no help text.\n         * <p>\n         * \n         * @param cms\n         *            needed to remove the site root from the resource path.\n         * \n         * @param resource\n         *            The resource of this selection.\n         * \n         */\n        public CmsResourceSelectWidgetOption(CmsObject cms, CmsResource resource) {\n\n            this(cms, resource, false);\n\n        }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the resource type id.\n     * <p>\n     * \n     * @return the resourceTypeID\n     */\n    public int getResourceTypeID() {\n\n        return m_resourceTypeID;\n    }","id":38701,"modified_method":"/**\n     * Returns the list of resource type ids (Integer).\n     * <p>\n     * \n     * @return the List of resource type ids\n     */\n    public List getResourceTypeIDs() {\n\n        return m_resourceTypeIDs;\n    }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * \n         * Creates a select option with the resource to select, the given optionText as the display text and no help\n         * text that is potentially the default selection (argument isDefault).\n         * <p>\n         * \n         * @param resource the resource of this selection\n         * @param isDefault true, if this option is the default option (preselected)\n         * @param optionText the text to display for this option\n         */\n        public CmsResourceSelectWidgetOption(CmsResource resource, boolean isDefault, String optionText) {\n\n            this(resource, isDefault, optionText, null);\n\n        }","id":38702,"modified_method":"/**\n         * \n         * Creates a select option with the resource to select, the given optionText as the display text and no help\n         * text that is potentially the default selection (argument isDefault).\n         * <p>\n         * \n         * @param cms\n         *            needed to remove the site root from the resource path.\n         * \n         * @param resource\n         *            The resource of this selection.\n         * \n         * @param isDefault\n         *            true, if this option is the default option (preselected.\n         * \n         * @param optionText\n         *            the text to display for this option.\n         */\n        public CmsResourceSelectWidgetOption(CmsObject cms, CmsResource resource, boolean isDefault, String optionText) {\n\n            this(cms, resource, isDefault, optionText, null);\n\n        }","commit_id":"0474b285e9f0ba843e5028f7fb6582cec7934e2b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new tab.<p>\n     * \n     * @param list list of items\n     * \n     * @return the created tab widget\n     */\n    public FlowPanel createTab(CmsList<? extends I_CmsListItem> list) {\n\n        FlowPanel tab = new FlowPanel();\n        tab.setStyleName(org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.tabbedPanelCss().tabPanel());\n        list.addStyleName(org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.generalCss().buttonCornerAll());\n        tab.add(list);\n        return tab;\n    }","id":38703,"modified_method":"/**\n     * Creates a new tab.<p>\n     * \n     * @param list list of items\n     * \n     * @return the created tab widget\n     */\n    public FlowPanel createTab(CmsList<? extends I_CmsListItem> list) {\n\n        FlowPanel tab = new FlowPanel();\n        tab.setStyleName(org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.tabbedPanelCss().tabPanel());\n        list.addStyleName(org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.generalCss().buttonCornerAll());\n        list.addStyleName(I_CmsLayoutBundle.INSTANCE.clipboardCss().clipboardList());\n        tab.add(list);\n        return tab;\n    }","commit_id":"d0637873ff6b9c022417dcfb8a943d40a91214b9","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Handles a dropped detail page.<p>\n     * \n     * @param createItem the detail page which was dropped into the sitemap \n     * @param parent the parent sitemap entry  \n     */\n    private void handleDropNewEntry(CmsCreatableListItem createItem, CmsClientSitemapEntry parent) {\n\n        CmsNewResourceInfo typeInfo = createItem.getResourceTypeInfo();\n        CmsNewResourceInfo defaultNew = m_controller.getData().getDefaultNewElementInfo();\n        CmsClientSitemapEntry entry = new CmsClientSitemapEntry();\n        String uniqueName = CmsSitemapController.ensureUniqueName(parent, typeInfo.getTypeName());\n        entry.setName(uniqueName);\n        entry.setSitePath(m_insertPath + uniqueName + \"/\");\n        entry.setNew(true);\n        entry.setVfsPath(null);\n        entry.setPosition(m_insertIndex);\n        entry.setInNavigation(true);\n        createItem.getResourceTypeInfo().getTypeName();\n        //TODO: handle redirects specially \n        entry.setResourceTypeName(\"folder\");\n\n        entry.setDefaultFileProperties(Collections.<String, CmsClientProperty> emptyMap());\n        if (NewEntryType.detailpage == createItem.getNewEntryType()) {\n            entry.setDetailpageTypeName(typeInfo.getTypeName());\n        }\n        if (NewEntryType.redirect == createItem.getNewEntryType()) {\n            entry.setEntryType(EntryType.redirect);\n            entry.setSitePath(m_insertPath + uniqueName);\n        } else {\n            entry.setSitePath(m_insertPath + uniqueName + \"/\");\n        }\n        int resourceTypeId;\n        if (typeInfo.getId() == m_controller.getData().getNewRedirectElementInfo().getId()) {\n            resourceTypeId = m_controller.getData().getNewRedirectElementInfo().getId();\n        } else {\n            resourceTypeId = defaultNew.getId();\n        }\n        m_controller.create(entry, resourceTypeId, defaultNew.getCopyResourceId());\n    }","id":38704,"modified_method":"/**\n     * Handles a dropped detail page.<p>\n     * \n     * @param createItem the detail page which was dropped into the sitemap \n     * @param parent the parent sitemap entry  \n     */\n    private void handleDropNewEntry(CmsCreatableListItem createItem, CmsClientSitemapEntry parent) {\n\n        CmsNewResourceInfo typeInfo = createItem.getResourceTypeInfo();\n        CmsClientSitemapEntry entry = new CmsClientSitemapEntry();\n        String uniqueName = CmsSitemapController.ensureUniqueName(parent, typeInfo.getTypeName());\n        entry.setName(uniqueName);\n        entry.setSitePath(m_insertPath + uniqueName + \"/\");\n        entry.setNew(true);\n        entry.setVfsPath(null);\n        entry.setPosition(m_insertIndex);\n        entry.setInNavigation(true);\n        createItem.getResourceTypeInfo().getTypeName();\n        //TODO: handle redirects specially \n        entry.setResourceTypeName(\"folder\");\n\n        entry.setDefaultFileProperties(Collections.<String, CmsClientProperty> emptyMap());\n        if (NewEntryType.detailpage == createItem.getNewEntryType()) {\n            entry.setDetailpageTypeName(typeInfo.getTypeName());\n        }\n        if (NewEntryType.redirect == createItem.getNewEntryType()) {\n            entry.setEntryType(EntryType.redirect);\n            entry.setSitePath(m_insertPath + uniqueName);\n        } else {\n            entry.setSitePath(m_insertPath + uniqueName + \"/\");\n        }\n        m_controller.create(entry, typeInfo.getId(), typeInfo.getCopyResourceId());\n    }","commit_id":"d0637873ff6b9c022417dcfb8a943d40a91214b9","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.sitemap.client.toolbar.A_CmsToolbarListMenuButton#initContent()\n     */\n    @Override\n    protected void initContent() {\n\n        CmsToolbarClipboardView view = new CmsToolbarClipboardView(this, getController());\n        FlowPanel modifiedTab = createTab(view.getModified());\n        view.getModified().addStyleName(I_CmsLayoutBundle.INSTANCE.clipboardCss().clipboardList());\n\n        modifiedTab.add(m_clearModified);\n        addTab(modifiedTab, Messages.get().key(Messages.GUI_CLIPBOARD_MODIFIED_TITLE_0));\n        FlowPanel deletedTab = createTab(view.getDeleted());\n        view.getDeleted().addStyleName(I_CmsLayoutBundle.INSTANCE.clipboardCss().clipboardList());\n\n        deletedTab.add(m_clearDeleted);\n        addTab(deletedTab, Messages.get().key(Messages.GUI_CLIPBOARD_DELETED_TITLE_0));\n    }","id":38705,"modified_method":"/**\n     * @see org.opencms.ade.sitemap.client.toolbar.A_CmsToolbarListMenuButton#initContent()\n     */\n    @Override\n    protected void initContent() {\n\n        CmsToolbarClipboardView view = new CmsToolbarClipboardView(this, getController());\n        FlowPanel modifiedTab = createTab(view.getModified());\n\n        modifiedTab.add(m_clearModified);\n        addTab(modifiedTab, Messages.get().key(Messages.GUI_CLIPBOARD_MODIFIED_TITLE_0));\n        FlowPanel deletedTab = createTab(view.getDeleted());\n\n        deletedTab.add(m_clearDeleted);\n        addTab(deletedTab, Messages.get().key(Messages.GUI_CLIPBOARD_DELETED_TITLE_0));\n    }","commit_id":"d0637873ff6b9c022417dcfb8a943d40a91214b9","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a resource type info bean for a given resource type.<p>\n     * \n     * @param resType the resource type\n     * @param copyResourceId the structure id of the copy resource\n     *  \n     * @return the resource type info bean\n     */\n    private CmsNewResourceInfo createResourceTypeInfo(I_CmsResourceType resType, CmsUUID copyResourceId) {\n\n        String name = resType.getTypeName();\n        Locale locale = OpenCms.getWorkplaceManager().getWorkplaceLocale(getCmsObject());\n        if (locale == null) {\n            locale = new Locale(\"en\");\n        }\n        return new CmsNewResourceInfo(\n            resType.getTypeId(),\n            name,\n            CmsWorkplaceMessages.getResourceTypeName(locale, name),\n            CmsWorkplaceMessages.getResourceTypeDescription(locale, name),\n            copyResourceId);\n    }","id":38706,"modified_method":"/**\n     * Creates a resource type info bean for a given resource type.<p>\n     * \n     * @param resType the resource type\n     * @param copyResource the structure id of the copy resource\n     *  \n     * @return the resource type info bean\n     */\n    private CmsNewResourceInfo createResourceTypeInfo(I_CmsResourceType resType, CmsResource copyResource) {\n\n        String name = resType.getTypeName();\n        Locale locale = OpenCms.getWorkplaceManager().getWorkplaceLocale(getCmsObject());\n        if (locale == null) {\n            locale = new Locale(\"en\");\n        }\n        if (copyResource != null) {\n            return new CmsNewResourceInfo(copyResource.getTypeId(), name, CmsWorkplaceMessages.getResourceTypeName(\n                locale,\n                name), CmsWorkplaceMessages.getResourceTypeDescription(locale, name), copyResource.getStructureId());\n        } else {\n            return new CmsNewResourceInfo(resType.getTypeId(), name, CmsWorkplaceMessages.getResourceTypeName(\n                locale,\n                name), CmsWorkplaceMessages.getResourceTypeDescription(locale, name), null);\n        }\n    }","commit_id":"d0637873ff6b9c022417dcfb8a943d40a91214b9","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the resource type info beans for types for which new detail pages can be created.<p>\n     * \n     * @param cms the current CMS context \n     * @param entryPoint the sitemap entry-point \n     * @param copyResourceId the structure id of the copy resource\n     * \n     * @return the resource type info beans for types for which new detail pages can be created \n     * \n     * @throws CmsException if something goes wrong \n     */\n    private List<CmsNewResourceInfo> getResourceTypeInfos(CmsObject cms, String entryPoint, CmsUUID copyResourceId)\n    throws CmsException {\n\n        List<CmsNewResourceInfo> result = new ArrayList<CmsNewResourceInfo>();\n        CmsContainerPageConfigurationData configData = OpenCms.getADEConfigurationManager().getContainerPageConfiguration(\n            cms,\n            cms.getRequestContext().addSiteRoot(entryPoint));\n        Map<String, CmsConfigurationItem> typeConfig = configData.getTypeConfiguration();\n        for (CmsConfigurationItem item : typeConfig.values()) {\n            CmsResource sourceFile = item.getSourceFile();\n            I_CmsResourceType resourceType = OpenCms.getResourceManager().getResourceType(sourceFile.getTypeId());\n            CmsNewResourceInfo info = createResourceTypeInfo(resourceType, copyResourceId);\n            result.add(info);\n        }\n        return result;\n    }","id":38707,"modified_method":"/**\n     * Gets the resource type info beans for types for which new detail pages can be created.<p>\n     * \n     * @param cms the current CMS context \n     * @param entryPoint the sitemap entry-point \n     * @param copyResource the copy resource\n     * \n     * @return the resource type info beans for types for which new detail pages can be created \n     * \n     * @throws CmsException if something goes wrong \n     */\n    private List<CmsNewResourceInfo> getResourceTypeInfos(CmsObject cms, String entryPoint, CmsResource copyResource)\n    throws CmsException {\n\n        List<CmsNewResourceInfo> result = new ArrayList<CmsNewResourceInfo>();\n        CmsContainerPageConfigurationData configData = OpenCms.getADEConfigurationManager().getContainerPageConfiguration(\n            cms,\n            cms.getRequestContext().addSiteRoot(entryPoint));\n        Map<String, CmsConfigurationItem> typeConfig = configData.getTypeConfiguration();\n        for (CmsConfigurationItem item : typeConfig.values()) {\n            CmsResource sourceFile = item.getSourceFile();\n            I_CmsResourceType resourceType = OpenCms.getResourceManager().getResourceType(sourceFile.getTypeId());\n            CmsNewResourceInfo info = createResourceTypeInfo(resourceType, copyResource);\n            result.add(info);\n        }\n        return result;\n    }","commit_id":"d0637873ff6b9c022417dcfb8a943d40a91214b9","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.sitemap.shared.rpc.I_CmsSitemapService#prefetch(java.lang.String)\n     */\n    public CmsSitemapData prefetch(String sitemapUri) throws CmsRpcException {\n\n        CmsSitemapData result = null;\n        CmsObject cms = getCmsObject();\n        CmsADEManager sitemapMgr = OpenCms.getADEManager();\n        try {\n            String openPath = getRequest().getParameter(\"path\");\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(openPath)) {\n                // if no path is supplied, start from root\n                openPath = \"/\";\n            }\n            String entryPoint = sitemapMgr.findEntryPoint(cms, openPath);\n\n            Map<String, CmsXmlContentProperty> propertyConfig = new LinkedHashMap<String, CmsXmlContentProperty>(\n                sitemapMgr.getElementPropertyConfiguration(cms, entryPoint));\n            Map<String, CmsClientProperty> parentProperties = generateParentProperties(entryPoint);\n\n            String siteRoot = cms.getRequestContext().getSiteRoot();\n            String exportRfsPrefix = OpenCms.getStaticExportManager().getDefaultRfsPrefix();\n            CmsSite site = OpenCms.getSiteManager().getSiteForSiteRoot(siteRoot);\n            boolean isSecure = site.hasSecureServer();\n\n            String parentSitemap = null;\n            if (!entryPoint.equals(\"/\")) {\n                parentSitemap = sitemapMgr.findEntryPoint(cms, CmsResource.getParentFolder(entryPoint));\n            }\n            CmsSitemapConfigurationData sitemapConfig = OpenCms.getADEConfigurationManager().getSitemapConfiguration(\n                cms,\n                cms.getRequestContext().addSiteRoot(openPath));\n            String noEdit = \"\";\n            CmsNewResourceInfo defaultNewInfo = null;\n            List<CmsNewResourceInfo> newResourceInfos = null;\n            CmsDetailPageTable detailPages = null;\n            List<CmsNewResourceInfo> resourceTypeInfos = null;\n            boolean canEditDetailPages = false;\n            boolean isOnlineProject = CmsProject.isOnlineProject(cms.getRequestContext().getCurrentProject().getUuid());\n            if (sitemapConfig == null) {\n                noEdit = Messages.get().getBundle().key(Messages.GUI_SITEMAP_NO_EDIT_0);\n            } else {\n                detailPages = new CmsDetailPageTable(sitemapConfig.getDetailPageInfo());\n                if (!isOnlineProject) {\n                    CmsConfigurationItem containerpageConfigItem = sitemapConfig.getTypeConfiguration().get(\n                        CmsResourceTypeXmlContainerPage.getStaticTypeName());\n                    if (containerpageConfigItem != null) {\n                        resourceTypeInfos = getResourceTypeInfos(\n                            getCmsObject(),\n                            entryPoint,\n                            containerpageConfigItem.getSourceFile().getStructureId());\n                        defaultNewInfo = createNewResourceInfo(cms, containerpageConfigItem);\n                    }\n                    canEditDetailPages = !(sitemapConfig.getLastSource().isModuleConfiguration());\n                    newResourceInfos = getNewResourceInfos(cms, entryPoint);\n                }\n            }\n            if (isOnlineProject) {\n                noEdit = Messages.get().getBundle().key(Messages.GUI_SITEMAP_NO_EDIT_ONLINE_0);\n            }\n            List<String> allPropNames = getPropertyNames(cms);\n\n            cms.getRequestContext().getSiteRoot();\n            result = new CmsSitemapData(\n                getTemplates(),\n                propertyConfig,\n                getClipboardData(),\n                parentProperties,\n                allPropNames,\n                exportRfsPrefix,\n                isSecure,\n                noEdit,\n                isDisplayToolbar(getRequest()),\n                defaultNewInfo,\n                newResourceInfos,\n                createResourceTypeInfo(OpenCms.getResourceManager().getResourceType(RECOURCE_TYPE_NAME_REDIRECT), null),\n                OpenCms.getSiteManager().getCurrentSite(cms).getTitle(),\n                parentSitemap,\n                getRootEntry(entryPoint),\n                openPath,\n                30,\n                detailPages,\n                resourceTypeInfos,\n                canEditDetailPages);\n        } catch (Throwable e) {\n            error(e);\n        }\n        return result;\n    }","id":38708,"modified_method":"/**\n     * @see org.opencms.ade.sitemap.shared.rpc.I_CmsSitemapService#prefetch(java.lang.String)\n     */\n    public CmsSitemapData prefetch(String sitemapUri) throws CmsRpcException {\n\n        CmsSitemapData result = null;\n        CmsObject cms = getCmsObject();\n        CmsADEManager sitemapMgr = OpenCms.getADEManager();\n        try {\n            String openPath = getRequest().getParameter(\"path\");\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(openPath)) {\n                // if no path is supplied, start from root\n                openPath = \"/\";\n            }\n            String entryPoint = sitemapMgr.findEntryPoint(cms, openPath);\n\n            Map<String, CmsXmlContentProperty> propertyConfig = new LinkedHashMap<String, CmsXmlContentProperty>(\n                sitemapMgr.getElementPropertyConfiguration(cms, entryPoint));\n            Map<String, CmsClientProperty> parentProperties = generateParentProperties(entryPoint);\n\n            String siteRoot = cms.getRequestContext().getSiteRoot();\n            String exportRfsPrefix = OpenCms.getStaticExportManager().getDefaultRfsPrefix();\n            CmsSite site = OpenCms.getSiteManager().getSiteForSiteRoot(siteRoot);\n            boolean isSecure = site.hasSecureServer();\n\n            String parentSitemap = null;\n            if (!entryPoint.equals(\"/\")) {\n                parentSitemap = sitemapMgr.findEntryPoint(cms, CmsResource.getParentFolder(entryPoint));\n            }\n            CmsSitemapConfigurationData sitemapConfig = OpenCms.getADEConfigurationManager().getSitemapConfiguration(\n                cms,\n                cms.getRequestContext().addSiteRoot(openPath));\n            String noEdit = \"\";\n            CmsNewResourceInfo defaultNewInfo = null;\n            List<CmsNewResourceInfo> newResourceInfos = null;\n            CmsDetailPageTable detailPages = null;\n            List<CmsNewResourceInfo> resourceTypeInfos = null;\n            boolean canEditDetailPages = false;\n            boolean isOnlineProject = CmsProject.isOnlineProject(cms.getRequestContext().getCurrentProject().getUuid());\n            if (sitemapConfig == null) {\n                noEdit = Messages.get().getBundle().key(Messages.GUI_SITEMAP_NO_EDIT_0);\n            } else {\n                detailPages = new CmsDetailPageTable(sitemapConfig.getDetailPageInfo());\n                if (!isOnlineProject) {\n                    CmsConfigurationItem containerpageConfigItem = sitemapConfig.getTypeConfiguration().get(\n                        CmsResourceTypeXmlContainerPage.getStaticTypeName());\n                    if (containerpageConfigItem != null) {\n                        resourceTypeInfos = getResourceTypeInfos(\n                            getCmsObject(),\n                            entryPoint,\n                            containerpageConfigItem.getSourceFile());\n                        defaultNewInfo = createNewResourceInfo(cms, containerpageConfigItem);\n                    }\n                    canEditDetailPages = !(sitemapConfig.getLastSource().isModuleConfiguration());\n                    newResourceInfos = getNewResourceInfos(cms, entryPoint);\n                }\n            }\n            if (isOnlineProject) {\n                noEdit = Messages.get().getBundle().key(Messages.GUI_SITEMAP_NO_EDIT_ONLINE_0);\n            }\n            List<String> allPropNames = getPropertyNames(cms);\n\n            cms.getRequestContext().getSiteRoot();\n            result = new CmsSitemapData(\n                getTemplates(),\n                propertyConfig,\n                getClipboardData(),\n                parentProperties,\n                allPropNames,\n                exportRfsPrefix,\n                isSecure,\n                noEdit,\n                isDisplayToolbar(getRequest()),\n                defaultNewInfo,\n                newResourceInfos,\n                createResourceTypeInfo(OpenCms.getResourceManager().getResourceType(RECOURCE_TYPE_NAME_REDIRECT), null),\n                OpenCms.getSiteManager().getCurrentSite(cms).getTitle(),\n                parentSitemap,\n                getRootEntry(entryPoint),\n                openPath,\n                30,\n                detailPages,\n                resourceTypeInfos,\n                canEditDetailPages);\n        } catch (Throwable e) {\n            error(e);\n        }\n        return result;\n    }","commit_id":"d0637873ff6b9c022417dcfb8a943d40a91214b9","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Adds a resource type to the list of configured resource types.<p>\n         * \n         * @param type the resource type to add\n         */\n        protected void addResourceType(I_CmsResourceType type) {\n\n            m_resourceTypeIdMap.put(Integer.valueOf(type.getTypeId()), type);\n            m_resourceTypeNameMap.put(type.getTypeName(), type);\n            m_resourceTypeList.add(type);\n        }","id":38709,"modified_method":"/**\n         * Adds a resource type to the list of configured resource types.<p>\n         * \n         * @param type the resource type to add\n         */\n        protected void addResourceType(I_CmsResourceType type) {\n\n            // TODO: If we switch to Java 1.5 compatiblity change this to Integer.valueOf(int) for sligthly better performance \n            m_resourceTypeIdMap.put(new Integer(type.getTypeId()), type);\n            m_resourceTypeNameMap.put(type.getTypeName(), type);\n            m_resourceTypeList.add(type);\n        }","commit_id":"4a74dd4c402bbc013487af0f6bbaf68164fc8144","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * Returns the configured resource type with the matching type id, or <code>null<\/code>\n         * if a resource type with that id is not configured.<p> \n         * \n         * @param typeId the type id to get the resource type for\n         * \n         * @return the configured resource type with the matching type id, or <code>null<\/code>\n         */\n        protected I_CmsResourceType getResourceTypeById(int typeId) {\n\n            return (I_CmsResourceType)m_resourceTypeIdMap.get(Integer.valueOf(typeId));\n        }","id":38710,"modified_method":"/**\n         * Returns the configured resource type with the matching type id, or <code>null<\/code>\n         * if a resource type with that id is not configured.<p> \n         * \n         * @param typeId the type id to get the resource type for\n         * \n         * @return the configured resource type with the matching type id, or <code>null<\/code>\n         */\n        protected I_CmsResourceType getResourceTypeById(int typeId) {\n\n            // TODO: If we switch to Java 1.5 compatiblity change this to Integer.valueOf(int) for sligthly better performance \n            return (I_CmsResourceType)m_resourceTypeIdMap.get(new Integer(typeId));\n        }","commit_id":"4a74dd4c402bbc013487af0f6bbaf68164fc8144","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public AntMacroDefImpl(final AntElement parent,\n                         final XmlElement sourceElement,\n                         final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n\n    if (getNameElement() == ourNull) {\n      myMacroDefinition = null;\n      return;\n    }\n\n    final AntFile file = getAntFile();\n    final AntStructuredElement seParent = PsiTreeUtil.getParentOfType(this, AntStructuredElement.class);\n    assert seParent != null;\n    final String thisClassName = toString();\n    final HashMap<String, AntAttributeType> attributes = new HashMap<String, AntAttributeType>();\n    final HashMap<AntTypeId, String> nestedElements = new HashMap<AntTypeId, String>();\n    final AntElement[] children = getChildren();\n\n    for (AntElement child : children) {\n      if (child instanceof AntStructuredElement) {\n        AntStructuredElement se = (AntStructuredElement)child;\n        final String name = se.getName();\n        if (name != null) {\n          final String tagName = se.getSourceElement().getName();\n          if (tagName.equals(\"attribute\")) {\n            attributes.put(name, AntAttributeType.STRING);\n          }\n          else if (tagName.equals(\"element\")) {\n            final AntTypeDefinitionImpl nestedElementDef =\n              new AntTypeDefinitionImpl((AntTypeDefinitionImpl)file.getTargetDefinition());\n            final AntTypeId typeId = new AntTypeId(name);\n            nestedElementDef.setTypeId(typeId);\n            nestedElementDef.setIsTask(false);\n            nestedElementDef.setClassName(thisClassName + '.' + name);\n            seParent.registerCustomType(nestedElementDef);\n            nestedElements.put(typeId, nestedElementDef.getClassName());\n          }\n        }\n      }\n    }\n    final String name = getName();\n    myMacroDefinition =\n      new AntTypeDefinitionImpl(new AntTypeId(name), thisClassName, true, attributes, nestedElements);\n    seParent.registerCustomType(myMacroDefinition);\n  }","id":38711,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public AntMacroDefImpl(final AntElement parent,\n                         final XmlElement sourceElement,\n                         final AntTypeDefinition definition) {\n    super(parent, sourceElement, definition);\n\n    if (getNameElement() == ourNull) {\n      myMacroDefinition = null;\n      return;\n    }\n\n    final AntFile file = getAntFile();\n    final AntStructuredElement seParent = PsiTreeUtil.getParentOfType(this, AntStructuredElement.class);\n    assert seParent != null;\n    final String thisClassName = toString();\n    final HashMap<String, AntAttributeType> attributes = new HashMap<String, AntAttributeType>();\n    final HashMap<AntTypeId, String> nestedElements = new HashMap<AntTypeId, String>();\n    final AntElement[] children = getChildren();\n\n    for (AntElement child : children) {\n      if (child instanceof AntStructuredElement) {\n        AntStructuredElement se = (AntStructuredElement)child;\n        final String name = se.getName();\n        if (name != null) {\n          final String tagName = se.getSourceElement().getName();\n          if (tagName.equals(\"attribute\")) {\n            attributes.put(name, AntAttributeType.STRING);\n          }\n          else if (tagName.equals(\"element\")) {\n            final AntTypeDefinitionImpl nestedElementDef =\n              new AntTypeDefinitionImpl((AntTypeDefinitionImpl)file.getTargetDefinition());\n            final AntTypeId typeId = new AntTypeId(name);\n            nestedElementDef.setTypeId(typeId);\n            nestedElementDef.setIsTask(false);\n            nestedElementDef.setClassName(thisClassName + '.' + name);\n            seParent.registerCustomType(nestedElementDef);\n            nestedElements.put(typeId, nestedElementDef.getClassName());\n          }\n        }\n      }\n    }\n    final String name = getName();\n    myMacroDefinition =\n      new AntTypeDefinitionImpl(new AntTypeId(name), thisClassName, true, attributes, nestedElements, this);\n    seParent.registerCustomType(myMacroDefinition);\n  }","commit_id":"8365c0e548c09b8d8a92dc088cb39fec8b5fb77b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntMacroDef[\");\n      builder.append(getSourceElement().getName());\n      builder.append(\"]\");\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":38712,"modified_method":"public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(ANT_MACRODEF_NAME);\n      builder.append(\"[\");\n      builder.append(getSourceElement().getName());\n      builder.append(\"]\");\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","commit_id":"8365c0e548c09b8d8a92dc088cb39fec8b5fb77b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getName() {\n    XmlElement element = getSourceElement();\n    if (element == null) {\n      element = null;\n    }\n    PsiElement parent = element.getParent();\n    if (parent == null) {\n      parent = null;\n    }\n    return ((XmlAttribute)parent).getValue();\n  }","id":38713,"modified_method":"public String getName() {\n    PsiElement parent = getSourceElement().getParent();\n    if (parent == null) {\n      return null;\n    }\n    return ((XmlAttribute)parent).getValue();\n  }","commit_id":"8365c0e548c09b8d8a92dc088cb39fec8b5fb77b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    final AntProject project = getElement().getAntProject();\n    return getVariants(project);\n  }","id":38714,"modified_method":"public Object[] getVariants() {\n    return getVariants(getElement().getAntProject());\n  }","commit_id":"8365c0e548c09b8d8a92dc088cb39fec8b5fb77b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getAttributeValueStartOffset() {\n    return getAttribute().getValueElement().getTextRange().getStartOffset() + 1;\n  }","id":38715,"modified_method":"private int getAttributeValueStartOffset() {\n    final XmlAttribute attr = getAttribute();\n    final XmlAttributeValue valueElement = attr.getValueElement();\n    return (valueElement == null)\n           ? attr.getTextRange().getEndOffset() + 1\n           : valueElement.getTextRange().getStartOffset() + 1;\n  }","commit_id":"8365c0e548c09b8d8a92dc088cb39fec8b5fb77b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntTypeDefinitionImpl(final AntTypeDefinitionImpl base) {\n    myTypeId = base.getTypeId();\n    myClassName = base.getClassName();\n    myIsTask = base.isTask();\n    myAttributes = new HashMap<String, AntAttributeType>(base.myAttributes);\n    myNestedClassNames = new HashMap<AntTypeId, String>(base.myNestedClassNames);\n  }","id":38716,"modified_method":"public AntTypeDefinitionImpl(final AntTypeDefinitionImpl base) {\n    this(base.getTypeId(), base.getClassName(), base.isTask(),\n         new HashMap<String, AntAttributeType>(base.myAttributes),\n         new HashMap<AntTypeId, String>(base.myNestedClassNames));\n  }","commit_id":"8365c0e548c09b8d8a92dc088cb39fec8b5fb77b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntTypeDefinitionImpl(final AntTypeId id,\n                               final String className,\n                               final boolean isTask,\n                               @NonNls @NotNull final Map<String, AntAttributeType> attributes,\n                               final Map<AntTypeId, String> nestedElements) {\n    myTypeId = id;\n    myClassName = className;\n    myIsTask = isTask;\n    attributes.put(\"id\", AntAttributeType.STRING);\n    myAttributes = attributes;\n    myNestedClassNames = nestedElements;\n  }","id":38717,"modified_method":"public AntTypeDefinitionImpl(final AntTypeId id,\n                               final String className,\n                               final boolean isTask,\n                               @NonNls @NotNull final Map<String, AntAttributeType> attributes,\n                               final Map<AntTypeId, String> nestedElements) {\n    this(id, className, isTask, attributes, nestedElements, null);\n  }","commit_id":"8365c0e548c09b8d8a92dc088cb39fec8b5fb77b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    if (!isInitialized) {\n      return;\n    }\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        disposeMPS();\n        isInitialized = false;\n      }\n    });\n  }","id":38718,"modified_method":"public void dispose() {\n    if (!isInitialized) {\n      return;\n    }\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        MPSModuleRepository.getInstance().unregisterModules(IterableUtil.asCollection(myProject.getModules()), myProject);\n        myProject.dispose();\n        myJpsToMpsModules.clear();\n        myRepo = null;\n      }\n    });\n    disposeMPS();\n    isInitialized = false;\n  }","commit_id":"23f512bb0a595f122c8f622070243fe62373b0ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void init(final CompileContext context) {\n    if (isInitialized) {\n      return;\n    }\n    initMPS();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        long start = System.nanoTime();\n        initRepository(context,\n          context.getBuilderParameter(MPSMakeConstants.MPS_LANGUAGES.toString()),\n          context.getBuilderParameter(MPSMakeConstants.MPS_REPOSITORY.toString()));\n\n        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());\n\n        initProject(context);\n\n        if (MPSCompilerUtil.isTracingMode()) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"MPS loaded in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n        }\n        isInitialized = true;\n      }\n    });\n  }","id":38719,"modified_method":"public void init(final CompileContext context) {\n    if (isInitialized) {\n      return;\n    }\n    initMPS();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        long start = System.nanoTime();\n        initRepository(context,\n          context.getBuilderParameter(MPSMakeConstants.MPS_LANGUAGES.toString()),\n          context.getBuilderParameter(MPSMakeConstants.MPS_REPOSITORY.toString()));\n\n        initProject(context);\n\n        if (MPSCompilerUtil.isTracingMode()) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"MPS loaded in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n        }\n        isInitialized = true;\n      }\n    });\n  }","commit_id":"23f512bb0a595f122c8f622070243fe62373b0ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initRepository(CompileContext context, String languages, String repoFile) {\n    if (repoFile != null) {\n      File f = new File(repoFile);\n      ModelInputStream mos = null;\n      try {\n        long start = System.nanoTime();\n        mos = new ModelInputStream(new FileInputStream(f));\n        myRepo = CachedRepositoryData.load(mos);\n        if (MPSCompilerUtil.isTracingMode()) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"loaded \" + myRepo.getModules().size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n        }\n\n        // use optimized implementation of default model root\n        PersistenceRegistry.getInstance().setModelRootFactory(PersistenceRegistry.DEFAULT_MODEL_ROOT, new ModelRootFactory() {\n          @Override\n          public ModelRoot create() {\n            return new CachedDefaultModelRoot(myRepo);\n          }\n        });\n\n        PersistenceRegistry.getInstance().setModelRootFactory(PersistenceRegistry.JAVA_CLASSES_ROOT, new ModelRootFactory() {\n          @Override\n          public ModelRoot create() {\n            return new CachedJavaClassStubsModelRoot(myRepo);\n          }\n        });\n\n        start = System.nanoTime();\n        for (CachedModuleData data : myRepo.getModules()) {\n          ModuleRepositoryFacade.createModule(data.getHandle(), this);\n        }\n        if (MPSCompilerUtil.isTracingMode()) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"instantiated \" + myRepo.getModules().size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n        }\n        return;\n      } catch (IOException e) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, e));\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.WARNING, \"cannot load cache, generation may be slow\"));\n      } finally {\n        jetbrains.mps.util.FileUtil.closeFileSafe(mos);\n      }\n    } else if (languages != null) {\n      // TODO split by semicolon, etc.\n\n      long start = System.nanoTime();\n      List<ModuleHandle> loadedModules = new ArrayList<ModuleHandle>();\n      BaseMPSModuleOwner owner = new BaseMPSModuleOwner() {};\n      for (String path: languages.split(\";\")) {\n        IFile ipath = FileSystem.getInstance().getFileByPath(path);\n        loadedModules.addAll(ModulesMiner.getInstance().collectModules(ipath, true));\n      }\n\n      if (MPSCompilerUtil.isTracingMode()) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"loaded \" + loadedModules.size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n      }\n\n      start = System.nanoTime();\n      for (ModuleHandle moduleHandle : loadedModules) {\n        SModule module = ModuleRepositoryFacade.createModule(moduleHandle, owner);\n      }\n\n      if (MPSCompilerUtil.isTracingMode()) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"instantiated \" + loadedModules.size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n      }\n\n      return;\n    }\n\n    context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.WARNING, \"cannot start MPS, no repository provided\"));\n  }","id":38720,"modified_method":"private void initRepository(CompileContext context, String languages, String repoFile) {\n    if (repoFile != null) {\n      File f = new File(repoFile);\n      ModelInputStream mos = null;\n      try {\n        long start = System.nanoTime();\n        mos = new ModelInputStream(new FileInputStream(f));\n        myRepo = CachedRepositoryData.load(mos);\n        if (MPSCompilerUtil.isTracingMode()) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"loaded \" + myRepo.getModules().size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n        }\n\n        // use optimized implementation of default model root\n        PersistenceRegistry.getInstance().setModelRootFactory(PersistenceRegistry.DEFAULT_MODEL_ROOT, new ModelRootFactory() {\n          @Override\n          public ModelRoot create() {\n            return new CachedDefaultModelRoot(myRepo);\n          }\n        });\n\n        PersistenceRegistry.getInstance().setModelRootFactory(PersistenceRegistry.JAVA_CLASSES_ROOT, new ModelRootFactory() {\n          @Override\n          public ModelRoot create() {\n            return new CachedJavaClassStubsModelRoot(myRepo);\n          }\n        });\n\n        start = System.nanoTime();\n        for (CachedModuleData data : myRepo.getModules()) {\n          ModuleRepositoryFacade.createModule(data.getHandle(), this);\n        }\n        if (MPSCompilerUtil.isTracingMode()) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"instantiated \" + myRepo.getModules().size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n        }\n        return;\n      } catch (IOException e) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, e));\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.WARNING, \"cannot load cache, generation may be slow\"));\n      } finally {\n        jetbrains.mps.util.FileUtil.closeFileSafe(mos);\n      }\n    } else if (languages != null) {\n      // TODO split by semicolon, etc.\n\n      long start = System.nanoTime();\n      List<ModuleHandle> loadedModules = new ArrayList<ModuleHandle>();\n      for (String path: languages.split(\";\")) {\n        IFile ipath = FileSystem.getInstance().getFileByPath(path);\n        loadedModules.addAll(ModulesMiner.getInstance().collectModules(ipath, true));\n      }\n\n      if (MPSCompilerUtil.isTracingMode()) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"loaded \" + loadedModules.size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n      }\n\n      start = System.nanoTime();\n      for (ModuleHandle moduleHandle : loadedModules) {\n        ModuleRepositoryFacade.createModule(moduleHandle, OWNER);\n      }\n\n      if (MPSCompilerUtil.isTracingMode()) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"instantiated \" + loadedModules.size() + \" modules in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n      }\n\n      return;\n    }\n\n    context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.WARNING, \"cannot start MPS, no repository provided\"));\n  }","commit_id":"23f512bb0a595f122c8f622070243fe62373b0ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initProject(CompileContext context) {\n    long start = System.nanoTime();\n\n    JpsProject jpsProject = context.getProjectDescriptor().getProject();\n    myProject = new JpsMPSProject(jpsProject);\n\n    Set<JpsLibrary> processedSdks = new HashSet<JpsLibrary>();\n\n    JpsLibrary jdk = null;\n    for (JpsModule mod : jpsProject.getModules()) {\n      JpsMPSModuleExtension extension = JpsMPSExtensionService.getInstance().getExtension(mod);\n\n      if (extension == null) {\n        continue;\n      }\n\n      if (MPSCompilerUtil.isTracingMode()) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Creating solution for \" + mod.getName()));\n      }\n\n      SolutionDescriptor descriptor = extension.getConfiguration().getSolutionDescriptor();\n      descriptor.setNamespace(mod.getName());\n      MPSCompilerUtil.debug(context, \"UUID \" + descriptor.getId());\n      // Commeted out. See SolutionIdea: solutions don't have foreign ids, rather regular\n//      descriptor.setId(ModuleId.foreign(mod.getName()));\n\n      JpsSolutionIdea module = new JpsSolutionIdea(mod, descriptor, context);\n      JpsSolutionIdea solutionIdea = MPSModuleRepository.getInstance().registerModule(module, myProject);\n      if (module == solutionIdea) {\n        solutionIdea.updateModelsSet();\n      }\n      myProject.addModule(solutionIdea.getModuleReference());\n\n      jpsToMpsModules.put(mod, solutionIdea);\n\n      // let's handle module sdkLib\n      for (JpsLibrary sdk: getModuleSdks(mod, context)) {\n        MPSCompilerUtil.debug(context, \"SDK name\" + sdk.getName() + \" type: \" + sdk.getType());\n\n        JpsLibSolution sdkSolution = createLibSolution(sdk, jdk, context);\n        JpsLibSolution regSolution = MPSModuleRepository.getInstance().registerModule(sdkSolution, myProject);\n        MPSCompilerUtil.debug(context, \"SDK \" + regSolution.getModuleReference().toString());\n        if (sdkSolution == regSolution) {\n          MPSCompilerUtil.debug(context, \"SDK updating model set for \" + sdk.getName());\n          sdkSolution.updateModelsSet();\n        }\n\n        if (JpsJavaSdkType.INSTANCE.equals(sdk.getType()) && !processedSdks.contains(sdk)) {\n          jdk = jdk != null ? jdk : sdk;\n          processedSdks.add(sdk);\n        }\n      }\n    }\n\n    if (processedSdks.size() > 1) {\n      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.ERROR, \"Different SDKs in modules with MPS facets are not supported\"));\n    }\n\n    // maybe libraries should be put into repository before modules, so that SolutionIdea already has its dependencies at hand\n\n    for (JpsLibrary jpsLib : jpsProject.getLibraryCollection().getLibraries()) {\n      JpsLibSolution libSolution = createLibSolution(jpsLib, jdk, context);\n      JpsLibSolution regSolution = MPSModuleRepository.getInstance().registerModule(libSolution, myProject);\n      MPSCompilerUtil.debug(context, \"LIB \" + regSolution.getModuleReference().toString());\n      if (libSolution == regSolution) {\n        MPSCompilerUtil.debug(context, \"LIB updating model set for \" + jpsLib.getName());\n        libSolution.updateModelsSet();\n      }\n      if (MPSCompilerUtil.isExtraTracingMode()) {\n        for (SModel desc : SModelRepository.getInstance().getModelDescriptors(regSolution)) {\n          MPSCompilerUtil.debug(context, \"LIB model \" + desc.getModelName());\n        }\n      }\n    }\n\n    if (MPSCompilerUtil.isTracingMode()) {\n      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Project modules loaded in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n\n      if (MPSCompilerUtil.isExtraTracingMode()) {\n        for (SModule m : MPSModuleRepository.getInstance().getModules(myProject)) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Debug output: module \" + m.getModuleReference().toString()));\n\n          for (SModel d : SModelRepository.getInstance().getModelDescriptors(m)) {\n            context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Debug output: model \" + SNodeOperations.getModelLongName(d) + \" / \" + d.getReference().toString()));\n            // It makes model loading non-lazy and kills the whole thing if stubs are built for everything (like SDK, libs, etc)\n  //          for (SNode n : d.getRootNodes()) {\n  //            context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"node: \" + n.getName() + \" id: \" + n.getSNodeId().toString()));\n  //            if (n.getName().equals(\"PsiListener\") || n.getName().equals(\"PsiChangesWatcher\")) {\n  //              for (SNode n2 : n.getChildren()) {\n  //                context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"child: \" + n2.getName() + \" id: \" + n2.getSNodeId().toString()));\n  //              }\n  //            }\n  //          }\n          }\n        }\n      }\n    }\n  }","id":38721,"modified_method":"private void initProject(CompileContext context) {\n    long start = System.nanoTime();\n\n    JpsProject jpsProject = context.getProjectDescriptor().getProject();\n    myProject = new JpsMPSProject(jpsProject);\n\n    Set<JpsLibrary> processedSdks = new HashSet<JpsLibrary>();\n\n    JpsLibrary jdk = null;\n    for (JpsModule mod : jpsProject.getModules()) {\n      JpsMPSModuleExtension extension = JpsMPSExtensionService.getInstance().getExtension(mod);\n\n      if (extension == null) {\n        continue;\n      }\n\n      if (MPSCompilerUtil.isTracingMode()) {\n        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Creating solution for \" + mod.getName()));\n      }\n\n      SolutionDescriptor descriptor = extension.getConfiguration().getSolutionDescriptor();\n      descriptor.setNamespace(mod.getName());\n      MPSCompilerUtil.debug(context, \"UUID \" + descriptor.getId());\n      // Commeted out. See SolutionIdea: solutions don't have foreign ids, rather regular\n//      descriptor.setId(ModuleId.foreign(mod.getName()));\n\n      JpsSolutionIdea module = new JpsSolutionIdea(mod, descriptor, context);\n      JpsSolutionIdea solutionIdea = MPSModuleRepository.getInstance().registerModule(module, myProject);\n      if (module == solutionIdea) {\n        solutionIdea.updateModelsSet();\n      }\n      myProject.addModule(solutionIdea.getModuleReference());\n\n      myJpsToMpsModules.put(mod, solutionIdea);\n\n      // let's handle module sdkLib\n      for (JpsLibrary sdk: getModuleSdks(mod, context)) {\n        MPSCompilerUtil.debug(context, \"SDK name\" + sdk.getName() + \" type: \" + sdk.getType());\n\n        JpsLibSolution sdkSolution = createLibSolution(sdk, jdk, context);\n        JpsLibSolution regSolution = MPSModuleRepository.getInstance().registerModule(sdkSolution, myProject);\n        MPSCompilerUtil.debug(context, \"SDK \" + regSolution.getModuleReference().toString());\n        if (sdkSolution == regSolution) {\n          MPSCompilerUtil.debug(context, \"SDK updating model set for \" + sdk.getName());\n          sdkSolution.updateModelsSet();\n        }\n\n        if (JpsJavaSdkType.INSTANCE.equals(sdk.getType()) && !processedSdks.contains(sdk)) {\n          jdk = jdk != null ? jdk : sdk;\n          processedSdks.add(sdk);\n        }\n      }\n    }\n\n    if (processedSdks.size() > 1) {\n      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.ERROR, \"Different SDKs in modules with MPS facets are not supported\"));\n    }\n\n    // maybe libraries should be put into repository before modules, so that SolutionIdea already has its dependencies at hand\n\n    for (JpsLibrary jpsLib : jpsProject.getLibraryCollection().getLibraries()) {\n      JpsLibSolution libSolution = createLibSolution(jpsLib, jdk, context);\n      JpsLibSolution regSolution = MPSModuleRepository.getInstance().registerModule(libSolution, myProject);\n      MPSCompilerUtil.debug(context, \"LIB \" + regSolution.getModuleReference().toString());\n      if (libSolution == regSolution) {\n        MPSCompilerUtil.debug(context, \"LIB updating model set for \" + jpsLib.getName());\n        libSolution.updateModelsSet();\n      }\n      if (MPSCompilerUtil.isExtraTracingMode()) {\n        for (SModel desc : SModelRepository.getInstance().getModelDescriptors(regSolution)) {\n          MPSCompilerUtil.debug(context, \"LIB model \" + desc.getModelName());\n        }\n      }\n    }\n\n    if (MPSCompilerUtil.isTracingMode()) {\n      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Project modules loaded in \" + (System.nanoTime() - start) / 1000000 + \" ms\"));\n\n      if (MPSCompilerUtil.isExtraTracingMode()) {\n        for (SModule m : MPSModuleRepository.getInstance().getModules(myProject)) {\n          context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Debug output: module \" + m.getModuleReference().toString()));\n\n          for (SModel d : SModelRepository.getInstance().getModelDescriptors(m)) {\n            context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"Debug output: model \" + SNodeOperations.getModelLongName(d) + \" / \" + d.getReference().toString()));\n            // It makes model loading non-lazy and kills the whole thing if stubs are built for everything (like SDK, libs, etc)\n  //          for (SNode n : d.getRootNodes()) {\n  //            context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"node: \" + n.getName() + \" id: \" + n.getSNodeId().toString()));\n  //            if (n.getName().equals(\"PsiListener\") || n.getName().equals(\"PsiChangesWatcher\")) {\n  //              for (SNode n2 : n.getChildren()) {\n  //                context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID, Kind.INFO, \"child: \" + n2.getName() + \" id: \" + n2.getSNodeId().toString()));\n  //              }\n  //            }\n  //          }\n          }\n        }\n      }\n    }\n  }","commit_id":"23f512bb0a595f122c8f622070243fe62373b0ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JpsSolutionIdea getSolution(JpsModule module) {\n    if (!isInitialized) throw new IllegalStateException(\"Not initialized yet\");\n    return jpsToMpsModules.get(module);\n  }","id":38722,"modified_method":"public JpsSolutionIdea getSolution(JpsModule module) {\n    if (!isInitialized) throw new IllegalStateException(\"Not initialized yet\");\n    return myJpsToMpsModules.get(module);\n  }","commit_id":"23f512bb0a595f122c8f622070243fe62373b0ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  @Override\n  public Module createModule(@NotNull ModifiableModuleModel moduleModel)\n    throws InvalidDataException, IOException, ModuleWithNameAlreadyExists, JDOMException, ConfigurationException {\n    final String path = getContentEntryPath();\n    unzip(path, true);\n    return ImportImlMode.setUpLoader(getModuleFilePath()).createModule(moduleModel);\n  }","id":38723,"modified_method":"@NotNull\n  @Override\n  public Module createModule(@NotNull ModifiableModuleModel moduleModel)\n    throws InvalidDataException, IOException, ModuleWithNameAlreadyExists, JDOMException, ConfigurationException {\n    final String path = getContentEntryPath();\n    unzip(path, true);\n    Module module = ImportImlMode.setUpLoader(getModuleFilePath()).createModule(moduleModel);\n    if (myProjectMode) {\n      moduleModel.renameModule(module, module.getProject().getName());\n    }\n    return module;\n  }","commit_id":"77c4322182237f4f22662a26254825dbff9f8d0b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Module commitModule(@NotNull Project project, ModifiableModuleModel model) {\n    if (myProjectMode) {\n      final Module[] modules = ModuleManager.getInstance(project).getModules();\n      if (modules.length > 0) {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            try {\n              setupModule(modules[0]);\n            }\n            catch (ConfigurationException e) {\n              LOG.error(e);\n            }\n          }\n        });\n      }\n      return null;\n    }\n    else {\n      return super.commitModule(project, model);\n    }\n  }","id":38724,"modified_method":"@Override\n  public Module commitModule(@NotNull final Project project, ModifiableModuleModel model) {\n    if (myProjectMode) {\n      final Module[] modules = ModuleManager.getInstance(project).getModules();\n      if (modules.length > 0) {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            try {\n              Module module = modules[0];\n              setupModule(module);\n              ModifiableModuleModel modifiableModuleModel = ModuleManager.getInstance(project).getModifiableModel();\n              modifiableModuleModel.renameModule(module, module.getProject().getName());\n              modifiableModuleModel.commit();\n            }\n            catch (ConfigurationException e) {\n              LOG.error(e);\n            }\n            catch (ModuleWithNameAlreadyExists exists) {\n              // do nothing\n            }\n          }\n        });\n      }\n      return null;\n    }\n    else {\n      return super.commitModule(project, model);\n    }\n  }","commit_id":"77c4322182237f4f22662a26254825dbff9f8d0b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void valueChanged(ListSelectionEvent e)\n    {\n        if(!e.getValueIsAdjusting())\n        {\n            ConfigurationForm configForm\n                = (ConfigurationForm) this.getSelectedValue();\n            \n            configFrame.showFormContent(configForm);\n        }\n    }","id":38725,"modified_method":"/**\n     * Called when user selects a component in the list of configuration forms.\n     */\n    public void valueChanged(ListSelectionEvent e)\n    {\n        if(!e.getValueIsAdjusting())\n        {\n            ConfigFormDescriptor configFormDescriptor\n                = (ConfigFormDescriptor) this.getSelectedValue();\n            \n            if(configFormDescriptor != null)\n                configFrame.showFormContent(configFormDescriptor);\n        }\n    }","commit_id":"5bc411aab193170f628b514aa541252294ad607c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes a <tt>ConfigurationForm<\/tt> from this list. \n     * @param configForm The <tt>ConfigurationForm<\/tt> to remove.\n     */\n    public void removeConfigForm(ConfigurationForm configForm)\n    {\n        listModel.removeElement(configForm);\n    }","id":38726,"modified_method":"/**\n     * Removes a <tt>ConfigurationForm<\/tt> from this list. \n     * @param configForm The <tt>ConfigurationForm<\/tt> to remove.\n     */\n    public void removeConfigForm(ConfigurationForm configForm)\n    {\n        for(int i = 0; i < listModel.getSize(); i ++)\n        {\n            ConfigFormDescriptor descriptor\n                = (ConfigFormDescriptor) listModel.get(i);\n            \n            if(descriptor.getConfigForm().equals(configForm))\n                listModel.removeElement(descriptor);\n        }\n    }","commit_id":"5bc411aab193170f628b514aa541252294ad607c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a new <tt>ConfigurationForm<\/tt> to this list. \n     * @param configForm The <tt>ConfigurationForm<\/tt> to add.\n     */\n    public void addConfigForm(ConfigurationForm configForm)\n    {\n        listModel.addElement(configForm);\n    }","id":38727,"modified_method":"/**\n     * Adds a new <tt>ConfigurationForm<\/tt> to this list. \n     * @param configForm The <tt>ConfigurationForm<\/tt> to add.\n     */\n    public void addConfigForm(ConfigFormDescriptor configForm)\n    {\n        listModel.addElement(configForm);\n    }","commit_id":"5bc411aab193170f628b514aa541252294ad607c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * \n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     */\n    public Component getListCellRendererComponent(JList list, Object value,\n            int index, boolean isSelected, boolean cellHasFocus)\n    {\n        ConfigurationForm configForm = (ConfigurationForm) value;\n        \n        byte[] configFormIcon = configForm.getIcon();\n        \n        if(configFormIcon != null)            \n            iconLabel.setIcon(new ImageIcon(ImageLoader.getBytesInImage(\n                    configFormIcon)));\n        \n        textLabel.setText(configForm.getTitle());\n        \n        this.isSelected = isSelected;\n\n        return this;\n    }","id":38728,"modified_method":"/**\n     * Implements the <tt>ListCellRenderer<\/tt> method.\n     * \n     * Returns this panel that has been configured to display the meta contact\n     * and meta contact group cells.\n     */\n    public Component getListCellRendererComponent(JList list, Object value,\n            int index, boolean isSelected, boolean cellHasFocus)\n    {\n        ConfigFormDescriptor cfDescriptor = (ConfigFormDescriptor) value;\n        \n        if(cfDescriptor.getConfigFormIcon() != null)            \n            iconLabel.setIcon(cfDescriptor.getConfigFormIcon());\n        \n        if(cfDescriptor.getConfigFormTitle() != null)\n            textLabel.setText(cfDescriptor.getConfigFormTitle());\n        \n        this.isSelected = isSelected;\n\n        return this;\n    }","commit_id":"5bc411aab193170f628b514aa541252294ad607c","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void showFormContent(ConfigurationForm configForm)\n    {\n        this.centerPanel.removeAll();\n        \n        this.titlePanel.setTitleText(configForm.getTitle());\n\n        this.centerPanel.add(titlePanel, BorderLayout.NORTH);\n\n        this.centerPanel.add((Component)configForm.getForm(),\n                BorderLayout.CENTER);\n        \n        this.centerPanel.revalidate();\n        this.centerPanel.repaint();\n     \n    }","id":38729,"modified_method":"/**\n     * Shows on the right the configuration form given by the given\n     * <tt>ConfigFormDescriptor<\/tt>.\n     * \n     * @param configFormDescriptor\n     */\n    public void showFormContent(ConfigFormDescriptor configFormDescriptor)\n    {\n        this.centerPanel.removeAll();\n        \n        this.titlePanel.setTitleText(configFormDescriptor.getConfigFormTitle());\n\n        this.centerPanel.add(titlePanel, BorderLayout.NORTH);\n\n        this.centerPanel.add(configFormDescriptor.getConfigFormPanel(),\n                BorderLayout.CENTER);\n        \n        this.centerPanel.revalidate();\n        this.centerPanel.repaint();\n     \n    }","commit_id":"5bc411aab193170f628b514aa541252294ad607c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <code>ConfigurationManager.addConfigurationForm<\/code>\n     * method. Checks if the form contained in the <tt>ConfigurationForm<\/tt>\n     * is an instance of java.awt.Component and if so adds the form in this\n     * dialog, otherwise throws a ClassCastException.\n     * @see ConfigurationWindow#addConfigurationForm(ConfigurationForm)\n     */\n    public void addConfigurationForm(ConfigurationForm configForm) {\n\n        if(configForm.getForm() instanceof Component)\n        {\n            this.configList.addConfigForm(configForm);\n    \n//            this.recalculateSize();\n            \n        }\n        else {\n            throw new ClassCastException(\"ConfigurationFrame :\"\n            + configForm.getForm().getClass()\n            + \" is not a class supported by this ui implementation\");\n        }\n    }","id":38730,"modified_method":"/**\n     * Implements the <code>ConfigurationManager.addConfigurationForm<\/code>\n     * method. Checks if the form contained in the <tt>ConfigurationForm<\/tt>\n     * is an instance of java.awt.Component and if so adds the form in this\n     * dialog, otherwise throws a ClassCastException.\n     * @see ConfigurationWindow#addConfigurationForm(ConfigurationForm)\n     */\n    public void addConfigurationForm(ConfigurationForm configForm)\n    {\n        ConfigFormDescriptor descriptor = new ConfigFormDescriptor(configForm);\n\n        if(descriptor != null)\n            configList.addConfigForm(descriptor);\n    }","commit_id":"5bc411aab193170f628b514aa541252294ad607c","url":"https://github.com/jitsi/jitsi"},{"original_method":"public DataSourceViewer(DRBrowser drBrowser){\n        \n        \n        setLayout(new BorderLayout());\n        setBorder(new TitledBorder(\"DataSource\"));\n        this.drBrowser = drBrowser;\n        resourcesPanel = new JPanel();\n        \n        dataSourceList = new DataSourceList(this);\n        dataSourceList.addKeyListener(this);\n        \n        \n        loadDataSources();\n        \n        // if (loadingFromFile)dataSourceChanged = false;\n        setPopup();\n        dataSourceList.addListSelectionListener(new ListSelectionListener() {\n            public void valueChanged(ListSelectionEvent e) {\n                \n                if ((DataSource)((JList)e.getSource()).getSelectedValue()!=null){\n                    System.out.print(\"do I get here?\");\n                    DataSourceViewer.this.setActiveDataSource(((DataSource)((JList)e.getSource()).getSelectedValue()));\n                    \n                    \n                }}\n        });\n        dataSourceList.addMouseListener(new MouseAdapter() {\n            public void mouseClicked(MouseEvent e) {\n                if(e.getButton() == e.BUTTON3) {\n                    popup.show(e.getComponent(), e.getX(), e.getY());\n                }\n            }\n        });\n        \n        \n        // GRID: addConditionButton\n        JButton addButton=new VueButton(\"add\");\n        addButton.setBackground(this.getBackground());\n        addButton.setToolTipText(\"Add/Edit Datasource Information\");\n        \n        addButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                showAddEditWindow(0);\n                \n            }\n        });\n        \n        \n        // GRID: deleteConditionButton\n        JButton deleteButton=new VueButton(\"delete\");\n        deleteButton.setBackground(this.getBackground());\n        deleteButton.setToolTipText(\"Remove a Datasource from VUE\");\n        \n        deleteButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                deleteDataSource(activeDataSource);\n                \n                refreshDataSourceList();\n                if (!dataSourceList.getContents().isEmpty())dataSourceList.setSelectedIndex(0);\n                else{\n                    DataSourceViewer.this.drBrowser.remove(resourcesPanel);\n                    DataSourceViewer.this.resourcesPanel  = new JPanel();\n                    DataSourceViewer.this.drBrowser.add(resourcesPanel,BorderLayout.CENTER);\n                    DataSourceViewer.this.drBrowser.repaint();\n                    DataSourceViewer.this.drBrowser.validate();\n                }\n            }\n        });\n        \n        \n        // GRID: addConditionButton\n        \n        \n        JButton refreshButton=new VueButton(\"refresh\");\n        \n        refreshButton.setBackground(this.getBackground());\n        refreshButton.setToolTipText(\"Refresh Local Datasource\");\n        \n        refreshButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                activeDataSource.setResourceViewer();\n                refreshDataSourceList();\n                \n            }\n        });\n        \n        \n        JLabel questionLabel = new JLabel(VueResources.getImageIcon(\"smallInfo\"), JLabel.LEFT);\n        questionLabel.setPreferredSize(new Dimension(22, 17));\n        questionLabel.setToolTipText(\"Add/Delete/Refresh a Data Source\");\n        \n        JPanel topPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT,2,0));\n        \n        \n        topPanel.add(addButton);\n        topPanel.add(deleteButton);\n        topPanel.add(refreshButton);\n        topPanel.add(questionLabel);\n        \n        \n        \n        dataSourcePanel = new JPanel();\n        dataSourcePanel.setLayout(new BorderLayout());\n        dataSourcePanel.add(topPanel,BorderLayout.NORTH);\n        \n        \n        JScrollPane dataJSP = new JScrollPane(dataSourceList);\n        dataSourcePanel.add(dataJSP,BorderLayout.CENTER);\n        add(dataSourcePanel,BorderLayout.CENTER);\n        drBrowser.add(resourcesPanel,BorderLayout.CENTER);\n        \n        \n        \n    }","id":38731,"modified_method":"public DataSourceViewer(DRBrowser drBrowser){\n        \n        \n        setLayout(new BorderLayout());\n        setBorder(new TitledBorder(\"DataSource\"));\n        this.drBrowser = drBrowser;\n        resourcesPanel = new JPanel();\n        \n        dataSourceList = new DataSourceList(this);\n        dataSourceList.addKeyListener(this);\n        \n        \n        loadDataSources();\n        \n        // if (loadingFromFile)dataSourceChanged = false;\n        setPopup();\n        dataSourceList.addListSelectionListener(new ListSelectionListener() {\n            public void valueChanged(ListSelectionEvent e) {\n                \n                if ((DataSource)((JList)e.getSource()).getSelectedValue()!=null){\n                    DataSourceViewer.this.setActiveDataSource(((DataSource)((JList)e.getSource()).getSelectedValue()));\n                    \n                    \n                }}\n        });\n        dataSourceList.addMouseListener(new MouseAdapter() {\n            public void mouseClicked(MouseEvent e) {\n                if(e.getButton() == e.BUTTON3) {\n                    popup.show(e.getComponent(), e.getX(), e.getY());\n                }\n            }\n        });\n        \n        \n        // GRID: addConditionButton\n        JButton addButton=new VueButton(\"add\");\n        addButton.setBackground(this.getBackground());\n        addButton.setToolTipText(\"Add/Edit Datasource Information\");\n        \n        addButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                showAddEditWindow(0);\n                \n            }\n        });\n        \n        \n        // GRID: deleteConditionButton\n        JButton deleteButton=new VueButton(\"delete\");\n        deleteButton.setBackground(this.getBackground());\n        deleteButton.setToolTipText(\"Remove a Datasource from VUE\");\n        \n        deleteButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                deleteDataSource(activeDataSource);\n                \n                refreshDataSourceList();\n                if (!dataSourceList.getContents().isEmpty())dataSourceList.setSelectedIndex(0);\n                else{\n                    DataSourceViewer.this.drBrowser.remove(resourcesPanel);\n                    DataSourceViewer.this.resourcesPanel  = new JPanel();\n                    DataSourceViewer.this.drBrowser.add(resourcesPanel,BorderLayout.CENTER);\n                    DataSourceViewer.this.drBrowser.repaint();\n                    DataSourceViewer.this.drBrowser.validate();\n                }\n            }\n        });\n        \n        \n        // GRID: addConditionButton\n        \n        \n        JButton refreshButton=new VueButton(\"refresh\");\n        \n        refreshButton.setBackground(this.getBackground());\n        refreshButton.setToolTipText(\"Refresh Local Datasource\");\n        \n        refreshButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                activeDataSource.setResourceViewer();\n                refreshDataSourceList();\n                \n            }\n        });\n        \n        \n        JLabel questionLabel = new JLabel(VueResources.getImageIcon(\"smallInfo\"), JLabel.LEFT);\n        questionLabel.setPreferredSize(new Dimension(22, 17));\n        questionLabel.setToolTipText(\"Add/Delete/Refresh a Data Source\");\n        \n        JPanel topPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT,2,0));\n        \n        \n        topPanel.add(addButton);\n        topPanel.add(deleteButton);\n        topPanel.add(refreshButton);\n        topPanel.add(questionLabel);\n        \n        \n        \n        dataSourcePanel = new JPanel();\n        dataSourcePanel.setLayout(new BorderLayout());\n        dataSourcePanel.add(topPanel,BorderLayout.NORTH);\n        \n        \n        JScrollPane dataJSP = new JScrollPane(dataSourceList);\n        dataSourcePanel.add(dataJSP,BorderLayout.CENTER);\n        add(dataSourcePanel,BorderLayout.CENTER);\n        drBrowser.add(resourcesPanel,BorderLayout.CENTER);\n        \n        \n        \n    }","commit_id":"54ffacabd0c2986157138643ceaa59b0b7303baa","url":"https://github.com/VUE/VUE"},{"original_method":"public void deleteDataSource(DataSource ds){\n        \n        int type;\n        \n        if (ds instanceof LocalFileDataSource) type = 0;\n        else if (ds instanceof FavoritesDataSource) type = 1;\n        else  if (ds instanceof RemoteFileDataSource) type = 2;\n        else  if (ds instanceof FedoraDataSource) type = 3;\n        else  if (ds instanceof GoogleDataSource) type = 4;\n        else  if (ds instanceof OsidDataSource) type = 5;\n        else type = 6;\n        \n        Vector dataSourceVector = (Vector)allDataSources.get(type);\n        dataSourceVector.removeElement(ds);\n        \n        \n    }","id":38732,"modified_method":"public void deleteDataSource(DataSource ds){\n        \n        int type;\n        \n        if (ds instanceof LocalFileDataSource) type = 0;\n        else if (ds instanceof FavoritesDataSource) type = 1;\n        else  if (ds instanceof RemoteFileDataSource) type = 2;\n        else  if (ds instanceof FedoraDataSource) type = 3;\n        else  if (ds instanceof GoogleDataSource) type = 4;\n        else  if (ds instanceof OsidDataSource) type = 5;\n        else type = 6;\n        if(JOptionPane.showConfirmDialog(this,\"Are you sure you want to delete DataSource :\"+ds.getDisplayName(),\"Delete DataSource Confirmation\",JOptionPane.YES_NO_OPTION) == JOptionPane.OK_OPTION) {   \n            Vector dataSourceVector = (Vector)allDataSources.get(type);\n            dataSourceVector.removeElement(ds);\n        }\n        \n        \n    }","commit_id":"54ffacabd0c2986157138643ceaa59b0b7303baa","url":"https://github.com/VUE/VUE"},{"original_method":"private void resetPanel() {\n            dsNameField.setText(cDsNameField);\n            addressField.setText(cAddressField);\n        }","id":38733,"modified_method":"private void resetPanel() {\n            dsNameField.setText(cDsNameField);\n            addressField.setText(cAddressField);\n            siteField.setText(cSiteField);\n            clientField.setText(cClientField);\n        }","commit_id":"54ffacabd0c2986157138643ceaa59b0b7303baa","url":"https://github.com/VUE/VUE"},{"original_method":"public GoogleDataSourcePanel(GoogleDataSource dataSource) {\n            this.dataSource = dataSource;\n            cDsNameField = dataSource.getDisplayName();\n            cAddressField = dataSource.getAddress();\n            GridBagLayout gridbag = new GridBagLayout();\n            GridBagConstraints c = new GridBagConstraints();\n            this.setLayout(gridbag);\n            JLabel dsNameLabel = new JLabel(\"Display Name: \");\n            JLabel addressLabel = new JLabel(\"Address:\");\n            dsNameField = new JTextField();\n            addressField = new JTextField();\n            \n            JPanel bottomPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));\n            JButton submitButton = new JButton(\"Submit\");\n            submitButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e){\n                    if(validateFields()) {\n                        GoogleDataSourcePanel.this.dataSource.setDisplayName(dsNameField.getText());\n                        GoogleDataSourcePanel.this.dataSource.setAddress(addressField.getText());\n                        dialog.hide();\n                        dialog.dispose();\n                    }\n                }\n            });\n            \n            JButton resetButton = new JButton(\"Reset\");\n            resetButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e){\n                    resetPanel();\n                }\n            });\n            bottomPanel.add(submitButton);\n            bottomPanel.add(resetButton);\n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            c.fill = GridBagConstraints.NONE;\n            c.weightx = 0.0;\n            gridbag.setConstraints(dsNameLabel,c);\n            this.add(dsNameLabel);\n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            c.weightx = 1.0;\n            gridbag.setConstraints(dsNameField,c);\n            this.add(dsNameField);\n            \n            c.gridwidth = GridBagConstraints.RELATIVE;\n            c.fill = GridBagConstraints.NONE;\n            c.weightx = 0.0;\n            gridbag.setConstraints(addressLabel,c);\n            this.add(addressLabel);\n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            c.weightx = 1.0;\n            gridbag.setConstraints(addressField,c);\n            this.add(addressField);\n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.weightx = 1.0;\n            c.fill = GridBagConstraints.NONE;\n            gridbag.setConstraints(bottomPanel,c);\n            this.add(bottomPanel);\n            resetPanel();\n        }","id":38734,"modified_method":"public GoogleDataSourcePanel(GoogleDataSource dataSource) {\n            this.dataSource = dataSource;\n            cDsNameField = dataSource.getDisplayName();\n            cAddressField = dataSource.getUrl();\n            cSiteField  = dataSource.getSite();\n            cClientField = dataSource.getClient();\n            GridBagLayout gridbag = new GridBagLayout();\n            GridBagConstraints c = new GridBagConstraints();\n            this.setLayout(gridbag);\n            JLabel dsNameLabel = new JLabel(\"Display Name: \");\n            JLabel addressLabel = new JLabel(\"Address:\");\n            JLabel siteLabel = new JLabel(\"Site:\");\n            JLabel clientLabel = new JLabel(\"Client:\");\n            dsNameField = new JTextField();\n            addressField = new JTextField();\n            siteField = new JTextField();\n            clientField = new JTextField();\n            JPanel bottomPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));\n            JButton submitButton = new JButton(\"Submit\");\n            submitButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e){\n                    if(validateFields()) {\n                        GoogleDataSourcePanel.this.dataSource.setDisplayName(dsNameField.getText());\n                        GoogleDataSourcePanel.this.dataSource.setUrl(addressField.getText());\n                        GoogleDataSourcePanel.this.dataSource.setClient(clientField.getText());\n                        GoogleDataSourcePanel.this.dataSource.setSite(siteField.getText());\n                        dialog.hide();\n                        dialog.dispose();\n                    }\n                }\n            });\n            \n            JButton resetButton = new JButton(\"Reset\");\n            resetButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e){\n                    resetPanel();\n                }\n            });\n            bottomPanel.add(submitButton);\n            bottomPanel.add(resetButton);\n            c.anchor = GridBagConstraints.WEST;\n            c.gridwidth = GridBagConstraints.RELATIVE;\n            c.fill = GridBagConstraints.NONE;\n            c.weightx = 0.0;\n            gridbag.setConstraints(dsNameLabel,c);\n            this.add(dsNameLabel);\n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            c.weightx = 1.0;\n            gridbag.setConstraints(dsNameField,c);\n            this.add(dsNameField);\n            \n            c.gridwidth = GridBagConstraints.RELATIVE;\n            c.fill = GridBagConstraints.NONE;\n            c.weightx = 0.0;\n            gridbag.setConstraints(addressLabel,c);\n            this.add(addressLabel);\n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            c.weightx = 1.0;\n            gridbag.setConstraints(addressField,c);\n            this.add(addressField);\n            \n            c.gridwidth = GridBagConstraints.RELATIVE;\n            c.fill = GridBagConstraints.NONE;\n            c.weightx = 0.0;\n            gridbag.setConstraints(siteLabel,c);\n            this.add(siteLabel);\n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            c.weightx = 1.0;\n            gridbag.setConstraints(siteField,c);\n            this.add(siteField);\n            \n            c.gridwidth = GridBagConstraints.RELATIVE;\n            c.fill = GridBagConstraints.NONE;\n            c.weightx = 0.0;\n            gridbag.setConstraints(clientLabel,c);\n            this.add(clientLabel);\n            \n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.fill = GridBagConstraints.HORIZONTAL;\n            c.weightx = 1.0;\n            gridbag.setConstraints(clientField,c);\n            this.add(clientField);\n            \n            c.anchor = GridBagConstraints.EAST;\n            c.gridwidth = GridBagConstraints.REMAINDER;\n            c.weightx = 1.0;\n            c.fill = GridBagConstraints.NONE;\n            gridbag.setConstraints(bottomPanel,c);\n            this.add(bottomPanel);\n            resetPanel();\n        }","commit_id":"54ffacabd0c2986157138643ceaa59b0b7303baa","url":"https://github.com/VUE/VUE"},{"original_method":"public void  setResourceViewer(){\n             \n       try{\n         \n        \n         this.resourceViewer = new TuftsGoogle(this.getDisplayName(),this.getAddress());\n              \n       }catch (Exception ex){VueUtil.alert(null,ex.getMessage(),\"Error Setting Reseource Viewer\");}; \n   }","id":38735,"modified_method":"public void  setResourceViewer(){\n        \n        try{\n            this.resourceViewer = new TuftsGoogle(this.getDisplayName(),this.getAddress());\n            DataSourceViewer.refreshDataSourcePanel(this);\n        }catch (Exception ex){VueUtil.alert(null,ex.getMessage(),\"Error Setting Reseource Viewer\");};\n    }","commit_id":"54ffacabd0c2986157138643ceaa59b0b7303baa","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters. \n     * \n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    \n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, \n            Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \" \n                    + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \" \n                    + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \" \n                    + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsRequestContext reqCont = cms.getRequestContext();\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n        boolean userYetChanged = true;\n        boolean userYetEstablished = true;\n        \n        // find out which template (=perspective) should be used \n        String perspective = (String)parameters.get(\"perspective\");\n        if(perspective != null && perspective.equals(\"user\")) {\n            session.removeValue(\"ERROR\");\n            if(reqCont.getRequest().getParameter(\"CHANGE\") != null) {\n                \n                // change data of selected user\n                perspective = \"changeuser\";\n                userYetChanged = false;\n            }\n            else {\n                if(reqCont.getRequest().getParameter(\"DELETE\") != null) {\n                    \n                    // delete the selected user\n                    perspective = \"deleteuser\";\n                }\n                else {\n                    if(reqCont.getRequest().getParameter(\"NEW\") != null) {\n                        \n                        // establish a new user\n                        perspective = \"newuser\";\n                        userYetEstablished = false;\n                    }\n                }\n            }\n        }\n        if(perspective == null) {\n            \n            // display the first template, which lets you chose the action\n            perspective = new String(\"user\");\n        }\n        if(perspective.equals(\"newuser\") || perspective.equals(\"changeuser\")) {\n            \n            // first the common part of the two actions:\n            \n            // read the common parameters like first name, description, ...\n            String firstname, desc, street, pwd, pwd2, user, userLastname, town, zipcode, \n                    email, defaultGroup;\n            if(session.getValue(\"ERROR\") == null) {\n                firstname = (String)parameters.get(\"USERFIRSTNAME\");\n                desc = (String)parameters.get(\"USERDESC\");\n                street = (String)parameters.get(\"USERSTREET\");\n                pwd = (String)parameters.get(\"PWD\");\n                pwd2 = (String)parameters.get(\"PWD2\");\n                user = (String)parameters.get(\"USER\");\n                userLastname = (String)parameters.get(\"USERNAME\");\n                town = (String)parameters.get(\"TOWN\");\n                zipcode = (String)parameters.get(\"ZIP\");\n                email = (String)parameters.get(\"USEREMAIL\");\n                defaultGroup = (String)parameters.get(\"DEFAULTGROUP\");\n            }\n            else {\n                \n                // an error has occurred before, retrieve the form data from the session\n                firstname = (String)session.getValue(\"USERFIRSTNAME\");\n                desc = (String)session.getValue(\"USERDESC\");\n                street = (String)session.getValue(\"USERSTREET\");\n                pwd = (String)session.getValue(\"PWD\");\n                pwd2 = (String)session.getValue(\"PWD2\");\n                user = (String)session.getValue(\"USER\");\n                userLastname = (String)session.getValue(\"USERNAME\");\n                town = (String)session.getValue(\"TOWN\");\n                zipcode = (String)session.getValue(\"ZIP\");\n                email = (String)session.getValue(\"USEREMAIL\");\n                defaultGroup = (String)session.getValue(\"DEFAULTGROUP\");\n                session.removeValue(\"ERROR\");\n            }\n            if(firstname == null) {\n                firstname = \"\";\n            }\n            if(desc == null) {\n                desc = \"\";\n            }\n            if(street == null) {\n                street = \"\";\n            }\n            if(pwd == null) {\n                pwd = \"\";\n            }\n            if(pwd2 == null) {\n                pwd2 = \"\";\n            }\n            if(user == null) {\n                user = \"\";\n            }\n            if(userLastname == null) {\n                userLastname = \"\";\n            }\n            if(town == null) {\n                town = \"\";\n            }\n            if(zipcode == null) {\n                zipcode = \"\";\n            }\n            if(email == null) {\n                email = \"\";\n            }\n            if(defaultGroup == null) {\n                defaultGroup = \"\";\n            }\n            \n            // vectors of Strings that hold the selected and not selected Groups\n            Vector selectedGroups = (Vector)session.getValue(\"selectedGroups\");\n            Vector notSelectedGroups = (Vector)session.getValue(\"notSelectedGroups\");\n            if(perspective.equals(\"newuser\")) {\n                \n                // input is the form for establishing new users\n                templateSelector = \"newuser\";\n                if(!userYetEstablished) {\n                    \n                    // first time the form is visited\n                    user = \"\";\n                    selectedGroups = new Vector();\n                    notSelectedGroups = new Vector();\n                    selectedGroups.addElement(C_GROUP_USERS); // preselect Users\n                    Vector groups = cms.getGroups();\n                    for(int z = 0;z < groups.size();z++) {\n                        String aName = (String)((CmsGroup)groups.elementAt(z)).getName();\n                        if(!C_GROUP_USERS.equals(aName)) {\n                            notSelectedGroups.addElement(aName);\n                        }\n                    }\n                    session.putValue(\"selectedGroups\", selectedGroups);\n                    session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                }\n                if(reqCont.getRequest().getParameter(\"ADD\") != null) {\n                    \n                    // add a new group to selectedGroups \n                    String groupname = (String)parameters.get(\"notselectgroup\");\n                    if(groupname != null) {\n                        selectedGroups.addElement(groupname);\n                        notSelectedGroups.removeElement(groupname);\n                    }\n                    session.putValue(\"selectedGroups\", selectedGroups);\n                    session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                }\n                else {\n                    if(reqCont.getRequest().getParameter(\"REMOVE\") != null) {\n                        \n                        // delete a new group from selectedGroups                         \n                        // and move it to notSelectedGroups\n                        String groupname = (String)parameters.get(\"selectgroup\");\n                        if(groupname != null) {\n                            notSelectedGroups.addElement(groupname);\n                            selectedGroups.removeElement(groupname);\n                            if(groupname.equals(defaultGroup)) {\n                                defaultGroup = \"\";\n                            }\n                        }\n                        session.putValue(\"selectedGroups\", selectedGroups);\n                        session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                    }\n                    else {\n                        if(reqCont.getRequest().getParameter(\"OK\") != null) {\n                            \n                            // form submitted, try to establish new user\n                            try {\n                                if(email.equals(\"\") || userLastname.equals(\"\") \n                                        || user.equals(\"\")) {\n                                    throw new CmsException(\"user data missing\", \n                                            CmsException.C_NO_USER);\n                                }\n                                if(!pwd.equals(pwd2)) {\n                                    throw new CmsException(\"unequal passwords\", \n                                            CmsException.C_SHORT_PASSWORD);\n                                }\n                                if(pwd.length() < C_PASSWORD_MINIMUMSIZE) {\n                                    throw new CmsException(\"password too short\", \n                                            CmsException.C_SHORT_PASSWORD);\n                                }\n                                Hashtable additionalInfo = new Hashtable();\n                                \n                                // additionalInfo.put(C_ADDITIONAL_INFO_ZIPCODE, zipcode);                                \n                                // additionalInfo.put(C_ADDITIONAL_INFO_TOWN, town);\n                                CmsUser newUser = cms.addUser(user, pwd, defaultGroup, desc, \n                                        additionalInfo, C_FLAG_ENABLED);\n                                newUser.setEmail(email);\n                                newUser.setFirstname(firstname);\n                                newUser.setLastname(userLastname);\n                                newUser.setAddress(street);\n                                newUser.setAdditionalInfo(C_ADDITIONAL_INFO_ZIPCODE, zipcode);\n                                newUser.setAdditionalInfo(C_ADDITIONAL_INFO_TOWN, town);\n                                for(int z = 0;z < selectedGroups.size();z++) {\n                                    String groupname = (String)selectedGroups.elementAt(z);\n                                    if(!groupname.equals(defaultGroup)) {\n                                        cms.addUserToGroup(user, groupname);\n                                    }\n                                }\n                                cms.writeUser(newUser); // update in the database\n                                session.removeValue(\"selectedGroups\");\n                                session.removeValue(\"notSelectedGroups\");\n                                session.removeValue(\"ERROR\");\n                                templateSelector = \"\"; //successful\n                            }\n                            catch(CmsException e) {\n                                \n                                // save the form data in the session, so it can be displayed again later\n                                session.putValue(\"ERROR\", new String(\"yes\")); // remeber that an error has occurred\n                                session.putValue(\"USERFIRSTNAME\", firstname);\n                                session.putValue(\"USERDESC\", desc);\n                                session.putValue(\"USERSTREET\", street);\n                                session.putValue(\"PWD\", pwd);\n                                session.putValue(\"PWD2\", pwd2);\n                                session.putValue(\"USER\", user);\n                                session.putValue(\"USERNAME\", userLastname);\n                                session.putValue(\"ZIP\", zipcode);\n                                session.putValue(\"TOWN\", town);\n                                session.putValue(\"USEREMAIL\", email);\n                                session.putValue(\"DEFAULTGROUP\", defaultGroup);\n                                if(e.getType() == CmsException.C_SHORT_PASSWORD) {\n                                    if(e.getMessage().equals(\"unequal passwords\")) {\n                                        templateSelector = \"passworderror1\";\n                                    }\n                                    else {\n                                        if(e.getMessage().equals(\"password too short\")) {\n                                            templateSelector = \"passworderror2\";\n                                        }\n                                        else {\n                                            throw e;\n                                        }\n                                    }\n                                }\n                                else {\n                                    if(e.getType() == CmsException.C_NO_GROUP) {\n                                        templateSelector = \"errornogroup1\";\n                                    }\n                                    else {\n                                        if(e.getType() == CmsException.C_NO_USER \n                                                && e.getMessage().equals(\"user data missing\")) {\n                                            templateSelector = \"errordatamissing1\";\n                                        }\n                                        else {\n                                            throw e; // hand the exception down\n                                        }\n                                    }\n                                }\n                            } // catch block\n                        } // OK\n                    }\n                }\n            }\n            else {\n                \n                // input is the form for changing the user data\n                templateSelector = \"changeuser\";\n                boolean disabled = false;\n                if(!userYetChanged) {\n                    \n                    // form visited for the first time, not yet changed                    \n                    // read the data from the user object\n                    CmsUser theUser = (CmsUser)cms.readUser(user);\n                    if(theUser == null) {\n                        throw new CmsException(\"user does not exist\");\n                    }\n                    firstname = theUser.getFirstname();\n                    desc = theUser.getDescription();\n                    street = theUser.getAddress();\n                    userLastname = theUser.getLastname();\n                    email = theUser.getEmail();\n                    disabled = theUser.getDisabled();\n                    zipcode = (String)theUser.getAdditionalInfo(C_ADDITIONAL_INFO_ZIPCODE);\n                    town = (String)theUser.getAdditionalInfo(C_ADDITIONAL_INFO_TOWN);\n                    defaultGroup = theUser.getDefaultGroup().getName();\n                    Vector groups = cms.getDirectGroupsOfUser(user);\n                    if(groups != null) {\n                        selectedGroups = new Vector();\n                        for(int z = 0;z < groups.size();z++) {\n                            selectedGroups.addElement(((CmsGroup)groups.elementAt(z)).getName());\n                        }\n                    }\n                    else {\n                        throw new CmsException(CmsException.C_NO_GROUP);\n                    }\n                    groups = cms.getGroups();\n                    if(groups != null) {\n                        notSelectedGroups = new Vector();\n                        for(int z = 0;z < groups.size();z++) {\n                            String name = ((CmsGroup)groups.elementAt(z)).getName();\n                            if(!selectedGroups.contains(name)) {\n                                notSelectedGroups.addElement(name);\n                            }\n                        }\n                    }\n                }\n                else {\n                    \n                    // fetch data from the form\t\t\n                    if((String)parameters.get(\"LOCK\") != null) {\n                        disabled = true;\n                    }\n                    if(reqCont.getRequest().getParameter(\"ADD\") != null) {\n                        \n                        // add a new group to selectedGroups \n                        String groupname = (String)parameters.get(\"notselectgroup\");\n                        if(groupname != null) {\n                            selectedGroups.addElement(groupname);\n                            notSelectedGroups.removeElement(groupname);\n                        }\n                    }\n                    else {\n                        if(reqCont.getRequest().getParameter(\"REMOVE\") != null) {\n                            \n                            // delete a group from selectedGroups                             \n                            // and move it to notSelectedGroups\n                            String groupname = (String)parameters.get(\"selectgroup\");\n                            if(groupname != null) {\n                                notSelectedGroups.addElement(groupname);\n                                selectedGroups.removeElement(groupname);\n                                if(groupname.equals(defaultGroup)) {\n                                    defaultGroup = \"\";\n                                }\n                            }\n                        }\n                        else {\n                            if(reqCont.getRequest().getParameter(\"OK\") != null) {\n                                \n                                // form submitted, try to change the user data\n                                try {\n                                    if(email.equals(\"\") || userLastname.equals(\"\") \n                                            || user.equals(\"\")) {\n                                        throw new CmsException(\"user data missing\", \n                                                CmsException.C_NO_USER);\n                                    }\n                                    if(!pwd.equals(pwd2)) {\n                                        throw new CmsException(\"unequal passwords\", \n                                                CmsException.C_SHORT_PASSWORD);\n                                    }\n                                    if(!pwd.equals(\"\")) {\n                                        if(pwd.length() < C_PASSWORD_MINIMUMSIZE) {\n                                            throw new CmsException(\"password too short\", \n                                                    CmsException.C_SHORT_PASSWORD);\n                                        }\n                                        cms.setPassword(user, pwd);\n                                    } // if nothing is entered don't change the password \n                                    CmsUser theUser = (CmsUser)cms.readUser(user);\n                                    theUser.setEmail(email);\n                                    theUser.setFirstname(firstname);\n                                    theUser.setLastname(userLastname);\n                                    theUser.setAddress(street);\n                                    theUser.setAdditionalInfo(C_ADDITIONAL_INFO_ZIPCODE, zipcode);\n                                    theUser.setAdditionalInfo(C_ADDITIONAL_INFO_TOWN, town);\n                                    if((C_USER_ADMIN.equals(theUser.getName())) \n                                            && (!selectedGroups.contains(C_GROUP_ADMIN))) {\n                                        throw new CmsException(\"cant remove Admin from \" \n                                                + C_GROUP_ADMIN, CmsException.C_NOT_ADMIN);\n                                    }\n                                    if(disabled && selectedGroups.contains(C_GROUP_ADMIN)) {\n                                        throw new CmsException(\"disabled admin\", \n                                                 CmsException.C_NOT_ADMIN);\n                                    }\n                                    if(disabled == true) {\n                                        theUser.setDisabled();\n                                    }\n                                    else {\n                                        theUser.setEnabled();\n                                    }\n                                    changeGroups(cms, theUser, defaultGroup, selectedGroups);\n                                    session.removeValue(\"selectedGroups\");\n                                    session.removeValue(\"notSelectedGroups\");\n                                    session.removeValue(\"DEFAULTGROUP\");\n                                    session.removeValue(\"ERROR\");\n                                    templateSelector = \"\"; //successful\n                                }\n                                catch(CmsException e) {\n                                    session.putValue(\"ERROR\", new String(\"yes\")); // remeber that an error has occurred\n                                    session.putValue(\"USERFIRSTNAME\", firstname);\n                                    session.putValue(\"USERDESC\", desc);\n                                    session.putValue(\"USERSTREET\", street);\n                                    session.putValue(\"PWD\", pwd);\n                                    session.putValue(\"PWD2\", pwd2);\n                                    session.putValue(\"USER\", user);\n                                    session.putValue(\"USERNAME\", userLastname);\n                                    session.putValue(\"ZIP\", zipcode);\n                                    session.putValue(\"TOWN\", town);\n                                    session.putValue(\"USEREMAIL\", email);\n                                    session.putValue(\"DEFAULTGROUP\", defaultGroup);\n                                    if(e.getType() == CmsException.C_SHORT_PASSWORD) {\n                                        if(e.getMessage().equals(\"unequal passwords\")) {\n                                            templateSelector = \"passworderror3\";\n                                        }\n                                        else {\n                                            if(e.getMessage().equals(\"password too short\")) {\n                                                templateSelector = \"passworderror4\";\n                                            }\n                                            else {\n                                                throw e;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        if(e.getType() == CmsException.C_NO_GROUP) {\n                                            templateSelector = \"errornogroup2\";\n                                        }\n                                        else {\n                                            if(e.getType() == CmsException.C_NO_USER \n                                                    && e.getMessage().equals(\"user data missing\")) {\n                                                templateSelector = \"errordatamissing2\";\n                                            }\n                                            else {\n                                                if(e.getType() == CmsException.C_NOT_ADMIN \n                                                        && e.getMessage().equals(\"disabled admin\")) {\n                                                    templateSelector = \"errordisabledadmin\";\n                                                }\n                                                else {\n                                                    throw e; // hand the exception down\n                                                }\n                                            }\n                                        }\n                                    }\n                                } // catch block\n                            } // OK\n                        }\n                    }\n                } // userYetEstablished\n                session.putValue(\"selectedGroups\", selectedGroups);\n                session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                session.putValue(\"DEFAULTGROUP\", defaultGroup);\n                xmlTemplateDocument.setData(\"DISABLED\", disabled ? \"checked\" : \"\");\n            }\n            \n            // again common part for 'newuser' and 'changeuser':            \n            // set the variables for display in the document\n            if(firstname == null) {\n                firstname = \"\";\n            }\n            if(desc == null) {\n                desc = \"\";\n            }\n            if(street == null) {\n                street = \"\";\n            }\n            if(pwd == null) {\n                pwd = \"\";\n            }\n            if(pwd2 == null) {\n                pwd2 = \"\";\n            }\n            if(user == null) {\n                user = \"\";\n            }\n            if(userLastname == null) {\n                userLastname = \"\";\n            }\n            if(town == null) {\n                town = \"\";\n            }\n            if(zipcode == null) {\n                zipcode = \"\";\n            }\n            if(email == null) {\n                email = \"\";\n            }\n            xmlTemplateDocument.setData(\"USERFIRSTNAME\", firstname);\n            xmlTemplateDocument.setData(\"USERDESC\", desc);\n            xmlTemplateDocument.setData(\"USERSTREET\", street);\n            xmlTemplateDocument.setData(\"PWD\", pwd);\n            xmlTemplateDocument.setData(\"PWD2\", pwd2);\n            xmlTemplateDocument.setData(\"USER\", user);\n            xmlTemplateDocument.setData(\"USERNAME\", userLastname);\n            xmlTemplateDocument.setData(\"TOWN\", town);\n            xmlTemplateDocument.setData(\"ZIP\", zipcode);\n            xmlTemplateDocument.setData(\"EMAIL\", email);\n        } // belongs to: 'if perspective is newuser or changeuser'\n        else {\n            if(perspective.equals(\"deleteuser\")) {\n                String user = (String)parameters.get(\"USER\");\n                xmlTemplateDocument.setData(\"USER\", user);\n                templateSelector = \"RUsureDelete\";\n            }\n            else {\n                if(perspective.equals(\"reallydeleteuser\")) {\n                    \n                    // deleting a user\n                    String user = (String)parameters.get(\"USER\");\n                    try {\n                        cms.deleteUser(user);\n                        templateSelector = \"\";\n                    }\n                    catch(Exception e) {\n                        \n                        // user == null or delete failed\n                        xmlTemplateDocument.setData(\"DELETEDETAILS\", Utils.getStackTrace(e));\n                        templateSelector = \"deleteerror\";\n                    }\n                } // delete user\n            }\n        }\n        \n        // Now load the template file and start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, \n                templateSelector);\n    }","id":38736,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"getting content of element \"\n                    + ((elementName == null) ? \"<root>\" : elementName));\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"template file is: \"\n                    + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, this.getClassName() + \"selected template section is: \"\n                    + ((templateSelector == null) ? \"<default>\" : templateSelector));\n        }\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsRequestContext reqCont = cms.getRequestContext();\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n        boolean userYetChanged = true;\n        boolean userYetEstablished = true;\n\n        // find out which template (=perspective) should be used\n        String perspective = (String)parameters.get(\"perspective\");\n        if(perspective != null && perspective.equals(\"user\")) {\n            session.removeValue(\"ERROR\");\n            if(reqCont.getRequest().getParameter(\"CHANGE\") != null) {\n\n                // change data of selected user\n                perspective = \"changeuser\";\n                userYetChanged = false;\n            }\n            else {\n                if(reqCont.getRequest().getParameter(\"DELETE\") != null) {\n\n                    // delete the selected user\n                    perspective = \"deleteuser\";\n                }\n                else {\n                    if(reqCont.getRequest().getParameter(\"NEW\") != null) {\n\n                        // establish a new user\n                        perspective = \"newuser\";\n                        userYetEstablished = false;\n                    }\n                }\n            }\n        }\n        if(perspective == null) {\n\n            // display the first template, which lets you chose the action\n            perspective = new String(\"user\");\n        }\n        if(perspective.equals(\"newuser\") || perspective.equals(\"changeuser\")) {\n\n            // first the common part of the two actions:\n\n            // read the common parameters like first name, description, ...\n            String firstname, desc, street, pwd, pwd2, user, userLastname, town, zipcode,\n                    email, defaultGroup;\n            if(session.getValue(\"ERROR\") == null) {\n                firstname = (String)parameters.get(\"USERFIRSTNAME\");\n                desc = (String)parameters.get(\"USERDESC\");\n                street = (String)parameters.get(\"USERSTREET\");\n                pwd = (String)parameters.get(\"PWD\");\n                pwd2 = (String)parameters.get(\"PWD2\");\n                user = (String)parameters.get(\"USER\");\n                userLastname = (String)parameters.get(\"USERNAME\");\n                town = (String)parameters.get(\"TOWN\");\n                zipcode = (String)parameters.get(\"ZIP\");\n                email = (String)parameters.get(\"USEREMAIL\");\n                defaultGroup = (String)parameters.get(\"DEFAULTGROUP\");\n            }\n            else {\n\n                // an error has occurred before, retrieve the form data from the session\n                firstname = (String)session.getValue(\"USERFIRSTNAME\");\n                desc = (String)session.getValue(\"USERDESC\");\n                street = (String)session.getValue(\"USERSTREET\");\n                pwd = (String)session.getValue(\"PWD\");\n                pwd2 = (String)session.getValue(\"PWD2\");\n                user = (String)session.getValue(\"USER\");\n                userLastname = (String)session.getValue(\"USERNAME\");\n                town = (String)session.getValue(\"TOWN\");\n                zipcode = (String)session.getValue(\"ZIP\");\n                email = (String)session.getValue(\"USEREMAIL\");\n                defaultGroup = (String)session.getValue(\"DEFAULTGROUP\");\n                session.removeValue(\"ERROR\");\n            }\n            if(firstname == null) {\n                firstname = \"\";\n            }\n            if(desc == null) {\n                desc = \"\";\n            }\n            if(street == null) {\n                street = \"\";\n            }\n            if(pwd == null) {\n                pwd = \"\";\n            }\n            if(pwd2 == null) {\n                pwd2 = \"\";\n            }\n            if(user == null) {\n                user = \"\";\n            }\n            if(userLastname == null) {\n                userLastname = \"\";\n            }\n            if(town == null) {\n                town = \"\";\n            }\n            if(zipcode == null) {\n                zipcode = \"\";\n            }\n            if(email == null) {\n                email = \"\";\n            }\n            if(defaultGroup == null) {\n                defaultGroup = \"\";\n            }\n\n            // vectors of Strings that hold the selected and not selected Groups\n            Vector selectedGroups = (Vector)session.getValue(\"selectedGroups\");\n            Vector notSelectedGroups = (Vector)session.getValue(\"notSelectedGroups\");\n            if(perspective.equals(\"newuser\")) {\n\n                // input is the form for establishing new users\n                templateSelector = \"newuser\";\n                if(!userYetEstablished) {\n\n                    // first time the form is visited\n                    user = \"\";\n                    selectedGroups = new Vector();\n                    notSelectedGroups = new Vector();\n                    selectedGroups.addElement(C_GROUP_USERS); // preselect Users\n                    Vector groups = cms.getGroups();\n                    for(int z = 0;z < groups.size();z++) {\n                        String aName = (String)((CmsGroup)groups.elementAt(z)).getName();\n                        if(!C_GROUP_USERS.equals(aName)) {\n                            notSelectedGroups.addElement(aName);\n                        }\n                    }\n                    session.putValue(\"selectedGroups\", selectedGroups);\n                    session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                }\n                if(reqCont.getRequest().getParameter(\"ADD\") != null) {\n\n                    // add a new group to selectedGroups\n                    String groupname = (String)parameters.get(\"notselectgroup\");\n                    if(groupname != null) {\n                        selectedGroups.addElement(groupname);\n                        notSelectedGroups.removeElement(groupname);\n                    }\n                    session.putValue(\"selectedGroups\", selectedGroups);\n                    session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                }\n                else {\n                    if(reqCont.getRequest().getParameter(\"REMOVE\") != null) {\n\n                        // delete a new group from selectedGroups\n                        // and move it to notSelectedGroups\n                        String groupname = (String)parameters.get(\"selectgroup\");\n                        if(groupname != null) {\n                            notSelectedGroups.addElement(groupname);\n                            selectedGroups.removeElement(groupname);\n                            if(groupname.equals(defaultGroup)) {\n                                defaultGroup = \"\";\n                            }\n                        }\n                        session.putValue(\"selectedGroups\", selectedGroups);\n                        session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                    }\n                    else {\n                        if(reqCont.getRequest().getParameter(\"OK\") != null) {\n\n                            // form submitted, try to establish new user\n                            try {\n                                if(email.equals(\"\") || userLastname.equals(\"\")\n                                        || user.equals(\"\")) {\n                                    throw new CmsException(\"user data missing\",\n                                            CmsException.C_NO_USER);\n                                }\n                                if(!pwd.equals(pwd2)) {\n                                    throw new CmsException(\"unequal passwords\",\n                                            CmsException.C_SHORT_PASSWORD);\n                                }\n                                if(pwd.length() < C_PASSWORD_MINIMUMSIZE) {\n                                    throw new CmsException(\"password too short\",\n                                            CmsException.C_SHORT_PASSWORD);\n                                }\n                                Hashtable additionalInfo = new Hashtable();\n\n                                // additionalInfo.put(C_ADDITIONAL_INFO_ZIPCODE, zipcode);\n                                // additionalInfo.put(C_ADDITIONAL_INFO_TOWN, town);\n                                CmsUser newUser = cms.addUser(user, pwd, defaultGroup, desc,\n                                        additionalInfo, C_FLAG_ENABLED);\n                                newUser.setEmail(email);\n                                newUser.setFirstname(firstname);\n                                newUser.setLastname(userLastname);\n                                newUser.setAddress(street);\n                                newUser.setAdditionalInfo(C_ADDITIONAL_INFO_ZIPCODE, zipcode);\n                                newUser.setAdditionalInfo(C_ADDITIONAL_INFO_TOWN, town);\n                                for(int z = 0;z < selectedGroups.size();z++) {\n                                    String groupname = (String)selectedGroups.elementAt(z);\n                                    if(!groupname.equals(defaultGroup)) {\n                                        cms.addUserToGroup(user, groupname);\n                                    }\n                                }\n                                cms.writeUser(newUser); // update in the database\n                                session.removeValue(\"selectedGroups\");\n                                session.removeValue(\"notSelectedGroups\");\n                                session.removeValue(\"ERROR\");\n                                templateSelector = \"\"; //successful\n                            }\n                            catch(CmsException e) {\n\n                                // save the form data in the session, so it can be displayed again later\n                                session.putValue(\"ERROR\", new String(\"yes\")); // remeber that an error has occurred\n                                session.putValue(\"USERFIRSTNAME\", firstname);\n                                session.putValue(\"USERDESC\", desc);\n                                session.putValue(\"USERSTREET\", street);\n                                session.putValue(\"PWD\", pwd);\n                                session.putValue(\"PWD2\", pwd2);\n                                session.putValue(\"USER\", user);\n                                session.putValue(\"USERNAME\", userLastname);\n                                session.putValue(\"ZIP\", zipcode);\n                                session.putValue(\"TOWN\", town);\n                                session.putValue(\"USEREMAIL\", email);\n                                session.putValue(\"DEFAULTGROUP\", defaultGroup);\n                                if(e.getType() == CmsException.C_SHORT_PASSWORD) {\n                                    if(e.getMessage().equals(\"unequal passwords\")) {\n                                        templateSelector = \"passworderror1\";\n                                    }\n                                    else {\n                                        if(e.getMessage().equals(\"password too short\")) {\n                                            templateSelector = \"passworderror2\";\n                                        }\n                                        else {\n                                            throw e;\n                                        }\n                                    }\n                                }\n                                else {\n                                    if(e.getType() == CmsException.C_NO_GROUP) {\n                                        templateSelector = \"errornogroup1\";\n                                    }\n                                    else {\n                                        if(e.getType() == CmsException.C_NO_USER\n                                                && e.getMessage().equals(\"user data missing\")) {\n                                            templateSelector = \"errordatamissing1\";\n                                        }\n                                        else {\n                                            throw e; // hand the exception down\n                                        }\n                                    }\n                                }\n                            } // catch block\n                        } // OK\n                    }\n                }\n            }\n            else {\n\n                // input is the form for changing the user data\n                templateSelector = \"changeuser\";\n                boolean disabled = false;\n                if(!userYetChanged) {\n\n                    // form visited for the first time, not yet changed\n                    // read the data from the user object\n                    CmsUser theUser = (CmsUser)cms.readUser(user);\n                    if(theUser == null) {\n                        throw new CmsException(\"user does not exist\");\n                    }\n                    firstname = theUser.getFirstname();\n                    desc = theUser.getDescription();\n                    street = theUser.getAddress();\n                    userLastname = theUser.getLastname();\n                    email = theUser.getEmail();\n                    disabled = theUser.getDisabled();\n                    zipcode = (String)theUser.getAdditionalInfo(C_ADDITIONAL_INFO_ZIPCODE);\n                    town = (String)theUser.getAdditionalInfo(C_ADDITIONAL_INFO_TOWN);\n                    defaultGroup = theUser.getDefaultGroup().getName();\n                    Vector groups = cms.getDirectGroupsOfUser(user);\n                    if(groups != null) {\n                        selectedGroups = new Vector();\n                        for(int z = 0;z < groups.size();z++) {\n                            selectedGroups.addElement(((CmsGroup)groups.elementAt(z)).getName());\n                        }\n                    }\n                    else {\n                        throw new CmsException(CmsException.C_NO_GROUP);\n                    }\n                    groups = cms.getGroups();\n                    if(groups != null) {\n                        notSelectedGroups = new Vector();\n                        for(int z = 0;z < groups.size();z++) {\n                            String name = ((CmsGroup)groups.elementAt(z)).getName();\n                            if(!selectedGroups.contains(name)) {\n                                notSelectedGroups.addElement(name);\n                            }\n                        }\n                    }\n                }\n                else {\n\n                    // fetch data from the form\n                    if((String)parameters.get(\"LOCK\") != null) {\n                        disabled = true;\n                    }\n                    if(reqCont.getRequest().getParameter(\"ADD\") != null) {\n\n                        // add a new group to selectedGroups\n                        String groupname = (String)parameters.get(\"notselectgroup\");\n                        if(groupname != null) {\n                            if(!selectedGroups.contains(groupname)){\n                                selectedGroups.addElement(groupname);\n                            }\n                            notSelectedGroups.removeElement(groupname);\n                        }\n                    }\n                    else {\n                        if(reqCont.getRequest().getParameter(\"REMOVE\") != null) {\n\n                            // delete a group from selectedGroups\n                            // and move it to notSelectedGroups\n                            String groupname = (String)parameters.get(\"selectgroup\");\n                            if(groupname != null) {\n                                if(!notSelectedGroups.contains(groupname)){\n                                    notSelectedGroups.addElement(groupname);\n                                    if(groupname.equals(defaultGroup)) {\n                                        defaultGroup = \"\";\n                                    }\n                                }\n                                selectedGroups.removeElement(groupname);\n                            }\n                        }\n                        else {\n                            if(reqCont.getRequest().getParameter(\"OK\") != null) {\n\n                                // form submitted, try to change the user data\n                                try {\n                                    if(email.equals(\"\") || userLastname.equals(\"\")\n                                            || user.equals(\"\")) {\n                                        throw new CmsException(\"user data missing\",\n                                                CmsException.C_NO_USER);\n                                    }\n                                    if(!pwd.equals(pwd2)) {\n                                        throw new CmsException(\"unequal passwords\",\n                                                CmsException.C_SHORT_PASSWORD);\n                                    }\n                                    if(!pwd.equals(\"\")) {\n                                        if(pwd.length() < C_PASSWORD_MINIMUMSIZE) {\n                                            throw new CmsException(\"password too short\",\n                                                    CmsException.C_SHORT_PASSWORD);\n                                        }\n                                        cms.setPassword(user, pwd);\n                                    } // if nothing is entered don't change the password\n                                    CmsUser theUser = (CmsUser)cms.readUser(user);\n                                    theUser.setEmail(email);\n                                    theUser.setFirstname(firstname);\n                                    theUser.setLastname(userLastname);\n                                    theUser.setAddress(street);\n                                    theUser.setAdditionalInfo(C_ADDITIONAL_INFO_ZIPCODE, zipcode);\n                                    theUser.setAdditionalInfo(C_ADDITIONAL_INFO_TOWN, town);\n                                    if((C_USER_ADMIN.equals(theUser.getName()))\n                                            && (!selectedGroups.contains(C_GROUP_ADMIN))) {\n                                        throw new CmsException(\"cant remove Admin from \"\n                                                + C_GROUP_ADMIN, CmsException.C_NOT_ADMIN);\n                                    }\n                                    if(disabled && selectedGroups.contains(C_GROUP_ADMIN)) {\n                                        throw new CmsException(\"disabled admin\",\n                                                 CmsException.C_NOT_ADMIN);\n                                    }\n                                    if(disabled == true) {\n                                        theUser.setDisabled();\n                                    }\n                                    else {\n                                        theUser.setEnabled();\n                                    }\n                                    changeGroups(cms, theUser, defaultGroup, selectedGroups);\n                                    session.removeValue(\"selectedGroups\");\n                                    session.removeValue(\"notSelectedGroups\");\n                                    session.removeValue(\"DEFAULTGROUP\");\n                                    session.removeValue(\"ERROR\");\n                                    templateSelector = \"\"; //successful\n                                }\n                                catch(CmsException e) {\n                                    session.putValue(\"ERROR\", new String(\"yes\")); // remeber that an error has occurred\n                                    session.putValue(\"USERFIRSTNAME\", firstname);\n                                    session.putValue(\"USERDESC\", desc);\n                                    session.putValue(\"USERSTREET\", street);\n                                    session.putValue(\"PWD\", pwd);\n                                    session.putValue(\"PWD2\", pwd2);\n                                    session.putValue(\"USER\", user);\n                                    session.putValue(\"USERNAME\", userLastname);\n                                    session.putValue(\"ZIP\", zipcode);\n                                    session.putValue(\"TOWN\", town);\n                                    session.putValue(\"USEREMAIL\", email);\n                                    session.putValue(\"DEFAULTGROUP\", defaultGroup);\n                                    if(e.getType() == CmsException.C_SHORT_PASSWORD) {\n                                        if(e.getMessage().equals(\"unequal passwords\")) {\n                                            templateSelector = \"passworderror3\";\n                                        }\n                                        else {\n                                            if(e.getMessage().equals(\"password too short\")) {\n                                                templateSelector = \"passworderror4\";\n                                            }\n                                            else {\n                                                session.putValue(\"ERROR\", new String(\"yes\"));\n                                                throw e;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        if(e.getType() == CmsException.C_NO_GROUP) {\n                                            templateSelector = \"errornogroup2\";\n                                        }\n                                        else {\n                                            if(e.getType() == CmsException.C_NO_USER\n                                                    && e.getMessage().equals(\"user data missing\")) {\n                                                templateSelector = \"errordatamissing2\";\n                                            }\n                                            else {\n                                                if(e.getType() == CmsException.C_NOT_ADMIN\n                                                        && e.getMessage().equals(\"disabled admin\")) {\n                                                    templateSelector = \"errordisabledadmin\";\n                                                }\n                                                else {\n                                                    session.putValue(\"ERROR\", new String(\"yes\"));\n                                                    throw e; // hand the exception down\n                                                }\n                                            }\n                                        }\n                                    }\n                                } // catch block\n                            } // OK\n                        }\n                    }\n                } // userYetEstablished\n                session.putValue(\"selectedGroups\", selectedGroups);\n                session.putValue(\"notSelectedGroups\", notSelectedGroups);\n                session.putValue(\"DEFAULTGROUP\", defaultGroup);\n                xmlTemplateDocument.setData(\"DISABLED\", disabled ? \"checked\" : \"\");\n            }\n\n            // again common part for 'newuser' and 'changeuser':\n            // set the variables for display in the document\n            if(firstname == null) {\n                firstname = \"\";\n            }\n            if(desc == null) {\n                desc = \"\";\n            }\n            if(street == null) {\n                street = \"\";\n            }\n            if(pwd == null) {\n                pwd = \"\";\n            }\n            if(pwd2 == null) {\n                pwd2 = \"\";\n            }\n            if(user == null) {\n                user = \"\";\n            }\n            if(userLastname == null) {\n                userLastname = \"\";\n            }\n            if(town == null) {\n                town = \"\";\n            }\n            if(zipcode == null) {\n                zipcode = \"\";\n            }\n            if(email == null) {\n                email = \"\";\n            }\n            xmlTemplateDocument.setData(\"USERFIRSTNAME\", firstname);\n            xmlTemplateDocument.setData(\"USERDESC\", desc);\n            xmlTemplateDocument.setData(\"USERSTREET\", street);\n            xmlTemplateDocument.setData(\"PWD\", pwd);\n            xmlTemplateDocument.setData(\"PWD2\", pwd2);\n            xmlTemplateDocument.setData(\"USER\", user);\n            xmlTemplateDocument.setData(\"USERNAME\", userLastname);\n            xmlTemplateDocument.setData(\"TOWN\", town);\n            xmlTemplateDocument.setData(\"ZIP\", zipcode);\n            xmlTemplateDocument.setData(\"EMAIL\", email);\n        } // belongs to: 'if perspective is newuser or changeuser'\n        else {\n            if(perspective.equals(\"deleteuser\")) {\n                String user = (String)parameters.get(\"USER\");\n                xmlTemplateDocument.setData(\"USER\", user);\n                templateSelector = \"RUsureDelete\";\n            }\n            else {\n                if(perspective.equals(\"reallydeleteuser\")) {\n\n                    // deleting a user\n                    String user = (String)parameters.get(\"USER\");\n                    try {\n                        cms.deleteUser(user);\n                        templateSelector = \"\";\n                    }\n                    catch(Exception e) {\n\n                        // user == null or delete failed\n                        xmlTemplateDocument.setData(\"DELETEDETAILS\", Utils.getStackTrace(e));\n                        templateSelector = \"deleteerror\";\n                    }\n                } // delete user\n            }\n        }\n\n        // Now load the template file and start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters,\n                templateSelector);\n    }","commit_id":"4441f9abf854daec115ad9c599fdd4770f19035e","url":"https://github.com/alkacon/opencms-core"},{"original_method":"protected boolean removeLibrary(final Library library) {\n    final LibraryTable table = library.getTable();\n    if (table != null) {\n      final Collection<ProjectStructureElementUsage> usages = myContext.getDaemonAnalyzer().getUsages(new LibraryProjectStructureElement(myContext, library));\n      if (usages.size() > 0) {\n        final MultiMap<String, ProjectStructureElementUsage> containerType2Usage = new MultiMap<String, ProjectStructureElementUsage>();\n        for (final ProjectStructureElementUsage usage : usages) {\n          containerType2Usage.putValue(usage.getContainingElement().getTypeName(), usage);\n        }\n\n        List<String> types = new ArrayList<String>(containerType2Usage.keySet());\n        Collections.sort(types);\n\n        final StringBuilder sb = new StringBuilder(\"Library '\");\n        Library libraryModel = myContext.getLibraryModel(library);\n        sb.append(libraryModel != null ? libraryModel.getName() : library.getName()).append(\"' is used in \");\n        for (int i = 0; i < types.size(); i++) {\n          if (i > 0 && i == types.size() - 1) {\n            sb.append(\" and in \");\n          }\n          else if (i > 0) {\n            sb.append(\", in \");\n          }\n          String type = types.get(i);\n          Collection<ProjectStructureElementUsage> usagesOfType = containerType2Usage.get(type);\n          if (usagesOfType.size() > 1) {\n            sb.append(usagesOfType.size()).append(\" \").append(StringUtil.decapitalize(StringUtil.pluralize(type)));\n          }\n          else {\n            sb.append(StringUtil.decapitalize(usagesOfType.iterator().next().getContainingElement().getPresentableName()));\n          }\n        }\n\n        sb.append(\".\\n\\nAre you sure you want to delete this library?\");\n\n        if (DialogWrapper.OK_EXIT_CODE == Messages.showOkCancelDialog(myProject, sb.toString(),\n                                    \"Delete Library\", Messages.getQuestionIcon())) {\n\n          for (final ProjectStructureElementUsage usage : usages) {\n            usage.removeSourceElement();\n          }\n\n          getModelProvider().getModifiableModel().removeLibrary(library);\n          myContext.getDaemonAnalyzer().removeElement(new LibraryProjectStructureElement(myContext, library));\n          return true;\n        }\n      } else {\n        getModelProvider().getModifiableModel().removeLibrary(library);\n        myContext.getDaemonAnalyzer().removeElement(new LibraryProjectStructureElement(myContext, library));\n        return true;\n      }\n    }\n\n    return false;\n  }","id":38737,"modified_method":"protected boolean removeLibrary(final Library library) {\n    final LibraryTable table = library.getTable();\n    if (table != null) {\n      final LibraryProjectStructureElement libraryElement = new LibraryProjectStructureElement(myContext, library);\n      final Collection<ProjectStructureElementUsage> usages = new ArrayList<ProjectStructureElementUsage>(myContext.getDaemonAnalyzer().getUsages(libraryElement));\n      if (usages.size() > 0) {\n        final MultiMap<String, ProjectStructureElementUsage> containerType2Usage = new MultiMap<String, ProjectStructureElementUsage>();\n        for (final ProjectStructureElementUsage usage : usages) {\n          containerType2Usage.putValue(usage.getContainingElement().getTypeName(), usage);\n        }\n\n        List<String> types = new ArrayList<String>(containerType2Usage.keySet());\n        Collections.sort(types);\n\n        final StringBuilder sb = new StringBuilder(\"Library '\");\n        Library libraryModel = myContext.getLibraryModel(library);\n        sb.append(libraryModel != null ? libraryModel.getName() : library.getName()).append(\"' is used in \");\n        for (int i = 0; i < types.size(); i++) {\n          if (i > 0 && i == types.size() - 1) {\n            sb.append(\" and in \");\n          }\n          else if (i > 0) {\n            sb.append(\", in \");\n          }\n          String type = types.get(i);\n          Collection<ProjectStructureElementUsage> usagesOfType = containerType2Usage.get(type);\n          if (usagesOfType.size() > 1) {\n            sb.append(usagesOfType.size()).append(\" \").append(StringUtil.decapitalize(StringUtil.pluralize(type)));\n          }\n          else {\n            sb.append(StringUtil.decapitalize(usagesOfType.iterator().next().getContainingElement().getPresentableName()));\n          }\n        }\n\n        sb.append(\".\\n\\nAre you sure you want to delete this library?\");\n\n        if (DialogWrapper.OK_EXIT_CODE == Messages.showOkCancelDialog(myProject, sb.toString(),\n                                    \"Delete Library\", Messages.getQuestionIcon())) {\n\n          for (final ProjectStructureElementUsage usage : usages) {\n            usage.removeSourceElement();\n          }\n\n          getModelProvider().getModifiableModel().removeLibrary(library);\n          myContext.getDaemonAnalyzer().removeElement(libraryElement);\n          return true;\n        }\n      } else {\n        getModelProvider().getModifiableModel().removeLibrary(library);\n        myContext.getDaemonAnalyzer().removeElement(libraryElement);\n        return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"d62693090548ab990fef12100e8f7aa72ae579bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void configGet() throws IOException {\n    setDataCommandInfo(\"Get config\");\n\n    checkServerAccess(\"server.config.get\");\n\n    final String key = channel.readString();\n    final OGlobalConfiguration cfg = OGlobalConfiguration.findByKey(key);\n    String cfgValue = cfg != null ? cfg.getValueAsString() : \"\";\n\n    beginResponse();\n    try {\n      sendOk(clientTxId);\n      channel.writeString(cfgValue);\n    } finally {\n      endResponse();\n    }\n  }","id":38738,"modified_method":"protected void configGet() throws IOException {\n    setDataCommandInfo(\"Get config\");\n\n    checkServerAccess(\"server.config.get\");\n\n    final String key = channel.readString();\n    final OGlobalConfiguration cfg = OGlobalConfiguration.findByKey(key);\n    String cfgValue = cfg != null ? cfg.isHidden() ? \"<hidden>\" : cfg.getValueAsString() : \"\";\n\n    beginResponse();\n    try {\n      sendOk(clientTxId);\n      channel.writeString(cfgValue);\n    } finally {\n      endResponse();\n    }\n  }","commit_id":"74c024d3a51c7655fce54141670ccff856d1bf5e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void configList() throws IOException {\n    setDataCommandInfo(\"List config\");\n\n    checkServerAccess(\"server.config.get\");\n\n    beginResponse();\n    try {\n      sendOk(clientTxId);\n\n      channel.writeShort((short) OGlobalConfiguration.values().length);\n      for (OGlobalConfiguration cfg : OGlobalConfiguration.values()) {\n\n        String key;\n        try {\n          key = cfg.getKey();\n        } catch (Exception e) {\n          key = \"?\";\n        }\n\n        String value;\n        try {\n          value = cfg.getValueAsString() != null ? cfg.getValueAsString() : \"\";\n        } catch (Exception e) {\n          value = \"\";\n        }\n\n        channel.writeString(key);\n        channel.writeString(value);\n      }\n    } finally {\n      endResponse();\n    }\n  }","id":38739,"modified_method":"protected void configList() throws IOException {\n    setDataCommandInfo(\"List config\");\n\n    checkServerAccess(\"server.config.get\");\n\n    beginResponse();\n    try {\n      sendOk(clientTxId);\n\n      channel.writeShort((short) OGlobalConfiguration.values().length);\n      for (OGlobalConfiguration cfg : OGlobalConfiguration.values()) {\n\n        String key;\n        try {\n          key = cfg.getKey();\n        } catch (Exception e) {\n          key = \"?\";\n        }\n\n        String value;\n        if (cfg.isHidden())\n          value = \"<hidden>\";\n        else\n          try {\n            value = cfg.getValueAsString() != null ? cfg.getValueAsString() : \"\";\n          } catch (Exception e) {\n            value = \"\";\n          }\n\n        channel.writeString(key);\n        channel.writeString(value);\n      }\n    } finally {\n      endResponse();\n    }\n  }","commit_id":"74c024d3a51c7655fce54141670ccff856d1bf5e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void writeGlobalProperties(OJSONWriter json) throws IOException {\r\n    json.beginCollection(2, true, \"globalProperties\");\r\n\r\n    for (OGlobalConfiguration c : OGlobalConfiguration.values()) {\r\n      json.beginObject(3, true, null);\r\n      json.writeAttribute(4, false, \"key\", c.getKey());\r\n      json.writeAttribute(4, false, \"description\", c.getDescription());\r\n      json.writeAttribute(4, false, \"value\", c.getValue());\r\n      json.writeAttribute(4, false, \"defaultValue\", c.getDefValue());\r\n      json.writeAttribute(4, false, \"canChange\", c.isChangeableAtRuntime());\r\n      json.endObject(3, true);\r\n    }\r\n\r\n    json.endCollection(2, true);\r\n  }","id":38740,"modified_method":"private void writeGlobalProperties(OJSONWriter json) throws IOException {\r\n    json.beginCollection(2, true, \"globalProperties\");\r\n\r\n    for (OGlobalConfiguration c : OGlobalConfiguration.values()) {\r\n      json.beginObject(3, true, null);\r\n      json.writeAttribute(4, false, \"key\", c.getKey());\r\n      json.writeAttribute(4, false, \"description\", c.getDescription());\r\n      json.writeAttribute(4, false, \"value\", c.isHidden() ? \"<hidden>\" : c.getValue());\r\n      json.writeAttribute(4, false, \"defaultValue\", c.getDefValue());\r\n      json.writeAttribute(4, false, \"canChange\", c.isChangeableAtRuntime());\r\n      json.endObject(3, true);\r\n    }\r\n\r\n    json.endCollection(2, true);\r\n  }","commit_id":"74c024d3a51c7655fce54141670ccff856d1bf5e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Associates breakpoint with class.\n   *    Create requests for loaded class and registers callback for loading classes\n   * @param debugProcess the requesting process\n   */\n  protected void createOrWaitPrepare(DebugProcessImpl debugProcess, String classToBeLoaded) {\n    debugProcess.getRequestsManager().callbackOnPrepareClasses(this, classToBeLoaded);\n\n    List list = debugProcess.getVirtualMachineProxy().classesByName(classToBeLoaded);\n    for (Iterator it = list.iterator(); it.hasNext();) {\n      ReferenceType refType = (ReferenceType)it.next();\n      if (refType.isPrepared()) {\n        processClassPrepare(debugProcess, refType);\n      }\n    }\n  }","id":38741,"modified_method":"/**\n   * Associates breakpoint with class.\n   *    Create requests for loaded class and registers callback for loading classes\n   * @param debugProcess the requesting process\n   */\n  protected void createOrWaitPrepare(DebugProcessImpl debugProcess, String classToBeLoaded) {\n    debugProcess.getRequestsManager().callbackOnPrepareClasses(this, classToBeLoaded);\n\n    List list = debugProcess.getVirtualMachineProxy().classesByName(classToBeLoaded);\n    for (final Object aList : list) {\n      ReferenceType refType = (ReferenceType)aList;\n      if (refType.isPrepared()) {\n        processClassPrepare(debugProcess, refType);\n      }\n    }\n  }","commit_id":"a8fc1ad21345adbeafc30f5d52ae86ddb13a809c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void createOrWaitPrepare(final DebugProcessImpl debugProcess, final SourcePosition classPosition) {\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        debugProcess.getRequestsManager().callbackOnPrepareClasses(Breakpoint.this, classPosition);\n\n        List list = debugProcess.getPositionManager().getAllClasses(classPosition);\n        for (Iterator it = list.iterator(); it.hasNext();) {\n          ReferenceType refType = (ReferenceType)it.next();\n          if (refType.isPrepared()) {\n            processClassPrepare(debugProcess, refType);\n          }\n        }\n      }\n    });\n  }","id":38742,"modified_method":"protected void createOrWaitPrepare(final DebugProcessImpl debugProcess, final SourcePosition classPosition) {\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        debugProcess.getRequestsManager().callbackOnPrepareClasses(Breakpoint.this, classPosition);\n\n        List list = debugProcess.getPositionManager().getAllClasses(classPosition);\n        for (final Object aList : list) {\n          ReferenceType refType = (ReferenceType)aList;\n          if (refType.isPrepared()) {\n            processClassPrepare(debugProcess, refType);\n          }\n        }\n      }\n    });\n  }","commit_id":"a8fc1ad21345adbeafc30f5d52ae86ddb13a809c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void runAction(final EvaluationContextImpl context, LocatableEvent event) {\n    if (LOG_ENABLED || LOG_EXPRESSION_ENABLED) {\n      final StringBuilder buf = new StringBuilder(128);\n      if (LOG_ENABLED) {\n        buf.append(getEventMessage(event));\n        buf.append(\"\\n\");\n      }\n      final DebugProcessImpl debugProcess = context.getDebugProcess();\n      if (LOG_EXPRESSION_ENABLED && getLogMessage() != null && !\"\".equals(getLogMessage())) {\n        if(!debugProcess.isAttached()) {\n          return;\n        }\n\n        String result;\n        try {\n          ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(getProject(), new com.intellij.debugger.EvaluatingComputable<ExpressionEvaluator>() {\n            public ExpressionEvaluator compute() throws EvaluateException {\n              return EvaluatorBuilderImpl.getInstance().build(getLogMessage(), ContextUtil.getContextElement(context));\n            }\n          });\n          result = DebuggerUtilsEx.getValueAsString(context, evaluator.evaluate(context));\n          buf.append(getLogMessage());\n          buf.append(\" = \");\n          buf.append(result);\n        }\n        catch (EvaluateException e) {\n          buf.append(DebuggerBundle.message(\"error.unable.to.evaluate.expression\"));\n          buf.append(\"\\\"\");\n          buf.append(getLogMessage());\n          buf.append(\"\\\"\");\n          buf.append(\" : \");\n          buf.append(e.getMessage());\n        }\n        buf.append(\"\\n\");\n      }\n      if (buf.length() > 0) {\n        debugProcess.printToConsole(buf.toString());\n      }\n    }\n  }","id":38743,"modified_method":"private void runAction(final EvaluationContextImpl context, LocatableEvent event) {\n    if (LOG_ENABLED || LOG_EXPRESSION_ENABLED) {\n      final StringBuilder buf = new StringBuilder(128);\n      if (LOG_ENABLED) {\n        buf.append(getEventMessage(event));\n        buf.append(\"\\n\");\n      }\n      final DebugProcessImpl debugProcess = context.getDebugProcess();\n      if (LOG_EXPRESSION_ENABLED && getLogMessage() != null && !\"\".equals(getLogMessage().getText())) {\n        if(!debugProcess.isAttached()) {\n          return;\n        }\n\n        try {\n          ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(getProject(), new EvaluatingComputable<ExpressionEvaluator>() {\n            public ExpressionEvaluator compute() throws EvaluateException {\n              return EvaluatorBuilderImpl.getInstance().build(getLogMessage(), ContextUtil.getContextElement(context));\n            }\n          });\n          String result = DebuggerUtils.getValueAsString(context, evaluator.evaluate(context));\n          buf.append(getLogMessage());\n          buf.append(\" = \");\n          buf.append(result);\n        }\n        catch (EvaluateException e) {\n          buf.append(DebuggerBundle.message(\"error.unable.to.evaluate.expression\"));\n          buf.append(\"\\\"\");\n          buf.append(getLogMessage());\n          buf.append(\"\\\"\");\n          buf.append(\" : \");\n          buf.append(e.getMessage());\n        }\n        buf.append(\"\\n\");\n      }\n      if (buf.length() > 0) {\n        debugProcess.printToConsole(buf.toString());\n      }\n    }\n  }","commit_id":"a8fc1ad21345adbeafc30f5d52ae86ddb13a809c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean evaluateCondition(EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {\n    if(COUNT_FILTER_ENABLED) {\n      context.getDebugProcess().getVirtualMachineProxy().suspend();\n      context.getDebugProcess().getRequestsManager().deleteRequest(this);\n      ((Breakpoint)this).createRequest(context.getDebugProcess());\n      context.getDebugProcess().getVirtualMachineProxy().resume();\n    }\n    if (INSTANCE_FILTERS_ENABLED) {\n      Value value = context.getThisObject();\n      if (value != null) {  // non-static\n        ObjectReference reference = (ObjectReference)value;\n        if(!hasObjectID(reference.uniqueID())) return false;\n      }\n    }\n\n    if (CONDITION_ENABLED && getCondition() != null && !\"\".equals(getCondition())) {\n      try {\n        ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(context.getProject(), new com.intellij.debugger.EvaluatingComputable<ExpressionEvaluator>() {\n          public ExpressionEvaluator compute() throws EvaluateException {\n            return EvaluatorBuilderImpl.getInstance().build(getCondition(), getEvaluationElement());\n          }\n        });\n        Value value = evaluator.evaluate(context);\n        if (!(value instanceof BooleanValue)) {\n          throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.boolean.expected\"));\n        }\n        if(!((BooleanValue)value).booleanValue()) {\n          return false;\n        }\n      }\n      catch (EvaluateException ex) {\n        if(ex.getCause() instanceof VMDisconnectedException) {\n          return false;\n        }\n        throw EvaluateExceptionUtil.createEvaluateException(\n          DebuggerBundle.message(\"error.failed.evaluating.breakpoint.condition\", getCondition(), ex.getMessage())\n        );\n      }\n      return true;\n    }\n\n    return true;\n  }","id":38744,"modified_method":"public boolean evaluateCondition(EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {\n    if(COUNT_FILTER_ENABLED) {\n      context.getDebugProcess().getVirtualMachineProxy().suspend();\n      context.getDebugProcess().getRequestsManager().deleteRequest(this);\n      ((Breakpoint)this).createRequest(context.getDebugProcess());\n      context.getDebugProcess().getVirtualMachineProxy().resume();\n    }\n    if (INSTANCE_FILTERS_ENABLED) {\n      Value value = context.getThisObject();\n      if (value != null) {  // non-static\n        ObjectReference reference = (ObjectReference)value;\n        if(!hasObjectID(reference.uniqueID())) return false;\n      }\n    }\n\n    if (CONDITION_ENABLED && getCondition() != null && !\"\".equals(getCondition().getText())) {\n      try {\n        ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(context.getProject(), new EvaluatingComputable<ExpressionEvaluator>() {\n          public ExpressionEvaluator compute() throws EvaluateException {\n            return EvaluatorBuilderImpl.getInstance().build(getCondition(), getEvaluationElement());\n          }\n        });\n        Value value = evaluator.evaluate(context);\n        if (!(value instanceof BooleanValue)) {\n          throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.boolean.expected\"));\n        }\n        if(!((BooleanValue)value).booleanValue()) {\n          return false;\n        }\n      }\n      catch (EvaluateException ex) {\n        if(ex.getCause() instanceof VMDisconnectedException) {\n          return false;\n        }\n        throw EvaluateExceptionUtil.createEvaluateException(\n          DebuggerBundle.message(\"error.failed.evaluating.breakpoint.condition\", getCondition(), ex.getMessage())\n        );\n      }\n      return true;\n    }\n\n    return true;\n  }","commit_id":"a8fc1ad21345adbeafc30f5d52ae86ddb13a809c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return true if the ID was added or false otherwise\n   */\n  public boolean hasObjectID(long id) {\n    for (int i = 0; i < myInstanceFilters.length; i++) {\n      InstanceFilter instanceFilter = myInstanceFilters[i];\n      if (instanceFilter.getId() == id) {\n        return true;\n      }\n    }\n    return false;\n  }","id":38745,"modified_method":"/**\n   * @return true if the ID was added or false otherwise\n   */\n  private boolean hasObjectID(long id) {\n    for (InstanceFilter instanceFilter : myInstanceFilters) {\n      if (instanceFilter.getId() == id) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"a8fc1ad21345adbeafc30f5d52ae86ddb13a809c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addInstanceFilter(long l) {\n    final InstanceFilter[] filters = new InstanceFilter[myInstanceFilters.length + 1];\n    System.arraycopy(myInstanceFilters, 0, filters, 0, myInstanceFilters.length);\n    filters[myInstanceFilters.length] = InstanceFilter.create(\"\" + l);\n    myInstanceFilters = filters;\n  }","id":38746,"modified_method":"protected void addInstanceFilter(long l) {\n    final InstanceFilter[] filters = new InstanceFilter[myInstanceFilters.length + 1];\n    System.arraycopy(myInstanceFilters, 0, filters, 0, myInstanceFilters.length);\n    filters[myInstanceFilters.length] = InstanceFilter.create(String.valueOf(l));\n    myInstanceFilters = filters;\n  }","commit_id":"a8fc1ad21345adbeafc30f5d52ae86ddb13a809c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element parentNode) throws InvalidDataException {\n    DefaultJDOMExternalizer.readExternal(this, parentNode);\n    String condition = JDOMExternalizerUtil.readField(parentNode, CONDITION_OPTION_NAME);\n    if (condition != null) {\n      setCondition(new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, condition));\n    }\n\n    myClassFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(FILTER_OPTION_NAME));\n    myClassExclusionFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(EXCLUSION_FILTER_OPTION_NAME));\n\n    final ClassFilter [] instanceFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(INSTANCE_ID_OPTION_NAME));\n    final List<InstanceFilter> iFilters = new ArrayList<InstanceFilter>(instanceFilters.length);\n\n    for (int i = 0; i < instanceFilters.length; i++) {\n      try {\n        iFilters.add(InstanceFilter.create(instanceFilters[i]));\n      }\n      catch (Exception e) {\n      }\n    }\n    myInstanceFilters = iFilters.toArray(new InstanceFilter[iFilters.size()]);\n  }","id":38747,"modified_method":"public void readExternal(Element parentNode) throws InvalidDataException {\n    DefaultJDOMExternalizer.readExternal(this, parentNode);\n    String condition = JDOMExternalizerUtil.readField(parentNode, CONDITION_OPTION_NAME);\n    if (condition != null) {\n      setCondition(new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, condition));\n    }\n\n    myClassFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(FILTER_OPTION_NAME));\n    myClassExclusionFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(EXCLUSION_FILTER_OPTION_NAME));\n\n    final ClassFilter [] instanceFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(INSTANCE_ID_OPTION_NAME));\n    final List<InstanceFilter> iFilters = new ArrayList<InstanceFilter>(instanceFilters.length);\n\n    for (ClassFilter instanceFilter : instanceFilters) {\n      try {\n        iFilters.add(InstanceFilter.create(instanceFilter));\n      }\n      catch (Exception e) {\n      }\n    }\n    myInstanceFilters = iFilters.toArray(new InstanceFilter[iFilters.size()]);\n  }","commit_id":"a8fc1ad21345adbeafc30f5d52ae86ddb13a809c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean computeRegExpPresentation(@NotNull final XValueNode node, @NotNull final InstanceRef instanceRef) {\n    if (instanceRef.getKind() == InstanceKind.RegExp) {\n      // The pattern is always an instance of kind String.\n      final InstanceRef pattern = instanceRef.getPattern();\n      final String suffix = pattern.getValueAsStringIsTruncated() ? \"... (truncated value)\" : \"\";\n      final String patternString = StringUtil.replace(pattern.getValueAsString() + suffix, \"\\\"\", \"\\\\\\\"\");\n\n      node.setPresentation(AllIcons.Debugger.Value, new XStringValuePresentation(patternString) {\n        @Nullable\n        @Override\n        public String getType() {\n          return instanceRef.getClassRef().getName();\n        }\n      }, true);\n      return true;\n    }\n    return false;\n  }","id":38748,"modified_method":"private boolean computeRegExpPresentation(@NotNull final XValueNode node, @NotNull final InstanceRef instanceRef) {\n    if (instanceRef.getKind() == InstanceKind.RegExp) {\n      // The pattern is always an instance of kind String.\n      final InstanceRef pattern = instanceRef.getPattern();\n      assert pattern.getKind() == InstanceKind.String : pattern;\n\n      final String patternString = StringUtil.replace(pattern.getValueAsString(), \"\\\"\", \"\\\\\\\"\");\n      node.setPresentation(AllIcons.Debugger.Value, new XStringValuePresentation(patternString) {\n        @Nullable\n        @Override\n        public String getType() {\n          return instanceRef.getClassRef().getName();\n        }\n      }, true);\n\n      if (pattern.getValueAsStringIsTruncated()) {\n        addFullStringValueEvaluator(node, pattern);\n      }\n\n      return true;\n    }\n    return false;\n  }","commit_id":"0591fb914831dae01fc83d499901e96c643dfba8","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static boolean computeVarHavingStringValuePresentation(@NotNull final XValueNode node, @NotNull final InstanceRef instanceRef) {\n    // getValueAsString() is provided for the instance kinds: Null, Bool, Double, Int, String (value may be truncated), Float32x4, Float64x2, Int32x4, StackTrace\n    switch (instanceRef.getKind()) {\n      case Null:\n      case Bool:\n        node.setPresentation(AllIcons.Debugger.Db_primitive, new XKeywordValuePresentation(instanceRef.getValueAsString()), false);\n        break;\n      case Double:\n      case Int:\n        node.setPresentation(AllIcons.Debugger.Db_primitive, new XNumericValuePresentation(instanceRef.getValueAsString()), false);\n        break;\n      case String:\n        final String suffix = instanceRef.getValueAsStringIsTruncated() ? \"... (truncated value)\" : \"\";\n        final String presentableValue = StringUtil.replace(instanceRef.getValueAsString() + suffix, \"\\\"\", \"\\\\\\\"\");\n        node.setPresentation(AllIcons.Debugger.Db_primitive, new XStringValuePresentation(presentableValue), false);\n        break;\n      case Float32x4:\n      case Float64x2:\n      case Int32x4:\n      case StackTrace:\n        node.setFullValueEvaluator(new ImmediateFullValueEvaluator(\"Click to see stack trace...\", instanceRef.getValueAsString()));\n        node.setPresentation(AllIcons.Debugger.Value, instanceRef.getClassRef().getName(), \"\", true);\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }","id":38749,"modified_method":"private boolean computeVarHavingStringValuePresentation(@NotNull final XValueNode node, @NotNull final InstanceRef instanceRef) {\n    // getValueAsString() is provided for the instance kinds: Null, Bool, Double, Int, String (value may be truncated), Float32x4, Float64x2, Int32x4, StackTrace\n    switch (instanceRef.getKind()) {\n      case Null:\n      case Bool:\n        node.setPresentation(AllIcons.Debugger.Db_primitive, new XKeywordValuePresentation(instanceRef.getValueAsString()), false);\n        break;\n      case Double:\n      case Int:\n        node.setPresentation(AllIcons.Debugger.Db_primitive, new XNumericValuePresentation(instanceRef.getValueAsString()), false);\n        break;\n      case String:\n        final String presentableValue = StringUtil.replace(instanceRef.getValueAsString(), \"\\\"\", \"\\\\\\\"\");\n        node.setPresentation(AllIcons.Debugger.Db_primitive, new XStringValuePresentation(presentableValue), false);\n\n        if (instanceRef.getValueAsStringIsTruncated()) {\n          addFullStringValueEvaluator(node, instanceRef);\n        }\n        break;\n      case Float32x4:\n      case Float64x2:\n      case Int32x4:\n      case StackTrace:\n        node.setFullValueEvaluator(new ImmediateFullValueEvaluator(\"Click to see stack trace...\", instanceRef.getValueAsString()));\n        node.setPresentation(AllIcons.Debugger.Value, instanceRef.getClassRef().getName(), \"\", true);\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }","commit_id":"0591fb914831dae01fc83d499901e96c643dfba8","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * DES Encrypts and then base64 encodes the passed in String using the\n     * passed in secret key. The base64 encoding is\n     * performed to ensure that the encrypted string can be stored in places\n     * that don't support extended character sets.\n     */\n    public static String base64EncryptedString(String v, Key sKey){\n        if( v == null )\n            return v;\n        String encBase64String = null;\n        try{\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, sKey);\n            byte[] stringBytes = v.getBytes(\"UTF8\");\n            stringBytes = ERXCompressionUtilities.deflateByteArray(stringBytes);\n            byte[] raw = cipher.doFinal(stringBytes);\n            encBase64String = base64Encode(raw);\n        } catch(java.security.NoSuchAlgorithmException ex) {\n            throw new NSForwardException(ex, \"Couldn't find the DES algorithm; perhaps you do not have the SunJCE security provider installed properly?\");\n        } catch(Exception ex) {\n            throw new NSForwardException(ex);\n        }\n        return encBase64String;\n    }","id":38750,"modified_method":"/**\n\t * @deprecated use ERXDESCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)\n\t */\n\t@Deprecated\n\tpublic static String base64EncryptedString(String clearText, Key secretKey) {\n\t\treturn ((ERXDESCrypter) ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)).encrypt(clearText, secretKey);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Base64 decodes and then DES decrypts the passed in string using the\n     * secret key returned by <code>secretKey<\/code>.\n     */\n    public static String decryptedBase64String(String v){\n        return decryptedBase64String(v, secretDESKey());\n    }","id":38751,"modified_method":"/**\n\t * @deprecated use ERXDESCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)\n\t */\n\t@Deprecated\n\tpublic static String decryptedBase64String(String encryptedText) {\n\t\treturn ERXCrypto.crypterForAlgorithm(ERXCrypto.DES).decrypt(encryptedText);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * DES Encrypts and then base64 encodes the passed in String using the\n     * secret key returned by <code>secretKey<\/code>. The base64 encoding is\n     * performed to ensure that the encrypted string can be stored in places\n     * that don't support extended character sets.\n     */\n    public static String base64EncryptedString(String v){\n        return base64EncryptedString(v, secretDESKey());\n    }","id":38752,"modified_method":"/**\n\t * @deprecated use ERXDESCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)\n\t */\n\t@Deprecated\n\tpublic static String base64EncryptedString(String clearText) {\n\t\treturn ERXCrypto.crypterForAlgorithm(ERXCrypto.DES).encrypt(clearText);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void setSecretKeyPathFramework(String v){\n        _secretKeyPathFramework = v;\n    }","id":38753,"modified_method":"/**\n\t * @deprecated use ERXDESCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)\n\t */\n\t@Deprecated\n\tpublic static void setSecretKeyPathFramework(String secretKeyPathFramework) {\n\t\t((ERXDESCrypter) ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)).setSecretKeyPathFramework(secretKeyPathFramework);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Decodes all of the values from a given dictionary\n     * using blowfish.\n     * @param dict dictionary of key value pairs where the\n     * \t\tvalues are blowfish encoded strings\n     * @return a dictionary of decoded key-value pairs\n     */\n    public static NSMutableDictionary decodedFormValuesDictionary(NSDictionary dict) {\n        NSMutableDictionary result = new NSMutableDictionary();\n        for (Enumeration e = dict.allKeys().objectEnumerator();\n             e.hasMoreElements();) {\n            String key = (String)e.nextElement();\n            NSArray objects = (NSArray)dict.objectForKey(key);\n            String value = (blowfishDecode((String)objects.lastObject())).trim();\n            result.setObjectForKey(value, key);\n        }\n        return result;\n    }","id":38754,"modified_method":"/**\n\t * Decodes all of the values from a given dictionary using the default crypter.\n\t * \n\t * @param dict\n\t *            dictionary of key value pairs where the values are\n\t *            encoded strings\n\t * @return a dictionary of decoded key-value pairs\n\t */\n\tpublic static NSMutableDictionary<String, String> decodedFormValuesDictionary(NSDictionary<String, NSArray<String>> dict) {\n\t\tNSMutableDictionary<String, String> result = new NSMutableDictionary<String, String>();\n\t\tfor (Enumeration e = dict.allKeys().objectEnumerator(); e.hasMoreElements();) {\n\t\t\tString key = (String) e.nextElement();\n\t\t\tNSArray<String> objects = dict.objectForKey(key);\n\t\t\tString value = ERXCrypto.defaultCrypter().encrypt(objects.lastObject()).trim();\n\t\t\tresult.setObjectForKey(value, key);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Blowfish encodes a given string using the\n     * secret key specified in the System property:\n     * <b>ERBlowfishCipherKey<\/b>. The blowfish cipher is\n     * a two way cipher meaning that given the secret key\n     * you can de-cipher what the original string is. For\n     * one-way encryption look at methods dealing with the\n     * Sha alogrithm. To decode a blowfish encoded string\n     * use the method: <code>blowfishDecode<\/code>. The\n     * resultant string from encoding a string is safe for\n     * use in urls and cookies.\n     * @param s string to be encrypted\n     * @return encrypted string\n     */\n    public static String blowfishEncode(String s) {\n        if( s == null )\n            return s;\n        StringBuffer result=new StringBuffer();\n        int pos=0,length=s.length();\n        byte[] bytesToEncrypt=new byte[BLOCK_SIZE];\n        byte[] encryptedBytes=null;\n        while (pos<length) {\n            int k=0;\n            for (int j=pos; j<length && j<pos+BLOCK_SIZE; k++,j++) {\n                char c=s.charAt(j);\n                bytesToEncrypt[k]=(byte)c;\n            }\n            if (k<BLOCK_SIZE) {\n                for (int l=k; l<BLOCK_SIZE; l++) bytesToEncrypt[l]=0;\n            }\n            \n            try {\n                encryptedBytes=encryptCipher().doFinal(bytesToEncrypt);\n            } catch (Exception e) {\n                throw new NSForwardException(e);\n            }\n            for (k=0; k<BLOCK_SIZE; k++) {\n                result.append( ERXStringUtilities.HEX_CHARS[( encryptedBytes [k] >>> 4 ) & 0xf]);\n                result.append( ERXStringUtilities.HEX_CHARS[encryptedBytes[k] & 0xf]);\n            }\n            pos+=BLOCK_SIZE;\n        }\n        return result.toString();\n    }","id":38755,"modified_method":"/**\n\t * @deprecated use ERXBlowfishCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.BLOWFISH)\n\t */\n\t@Deprecated\n\tpublic static String blowfishEncode(String clearText) {\n\t\treturn ERXCrypto.crypterForAlgorithm(ERXCrypto.BLOWFISH).encrypt(clearText);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void setSecretKeyPath(String v){\n        _secretKeyPath = v;\n    }","id":38756,"modified_method":"/**\n\t * @deprecated use ERXDESCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)\n\t */\n\t@Deprecated\n\tpublic static void setSecretKeyPath(String secretKeyPath) {\n\t\t((ERXDESCrypter) ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)).setSecretKeyPath(secretKeyPath);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Base64 decodes and then DES decrypts the passed in string using the\n     * passed in secret key.\n     */\n    public static String decryptedBase64String(String v, Key sKey){\n        if( v == null )\n            return v;\n        String decString = null;\n        try{\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, secretDESKey());\n            byte[] raw = base64Decode(v);\n            byte[] stringBytes = cipher.doFinal(raw);\n            stringBytes = ERXCompressionUtilities.inflateByteArray(stringBytes);\n            decString = new String(stringBytes, \"UTF8\");\n        } catch(java.security.NoSuchAlgorithmException ex) {\n            throw new NSForwardException(ex, \"Couldn't find the DES algorithm; perhaps you do not have the SunJCE security provider installed properly?\");\n        } catch(Exception ex) {\n            throw new NSForwardException(ex);\n        }\n        return decString;\n    }","id":38757,"modified_method":"/**\n\t * @deprecated use ERXDESCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)\n\t */\n\t@Deprecated\n\tpublic static String decryptedBase64String(String encryptedText, Key secretKey) {\n\t\treturn ((ERXDESCrypter) ERXCrypto.crypterForAlgorithm(ERXCrypto.DES)).decrypt(encryptedText, secretKey);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Decodes a blowfish encoded string. Note that\n     * the originally encoded string should have been\n     * encoded with the same secret key as is used for\n     * the decoding cipher or else you are going to get\n     * garbage. To encode a string have a look at\n     * <code>blowfishEncode<\/code>.\n     * @param s blowfish encoded string to be decoded\n     * @return decode clear text string\n     */\n    public static String blowfishDecode(String s) {\n        if( s == null )\n            return null;\n        int length=s.length();\n        if (length%16!=0) {\n            return null;\n        }\n        StringBuffer result=new StringBuffer();\n        byte[] clearText=null;\n        byte[] encryptedBytes=new byte[BLOCK_SIZE];\n\n        int i=0;\n        for (int j=0; j<length;) {\n\n            char c1=s.charAt(j++); int b1=c1<'a' ? c1-'0' : c1-'a'+10;\n            char c2=s.charAt(j++); int b2=c2<'a' ? c2-'0' : c2-'a'+10;\n            encryptedBytes[i++]=(byte)((b1<<4)+b2);\n            if (i==BLOCK_SIZE) {\n                // we filled a block\n                try {\n                    clearText=decryptCipher().doFinal(encryptedBytes);\n                } catch (Exception e) {\n                    throw new NSForwardException(e);\n                }\n                for (int k=0; k<BLOCK_SIZE;k++) {\n                    if( clearText[k] != 0 )\n                        result.append((char)clearText[k]);\n                }\n                i=0;\n            }\n        }\n        \n        if (i!=0) {\n            for (int j=i;j<BLOCK_SIZE;i++) encryptedBytes[j]=0;\n            try {\n                clearText=decryptCipher().doFinal(encryptedBytes);\n            } catch (Exception e) {\n                throw new NSForwardException(e);\n            }        \n            for (int k=0; k<BLOCK_SIZE;k++) {\n                    result.append((char)clearText[k]);\n            }\n        }\n        return result.toString();\n    }","id":38758,"modified_method":"/**\n\t * @deprecated use ERXBlowfishCrypter and/or\n\t *             ERXCrypto.crypterForAlgorithm(ERXCrypto.BLOWFISH)\n\t */\n\t@Deprecated\n\tpublic static String blowfishDecode(String encryptedText) {\n\t\treturn ERXCrypto.crypterForAlgorithm(ERXCrypto.BLOWFISH).decrypt(encryptedText);\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Sha encodes a given string. The resulting\n     * string is safe to use in urls and cookies.\n     * From the digest of the string it is nearly\n     * impossible to determine what the original\n     * string was. Running the same string through\n     * the Sha digest multiple times will always\n     * produce the same hash.\n     * @param string to be put through the sha digest\n     * @return hashed form of the given string\n     */\n    public static String shaEncode(String string) {\n        if( string == null )\n            return string;\n        byte[] buf = string.getBytes();\n        MessageDigest md;\n        try {\n            md= MessageDigest.getInstance(\"SHA\");\n        } catch (java.security.NoSuchAlgorithmException ex) {\n            throw new NSForwardException(ex, \"Couldn't find the SHA algorithm; perhaps you do not have the SunJCE security provider installed properly?\");\n        }\n        md.update(buf);\n        return ERXStringUtilities.byteArrayToHexString(md.digest());\n    }","id":38759,"modified_method":"/**\n\t * Sha encodes a given string. The resulting string is safe to use in urls\n\t * and cookies. From the digest of the string it is nearly impossible to\n\t * determine what the original string was. Running the same string through\n\t * the Sha digest multiple times will always produce the same hash.\n\t * \n\t * @param string\n\t *            to be put through the sha digest\n\t * @return hashed form of the given string\n\t */\n\tpublic static String shaEncode(String text) {\n\t\tif (text == null) {\n\t\t\treturn text;\n\t\t}\n\t\tbyte[] buf = text.getBytes();\n\t\ttry {\n\t\t\tMessageDigest md = MessageDigest.getInstance(\"SHA\");\n\t\t\tmd.update(buf);\n\t\t\treturn ERXStringUtilities.byteArrayToHexString(md.digest());\n\t\t}\n\t\tcatch (java.security.NoSuchAlgorithmException ex) {\n\t\t\tthrow new NSForwardException(ex, \"Couldn't find the SHA algorithm; perhaps you do not have the SunJCE security provider installed properly?\");\n\t\t}\n\t}","commit_id":"3af45b3d606f0b159a05539bba0175d0c0f9c407","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Implementation of the Enumeration interface\n\t */\n\tpublic Object nextElement() {\n\t\treturn next();\n\t}","id":38760,"modified_method":"/**\n\t * Implementation of the Enumeration interface\n\t */\n\tpublic E nextElement() {\n\t\treturn next();\n\t}","commit_id":"a768324aa2c864dea9a1ae15b79fa9fd89873e5a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Constructs a fetch specification iterator for a fetch specification,\n     * an optional set of pre-fetched primary keys\n     * and a batch size. All objects will be\n     * fetched from the given editing context. Note that you can switch\n     * out different editing contexts between calls to <b>nextBatch<\/b>.\n     * <p>Note: if no ec is supplied a new one is initialized.<\/p>\n     * @param fetchSpecification to iterate through\n     * @param pkeys primary keys to iterate through\n     * @param ec editing context to fetch against\n     * @param batchSize number of objects to fetch in a given batch\n     */\n    public ERXFetchSpecificationBatchIterator(EOFetchSpecification fetchSpecification, NSArray pkeys, EOEditingContext ec, int batchSize) {\n        super();\n\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, fetchSpecification.entityName());\n        NSArray primaryKeyAttributes = entity.primaryKeyAttributes();\n        if (primaryKeyAttributes.count() > 1) {\n            throw new RuntimeException(\"ERXFetchSpecificationBatchIterator: Currently only single primary key entities are supported.\");\n        }\n\n        primaryKeyAttributeName = ((EOAttribute)primaryKeyAttributes.lastObject()).name();\n        this.fetchSpecification = (EOFetchSpecification) fetchSpecification.clone();\n        primaryKeys = pkeys;\n        setEditingContext(ec != null ? ec : ERXEC.newEditingContext());\n        setBatchSize(batchSize);\n        setFiltersBatches(false);\n        \n        EOQualifier qualifier = this.fetchSpecification.qualifier();\n        if (qualifier != null) {\n            editingContext().rootObjectStore().lock();\n            try {\n                this.fetchSpecification.setQualifier(entity.schemaBasedQualifier(qualifier));\n            } finally {\n                editingContext().rootObjectStore().unlock();\n            }\n        }\n    }","id":38761,"modified_method":"/**\n     * Constructs a fetch specification iterator for a fetch specification,\n     * an optional set of pre-fetched primary keys\n     * and a batch size. All objects will be\n     * fetched from the given editing context. Note that you can switch\n     * out different editing contexts between calls to <b>nextBatch<\/b>.\n     * <p>Note: if no ec is supplied a new one is initialized.<\/p>\n     * @param fetchSpecification to iterate through\n     * @param pkeys primary keys to iterate through\n     * @param ec editing context to fetch against\n     * @param batchSize number of objects to fetch in a given batch\n     */\n    public ERXFetchSpecificationBatchIterator(EOFetchSpecification fetchSpecification, NSArray pkeys, EOEditingContext ec, int batchSize) {\n        super();\n\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, fetchSpecification.entityName());\n        NSArray<EOAttribute> primaryKeyAttributes = entity.primaryKeyAttributes();\n        if (primaryKeyAttributes.count() > 1) {\n            throw new RuntimeException(\"ERXFetchSpecificationBatchIterator: Currently only single primary key entities are supported.\");\n        }\n\n        primaryKeyAttributeName = primaryKeyAttributes.lastObject().name();\n        this.fetchSpecification = (EOFetchSpecification) fetchSpecification.clone();\n        primaryKeys = pkeys;\n        setEditingContext(ec != null ? ec : ERXEC.newEditingContext());\n        setBatchSize(batchSize);\n        setFiltersBatches(false);\n        \n        EOQualifier qualifier = this.fetchSpecification.qualifier();\n        if (qualifier != null) {\n            editingContext().rootObjectStore().lock();\n            try {\n                this.fetchSpecification.setQualifier(entity.schemaBasedQualifier(qualifier));\n            } finally {\n                editingContext().rootObjectStore().unlock();\n            }\n        }\n    }","commit_id":"a768324aa2c864dea9a1ae15b79fa9fd89873e5a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Gets the next batch of enterprise objects for the\n     * given fetch specification. Note that the editing\n     * context that is set will be used to fetch against.\n     * You can swap out a different editing context before\n     * calling this method to reduce memory consumption.\n     * (However, if you are mixing calls to this method \n     * with calls to {@link #next()} or {@link #nextElement()},\n     * this method may return a partial batch of already-cached\n     * objects, in the editing context which was in place at the\n     * time they were fetched.)\n     * @return batch of enterprise objects\n     */\n    public NSArray nextBatch() {\n        if(cachedBatch != null) {\n            NSArray nextBatch = cachedBatch;\n            cachedBatch = null;\n            return nextBatch;\n        }\n\n        return _fetchNextBatch();\n    }","id":38762,"modified_method":"/**\n     * Gets the next batch of enterprise objects for the\n     * given fetch specification. Note that the editing\n     * context that is set will be used to fetch against.\n     * You can swap out a different editing context before\n     * calling this method to reduce memory consumption.\n     * (However, if you are mixing calls to this method \n     * with calls to {@link #next()} or {@link #nextElement()},\n     * this method may return a partial batch of already-cached\n     * objects, in the editing context which was in place at the\n     * time they were fetched.)\n     * @return batch of enterprise objects\n     */\n    public NSArray<E> nextBatch() {\n        if(cachedBatch != null) {\n            NSArray<E> nextBatch = cachedBatch;\n            cachedBatch = null;\n            return nextBatch;\n        }\n\n        return _fetchNextBatch();\n    }","commit_id":"a768324aa2c864dea9a1ae15b79fa9fd89873e5a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fetches the next batch unconditionally. Subclasses can\n     * override this rather than {@link #nextBatch()}, to get\n     * automatic support for the Iterator and Enumeration interfaces. \n     * @return next batch\n     */\n    protected NSArray _fetchNextBatch() {\n        if (hasNextBatch()) {\n            NSRange range = _rangeForOffset(currentObjectFetchCount);\n            NSArray nextBatch = batchWithRange(range);\n            currentObjectFetchCount += range.length();\n            return nextBatch;\n        }\n        throw new IllegalStateException(\"Iterator is exhausted\");\n    }","id":38763,"modified_method":"/**\n     * Fetches the next batch unconditionally. Subclasses can\n     * override this rather than {@link #nextBatch()}, to get\n     * automatic support for the Iterator and Enumeration interfaces. \n     * @return next batch\n     */\n    protected NSArray<E> _fetchNextBatch() {\n        if (hasNextBatch()) {\n            NSRange range = _rangeForOffset(currentObjectFetchCount);\n            NSArray<E> nextBatch = batchWithRange(range);\n            currentObjectFetchCount += range.length();\n            return nextBatch;\n        }\n        throw new IllegalStateException(\"Iterator is exhausted\");\n    }","commit_id":"a768324aa2c864dea9a1ae15b79fa9fd89873e5a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Implementation of the Iterator interface\n\t */\n\tpublic Object next() {\n        if( cachedBatch == null) {\n            NSArray nextBatch = _fetchNextBatch(); //will raise if no more batches, which is expected behavior if next() is called w/o first checking hasNext()\n            while(nextBatch.count() == 0 && hasNextBatch()) { //if filtersBatches, we can get empty batches, so repeat until we get something, or run out\n                nextBatch = _fetchNextBatch();\n            }\n            cachedBatch = nextBatch.mutableClone();\n\t\t}\n\n        Object nextObject = null;\n        if( cachedBatch.count() > 0 ) {\n            nextObject = cachedBatch.removeObjectAtIndex(0);\n        }\n        if( cachedBatch.count() == 0 ) {\n            cachedBatch = null;\n        }\n        return nextObject;\n\t}","id":38764,"modified_method":"/**\n\t * Implementation of the Iterator interface\n\t */\n\tpublic E next() {\n        if( cachedBatch == null) {\n            NSArray<E> nextBatch = _fetchNextBatch(); //will raise if no more batches, which is expected behavior if next() is called w/o first checking hasNext()\n            while(nextBatch.count() == 0 && hasNextBatch()) { //if filtersBatches, we can get empty batches, so repeat until we get something, or run out\n                nextBatch = _fetchNextBatch();\n            }\n            cachedBatch = nextBatch.mutableClone();\n\t\t}\n\n        E nextObject = null;\n        if( cachedBatch.count() > 0 ) {\n            nextObject = cachedBatch.removeObjectAtIndex(0);\n        }\n        if( cachedBatch.count() == 0 ) {\n            cachedBatch = null;\n        }\n        return nextObject;\n\t}","commit_id":"a768324aa2c864dea9a1ae15b79fa9fd89873e5a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the batch corresponding to the given range.\n     *\n     * If the supplied range does not fall within the available range,\n     * the results returned correspond to the intersection of the two.\n     *\n     * If no items are found, the supplied range does not intersect the\n     * available range, or the supplied range has length zero, then an\n     * empty array is returned.\n     *\n     * Calling this method does not affect the position of the iterator.\n     * @param requestedRange range of batch to retrieve\n     * @return batch of enterprise objects\n     */\n    public NSArray batchWithRange(NSRange requestedRange) {\n        EOEditingContext ec = editingContext();\n        if ( ec == null) {\n            throw new IllegalStateException(\"ERXFetchSpecificationBatchIterator: Calling nextBatch with a null editing context!\");\n        }\n\n        NSArray nextBatch = null;\n        NSRange range = requestedRange.rangeByIntersectingRange( new NSRange(0, count()) ); //intersect with legal range\n        if ( range.length() > 0 ) {\n            NSArray primaryKeys = primaryKeys();\n            NSArray primaryKeysToFetch = primaryKeys.subarrayWithRange(range);\n\n            log.debug(\"Of primaryKey count: \" + primaryKeys.count() + \" fetching range: \" + range + \" which is: \" + primaryKeysToFetch.count());\n\n            ERXInQualifier qual = new ERXInQualifier(primaryKeyAttributeName, primaryKeysToFetch);\n            EOFetchSpecification batchFS = new EOFetchSpecification(fetchSpecification.entityName(), qual, fetchSpecification.sortOrderings());\n            if (fetchSpecification.prefetchingRelationshipKeyPaths() != null) {\n            \tbatchFS.setPrefetchingRelationshipKeyPaths(fetchSpecification.prefetchingRelationshipKeyPaths());\n            }\n            batchFS.setRefreshesRefetchedObjects(fetchSpecification.refreshesRefetchedObjects());\n            batchFS.setRawRowKeyPaths(fetchSpecification.rawRowKeyPaths());\n            nextBatch = ec.objectsWithFetchSpecification(batchFS);\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Actually fetched: \" + nextBatch.count() + \" with fetch specification: \" + batchFS);\n                if (primaryKeysToFetch.count() > nextBatch.count()) {\n                    NSArray missedKeys = ERXArrayUtilities.arrayMinusArray(primaryKeysToFetch, (NSArray)nextBatch.valueForKey(primaryKeyAttributeName));\n                    log.debug(\"Primary Keys that were not found for this batch: \" + missedKeys);\n                }\n            }\n\n            if (shouldFilterBatches) {\n                EOQualifier originalQualifier = fetchSpecification.qualifier();\n                if (originalQualifier != null) {\n                    nextBatch = EOQualifier.filteredArrayWithQualifier(nextBatch, originalQualifier);\n                    log.debug(\"Filtered batch to: \" + nextBatch.count());\n                }\n            }\n        }\n        return nextBatch != null ? nextBatch : NSArray.EmptyArray;\n    }","id":38765,"modified_method":"/**\n     * Returns the batch corresponding to the given range.\n     *\n     * If the supplied range does not fall within the available range,\n     * the results returned correspond to the intersection of the two.\n     *\n     * If no items are found, the supplied range does not intersect the\n     * available range, or the supplied range has length zero, then an\n     * empty array is returned.\n     *\n     * Calling this method does not affect the position of the iterator.\n     * @param requestedRange range of batch to retrieve\n     * @return batch of enterprise objects\n     */\n    public NSArray<E> batchWithRange(NSRange requestedRange) {\n        EOEditingContext ec = editingContext();\n        if ( ec == null) {\n            throw new IllegalStateException(\"ERXFetchSpecificationBatchIterator: Calling nextBatch with a null editing context!\");\n        }\n\n        NSArray<E> nextBatch = null;\n        NSRange range = requestedRange.rangeByIntersectingRange( new NSRange(0, count()) ); //intersect with legal range\n        if ( range.length() > 0 ) {\n            NSArray primaryKeys = primaryKeys();\n            NSArray primaryKeysToFetch = primaryKeys.subarrayWithRange(range);\n\n            log.debug(\"Of primaryKey count: \" + primaryKeys.count() + \" fetching range: \" + range + \" which is: \" + primaryKeysToFetch.count());\n\n            ERXInQualifier qual = new ERXInQualifier(primaryKeyAttributeName, primaryKeysToFetch);\n            EOFetchSpecification batchFS = new EOFetchSpecification(fetchSpecification.entityName(), qual, fetchSpecification.sortOrderings());\n            if (fetchSpecification.prefetchingRelationshipKeyPaths() != null) {\n            \tbatchFS.setPrefetchingRelationshipKeyPaths(fetchSpecification.prefetchingRelationshipKeyPaths());\n            }\n            batchFS.setRefreshesRefetchedObjects(fetchSpecification.refreshesRefetchedObjects());\n            batchFS.setRawRowKeyPaths(fetchSpecification.rawRowKeyPaths());\n            nextBatch = ec.objectsWithFetchSpecification(batchFS);\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Actually fetched: \" + nextBatch.count() + \" with fetch specification: \" + batchFS);\n                if (primaryKeysToFetch.count() > nextBatch.count()) {\n                    NSArray missedKeys = ERXArrayUtilities.arrayMinusArray(primaryKeysToFetch, (NSArray)nextBatch.valueForKey(primaryKeyAttributeName));\n                    log.debug(\"Primary Keys that were not found for this batch: \" + missedKeys);\n                }\n            }\n\n            if (shouldFilterBatches) {\n                EOQualifier originalQualifier = fetchSpecification.qualifier();\n                if (originalQualifier != null) {\n                    nextBatch = EOQualifier.filteredArrayWithQualifier(nextBatch, originalQualifier);\n                    log.debug(\"Filtered batch to: \" + nextBatch.count());\n                }\n            }\n        }\n        return nextBatch != null ? nextBatch : NSArray.EmptyArray;\n    }","commit_id":"a768324aa2c864dea9a1ae15b79fa9fd89873e5a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * Gets the sql string for the named attribute using the provided expression.  The difference between this and the\n         * standard {@link EOSQLExpression#sqlStringForAttributeNamed} is this one can handle an \"attribute\" name that ends\n         * in a EORelationship rather than an actual EOAttribute.  This is necessary to support the \n         * {@link ERXExistsQualifier#baseKeyPath} syntax (being the relationship path to the entity to which the\n         * subqualifier will be applied) chosen for this qualifier.\n         * @param name of the attribute to get, e.g., department.division\n         * @param expression to use when generating the SQL\n         * @return the SQL string for the attribute\n         */\n        private String sqlStringForAttributeNamedInExpression(String name, EOSQLExpression expression) {\n            NSArray pieces = NSArray.componentsSeparatedByString(name, \".\");\n            EOEntity entity = expression.entity();\n            EORelationship rel;\n            EOAttribute att;\n            NSMutableArray path = new NSMutableArray();\n            int numPieces = pieces.count();\n\n            if (numPieces == 1 && null == entity.anyRelationshipNamed(name)) {\n                att = entity.anyAttributeNamed(name);\n                if (null == att) { return null; }\n                return expression.sqlStringForAttribute(att);\n            } else {\n                for (int i = 0; i < numPieces - 1; i++) {\n                    rel = entity.anyRelationshipNamed((String)pieces.objectAtIndex(i));\n                    if (null == rel) {\n                        return null;\n                    }\n                    path.addObject(rel);\n                    entity = rel.destinationEntity();\n                }\n\n                String key = (String)pieces.lastObject();\n                if (entity.anyRelationshipNamed(key) != null) { // Test first for a relationship.\n                    rel = entity.anyRelationshipNamed(key);\n                    if (rel.isFlattened()) {\n                        String relPath = rel.relationshipPath();\n                        NSArray relParts = NSArray.componentsSeparatedByString(relPath, \".\");\n                        for (int i = 0; i < relParts.count(); i++) {\n                            rel = entity.anyRelationshipNamed((String)pieces.objectAtIndex(i));\n                            path.addObject(rel);\n                            entity = rel.destinationEntity();\n                        }\n                    } else {\n                        path.addObject(rel);\n                    }\n                    att = rel.destinationAttributes().lastObject();\n                } else { // The test for an attribute.\n                    att = entity.anyAttributeNamed(key);\n                }\n\n                if (null == att) {\n                    return null;\n                }\n                path.addObject(att);\n            }\n\n            return expression.sqlStringForAttributePath(path);\n        }","id":38766,"modified_method":"/**\n         * Gets the sql string for the named attribute using the provided expression.  The difference between this and the\n         * standard {@link EOSQLExpression#sqlStringForAttributeNamed} is this one can handle an \"attribute\" name that ends\n         * in a EORelationship rather than an actual EOAttribute.  This is necessary to support the \n         * {@link ERXExistsQualifier#baseKeyPath} syntax (being the relationship path to the entity to which the\n         * subqualifier will be applied) chosen for this qualifier.\n         * @param name of the attribute to get, e.g., department.division\n         * @param expression to use when generating the SQL\n         * @return the SQL string for the attribute\n         */\n        private String sqlStringForAttributeNamedInExpression(String name, EOSQLExpression expression) {\n            NSArray<String> pieces = NSArray.componentsSeparatedByString(name, \".\");\n            EOEntity entity = expression.entity();\n            EORelationship rel;\n            EOAttribute att;\n            NSMutableArray<EOProperty> path = new NSMutableArray<EOProperty>();\n            int numPieces = pieces.count();\n\n            if (numPieces == 1 && null == entity.anyRelationshipNamed(name)) {\n                att = entity.anyAttributeNamed(name);\n                if (null == att) { return null; }\n                return expression.sqlStringForAttribute(att);\n            }\n                for (int i = 0; i < numPieces - 1; i++) {\n                    rel = entity.anyRelationshipNamed(pieces.objectAtIndex(i));\n                    if (null == rel) {\n                        return null;\n                    }\n                    path.addObject(rel);\n                    entity = rel.destinationEntity();\n                }\n\n                String key = pieces.lastObject();\n                if (entity.anyRelationshipNamed(key) != null) { // Test first for a relationship.\n                    rel = entity.anyRelationshipNamed(key);\n                    if (rel.isFlattened()) {\n                        String relPath = rel.relationshipPath();\n                        for (String relPart : NSArray.componentsSeparatedByString(relPath, \".\")) {\n                            rel = entity.anyRelationshipNamed(relPart);\n                            path.addObject(rel);\n                            entity = rel.destinationEntity();\n                        }\n                    } else {\n                        path.addObject(rel);\n                    }\n                    att = rel.destinationAttributes().lastObject();\n                } else { // The test for an attribute.\n                    att = entity.anyAttributeNamed(key);\n                }\n\n                if (null == att) {\n                    return null;\n                }\n                path.addObject(att);\n\n            return expression.sqlStringForAttributePath(path);\n        }","commit_id":"4469da23cc6fdef8a050651a39ae7572e46bfc2f","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * Generates the EXISTS SQL string for the given SQL expression.\n         * The bulk of the logic for generating the sub-query is in this method.\n         * @param qualifier for which to generate the SQL\n         * @param expression to use during SQL generation\n         * @return SQL string for the current sub-query\n         */\n        public String sqlStringForSQLExpression(EOQualifier qualifier, EOSQLExpression expression) {\n            if (null == qualifier || null == expression) {\n                return null;\n            }\n\n            ERXExistsQualifier existsQualifier = (ERXExistsQualifier)qualifier;\n            EOQualifier subqualifier = existsQualifier.subqualifier();\n            String baseKeyPath = existsQualifier.baseKeyPath();\n\n            EOEntity baseEntity = expression.entity();\n            EORelationship relationship = null;\n\n            // Walk the key path to the last entity.\n            if (baseKeyPath != null) {\n                for (Enumeration pathEnum = NSArray.componentsSeparatedByString(baseKeyPath, \".\").objectEnumerator(); pathEnum.hasMoreElements();) {\n                    String path = (String)pathEnum.nextElement();\n                    if (null == relationship) {\n                        relationship = baseEntity.anyRelationshipNamed(path);\n                    } else {\n                        relationship = relationship.destinationEntity().anyRelationshipNamed(path);\n                    }\n                }\n            }\n\n            EOEntity srcEntity = relationship != null ? relationship.entity() : baseEntity;\n            EOEntity destEntity = relationship != null ? relationship.destinationEntity() : baseEntity;\n\n            // We need to do a bunch of hand-waiving to get the right table aliases for the table used in the exists\n            // subquery and for the join clause back to the source table.\n            String sourceTableAlias = \"t0\"; // The alias for the the source table of the baseKeyPath from the main query.\n            String destTableAlias; // The alias for the table used in the subquery.\n            if (!srcEntity.equals(baseEntity)) { // The exists clause is applied to the different table.\n                String sourceKeyPath = ERXStringUtilities.keyPathWithoutLastProperty(baseKeyPath);\n                sqlStringForAttributeNamedInExpression(sourceKeyPath, expression);\n                sqlStringForAttributeNamedInExpression(baseKeyPath, expression);\n                sourceTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(sourceKeyPath);\n                destTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(baseKeyPath);\n                if (null == destTableAlias) {\n                    destTableAlias = \"t\" + (expression.aliasesByRelationshipPath().count()); // The first entry = \"t0\".\n                    expression.aliasesByRelationshipPath().takeValueForKey(destTableAlias, baseKeyPath);\n                }\n            } else { // The exists clause is applied to the base table.\n                destTableAlias = \"t\" + expression.aliasesByRelationshipPath().count(); // Probably \"t1\"\n            }\n\n            EOAttribute sourceKeyAttribute = srcEntity.primaryKeyAttributes().lastObject();\n            String sourceKey = expression.sqlStringForAttribute(sourceKeyAttribute);\n\n            EOAttribute destKeyAttribute = relationship.destinationAttributes().lastObject();\n            String destKey = expression.sqlStringForAttribute(destKeyAttribute);\n            \n            EOQualifier qual = EOQualifierSQLGeneration.Support._schemaBasedQualifierWithRootEntity(subqualifier, destEntity);\n            EOFetchSpecification fetchSpecification = new EOFetchSpecification(destEntity.name(), qual, null, false, true, null);\n\n            EODatabaseContext context = EODatabaseContext.registeredDatabaseContextForModel(destEntity.model(), EOObjectStoreCoordinator.defaultCoordinator());\n            EOSQLExpressionFactory factory = context.database().adaptor().expressionFactory();\n\n            EOSQLExpression subExpression = factory.expressionForEntity(destEntity);\n            subExpression.aliasesByRelationshipPath().setObjectForKey(destTableAlias, \"\");\n            subExpression.setUseAliases(true);\n            subExpression.prepareSelectExpressionWithAttributes(destEntity.primaryKeyAttributes(), false, fetchSpecification);\n\n            for (Enumeration bindEnumeration = subExpression.bindVariableDictionaries().objectEnumerator(); bindEnumeration.hasMoreElements();) {\n                expression.addBindVariableDictionary((NSDictionary)bindEnumeration.nextElement());\n            }\n\n            StringBuffer sb = new StringBuffer();\n            sb.append(\" EXISTS ( \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", subExpression.statement()));\n            sb.append(\" AND \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", destKey));\n            sb.append(\" = \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", sourceTableAlias + \".\", sourceKey));\n            sb.append(\" ) \");\n            return sb.toString();\n        }","id":38767,"modified_method":"/**\n         * Generates the EXISTS SQL string for the given SQL expression.\n         * The bulk of the logic for generating the sub-query is in this method.\n         * @param qualifier for which to generate the SQL\n         * @param expression to use during SQL generation\n         * @return SQL string for the current sub-query\n         */\n        public String sqlStringForSQLExpression(EOQualifier qualifier, EOSQLExpression expression) {\n            if (null == qualifier || null == expression) {\n                return null;\n            }\n\n            ERXExistsQualifier existsQualifier = (ERXExistsQualifier)qualifier;\n            EOQualifier subqualifier = existsQualifier.subqualifier();\n            String baseKeyPath = existsQualifier.baseKeyPath();\n\n            EOEntity baseEntity = expression.entity();\n            EORelationship relationship = null;\n\n            // Walk the key path to the last entity.\n            if (baseKeyPath != null) {\n                for (String path : NSArray.componentsSeparatedByString(baseKeyPath, \".\")) {\n                    if (null == relationship) {\n                        relationship = baseEntity.anyRelationshipNamed(path);\n                    } else {\n                        relationship = relationship.destinationEntity().anyRelationshipNamed(path);\n                    }\n                }\n            }\n\n            EOEntity srcEntity = relationship != null ? relationship.entity() : baseEntity;\n            EOEntity destEntity = relationship != null ? relationship.destinationEntity() : baseEntity;\n\n            // We need to do a bunch of hand-waiving to get the right table aliases for the table used in the exists\n            // subquery and for the join clause back to the source table.\n            String sourceTableAlias = \"t0\"; // The alias for the the source table of the baseKeyPath from the main query.\n            String destTableAlias; // The alias for the table used in the subquery.\n            if (!srcEntity.equals(baseEntity)) { // The exists clause is applied to the different table.\n                String sourceKeyPath = ERXStringUtilities.keyPathWithoutLastProperty(baseKeyPath);\n                sqlStringForAttributeNamedInExpression(sourceKeyPath, expression);\n                sqlStringForAttributeNamedInExpression(baseKeyPath, expression);\n                sourceTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(sourceKeyPath);\n                destTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(baseKeyPath);\n                if (null == destTableAlias) {\n                    destTableAlias = \"t\" + (expression.aliasesByRelationshipPath().count()); // The first entry = \"t0\".\n                    expression.aliasesByRelationshipPath().takeValueForKey(destTableAlias, baseKeyPath);\n                }\n            } else { // The exists clause is applied to the base table.\n                destTableAlias = \"t\" + expression.aliasesByRelationshipPath().count(); // Probably \"t1\"\n            }\n\n            EOAttribute sourceKeyAttribute = srcEntity.primaryKeyAttributes().lastObject();\n            String sourceKey = expression.sqlStringForAttribute(sourceKeyAttribute);\n\n            EOAttribute destKeyAttribute = relationship.destinationAttributes().lastObject();\n            String destKey = expression.sqlStringForAttribute(destKeyAttribute);\n            \n            EOQualifier qual = EOQualifierSQLGeneration.Support._schemaBasedQualifierWithRootEntity(subqualifier, destEntity);\n            EOFetchSpecification fetchSpecification = new EOFetchSpecification(destEntity.name(), qual, null, false, true, null);\n\n            EODatabaseContext context = EODatabaseContext.registeredDatabaseContextForModel(destEntity.model(), EOObjectStoreCoordinator.defaultCoordinator());\n            EOSQLExpressionFactory factory = context.database().adaptor().expressionFactory();\n\n            EOSQLExpression subExpression = factory.expressionForEntity(destEntity);\n            subExpression.aliasesByRelationshipPath().setObjectForKey(destTableAlias, \"\");\n            subExpression.setUseAliases(true);\n            subExpression.prepareSelectExpressionWithAttributes(destEntity.primaryKeyAttributes(), false, fetchSpecification);\n\n            for (Enumeration bindEnumeration = subExpression.bindVariableDictionaries().objectEnumerator(); bindEnumeration.hasMoreElements();) {\n                expression.addBindVariableDictionary((NSDictionary)bindEnumeration.nextElement());\n            }\n\n            StringBuilder sb = new StringBuilder();\n            sb.append(\" EXISTS ( \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", subExpression.statement()));\n            sb.append(\" AND \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", destKey));\n            sb.append(\" = \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", sourceTableAlias + \".\", sourceKey));\n            sb.append(\" ) \");\n            return sb.toString();\n        }","commit_id":"4469da23cc6fdef8a050651a39ae7572e46bfc2f","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <P>This method returns true if the connection URL for the\n   * database has a special flag on it which indicates to the\n   * system that the jdbcInfo which has been bundled into the\n   * plugin is acceptable to use in place of actually going to\n   * the database and getting it.\n   */\n  protected boolean shouldUseBundledJdbcInfo() {\n    boolean shouldUseBundledJdbcInfo = false;\n    String url = connectionURL();\n    if (url != null) {\n      shouldUseBundledJdbcInfo = url.toLowerCase().matches(\".*(\\\\?|\\\\?.*&)\" + PostgresqlPlugIn.QUERY_STRING_USE_BUNDLED_JDBC_INFO.toLowerCase() + \"=(true|yes)(\\\\&|$)\");\n    }\n    return shouldUseBundledJdbcInfo;\n  }","id":38768,"modified_method":"/**\n   * This method returns <code>true<\/code> if the connection URL for the\n   * database has a special flag on it which indicates to the\n   * system that the jdbcInfo which has been bundled into the\n   * plugin is acceptable to use in place of actually going to\n   * the database and getting it.\n   * \n   * @return <code>true<\/code> if bundled jdbcInfo should be used\n   */\n  protected boolean shouldUseBundledJdbcInfo() {\n    boolean shouldUseBundledJdbcInfo = false;\n    String url = connectionURL();\n    if (url != null) {\n      shouldUseBundledJdbcInfo = url.toLowerCase().matches(\".*(\\\\?|\\\\?.*&)\" + PostgresqlPlugIn.QUERY_STRING_USE_BUNDLED_JDBC_INFO.toLowerCase() + \"=(true|yes)(\\\\&|$)\");\n    }\n    return shouldUseBundledJdbcInfo;\n  }","commit_id":"dff89683530056aa7e8ae7271f72c2303c32b25e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Name of the driver.\n   */\n  public String defaultDriverName() {\n    return \"org.postgresql.Driver\";\n  }","id":38769,"modified_method":"@Override\n  public String defaultDriverName() {\n    return \"org.postgresql.Driver\";\n  }","commit_id":"dff89683530056aa7e8ae7271f72c2303c32b25e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <P>This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * <\/P> \n   */\n  public NSDictionary jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n//    try {\n//      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n//      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n//      fos.write(jdbcInfoS.getBytes());\n//      fos.close();\n//    }\n//    catch(Exception e) {\n//      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n//    }\n\n    NSDictionary jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if(shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n      \n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      }\n    }\n    else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","id":38770,"modified_method":"/**\n   * This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * \n   * @return jdbcInfo dictionary\n   */\n  @Override\n  public NSDictionary jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n//    try {\n//      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n//      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n//      fos.write(jdbcInfoS.getBytes());\n//      fos.close();\n//    }\n//    catch(Exception e) {\n//      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n//    }\n\n    NSDictionary jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if(shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n      \n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      }\n    }\n    else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","commit_id":"dff89683530056aa7e8ae7271f72c2303c32b25e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Name of the database.\n   */\n  public String databaseProductName() {\n    return \"Postgresql\";\n  }","id":38771,"modified_method":"@Override\n  public String databaseProductName() {\n    return \"Postgresql\";\n  }","commit_id":"dff89683530056aa7e8ae7271f72c2303c32b25e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique  primary key value\n   */\n  public NSArray newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n    \n    EOAttribute attribute = (EOAttribute) entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray results = new NSMutableArray(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n    \n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuffer sql = new StringBuffer();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary row;\n            while ((row = channel.fetchRow()) != null) {\n              Enumeration pksEnum = row.allValues().objectEnumerator();\n              while (pksEnum.hasMoreElements()) {\n                Number pkObj = (Number)pksEnum.nextElement();\n                Number pk;\n                if (isIntType) {\n                  pk = Integer.valueOf(pkObj.intValue());\n                }\n                else {\n                  pk = Long.valueOf(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray(entity));\n            int stmCount = statements.count();\n            for (int i = 0; i < stmCount; i++) {\n              channel.evaluateExpression((EOSQLExpression) statements.objectAtIndex(i));\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n    \n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n    \n    return results;\n  }","id":38772,"modified_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique primary key value\n   */\n  @Override\n  public NSArray<NSDictionary<String, Object>> newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n    \n    EOAttribute attribute = entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray<NSDictionary<String, Object>> results = new NSMutableArray<NSDictionary<String, Object>>(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n    \n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuilder sql = new StringBuilder();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary row;\n            while ((row = channel.fetchRow()) != null) {\n              Enumeration pksEnum = row.allValues().objectEnumerator();\n              while (pksEnum.hasMoreElements()) {\n                Number pkObj = (Number)pksEnum.nextElement();\n                Number pk;\n                if (isIntType) {\n                  pk = Integer.valueOf(pkObj.intValue());\n                }\n                else {\n                  pk = Long.valueOf(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary<String, Object>(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary<String, Object> row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray<EOSQLExpression> statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray<EOEntity>(entity));\n            int stmCount = statements.count();\n            for (int i = 0; i < stmCount; i++) {\n              channel.evaluateExpression(statements.objectAtIndex(i));\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n    \n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n    \n    return results;\n  }","commit_id":"dff89683530056aa7e8ae7271f72c2303c32b25e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <P>WebObjects 5.4's version of JDBCAdaptor will use this\n   * in order to assemble the name of the prototype to use when\n   * it loads models.<\/P>\n   * @return the name of the plugin.\n   */\n  public String name() {\n    return \"Postgresql\";\n  }","id":38773,"modified_method":"/**\n   * WebObjects 5.4's version of JDBCAdaptor will use this\n   * in order to assemble the name of the prototype to use when\n   * it loads models.\n   * \n   * @return the name of the plugin\n   */\n  @Override\n  public String name() {\n    return \"Postgresql\";\n  }","commit_id":"dff89683530056aa7e8ae7271f72c2303c32b25e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Checks whether primary key generation can be supported for <code>entity<\/code>\n   *\n   * @param entity    the entity to be checked\n   * @return  yes/no\n   */\n  private boolean isPrimaryKeyGenerationNotSupported(EOEntity entity) {\n    return entity.primaryKeyAttributes().count() > 1 || ((EOAttribute) entity.primaryKeyAttributes().lastObject()).adaptorValueType() != EOAttribute.AdaptorNumberType;\n  }","id":38774,"modified_method":"/**\n   * Checks whether primary key generation can be supported for <code>entity<\/code>\n   *\n   * @param entity    the entity to be checked\n   * @return  yes/no\n   */\n  private boolean isPrimaryKeyGenerationNotSupported(EOEntity entity) {\n    return entity.primaryKeyAttributes().count() > 1 || entity.primaryKeyAttributes().lastObject().adaptorValueType() != EOAttribute.AdaptorNumberType;\n  }","commit_id":"dff89683530056aa7e8ae7271f72c2303c32b25e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public int updateValuesInRowsDescribedByQualifier(NSDictionary aRow, EOQualifier aQualifier, EOEntity anEntity) {\n        if (aRow != null) {\n            if (aQualifier != null) {\n                if (anEntity != null) {\n                    NSArray someFiles = FSQualifierHandler.filesWithQualifier(aQualifier, rootDirectory(anEntity));\n                    if (someFiles != null) {\n                        someFiles = filteredArrayWithEntity(someFiles, anEntity);\n                        if (someFiles != null) {\n                            int count = someFiles.count();\n                            for (int index = 0; index < count; index++) {\n                                File aFile = (File) someFiles.objectAtIndex(index);\n                                NSArray someKeys = aRow.allKeys();\n                                int keyCount = someKeys.count();\n\n                                for (int keyIndex = 0; keyIndex < keyCount; keyIndex++) {\n                                    Object aKey = someKeys.objectAtIndex(keyIndex);\n                                    EOAttribute anAttribute = anEntity.attributeNamed(aKey.toString());\n                                    if (anAttribute != null) {\n                                        Object aValue = aRow.objectForKey(aKey);\n\n                                        NSKeyValueCoding.DefaultImplementation.takeValueForKey(aFile, aValue, anAttribute.columnName());\n                                    }\n                                }\n                            }\n                            return count;\n                        }\n                    }\n                    return 0;\n                }\n                throw new IllegalArgumentException(\"FSAdaptorChannel.updateValuesInRowsDescribedByQualifier: null entity.\");\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.updateValuesInRowsDescribedByQualifier: null qualifier.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.updateValuesInRowsDescribedByQualifier: null row.\");\n    }","id":38775,"modified_method":"public int updateValuesInRowsDescribedByQualifier(NSDictionary aRow, EOQualifier aQualifier, EOEntity anEntity) {\n        if (aRow != null) {\n            if (aQualifier != null) {\n                if (anEntity != null) {\n                    NSArray<File> someFiles = FSQualifierHandler.filesWithQualifier(aQualifier, rootDirectory(anEntity));\n                    if (someFiles != null) {\n                        someFiles = filteredArrayWithEntity(someFiles, anEntity);\n                        if (someFiles != null) {\n                            int count = someFiles.count();\n                            for (int index = 0; index < count; index++) {\n                                File aFile = someFiles.objectAtIndex(index);\n                                NSArray someKeys = aRow.allKeys();\n                                int keyCount = someKeys.count();\n\n                                for (int keyIndex = 0; keyIndex < keyCount; keyIndex++) {\n                                    Object aKey = someKeys.objectAtIndex(keyIndex);\n                                    EOAttribute anAttribute = anEntity.attributeNamed(aKey.toString());\n                                    if (anAttribute != null) {\n                                        Object aValue = aRow.objectForKey(aKey);\n\n                                        NSKeyValueCoding.DefaultImplementation.takeValueForKey(aFile, aValue, anAttribute.columnName());\n                                    }\n                                }\n                            }\n                            return count;\n                        }\n                    }\n                    return 0;\n                }\n                throw new IllegalArgumentException(\"FSAdaptorChannel.updateValuesInRowsDescribedByQualifier: null entity.\");\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.updateValuesInRowsDescribedByQualifier: null qualifier.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.updateValuesInRowsDescribedByQualifier: null row.\");\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSMutableDictionary fetchRow() {\n        File aFile = (File) files().lastObject();\n        if (aFile != null) {\n            files().removeLastObject();\n            return dictionaryForFileWithAttributes(aFile, attributesToFetch());\n        }\n        return null;\n    }","id":38776,"modified_method":"public NSMutableDictionary<String, Object> fetchRow() {\n        File aFile = files().lastObject();\n        if (aFile != null) {\n            files().removeLastObject();\n            return dictionaryForFileWithAttributes(aFile, attributesToFetch());\n        }\n        return null;\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void insertRow(NSDictionary aRow, EOEntity anEntity) {\n        if (aRow != null) {\n            if (anEntity != null) {\n                String aPath = (String) aRow.objectForKey(\"absolutePath\");\n                if (aPath != null) {\n                    File aFile = new File(aPath);\n                    try {\n                        if (anEntity.externalName().equals(\"FSDirectory\"))\n                            aFile.mkdirs();\n                        else\n                            aFile.createNewFile();\n                    } catch (Exception anException) {\n                        throw new RuntimeException(\"FSAdaptorChannel.insertRow: \" + anException);\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSAdaptorChannel.insertRow: null absolutePath.\");\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.insertRow: null entity.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.insertRow: null row.\");\n    }","id":38777,"modified_method":"public void insertRow(NSDictionary<String, Object> aRow, EOEntity anEntity) {\n        if (aRow != null) {\n            if (anEntity != null) {\n                String aPath = (String) aRow.objectForKey(\"absolutePath\");\n                if (aPath != null) {\n                    File aFile = new File(aPath);\n                    try {\n                        if (anEntity.externalName().equals(\"FSDirectory\"))\n                            aFile.mkdirs();\n                        else\n                            aFile.createNewFile();\n                    } catch (Exception anException) {\n                        throw new RuntimeException(\"FSAdaptorChannel.insertRow: \" + anException);\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSAdaptorChannel.insertRow: null absolutePath.\");\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.insertRow: null entity.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.insertRow: null row.\");\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setAttributesToFetch(NSArray someAttributes) {\n        if (someAttributes != null)\n            _attributes = someAttributes;\n        else\n            throw new IllegalArgumentException(\"FSAdaptorChannel.setAttributesToFetch: null attributes.\");\n    }","id":38778,"modified_method":"public void setAttributesToFetch(NSArray<EOAttribute> someAttributes) {\n        if (someAttributes != null)\n            _attributes = someAttributes;\n        else\n            throw new IllegalArgumentException(\"FSAdaptorChannel.setAttributesToFetch: null attributes.\");\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"private NSMutableDictionary dictionaryForFileWithAttributes(File aFile, NSArray someAttributes) {\n        if (aFile != null) {\n            if (someAttributes != null) {\n                NSMutableDictionary aDictionary = new NSMutableDictionary();\n                int count = someAttributes.count();\n                for (int index = 0; index < count; index++) {\n                    EOAttribute anAttribute = (EOAttribute) someAttributes.objectAtIndex(index);\n                    String columnName = anAttribute.columnName();\n                    Object aValue = null;\n                    if (\"content\".equals(columnName)) {\n                        InputStream in = null;\n                        try {\n                            String path = aFile.getAbsolutePath();\n                            in = new FileInputStream(path);\n                            int length = in.available();\n                            if (length == 0) {\n                                aValue = \"\";\n                            } else {\n                                byte buffer[] = new byte[length];\n                                in.read(buffer);\n                                aValue = new String(buffer);\n                            }\n                        } catch (IOException ex) {\n                            System.err.println(\"dictionaryForFileWithAttributes : (\" + aFile.getName() + \") \" + ex);\n                        } finally {\n                            if (in != null) {\n                                try {\n                                    in.close();\n                                } catch (IOException e) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    } else if (\"realFile\".equals(columnName)) {\n                        aValue = aFile;\n                    } else {\n                        aValue = NSKeyValueCoding.DefaultImplementation.valueForKey(aFile, columnName);\n                    }\n                    if (aValue == null)\n                        aValue = NSKeyValueCoding.NullValue;\n                    aDictionary.setObjectForKey(aValue, anAttribute.name());\n                }\n                return aDictionary;\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.dictionaryForFileWithAttributes: null attributes.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.dictionaryForFileWithAttributes: null file.\");\n    }","id":38779,"modified_method":"private NSMutableDictionary<String, Object> dictionaryForFileWithAttributes(File aFile, NSArray<EOAttribute> someAttributes) {\n        if (aFile != null) {\n            if (someAttributes != null) {\n                NSMutableDictionary<String, Object> aDictionary = new NSMutableDictionary<String, Object>();\n                for (EOAttribute anAttribute : someAttributes) {\n                    String columnName = anAttribute.columnName();\n                    Object aValue = null;\n                    if (\"content\".equals(columnName)) {\n                        InputStream in = null;\n                        try {\n                            String path = aFile.getAbsolutePath();\n                            in = new FileInputStream(path);\n                            int length = in.available();\n                            if (length == 0) {\n                                aValue = \"\";\n                            } else {\n                                byte buffer[] = new byte[length];\n                                in.read(buffer);\n                                aValue = new String(buffer);\n                            }\n                        } catch (IOException ex) {\n                            System.err.println(\"dictionaryForFileWithAttributes : (\" + aFile.getName() + \") \" + ex);\n                        } finally {\n                            if (in != null) {\n                                try {\n                                    in.close();\n                                } catch (IOException e) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    } else if (\"realFile\".equals(columnName)) {\n                        aValue = aFile;\n                    } else {\n                        aValue = NSKeyValueCoding.DefaultImplementation.valueForKey(aFile, columnName);\n                    }\n                    if (aValue == null)\n                        aValue = NSKeyValueCoding.NullValue;\n                    aDictionary.setObjectForKey(aValue, anAttribute.name());\n                }\n                return aDictionary;\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.dictionaryForFileWithAttributes: null attributes.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.dictionaryForFileWithAttributes: null file.\");\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"public int deleteRowsDescribedByQualifier(EOQualifier aQualifier, EOEntity anEntity) {\n        if (aQualifier != null) {\n            if (anEntity != null) {\n                NSArray someFiles = FSQualifierHandler.filesWithQualifier(aQualifier, rootDirectory(anEntity));\n                if (someFiles != null) {\n                    someFiles = filteredArrayWithEntity(someFiles, anEntity);\n                    if (someFiles != null) {\n                        int count = someFiles.count();\n                        int counter = 0;\n                        for (int index = 0; index < count; index++) {\n                            File aFile = (File) someFiles.objectAtIndex(index);\n                            if (aFile.delete())\n                                counter++;\n                        }\n                        return counter;\n                    }\n                }\n                return 0;\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.deleteRowsDescribedByQualifier: null entity.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.deleteRowsDescribedByQualifier: null qualifier.\");\n    }","id":38780,"modified_method":"public int deleteRowsDescribedByQualifier(EOQualifier aQualifier, EOEntity anEntity) {\n        if (aQualifier != null) {\n            if (anEntity != null) {\n                NSArray<File> someFiles = FSQualifierHandler.filesWithQualifier(aQualifier, rootDirectory(anEntity));\n                if (someFiles != null) {\n                    someFiles = filteredArrayWithEntity(someFiles, anEntity);\n                    if (someFiles != null) {\n                        int count = someFiles.count();\n                        int counter = 0;\n                        for (int index = 0; index < count; index++) {\n                            File aFile = someFiles.objectAtIndex(index);\n                            if (aFile.delete())\n                                counter++;\n                        }\n                        return counter;\n                    }\n                }\n                return 0;\n            }\n            throw new IllegalArgumentException(\"FSAdaptorChannel.deleteRowsDescribedByQualifier: null entity.\");\n        }\n        throw new IllegalArgumentException(\"FSAdaptorChannel.deleteRowsDescribedByQualifier: null qualifier.\");\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void selectAttributes(NSArray someAttributes, EOFetchSpecification aFetchSpecification, boolean shouldLock, EOEntity anEntity) {\n        if (anEntity == null)\n            throw new IllegalArgumentException(\"FSAdaptorChannel.selectAttributes: null entity.\");\n        if (someAttributes == null)\n            throw new IllegalArgumentException(\"FSAdaptorChannel.selectAttributes: null attributes.\");\n\n        setAttributesToFetch(someAttributes);\n\n        EOQualifier qualifier = null;\n        String entityName = anEntity.name();\n\n        if (aFetchSpecification != null)\n            qualifier = aFetchSpecification.qualifier();\n\n        if (debug)\n            System.out.println(\"*****selectAttributes: \" + entityName + \"--\" + aFetchSpecification.entityName() + \"--\" + aFetchSpecification);\n        // if(true) throw new RuntimeException();\n        NSArray someFiles = (FSQualifierHandler.filesWithQualifier(qualifier, rootDirectory(anEntity)));\n\n        if (someFiles != null) {\n            NSArray someSortOrderings = aFetchSpecification.sortOrderings();\n            if (someSortOrderings != null)\n                someFiles = (EOSortOrdering.sortedArrayUsingKeyOrderArray(someFiles, someSortOrderings));\n            someFiles = filteredArrayWithEntity(someFiles, anEntity);\n            if (someFiles != null)\n                files().addObjectsFromArray(someFiles);\n        }\n    }","id":38781,"modified_method":"public void selectAttributes(NSArray<EOAttribute> someAttributes, EOFetchSpecification aFetchSpecification, boolean shouldLock, EOEntity anEntity) {\n        if (anEntity == null)\n            throw new IllegalArgumentException(\"FSAdaptorChannel.selectAttributes: null entity.\");\n        if (someAttributes == null)\n            throw new IllegalArgumentException(\"FSAdaptorChannel.selectAttributes: null attributes.\");\n\n        setAttributesToFetch(someAttributes);\n\n        EOQualifier qualifier = null;\n        String entityName = anEntity.name();\n\n        if (aFetchSpecification != null)\n            qualifier = aFetchSpecification.qualifier();\n\n        if (debug)\n            System.out.println(\"*****selectAttributes: \" + entityName + \"--\" + aFetchSpecification.entityName() + \"--\" + aFetchSpecification);\n        // if(true) throw new RuntimeException();\n        NSArray<File> someFiles = FSQualifierHandler.filesWithQualifier(qualifier, rootDirectory(anEntity));\n\n        if (someFiles != null) {\n            NSArray<EOSortOrdering> someSortOrderings = aFetchSpecification.sortOrderings();\n            if (someSortOrderings != null)\n                someFiles = EOSortOrdering.sortedArrayUsingKeyOrderArray(someFiles, someSortOrderings);\n            someFiles = filteredArrayWithEntity(someFiles, anEntity);\n            if (someFiles != null)\n                files().addObjectsFromArray(someFiles);\n        }\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"private static void addFilesWithQualifierToSet(EOQualifier aQualifier, NSMutableSet aSet) {\n        if (aQualifier != null) {\n            if (aSet != null) {\n                FSQualifierHandler[] someHandlers = handlers();\n                int count = someHandlers.length;\n                for (int index = 0; index < count; index++) {\n                    FSQualifierHandler anHandler = someHandlers[index];\n                    if (anHandler.canHandleQualifier(aQualifier)) {\n                        anHandler.addFilesMatchingQualifierToSet(aQualifier, aSet);\n                        break;\n                    }\n                }\n                return;\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.addFilesWithQualifierToSet: null set.\");\n        }\n        throw new IllegalArgumentException(\"FSQualifierHandler.addFilesWithQualifierToSet: null qualifier.\");\n    }","id":38782,"modified_method":"private static void addFilesWithQualifierToSet(EOQualifier aQualifier, NSMutableSet<File> aSet) {\n        if (aQualifier != null) {\n            if (aSet != null) {\n                FSQualifierHandler[] someHandlers = handlers();\n                int count = someHandlers.length;\n                for (int index = 0; index < count; index++) {\n                    FSQualifierHandler anHandler = someHandlers[index];\n                    if (anHandler.canHandleQualifier(aQualifier)) {\n                        anHandler.addFilesMatchingQualifierToSet(aQualifier, aSet);\n                        break;\n                    }\n                }\n                return;\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.addFilesWithQualifierToSet: null set.\");\n        }\n        throw new IllegalArgumentException(\"FSQualifierHandler.addFilesWithQualifierToSet: null qualifier.\");\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    addFileWithQualifierToSet((EOKeyValueQualifier) aQualifier, aSet);\n                    addParentFilesWithQualifierToSet(((EOKeyValueQualifier) aQualifier), aSet);\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","id":38783,"modified_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet<File> aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    addFileWithQualifierToSet((EOKeyValueQualifier) aQualifier, aSet);\n                    addParentFilesWithQualifierToSet(((EOKeyValueQualifier) aQualifier), aSet);\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    NSArray someQualifiers = ((EOOrQualifier) aQualifier).qualifiers();\n                    if (someQualifiers != null) {\n                        int count = someQualifiers.count();\n                        for (int index = 0; index < count; index++) {\n                            EOQualifier anotherQualifier = ((EOQualifier) someQualifiers.objectAtIndex(index));\n                            FSQualifierHandler.addFilesWithQualifierToSet(anotherQualifier, aSet);\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.Or.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.Or.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","id":38784,"modified_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet<File> aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    NSArray<EOQualifier> someQualifiers = ((EOOrQualifier) aQualifier).qualifiers();\n                    if (someQualifiers != null) {\n                        int count = someQualifiers.count();\n                        for (int index = 0; index < count; index++) {\n                            EOQualifier anotherQualifier = someQualifiers.objectAtIndex(index);\n                            FSQualifierHandler.addFilesWithQualifierToSet(anotherQualifier, aSet);\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.Or.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.Or.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    NSArray someQualifiers = ((EOAndQualifier) aQualifier).qualifiers();\n                    if (someQualifiers != null) {\n                        int count = someQualifiers.count();\n                        for (int index = 0; index < count; index++) {\n                            EOQualifier anotherQualifier = ((EOQualifier) someQualifiers.objectAtIndex(index));\n                            FSQualifierHandler.addFilesWithQualifierToSet(anotherQualifier, aSet);\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.And.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.And.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","id":38785,"modified_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet<File> aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    NSArray<EOQualifier> someQualifiers = ((EOAndQualifier) aQualifier).qualifiers();\n                    if (someQualifiers != null) {\n                        int count = someQualifiers.count();\n                        for (int index = 0; index < count; index++) {\n                            EOQualifier anotherQualifier = someQualifiers.objectAtIndex(index);\n                            FSQualifierHandler.addFilesWithQualifierToSet(anotherQualifier, aSet);\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.And.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.And.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void addParentFilesWithQualifierToSet(EOKeyValueQualifier aQualifier, NSMutableSet aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    String aKey = aQualifier.key();\n                    if (aKey.equals(ParentPathKey)) {\n                        String aPath = aQualifier.value().toString();\n                        File aFile = fileWithPath(aPath);\n                        if (aFile.exists() && aFile.isDirectory()) {\n                            File[] someFiles = aFile.listFiles();\n                            if (someFiles != null && someFiles.length > 0) {\n                                NSArray files = new NSArray(someFiles);\n                                aSet.addObjectsFromArray(files);\n                                if (debug)\n                                    System.out.println(\"EOKeyValueQualifier.addParentFilesWithQualifierToSet: \" + files);\n                            }\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addParentFilesWithQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addParentFilesWithQualifierToSet: null qualifier.\");\n        }","id":38786,"modified_method":"private void addParentFilesWithQualifierToSet(EOKeyValueQualifier aQualifier, NSMutableSet<File> aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    String aKey = aQualifier.key();\n                    if (aKey.equals(ParentPathKey)) {\n                        String aPath = aQualifier.value().toString();\n                        File aFile = fileWithPath(aPath);\n                        if (aFile.exists() && aFile.isDirectory()) {\n                            File[] someFiles = aFile.listFiles();\n                            if (someFiles != null && someFiles.length > 0) {\n                                NSArray<File> files = new NSArray<File>(someFiles);\n                                aSet.addObjectsFromArray(files);\n                                if (debug)\n                                    System.out.println(\"EOKeyValueQualifier.addParentFilesWithQualifierToSet: \" + files);\n                            }\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addParentFilesWithQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addParentFilesWithQualifierToSet: null qualifier.\");\n        }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void addFileWithQualifierToSet(EOKeyValueQualifier aQualifier, NSMutableSet aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    String aKey = aQualifier.key();\n                    for (int index = 0; index < PathKeysCount; index++) {\n                        if (aKey.equals(PathKeys[index])) {\n                            String aPath = aQualifier.value().toString();\n                            File aFile = fileWithPath(aPath);\n                            if (aFile.exists())\n                                aSet.addObject(aFile);\n                            if (debug)\n                                System.out.println(\"EOKeyValueQualifier.addFileWithQualifierToSet: \" + aFile);\n                            break;\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFileWithQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFileWithQualifierToSet: null qualifier.\");\n        }","id":38787,"modified_method":"private void addFileWithQualifierToSet(EOKeyValueQualifier aQualifier, NSMutableSet<File> aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    String aKey = aQualifier.key();\n                    for (int index = 0; index < PathKeysCount; index++) {\n                        if (aKey.equals(PathKeys[index])) {\n                            String aPath = aQualifier.value().toString();\n                            File aFile = fileWithPath(aPath);\n                            if (aFile.exists())\n                                aSet.addObject(aFile);\n                            if (debug)\n                                System.out.println(\"EOKeyValueQualifier.addFileWithQualifierToSet: \" + aFile);\n                            break;\n                        }\n                    }\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFileWithQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.KeyValue.addFileWithQualifierToSet: null qualifier.\");\n        }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"static NSArray filesWithQualifier(EOQualifier aQualifier, String root) {\n        if (aQualifier != null) {\n            rootDirectory = root;\n            if (debug)\n                System.out.println(\"FSQualifierHandler.rootDirectory: \" + rootDirectory);\n            NSMutableSet aSet = new NSMutableSet();\n            addFilesWithQualifierToSet(aQualifier, aSet);\n            if (aSet.count() > 0) {\n                NSArray anArray = EOQualifier.filteredArrayWithQualifier(aSet.allObjects(), aQualifier);\n                if (anArray != null && anArray.count() > 0) {\n                    if (debug)\n                        System.out.println(\"FSQualifierHandler.filesWithQualifier: \" + anArray);\n                    return anArray;\n                }\n            }\n            return null;\n        }\n        if (root != null) {\n            File aFile = fileWithPath(\"\");\n            if (aFile.exists() && aFile.isDirectory()) {\n                return new NSArray(aFile.listFiles());\n            }\n            return null;\n        }\n        throw new IllegalArgumentException(\"FSQualifierHandler.filesWithQualifier: null qualifier.\");\n    }","id":38788,"modified_method":"static NSArray<File> filesWithQualifier(EOQualifier aQualifier, String root) {\n        if (aQualifier != null) {\n            rootDirectory = root;\n            if (debug)\n                System.out.println(\"FSQualifierHandler.rootDirectory: \" + rootDirectory);\n            NSMutableSet<File> aSet = new NSMutableSet<File>();\n            addFilesWithQualifierToSet(aQualifier, aSet);\n            if (aSet.count() > 0) {\n                NSArray<File> anArray = EOQualifier.filteredArrayWithQualifier(aSet.allObjects(), aQualifier);\n                if (anArray != null && anArray.count() > 0) {\n                    if (debug)\n                        System.out.println(\"FSQualifierHandler.filesWithQualifier: \" + anArray);\n                    return anArray;\n                }\n            }\n            return null;\n        }\n        if (root != null) {\n            File aFile = fileWithPath(\"\");\n            if (aFile.exists() && aFile.isDirectory()) {\n                return new NSArray<File>(aFile.listFiles());\n            }\n            return null;\n        }\n        throw new IllegalArgumentException(\"FSQualifierHandler.filesWithQualifier: null qualifier.\");\n    }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected abstract void addFilesMatchingQualifierToSet(EOQualifier eoqualifier, NSMutableSet nsmutableset);","id":38789,"modified_method":"protected abstract void addFilesMatchingQualifierToSet(EOQualifier eoqualifier, NSMutableSet<File> nsmutableset);","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    FSQualifierHandler.addFilesWithQualifierToSet(((EONotQualifier) aQualifier).qualifier(), aSet);\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.Not.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.Not.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","id":38790,"modified_method":"protected void addFilesMatchingQualifierToSet(EOQualifier aQualifier, NSMutableSet<File> aSet) {\n            if (aQualifier != null) {\n                if (aSet != null) {\n                    FSQualifierHandler.addFilesWithQualifierToSet(((EONotQualifier) aQualifier).qualifier(), aSet);\n                    return;\n                }\n                throw new IllegalArgumentException(\"FSQualifierHandler.Not.addFilesMatchingQualifierToSet: null set.\");\n            }\n            throw new IllegalArgumentException(\"FSQualifierHandler.Not.addFilesMatchingQualifierToSet: null qualifier.\");\n        }","commit_id":"798f6ff6b46b1aa7300dc63b5a01805efd13f939","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns an {@link com.webobjects.foundation.NSArray NSArray} containing the primary keys from the resulting rows starting\n     * at start and stopping at end using a custom SQL, derived from the SQL\n     * which the {@link com.webobjects.eocontrol.EOFetchSpecification EOFetchSpecification} would use normally {@link com.webobjects.eocontrol.EOFetchSpecification#setHints(NSDictionary) setHints()}\n     *\n     * @param ec editingcontext to fetch objects into\n     * @param spec fetch specification for the fetch\n     * @param start\n     * @param end\n     *\n     * @return primary keys in the given range\n     */\n    public static NSArray primaryKeyValuesInRange(EOEditingContext ec, EOFetchSpecification spec, int start, int end) {\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, spec.entityName());\n        NSArray pkNames = (NSArray) entity.primaryKeyAttributes().valueForKey(\"name\");\n        spec.setFetchesRawRows(true);\n        spec.setRawRowKeyPaths(pkNames);\n        EOSQLExpression sql = ERXEOAccessUtilities.sqlExpressionForFetchSpecification(ec, spec, start, end);\n        NSDictionary hints = new NSDictionary(sql, \"EOCustomQueryExpressionHintKey\");\n        spec.setHints(hints);\n        return ec.objectsWithFetchSpecification(spec);\n    }","id":38791,"modified_method":"/**\n     * Returns an {@link com.webobjects.foundation.NSArray NSArray} containing the primary keys from the resulting rows starting\n     * at start and stopping at end using a custom SQL, derived from the SQL\n     * which the {@link com.webobjects.eocontrol.EOFetchSpecification EOFetchSpecification} would use normally {@link com.webobjects.eocontrol.EOFetchSpecification#setHints(NSDictionary) setHints()}\n     *\n     * @param ec editingcontext to fetch objects into\n     * @param spec fetch specification for the fetch\n     * @param start\n     * @param end\n     *\n     * @return primary keys in the given range\n     */\n    public static NSArray primaryKeyValuesInRange(EOEditingContext ec, EOFetchSpecification spec, int start, int end) {\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, spec.entityName());\n        NSArray pkNames = (NSArray) entity.primaryKeyAttributes().valueForKey(\"name\");\n        spec.setFetchesRawRows(true);\n        spec.setRawRowKeyPaths(pkNames);\n        EOSQLExpression sql = ERXEOAccessUtilities.sqlExpressionForFetchSpecification(ec, spec, start, end);\n        NSDictionary<String, EOSQLExpression> hints = new NSDictionary<String, EOSQLExpression>(sql, \"EOCustomQueryExpressionHintKey\");\n        spec.setHints(hints);\n        return ec.objectsWithFetchSpecification(spec);\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the decoded dictionary for an propertylist encoded string representation\n     * of the primary key for a given object.\n     *\n     * @return string representation of the primary key of the\n     *\t\tobject.\n     */\n    public static NSDictionary primaryKeyDictionaryForString(EOEditingContext ec, String entityName, String string) {\n        if(string == null)\n            return null;\n        if(string.trim().length()==0) {\n            return NSDictionary.EmptyDictionary;\n        }\n        \n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        NSArray pks = entity.primaryKeyAttributes();\n        NSMutableDictionary pk = new NSMutableDictionary();\n        try {\n            Object rawValue = NSPropertyListSerialization.propertyListFromString(string);\n            if(rawValue instanceof NSArray) {\n                int index = 0;\n                for(Enumeration e = ((NSArray)rawValue).objectEnumerator(); e.hasMoreElements();) {\n                    EOAttribute attribute = (EOAttribute)pks.objectAtIndex(index++);\n                    Object value = e.nextElement();\n                    if(attribute.adaptorValueType() == EOAttribute.AdaptorDateType && !(value instanceof NSTimestamp)) {\n                        value = new NSTimestampFormatter(\"%Y-%m-%d %H:%M:%S %Z\").parseObject((String)value);\n                    }\n                    value = attribute.validateValue(value);\n                    pk.setObjectForKey(value, attribute.name());\n                    if(pks.count() == 1) {\n                        break;\n                    }\n                }\n            } else {\n            \tif(rawValue instanceof NSMutableData) {\n                \t// AK: wtf!! I got an exception \n                \t// java.lang.IllegalArgumentException: Attempt to create an EOGlobalID for the entity \"Asset\" with a primary key component of type com.webobjects.foundation.NSMutableData instead of type com.webobjects.foundation.NSData!\n                \t// so this is a lame attempt to fix it.\n                \t\n            \t\trawValue = new NSData((NSMutableData)rawValue);\n            \t}\n                EOAttribute attribute = (EOAttribute)pks.objectAtIndex(0);\n                Object value = rawValue;\n                value = attribute.validateValue(value);\n                pk.setObjectForKey(value, attribute.name());\n            }\n            return pk;\n        } catch (Exception ex) {\n            throw new NSForwardException(ex, \"Error while parsing primary key: \" + string);\n        }\n    }","id":38792,"modified_method":"/**\n     * Returns the decoded dictionary for an propertylist encoded string representation\n     * of the primary key for a given object.\n     *\n     * @return string representation of the primary key of the\n     *\t\tobject.\n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic static NSDictionary<String, Object> primaryKeyDictionaryForString(EOEditingContext ec, String entityName, String string) {\n        if(string == null) {\n            return null;\n        }\n        \n        if(string.trim().length()==0) {\n            return NSDictionary.EmptyDictionary;\n        }\n        \n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        NSArray pks = entity.primaryKeyAttributes();\n        NSMutableDictionary<String, Object> pk = new NSMutableDictionary<String, Object>();\n        try {\n            Object rawValue = NSPropertyListSerialization.propertyListFromString(string);\n            if(rawValue instanceof NSArray) {\n                int index = 0;\n                for(Enumeration e = ((NSArray)rawValue).objectEnumerator(); e.hasMoreElements();) {\n                    EOAttribute attribute = (EOAttribute)pks.objectAtIndex(index++);\n                    Object value = e.nextElement();\n                    if(attribute.adaptorValueType() == EOAttribute.AdaptorDateType && !(value instanceof NSTimestamp)) {\n                        value = new NSTimestampFormatter(\"%Y-%m-%d %H:%M:%S %Z\").parseObject((String)value);\n                    }\n                    value = attribute.validateValue(value);\n                    pk.setObjectForKey(value, attribute.name());\n                    if(pks.count() == 1) {\n                        break;\n                    }\n                }\n            } else {\n            \tif(rawValue instanceof NSMutableData) {\n                \t// AK: wtf!! I got an exception \n                \t// java.lang.IllegalArgumentException: Attempt to create an EOGlobalID for the entity \"Asset\" with a primary key component of type com.webobjects.foundation.NSMutableData instead of type com.webobjects.foundation.NSData!\n                \t// so this is a lame attempt to fix it.\n                \t\n            \t\trawValue = new NSData((NSMutableData)rawValue);\n            \t}\n                EOAttribute attribute = (EOAttribute)pks.objectAtIndex(0);\n                Object value = rawValue;\n                value = attribute.validateValue(value);\n                pk.setObjectForKey(value, attribute.name());\n            }\n            return pk;\n        } catch (Exception ex) {\n            throw new NSForwardException(ex, \"Error while parsing primary key: \" + string);\n        }\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n    * Fetches an array of primary keys matching a given qualifier\n     * and sorted with a given array of sort orderings.\n     * @param ec editing context to fetch into\n     * @param entityName name of the entity\n     * @param eoqualifier to restrict matching primary keys\n     * @param sortOrderings array of sort orders to sort result set\n     * @return array of primary keys matching a given qualifier\n     */\n    public static NSArray primaryKeysMatchingQualifier(EOEditingContext ec,\n                                                       String entityName,\n                                                       EOQualifier eoqualifier,\n                                                       NSArray sortOrderings) {\n        EOFetchSpecification fs = ERXEOControlUtilities.primaryKeyFetchSpecificationForEntity(ec,\n                                                                                              entityName,\n                                                                                              eoqualifier,\n                                                                                              sortOrderings,\n                                                                                              null);\n        return ec.objectsWithFetchSpecification(fs);\n    }","id":38793,"modified_method":"/**\n    * Fetches an array of primary keys matching a given qualifier\n     * and sorted with a given array of sort orderings.\n     * @param ec editing context to fetch into\n     * @param entityName name of the entity\n     * @param eoqualifier to restrict matching primary keys\n     * @param sortOrderings array of sort orders to sort result set\n     * @return array of primary keys matching a given qualifier\n     */\n    public static NSArray primaryKeysMatchingQualifier(EOEditingContext ec,\n                                                       String entityName,\n                                                       EOQualifier eoqualifier,\n                                                       NSArray<EOSortOrdering> sortOrderings) {\n        EOFetchSpecification fs = ERXEOControlUtilities.primaryKeyFetchSpecificationForEntity(ec,\n                                                                                              entityName,\n                                                                                              eoqualifier,\n                                                                                              sortOrderings,\n                                                                                              null);\n        return ec.objectsWithFetchSpecification(fs);\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fetches an enterprise object based on a given primary key value.\n     * This method has an advantage over the standard EOUtilities method\n     * in that you can specify prefetching key paths as well as refreshing\n     * the snapshot of the given object\n     * @param ec editing context to fetch into\n     * @param entityName name of the entity\n     * @param primaryKeyValue primary key value. Compound primary keys are given as NSDictionaries.\n     * @param prefetchingKeyPaths key paths to fetch off of the eo\n     * @return enterprise object matching the given value\n     */    \n    public static EOEnterpriseObject objectWithPrimaryKeyValue(EOEditingContext ec,\n                                                               String entityName,\n                                                               Object primaryKeyValue,\n                                                               NSArray prefetchingKeyPaths) {\n        EOEntity entity = EOUtilities.entityNamed(ec, entityName);\n        NSDictionary values;\n        if(primaryKeyValue instanceof NSDictionary) {\n            values = (NSDictionary)primaryKeyValue;\n        }  else {\n            if (entity.primaryKeyAttributes().count() != 1) {\n                throw new IllegalStateException(\"Entity \\\"\" + entity.name() + \"\\\" has a compound primary key. Can't be used with the method: objectWithPrimaryKeyValue\");\n            }\n            values = new NSDictionary(primaryKeyValue,\n                               ((EOAttribute)entity.primaryKeyAttributes().lastObject()).name());\n        }\n        EOQualifier qualfier = EOQualifier.qualifierToMatchAllValues(values);\n        EOFetchSpecification fs = new EOFetchSpecification(entityName, qualfier, null);\n        // Might as well get fresh stuff\n        fs.setRefreshesRefetchedObjects(true);\n        if (prefetchingKeyPaths != null)\n            fs.setPrefetchingRelationshipKeyPaths(prefetchingKeyPaths);\n        NSArray eos = ec.objectsWithFetchSpecification(fs);\n        if (eos.count() > 1)\n            throw new IllegalStateException(\"Found multiple objects for entity \\\"\" + entity.name() + \" with primary key value: \" + primaryKeyValue);\n        return eos.count() == 1 ? (EOEnterpriseObject)eos.lastObject() : null;\n    }","id":38794,"modified_method":"/**\n     * Fetches an enterprise object based on a given primary key value.\n     * This method has an advantage over the standard EOUtilities method\n     * in that you can specify prefetching key paths as well as refreshing\n     * the snapshot of the given object\n     * @param ec editing context to fetch into\n     * @param entityName name of the entity\n     * @param primaryKeyValue primary key value. Compound primary keys are given as NSDictionaries.\n     * @param prefetchingKeyPaths key paths to fetch off of the eo\n     * @return enterprise object matching the given value\n     */    \n    public static EOEnterpriseObject objectWithPrimaryKeyValue(EOEditingContext ec,\n                                                               String entityName,\n                                                               Object primaryKeyValue,\n                                                               NSArray prefetchingKeyPaths) {\n    \treturn ERXEOControlUtilities.objectWithPrimaryKeyValue(ec, entityName, primaryKeyValue, prefetchingKeyPaths, true);\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the decoded global id for an propertylist encoded string representation\n     * of the primary key for a given object.\n     */\n\n    public static EOGlobalID globalIDForString(EOEditingContext ec, String entityName, String string) {\n    \tNSDictionary values = primaryKeyDictionaryForString(ec, entityName, string);\n    \tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        NSArray pks = entity.primaryKeyAttributeNames();\n        EOGlobalID gid = EOKeyGlobalID.globalIDWithEntityName(entityName, values.objectsForKeys(pks, null).objects());\n    \treturn gid;\n    }","id":38795,"modified_method":"/**\n     * Returns the decoded global id for an propertylist encoded string representation\n     * of the primary key for a given object.\n     */\n\n    @SuppressWarnings(\"unchecked\")\n\tpublic static EOGlobalID globalIDForString(EOEditingContext ec, String entityName, String string) {\n    \tNSDictionary<String, Object> values = primaryKeyDictionaryForString(ec, entityName, string);\n    \tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        NSArray<String> pks = entity.primaryKeyAttributeNames();\n        EOGlobalID gid = EOKeyGlobalID.globalIDWithEntityName(entityName, values.objectsForKeys(pks, null).objects());\n    \treturn gid;\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Constructs a fetch specification that will only fetch the primary\n     * keys for a given qualifier.\n     * @param ec editing context, only used to determine the entity\n     * @param entityName name of the entity, only used to determine the entity\n     * @param eoqualifier to construct the fetch spec with\n     * @param sortOrderings array of sort orderings to sort the result set\n     *\t\twith.\n     * @param additionalKeys array of additional key paths to construct the\n     *\t\traw rows key paths to fetch.\n     * @return fetch specification that can be used to fetch primary keys for\n     * \t\ta given qualifier and sort orderings.\n     */\n    public static EOFetchSpecification primaryKeyFetchSpecificationForEntity(EOEditingContext ec,\n                                                                      String entityName,\n                                                                      EOQualifier eoqualifier,\n                                                                      NSArray sortOrderings,\n                                                                      NSArray additionalKeys) {\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        EOFetchSpecification fs = new EOFetchSpecification(entityName, eoqualifier, sortOrderings);\n        fs.setFetchesRawRows(true);\n        NSMutableArray keys = new NSMutableArray(entity.primaryKeyAttributeNames());\n        if (additionalKeys != null) {\n            keys.addObjectsFromArray(additionalKeys);\n        }\n        fs.setRawRowKeyPaths(keys);\n        return fs;\n    }","id":38796,"modified_method":"/**\n     * Constructs a fetch specification that will only fetch the primary\n     * keys for a given qualifier.\n     * @param ec editing context, only used to determine the entity\n     * @param entityName name of the entity, only used to determine the entity\n     * @param eoqualifier to construct the fetch spec with\n     * @param sortOrderings array of sort orderings to sort the result set\n     *\t\twith.\n     * @param additionalKeys array of additional key paths to construct the\n     *\t\traw rows key paths to fetch.\n     * @return fetch specification that can be used to fetch primary keys for\n     * \t\ta given qualifier and sort orderings.\n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic static EOFetchSpecification primaryKeyFetchSpecificationForEntity(EOEditingContext ec,\n                                                                      String entityName,\n                                                                      EOQualifier eoqualifier,\n                                                                      NSArray<EOSortOrdering> sortOrderings,\n                                                                      NSArray<String> additionalKeys) {\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        EOFetchSpecification fs = new EOFetchSpecification(entityName, eoqualifier, sortOrderings);\n        fs.setFetchesRawRows(true);\n        NSMutableArray<String> keys = new NSMutableArray<String>(entity.primaryKeyAttributeNames());\n        if (additionalKeys != null) {\n            keys.addObjectsFromArray(additionalKeys);\n        }\n        fs.setRawRowKeyPaths(keys);\n        return fs;\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Utility method to generate a new primary key for an object. Calls\n     * {@link #newPrimaryKeyForObjectFromClassProperties(EOEnterpriseObject)} and if that returns null,\n     * {@link #newPrimaryKeyDictionaryForEntityNamed(EOEditingContext, String)}\n     * @return new primary key dictionary or null if a failure occured.\n     */\n\n    public static NSDictionary<String, Object> newPrimaryKeyDictionaryForObject(EOEnterpriseObject eo) {\n        NSDictionary dict = newPrimaryKeyDictionaryForObjectFromClassProperties(eo);\n        if(dict == null) {\n            dict = newPrimaryKeyDictionaryForEntityNamed(eo.editingContext(), eo.entityName());\n        }\n        return dict;\n    }","id":38797,"modified_method":"/**\n     * Utility method to generate a new primary key for an object. Calls\n     * {@link #newPrimaryKeyForObjectFromClassProperties(EOEnterpriseObject)} and if that returns null,\n     * {@link #newPrimaryKeyDictionaryForEntityNamed(EOEditingContext, String)}\n     * @return new primary key dictionary or null if a failure occured.\n     */\n\n    public static NSDictionary<String, Object> newPrimaryKeyDictionaryForObject(EOEnterpriseObject eo) {\n        NSDictionary<String, Object> dict = newPrimaryKeyDictionaryForObjectFromClassProperties(eo);\n        if(dict == null) {\n            dict = newPrimaryKeyDictionaryForEntityNamed(eo.editingContext(), eo.entityName());\n        }\n        return dict;\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns an {@link com.webobjects.foundation.NSArray NSArray} containing the objects from the resulting rows starting\n     * at start and stopping at end using a custom SQL, derived from the SQL\n     * which the {@link com.webobjects.eocontrol.EOFetchSpecification EOFetchSpecification} would use normally {@link com.webobjects.eocontrol.EOFetchSpecification#setHints(NSDictionary) setHints()}\n     *\n     * @param ec editingcontext to fetch objects into\n     * @param spec fetch specification for the fetch\n     * @param start\n     * @param end\n     *\n     * @return objects in the given range\n     */\n    public static NSArray objectsInRange(EOEditingContext ec, EOFetchSpecification spec, int start, int end) {\n        EOSQLExpression sql = ERXEOAccessUtilities.sqlExpressionForFetchSpecification(ec, spec, start, end);\n        NSDictionary hints = new NSDictionary(sql, \"EOCustomQueryExpressionHintKey\");\n        spec.setHints(hints);\n\n        return ec.objectsWithFetchSpecification(spec);\n    }","id":38798,"modified_method":"/**\n     * Returns an {@link com.webobjects.foundation.NSArray NSArray} containing the objects from the resulting rows starting\n     * at start and stopping at end using a custom SQL, derived from the SQL\n     * which the {@link com.webobjects.eocontrol.EOFetchSpecification EOFetchSpecification} would use normally {@link com.webobjects.eocontrol.EOFetchSpecification#setHints(NSDictionary) setHints()}\n     *\n     * @param ec editingcontext to fetch objects into\n     * @param spec fetch specification for the fetch\n     * @param start\n     * @param end\n     *\n     * @return objects in the given range\n     */\n    public static NSArray objectsInRange(EOEditingContext ec, EOFetchSpecification spec, int start, int end) {\n        EOSQLExpression sql = ERXEOAccessUtilities.sqlExpressionForFetchSpecification(ec, spec, start, end);\n        NSDictionary<String, EOSQLExpression> hints = new NSDictionary<String, EOSQLExpression>(sql, \"EOCustomQueryExpressionHintKey\");\n        spec.setHints(hints);\n\n        return ec.objectsWithFetchSpecification(spec);\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Turns a given enterprise object back into a fault.\n     * @param eo enterprise object to refault\n     */\n    public static void refaultObject(EOEnterpriseObject eo) {\n        if (eo != null && !eo.isFault()) {\n            EOEditingContext ec = eo.editingContext();\n            NSArray gids = new NSArray(ec.globalIDForObject(eo));\n            ec.invalidateObjectsWithGlobalIDs(gids);\n        }\n    }","id":38799,"modified_method":"/**\n     * Turns a given enterprise object back into a fault.\n     * @param eo enterprise object to refault\n     */\n    public static void refaultObject(EOEnterpriseObject eo) {\n        if (eo != null && !eo.isFault()) {\n            EOEditingContext ec = eo.editingContext();\n            NSArray<EOGlobalID> gids = new NSArray<EOGlobalID>(ec.globalIDForObject(eo));\n            ec.invalidateObjectsWithGlobalIDs(gids);\n        }\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the number of objects in the database with the qualifier and counting attribute.  This implementation\n     * queries the database directly without loading the objects into memory.\n     * \n     * @param ec the editing context\n     * @param entityName the name of the entity\n     * @param qualifier the qualifier to filter with\n     * @param aggregateAttribute the attribute that contains the \"count(*)\" definition\n     * @return the number of objects\n     */\n    public static Object _aggregateFunctionWithQualifierAndAggregateAttribute(EOEditingContext ec, String entityName, EOQualifier qualifier, EOAttribute aggregateAttribute) {\n\t\tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n\t\tEOModel model = entity.model();\n\t\tEODatabaseContext databaseContext = EODatabaseContext.registeredDatabaseContextForModel(model, ec);\n\t\tdatabaseContext.lock();\n\t\ttry {\n\t\t\tEOSQLExpressionFactory sqlFactory = databaseContext.adaptorContext().adaptor().expressionFactory();\n\t\t\tEOQualifier schemaBasedQualifier = entity.schemaBasedQualifier(qualifier);\n\t\t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(entity.name(), schemaBasedQualifier, null);\n\t\t\tfetchSpec.setFetchesRawRows(true);\n\t\n\t\t\tEOSQLExpression sqlExpr = sqlFactory.expressionForEntity(entity);\n\t\t\tsqlExpr.prepareSelectExpressionWithAttributes(new NSArray(aggregateAttribute), false, fetchSpec);\n\t\n\t\t\tEOAdaptorChannel adaptorChannel = databaseContext.availableChannel().adaptorChannel();\n\t\t\tif (!adaptorChannel.isOpen()) {\n\t\t\t\tadaptorChannel.openChannel();\n\t\t\t}\n\t\t\tObject aggregateValue = null; \n\t\t\tNSArray attributes = new NSArray(aggregateAttribute);\n\t\t\tadaptorChannel.evaluateExpression(sqlExpr);\n\t\t\ttry {\n\t\t\t\tadaptorChannel.setAttributesToFetch(attributes);\n\t\t\t\tNSDictionary row = adaptorChannel.fetchRow();\n\t\t\t\tif (row != null) {\n\t\t\t\t\taggregateValue = row.objectForKey(aggregateAttribute.name());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tadaptorChannel.cancelFetch();\n\t\t\t}\n\t\t    return aggregateValue;\n\t\t}\n\t\tfinally {\n\t\t\tdatabaseContext.unlock();\n\t\t}\n    }","id":38800,"modified_method":"/**\n     * Returns the number of objects in the database with the qualifier and counting attribute.  This implementation\n     * queries the database directly without loading the objects into memory.\n     * \n     * @param ec the editing context\n     * @param entityName the name of the entity\n     * @param qualifier the qualifier to filter with\n     * @param aggregateAttribute the attribute that contains the \"count(*)\" definition\n     * @return the number of objects\n     */\n    public static Object _aggregateFunctionWithQualifierAndAggregateAttribute(EOEditingContext ec, String entityName, EOQualifier qualifier, EOAttribute aggregateAttribute) {\n\t\tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n\t\tEOModel model = entity.model();\n\t\tEODatabaseContext databaseContext = EODatabaseContext.registeredDatabaseContextForModel(model, ec);\n\t\tdatabaseContext.lock();\n\t\ttry {\n\t\t\tEOSQLExpressionFactory sqlFactory = databaseContext.adaptorContext().adaptor().expressionFactory();\n\t\t\tEOQualifier schemaBasedQualifier = entity.schemaBasedQualifier(qualifier);\n\t\t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(entity.name(), schemaBasedQualifier, null);\n\t\t\tfetchSpec.setFetchesRawRows(true);\n\t\n\t\t\tEOSQLExpression sqlExpr = sqlFactory.expressionForEntity(entity);\n\t\t\tsqlExpr.prepareSelectExpressionWithAttributes(new NSArray<EOAttribute>(aggregateAttribute), false, fetchSpec);\n\t\n\t\t\tEOAdaptorChannel adaptorChannel = databaseContext.availableChannel().adaptorChannel();\n\t\t\tif (!adaptorChannel.isOpen()) {\n\t\t\t\tadaptorChannel.openChannel();\n\t\t\t}\n\t\t\tObject aggregateValue = null; \n\t\t\tNSArray<EOAttribute> attributes = new NSArray<EOAttribute>(aggregateAttribute);\n\t\t\tadaptorChannel.evaluateExpression(sqlExpr);\n\t\t\ttry {\n\t\t\t\tadaptorChannel.setAttributesToFetch(attributes);\n\t\t\t\tNSDictionary row = adaptorChannel.fetchRow();\n\t\t\t\tif (row != null) {\n\t\t\t\t\taggregateValue = row.objectForKey(aggregateAttribute.name());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tadaptorChannel.cancelFetch();\n\t\t\t}\n\t\t    return aggregateValue;\n\t\t}\n\t\tfinally {\n\t\t\tdatabaseContext.unlock();\n\t\t}\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Utility method to generate a new primary key dictionary using\n     * the adaptor for a given entity. This is can be handy if you\n     * need to have a primary key for an object before it is saved to\n     * the database. This method uses the same method that EOF uses\n     * by default for generating primary keys. See\n     * {@link ERXGeneratesPrimaryKeyInterface} for more information\n     * about using a newly created dictionary as the primary key for\n     * an enterprise object.\n     * @param ec editing context\n     * @param entityName name of the entity to generate the primary\n     *\t\tkey dictionary for.\n     * @return a dictionary containing a new primary key for the given\n     *\t\tentity.\n     */\n    public static NSDictionary newPrimaryKeyDictionaryForEntityNamed(EOEditingContext ec, String entityName) {\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(entity.model(), ec);\n        NSDictionary primaryKey = null;\n        try {\n            dbContext.lock();\n            EOAdaptorChannel adaptorChannel = dbContext.availableChannel().adaptorChannel();\n            if (!adaptorChannel.isOpen())\n                adaptorChannel.openChannel();\n            NSArray arr = adaptorChannel.primaryKeysForNewRowsWithEntity(1, entity);\n            if (arr != null) {\n                primaryKey = (NSDictionary)arr.lastObject();\n            } else {\n                log.warn(\"Could not get primary key array for entity: \" + entityName);\n            }\n        } catch (Exception e) {\n            log.error(\"Caught exception when generating primary key for entity: \" + entityName, e);\n            throw new NSForwardException(e);\n        } finally {\n            dbContext.unlock();\n        }\n        return primaryKey;\n    }","id":38801,"modified_method":"/**\n     * Utility method to generate a new primary key dictionary using\n     * the adaptor for a given entity. This is can be handy if you\n     * need to have a primary key for an object before it is saved to\n     * the database. This method uses the same method that EOF uses\n     * by default for generating primary keys. See\n     * {@link ERXGeneratesPrimaryKeyInterface} for more information\n     * about using a newly created dictionary as the primary key for\n     * an enterprise object.\n     * @param ec editing context\n     * @param entityName name of the entity to generate the primary\n     *\t\tkey dictionary for.\n     * @return a dictionary containing a new primary key for the given\n     *\t\tentity.\n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic static NSDictionary<String, Object> newPrimaryKeyDictionaryForEntityNamed(EOEditingContext ec, String entityName) {\n        EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n        EODatabaseContext dbContext = EODatabaseContext.registeredDatabaseContextForModel(entity.model(), ec);\n        NSDictionary<String, Object> primaryKey = null;\n        try {\n            dbContext.lock();\n            EOAdaptorChannel adaptorChannel = dbContext.availableChannel().adaptorChannel();\n            if (!adaptorChannel.isOpen()) {\n                adaptorChannel.openChannel();\n            }\n            NSArray<NSDictionary<String, Object>> arr = adaptorChannel.primaryKeysForNewRowsWithEntity(1, entity);\n            if (arr != null) {\n                primaryKey = arr.lastObject();\n            } else {\n                log.warn(\"Could not get primary key array for entity: \" + entityName);\n            }\n        } catch (Exception e) {\n            log.error(\"Caught exception when generating primary key for entity: \" + entityName, e);\n            throw new NSForwardException(e);\n        } finally {\n            dbContext.unlock();\n        }\n        return primaryKey;\n    }","commit_id":"2890d0717efe6b8912e397b45b17b7106507d051","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * Generates the EXISTS SQL string for the given SQL expression.\n         * The bulk of the logic for generating the sub-query is in this method.\n         * @param qualifier for which to generate the SQL\n         * @param expression to use during SQL generation\n         * @return SQL string for the current sub-query\n         */\n        public String sqlStringForSQLExpression(EOQualifier qualifier, EOSQLExpression expression) {\n            if (null == qualifier || null == expression) {\n                return null;\n            }\n\n            ERXExistsQualifier existsQualifier = (ERXExistsQualifier)qualifier;\n            EOQualifier subqualifier = existsQualifier.subqualifier();\n            String baseKeyPath = existsQualifier.baseKeyPath();\n\n            EOEntity baseEntity = expression.entity();\n            EORelationship relationship = null;\n\n            // Walk the key path to the last entity.\n            if (baseKeyPath != null) {\n                for (Enumeration pathEnum = NSArray.componentsSeparatedByString(baseKeyPath, \".\").objectEnumerator(); pathEnum.hasMoreElements();) {\n                    String path = (String)pathEnum.nextElement();\n                    if (null == relationship) {\n                        relationship = baseEntity.anyRelationshipNamed(path);\n                    } else {\n                        relationship = relationship.destinationEntity().anyRelationshipNamed(path);\n                    }\n                }\n            }\n\n            EOEntity srcEntity = relationship != null ? relationship.entity() : baseEntity;\n            EOEntity destEntity = relationship != null ? relationship.destinationEntity() : baseEntity;\n\n            // We need to do a bunch of hand-waiving to get the right table aliases for the table used in the exists\n            // subquery and for the join clause back to the source table.\n            String sourceTableAlias = \"t0\"; // The alias for the the source table of the baseKeyPath from the main query.\n            String destTableAlias; // The alias for the table used in the subquery.\n            if (!srcEntity.equals(baseEntity)) { // The exists clause is applied to the different table.\n                String sourceKeyPath = ERXStringUtilities.keyPathWithoutLastProperty(baseKeyPath);\n                sqlStringForAttributeNamedInExpression(sourceKeyPath, expression);\n                sqlStringForAttributeNamedInExpression(baseKeyPath, expression);\n                sourceTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(sourceKeyPath);\n                destTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(baseKeyPath);\n                if (null == destTableAlias) {\n                    destTableAlias = \"t\" + (expression.aliasesByRelationshipPath().count()); // The first entry = \"t0\".\n                    expression.aliasesByRelationshipPath().takeValueForKey(destTableAlias, baseKeyPath);\n                }\n            } else { // The exists clause is applied to the base table.\n                destTableAlias = \"t\" + expression.aliasesByRelationshipPath().count(); // Probably \"t1\"\n            }\n\n            EOAttribute pk = (EOAttribute)srcEntity.primaryKeyAttributes().lastObject();\n            String foreignKey = expression.sqlStringForAttribute(pk);\n\n            EOQualifier qual = EOQualifierSQLGeneration.Support._schemaBasedQualifierWithRootEntity(subqualifier, destEntity);\n            EOFetchSpecification fetchSpecification = new EOFetchSpecification(destEntity.name(), qual, null, false, true, null);\n\n            EODatabaseContext context = EODatabaseContext.registeredDatabaseContextForModel(destEntity.model(), EOObjectStoreCoordinator.defaultCoordinator());\n            EOSQLExpressionFactory factory = context.database().adaptor().expressionFactory();\n\n            EOSQLExpression subExpression = factory.expressionForEntity(destEntity);\n            subExpression.aliasesByRelationshipPath().setObjectForKey(destTableAlias, \"\");\n            subExpression.setUseAliases(true);\n            subExpression.prepareSelectExpressionWithAttributes(destEntity.primaryKeyAttributes(), false, fetchSpecification);\n\n            for (Enumeration bindEnumeration = subExpression.bindVariableDictionaries().objectEnumerator(); bindEnumeration.hasMoreElements();) {\n                expression.addBindVariableDictionary((NSDictionary)bindEnumeration.nextElement());\n            }\n\n            StringBuffer sb = new StringBuffer();\n            sb.append(\" EXISTS ( \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", subExpression.statement()));\n            sb.append(\" AND \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", foreignKey));\n            sb.append(\" = \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", sourceTableAlias + \".\", foreignKey));\n            sb.append(\" ) \");\n            return sb.toString();\n        }","id":38802,"modified_method":"/**\n         * Generates the EXISTS SQL string for the given SQL expression.\n         * The bulk of the logic for generating the sub-query is in this method.\n         * @param qualifier for which to generate the SQL\n         * @param expression to use during SQL generation\n         * @return SQL string for the current sub-query\n         */\n        public String sqlStringForSQLExpression(EOQualifier qualifier, EOSQLExpression expression) {\n            if (null == qualifier || null == expression) {\n                return null;\n            }\n\n            ERXExistsQualifier existsQualifier = (ERXExistsQualifier)qualifier;\n            EOQualifier subqualifier = existsQualifier.subqualifier();\n            String baseKeyPath = existsQualifier.baseKeyPath();\n\n            EOEntity baseEntity = expression.entity();\n            EORelationship relationship = null;\n\n            // Walk the key path to the last entity.\n            if (baseKeyPath != null) {\n                for (Enumeration pathEnum = NSArray.componentsSeparatedByString(baseKeyPath, \".\").objectEnumerator(); pathEnum.hasMoreElements();) {\n                    String path = (String)pathEnum.nextElement();\n                    if (null == relationship) {\n                        relationship = baseEntity.anyRelationshipNamed(path);\n                    } else {\n                        relationship = relationship.destinationEntity().anyRelationshipNamed(path);\n                    }\n                }\n            }\n\n            EOEntity srcEntity = relationship != null ? relationship.entity() : baseEntity;\n            EOEntity destEntity = relationship != null ? relationship.destinationEntity() : baseEntity;\n\n            // We need to do a bunch of hand-waiving to get the right table aliases for the table used in the exists\n            // subquery and for the join clause back to the source table.\n            String sourceTableAlias = \"t0\"; // The alias for the the source table of the baseKeyPath from the main query.\n            String destTableAlias; // The alias for the table used in the subquery.\n            if (!srcEntity.equals(baseEntity)) { // The exists clause is applied to the different table.\n                String sourceKeyPath = ERXStringUtilities.keyPathWithoutLastProperty(baseKeyPath);\n                sqlStringForAttributeNamedInExpression(sourceKeyPath, expression);\n                sqlStringForAttributeNamedInExpression(baseKeyPath, expression);\n                sourceTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(sourceKeyPath);\n                destTableAlias = (String)expression.aliasesByRelationshipPath().valueForKey(baseKeyPath);\n                if (null == destTableAlias) {\n                    destTableAlias = \"t\" + (expression.aliasesByRelationshipPath().count()); // The first entry = \"t0\".\n                    expression.aliasesByRelationshipPath().takeValueForKey(destTableAlias, baseKeyPath);\n                }\n            } else { // The exists clause is applied to the base table.\n                destTableAlias = \"t\" + expression.aliasesByRelationshipPath().count(); // Probably \"t1\"\n            }\n\n            EOAttribute sourceKeyAttribute = srcEntity.primaryKeyAttributes().lastObject();\n            String sourceKey = expression.sqlStringForAttribute(sourceKeyAttribute);\n\n            EOAttribute destKeyAttribute = relationship.destinationAttributes().lastObject();\n            String destKey = expression.sqlStringForAttribute(destKeyAttribute);\n            \n            EOQualifier qual = EOQualifierSQLGeneration.Support._schemaBasedQualifierWithRootEntity(subqualifier, destEntity);\n            EOFetchSpecification fetchSpecification = new EOFetchSpecification(destEntity.name(), qual, null, false, true, null);\n\n            EODatabaseContext context = EODatabaseContext.registeredDatabaseContextForModel(destEntity.model(), EOObjectStoreCoordinator.defaultCoordinator());\n            EOSQLExpressionFactory factory = context.database().adaptor().expressionFactory();\n\n            EOSQLExpression subExpression = factory.expressionForEntity(destEntity);\n            subExpression.aliasesByRelationshipPath().setObjectForKey(destTableAlias, \"\");\n            subExpression.setUseAliases(true);\n            subExpression.prepareSelectExpressionWithAttributes(destEntity.primaryKeyAttributes(), false, fetchSpecification);\n\n            for (Enumeration bindEnumeration = subExpression.bindVariableDictionaries().objectEnumerator(); bindEnumeration.hasMoreElements();) {\n                expression.addBindVariableDictionary((NSDictionary)bindEnumeration.nextElement());\n            }\n\n            StringBuffer sb = new StringBuffer();\n            sb.append(\" EXISTS ( \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", subExpression.statement()));\n            sb.append(\" AND \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", destTableAlias + \".\", destKey));\n            sb.append(\" = \");\n            sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", sourceTableAlias + \".\", sourceKey));\n            sb.append(\" ) \");\n            return sb.toString();\n        }","commit_id":"373c54f484e572f992af07f44250665861d1da78","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Obtains a batch iterator for the objects resulting from the passed in SQL query with binded variables.\n     * <p>\n     * The requirements for the passed in SQL query are the same as {@link #selectObjectsOfEntityForSqlWithBindings(EOEditingContext, String, String, boolean, ERXSQLBinding...)},\n     * except for an important difference: the query must return only one column with the entity primary keys.\n     * Instead of doing a query like 'SELECT * FROM Person ...', assuming ID as the name of the primary key column,\n     * the query would be 'SELECT ID FROM Person ...'. Despite this, the batch iterator will provide you the\n     * full initialized EOs.\n     * <\/p>\n     * <p>\n     * <strong>SORTING<\/strong> - If you want to obtain sorted results, you'll have to add the sorting information to\n     * the query (using ORDER BY clauses) <em>and<\/em> pass an array of EOSortOrderings to this method. The sorting\n     * information in the query will be used to sort the primary key array. The EOSortOrderings are used to sort objects\n     * inside each batch. To obtain sorted results as expected, both sorting criteria should be similar.\n     * <\/p>\n     * @param ec\n     *          The editing context where the objects will be placed\n     * @param entityName\n     *          The name of the entity whose objects are returned by the query\n     * @param query\n     *          The SQL query\n     * @param refreshesCache\n     *          If true, the cached snapshots will be refreshed. See {@link EOFetchSpecification#setRefreshesRefetchedObjects(boolean)}.\n     * @param batchSize\n     *          The size of each batch\n     * @param sortOrderings\n     *          EOSortOrderings for batches (see description above)\n     * @param bindings\n     *          The variable bindings, wrapped in {@link ERXSQLBinding} objects\n     * \n     * @return batch iterator for the passed in query\n     */\n    public static ERXFetchSpecificationBatchIterator batchIteratorForObjectsWithSqlWithBindings( EOEditingContext ec, String entityName, String query, boolean refreshesCache, int batchSize, NSArray sortOrderings, ERXSQLBinding... bindings ) {\n        EODatabaseContext databaseContext = databaseContextForEntityName(ec,entityName);\n        EOEntity entity = EOUtilities.entityNamed(ec, entityName);\n\n        if( entity.primaryKeyAttributes().count() > 1 ) {\n            throw new RuntimeException(\"Multiple primary keys not supported.\");\n        }\n\n        EOSQLExpression expression = databaseContext.adaptorContext().adaptor().expressionFactory().expressionForEntity( entity );\n        expression.setStatement(processedQueryString(query, expression, bindings));\n\n        EOFetchSpecification pkSpec = new EOFetchSpecification( entityName, null, null );\n        pkSpec.setRefreshesRefetchedObjects(refreshesCache);\n        pkSpec.setFetchesRawRows(true);\n        pkSpec.setRawRowKeyPaths(entity.primaryKeyAttributeNames());\n        pkSpec.setHints( new NSDictionary( expression, EODatabaseContext.CustomQueryExpressionHintKey ) );\n\n        NSArray pkDicts = ec.objectsWithFetchSpecification(pkSpec);\n        NSMutableArray pks = new NSMutableArray();\n        String pkAtttributeName = ((EOAttribute) entity.primaryKeyAttributes().lastObject()).name();\n\n        for ( Enumeration rowEnumerator = pkDicts.objectEnumerator(); rowEnumerator.hasMoreElements(); ) {\n            NSDictionary row = (NSDictionary) rowEnumerator.nextElement();\n            pks.addObject( row.objectForKey( pkAtttributeName ));\n        }\n\n        EOFetchSpecification spec = new EOFetchSpecification(entityName, null, sortOrderings);\n        spec.setRefreshesRefetchedObjects( refreshesCache );\n        return new ERXFetchSpecificationBatchIterator( spec, pks, ec, batchSize);\n    }","id":38803,"modified_method":"/**\n     * Obtains a batch iterator for the objects resulting from the passed in SQL query with binded variables.\n     * <p>\n     * The requirements for the passed in SQL query are the same as {@link #selectObjectsOfEntityForSqlWithBindings(EOEditingContext, String, String, boolean, ERXSQLBinding...)},\n     * except for an important difference: the query must return only one column with the entity primary keys.\n     * Instead of doing a query like 'SELECT * FROM Person ...', assuming ID as the name of the primary key column,\n     * the query would be 'SELECT ID FROM Person ...'. Despite this, the batch iterator will provide you the\n     * full initialized EOs.\n     * <\/p>\n     * <p>\n     * <strong>SORTING<\/strong> - If you want to obtain sorted results, you'll have to add the sorting information to\n     * the query (using ORDER BY clauses) <em>and<\/em> pass an array of EOSortOrderings to this method. The sorting\n     * information in the query will be used to sort the primary key array. The EOSortOrderings are used to sort objects\n     * inside each batch. To obtain sorted results as expected, both sorting criteria should be similar.\n     * <\/p>\n     * @param ec\n     *          The editing context where the objects will be placed\n     * @param entityName\n     *          The name of the entity whose objects are returned by the query\n     * @param query\n     *          The SQL query\n     * @param refreshesCache\n     *          If true, the cached snapshots will be refreshed. See {@link EOFetchSpecification#setRefreshesRefetchedObjects(boolean)}.\n     * @param batchSize\n     *          The size of each batch\n     * @param sortOrderings\n     *          EOSortOrderings for batches (see description above)\n     * @param bindings\n     *          The variable bindings, wrapped in {@link ERXSQLBinding} objects\n     * \n     * @return batch iterator for the passed in query\n     */\n    public static ERXFetchSpecificationBatchIterator batchIteratorForObjectsWithSqlWithBindings( EOEditingContext ec, String entityName, String query, boolean refreshesCache, int batchSize, NSArray sortOrderings, ERXSQLBinding... bindings ) {\n        EODatabaseContext databaseContext = databaseContextForEntityName(ec,entityName);\n        EOEntity entity = EOUtilities.entityNamed(ec, entityName);\n\n        if( entity.primaryKeyAttributes().count() > 1 ) {\n            throw new RuntimeException(\"Multiple primary keys not supported.\");\n        }\n\n        EOSQLExpression expression = databaseContext.adaptorContext().adaptor().expressionFactory().expressionForEntity( entity );\n        expression.setStatement(processedQueryString(query, expression, bindings));\n\n        EOFetchSpecification pkSpec = new EOFetchSpecification( entityName, null, null );\n        pkSpec.setRefreshesRefetchedObjects(refreshesCache);\n        pkSpec.setFetchesRawRows(true);\n        pkSpec.setRawRowKeyPaths(entity.primaryKeyAttributeNames());\n        pkSpec.setHints( new NSDictionary( expression, EODatabaseContext.CustomQueryExpressionHintKey ) );\n\n        NSArray pkDicts = ec.objectsWithFetchSpecification(pkSpec);\n        NSMutableArray pks = new NSMutableArray();\n        String pkAtttributeName = entity.primaryKeyAttributes().lastObject().name();\n\n        for ( Enumeration rowEnumerator = pkDicts.objectEnumerator(); rowEnumerator.hasMoreElements(); ) {\n            NSDictionary row = (NSDictionary) rowEnumerator.nextElement();\n            pks.addObject( row.objectForKey( pkAtttributeName ));\n        }\n\n        EOFetchSpecification spec = new EOFetchSpecification(entityName, null, sortOrderings);\n        spec.setRefreshesRefetchedObjects( refreshesCache );\n        return new ERXFetchSpecificationBatchIterator( spec, pks, ec, batchSize);\n    }","commit_id":"764dc604df96b2ce65d8fa6f41fefbcf12a01356","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void updateDisplayedObjects() {\n\t\tif (isBatching()) {\n\t\t\t// refetch();\n\t\t\tNSMutableArray selectedObjects = (NSMutableArray) selectedObjects();\n\t\t\tNSArray obj = allObjects();\n\t\t\tif (delegate() != null) {\n\t\t\t\t_NSDelegate delegate = new _NSDelegate(WODisplayGroup.Delegate.class, delegate());\n\t\t\t\tif (delegate != null && delegate.respondsTo(\"displayGroupDisplayArrayForObjects\")) {\n\t\t\t\t\tdelegate.perform(\"displayGroupDisplayArrayForObjects\", this, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// _displayedObjects = new NSMutableArray(obj);\n\t\t\tsetSelectedObjects(selectedObjects);\n\t\t\t// selectObjectsIdenticalToSelectFirstOnNoMatch(selectedObjects,\n\t\t\t// false);\n\t\t\tredisplay();\n\t\t}\n\t\telse {\n\t\t\tsuper.updateDisplayedObjects();\n\t\t}\n\t}","id":38804,"modified_method":"@Override\n\tpublic void updateDisplayedObjects() {\n\t\tif (isBatching()) {\n\t\t\t// refetch();\n\t\t\tNSMutableArray<T> selectedObjects = (NSMutableArray<T>) selectedObjects();\n\t\t\tNSArray<T> obj = allObjects();\n\t\t\tif (delegate() != null) {\n\t\t\t\t_NSDelegate delegate = new _NSDelegate(WODisplayGroup.Delegate.class, delegate());\n\t\t\t\tif (delegate != null && delegate.respondsTo(\"displayGroupDisplayArrayForObjects\")) {\n\t\t\t\t\tdelegate.perform(\"displayGroupDisplayArrayForObjects\", this, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// _displayedObjects = new NSMutableArray(obj);\n\t\t\tsetSelectedObjects(selectedObjects);\n\t\t\t// selectObjectsIdenticalToSelectFirstOnNoMatch(selectedObjects,\n\t\t\t// false);\n\t\t\tredisplay();\n\t\t}\n\t\telse {\n\t\t\tsuper.updateDisplayedObjects();\n\t\t}\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Overridden to preserve the selected objects.\n\t */\n\t@Override\n\tpublic void setSortOrderings(NSArray nsarray) {\n\t\tNSArray selectedObjects = selectedObjects();\n\t\tsuper.setSortOrderings(nsarray);\n\t\tsetSelectedObjects(selectedObjects);\n\t\tif (isBatching()) {\n\t\t\t_displayedObjects = null;\n\t\t}\n\t}","id":38805,"modified_method":"/**\n\t * Overridden to preserve the selected objects.\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void setSortOrderings(NSArray nsarray) {\n\t\tNSArray<T> selectedObjects = selectedObjects();\n\t\tsuper.setSortOrderings(nsarray);\n\t\tsetSelectedObjects(selectedObjects);\n\t\tif (isBatching()) {\n\t\t\t_displayedObjects = null;\n\t\t}\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Overriden to clear out our array of fetched objects.\n\t */\n\t@Override\n\tpublic void setNumberOfObjectsPerBatch(int count) {\n\t\tboolean didFetch = _displayedObjects != null;\n\t\tif (isBatching() && numberOfObjectsPerBatch() != count) {\n\t\t\t_displayedObjects = null;\n\t\t}\n\t\tNSArray selectedObjects = selectedObjects();\n\t\tsuper.setNumberOfObjectsPerBatch(count);\n\t\tsetSelectedObjects(selectedObjects);\n\t\t// we have already fetched, so we need to adapt the batch count\n\t\tif (didFetch) {\n\t\t\tupdateBatchCount();\n\t\t}\n\t}","id":38806,"modified_method":"/**\n\t * Overriden to clear out our array of fetched objects.\n\t */\n\t@Override\n\tpublic void setNumberOfObjectsPerBatch(int count) {\n\t\tboolean didFetch = _displayedObjects != null;\n\t\tif (isBatching() && numberOfObjectsPerBatch() != count) {\n\t\t\t_displayedObjects = null;\n\t\t}\n\t\tNSArray<T> selectedObjects = selectedObjects();\n\t\tsuper.setNumberOfObjectsPerBatch(count);\n\t\tsetSelectedObjects(selectedObjects);\n\t\t// we have already fetched, so we need to adapt the batch count\n\t\tif (didFetch) {\n\t\t\tupdateBatchCount();\n\t\t}\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Utility that does the actual fetching, if a qualifier() is set, it adds\n\t * it to the dataSource() fetch qualifier.\n\t */\n\tprotected void refetch() {\n\t\tint rowCount = rowCount();\n\n\t\tint start = (currentBatchIndex() - 1) * numberOfObjectsPerBatch();\n\t\tint end = start + numberOfObjectsPerBatch();\n\n\t\tif (numberOfObjectsPerBatch() == 0) {\n\t\t\tstart = 0;\n\t\t\tend = rowCount;\n\t\t}\n\n\t\tif (end > rowCount) {\n\t\t\tend = rowCount;\n\t\t}\n\n\t\tif(filteredObjects().count() != rowCount) {\n\t\t\tNSArray selectedObjects = selectedObjects();\n\t\t\tsetObjectArray(new FakeArray(rowCount));\n\t\t\tsetSelectedObjects(selectedObjects);\n\t\t}\n\t\t\n\t\t_displayedObjects = objectsInRange(start, end);\n\t\t\n\t\t// MS: Adjust our guess of the row count if it was\n\t\t// too high.\n\t\tif (_rowCount != -1) {\n\t\t\tint displayedObjectsCount = _displayedObjects.count();\n\t\t\tif (displayedObjectsCount < numberOfObjectsPerBatch()) {\n\t\t\t\t_rowCount = start + _displayedObjects.count();\n\t\t\t}\n\t\t}\n\t}","id":38807,"modified_method":"/**\n\t * Utility that does the actual fetching, if a qualifier() is set, it adds\n\t * it to the dataSource() fetch qualifier.\n\t */\n\tprotected void refetch() {\n\t\tint rowCount = rowCount();\n\n\t\tint start = (currentBatchIndex() - 1) * numberOfObjectsPerBatch();\n\t\tint end = start + numberOfObjectsPerBatch();\n\n\t\tif (numberOfObjectsPerBatch() == 0) {\n\t\t\tstart = 0;\n\t\t\tend = rowCount;\n\t\t}\n\n\t\tif (end > rowCount) {\n\t\t\tend = rowCount;\n\t\t}\n\n\t\tif(filteredObjects().count() != rowCount) {\n\t\t\tNSArray<T> selectedObjects = selectedObjects();\n\t\t\tsetObjectArray(new FakeArray(rowCount));\n\t\t\tsetSelectedObjects(selectedObjects);\n\t\t}\n\t\t\n\t\t_displayedObjects = objectsInRange(start, end);\n\t\t\n\t\t// MS: Adjust our guess of the row count if it was\n\t\t// too high.\n\t\tif (_rowCount != -1) {\n\t\t\tint displayedObjectsCount = _displayedObjects.count();\n\t\t\tif (displayedObjectsCount < numberOfObjectsPerBatch()) {\n\t\t\t\t_rowCount = start + _displayedObjects.count();\n\t\t\t}\n\t\t}\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Decodes an ERXBatchingDisplayGroup from the given unarchiver.\n\t * \n\t * @param unarchiver the unarchiver to construct this display group with\n\t * @return the corresponding batching display group\n\t */\n\tpublic static Object decodeWithKeyValueUnarchiver(EOKeyValueUnarchiver unarchiver) {\n\t\treturn new ERXBatchingDisplayGroup(unarchiver);\n\t}","id":38808,"modified_method":"/**\n\t * Decodes an ERXBatchingDisplayGroup from the given unarchiver.\n\t * \n\t * @param unarchiver the unarchiver to construct this display group with\n\t * @return the corresponding batching display group\n\t */\n\tpublic static Object decodeWithKeyValueUnarchiver(EOKeyValueUnarchiver unarchiver) {\n\t\treturn new ERXBatchingDisplayGroup<Object>(unarchiver);\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Overriden to re-set the selection. Why is this cleared in the super class?\n\t */\n\tpublic Object displayNextBatch() {\n\t\tNSArray oldSelection = selectedObjects();\n\t\tObject result = super.displayNextBatch();\n\t\tsetSelectedObjects(oldSelection);\n\t\treturn result;\n\t}","id":38809,"modified_method":"/**\n\t * Overriden to re-set the selection. Why is this cleared in the super class?\n\t */\n\t@Override\n\tpublic Object displayNextBatch() {\n\t\tNSArray<T> oldSelection = selectedObjects();\n\t\tObject result = super.displayNextBatch();\n\t\tsetSelectedObjects(oldSelection);\n\t\treturn result;\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns all objects, filtered by the qualifier().\n\t */\n\tpublic NSArray filteredObjects() {\n\t\t// FIXME AK: need to cache here\n\t\tNSArray result;\n\t\tEOQualifier q=qualifier();\n\t\tif (q!=null) {\n\t\t\tresult=EOQualifier.filteredArrayWithQualifier(allObjects(),q);\n\t\t} else {\n\t\t\tresult=allObjects();\n\t\t}\n\t\treturn result;\n\t}","id":38810,"modified_method":"/**\n\t * Returns all objects, filtered by the qualifier().\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic NSArray<T> filteredObjects() {\n\t\t// FIXME AK: need to cache here\n\t\tNSArray<T> result;\n\t\tEOQualifier q=qualifier();\n\t\tif (q!=null) {\n\t\t\tresult=EOQualifier.filteredArrayWithQualifier(allObjects(),q);\n\t\t} else {\n\t\t\tresult=allObjects();\n\t\t}\n\t\treturn result;\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Overriden to re-set the selection. Why is this cleared in the super class?\n\t */\n\tpublic Object displayPreviousBatch() {\n\t\tNSArray oldSelection = selectedObjects();\n\t\tObject result = super.displayPreviousBatch();\n\t\tsetSelectedObjects(oldSelection);\n\t\treturn result;\n\t}","id":38811,"modified_method":"/**\n\t * Overriden to re-set the selection. Why is this cleared in the super class?\n\t */\n\t@Override\n\tpublic Object displayPreviousBatch() {\n\t\tNSArray<T> oldSelection = selectedObjects();\n\t\tObject result = super.displayPreviousBatch();\n\t\tsetSelectedObjects(oldSelection);\n\t\treturn result;\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Overriden to re-set the selection. Why is this cleared in the super class?\n\t */\n\tpublic void setNumberOfObjectsPerBatch(int i) {\n\t\tNSArray oldSelection = selectedObjects();\n\t\tsuper.setNumberOfObjectsPerBatch(i);\n\t\tsetSelectedObjects(oldSelection);\n\t}","id":38812,"modified_method":"/**\n\t * Overriden to re-set the selection. Why is this cleared in the super class?\n\t */\n\t@Override\n\tpublic void setNumberOfObjectsPerBatch(int i) {\n\t\tNSArray<T> oldSelection = selectedObjects();\n\t\tsuper.setNumberOfObjectsPerBatch(i);\n\t\tsetSelectedObjects(oldSelection);\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Overridden to support extra qualifiers.\n\t */\n\tpublic EOQualifier qualifierFromQueryValues() {\n\t\tEOQualifier q1 = super.qualifierFromQueryValues();\n\t\tEOQualifier q2 = null;\n\t\tif(_extraQualifiers.allValues().count() > 1) {\n\t\t\tq2 = new EOAndQualifier(_extraQualifiers.allValues());\n\t\t} else if(_extraQualifiers.allValues().count() > 0) {\n\t\t\tq2 = (EOQualifier)_extraQualifiers.allValues().lastObject();\n\t\t}\n\t\treturn q1 == null ? q2 : (q2 == null ? q1 : new EOAndQualifier(new NSArray(new Object[] {q1, q2})));\n\t}","id":38813,"modified_method":"/**\n\t * Overridden to support extra qualifiers.\n\t */\n\t@Override\n\tpublic EOQualifier qualifierFromQueryValues() {\n\t\tEOQualifier q1 = super.qualifierFromQueryValues();\n\t\tEOQualifier q2 = null;\n\t\tif(_extraQualifiers.allValues().count() > 1) {\n\t\t\tq2 = new EOAndQualifier(_extraQualifiers.allValues());\n\t\t} else if(_extraQualifiers.allValues().count() > 0) {\n\t\t\tq2 = _extraQualifiers.allValues().lastObject();\n\t\t}\n\t\treturn q1 == null ? q2 : (q2 == null ? q1 : new EOAndQualifier(new NSArray<EOQualifier>(new EOQualifier[] {q1, q2})));\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray displayedObjects() {\n\t\tNSMutableArray displayedObjects = new NSMutableArray(numberOfObjectsPerBatch());\n\t\tif (_displayedObjects == null) {\n\t\t\tint numberOfObjectsPerBatch = numberOfObjectsPerBatch();\n\t\t\tint startIndex = (currentBatchIndex() - 1) * numberOfObjectsPerBatch;\n\t\t\tint size = (_objectList == null) ? 0 : size();\n\t\t\tint endIndex = Math.min(startIndex + numberOfObjectsPerBatch, size);\n\t\t\tfor (int i = startIndex; i < endIndex; i++) {\n\t\t\t\tdisplayedObjects.addObject(_objectList.get(i));\n\t\t\t}\n\t\t}\n\t\treturn displayedObjects;\n\t}","id":38814,"modified_method":"@Override\n\tpublic NSArray<T> displayedObjects() {\n\t\tNSMutableArray<T> displayedObjects = new NSMutableArray<T>(numberOfObjectsPerBatch());\n\t\tif (_displayedObjects == null) {\n\t\t\tint numberOfObjectsPerBatch = numberOfObjectsPerBatch();\n\t\t\tint startIndex = (currentBatchIndex() - 1) * numberOfObjectsPerBatch;\n\t\t\tint size = (_objectList == null) ? 0 : size();\n\t\t\tint endIndex = Math.min(startIndex + numberOfObjectsPerBatch, size);\n\t\t\tfor (int i = startIndex; i < endIndex; i++) {\n\t\t\t\tdisplayedObjects.addObject(_objectList.get(i));\n\t\t\t}\n\t\t}\n\t\treturn displayedObjects;\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected int size() {\n\t\tint size;\n\t\tif (_objectList instanceof NSArray) {\n\t\t\tsize = ((NSArray) _objectList).count();\n\t\t}\n\t\telse {\n\t\t\tsize = _objectList.size();\n\t\t}\n\t\treturn size;\n\t}","id":38815,"modified_method":"protected int size() {\n\t\tint size;\n\t\tif (_objectList instanceof NSArray) {\n\t\t\tsize = ((NSArray<T>) _objectList).count();\n\t\t}\n\t\telse {\n\t\t\tsize = _objectList.size();\n\t\t}\n\t\treturn size;\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setObjectList(List objectList) {\n\t\t_objectList = objectList;\n\t\tif (objectList instanceof IBatchingList) {\n\t\t\t((IBatchingList) objectList).setSortOrderings(sortOrderings());\n\t\t\t((IBatchingList) objectList).setPageIndex(currentBatchIndex());\n\t\t\t((IBatchingList) objectList).setPageSize(numberOfObjectsPerBatch());\n\t\t}\n\t\tFakeArray fa = new FakeArray(size());\n\t\tsetObjectArray(fa);\n\t}","id":38816,"modified_method":"public void setObjectList(List<T> objectList) {\n\t\t_objectList = objectList;\n\t\tif (objectList instanceof IBatchingList) {\n\t\t\t((IBatchingList) objectList).setSortOrderings(sortOrderings());\n\t\t\t((IBatchingList) objectList).setPageIndex(currentBatchIndex());\n\t\t\t((IBatchingList) objectList).setPageSize(numberOfObjectsPerBatch());\n\t\t}\n\t\tFakeArray fa = new FakeArray(size());\n\t\tsetObjectArray(fa);\n\t}","commit_id":"d3a0fce49f31ea903ed59d0d32d380c6cc3612b7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Finds an entity that is contained in a string. This is used a lot in\n     * DirectToWeb. Example: \"ListAllStudios\"=>Studio\n     * \n     * @param ec\n     *            editing context\n     * @param string\n     *            string to look into\n     * @return found entity or <code>null<\/code>\n     */\n    public static EOEntity entityMatchingString(EOEditingContext ec, String string) {\n        EOEntity result = null;\n        if (string != null) {\n            NSArray entityNames = null;\n            String lowerCaseName = string.toLowerCase();\n            if (entityNames == null) {\n                EOModelGroup group = modelGroup(ec);\n                entityNames = (NSArray) ERXUtilities.entitiesForModelGroup(group).valueForKeyPath(\"name.toLowerCase\");\n            }\n            NSMutableArray possibleEntities = new NSMutableArray();\n            for (Enumeration e = entityNames.objectEnumerator(); e.hasMoreElements();) {\n                String lowercaseEntityName = (String) e.nextElement();\n                if (lowerCaseName.indexOf(lowercaseEntityName) != -1) possibleEntities.addObject(lowercaseEntityName);\n            }\n            if (possibleEntities.count() == 1) {\n                result = ERXUtilities.caseInsensitiveEntityNamed((String) possibleEntities.lastObject());\n            } else if (possibleEntities.count() > 1) {\n                ERXArrayUtilities.sortArrayWithKey(possibleEntities, \"length\");\n                if (((String) possibleEntities.objectAtIndex(0)).length() == ((String) possibleEntities.lastObject()).length())\n                        log.warn(\"Found multiple entities of the same length for string: \" + string + \" possible entities: \"\n                                + possibleEntities);\n                result = ERXUtilities.caseInsensitiveEntityNamed((String) possibleEntities.lastObject());\n            }\n            if (log.isDebugEnabled())\n                    log.debug(\"Found possible entities: \" + possibleEntities + \" for string: \" + string + \" result: \" + result);\n        }\n        return result;\n    }","id":38817,"modified_method":"/**\n     * Finds an entity that is contained in a string. This is used a lot in\n     * DirectToWeb. Example: \"ListAllStudios\"=>Studio\n     * \n     * @param ec\n     *            editing context\n     * @param string\n     *            string to look into\n     * @return found entity or <code>null<\/code>\n     */\n    public static EOEntity entityMatchingString(EOEditingContext ec, String string) {\n        EOEntity result = null;\n        if (string != null) {\n            String lowerCaseName = string.toLowerCase();\n            EOModelGroup group = modelGroup(ec);\n            NSArray<String> entityNames = (NSArray<String>) ERXUtilities.entitiesForModelGroup(group).valueForKeyPath(\"name.toLowerCase\");\n            NSMutableArray<String> possibleEntities = new NSMutableArray<String>();\n            for (String lowercaseEntityName : entityNames) {\n                if (lowerCaseName.indexOf(lowercaseEntityName) != -1) possibleEntities.addObject(lowercaseEntityName);\n            }\n            if (possibleEntities.count() == 1) {\n                result = ERXUtilities.caseInsensitiveEntityNamed(possibleEntities.lastObject());\n            } else if (possibleEntities.count() > 1) {\n                ERXArrayUtilities.sortArrayWithKey(possibleEntities, \"length\");\n                if (possibleEntities.objectAtIndex(0).length() == possibleEntities.lastObject().length())\n                        log.warn(\"Found multiple entities of the same length for string: \" + string + \" possible entities: \"\n                                + possibleEntities);\n                result = ERXUtilities.caseInsensitiveEntityNamed(possibleEntities.lastObject());\n            }\n            if (log.isDebugEnabled())\n                    log.debug(\"Found possible entities: \" + possibleEntities + \" for string: \" + string + \" result: \" + result);\n        }\n        return result;\n    }","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the source attribute for the relationship.  Assumes there is only one join.\n     *\n     * @param relationship relationship on entity to return source attribute for\n     * @return source attribute for the relationship\n     */\n    public static EOAttribute sourceAttributeForRelationship(EORelationship relationship)\n    {\n        EOJoin join = (EOJoin)relationship.joins().objectAtIndex(0);\n        return join.sourceAttribute();\n    }","id":38818,"modified_method":"/**\n     * Returns the source attribute for the relationship.  Assumes there is only one join.\n     *\n     * @param relationship relationship on entity to return source attribute for\n     * @return source attribute for the relationship\n     */\n    public static EOAttribute sourceAttributeForRelationship(EORelationship relationship)\n    {\n        EOJoin join = relationship.joins().objectAtIndex(0);\n        return join.sourceAttribute();\n    }","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static String createLogString(EOAdaptorChannel channel, EOSQLExpression expression, long millisecondsNeeded) {\n        String entityName = (expression.entity() != null ? expression.entity().name() : \"Unknown\");\n\t\tString description = \"\\\"\" + entityName + \"\\\"@\" + channel.adaptorContext().hashCode() + \" expression took \"\n\t\t        + millisecondsNeeded + \" ms: \" + expression.statement();\n\t\tStringBuffer sb = new StringBuffer();\n\t\tNSArray variables = expression.bindVariableDictionaries();\n\t\tint cnt = variables != null ? variables.count() : 0;\n\t\tif (cnt > 0) {\n\t\t    sb.append(\" withBindings: \");\n\t\t    for (int i = 0; i < cnt; i++) {\n\t\t        NSDictionary nsdictionary = (NSDictionary) variables.objectAtIndex(i);\n\t\t        Object obj = nsdictionary.valueForKey(\"BindVariableValue\");\n\t\t        String attributeName = (String) nsdictionary.valueForKey(\"BindVariableName\");\n\t\t        if (obj instanceof String) {\n\t\t            obj = EOSQLExpression.sqlStringForString((String) obj);\n\t\t        } else if (obj instanceof Number) {\n\t\t        \tobj = EOSQLExpression.sqlStringForNumber((Number) obj);\n\t\t        } else if (obj instanceof NSData) {\n\t\t            // ak: this is just for logging, however we would\n\t\t            // like to get readable data\n\t\t            // in particular for PKs and with postgres this\n\t\t            // works.\n\t\t            // plain EOF is broken, though\n\t\t            try {\n\t\t                if (((NSData) obj).length() < 50) {\n\t\t                    obj = expression.sqlStringForData((NSData) obj);\n\t\t                }\n\t\t            } catch (ArrayIndexOutOfBoundsException ex) {\n\t\t                // ignore, this is a bug in EOF\n\t\t            }\n\t\t            if (obj instanceof NSData) {\n\t\t                // produces very yucky output\n\t\t                obj = obj.toString();\n\t\t            }\n\t\t        } else {\n\t\t            if (expression.entity() != null) {\n\t\t                EOAttribute attribute = expression.entity().anyAttributeNamed(attributeName);\n\t\t                if (attribute != null) {\n\t\t                    obj = expression.formatValueForAttribute(obj, attribute);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if (i != 0)\n\t\t            sb.append(\", \");\n\t\t        sb.append(i + 1);\n\t\t        sb.append(\":\");\n\t\t        sb.append(obj);\n\t\t        sb.append(\"[\");\n\t\t        sb.append(attributeName);\n\t\t        sb.append(\"]\");\n\t\t    }\n\t\t}\n\t\tdescription = description + sb.toString();\n\n\t\treturn description;\n\t}","id":38819,"modified_method":"public static String createLogString(EOAdaptorChannel channel, EOSQLExpression expression, long millisecondsNeeded) {\n\t\tStringBuilder sb = new StringBuilder();\n        String entityName = (expression.entity() != null ? expression.entity().name() : \"Unknown\");\n        sb.append(\"\\\"\").append(entityName).append(\"\\\"@\").append(channel.adaptorContext().hashCode());\n        sb.append(\" expression took \").append(millisecondsNeeded).append(\" ms: \").append(expression.statement());\n\t\tNSArray<NSDictionary<String, ? extends Object>> variables = expression.bindVariableDictionaries();\n\t\tint cnt = variables != null ? variables.count() : 0;\n\t\tif (cnt > 0) {\n\t\t    sb.append(\" withBindings: \");\n\t\t    for (int i = 0; i < cnt; i++) {\n\t\t        NSDictionary<String, ? extends Object> nsdictionary = variables.objectAtIndex(i);\n\t\t        Object obj = nsdictionary.valueForKey(\"BindVariableValue\");\n\t\t        String attributeName = (String) nsdictionary.valueForKey(\"BindVariableName\");\n\t\t        if (obj instanceof String) {\n\t\t            obj = EOSQLExpression.sqlStringForString((String) obj);\n\t\t        } else if (obj instanceof Number) {\n\t\t        \tobj = EOSQLExpression.sqlStringForNumber((Number) obj);\n\t\t        } else if (obj instanceof NSData) {\n\t\t            // ak: this is just for logging, however we would\n\t\t            // like to get readable data\n\t\t            // in particular for PKs and with postgres this\n\t\t            // works.\n\t\t            // plain EOF is broken, though\n\t\t            try {\n\t\t                if (((NSData) obj).length() < 50) {\n\t\t                    obj = expression.sqlStringForData((NSData) obj);\n\t\t                }\n\t\t            } catch (ArrayIndexOutOfBoundsException ex) {\n\t\t                // ignore, this is a bug in EOF\n\t\t            }\n\t\t            if (obj instanceof NSData) {\n\t\t                // produces very yucky output\n\t\t                obj = obj.toString();\n\t\t            }\n\t\t        } else {\n\t\t            if (expression.entity() != null) {\n\t\t                EOAttribute attribute = expression.entity().anyAttributeNamed(attributeName);\n\t\t                if (attribute != null) {\n\t\t                    obj = expression.formatValueForAttribute(obj, attribute);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if (i != 0)\n\t\t            sb.append(\", \");\n\t\t        sb.append(i + 1);\n\t\t        sb.append(\":\");\n\t\t        sb.append(obj);\n\t\t        sb.append(\"[\");\n\t\t        sb.append(attributeName);\n\t\t        sb.append(\"]\");\n\t\t    }\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Creates an array containing all of the primary keys of the given objects.\n     * \n     * @param eos\n     *            array of enterprise objects\n     * @return array of primary keys\n     */\n    public static NSArray primaryKeysForObjects(NSArray eos) {\n        NSMutableArray result = new NSMutableArray();\n        if (eos.count() > 0) {\n            for (Enumeration e = eos.objectEnumerator(); e.hasMoreElements();) {\n                EOEnterpriseObject target = (EOEnterpriseObject) e.nextElement();\n                NSDictionary pKey = EOUtilities.primaryKeyForObject(target.editingContext(), target);\n                result.addObject(pKey.allValues().objectAtIndex(0));\n            }\n        }\n        return result;\n    }","id":38820,"modified_method":"/**\n     * Creates an array containing all of the primary keys of the given objects.\n     * \n     * @param eos\n     *            array of enterprise objects\n     * @return array of primary keys\n     */\n    public static NSArray primaryKeysForObjects(NSArray<? extends EOEnterpriseObject> eos) {\n        NSMutableArray result = new NSMutableArray();\n        if (eos != null) {\n            for (EOEnterpriseObject target : eos) {\n                NSDictionary pKey = EOUtilities.primaryKeyForObject(target.editingContext(), target);\n                result.addObject(pKey.allValues().objectAtIndex(0));\n            }\n        }\n        return result;\n    }","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Filters a list of relationships for only the ones that\n     * have a given EOAttribute as a source attribute. \n     * @param entity \n     * @param attrib EOAttribute to filter source attributes of\n     *      relationships.\n     * @return filtered array of EORelationship objects that have\n     *      the given attribute as the source attribute.\n     */\n    public static NSArray relationshipsForAttribute(EOEntity entity, EOAttribute attrib) {\n        NSMutableArray arr = new NSMutableArray();\n        int cnt = entity.relationships().count();\n        for(int i=0; i<cnt; i++){\n            EORelationship rel = (EORelationship)entity.relationships().objectAtIndex(i);\n            NSArray attribs = rel.sourceAttributes();\n            if(attribs.containsObject(attrib)){\n                arr.addObject(rel);\n            }\n        }\n        return arr;\n    }","id":38821,"modified_method":"/**\n     * Filters a list of relationships for only the ones that\n     * have a given EOAttribute as a source attribute. \n     * @param entity \n     * @param attrib EOAttribute to filter source attributes of\n     *      relationships.\n     * @return filtered array of EORelationship objects that have\n     *      the given attribute as the source attribute.\n     */\n    public static NSArray<EORelationship> relationshipsForAttribute(EOEntity entity, EOAttribute attrib) {\n        NSMutableArray<EORelationship> arr = new NSMutableArray<EORelationship>();\n        for (EORelationship rel : entity.relationships()) {\n            NSArray<EOAttribute> attribs = rel.sourceAttributes();\n            if (attribs.containsObject(attrib)) {\n                arr.addObject(rel);\n            }\n        }\n        return arr;\n    }","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the last entity for the given key path. If the path is empty or <code>null<\/code>, returns the given entity.\n     * @param entity\n     * @param keyPath\n     * @return entity object\n     */\n    public static EOEntity destinationEntityForKeyPath(EOEntity entity, String keyPath) {\n        if(keyPath == null || keyPath.length() == 0) {\n            return entity;\n        }\n        NSArray keyArray = NSArray.componentsSeparatedByString(keyPath, \".\");\n        for(Enumeration keys = keyArray.objectEnumerator(); keys.hasMoreElements(); ) {\n            String key = (String)keys.nextElement();\n            EORelationship rel = entity.anyRelationshipNamed(key);\n            if(rel == null) {\n                if(entity.anyAttributeNamed(key) == null) {\n                \tif(key.indexOf(\"@\") != 0) {\n                \t\tif(!_keysWithWarning.contains(key + \"-\" + entity)) {\n                \t\t\t_keysWithWarning.add(key + \"-\" + entity);\n                \t\t\tlog.warn(\"No relationship or attribute <\" + key + \"> in entity: \" + entity);\n                \t\t}\n                \t}\n                }\n                return null;\n            }\n            entity = rel.destinationEntity();\n        }\n        return entity;\n    }","id":38822,"modified_method":"/**\n     * Returns the last entity for the given key path. If the path is empty or <code>null<\/code>, returns the given entity.\n     * @param entity\n     * @param keyPath\n     * @return entity object\n     */\n    public static EOEntity destinationEntityForKeyPath(EOEntity entity, String keyPath) {\n        if(keyPath == null || keyPath.length() == 0) {\n            return entity;\n        }\n        NSArray<String> keyArray = NSArray.componentsSeparatedByString(keyPath, \".\");\n        for(String key : keyArray) {\n            EORelationship rel = entity.anyRelationshipNamed(key);\n            if(rel == null) {\n                if(entity.anyAttributeNamed(key) == null) {\n                \tif(key.indexOf(\"@\") != 0) {\n                \t\tif(!_keysWithWarning.contains(key + \"-\" + entity)) {\n                \t\t\t_keysWithWarning.add(key + \"-\" + entity);\n                \t\t\tlog.warn(\"No relationship or attribute <\" + key + \"> in entity: \" + entity);\n                \t\t}\n                \t}\n                }\n                return null;\n            }\n            entity = rel.destinationEntity();\n        }\n        return entity;\n    }","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Creates an AND qualifier of EOKeyValueQualifiers for every keypath in the given array of attributes.\n     *\n     * @author ak\n     * @param attributes \n     * @param values \n     * @return qualifier\n     */\n    public static EOQualifier qualifierFromAttributes(NSArray attributes, NSDictionary values) {\n        NSMutableArray qualifiers = new NSMutableArray();\n        EOQualifier result = null;\n        if(attributes.count() > 0) {\n            for (Enumeration i = attributes.objectEnumerator(); i.hasMoreElements();) {\n                EOAttribute key = (EOAttribute) i.nextElement();\n                Object value = values.objectForKey(key.name());\n                qualifiers.addObject(new EOKeyValueQualifier(key.name(), EOQualifier.QualifierOperatorEqual, value));\n            }\n            result = new EOAndQualifier(qualifiers);\n        }\n        return result;\n    }","id":38823,"modified_method":"/**\n     * Creates an AND qualifier of EOKeyValueQualifiers for every keypath in the given array of attributes.\n     *\n     * @author ak\n     * @param attributes \n     * @param values \n     * @return qualifier\n     */\n    public static EOQualifier qualifierFromAttributes(NSArray<EOAttribute> attributes, NSDictionary values) {\n        EOQualifier result = null;\n        if (attributes != null && attributes.count() > 0) {\n        \tNSMutableArray<EOQualifier> qualifiers = new NSMutableArray<EOQualifier>();\n            for (EOAttribute key : attributes) {\n                Object value = values.objectForKey(key.name());\n                qualifiers.addObject(new EOKeyValueQualifier(key.name(), EOQualifier.QualifierOperatorEqual, value));\n            }\n            result = new EOAndQualifier(qualifiers);\n        }\n        return result;\n    }","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Creates an array of relationships and attributes from the given keypath to give to the\n     * EOSQLExpression method <code>sqlStringForAttributePath<\/code>. If the last element is a\n     * relationship, then the relationship's source attribute will get chosen. As such, this can only \n     * work for single-value relationships in the last element.\n     * @param entity base entity\n     * @param keyPath key path\n     * @return array of EOProperties that make up the given key path\n     */\n    public static NSArray attributePathForKeyPath(EOEntity entity, String keyPath) {\n        NSMutableArray result = new NSMutableArray();\n        String[] parts = keyPath.split(\"\\\\.\");\n        String part;\n        for (int i = 0; i < parts.length - 1; i++) {\n            part = parts[i];\n            EORelationship relationship = entity.anyRelationshipNamed(part);\n            if(relationship == null) {\n            \t// CHECKME AK:  it would probably be better to return null \n            \t// to indicate that this is not a valid path?\n            \treturn NSArray.EmptyArray;\n            }\n            entity = relationship.destinationEntity();\n            result.addObject(relationship);\n        }\n        part = parts[parts.length-1];\n        EOAttribute attribute = entity.anyAttributeNamed(part);\n        if(attribute == null) {\n            EORelationship relationship = entity.anyRelationshipNamed(part);\n            if(relationship == null) {\n                throw new IllegalArgumentException(\"Last element is not an attribute nor a relationship: \" + keyPath);\n            }\n            if (relationship.isFlattened()) {\n            \tNSArray path = attributePathForKeyPath(entity, relationship.definition());\n            \tresult.addObjectsFromArray(path);\n            \treturn result;\n            } else {\n                attribute = ((EOJoin) relationship.joins().lastObject()).sourceAttribute();\n            }\n         }\n        result.addObject(attribute);\n        return result;\n    }","id":38824,"modified_method":"/**\n     * Creates an array of relationships and attributes from the given keypath to give to the\n     * EOSQLExpression method <code>sqlStringForAttributePath<\/code>. If the last element is a\n     * relationship, then the relationship's source attribute will get chosen. As such, this can only \n     * work for single-value relationships in the last element.\n     * @param entity base entity\n     * @param keyPath key path\n     * @return array of EOProperties that make up the given key path\n     */\n    public static NSArray<EOProperty> attributePathForKeyPath(EOEntity entity, String keyPath) {\n        NSMutableArray<EOProperty> result = new NSMutableArray<EOProperty>();\n        String[] parts = keyPath.split(\"\\\\.\");\n        String part;\n        for (int i = 0; i < parts.length - 1; i++) {\n            part = parts[i];\n            EORelationship relationship = entity.anyRelationshipNamed(part);\n            if(relationship == null) {\n            \t// CHECKME AK:  it would probably be better to return null \n            \t// to indicate that this is not a valid path?\n            \treturn NSArray.EmptyArray;\n            }\n            entity = relationship.destinationEntity();\n            result.addObject(relationship);\n        }\n        part = parts[parts.length-1];\n        EOAttribute attribute = entity.anyAttributeNamed(part);\n        if(attribute == null) {\n            EORelationship relationship = entity.anyRelationshipNamed(part);\n            if(relationship == null) {\n                throw new IllegalArgumentException(\"Last element is not an attribute nor a relationship: \" + keyPath);\n            }\n            if (relationship.isFlattened()) {\n            \tNSArray<EOProperty> path = attributePathForKeyPath(entity, relationship.definition());\n            \tresult.addObjectsFromArray(path);\n            \treturn result;\n            }\n            attribute = relationship.joins().lastObject().sourceAttribute();\n         }\n        result.addObject(attribute);\n        return result;\n    }","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n \t * In a multi-OSC or multi-instance scenario, when there are bugs, it is possible for the snapshots to become out of\n \t * sync with the database. It is useful to have some way to determine when exactly this condition occurs for writing\n \t * test cases.\n \t * \n \t * @return a set of strings that describe the mismatches that occurred\n \t */\n \tpublic static NSSet verifyAllSnapshots() {\n \t\tNSMutableSet mismatches = new NSMutableSet();\n \t\tNSMutableSet verifiedDatabases = new NSMutableSet();\n \t\tEOEditingContext editingContext = ERXEC.newEditingContext();\n \t\tEOModelGroup modelGroup = EOModelGroup.defaultGroup();\n \t\tEnumeration modelsEnum = modelGroup.models().objectEnumerator();\n \t\twhile (modelsEnum.hasMoreElements()) {\n \t\t\tEOModel model = (EOModel) modelsEnum.nextElement();\n \t\t\tEODatabaseContext databaseContext = null;\n \t\t\ttry {\n \t\t\t\tdatabaseContext = EODatabaseContext.registeredDatabaseContextForModel(model, editingContext);\n \t\t\t}\n \t\t\tcatch (IllegalStateException e) {\n \t\t\t\tlog.warn(\"Model \" + model.name() + \" failed: \" + e.getMessage());\n \t\t\t}\n \t\t\tif (databaseContext != null) {\n \t\t\t\tdatabaseContext.lock();\n \t\t\t\ttry {\n \t\t\t\t\tEODatabase database = databaseContext.database();\n \t\t\t\t\tif (!verifiedDatabases.containsObject(database)) {\n \t\t\t\t\t\tEnumeration gidEnum = database.snapshots().keyEnumerator();\n \t\t\t\t\t\twhile (gidEnum.hasMoreElements()) {\n \t\t\t\t\t\t\tEOGlobalID gid = (EOGlobalID) gidEnum.nextElement();\n \t\t\t\t\t\t\tif (gid instanceof EOKeyGlobalID) {\n \t\t\t\t\t\t\t\tEOEnterpriseObject eo = null;\n \t\t\t\t\t\t\t\tEOKeyGlobalID keyGID = (EOKeyGlobalID) gid;\n \t\t\t\t\t\t\t\tString entityName = keyGID.entityName();\n \t\t\t\t\t\t\t\tEOEntity entity = modelGroup.entityNamed(entityName);\n \t\t\t\t\t\t\t\tNSDictionary snapshot = database.snapshotForGlobalID(gid);\n \t\t\t\t\t\t\t\tif (snapshot != null) {\n \t\t\t\t\t\t\t\t\tEOQualifier gidQualifier = entity.qualifierForPrimaryKey(entity.primaryKeyForGlobalID(gid));\n \t\t\t\t\t\t\t\t\tEOFetchSpecification gidFetchSpec = new EOFetchSpecification(entityName, gidQualifier, null);\n\n \t\t\t\t\t\t\t\t\tNSMutableDictionary databaseSnapshotClone;\n \t\t\t\t\t\t\t\t\tNSMutableDictionary memorySnapshotClone = snapshot.mutableClone();\n \t\t\t\t\t\t\t\t\tEOAdaptorContext context;\n \t\t\t\t\t\t\t\t\tEOAdaptorChannel channel = databaseContext.availableChannel().adaptorChannel();\n \t\t\t\t\t\t\t\t\tchannel.openChannel();\n \t\t\t\t\t\t\t\t\tchannel.selectAttributes(entity.attributesToFetch(), gidFetchSpec, false, entity);\n \t\t\t\t\t\t\t\t\tNSDictionary nextRow;\n \t\t\t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\t\t\tdatabaseSnapshotClone = channel.fetchRow().mutableClone();\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\tfinally {\n \t\t\t\t\t\t\t\t\t\tchannel.cancelFetch();\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t// gidFetchSpec.setRefreshesRefetchedObjects(true);\n \t\t\t\t\t\t\t\t\t// NSArray databaseEOs = editingContext.objectsWithFetchSpecification(gidFetchSpec);\n \t\t\t\t\t\t\t\t\tif (databaseSnapshotClone == null) {\n \t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \" was deleted in the database, but the snapshot still exists: \" + memorySnapshotClone);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\t\t// NSMutableDictionary refreshedSnapshotClone =\n \t\t\t\t\t\t\t\t\t\t// database.snapshotForGlobalID(gid).mutableClone();\n \t\t\t\t\t\t\t\t\t\tERXDictionaryUtilities.removeMatchingEntries(memorySnapshotClone, databaseSnapshotClone);\n \t\t\t\t\t\t\t\t\t\tif (databaseSnapshotClone.count() > 0 || memorySnapshotClone.count() > 0) {\n \t\t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \" doesn't match the database: original = \" + memorySnapshotClone + \"; database = \" + databaseSnapshotClone);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\teo = (EOEnterpriseObject) editingContext.objectsWithFetchSpecification(gidFetchSpec).objectAtIndex(0);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n\n \t\t\t\t\t\t\t\tif (eo != null) {\n \t\t\t\t\t\t\t\t\tEnumeration relationshipsEnum = entity.relationships().objectEnumerator();\n \t\t\t\t\t\t\t\t\twhile (relationshipsEnum.hasMoreElements()) {\n \t\t\t\t\t\t\t\t\t\tEORelationship relationship = (EORelationship) relationshipsEnum.nextElement();\n \t\t\t\t\t\t\t\t\t\tString relationshipName = relationship.name();\n \t\t\t\t\t\t\t\t\t\tNSArray originalDestinationGIDs = database.snapshotForSourceGlobalID(keyGID, relationshipName);\n \t\t\t\t\t\t\t\t\t\tif (originalDestinationGIDs != null) {\n \t\t\t\t\t\t\t\t\t\t\tNSMutableArray newDestinationGIDs = new NSMutableArray();\n \t\t\t\t\t\t\t\t\t\t\tEOQualifier qualifier = relationship.qualifierWithSourceRow(database.snapshotForGlobalID(keyGID));\n \t\t\t\t\t\t\t\t\t\t\tEOFetchSpecification relationshipFetchSpec = new EOFetchSpecification(entityName, qualifier, null);\n \t\t\t\t\t\t\t\t\t\t\tEOAdaptorChannel channel = databaseContext.availableChannel().adaptorChannel();\n \t\t\t\t\t\t\t\t\t\t\tchannel.openChannel();\n \t\t\t\t\t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\t\t\t\t\tchannel.selectAttributes(relationship.destinationEntity().attributesToFetch(), relationshipFetchSpec, false, relationship.destinationEntity());\n \t\t\t\t\t\t\t\t\t\t\t\tNSDictionary nextRow;\n \t\t\t\t\t\t\t\t\t\t\t\tNSDictionary destinationSnapshot = null;\n \t\t\t\t\t\t\t\t\t\t\t\tdo {\n \t\t\t\t\t\t\t\t\t\t\t\t\tdestinationSnapshot = channel.fetchRow();\n \t\t\t\t\t\t\t\t\t\t\t\t\tif (destinationSnapshot != null) {\n \t\t\t\t\t\t\t\t\t\t\t\t\t\tEOGlobalID destinationGID = relationship.destinationEntity().globalIDForRow(destinationSnapshot);\n \t\t\t\t\t\t\t\t\t\t\t\t\t\tnewDestinationGIDs.addObject(destinationGID);\n \t\t\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\t\t\t\t\t\tdestinationSnapshot = null;\n \t\t\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\t\twhile (destinationSnapshot != null);\n \t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\tfinally {\n \t\t\t\t\t\t\t\t\t\t\t\tchannel.cancelFetch();\n \t\t\t\t\t\t\t\t\t\t\t}\n\n \t\t\t\t\t\t\t\t\t\t\tNSArray objectsNotInDatabase = ERXArrayUtilities.arrayMinusArray(originalDestinationGIDs, newDestinationGIDs);\n \t\t\t\t\t\t\t\t\t\t\tif (objectsNotInDatabase.count() > 0) {\n \t\t\t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \".\" + relationshipName + \" has entries not in the database: \" + objectsNotInDatabase);\n \t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\tNSArray objectsNotInMemory = ERXArrayUtilities.arrayMinusArray(newDestinationGIDs, originalDestinationGIDs);\n \t\t\t\t\t\t\t\t\t\t\tif (objectsNotInMemory.count() > 0) {\n \t\t\t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \".\" + relationshipName + \" is missing entries in the database: \" + objectsNotInMemory);\n \t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tverifiedDatabases.addObject(database);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinally {\n \t\t\t\t\tdatabaseContext.unlock();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn mismatches;\n \t}","id":38825,"modified_method":"/**\n \t * In a multi-OSC or multi-instance scenario, when there are bugs, it is possible for the snapshots to become out of\n \t * sync with the database. It is useful to have some way to determine when exactly this condition occurs for writing\n \t * test cases.\n \t * \n \t * @return a set of strings that describe the mismatches that occurred\n \t */\n \tpublic static NSSet verifyAllSnapshots() {\n \t\tNSMutableSet mismatches = new NSMutableSet();\n \t\tNSMutableSet verifiedDatabases = new NSMutableSet();\n \t\tEOEditingContext editingContext = ERXEC.newEditingContext();\n \t\tEOModelGroup modelGroup = EOModelGroup.defaultGroup();\n \t\tEnumeration modelsEnum = modelGroup.models().objectEnumerator();\n \t\twhile (modelsEnum.hasMoreElements()) {\n \t\t\tEOModel model = (EOModel) modelsEnum.nextElement();\n \t\t\tEODatabaseContext databaseContext = null;\n \t\t\ttry {\n \t\t\t\tdatabaseContext = EODatabaseContext.registeredDatabaseContextForModel(model, editingContext);\n \t\t\t}\n \t\t\tcatch (IllegalStateException e) {\n \t\t\t\tlog.warn(\"Model \" + model.name() + \" failed: \" + e.getMessage());\n \t\t\t}\n \t\t\tif (databaseContext != null) {\n \t\t\t\tdatabaseContext.lock();\n \t\t\t\ttry {\n \t\t\t\t\tEODatabase database = databaseContext.database();\n \t\t\t\t\tif (!verifiedDatabases.containsObject(database)) {\n \t\t\t\t\t\tEnumeration gidEnum = database.snapshots().keyEnumerator();\n \t\t\t\t\t\twhile (gidEnum.hasMoreElements()) {\n \t\t\t\t\t\t\tEOGlobalID gid = (EOGlobalID) gidEnum.nextElement();\n \t\t\t\t\t\t\tif (gid instanceof EOKeyGlobalID) {\n \t\t\t\t\t\t\t\tEOEnterpriseObject eo = null;\n \t\t\t\t\t\t\t\tEOKeyGlobalID keyGID = (EOKeyGlobalID) gid;\n \t\t\t\t\t\t\t\tString entityName = keyGID.entityName();\n \t\t\t\t\t\t\t\tEOEntity entity = modelGroup.entityNamed(entityName);\n \t\t\t\t\t\t\t\tNSDictionary snapshot = database.snapshotForGlobalID(gid);\n \t\t\t\t\t\t\t\tif (snapshot != null) {\n \t\t\t\t\t\t\t\t\tEOQualifier gidQualifier = entity.qualifierForPrimaryKey(entity.primaryKeyForGlobalID(gid));\n \t\t\t\t\t\t\t\t\tEOFetchSpecification gidFetchSpec = new EOFetchSpecification(entityName, gidQualifier, null);\n\n \t\t\t\t\t\t\t\t\tNSMutableDictionary databaseSnapshotClone;\n \t\t\t\t\t\t\t\t\tNSMutableDictionary memorySnapshotClone = snapshot.mutableClone();\n \t\t\t\t\t\t\t\t\tEOAdaptorChannel channel = databaseContext.availableChannel().adaptorChannel();\n \t\t\t\t\t\t\t\t\tchannel.openChannel();\n \t\t\t\t\t\t\t\t\tchannel.selectAttributes(entity.attributesToFetch(), gidFetchSpec, false, entity);\n \t\t\t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\t\t\tdatabaseSnapshotClone = channel.fetchRow().mutableClone();\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\tfinally {\n \t\t\t\t\t\t\t\t\t\tchannel.cancelFetch();\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t// gidFetchSpec.setRefreshesRefetchedObjects(true);\n \t\t\t\t\t\t\t\t\t// NSArray databaseEOs = editingContext.objectsWithFetchSpecification(gidFetchSpec);\n \t\t\t\t\t\t\t\t\tif (databaseSnapshotClone == null) {\n \t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \" was deleted in the database, but the snapshot still exists: \" + memorySnapshotClone);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\t\t// NSMutableDictionary refreshedSnapshotClone =\n \t\t\t\t\t\t\t\t\t\t// database.snapshotForGlobalID(gid).mutableClone();\n \t\t\t\t\t\t\t\t\t\tERXDictionaryUtilities.removeMatchingEntries(memorySnapshotClone, databaseSnapshotClone);\n \t\t\t\t\t\t\t\t\t\tif (databaseSnapshotClone.count() > 0 || memorySnapshotClone.count() > 0) {\n \t\t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \" doesn't match the database: original = \" + memorySnapshotClone + \"; database = \" + databaseSnapshotClone);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\teo = (EOEnterpriseObject) editingContext.objectsWithFetchSpecification(gidFetchSpec).objectAtIndex(0);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n\n \t\t\t\t\t\t\t\tif (eo != null) {\n \t\t\t\t\t\t\t\t\tEnumeration relationshipsEnum = entity.relationships().objectEnumerator();\n \t\t\t\t\t\t\t\t\twhile (relationshipsEnum.hasMoreElements()) {\n \t\t\t\t\t\t\t\t\t\tEORelationship relationship = (EORelationship) relationshipsEnum.nextElement();\n \t\t\t\t\t\t\t\t\t\tString relationshipName = relationship.name();\n \t\t\t\t\t\t\t\t\t\tNSArray originalDestinationGIDs = database.snapshotForSourceGlobalID(keyGID, relationshipName);\n \t\t\t\t\t\t\t\t\t\tif (originalDestinationGIDs != null) {\n \t\t\t\t\t\t\t\t\t\t\tNSMutableArray newDestinationGIDs = new NSMutableArray();\n \t\t\t\t\t\t\t\t\t\t\tEOQualifier qualifier = relationship.qualifierWithSourceRow(database.snapshotForGlobalID(keyGID));\n \t\t\t\t\t\t\t\t\t\t\tEOFetchSpecification relationshipFetchSpec = new EOFetchSpecification(entityName, qualifier, null);\n \t\t\t\t\t\t\t\t\t\t\tEOAdaptorChannel channel = databaseContext.availableChannel().adaptorChannel();\n \t\t\t\t\t\t\t\t\t\t\tchannel.openChannel();\n \t\t\t\t\t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\t\t\t\t\tchannel.selectAttributes(relationship.destinationEntity().attributesToFetch(), relationshipFetchSpec, false, relationship.destinationEntity());\n \t\t\t\t\t\t\t\t\t\t\t\tNSDictionary destinationSnapshot = null;\n \t\t\t\t\t\t\t\t\t\t\t\tdo {\n \t\t\t\t\t\t\t\t\t\t\t\t\tdestinationSnapshot = channel.fetchRow();\n \t\t\t\t\t\t\t\t\t\t\t\t\tif (destinationSnapshot != null) {\n \t\t\t\t\t\t\t\t\t\t\t\t\t\tEOGlobalID destinationGID = relationship.destinationEntity().globalIDForRow(destinationSnapshot);\n \t\t\t\t\t\t\t\t\t\t\t\t\t\tnewDestinationGIDs.addObject(destinationGID);\n \t\t\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\t\twhile (destinationSnapshot != null);\n \t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\tfinally {\n \t\t\t\t\t\t\t\t\t\t\t\tchannel.cancelFetch();\n \t\t\t\t\t\t\t\t\t\t\t}\n\n \t\t\t\t\t\t\t\t\t\t\tNSArray objectsNotInDatabase = ERXArrayUtilities.arrayMinusArray(originalDestinationGIDs, newDestinationGIDs);\n \t\t\t\t\t\t\t\t\t\t\tif (objectsNotInDatabase.count() > 0) {\n \t\t\t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \".\" + relationshipName + \" has entries not in the database: \" + objectsNotInDatabase);\n \t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t\tNSArray objectsNotInMemory = ERXArrayUtilities.arrayMinusArray(newDestinationGIDs, originalDestinationGIDs);\n \t\t\t\t\t\t\t\t\t\t\tif (objectsNotInMemory.count() > 0) {\n \t\t\t\t\t\t\t\t\t\t\t\tmismatches.addObject(gid + \".\" + relationshipName + \" is missing entries in the database: \" + objectsNotInMemory);\n \t\t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tverifiedDatabases.addObject(database);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinally {\n \t\t\t\t\tdatabaseContext.unlock();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn mismatches;\n \t}","commit_id":"b25130694e7a385e039d58633968a24c1deb2671","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected long createRow(Connection con, long increment) throws SQLException {\n\t\t\tcon.createStatement().executeUpdate(\"insert into erx_sequence_table (name_, value_) values ('\" + name() + \"', \" + increment + \")\");\n\t\t\treturn 0L;\n\t\t}","id":38826,"modified_method":"protected long createRow(Connection con, long increment) throws SQLException {\n\t\t\tString incrementString = EOSQLExpression.sqlStringForNumber(Long.valueOf(increment));\n\t\t\tString tableList = ERX_SEQUENCE_TABLE;\n\t\t\tString columnList = NAME_COLUMN_NAME + \",\" + VALUE_COLUMN_NAME;\n\t\t\tString valueList = \"'\" + name() + \"',\" + incrementString;\n\t\t\tString insertStatement = _factory.expressionForEntity(null).assembleInsertStatementWithRow(null, tableList, columnList, valueList);\n\t\t\tcon.createStatement().executeUpdate(insertStatement);\n\t\t\treturn 0L;\n\t\t}","commit_id":"5e065339ef91038acf49ece5df2f6c32483ccf4e","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected long selectAndUpdateValue(Connection con, long increment) throws SQLException {\n\t\t\tlong pk;\n\t\t\tString where = \"where name_ = '\"+ name() +\"'\";\n    \t\tResultSet resultSet = con.createStatement().executeQuery(\"select value_ from erx_sequence_table \" + where + \" for update\");\n    \t\tboolean hasNext = resultSet.next();\n    \t\tif (hasNext) {\n    \t\t\tpk = resultSet.getLong(\"value_\");\n    \t\t\tcon.createStatement().executeUpdate(\"update erx_sequence_table set value_ = value_ +\" + increment + \" \" + where);\n    \t\t} else {\n    \t\t\tpk = createRow(con, increment);\n    \t\t}\n    \t\treturn pk;\n\t\t}","id":38827,"modified_method":"protected long selectAndUpdateValue(Connection con, long increment) throws SQLException {\n\t\t\tlong pk;\n\t\t\tEOSQLExpression selectExpression = _factory.expressionForEntity(null);\n\n\t\t\tString columnList = VALUE_COLUMN_NAME;\n\t\t\tString tableList = ERX_SEQUENCE_TABLE;\n\t\t\tString whereSelector = selectExpression.sqlStringForSelector(EOQualifier.QualifierOperatorEqual, name());\n\t\t\tString whereClause = NAME_COLUMN_NAME + \" \" + whereSelector + \" '\" + name() + \"'\";\n\t\t\tString lockClause = selectExpression.lockClause();\n\n\t\t\tString selectStatement = selectExpression.assembleSelectStatementWithAttributes(null, true, null, null, \"SELECT \", columnList , tableList, whereClause, null, null, lockClause);\n\t\t\tResultSet resultSet = con.createStatement().executeQuery(selectStatement);\n    \t\t\n    \t\tboolean hasNext = resultSet.next();\n    \t\tif (hasNext) {\n    \t\t\tString incrementString = EOSQLExpression.sqlStringForNumber(Long.valueOf(increment));\n    \t\t\tString updateValueColumn = VALUE_COLUMN_NAME + \" = \" + VALUE_COLUMN_NAME + \" + \" + incrementString;\n\t\t\t\tString updateList = updateValueColumn;\n    \t\t\n    \t\t\tpk = resultSet.getLong(VALUE_COLUMN_NAME);\n\t\t\t\tString updateStatement = _factory.expressionForEntity(null).assembleUpdateStatementWithRow(null, null, tableList, updateList, whereClause);\n    \t\t\tcon.createStatement().executeQuery(updateStatement);\n    \t\t} else {\n    \t\t\tpk = createRow(con, increment);\n    \t\t}\n    \t\treturn pk;\n\t\t}","commit_id":"5e065339ef91038acf49ece5df2f6c32483ccf4e","url":"https://github.com/wocommunity/wonder"},{"original_method":"public DatabaseSequence(EOEditingContext ec, String modelName, String name, long initialValue) {\n\t\t\tsuper(name, initialValue);\n\t\t\tEOModel model = ERXEOAccessUtilities.modelGroup(ec).modelNamed(modelName);\n\t\t\t_broker = ERXJDBCConnectionBroker.connectionBrokerForModel(model);\n\t\t\t_lastValue = increasedMaxValue(0);\n\t\t\t_maxValue = _lastValue;\t\t\t\n\t\t}","id":38828,"modified_method":"public DatabaseSequence(EOEditingContext ec, String modelName, String name, long initialValue) {\n\t\t\tsuper(name, initialValue);\n\t\t\tEOModel model = ERXEOAccessUtilities.modelGroup(ec).modelNamed(modelName);\n\t\t\t_broker = ERXJDBCConnectionBroker.connectionBrokerForModel(model);\n    \t\t_factory = new EOSQLExpressionFactory(EOAdaptor.adaptorWithModel(model));\n\t\t\t_lastValue = increasedMaxValue(0);\n\t\t\t_maxValue = _lastValue;\n\t\t}","commit_id":"5e065339ef91038acf49ece5df2f6c32483ccf4e","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected long createRow(Connection con, long increment) throws SQLException {\n\t\t\tEOEntity entity = ERXEOAccessUtilities.rootEntityForEntityNamed(_entityName);\n\t\t\tString tableName = entity.externalName();\n\t\t\tString colName = ((EOAttribute)entity.primaryKeyAttributes().lastObject()).columnName();\n\t\t\tString sql = \"select max(\" + colName + \") from \" + tableName;\n\n\t\t\tResultSet resultSet;\n\t\t\tresultSet = con.createStatement().executeQuery(sql);\n\t\t\tcon.commit();\n\n\t\t\tboolean hasNext = resultSet.next();\n\t\t\tlong v = 0L;\n\t\t\tif (hasNext) {\n\t\t\t\tv = resultSet.getLong(1);\n\t\t\t\tv = fixMaxIdValue(v);\n\t\t\t\t/*if (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"received max id from table \" + tableName + \", setting value in PK_TABLE to \" + v);\n\t\t\t\t\t                if(encodeEntityInPkValue()) {\n\t                \tv = v >> CODE_LENGTH;\n\t                }\n\t                if(encodeHostInPkValue()) {\n\t                \tv = v >> HOST_CODE_LENGTH;\n\t                }*/\n\t\t\t}\n\t\t\tsuper.createRow(con, v+increment);\n\t\t\treturn v;\n\t\t}","id":38829,"modified_method":"protected long createRow(Connection con, long increment) throws SQLException {\n\t\t\tEOEntity entity = ERXEOAccessUtilities.rootEntityForEntityNamed(_entityName);\n\t\t\tString tableName = entity.externalName();\n\t\t\tString colName = entity.primaryKeyAttributes().lastObject().columnName();\n\t\t\tString sql = \"select max(\" + colName + \") from \" + tableName;\n\n\t\t\tResultSet resultSet;\n\t\t\tresultSet = con.createStatement().executeQuery(sql);\n\t\t\tcon.commit();\n\n\t\t\tboolean hasNext = resultSet.next();\n\t\t\tlong v = 0L;\n\t\t\tif (hasNext) {\n\t\t\t\tv = resultSet.getLong(1);\n\t\t\t\tv = fixMaxIdValue(v);\n\t\t\t\t/*if (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"received max id from table \" + tableName + \", setting value in PK_TABLE to \" + v);\n\t\t\t\t\t                if(encodeEntityInPkValue()) {\n\t                \tv = v >> CODE_LENGTH;\n\t                }\n\t                if(encodeHostInPkValue()) {\n\t                \tv = v >> HOST_CODE_LENGTH;\n\t                }*/\n\t\t\t}\n\t\t\tsuper.createRow(con, v+increment);\n\t\t\treturn v;\n\t\t}","commit_id":"5e065339ef91038acf49ece5df2f6c32483ccf4e","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void createTable(Connection con) throws SQLException {\n\t\t\tcon.createStatement().executeUpdate(\"create table erx_sequence_table (name_ varchar(100) not null, value_ int)\");\n\t\t\tcon.createStatement().executeUpdate(\"alter table erx_sequence_table add primary key (name_)\");// NOT\n\t\t\t// DEFERRABLE\n\t\t\t// INITIALLY\n\t\t\t// IMMEDIATE\");\n\t\t}","id":38830,"modified_method":"protected void createTable(Connection con) throws SQLException {\n\t\t\tString nameColumnClause = NAME_COLUMN_NAME + \" VARCHAR(100) NOT NULL\";\n\t\t\tString valueColumnClause = VALUE_COLUMN_NAME + \" INT\";\n\t\t\tString createTableStatement = \"CREATE TABLE \" + ERX_SEQUENCE_TABLE + \" (\" + nameColumnClause + \", \" + valueColumnClause + \")\";\n\t\t\tString alterTableStatement = \"ALTER TABLE \" + ERX_SEQUENCE_TABLE + \" ADD PRIMARY KEY (\" + NAME_COLUMN_NAME + \")\";// NOT\n\t\t\t// DEFERRABLE\n\t\t\t// INITIALLY\n\t\t\t// IMMEDIATE\");\n\t\t\tcon.createStatement().executeUpdate(createTableStatement);\n\t\t\tcon.createStatement().executeUpdate(alterTableStatement);\n\t\t}","commit_id":"5e065339ef91038acf49ece5df2f6c32483ccf4e","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected boolean isCreationError(SQLException ex) {\n\t\t\tString s = ex.getMessage().toLowerCase();\n    \t\tboolean creationError = false;\n    \t\tcreationError |= (s.indexOf(\"error code 116\") != -1); // frontbase?\n\t\t\tcreationError |= (s.indexOf(\"erx_sequence_table\") != -1 && s.indexOf(\"does not exist\") != -1); // postgres ?\n\t\t\tcreationError |= s.indexOf(\"ora-00942\") != -1; // oracle\n\t\t\tcreationError |= s.indexOf(\"doesn't exist\") != -1; // mysql\n\t\t\tcreationError |= (s.indexOf(\"erx_sequence_table\") != -1 && s.indexOf(\"not found.\") != -1); // sybase\n\t\t\treturn creationError;\n\t\t}","id":38831,"modified_method":"protected boolean isCreationError(SQLException ex) {\n\t\t\tString s = ex.getMessage().toLowerCase();\n    \t\tboolean creationError = false;\n    \t\tString tableNameLastComponent = DatabaseSequence.ERX_SEQUENCE_TABLE.substring(DatabaseSequence.ERX_SEQUENCE_TABLE.lastIndexOf('.')+1);\n    \t\tcreationError |= (s.indexOf(\"error 116\") != -1); // frontbase?\n\t\t\tcreationError |= (s.indexOf(tableNameLastComponent) != -1 && s.indexOf(\"does not exist\") != -1); // postgres ?\n\t\t\tcreationError |= s.indexOf(\"ora-00942\") != -1; // oracle\n\t\t\tcreationError |= s.indexOf(\"doesn't exist\") != -1; // mysql\n\t\t\tcreationError |= (s.indexOf(tableNameLastComponent) != -1 && s.indexOf(\"not found.\") != -1); // sybase\n\t\t\treturn creationError;\n\t\t}","commit_id":"5e065339ef91038acf49ece5df2f6c32483ccf4e","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns a localized string for the given prefix and keyPath, inserting it \"prefix.keyPath\" = \"Key Path\"; Also\n\t * tries to find \"Key Path\"\n\t * \n\t * @param prefix\n\t * @param key\n\t */\n\tpublic String localizedDisplayNameForKey(String prefix, String key) {\n\t\tString localizerKey = prefix + \".\" + key;\n\t\tString result = localizedStringForKey(localizerKey);\n\t\tif (result == null) {\n\t\t\tresult = displayNameForKey(key);\n\t\t\tString localized = localizedStringForKey(result);\n\t\t\tif (localized != null) {\n\t\t\t\tresult = localized;\n\t\t\t\tlog.info(\"Found an old-style entry: \" + localizerKey + \"->\" + result);\n\t\t\t}\n\t\t\ttakeValueForKey(result, localizerKey);\n\t\t}\n\t\treturn result;\n\t}","id":38832,"modified_method":"/**\n\t * Returns a localized string for the given prefix and keyPath, inserting it \"prefix.keyPath\" = \"Key Path\"; Also\n\t * tries to find \"Key Path\"\n\t * \n\t * @param prefix\n\t * @param key\n\t * @return the localized string\n\t */\n\tpublic String localizedDisplayNameForKey(String prefix, String key) {\n\t\tString localizerKey = prefix + \".\" + key;\n\t\tString result = localizedStringForKey(localizerKey);\n\t\tif (result == null) {\n\t\t\tresult = displayNameForKey(key);\n\t\t\tString localized = localizedStringForKey(result);\n\t\t\tif (localized != null) {\n\t\t\t\tresult = localized;\n\t\t\t\tlog.info(\"Found an old-style entry: \" + localizerKey + \"->\" + result);\n\t\t\t}\n\t\t\ttakeValueForKey(result, localizerKey);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"bce3490c1b04c559a7a83e56872ce79d367d45c1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String localizedTemplateStringForKeyWithObjectOtherObject(String key, Object o1, Object o2) {\n\t\tif (key != null) {\n\t\t\tString template = (String) localizedStringForKeyWithDefault(key);\n\t\t\tif (template != null)\n\t\t\t\treturn ERXSimpleTemplateParser.sharedInstance().parseTemplateWithObject(template, null, o1, o2);\n\t\t}\n\t\treturn key;\n\t}","id":38833,"modified_method":"public String localizedTemplateStringForKeyWithObjectOtherObject(String key, Object o1, Object o2) {\n\t\tif (key != null) {\n\t\t\tString template = localizedStringForKeyWithDefault(key);\n\t\t\tif (template != null)\n\t\t\t\treturn ERXSimpleTemplateParser.sharedInstance().parseTemplateWithObject(template, null, o1, o2);\n\t\t}\n\t\treturn key;\n\t}","commit_id":"bce3490c1b04c559a7a83e56872ce79d367d45c1","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Processes a validation exception to make it look better.\n     * The resulting exception message is set in the errorMessages\n     * dictionary.\n     *\n     * @param e validation exception.\n     * @param value that failed validation.\n     * @param keyPath that failed validation.\n     * @param errorMessages dictionary to place the formatted message into.\n     * @param displayPropertyKeyPath key used in the case of the formatter exception\n     *\t\tto calculate the pretty display name.\n     * @param localizer to use to localize the exception.\n     * @param entity that the validation exception is happening too.\n     * @param pushChanges boolean to flag if the bad values should be pushed onto the\n     *\t\teo.\n     */\n    public static void validationFailedWithException(Throwable e,\n                                                     Object value,\n                                                     String keyPath,\n                                                     NSMutableDictionary errorMessages,\n                                                     String displayPropertyKeyPath,\n                                                     ERXLocalizer localizer,\n                                                     EOEntity entity,\n                                                     boolean pushChanges) {\n        if (log.isDebugEnabled())\n            log.debug(\"ValidationFailedWithException: \" + e.getClass().getName() + \" message: \" + e.getMessage());\n        String key = null;\n        String newErrorMessage=e.getMessage();\n        if (e instanceof NSValidation.ValidationException && ((NSValidation.ValidationException)e).key() != null\n            && ((NSValidation.ValidationException)e).object() != null) {\n            NSValidation.ValidationException nve = (NSValidation.ValidationException)e;\n            key = nve.key();\n            Object eo=nve.object();\n            // this because exceptions raised by formatters have the failing VALUE in this key..\n            // strip the exception name\n            //newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            //newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            if (eo instanceof EOEnterpriseObject) {\n                // the exception is coming from EREnterpriseObject\n                // WE PUSH THE WRONG VALUE INTO THE EO ANYWAY!\n                if (pushChanges)  {\n                    try {\n                        ((EOEnterpriseObject)eo).takeValueForKeyPath(value, key);\n                    } catch(NSKeyValueCoding.UnknownKeyException  ex) {\n                        // AK: as we could have custom components that have non-existant keys\n                        // we of course can't push a value, so we discard the resulting exception\n                    } catch(NoSuchElementException  ex) {\n                        // AK: as we could have custom components that have non-existant keys\n                        // we of course can't push a value, so we discard the resulting exception\n                    } catch(Exception ex) {\n                        log.error(\"Can't push value to key '\" + key + \"': \" + value, ex);\n                    }\n                }\n                entity = EOUtilities.entityForObject(((EOEnterpriseObject)eo).editingContext(),(EOEnterpriseObject)eo);\n            } else {\n                //the exception is coming from a formatter\n                key=(String)NSArray.componentsSeparatedByString(displayPropertyKeyPath,\".\").lastObject();\n                newErrorMessage=\"<b>\"+key+\"<\/b>:\"+newErrorMessage;\n            }\n        } else {\n            key = keyPath;\n        }\n        if (key != null && newErrorMessage != null) {\n        \t  String displayName = localizedDisplayNameForKey(entity != null ? entity.classDescriptionForInstances() : null, key, localizer);\n            errorMessages.setObjectForKey(newErrorMessage, displayName);\n        } else {\n            if(key != null) {\n                //log.warn(\"NULL message for key:'\"+key+\"': \" + ((EOGeneralAdaptorException)e).userInfo() , e);\n                log.warn(\"NULL message for key:'\"+key+\"': \" + e, e);\n                \n            } else {\n                log.warn(\"NULL key for message:'\"+newErrorMessage+\"'\", e);\n            }\n        }\n    }","id":38834,"modified_method":"/**\n     * Processes a validation exception to make it look better.\n     * The resulting exception message is set in the errorMessages\n     * dictionary.\n     *\n     * @param e validation exception.\n     * @param value that failed validation.\n     * @param keyPath that failed validation.\n     * @param errorMessages dictionary to place the formatted message into.\n     * @param displayPropertyKeyPath key used in the case of the formatter exception\n     *\t\tto calculate the pretty display name.\n     * @param localizer to use to localize the exception.\n     * @param entity that the validation exception is happening too.\n     * @param pushChanges boolean to flag if the bad values should be pushed onto the\n     *\t\teo.\n     */\n    public static void validationFailedWithException(Throwable e,\n                                                     Object value,\n                                                     String keyPath,\n                                                     NSMutableDictionary errorMessages,\n                                                     String displayPropertyKeyPath,\n                                                     ERXLocalizer localizer,\n                                                     EOEntity entity,\n                                                     boolean pushChanges) {\n        if (log.isDebugEnabled())\n            log.debug(\"ValidationFailedWithException: \" + e.getClass().getName() + \" message: \" + e.getMessage());\n        String key = null;\n        String newErrorMessage=e.getMessage();\n        if (e instanceof NSValidation.ValidationException && ((NSValidation.ValidationException)e).key() != null\n            && ((NSValidation.ValidationException)e).object() != null) {\n            NSValidation.ValidationException nve = (NSValidation.ValidationException)e;\n            key = nve.key();\n            Object eo=nve.object();\n            // this because exceptions raised by formatters have the failing VALUE in this key..\n            // strip the exception name\n            //newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            //newErrorMessage=newErrorMessage.substring(newErrorMessage.indexOf(\":\")+1);\n            if (eo instanceof EOEnterpriseObject) {\n                // the exception is coming from EREnterpriseObject\n                // WE PUSH THE WRONG VALUE INTO THE EO ANYWAY!\n                if (pushChanges)  {\n                    try {\n                        ((EOEnterpriseObject)eo).takeValueForKeyPath(value, key);\n                    } catch(NSKeyValueCoding.UnknownKeyException  ex) {\n                        // AK: as we could have custom components that have non-existant keys\n                        // we of course can't push a value, so we discard the resulting exception\n                    } catch(NoSuchElementException  ex) {\n                        // AK: as we could have custom components that have non-existant keys\n                        // we of course can't push a value, so we discard the resulting exception\n                    } catch(Exception ex) {\n                        log.error(\"Can't push value to key '\" + key + \"': \" + value, ex);\n                    }\n                }\n                entity = EOUtilities.entityForObject(((EOEnterpriseObject)eo).editingContext(),(EOEnterpriseObject)eo);\n            } else {\n                //the exception is coming from a formatter\n                key = NSArray.componentsSeparatedByString(displayPropertyKeyPath,\".\").lastObject();\n                newErrorMessage=\"<b>\"+key+\"<\/b>:\"+newErrorMessage;\n            }\n        } else {\n            key = keyPath;\n        }\n        if (key != null && newErrorMessage != null) {\n        \t  String displayName = localizedDisplayNameForKey(entity != null ? entity.classDescriptionForInstances() : null, key, localizer);\n            errorMessages.setObjectForKey(newErrorMessage, displayName);\n        } else {\n            if(key != null) {\n                //log.warn(\"NULL message for key:'\"+key+\"': \" + ((EOGeneralAdaptorException)e).userInfo() , e);\n                log.warn(\"NULL message for key:'\"+key+\"': \" + e, e);\n                \n            } else {\n                log.warn(\"NULL key for message:'\"+newErrorMessage+\"'\", e);\n            }\n        }\n    }","commit_id":"bce3490c1b04c559a7a83e56872ce79d367d45c1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String sqlStringForSQLExpression(EOQualifier eoqualifier, EOSQLExpression e) {\n            ERXToManyQualifier qualifier = (ERXToManyQualifier)eoqualifier;\n            StringBuffer result=new StringBuffer();\n            EOEntity targetEntity=e.entity();\n\n            NSArray toManyKeys=NSArray.componentsSeparatedByString(qualifier.key(),\".\");\n            EORelationship targetRelationship=null;\n            for (int i=0; i<toManyKeys.count()-1;i++) {\n                targetRelationship= targetEntity.anyRelationshipNamed((String)toManyKeys.objectAtIndex(i));\n                targetEntity=targetRelationship.destinationEntity();\n            }\n            targetRelationship=targetEntity.relationshipNamed((String)toManyKeys.lastObject());\n            targetEntity=targetRelationship.destinationEntity();\n\n            if (targetRelationship.joins()==null || targetRelationship.joins().count()==0) {\n                // we have a flattened many to many\n                String definitionKeyPath=targetRelationship.definition();                        \n                NSArray definitionKeys=NSArray.componentsSeparatedByString(definitionKeyPath,\".\");\n                EOEntity lastStopEntity=targetRelationship.entity();\n                EORelationship firstHopRelationship= lastStopEntity.relationshipNamed((String)definitionKeys.objectAtIndex(0));\n                EOEntity endOfFirstHopEntity= firstHopRelationship.destinationEntity();\n                EOJoin join=(EOJoin) firstHopRelationship.joins().objectAtIndex(0); // assumes 1 join\n                EOAttribute sourceAttribute=join.sourceAttribute();\n                EOAttribute targetAttribute=join.destinationAttribute();\n                EORelationship secondHopRelationship=endOfFirstHopEntity.relationshipNamed((String)definitionKeys.objectAtIndex(1));\n                join=(EOJoin) secondHopRelationship.joins().objectAtIndex(0); // assumes 1 join\n                EOAttribute secondHopSourceAttribute=join.sourceAttribute();\n\n                NSMutableArray lastStopPKeyPath=new NSMutableArray(toManyKeys);\n                lastStopPKeyPath.removeLastObject();\n                lastStopPKeyPath.addObject(firstHopRelationship.name());\n                lastStopPKeyPath.addObject(targetAttribute.name());\n                String firstHopRelationshipKeyPath=lastStopPKeyPath.componentsJoinedByString(\".\");\n                result.append(e.sqlStringForAttributeNamed(firstHopRelationshipKeyPath));\n                result.append(\" IN ( SELECT \");\n\n                result.append(lastStopEntity.externalName());\n                result.append('.');\n                result.append(((EOAttribute)lastStopEntity.primaryKeyAttributes().objectAtIndex(0)).columnName());\n\n                result.append(\" FROM \");\n\n                result.append(lastStopEntity.externalName());\n                result.append(',');\n\n                lastStopPKeyPath.removeLastObject();\n                String tableAliasForJoinTable=(String)e.aliasesByRelationshipPath().\n                    objectForKey(lastStopPKeyPath.componentsJoinedByString(\".\"));//\"j\"; //+random#\n                result.append(endOfFirstHopEntity.externalName());\n                result.append(' ');\n                result.append(tableAliasForJoinTable);\n\n                result.append(\" WHERE \");\n\n                appendColumnForAttributeToStringBuffer(sourceAttribute,result);\n                result.append('=');\n                result.append(e.sqlStringForAttributeNamed(firstHopRelationshipKeyPath));\n                \n                if(qualifier.elements() != null) {\n                    NSArray pKeys=ERXEOAccessUtilities.primaryKeysForObjects(qualifier.elements());\n                    result.append(\" AND \");\n                    \n                    result.append(tableAliasForJoinTable);\n                    result.append('.');\n                    result.append(secondHopSourceAttribute.columnName());\n                    \n                    result.append(\" IN (\"); \n                    EOAttribute pk = (EOAttribute)targetEntity.primaryKeyAttributes().lastObject();\n                    for(int i = 0; i < pKeys.count(); i++) {\n                        \n                        Object key = pKeys.objectAtIndex(i);\n                        String keyString = e.formatValueForAttribute(key, pk);\n                        result.append(keyString);\n                        if(i < pKeys.count()-1) {\n                            result.append(\",\");\n                        }\n                    }\n                    result.append(\") \");\n                }\n                result.append(\" GROUP BY \");\n                appendColumnForAttributeToStringBuffer(sourceAttribute,result);\n\n                result.append(\" HAVING COUNT(*)\");\n                if (qualifier.minCount() <= 0) {\n                    result.append(\"=\" + qualifier.elements().count());\n                } else {\n                    result.append(\">=\" + qualifier.minCount());                \n                }\n                result.append(\" )\");\n            } else {\n                throw new RuntimeException(\"not implemented!!\");\n            }\n            return result.toString();\n        }","id":38835,"modified_method":"@Override\n        @SuppressWarnings(\"unchecked\")\n\t\tpublic String sqlStringForSQLExpression(EOQualifier eoqualifier, EOSQLExpression e) {\n            ERXToManyQualifier qualifier = (ERXToManyQualifier)eoqualifier;\n            StringBuffer result=new StringBuffer();\n            EOEntity targetEntity=e.entity();\n\n            NSArray<String> toManyKeys=NSArray.componentsSeparatedByString(qualifier.key(),\".\");\n            EORelationship targetRelationship=null;\n            for (int i=0; i<toManyKeys.count()-1;i++) {\n                targetRelationship= targetEntity.anyRelationshipNamed(toManyKeys.objectAtIndex(i));\n                targetEntity=targetRelationship.destinationEntity();\n            }\n            targetRelationship=targetEntity.relationshipNamed(toManyKeys.lastObject());\n            targetEntity=targetRelationship.destinationEntity();\n\n            if (targetRelationship.joins()==null || targetRelationship.joins().count()==0) {\n                // we have a flattened many to many\n                String definitionKeyPath=targetRelationship.definition();                        \n                NSArray definitionKeys=NSArray.componentsSeparatedByString(definitionKeyPath,\".\");\n                EOEntity lastStopEntity=targetRelationship.entity();\n                EORelationship firstHopRelationship= lastStopEntity.relationshipNamed((String)definitionKeys.objectAtIndex(0));\n                EOEntity endOfFirstHopEntity= firstHopRelationship.destinationEntity();\n                EOJoin join=(EOJoin) firstHopRelationship.joins().objectAtIndex(0); // assumes 1 join\n                EOAttribute sourceAttribute=join.sourceAttribute();\n                EOAttribute targetAttribute=join.destinationAttribute();\n                EORelationship secondHopRelationship=endOfFirstHopEntity.relationshipNamed((String)definitionKeys.objectAtIndex(1));\n                join=(EOJoin) secondHopRelationship.joins().objectAtIndex(0); // assumes 1 join\n                EOAttribute secondHopSourceAttribute=join.sourceAttribute();\n\n                NSMutableArray<String> lastStopPKeyPath=new NSMutableArray<String>(toManyKeys);\n                lastStopPKeyPath.removeLastObject();\n                lastStopPKeyPath.addObject(firstHopRelationship.name());\n                lastStopPKeyPath.addObject(targetAttribute.name());\n                String firstHopRelationshipKeyPath=lastStopPKeyPath.componentsJoinedByString(\".\");\n                result.append(e.sqlStringForAttributeNamed(firstHopRelationshipKeyPath));\n                result.append(\" IN ( SELECT \");\n\n                result.append(lastStopEntity.externalName());\n                result.append('.');\n                result.append(((EOAttribute)lastStopEntity.primaryKeyAttributes().objectAtIndex(0)).columnName());\n\n                result.append(\" FROM \");\n\n                result.append(lastStopEntity.externalName());\n                result.append(',');\n\n                lastStopPKeyPath.removeLastObject();\n                String tableAliasForJoinTable=(String)e.aliasesByRelationshipPath().\n                    objectForKey(lastStopPKeyPath.componentsJoinedByString(\".\"));//\"j\"; //+random#\n                result.append(endOfFirstHopEntity.externalName());\n                result.append(' ');\n                result.append(tableAliasForJoinTable);\n\n                result.append(\" WHERE \");\n\n                appendColumnForAttributeToStringBuffer(sourceAttribute,result);\n                result.append('=');\n                result.append(e.sqlStringForAttributeNamed(firstHopRelationshipKeyPath));\n                \n                if(qualifier.elements() != null) {\n                    NSArray pKeys=ERXEOAccessUtilities.primaryKeysForObjects(qualifier.elements());\n                    result.append(\" AND \");\n                    \n                    result.append(tableAliasForJoinTable);\n                    result.append('.');\n                    result.append(secondHopSourceAttribute.columnName());\n                    \n                    result.append(\" IN (\"); \n                    EOAttribute pk = (EOAttribute)targetEntity.primaryKeyAttributes().lastObject();\n                    for(int i = 0; i < pKeys.count(); i++) {\n                        \n                        Object key = pKeys.objectAtIndex(i);\n                        String keyString = e.formatValueForAttribute(key, pk);\n                        result.append(keyString);\n                        if(i < pKeys.count()-1) {\n                            result.append(\",\");\n                        }\n                    }\n                    result.append(\") \");\n                }\n                result.append(\" GROUP BY \");\n                appendColumnForAttributeToStringBuffer(sourceAttribute,result);\n\n                result.append(\" HAVING COUNT(*)\");\n                if (qualifier.minCount() <= 0) {\n                    result.append(\"=\" + qualifier.elements().count());\n                } else {\n                    result.append(\">=\" + qualifier.minCount());                \n                }\n                result.append(\" )\");\n            } else {\n                throw new RuntimeException(\"not implemented!!\");\n            }\n            return result.toString();\n        }","commit_id":"9704be438835a8ef60bde0fa07e584ee06a38143","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <P>This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * <\/P> \n   */\n  public NSDictionary jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n//    try {\n//      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n//      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n//      fos.write(jdbcInfoS.getBytes());\n//      fos.close();\n//    }\n//    catch(Exception e) {\n//      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n//    }\n\n    NSDictionary jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if(shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n      \n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      }\n    }\n    else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","id":38836,"modified_method":"/**\n   * This is usually extracted from the the database using\n   * JDBC, but this is really inconvenient for users who are\n   * trying to generate SQL at some.  A specific version of the\n   * data has been written into the property list of the\n   * framework and this can be used as a hard-coded equivalent.\n   * \n   * @return jdbcInfo dictionary\n   */\n  @Override\n  public NSDictionary jdbcInfo() {\n    // you can swap this code out to write the property list out in order\n    // to get a fresh copy of the JDBCInfo.plist.\n//    try {\n//      String jdbcInfoS = NSPropertyListSerialization.stringFromPropertyList(super.jdbcInfo());\n//      FileOutputStream fos = new FileOutputStream(\"/tmp/JDBCInfo.plist\");\n//      fos.write(jdbcInfoS.getBytes());\n//      fos.close();\n//    }\n//    catch(Exception e) {\n//      throw new IllegalStateException(\"problem writing JDBCInfo.plist\",e);\n//    }\n\n    NSDictionary jdbcInfo;\n    // have a look at the JDBC connection URL to see if the flag has been set to\n    // specify that the hard-coded jdbcInfo information should be used.\n    if(shouldUseBundledJdbcInfo()) {\n      if(NSLog.debugLoggingAllowedForLevel(NSLog.DebugLevelDetailed)) {\n        NSLog.debug.appendln(\"Loading jdbcInfo from JDBCInfo.plist as opposed to using the JDBCPlugIn default implementation.\");\n      }\n      \n      InputStream jdbcInfoStream = NSBundle.bundleForClass(getClass()).inputStreamForResourcePath(\"JDBCInfo.plist\");\n      if (jdbcInfoStream == null) {\n        throw new IllegalStateException(\"Unable to find 'JDBCInfo.plist' in this plugin jar.\");\n      }\n\n      try {\n        jdbcInfo = (NSDictionary) NSPropertyListSerialization.propertyListFromData(new NSData(jdbcInfoStream, 2048), \"US-ASCII\");\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Failed to load 'JDBCInfo.plist' from this plugin jar.\", e);\n      }\n    }\n    else {\n      jdbcInfo = super.jdbcInfo();\n    }\n    return jdbcInfo;\n  }","commit_id":"02164256bd062897b2d360797e253b22ea41dba8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <P>WebObjects 5.4's version of JDBCAdaptor will use this\n   * in order to assemble the name of the prototype to use when\n   * it loads models.<\/P>\n   * @return the name of the plugin.\n   */\n  public String name() {\n    return \"Postgresql\";\n  }","id":38837,"modified_method":"/**\n   * WebObjects 5.4's version of JDBCAdaptor will use this\n   * in order to assemble the name of the prototype to use when\n   * it loads models.\n   * \n   * @return the name of the plugin\n   */\n  @Override\n  public String name() {\n    return \"Postgresql\";\n  }","commit_id":"02164256bd062897b2d360797e253b22ea41dba8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Checks whether primary key generation can be supported for <code>entity<\/code>\n   *\n   * @param entity    the entity to be checked\n   * @return  yes/no\n   */\n  private boolean isPrimaryKeyGenerationNotSupported(EOEntity entity) {\n    return entity.primaryKeyAttributes().count() > 1 || ((EOAttribute) entity.primaryKeyAttributes().lastObject()).adaptorValueType() != EOAttribute.AdaptorNumberType;\n  }","id":38838,"modified_method":"/**\n   * Checks whether primary key generation can be supported for <code>entity<\/code>\n   *\n   * @param entity    the entity to be checked\n   * @return  yes/no\n   */\n  private boolean isPrimaryKeyGenerationNotSupported(EOEntity entity) {\n    return entity.primaryKeyAttributes().count() > 1 || entity.primaryKeyAttributes().lastObject().adaptorValueType() != EOAttribute.AdaptorNumberType;\n  }","commit_id":"02164256bd062897b2d360797e253b22ea41dba8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Name of the database.\n   */\n  public String databaseProductName() {\n    return \"Postgresql\";\n  }","id":38839,"modified_method":"@Override\n  public String databaseProductName() {\n    return \"Postgresql\";\n  }","commit_id":"02164256bd062897b2d360797e253b22ea41dba8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Name of the driver.\n   */\n  public String defaultDriverName() {\n    return \"org.postgresql.Driver\";\n  }","id":38840,"modified_method":"@Override\n  public String defaultDriverName() {\n    return \"org.postgresql.Driver\";\n  }","commit_id":"02164256bd062897b2d360797e253b22ea41dba8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique  primary key value\n   */\n  public NSArray newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n    \n    EOAttribute attribute = (EOAttribute) entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray results = new NSMutableArray(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n    \n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuffer sql = new StringBuffer();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary row;\n            while ((row = channel.fetchRow()) != null) {\n              Enumeration pksEnum = row.allValues().objectEnumerator();\n              while (pksEnum.hasMoreElements()) {\n                Number pkObj = (Number)pksEnum.nextElement();\n                Number pk;\n                if (isIntType) {\n                  pk = Integer.valueOf(pkObj.intValue());\n                }\n                else {\n                  pk = Long.valueOf(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray(entity));\n            int stmCount = statements.count();\n            for (int i = 0; i < stmCount; i++) {\n              channel.evaluateExpression((EOSQLExpression) statements.objectAtIndex(i));\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n    \n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n    \n    return results;\n  }","id":38841,"modified_method":"/** \n   * Overrides the parent implementation to provide a more efficient mechanism for generating primary keys,\n   * while generating the primary key support on the fly.\n   *\n   * @param count the batch size\n   * @param entity the entity requesting primary keys\n   * @param channel open JDBCChannel\n   * @return NSArray of NSDictionary where each dictionary corresponds to a unique primary key value\n   */\n  @Override\n  public NSArray<NSDictionary<String, Object>> newPrimaryKeys(int count, EOEntity entity, JDBCChannel channel) {\n    if (isPrimaryKeyGenerationNotSupported(entity)) {\n      return null;\n    }\n    \n    EOAttribute attribute = entity.primaryKeyAttributes().lastObject();\n    String attrName = attribute.name();\n    boolean isIntType = \"i\".equals(attribute.valueType());\n\n    NSMutableArray<NSDictionary<String, Object>> results = new NSMutableArray<NSDictionary<String, Object>>(count);\n    String sequenceName = _sequenceNameForEntity(entity);\n    PostgresqlExpression expression = new PostgresqlExpression(entity);\n    \n    // MS: The original implementation of this did something like select setval('seq', nextval('seq') + count)\n    // which apparently is not an atomic operation, which causes terrible problems under load with multiple\n    // instances.  The new implementation does batch requests for keys.\n    int keysPerBatch = 20;\n    boolean succeeded = false;\n    for (int tries = 0; !succeeded && tries < 2; tries++) {\n      while (results.count() < count) {\n        try {\n          StringBuilder sql = new StringBuilder();\n          sql.append(\"SELECT \");\n          for (int keyBatchNum = Math.min(keysPerBatch, count - results.count()) - 1; keyBatchNum >= 0; keyBatchNum --) {\n            sql.append(\"NEXTVAL('\" + sequenceName + \"') AS KEY\" + keyBatchNum);\n            if (keyBatchNum > 0) {\n              sql.append(\", \");\n            }\n          }\n          expression.setStatement(sql.toString());\n          channel.evaluateExpression(expression);\n          try {\n            NSDictionary row;\n            while ((row = channel.fetchRow()) != null) {\n              Enumeration pksEnum = row.allValues().objectEnumerator();\n              while (pksEnum.hasMoreElements()) {\n                Number pkObj = (Number)pksEnum.nextElement();\n                Number pk;\n                if (isIntType) {\n                  pk = Integer.valueOf(pkObj.intValue());\n                }\n                else {\n                  pk = Long.valueOf(pkObj.longValue());\n                }\n                results.addObject(new NSDictionary<String, Object>(pk, attrName));\n              }            \n            }\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          succeeded = true;\n        }\n        catch (JDBCAdaptorException ex) {\n          //timc 2006-11-06 Check if sequence name contains schema name\n          int dotIndex = sequenceName.indexOf(\".\");\n          if (dotIndex == -1) {\n            expression.setStatement(\"select count(*) from pg_class where relname = '\" + sequenceName.toLowerCase() + \"' and relkind = 'S'\");\n          }\n          else {\n            String schemaName = sequenceName.substring(0, dotIndex);\n            String sequenceNameOnly = sequenceName.toLowerCase().substring(dotIndex + 1);\n            expression.setStatement(\"select count(c.*) from pg_catalog.pg_class c, pg_catalog.pg_namespace n where c.relnamespace=n.oid AND c.relkind = 'S' AND c.relname='\" + sequenceNameOnly + \"' AND n.nspname='\" + schemaName + \"'\");\n          }\n          channel.evaluateExpression(expression);\n          NSDictionary<String, Object> row;\n          try {\n            row = channel.fetchRow();\n          }\n          finally {\n            channel.cancelFetch();\n          }\n          // timc 2006-11-06 row.objectForKey(\"COUNT\") returns BigDecimal not Long\n          //if( new Long( 0 ).equals( row.objectForKey( \"COUNT\" ) ) ) {\n          Number numCount = (Number) row.objectForKey(\"COUNT\");\n          if (numCount != null && numCount.longValue() == 0L) {\n            EOSynchronizationFactory f = createSynchronizationFactory();\n            NSArray<EOSQLExpression> statements = f.primaryKeySupportStatementsForEntityGroup(new NSArray<EOEntity>(entity));\n            int stmCount = statements.count();\n            for (int i = 0; i < stmCount; i++) {\n              channel.evaluateExpression(statements.objectAtIndex(i));\n            }\n          }\n          else if (numCount == null) {\n            throw new IllegalStateException(\"Couldn't call sequence \" + sequenceName + \" and couldn't get sequence information from pg_class: \" + ex);\n          }\n          else {\n            throw new IllegalStateException(\"Caught exception, but sequence did already exist: \" + ex);\n          }\n        }\n      }\n    }\n    \n    if (results.count() != count) {\n      throw new IllegalStateException(\"Unable to generate primary keys from the sequence for \" + entity + \".\");\n    }\n    \n    return results;\n  }","commit_id":"02164256bd062897b2d360797e253b22ea41dba8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * <P>This method returns true if the connection URL for the\n   * database has a special flag on it which indicates to the\n   * system that the jdbcInfo which has been bundled into the\n   * plugin is acceptable to use in place of actually going to\n   * the database and getting it.\n   */\n  protected boolean shouldUseBundledJdbcInfo() {\n    boolean shouldUseBundledJdbcInfo = false;\n    String url = connectionURL();\n    if (url != null) {\n      shouldUseBundledJdbcInfo = url.toLowerCase().matches(\".*(\\\\?|\\\\?.*&)\" + PostgresqlPlugIn.QUERY_STRING_USE_BUNDLED_JDBC_INFO.toLowerCase() + \"=(true|yes)(\\\\&|$)\");\n    }\n    return shouldUseBundledJdbcInfo;\n  }","id":38842,"modified_method":"/**\n   * This method returns <code>true<\/code> if the connection URL for the\n   * database has a special flag on it which indicates to the\n   * system that the jdbcInfo which has been bundled into the\n   * plugin is acceptable to use in place of actually going to\n   * the database and getting it.\n   * \n   * @return <code>true<\/code> if bundled jdbcInfo should be used\n   */\n  protected boolean shouldUseBundledJdbcInfo() {\n    boolean shouldUseBundledJdbcInfo = false;\n    String url = connectionURL();\n    if (url != null) {\n      shouldUseBundledJdbcInfo = url.toLowerCase().matches(\".*(\\\\?|\\\\?.*&)\" + PostgresqlPlugIn.QUERY_STRING_USE_BUNDLED_JDBC_INFO.toLowerCase() + \"=(true|yes)(\\\\&|$)\");\n    }\n    return shouldUseBundledJdbcInfo;\n  }","commit_id":"02164256bd062897b2d360797e253b22ea41dba8","url":"https://github.com/wocommunity/wonder"},{"original_method":"@NonNullByDefault\n\tprotected LightweightTypeReference computeForLoopParameterType(final XForLoopExpression object,\n\t\t\tfinal ITypeComputationState state) {\n\t\tJvmFormalParameter declaredParam = object.getDeclaredParam();\n\t\tLightweightTypeReference parameterType = null;\n\t\tif (declaredParam.getParameterType() != null) {\n\t\t\tparameterType = state.getConverter().toLightweightReference(declaredParam.getParameterType());\n\t\t\tLightweightTypeReference iterableOrArray = null;\n\t\t\tif (parameterType.isPrimitive()) {\n\t\t\t\titerableOrArray = new ArrayTypeReference(state.getReferenceOwner(), parameterType);\n\t\t\t} else {\n\t\t\t\tParameterizedTypeReference reference = new ParameterizedTypeReference(state.getReferenceOwner(), services.getTypeReferences().findDeclaredType(Iterable.class, object));\n\t\t\t\tWildcardTypeReference wildcard = new WildcardTypeReference(state.getReferenceOwner());\n\t\t\t\twildcard.addUpperBound(parameterType);\n\t\t\t\treference.addTypeArgument(wildcard);\n\t\t\t\titerableOrArray = reference;\n\t\t\t}\n\t\t\tfinal CompoundTypeReference withSynonyms = new CompoundTypeReference(iterableOrArray.getOwner(), true);\n\t\t\twithSynonyms.addComponent(iterableOrArray);\n\t\t\tservices.getSynonymTypesProvider().collectSynonymTypes(iterableOrArray, new SynonymTypesProvider.Acceptor() {\n\t\t\t\t@Override\n\t\t\t\tprotected boolean accept(LightweightTypeReference synonym, Set<ConformanceHint> hints) {\n\t\t\t\t\tif (synonym.isType(List.class)) {\n\t\t\t\t\t\tList<LightweightTypeReference> superTypes = synonym.getAllSuperTypes();\n\t\t\t\t\t\tfor(LightweightTypeReference superType: superTypes) {\n\t\t\t\t\t\t\tif (superType.isType(Iterable.class)) {\n\t\t\t\t\t\t\t\tif (superType.getTypeArguments().size() == 1) {\n\t\t\t\t\t\t\t\t\tLightweightTypeReference argument = superType.getTypeArguments().get(0);\n\t\t\t\t\t\t\t\t\tif (argument.isWildcard()) {\n\t\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(superType);\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tJvmType rawSuperType = superType.getType();\n\t\t\t\t\t\t\t\t\t\tif (rawSuperType == null) {\n\t\t\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(superType);\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tParameterizedTypeReference parameterized = new ParameterizedTypeReference(superType.getOwner(), rawSuperType);\n\t\t\t\t\t\t\t\t\t\tWildcardTypeReference wildcard = new WildcardTypeReference(superType.getOwner());\n\t\t\t\t\t\t\t\t\t\twildcard.addUpperBound(argument);\n\t\t\t\t\t\t\t\t\t\tparameterized.addTypeArgument(wildcard);\n\t\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(parameterized);\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(superType);\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twithSynonyms.addComponent(synonym);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tITypeComputationState iterableState = state.withExpectation(withSynonyms);\n\t\t\tITypeComputationResult forExpressionResult = iterableState.computeTypes(object.getForExpression());\n\t\t\tLightweightTypeReference forExpressionType = forExpressionResult.getActualExpressionType();\n\t\t\tif (forExpressionType.isAny()) {\n\t\t\t\titerableState.refineExpectedType(object.getForExpression(), iterableOrArray);\n\t\t\t} else if (forExpressionType.isResolved() && iterableOrArray.isAssignableFrom(forExpressionType)) {\n\t\t\t\titerableState.refineExpectedType(object.getForExpression(), forExpressionType);\n\t\t\t}\n\t\t} else {\n\t\t\tWildcardTypeReference wildcard = new WildcardTypeReference(state.getReferenceOwner());\n\t\t\twildcard.addUpperBound(getTypeForName(Object.class, state));\n\t\t\tParameterizedTypeReference iterable = new ParameterizedTypeReference(state.getReferenceOwner(), services.getTypeReferences().findDeclaredType(Iterable.class, object));\n\t\t\titerable.addTypeArgument(wildcard);\n\t\t\t// TODO do we have to add synonyms, too?\n\t\t\tITypeComputationState iterableState = state.withExpectation(iterable); \n\t\t\tITypeComputationResult forExpressionResult = iterableState.computeTypes(object.getForExpression());\n\t\t\tLightweightTypeReference forExpressionType = forExpressionResult.getActualExpressionType();\n\t\t\tif (forExpressionType.isResolved() && !forExpressionType.isAny() && iterable.isAssignableFrom(forExpressionType)) {\n\t\t\t\titerableState.refineExpectedType(object.getForExpression(), forExpressionType);\n\t\t\t}\n\t\t\tparameterType = forExpressionType.accept(new TypeReferenceVisitorWithResult<LightweightTypeReference>() {\n\t\t\t\t@Override\n\t\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(ParameterizedTypeReference reference) {\n\t\t\t\t\tDeclaratorTypeArgumentCollector typeArgumentCollector = new ConstraintAwareTypeArgumentCollector(state.getReferenceOwner());\n\t\t\t\t\tMap<JvmTypeParameter, LightweightMergedBoundTypeArgument> typeParameterMapping = typeArgumentCollector.getTypeParameterMapping(reference);\n\t\t\t\t\tTypeParameterSubstitutor<?> substitutor = new TypeParameterByConstraintSubstitutor(typeParameterMapping, state.getReferenceOwner());\n\t\t\t\t\tJvmGenericType iterable = (JvmGenericType) services.getTypeReferences().findDeclaredType(Iterable.class, object);\n\t\t\t\t\tParameterizedTypeReference substituteMe = new ParameterizedTypeReference(state.getReferenceOwner(), iterable.getTypeParameters().get(0));\n\t\t\t\t\tLightweightTypeReference substitutedArgument = substitutor.substitute(substituteMe);\n\t\t\t\t\treturn substitutedArgument;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tprotected LightweightTypeReference doVisitAnyTypeReference(AnyTypeReference reference) {\n\t\t\t\t\treturn reference;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic LightweightTypeReference doVisitArrayTypeReference(ArrayTypeReference reference) {\n\t\t\t\t\treturn reference.getComponentType();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (parameterType == null) {\n\t\t\tthrow new IllegalStateException(\"Should not be possible\");\n\t\t}\n\t\treturn parameterType;\n\t}","id":38843,"modified_method":"@NonNullByDefault\n\tprotected LightweightTypeReference computeForLoopParameterType(final XForLoopExpression object,\n\t\t\tfinal ITypeComputationState state) {\n\t\tJvmFormalParameter declaredParam = object.getDeclaredParam();\n\t\tLightweightTypeReference parameterType = null;\n\t\tif (declaredParam.getParameterType() != null) {\n\t\t\tparameterType = state.getConverter().toLightweightReference(declaredParam.getParameterType());\n\t\t\tLightweightTypeReference iterableOrArray = null;\n\t\t\tif (parameterType.isPrimitive()) {\n\t\t\t\titerableOrArray = new ArrayTypeReference(state.getReferenceOwner(), parameterType);\n\t\t\t} else {\n\t\t\t\tParameterizedTypeReference reference = new ParameterizedTypeReference(state.getReferenceOwner(), services.getTypeReferences().findDeclaredType(Iterable.class, object));\n\t\t\t\tWildcardTypeReference wildcard = new WildcardTypeReference(state.getReferenceOwner());\n\t\t\t\twildcard.addUpperBound(parameterType);\n\t\t\t\treference.addTypeArgument(wildcard);\n\t\t\t\titerableOrArray = reference;\n\t\t\t}\n\t\t\tfinal CompoundTypeReference withSynonyms = new CompoundTypeReference(iterableOrArray.getOwner(), true);\n\t\t\twithSynonyms.addComponent(iterableOrArray);\n\t\t\tservices.getSynonymTypesProvider().collectSynonymTypes(iterableOrArray, new SynonymTypesProvider.Acceptor() {\n\t\t\t\t@Override\n\t\t\t\tprotected boolean accept(LightweightTypeReference synonym, Set<ConformanceHint> hints) {\n\t\t\t\t\tif (synonym.isType(List.class)) {\n\t\t\t\t\t\tList<LightweightTypeReference> superTypes = synonym.getAllSuperTypes();\n\t\t\t\t\t\tfor(LightweightTypeReference superType: superTypes) {\n\t\t\t\t\t\t\tif (superType.isType(Iterable.class)) {\n\t\t\t\t\t\t\t\tif (superType.getTypeArguments().size() == 1) {\n\t\t\t\t\t\t\t\t\tLightweightTypeReference argument = superType.getTypeArguments().get(0);\n\t\t\t\t\t\t\t\t\tif (argument.isWildcard()) {\n\t\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(superType);\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tJvmType rawSuperType = superType.getType();\n\t\t\t\t\t\t\t\t\t\tif (rawSuperType == null) {\n\t\t\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(superType);\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tParameterizedTypeReference parameterized = new ParameterizedTypeReference(superType.getOwner(), rawSuperType);\n\t\t\t\t\t\t\t\t\t\tWildcardTypeReference wildcard = new WildcardTypeReference(superType.getOwner());\n\t\t\t\t\t\t\t\t\t\twildcard.addUpperBound(argument);\n\t\t\t\t\t\t\t\t\t\tparameterized.addTypeArgument(wildcard);\n\t\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(parameterized);\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twithSynonyms.addComponent(superType);\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twithSynonyms.addComponent(synonym);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tITypeComputationState iterableState = state.withExpectation(withSynonyms);\n\t\t\tITypeComputationResult forExpressionResult = iterableState.computeTypes(object.getForExpression());\n\t\t\tLightweightTypeReference forExpressionType = forExpressionResult.getActualExpressionType();\n\t\t\tif (forExpressionType.isAny()) {\n\t\t\t\titerableState.refineExpectedType(object.getForExpression(), iterableOrArray);\n\t\t\t} else if (forExpressionType.isResolved()) {\n\t\t\t\tif (iterableOrArray.isAssignableFrom(forExpressionType))\n\t\t\t\t\titerableState.refineExpectedType(object.getForExpression(), forExpressionType);\n\t\t\t\telse {\n\t\t\t\t\tArrayTypeReference array = forExpressionType.tryConvertToArray();\n\t\t\t\t\tif (array != null) {\n\t\t\t\t\t\tif (parameterType.isAssignableFrom(array.getComponentType())) {\n\t\t\t\t\t\t\titerableState.refineExpectedType(object.getForExpression(), forExpressionType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tWildcardTypeReference wildcard = new WildcardTypeReference(state.getReferenceOwner());\n\t\t\twildcard.addUpperBound(getTypeForName(Object.class, state));\n\t\t\tParameterizedTypeReference iterable = new ParameterizedTypeReference(state.getReferenceOwner(), services.getTypeReferences().findDeclaredType(Iterable.class, object));\n\t\t\titerable.addTypeArgument(wildcard);\n\t\t\t// TODO do we have to add synonyms, too?\n\t\t\tITypeComputationState iterableState = state.withExpectation(iterable); \n\t\t\tITypeComputationResult forExpressionResult = iterableState.computeTypes(object.getForExpression());\n\t\t\tLightweightTypeReference forExpressionType = forExpressionResult.getActualExpressionType();\n\t\t\tif (forExpressionType.isResolved() && !forExpressionType.isAny() && iterable.isAssignableFrom(forExpressionType)) {\n\t\t\t\titerableState.refineExpectedType(object.getForExpression(), forExpressionType);\n\t\t\t}\n\t\t\tparameterType = forExpressionType.accept(new TypeReferenceVisitorWithResult<LightweightTypeReference>() {\n\t\t\t\t@Override\n\t\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(ParameterizedTypeReference reference) {\n\t\t\t\t\tDeclaratorTypeArgumentCollector typeArgumentCollector = new ConstraintAwareTypeArgumentCollector(state.getReferenceOwner());\n\t\t\t\t\tMap<JvmTypeParameter, LightweightMergedBoundTypeArgument> typeParameterMapping = typeArgumentCollector.getTypeParameterMapping(reference);\n\t\t\t\t\tTypeParameterSubstitutor<?> substitutor = new TypeParameterByConstraintSubstitutor(typeParameterMapping, state.getReferenceOwner());\n\t\t\t\t\tJvmGenericType iterable = (JvmGenericType) services.getTypeReferences().findDeclaredType(Iterable.class, object);\n\t\t\t\t\tParameterizedTypeReference substituteMe = new ParameterizedTypeReference(state.getReferenceOwner(), iterable.getTypeParameters().get(0));\n\t\t\t\t\tLightweightTypeReference substitutedArgument = substitutor.substitute(substituteMe);\n\t\t\t\t\treturn substitutedArgument;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tprotected LightweightTypeReference doVisitAnyTypeReference(AnyTypeReference reference) {\n\t\t\t\t\treturn reference;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic LightweightTypeReference doVisitArrayTypeReference(ArrayTypeReference reference) {\n\t\t\t\t\treturn reference.getComponentType();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (parameterType == null) {\n\t\t\tthrow new IllegalStateException(\"Should not be possible\");\n\t\t}\n\t\treturn parameterType;\n\t}","commit_id":"72dcca34b7b6528494ecbe3d0e87f09eb4695195","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n        public void start(StartContext context) throws StartException {\n            XBundle bundle = injectedBundle.getValue();\n            Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n            if (bundle != null && deployment.isAutoStart() && bundle.isResolved()) {\n                Component activatorComponent = injectedComponent.getOptionalValue();\n                if (activatorComponent != null) {\n                    ComponentInstance componentInstance = activatorComponent.createInstance();\n                    BundleActivator instance = (BundleActivator) componentInstance.getInstance();\n                    deployment.addAttachment(BundleActivator.class, instance);\n                }\n                try {\n                    bundle.start(Bundle.START_ACTIVATION_POLICY);\n                    depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.ACTIVE);\n                } catch (BundleException ex) {\n                    throw MESSAGES.cannotStartBundle(ex, bundle);\n                }\n            }\n        }","id":38844,"modified_method":"@Override\n        public void start(StartContext context) throws StartException {\n            XBundle bundle = injectedBundle.getValue();\n            Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n            Component activatorComponent = injectedComponent.getOptionalValue();\n            if (activatorComponent != null && deployment.getAttachment(BundleActivator.class) == null) {\n                ComponentInstance componentInstance = activatorComponent.createInstance();\n                BundleActivator instance = (BundleActivator) componentInstance.getInstance();\n                deployment.addAttachment(BundleActivator.class, instance);\n            }\n            OperationAssociation.INSTANCE.setAssociation(new ModelNode(\"deploy\"));\n            try {\n                bundle.start(Bundle.START_ACTIVATION_POLICY);\n                depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.ACTIVE);\n            } catch (BundleException ex) {\n                throw MESSAGES.cannotStartBundle(ex, bundle);\n            } finally {\n                OperationAssociation.INSTANCE.removeAssociation();\n            }\n        }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.BUNDLE_KEY);\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        if (bundle != null && deployment.isAutoStart() && bundle.isResolved()) {\n            ServiceName serviceName = BundleActivateService.addService(phaseContext.getServiceTarget(), depUnit, bundle).getName();\n            depUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, serviceName);\n            depUnit.putAttachment(BUNDLE_ACTIVATE_SERVICE, serviceName);\n        }\n    }","id":38845,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.BUNDLE_KEY);\n        if (bundle == null || bundle.isFragment() || !bundle.isResolved())\n            return;\n\n        ServiceController<XBundle> controller = BundleActivateService.addService(phaseContext.getServiceTarget(), depUnit, bundle);\n        phaseContext.addDependency(controller.getName(), AttachmentKey.create(XBundle.class));\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void stop(StopContext context) {\n            XBundle bundle = injectedBundle.getValue();\n            Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n            if (deployment.isAutoStart()) {\n                try {\n                    // Server shutdown should not modify the persistent start setting\n                    bundle.stop(Bundle.STOP_TRANSIENT);\n                    depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n                } catch (BundleException ex) {\n                    LOGGER.debugf(ex, \"Cannot stop bundle: %s\", bundle);\n                }\n            }\n        }","id":38846,"modified_method":"@Override\n        public void stop(StopContext context) {\n            XBundle bundle = injectedBundle.getValue();\n            try {\n                // Server shutdown should not modify the persistent start setting\n                bundle.stop(Bundle.STOP_TRANSIENT);\n                depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n            } catch (BundleException ex) {\n                LOGGER.debugf(ex, \"Cannot stop bundle: %s\", bundle);\n            }\n        }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n        ServiceName serviceName = depUnit.getAttachment(BUNDLE_ACTIVATE_SERVICE);\n        ServiceController<?> controller = serviceName != null ? depUnit.getServiceRegistry().getService(serviceName) : null;\n        if (controller != null) {\n            controller.setMode(Mode.REMOVE);\n            depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n        }\n    }","id":38847,"modified_method":"@Override\n    public void undeploy(final DeploymentUnit depUnit) {\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        final String contextName = depUnit.getName();\n\n        // Check if {@link BundleInstallIntegration} provided the {@link Deployment}\n        Deployment deployment = BundleInstallIntegration.removeDeployment(contextName);\n        if (deployment != null) {\n            deployment.setAutoStart(false);\n        }\n\n        // Check for attached BundleInfo\n        BundleInfo info = depUnit.getAttachment(OSGiConstants.BUNDLE_INFO_KEY);\n        if (deployment == null && info != null) {\n            deployment = DeploymentFactory.createDeployment(info);\n            deployment.addAttachment(BundleInfo.class, info);\n            OSGiMetaData metadata = info.getOSGiMetadata();\n            deployment.setAutoStart(!metadata.isFragment());\n\n            // Set the start level and prevent autostart if greater than the Framw\n            AnnotationInstance slAware = getAnnotation(depUnit, \"org.jboss.arquillian.osgi.StartLevelAware\");\n            if (slAware != null) {\n                int startLevel = slAware.value(\"startLevel\").asInt();\n                deployment.setStartLevel(startLevel);\n                deployment.setAutoStart(false);\n            }\n\n            // Prevent autostart for marked deployments\n            AnnotationInstance marker = getAnnotation(depUnit, \"org.jboss.as.arquillian.api.DeploymentMarker\");\n            if (marker != null && !marker.value(\"autoStart\").asBoolean()) {\n                deployment.setAutoStart(false);\n            }\n        }\n\n        // Attach the deployment\n        if (deployment != null) {\n\n            // Make sure the framework uses the same module id as the server\n            ModuleIdentifier identifier = depUnit.getAttachment(Attachments.MODULE_IDENTIFIER);\n            deployment.addAttachment(ModuleIdentifier.class, identifier);\n\n            // Allow additional dependencies for the set of supported deployemnt types\n            if (allowAdditionalModuleDependencies(depUnit)) {\n                ModuleSpecification moduleSpec = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n                deployment.addAttachment(ModuleSpecification.class, moduleSpec);\n            } else {\n                // Make this module private so that other modules in the deployment don't create a direct dependency\n                ModuleSpecification moduleSpec = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n                moduleSpec.setPrivateModule(true);\n            }\n\n            // Attach the bundle deployment\n            depUnit.putAttachment(OSGiConstants.DEPLOYMENT_KEY, deployment);\n        }\n    }","id":38848,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        final String contextName = depUnit.getName();\n\n        // Check if {@link BundleInstallIntegration} provided the {@link Deployment}\n        Deployment deployment = BundleLifecycleIntegration.removeDeployment(contextName);\n        if (deployment != null) {\n            deployment.setAutoStart(false);\n        }\n\n        // Check for attached BundleInfo\n        BundleInfo info = depUnit.getAttachment(OSGiConstants.BUNDLE_INFO_KEY);\n        if (deployment == null && info != null) {\n            deployment = DeploymentFactory.createDeployment(info);\n            deployment.addAttachment(BundleInfo.class, info);\n            OSGiMetaData metadata = info.getOSGiMetadata();\n            deployment.setAutoStart(!metadata.isFragment());\n\n            // Set the start level and prevent autostart if greater than the Framwork startlevel\n            AnnotationInstance slAware = getAnnotation(depUnit, \"org.jboss.arquillian.osgi.StartLevelAware\");\n            if (slAware != null) {\n                MethodInfo slTarget = (MethodInfo) slAware.target();\n                for (AnnotationInstance anDeployment : getAnnotations(depUnit, \"org.jboss.arquillian.container.test.api.Deployment\")) {\n                    AnnotationValue namevalue = anDeployment.value(\"name\");\n                    Object deploymentName = namevalue != null ? namevalue.value() : null;\n                    if (slTarget == anDeployment.target() && depUnit.getName().equals(deploymentName)) {\n                        int startLevel = slAware.value(\"startLevel\").asInt();\n                        deployment.setStartLevel(startLevel);\n                        deployment.setAutoStart(false);\n                    }\n                }\n            }\n\n            // Prevent autostart for marked deployments\n            AnnotationInstance marker = getAnnotation(depUnit, \"org.jboss.as.arquillian.api.DeploymentMarker\");\n            if (marker != null) {\n                AnnotationValue value = marker.value(\"autoStart\");\n                if (value != null && deployment.isAutoStart()) {\n                    deployment.setAutoStart(value.asBoolean());\n                }\n                value = marker.value(\"startLevel\");\n                if (value != null && deployment.getStartLevel() == null) {\n                    deployment.setStartLevel(value.asInt());\n                }\n            }\n        }\n\n        // Attach the deployment\n        if (deployment != null) {\n\n            // Make sure the framework uses the same module id as the server\n            ModuleIdentifier identifier = depUnit.getAttachment(Attachments.MODULE_IDENTIFIER);\n            deployment.addAttachment(ModuleIdentifier.class, identifier);\n\n            // Allow additional dependencies for the set of supported deployemnt types\n            if (allowAdditionalModuleDependencies(depUnit)) {\n                ModuleSpecification moduleSpec = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n                deployment.addAttachment(ModuleSpecification.class, moduleSpec);\n            } else {\n                // Make this module private so that other modules in the deployment don't create a direct dependency\n                ModuleSpecification moduleSpec = depUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n                moduleSpec.setPrivateModule(true);\n            }\n\n            // Attach the bundle deployment\n            depUnit.putAttachment(OSGiConstants.DEPLOYMENT_KEY, deployment);\n            deployment.addAttachment(DeploymentUnit.class, depUnit);\n        }\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"private AnnotationInstance getAnnotation(DeploymentUnit depUnit, String className) {\n        CompositeIndex index = depUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n        List<AnnotationInstance> annotations = index.getAnnotations(DotName.createSimple(className));\n        return annotations.size() == 1 ? annotations.get(0) : null;\n    }","id":38849,"modified_method":"private AnnotationInstance getAnnotation(DeploymentUnit depUnit, String className) {\n        List<AnnotationInstance> annotations = getAnnotations(depUnit, className);\n        return annotations.size() == 1 ? annotations.get(0) : null;\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.BUNDLE_KEY);\n        if (bundle == null || !deployment.isAutoStart())\n            return;\n\n        // Only process the top level deployment\n        if (depUnit.getParent() != null)\n            return;\n\n        resolveBundle(phaseContext, bundle);\n    }","id":38850,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Deployment deployment = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_KEY);\n        XBundle bundle = depUnit.getAttachment(OSGiConstants.BUNDLE_KEY);\n        if (bundle == null || !deployment.isAutoStart())\n            return;\n\n        resolveBundle(phaseContext, depUnit, bundle);\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void resolveBundle(DeploymentPhaseContext phaseContext, XBundle bundle) {\n        XBundleRevision brev = bundle.getBundleRevision();\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        XEnvironment env = depUnit.getAttachment(OSGiConstants.ENVIRONMENT_KEY);\n        XResolver resolver = depUnit.getAttachment(OSGiConstants.RESOLVER_KEY);\n        BundleManager bundleManager = depUnit.getAttachment(OSGiConstants.BUNDLE_MANAGER_KEY);\n        XResolveContext context = resolver.createResolveContext(env, Collections.singleton(brev), null);\n        try {\n            LOGGER.debugf(\"Resolve: %s\", depUnit.getName());\n            resolver.resolveAndApply(context);\n            depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n\n            // Add a dependency on the Bundle RESOLVED service\n            ServiceName bundleResolve = bundleManager.getServiceName(bundle, Bundle.RESOLVED);\n            phaseContext.addDeploymentDependency(bundleResolve, AttachmentKey.create(Object.class));\n\n            // Add a dependency on the Module service\n            ServiceName moduleService = ServiceModuleLoader.moduleServiceName(brev.getModuleIdentifier());\n            phaseContext.addDeploymentDependency(moduleService, Attachments.MODULE);\n        } catch (ResolutionException ex) {\n            LOGGER.warnCannotResolve(ex.getUnresolvedRequirements());\n        }\n    }","id":38851,"modified_method":"private void resolveBundle(DeploymentPhaseContext phaseContext, DeploymentUnit depUnit, XBundle bundle) {\n        XBundleRevision brev = bundle.getBundleRevision();\n        XEnvironment env = depUnit.getAttachment(OSGiConstants.ENVIRONMENT_KEY);\n        XResolver resolver = depUnit.getAttachment(OSGiConstants.RESOLVER_KEY);\n        XResolveContext context = resolver.createResolveContext(env, Collections.singleton(brev), null);\n        try {\n            LOGGER.debugf(\"Resolve: %s\", depUnit.getName());\n            resolver.resolveAndApply(context);\n            depUnit.putAttachment(Attachments.BUNDLE_STATE_KEY, BundleState.RESOLVED);\n\n            // Add a dependency on the Bundle RESOLVED service\n            BundleManager bundleManager = depUnit.getAttachment(OSGiConstants.BUNDLE_MANAGER_KEY);\n            ServiceName bundleResolve = bundleManager.getServiceName(bundle, Bundle.RESOLVED);\n            phaseContext.addDeploymentDependency(bundleResolve, AttachmentKey.create(Object.class));\n\n            // Add a dependency on the Module service\n            ServiceName moduleService = ServiceModuleLoader.moduleServiceName(brev.getModuleIdentifier());\n            phaseContext.addDeploymentDependency(moduleService, Attachments.MODULE);\n        } catch (ResolutionException ex) {\n            LOGGER.warnCannotResolve(ex.getUnresolvedRequirements());\n        }\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n        final String operationName = operation.require(ModelDescriptionConstants.OP).asString();\n        if (ModelDescriptionConstants.READ_ATTRIBUTE_OPERATION.equals(operationName)) {\n            handleReadAttributeOperation(context, operation);\n        } else {\n            handleOperation(operationName, context, operation);\n        }\n    }","id":38852,"modified_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n        final String operationName = operation.require(ModelDescriptionConstants.OP).asString();\n        if (ModelDescriptionConstants.READ_ATTRIBUTE_OPERATION.equals(operationName)) {\n            handleReadAttributeOperation(context, operation);\n        } else {\n            handleOperation(context, operationName, operation);\n        }\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void handleOperation(String operationName, OperationContext context, ModelNode operation) {\n        try {\n            if (ModelConstants.START.equals(operationName)) {\n                Bundle bundle = getTargetBundle(context, operation);\n                bundle.start();\n            } else if (ModelConstants.STOP.equals(operationName)) {\n                Bundle bundle = getTargetBundle(context, operation);\n                bundle.stop();\n            } else  {\n                throw new UnsupportedOperationException(operationName);\n            }\n        } catch (Exception ex) {\n            LOGGER.errorInOperationHandler(ex, operationName);\n            context.getFailureDescription().set(ex.getLocalizedMessage());\n        }\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","id":38853,"modified_method":"private void handleOperation(OperationContext context, String operationName, ModelNode operation) {\n        try {\n            if (ModelConstants.START.equals(operationName)) {\n                OperationAssociation.INSTANCE.setAssociation(operation);\n                try {\n                    Bundle bundle = getTargetBundle(context, operation);\n                    bundle.start();\n                } finally {\n                    OperationAssociation.INSTANCE.removeAssociation();\n                }\n            } else if (ModelConstants.STOP.equals(operationName)) {\n                Bundle bundle = getTargetBundle(context, operation);\n                bundle.stop();\n            } else  {\n                throw new UnsupportedOperationException(operationName);\n            }\n        } catch (Exception ex) {\n            LOGGER.errorInOperationHandler(ex, operationName);\n            context.getFailureDescription().set(ex.getLocalizedMessage());\n        }\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        ServiceController<?> controller = context.getController();\n        LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            SubsystemState subsystemState = injectedSubsystemState.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Register the URLStreamHandlerFactory\n            Module coreFrameworkModule = ((ModuleClassLoader) FrameworkBuilder.class.getClassLoader()).getModule();\n            Module.registerURLStreamHandlerFactoryModule(coreFrameworkModule);\n            Module.registerContentHandlerFactoryModule(coreFrameworkModule);\n\n            ServiceTarget serviceTarget = context.getChildTarget();\n            JAXPServiceProvider.addService(serviceTarget);\n            ResolverService.addService(serviceTarget);\n            RepositoryService.addService(serviceTarget);\n\n            // Configure the {@link Framework} builder\n            FrameworkBuilder builder = new FrameworkBuilder(props);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(serviceTarget);\n\n            // Install the integration services\n            builder.installIntegrationService(serviceContainer, serviceTarget, new BundleInstallIntegration());\n            builder.installIntegrationService(serviceContainer, serviceTarget, new FrameworkModuleIntegration(props));\n            builder.installIntegrationService(serviceContainer, serviceTarget, new ModuleLoaderIntegration());\n            builder.installIntegrationService(serviceContainer, serviceTarget, new SystemServicesIntegration(resource, extensions));\n\n            Activation activation = subsystemState.getActivationPolicy();\n            if (activation == Activation.EAGER) {\n                // Install the bootstrap bundle services\n                builder.installIntegrationService(serviceContainer, serviceTarget, new BootstrapBundlesIntegration());\n                builder.installIntegrationService(serviceContainer, serviceTarget, new PersistentBundlesIntegration());\n                builder.setInitialMode(Mode.ACTIVE);\n            } else {\n                // Exclude the bootstrap bundle services - see {@link FrameworkActivator}\n                builder.addExcludedService(IntegrationService.BOOTSTRAP_BUNDLES_INSTALL);\n                builder.addExcludedService(IntegrationService.PERSISTENT_BUNDLES_INSTALL);\n                builder.setInitialMode(Mode.LAZY);\n            }\n\n            // Create the {@link Framework} services\n            builder.createFrameworkServices(true);\n        } catch (Throwable th) {\n            throw MESSAGES.startFailedToCreateFrameworkServices(th);\n        }\n    }","id":38854,"modified_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        ServiceController<?> controller = context.getController();\n        LOGGER.tracef(\"Starting: %s in mode %s\", controller.getName(), controller.getMode());\n        try {\n            ServiceContainer serviceContainer = context.getController().getServiceContainer();\n\n            // Setup the OSGi {@link Framework} properties\n            SubsystemState subsystemState = injectedSubsystemState.getValue();\n            Map<String, Object> props = new HashMap<String, Object>(subsystemState.getProperties());\n            setupIntegrationProperties(context, props);\n\n            // Register the URLStreamHandlerFactory\n            Module coreFrameworkModule = ((ModuleClassLoader) FrameworkBuilder.class.getClassLoader()).getModule();\n            Module.registerURLStreamHandlerFactoryModule(coreFrameworkModule);\n            Module.registerContentHandlerFactoryModule(coreFrameworkModule);\n\n            ServiceTarget serviceTarget = context.getChildTarget();\n            JAXPServiceProvider.addService(serviceTarget);\n            ResolverService.addService(serviceTarget);\n            RepositoryService.addService(serviceTarget);\n\n            // Configure the {@link Framework} builder\n            FrameworkBuilder builder = new FrameworkBuilder(props);\n            builder.setServiceContainer(serviceContainer);\n            builder.setServiceTarget(serviceTarget);\n\n            // Install the integration services\n            builder.installIntegrationService(serviceContainer, serviceTarget, new BundleLifecycleIntegration());\n            builder.installIntegrationService(serviceContainer, serviceTarget, new FrameworkModuleIntegration(props));\n            builder.installIntegrationService(serviceContainer, serviceTarget, new ModuleLoaderIntegration());\n            builder.installIntegrationService(serviceContainer, serviceTarget, new SystemServicesIntegration(resource, extensions));\n\n            Activation activation = subsystemState.getActivationPolicy();\n            if (activation == Activation.EAGER) {\n                // Install the bootstrap bundle services\n                builder.installIntegrationService(serviceContainer, serviceTarget, new BootstrapBundlesIntegration());\n                builder.installIntegrationService(serviceContainer, serviceTarget, new PersistentBundlesIntegration());\n                builder.setInitialMode(Mode.ACTIVE);\n            } else {\n                // Exclude the bootstrap bundle services - see {@link FrameworkActivator}\n                builder.addExcludedService(IntegrationService.BOOTSTRAP_BUNDLES_INSTALL);\n                builder.addExcludedService(IntegrationService.PERSISTENT_BUNDLES_INSTALL);\n                builder.setInitialMode(Mode.LAZY);\n            }\n\n            // Create the {@link Framework} services\n            builder.createFrameworkServices(true);\n        } catch (Throwable th) {\n            throw MESSAGES.startFailedToCreateFrameworkServices(th);\n        }\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        final String contextName = depUnit.getName();\n\n        // Check if we already have a bundle {@link Deployment}\n        if (BundleInstallIntegration.getDeployment(contextName) != null)\n            return;\n\n        // Get the manifest from the deployment's virtual file\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        if (metadata != null) {\n            try {\n                // Construct and attach the {@link BundleInfo} from {@link OSGiMetaData}\n                VirtualFile virtualFile = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n                BundleInfo info = BundleInfo.createBundleInfo(AbstractVFS.adapt(virtualFile), contextName, metadata);\n                depUnit.putAttachment(OSGiConstants.BUNDLE_INFO_KEY, info);\n            } catch (BundleException ex) {\n                throw MESSAGES.cannotCreateBundleDeployment(ex, depUnit);\n            }\n        }\n    }","id":38855,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        final String contextName = depUnit.getName();\n\n        // Check if we already have a bundle {@link Deployment}\n        if (BundleLifecycleIntegration.getDeployment(contextName) != null)\n            return;\n\n        // Get the manifest from the deployment's virtual file\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        if (metadata != null) {\n            try {\n                // Construct and attach the {@link BundleInfo} from {@link OSGiMetaData}\n                VirtualFile virtualFile = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n                BundleInfo info = BundleInfo.createBundleInfo(AbstractVFS.adapt(virtualFile), contextName, metadata);\n                depUnit.putAttachment(OSGiConstants.BUNDLE_INFO_KEY, info);\n            } catch (BundleException ex) {\n                throw MESSAGES.cannotCreateBundleDeployment(ex, depUnit);\n            }\n        }\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final Activation activation = getActivationMode(operation);\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, verificationHandler);\n        final ModuleRegistrationTracker registrationTracker = new ModuleRegistrationTracker();\n\n        // Collect the subsystem extensions\n        final List<SubsystemExtension> extensions = new ArrayList<SubsystemExtension>();\n        final Iterator<SubsystemExtension> services = ServiceLoader.load(SubsystemExtension.class, getClass().getClassLoader()).iterator();\n        while(services.hasNext()) {\n            extensions.add(services.next());\n        }\n\n        // Create the framework activator\n        FrameworkActivator.create(serviceTarget, activation == Activation.LAZY);\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, extensions, verificationHandler));\n                newControllers.add(registrationTracker.install(serviceTarget, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_COMPONENTS, new OSGiComponentParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new FrameworkActivateProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_SUB_BUNDLE, new BundleResolveSubProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor(registrationTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        for(SubsystemExtension extension : extensions) {\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activation));\n    }","id":38856,"modified_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final Activation activation = getActivationMode(operation);\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context, verificationHandler);\n        final ModuleRegistrationTracker registrationTracker = new ModuleRegistrationTracker();\n\n        // Collect the subsystem extensions\n        final List<SubsystemExtension> extensions = new ArrayList<SubsystemExtension>();\n        final Iterator<SubsystemExtension> services = ServiceLoader.load(SubsystemExtension.class, getClass().getClassLoader()).iterator();\n        while(services.hasNext()) {\n            extensions.add(services.next());\n        }\n\n        // Create the framework activator\n        FrameworkActivator.create(serviceTarget, activation == Activation.LAZY);\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, extensions, verificationHandler));\n                newControllers.add(registrationTracker.install(serviceTarget, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_COMPONENTS, new OSGiComponentParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new FrameworkActivateProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor(registrationTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        for(SubsystemExtension extension : extensions) {\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activation));\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment\n    @StartLevelAware(startLevel = 3)\n    public static JavaArchive create() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, \"startlevel-bundle\");\n        archive.addClass(FrameworkUtils.class);\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                builder.addImportPackages(StartLevel.class);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","id":38857,"modified_method":"@Deployment(name = BUNDLE_A, managed = false, testable=false)\n    public static JavaArchive create() {\n        final JavaArchive archive = ShrinkWrap.create(JavaArchive.class, BUNDLE_A);\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                builder.addBundleSymbolicName(archive.getName());\n                builder.addBundleManifestVersion(2);\n                return builder.openStream();\n            }\n        });\n        return archive;\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testStartLevel() throws Exception {\n\n        int frameworkStartLevel = startLevel.getStartLevel();\n        assertEquals(\"Framework start level\", 1, frameworkStartLevel);\n        try {\n            assertNotNull(\"StartLevel injected\", startLevel);\n            int initialStartLevel = startLevel.getInitialBundleStartLevel();\n            assertEquals(\"Initial bundle start level\", 1, initialStartLevel);\n\n            assertEquals(\"Bundle RESOLVED\", Bundle.RESOLVED, bundle.getState());\n            assertEquals(\"startlevel-bundle\", bundle.getSymbolicName());\n\n            int bundleStartLevel = startLevel.getBundleStartLevel(bundle);\n            assertEquals(\"Bundle start level\", 3, bundleStartLevel);\n\n            // Change the framework start level and wait for the changed event\n            changeStartLevel(context, 2, TIMEOUT, MILLISECONDS);\n            assertEquals(\"Framework start level\", 2, startLevel.getStartLevel());\n\n            try {\n                bundle.start(Bundle.START_TRANSIENT);\n                fail(\"Bundle cannot be started due to the Framework's current start level\");\n            } catch (BundleException ex) {\n                // expected\n            }\n            assertEquals(\"Bundle RESOLVED\", Bundle.RESOLVED, bundle.getState());\n\n            // The bundle should not be started\n            bundle.start();\n            assertEquals(\"Bundle RESOLVED\", Bundle.RESOLVED, bundle.getState());\n\n            // Change the framework start level and wait for the changed event\n            changeStartLevel(context, 3, TIMEOUT, MILLISECONDS);\n\n            // The bundle should now be started\n            assertEquals(\"Bundle ACTIVE\", Bundle.ACTIVE, bundle.getState());\n\n            bundle.stop();\n            assertEquals(\"Bundle RESOLVED\", Bundle.RESOLVED, bundle.getState());\n\n            bundle.uninstall();\n            assertEquals(\"Bundle UNINSTALLED\", Bundle.UNINSTALLED, bundle.getState());\n        } finally {\n            // Change the framework start level and wait for the changed event\n            changeStartLevel(context, frameworkStartLevel, TIMEOUT, MILLISECONDS);\n        }\n    }","id":38858,"modified_method":"@Test\n    public void testStartLevel() throws Exception {\n\n        int frameworkStartLevel = startLevel.getStartLevel();\n        assertEquals(\"Framework start level\", 1, frameworkStartLevel);\n\n        int initialStartLevel = startLevel.getInitialBundleStartLevel();\n        assertEquals(\"Initial bundle start level\", 1, initialStartLevel);\n\n        InputStream input = deployer.getDeployment(BUNDLE_A);\n        Bundle bundle = context.installBundle(BUNDLE_A, input);\n        try {\n            assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, bundle.getState());\n\n            startLevel.setBundleStartLevel(bundle, 3);\n            assertEquals(\"Bundle start level\", 3, startLevel.getBundleStartLevel(bundle));\n\n            // Change the framework start level and wait for the changed event\n            changeStartLevel(context, 2, TIMEOUT, MILLISECONDS);\n            assertEquals(\"Framework start level\", 2, startLevel.getStartLevel());\n\n            try {\n                bundle.start(Bundle.START_TRANSIENT);\n                fail(\"Bundle cannot be started due to the Framework's current start level\");\n            } catch (BundleException ex) {\n                // expected\n            }\n            assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, bundle.getState());\n\n            // The bundle should not be started\n            bundle.start();\n            assertEquals(\"Bundle INSTALLED\", Bundle.INSTALLED, bundle.getState());\n\n            // Change the framework start level and wait for the changed event\n            changeStartLevel(context, 3, TIMEOUT, MILLISECONDS);\n\n            // The bundle should now be started\n            assertEquals(\"Bundle ACTIVE\", Bundle.ACTIVE, bundle.getState());\n        } finally {\n            bundle.uninstall();\n            changeStartLevel(context, frameworkStartLevel, TIMEOUT, MILLISECONDS);\n        }\n    }","commit_id":"c418da976b7e898a5ce5e00845f42f1c525d02fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n\t * Start inserts for unresolved (too big) Metadata's.\n\t * @param e\n\t * @param container\n\t * @param context\n\t * @return\n\t * @throws InsertException\n\t * @throws IOException\n\t */\n\tprivate boolean resolve(MetadataUnresolvedException e, ObjectContainer container, ClientContext context) throws InsertException, IOException {\n\t\tMetadata[] metas = e.mustResolve;\n\t\tboolean mustWait = false;\n\t\tif(persistent())\n\t\t\tcontainer.activate(metadataPuttersByMetadata, 2);\n\t\tfor(int i=0;i<metas.length;i++) {\n\t\t\tMetadata m = metas[i];\n\t\t\tif(!m.isResolved())\n\t\t\t\tmustWait = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(metadataPuttersByMetadata.containsKey(m)) continue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tBucket b = m.toBucket(context.getBucketFactory(persistent()));\n\t\t\t\t\n\t\t\t\tInsertBlock ib = new InsertBlock(b, null, FreenetURI.EMPTY_CHK_URI);\n\t\t\t\tSingleFileInserter metadataInserter = \n\t\t\t\t\tnew SingleFileInserter(this, this, ib, true, ctx, false, getCHKOnly, false, m, null, true, null, earlyEncode);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting subsidiary metadata: \"+metadataInserter+\" for \"+m);\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tthis.metadataPuttersByMetadata.put(m, metadataInserter);\n\t\t\t\t}\n\t\t\t\tmetadataInserter.start(null, container, context);\n\t\t\t} catch (MetadataUnresolvedException e1) {\n\t\t\t\tresolve(e1, container, context);\n\t\t\t}\n\t\t}\n\t\tif(persistent())\n\t\t\tcontainer.store(metadataPuttersByMetadata);\n\t\treturn mustWait;\n\t}","id":38859,"modified_method":"/**\n\t * Start inserts for unresolved (too big) Metadata's.\n\t * @param e\n\t * @param container\n\t * @param context\n\t * @return\n\t * @throws InsertException\n\t * @throws IOException\n\t */\n\tprivate void resolve(MetadataUnresolvedException e, ObjectContainer container, ClientContext context) throws InsertException, IOException {\n\t\tMetadata[] metas = e.mustResolve;\n\t\tif(persistent())\n\t\t\tcontainer.activate(metadataPuttersByMetadata, 2);\n\t\tfor(int i=0;i<metas.length;i++) {\n\t\t\tMetadata m = metas[i];\n\t\t\tsynchronized(this) {\n\t\t\t\tif(metadataPuttersByMetadata.containsKey(m)) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Already started insert for \"+m+\" in resolve() for \"+metas.length+\" Metadata's\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m.isResolved()) {\n\t\t\t\tLogger.error(this, \"Already resolved: \"+m+\" in resolve() - race condition???\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tBucket b = m.toBucket(context.getBucketFactory(persistent()));\n\t\t\t\t\n\t\t\t\tInsertBlock ib = new InsertBlock(b, null, FreenetURI.EMPTY_CHK_URI);\n\t\t\t\tSingleFileInserter metadataInserter = \n\t\t\t\t\tnew SingleFileInserter(this, this, ib, true, ctx, false, getCHKOnly, false, m, null, true, null, earlyEncode);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting subsidiary metadata: \"+metadataInserter+\" for \"+m);\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tthis.metadataPuttersByMetadata.put(m, metadataInserter);\n\t\t\t\t}\n\t\t\t\tmetadataInserter.start(null, container, context);\n\t\t\t} catch (MetadataUnresolvedException e1) {\n\t\t\t\tresolve(e1, container, context);\n\t\t\t}\n\t\t}\n\t\tif(persistent())\n\t\t\tcontainer.store(metadataPuttersByMetadata);\n\t}","commit_id":"94ada2460b9081f14aae4e37de257a31ee2a881b","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n         public void sawOpcode(int seen) {\n\t\tstack.mergeJumps(this);\n\t\ttry {\n         if (seen != INVOKEVIRTUAL) return;\n         if (!getClassName().equals(getClassConstantOperand())) return;\n         XMethod invokedMethod = XFactory.createXMethod(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(), false);\n         if (invokedMethod.getClassName().equals(getDottedClassConstantOperand())) {\n        \t // method is not inherited\n        \t return;\n         }\n         // method is inherited\n         String possibleTargetClass = getDottedClassName();\n         String superClassName = getDottedSuperclassName();\n         while(true) {\n        \t int i = possibleTargetClass.lastIndexOf('$');\n\t\t\tif (i == -1) break;\n\t\t\tpossibleTargetClass = possibleTargetClass.substring(0,i);\n\t\t\tif (possibleTargetClass.equals(superClassName)) break;\n        \t XMethod alternativeMethod = XFactory.createXMethod(possibleTargetClass, getNameConstantOperand(), getSigConstantOperand(), false);\n        \t if (alternativeMethod.isResolved()) \t\n        \t\t bugReporter.reportBug(new BugInstance(this, \"IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t          .addMethod(invokedMethod).describe(\"METHOD_INHERITED\")\n\t\t\t\t        .addMethod(alternativeMethod).describe(\"METHOD_ALTERNATIVE_TARGET\")\n\t\t\t\t        .addSourceLine(this, getPC()));\n         }\n         \n         \n\t\t} finally {\n\t\tstack.sawOpcode(this, seen);\n\t\t}\n\t}","id":38860,"modified_method":"@Override\n         public void sawOpcode(int seen) {\n\t\tstack.mergeJumps(this);\n\t\ttry {\n         if (seen != INVOKEVIRTUAL) return;\n         if (!getClassName().equals(getClassConstantOperand())) return;\n         XMethod invokedMethod = XFactory.createXMethod(getDottedClassConstantOperand(), getNameConstantOperand(), getSigConstantOperand(), false);\n         if (invokedMethod.isResolved() && invokedMethod.getClassName().equals(getDottedClassConstantOperand())) {\n        \t // method is not inherited\n        \t return;\n         }\n         // method is inherited\n         String possibleTargetClass = getDottedClassName();\n         String superClassName = getDottedSuperclassName();\n         while(true) {\n        \t int i = possibleTargetClass.lastIndexOf('$');\n\t\t\tif (i == -1) break;\n\t\t\tpossibleTargetClass = possibleTargetClass.substring(0,i);\n\t\t\tif (possibleTargetClass.equals(superClassName)) break;\n        \t XMethod alternativeMethod = XFactory.createXMethod(possibleTargetClass, getNameConstantOperand(), getSigConstantOperand(), false);\n        \t if (alternativeMethod.isResolved() && alternativeMethod.getClassName().equals(possibleTargetClass)) \t{\n        \t\t String targetPackage = invokedMethod.getPackageName();\n        \t\t String alternativePackage = alternativeMethod.getPackageName();\n        \t\t int priority = HIGH_PRIORITY;;\n        \t\t if (targetPackage.equals(alternativePackage)) priority++;\n        \t\t if (targetPackage.startsWith(\"javax.swing\") || targetPackage.startsWith(\"java.awt\"))\n        \t\t\t priority++;\n        \t\t bugReporter.reportBug(new BugInstance(this, \"IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD\", priority)\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t          .addMethod(invokedMethod).describe(\"METHOD_INHERITED\")\n\t\t\t\t        .addMethod(alternativeMethod).describe(\"METHOD_ALTERNATIVE_TARGET\")\n\t\t\t\t        .addSourceLine(this, getPC()));\n        \t\t break;\n        \t }\n         }\n         \n         \n\t\t} finally {\n\t\tstack.sawOpcode(this, seen);\n\t\t}\n\t}","commit_id":"c85fa7f3cb1b587934ebc20fc6e1eb40cd470551","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private boolean resolve(MetadataUnresolvedException e) throws InsertException, IOException {\n\t\tMetadata[] metas = e.mustResolve;\n\t\tboolean mustWait = false;\n\t\tfor(int i=0;i<metas.length;i++) {\n\t\t\tMetadata m = metas[i];\n\t\t\tif(!m.isResolved())\n\t\t\t\tmustWait = true;\n\t\t\tsynchronized(this) {\n\t\t\t\tif(metadataPuttersByMetadata.containsKey(m)) continue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tBucket b = m.toBucket(ctx.bf);\n\t\t\t\t\n\t\t\t\tInsertBlock ib = new InsertBlock(b, null, FreenetURI.EMPTY_CHK_URI);\n\t\t\t\tSingleFileInserter metadataInserter = \n\t\t\t\t\tnew SingleFileInserter(this, this, ib, true, ctx, false, getCHKOnly, false, m, null, true, null, earlyEncode);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting subsidiary metadata: \"+metadataInserter+\" for \"+m);\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tthis.metadataPuttersByMetadata.put(m, metadataInserter);\n\t\t\t\t}\n\t\t\t\tmetadataInserter.start(null);\n\t\t\t} catch (MetadataUnresolvedException e1) {\n\t\t\t\tresolve(e1);\n\t\t\t}\n\t\t}\n\t\treturn mustWait;\n\t}","id":38861,"modified_method":"/**\n\t * Start inserts for unresolved (too big) Metadata's.\n\t * @param e\n\t * @return\n\t * @throws InsertException\n\t * @throws IOException\n\t */\n\tprivate void resolve(MetadataUnresolvedException e) throws InsertException, IOException {\n\t\tMetadata[] metas = e.mustResolve;\n\t\tfor(int i=0;i<metas.length;i++) {\n\t\t\tMetadata m = metas[i];\n\t\t\tsynchronized(this) {\n\t\t\t\tif(metadataPuttersByMetadata.containsKey(m)) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Already started insert for \"+m+\" in resolve() for \"+metas.length+\" Metadata's\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m.isResolved()) {\n\t\t\t\tLogger.error(this, \"Already resolved: \"+m+\" in resolve() - race condition???\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tBucket b = m.toBucket(ctx.bf);\n\t\t\t\t\n\t\t\t\tInsertBlock ib = new InsertBlock(b, null, FreenetURI.EMPTY_CHK_URI);\n\t\t\t\tSingleFileInserter metadataInserter = \n\t\t\t\t\tnew SingleFileInserter(this, this, ib, true, ctx, false, getCHKOnly, false, m, null, true, null, earlyEncode);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Inserting subsidiary metadata: \"+metadataInserter+\" for \"+m);\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tthis.metadataPuttersByMetadata.put(m, metadataInserter);\n\t\t\t\t}\n\t\t\t\tmetadataInserter.start(null);\n\t\t\t} catch (MetadataUnresolvedException e1) {\n\t\t\t\tresolve(e1);\n\t\t\t}\n\t\t}\n\t}","commit_id":"0364bbc20fdeacb0771aa19c1c73b921cba52b27","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Parses the head includes.<p>\n     *\n     * @param formatterLoc the parent value location\n     *\n     * @throws CmsException if something goes wrong\n     */\n    private void parseHeadIncludes(I_CmsXmlContentLocation formatterLoc) throws CmsException {\n\n        I_CmsXmlContentValueLocation headIncludeCss = formatterLoc.getSubValue(N_HEAD_INCLUDE_CSS);\n        if (headIncludeCss != null) {\n            for (I_CmsXmlContentValueLocation inlineCssLoc : headIncludeCss.getSubValues(N_CSS_INLINE)) {\n                String inlineCss = inlineCssLoc.getValue().getStringValue(m_cms);\n                m_inlineCss.append(inlineCss);\n            }\n\n            for (I_CmsXmlContentValueLocation cssLinkLoc : headIncludeCss.getSubValues(N_CSS_LINK)) {\n                CmsXmlVfsFileValue fileValue = (CmsXmlVfsFileValue)cssLinkLoc.getValue();\n                CmsUUID structureId = fileValue.getLink(m_cms).getStructureId();\n                CmsResource resource = m_cms.readResource(structureId);\n                String cssPath = resource.getRootPath();\n                m_cssPaths.add(cssPath);\n            }\n        }\n        I_CmsXmlContentValueLocation headIncludeJs = formatterLoc.getSubValue(N_HEAD_INCLUDE_JS);\n        if (headIncludeJs != null) {\n            for (I_CmsXmlContentValueLocation inlineJsLoc : headIncludeJs.getSubValues(N_JAVASCRIPT_INLINE)) {\n                String inlineJs = inlineJsLoc.getValue().getStringValue(m_cms);\n                m_inlineJs.append(inlineJs);\n            }\n            for (I_CmsXmlContentValueLocation jsLinkLoc : headIncludeJs.getSubValues(N_JAVASCRIPT_LINK)) {\n                CmsXmlVfsFileValue fileValue = (CmsXmlVfsFileValue)jsLinkLoc.getValue();\n                CmsUUID structureId = fileValue.getLink(m_cms).getStructureId();\n                CmsResource resource = m_cms.readResource(structureId);\n                String jsPath = resource.getRootPath();\n                m_jsPaths.add(jsPath);\n            }\n        }\n    }","id":38862,"modified_method":"/**\n     * Parses the head includes.<p>\n     *\n     * @param formatterLoc the parent value location\n     */\n    private void parseHeadIncludes(I_CmsXmlContentLocation formatterLoc) {\n\n        I_CmsXmlContentValueLocation headIncludeCss = formatterLoc.getSubValue(N_HEAD_INCLUDE_CSS);\n        if (headIncludeCss != null) {\n            for (I_CmsXmlContentValueLocation inlineCssLoc : headIncludeCss.getSubValues(N_CSS_INLINE)) {\n                String inlineCss = inlineCssLoc.getValue().getStringValue(m_cms);\n                m_inlineCss.append(inlineCss);\n            }\n\n            for (I_CmsXmlContentValueLocation cssLinkLoc : headIncludeCss.getSubValues(N_CSS_LINK)) {\n                CmsXmlVfsFileValue fileValue = (CmsXmlVfsFileValue)cssLinkLoc.getValue();\n                CmsLink link = fileValue.getLink(m_cms);\n                if (link != null) {\n                    String cssPath = link.getTarget();\n                    m_cssPaths.add(cssPath);\n                }\n            }\n        }\n        I_CmsXmlContentValueLocation headIncludeJs = formatterLoc.getSubValue(N_HEAD_INCLUDE_JS);\n        if (headIncludeJs != null) {\n            for (I_CmsXmlContentValueLocation inlineJsLoc : headIncludeJs.getSubValues(N_JAVASCRIPT_INLINE)) {\n                String inlineJs = inlineJsLoc.getValue().getStringValue(m_cms);\n                m_inlineJs.append(inlineJs);\n            }\n            for (I_CmsXmlContentValueLocation jsLinkLoc : headIncludeJs.getSubValues(N_JAVASCRIPT_LINK)) {\n                CmsXmlVfsFileValue fileValue = (CmsXmlVfsFileValue)jsLinkLoc.getValue();\n                CmsLink link = fileValue.getLink(m_cms);\n                if (link != null) {\n                    String jsPath = link.getTarget();\n                    m_jsPaths.add(jsPath);\n                }\n            }\n        }\n    }","commit_id":"b49da1b5c28fb632c37ca6b21eebbbda79a18d67","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Reads the formatter bean from the given XML content.<p> \n     * \n     * @param content the formatter configuration XML content \n     * @param location a string indicating the location of the configuration \n     * @param id the id to use as the formatter id\n     *  \n     * @return the parsed formatter bean \n     * \n     * @throws ParseException if parsing goes wrong \n     * @throws CmsException if something else goes wrong \n     */\n    public CmsFormatterBean parse(CmsXmlContent content, String location, String id)\n    throws CmsException, ParseException {\n\n        Locale en = Locale.ENGLISH;\n        I_CmsXmlContentValue niceName = content.getValue(N_NICE_NAME, en);\n        m_niceName = niceName != null ? niceName.getStringValue(m_cms) : null;\n        CmsXmlContentRootLocation root = new CmsXmlContentRootLocation(content, en);\n\n        I_CmsXmlContentValueLocation rankLoc = root.getSubValue(N_RANK);\n        String rankStr = rankLoc.getValue().getStringValue(m_cms);\n        if (rankStr != null) {\n            rankStr = rankStr.trim();\n        }\n        int rank;\n        try {\n            rank = Integer.parseInt(rankStr);\n        } catch (NumberFormatException e) {\n            rank = CmsFormatterBean.DEFAULT_CONFIGURATION_RANK;\n        }\n        m_rank = rank;\n\n        String resType = getString(root, N_TYPE, null);\n        m_resourceType = resType.trim();\n\n        String autoEnabled = getString(root, N_AUTO_ENABLED, \"false\");\n        m_autoEnabled = Boolean.parseBoolean(autoEnabled);\n\n        I_CmsXmlContentValueLocation jspLoc = root.getSubValue(N_JSP);\n        CmsXmlVfsFileValue jspValue = (CmsXmlVfsFileValue)(jspLoc.getValue());\n        CmsUUID jspID = jspValue.getLink(m_cms).getStructureId();\n        CmsResource formatterRes = m_cms.readResource(jspID);\n        m_formatterResource = formatterRes;\n\n        String previewStr = getString(root, N_PREVIEW, \"false\");\n        m_preview = Boolean.parseBoolean(previewStr);\n\n        String searchableStr = getString(root, N_SEARCH_CONTENT, \"true\");\n        m_extractContent = Boolean.parseBoolean(searchableStr);\n\n        String isDetailStr = getString(root, N_DETAIL, \"true\");\n        boolean isDetail = Boolean.parseBoolean(isDetailStr);\n\n        parseMatch(root);\n        parseHeadIncludes(root);\n        parseSettings(root);\n\n        CmsFormatterBean formatterBean = new CmsFormatterBean(\n            m_containerTypes,\n            m_formatterResource.getRootPath(),\n            m_formatterResource.getStructureId(),\n            m_width,\n            m_maxWidth,\n            m_preview,\n            m_extractContent,\n            location,\n            m_cssPaths,\n            m_inlineCss.toString(),\n            m_jsPaths,\n            m_inlineJs.toString(),\n            m_niceName,\n            m_resourceType,\n            m_rank,\n            id,\n            m_settings,\n            true,\n            m_autoEnabled,\n            isDetail);\n        return formatterBean;\n    }","id":38863,"modified_method":"/**\n     * Reads the formatter bean from the given XML content.<p> \n     * \n     * @param content the formatter configuration XML content \n     * @param location a string indicating the location of the configuration \n     * @param id the id to use as the formatter id\n     *  \n     * @return the parsed formatter bean \n     * \n     * @throws ParseException if parsing goes wrong \n     * @throws CmsException if something else goes wrong \n     */\n    public CmsFormatterBean parse(CmsXmlContent content, String location, String id)\n    throws CmsException, ParseException {\n\n        Locale en = Locale.ENGLISH;\n        I_CmsXmlContentValue niceName = content.getValue(N_NICE_NAME, en);\n        m_niceName = niceName != null ? niceName.getStringValue(m_cms) : null;\n        CmsXmlContentRootLocation root = new CmsXmlContentRootLocation(content, en);\n\n        I_CmsXmlContentValueLocation rankLoc = root.getSubValue(N_RANK);\n        String rankStr = rankLoc.getValue().getStringValue(m_cms);\n        if (rankStr != null) {\n            rankStr = rankStr.trim();\n        }\n        int rank;\n        try {\n            rank = Integer.parseInt(rankStr);\n        } catch (NumberFormatException e) {\n            rank = CmsFormatterBean.DEFAULT_CONFIGURATION_RANK;\n        }\n        m_rank = rank;\n\n        String resType = getString(root, N_TYPE, null);\n        m_resourceType = resType.trim();\n\n        String autoEnabled = getString(root, N_AUTO_ENABLED, \"false\");\n        m_autoEnabled = Boolean.parseBoolean(autoEnabled);\n\n        I_CmsXmlContentValueLocation jspLoc = root.getSubValue(N_JSP);\n        CmsXmlVfsFileValue jspValue = (CmsXmlVfsFileValue)(jspLoc.getValue());\n        CmsLink link = jspValue.getLink(m_cms);\n        CmsUUID jspID = link.getStructureId();\n        CmsResource formatterRes = m_cms.readResource(jspID);\n        m_formatterResource = formatterRes;\n\n        String previewStr = getString(root, N_PREVIEW, \"false\");\n        m_preview = Boolean.parseBoolean(previewStr);\n\n        String searchableStr = getString(root, N_SEARCH_CONTENT, \"true\");\n        m_extractContent = Boolean.parseBoolean(searchableStr);\n\n        String isDetailStr = getString(root, N_DETAIL, \"true\");\n        boolean isDetail = Boolean.parseBoolean(isDetailStr);\n\n        parseMatch(root);\n        parseHeadIncludes(root);\n        parseSettings(root);\n\n        CmsFormatterBean formatterBean = new CmsFormatterBean(\n            m_containerTypes,\n            m_formatterResource.getRootPath(),\n            m_formatterResource.getStructureId(),\n            m_width,\n            m_maxWidth,\n            m_preview,\n            m_extractContent,\n            location,\n            m_cssPaths,\n            m_inlineCss.toString(),\n            m_jsPaths,\n            m_inlineJs.toString(),\n            m_niceName,\n            m_resourceType,\n            m_rank,\n            id,\n            m_settings,\n            true,\n            m_autoEnabled,\n            isDetail);\n        return formatterBean;\n    }","commit_id":"b412a670197ae93962db7e19a277733ab49ef52e","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** \n     * Reads a formatter given its structure id and returns it, or null if the formatter couldn't be read.<p>\n     * \n     * @param structureId the structure id of the formatter configuration \n     * \n     * @return the formatter bean, or null if no formatter could be read for some reason \n     */\n    protected CmsFormatterBean readFormatter(CmsUUID structureId) {\n\n        CmsFormatterBean formatterBean = null;\n        boolean fileWasRead = false;\n        try {\n            CmsResource formatterRes = m_cms.readResource(structureId);\n            CmsFile formatterFile = m_cms.readFile(formatterRes);\n            fileWasRead = true;\n            CmsFormatterBeanParser parser = new CmsFormatterBeanParser(m_cms);\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(m_cms, formatterFile);\n            formatterBean = parser.parse(content, formatterRes.getRootPath(), \"\" + formatterRes.getStructureId());\n        } catch (Exception e) {\n\n            if (!fileWasRead) {\n                // normal case if resources get deleted, should not be written to the error channel\n                LOG.info(e.getLocalizedMessage(), e);\n            } else {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        return formatterBean;\n    }","id":38864,"modified_method":"/** \n     * Reads a formatter given its structure id and returns it, or null if the formatter couldn't be read.<p>\n     * \n     * @param structureId the structure id of the formatter configuration \n     * \n     * @return the formatter bean, or null if no formatter could be read for some reason \n     */\n    protected CmsFormatterBean readFormatter(CmsUUID structureId) {\n\n        CmsFormatterBean formatterBean = null;\n        CmsResource formatterRes = null;\n        try {\n            formatterRes = m_cms.readResource(structureId);\n            CmsFile formatterFile = m_cms.readFile(formatterRes);\n            CmsFormatterBeanParser parser = new CmsFormatterBeanParser(m_cms);\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(m_cms, formatterFile);\n            formatterBean = parser.parse(content, formatterRes.getRootPath(), \"\" + formatterRes.getStructureId());\n        } catch (Exception e) {\n\n            if (formatterRes == null) {\n                // normal case if resources get deleted, should not be written to the error channel\n                LOG.info(e.getLocalizedMessage(), e);\n            } else {\n                LOG.error(\"Error while trying to read formatter configuration \"\n                    + formatterRes.getRootPath()\n                    + \":    \"\n                    + e.getLocalizedMessage(), e);\n            }\n        }\n        return formatterBean;\n    }","commit_id":"b412a670197ae93962db7e19a277733ab49ef52e","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Reads the formatter bean from the given XML content.<p> \n     * \n     * @param content the formatter configuration XML content \n     * @param location a string indicating the location of the configuration \n     * @param id the id to use as the formatter id\n     *  \n     * @return the parsed formatter bean \n     * \n     * @throws ParseException if parsing goes wrong \n     * @throws CmsException if something else goes wrong \n     */\n    public CmsFormatterBean parse(CmsXmlContent content, String location, String id)\n    throws CmsException, ParseException {\n\n        Locale en = Locale.ENGLISH;\n        I_CmsXmlContentValue niceName = content.getValue(N_NICE_NAME, en);\n        m_niceName = niceName != null ? niceName.getStringValue(m_cms) : null;\n        CmsXmlContentRootLocation root = new CmsXmlContentRootLocation(content, en);\n\n        I_CmsXmlContentValueLocation rankLoc = root.getSubValue(N_RANK);\n        String rankStr = rankLoc.getValue().getStringValue(m_cms);\n        if (rankStr != null) {\n            rankStr = rankStr.trim();\n        }\n        int rank;\n        try {\n            rank = Integer.parseInt(rankStr);\n        } catch (NumberFormatException e) {\n            rank = CmsFormatterBean.DEFAULT_CONFIGURATION_RANK;\n        }\n        m_rank = rank;\n\n        String resType = getString(root, N_TYPE, null);\n        m_resourceType = resType.trim();\n\n        String autoEnabled = getString(root, N_AUTO_ENABLED, \"false\");\n        m_autoEnabled = Boolean.parseBoolean(autoEnabled);\n\n        I_CmsXmlContentValueLocation jspLoc = root.getSubValue(N_JSP);\n        CmsXmlVfsFileValue jspValue = (CmsXmlVfsFileValue)(jspLoc.getValue());\n        CmsUUID jspID = jspValue.getLink(m_cms).getStructureId();\n        CmsResource formatterRes = m_cms.readResource(jspID);\n        m_formatterResource = formatterRes;\n\n        String previewStr = getString(root, N_PREVIEW, \"false\");\n        m_preview = Boolean.parseBoolean(previewStr);\n\n        String searchableStr = getString(root, N_SEARCH_CONTENT, \"true\");\n        m_extractContent = Boolean.parseBoolean(searchableStr);\n\n        String isDetailStr = getString(root, N_DETAIL, \"true\");\n        boolean isDetail = Boolean.parseBoolean(isDetailStr);\n\n        parseMatch(root);\n        parseHeadIncludes(root);\n        parseSettings(root);\n\n        CmsFormatterBean formatterBean = new CmsFormatterBean(\n            m_containerTypes,\n            m_formatterResource.getRootPath(),\n            m_formatterResource.getStructureId(),\n            m_width,\n            m_maxWidth,\n            m_preview,\n            m_extractContent,\n            location,\n            m_cssPaths,\n            m_inlineCss.toString(),\n            m_jsPaths,\n            m_inlineJs.toString(),\n            m_niceName,\n            m_resourceType,\n            m_rank,\n            id,\n            m_settings,\n            true,\n            m_autoEnabled,\n            isDetail);\n        return formatterBean;\n    }","id":38865,"modified_method":"/**\n     * Reads the formatter bean from the given XML content.<p> \n     * \n     * @param content the formatter configuration XML content \n     * @param location a string indicating the location of the configuration \n     * @param id the id to use as the formatter id\n     *  \n     * @return the parsed formatter bean \n     * \n     * @throws ParseException if parsing goes wrong \n     * @throws CmsException if something else goes wrong \n     */\n    public CmsFormatterBean parse(CmsXmlContent content, String location, String id)\n    throws CmsException, ParseException {\n\n        Locale en = Locale.ENGLISH;\n        I_CmsXmlContentValue niceName = content.getValue(N_NICE_NAME, en);\n        m_niceName = niceName != null ? niceName.getStringValue(m_cms) : null;\n        CmsXmlContentRootLocation root = new CmsXmlContentRootLocation(content, en);\n\n        I_CmsXmlContentValueLocation rankLoc = root.getSubValue(N_RANK);\n        String rankStr = rankLoc.getValue().getStringValue(m_cms);\n        if (rankStr != null) {\n            rankStr = rankStr.trim();\n        }\n        int rank;\n        try {\n            rank = Integer.parseInt(rankStr);\n        } catch (NumberFormatException e) {\n            rank = CmsFormatterBean.DEFAULT_CONFIGURATION_RANK;\n        }\n        m_rank = rank;\n\n        String resType = getString(root, N_TYPE, null);\n        m_resourceType = resType.trim();\n\n        String autoEnabled = getString(root, N_AUTO_ENABLED, \"false\");\n        m_autoEnabled = Boolean.parseBoolean(autoEnabled);\n\n        I_CmsXmlContentValueLocation jspLoc = root.getSubValue(N_JSP);\n        CmsXmlVfsFileValue jspValue = (CmsXmlVfsFileValue)(jspLoc.getValue());\n        CmsLink link = jspValue.getLink(m_cms);\n        CmsUUID jspID = link.getStructureId();\n        CmsResource formatterRes = m_cms.readResource(jspID);\n        m_formatterResource = formatterRes;\n\n        String previewStr = getString(root, N_PREVIEW, \"false\");\n        m_preview = Boolean.parseBoolean(previewStr);\n\n        String searchableStr = getString(root, N_SEARCH_CONTENT, \"true\");\n        m_extractContent = Boolean.parseBoolean(searchableStr);\n\n        String isDetailStr = getString(root, N_DETAIL, \"true\");\n        boolean isDetail = Boolean.parseBoolean(isDetailStr);\n\n        parseMatch(root);\n        parseHeadIncludes(root);\n        parseSettings(root);\n\n        CmsFormatterBean formatterBean = new CmsFormatterBean(\n            m_containerTypes,\n            m_formatterResource.getRootPath(),\n            m_formatterResource.getStructureId(),\n            m_width,\n            m_maxWidth,\n            m_preview,\n            m_extractContent,\n            location,\n            m_cssPaths,\n            m_inlineCss.toString(),\n            m_jsPaths,\n            m_inlineJs.toString(),\n            m_niceName,\n            m_resourceType,\n            m_rank,\n            id,\n            m_settings,\n            true,\n            m_autoEnabled,\n            isDetail);\n        return formatterBean;\n    }","commit_id":"a9df1d4ef4e9e1b61e3398f37a0789621d4fd91b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** \n     * Reads a formatter given its structure id and returns it, or null if the formatter couldn't be read.<p>\n     * \n     * @param structureId the structure id of the formatter configuration \n     * \n     * @return the formatter bean, or null if no formatter could be read for some reason \n     */\n    protected CmsFormatterBean readFormatter(CmsUUID structureId) {\n\n        CmsFormatterBean formatterBean = null;\n        boolean fileWasRead = false;\n        try {\n            CmsResource formatterRes = m_cms.readResource(structureId);\n            CmsFile formatterFile = m_cms.readFile(formatterRes);\n            fileWasRead = true;\n            CmsFormatterBeanParser parser = new CmsFormatterBeanParser(m_cms);\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(m_cms, formatterFile);\n            formatterBean = parser.parse(content, formatterRes.getRootPath(), \"\" + formatterRes.getStructureId());\n        } catch (Exception e) {\n\n            if (!fileWasRead) {\n                // normal case if resources get deleted, should not be written to the error channel\n                LOG.info(e.getLocalizedMessage(), e);\n            } else {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        return formatterBean;\n    }","id":38866,"modified_method":"/** \n     * Reads a formatter given its structure id and returns it, or null if the formatter couldn't be read.<p>\n     * \n     * @param structureId the structure id of the formatter configuration \n     * \n     * @return the formatter bean, or null if no formatter could be read for some reason \n     */\n    protected CmsFormatterBean readFormatter(CmsUUID structureId) {\n\n        CmsFormatterBean formatterBean = null;\n        CmsResource formatterRes = null;\n        try {\n            formatterRes = m_cms.readResource(structureId);\n            CmsFile formatterFile = m_cms.readFile(formatterRes);\n            CmsFormatterBeanParser parser = new CmsFormatterBeanParser(m_cms);\n            CmsXmlContent content = CmsXmlContentFactory.unmarshal(m_cms, formatterFile);\n            formatterBean = parser.parse(content, formatterRes.getRootPath(), \"\" + formatterRes.getStructureId());\n        } catch (Exception e) {\n\n            if (formatterRes == null) {\n                // normal case if resources get deleted, should not be written to the error channel\n                LOG.info(e.getLocalizedMessage(), e);\n            } else {\n                LOG.error(\"Error while trying to read formatter configuration \"\n                    + formatterRes.getRootPath()\n                    + \":    \"\n                    + e.getLocalizedMessage(), e);\n            }\n        }\n        return formatterBean;\n    }","commit_id":"a9df1d4ef4e9e1b61e3398f37a0789621d4fd91b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentValueLocation#asId(org.opencms.file.CmsObject)\n     */\n    public CmsUUID asId(CmsObject cms) {\n\n        return ((CmsXmlVfsFileValue)m_value).getLink(cms).getStructureId();\n    }","id":38867,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentValueLocation#asId(org.opencms.file.CmsObject)\n     */\n    public CmsUUID asId(CmsObject cms) {\n\n        CmsLink link = ((CmsXmlVfsFileValue)m_value).getLink(cms);\n        if (link == null) {\n            return null;\n        }\n        return link.getStructureId();\n    }","commit_id":"0c8883efa0ac0d6071e135f797cba0fe1ba5c642","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@CheckForNull\n  public UserDto selectNullableByScmAccountOrLoginOrName(DbSession session, String scmAccount) {\n    return mapper(session).selectNullableByScmAccountOrLoginOrName(scmAccount);\n  }","id":38868,"modified_method":"public List<UserDto> selectNullableByScmAccountOrLoginOrEmail(DbSession session, String scmAccountOrLoginOrEmail) {\n    return mapper(session).selectNullableByScmAccountOrLoginOrEmail(scmAccountOrLoginOrEmail);\n  }","commit_id":"c173a87a511c1242e3c5c7ac6d0f637c7c2ad66b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void select_nullable_by_scm_account() {\n    db.prepareDbUnit(getClass(), \"select_nullable_by_scm_account.xml\");\n\n    assertThat(dao.selectNullableByScmAccountOrLoginOrName(session, \"ma\").getLogin()).isEqualTo(\"marius\");\n    assertThat(dao.selectNullableByScmAccountOrLoginOrName(session, \"marius\").getLogin()).isEqualTo(\"marius\");\n    assertThat(dao.selectNullableByScmAccountOrLoginOrName(session, \"marius@lesbronzes.fr\").getLogin()).isEqualTo(\"marius\");\n\n    assertThat(dao.selectNullableByScmAccountOrLoginOrName(session, \"m\")).isNull();\n    assertThat(dao.selectNullableByScmAccountOrLoginOrName(session, \"unknown\")).isNull();\n  }","id":38869,"modified_method":"@Test\n  public void select_nullable_by_scm_account() {\n    db.prepareDbUnit(getClass(), \"select_nullable_by_scm_account.xml\");\n\n    List<UserDto> results = dao.selectNullableByScmAccountOrLoginOrEmail(session, \"ma\");\n    assertThat(results).hasSize(1);\n    assertThat(results.get(0).getLogin()).isEqualTo(\"marius\");\n\n    results = dao.selectNullableByScmAccountOrLoginOrEmail(session, \"marius\");\n    assertThat(results).hasSize(1);\n    assertThat(results.get(0).getLogin()).isEqualTo(\"marius\");\n\n    results = dao.selectNullableByScmAccountOrLoginOrEmail(session, \"marius@lesbronzes.fr\");\n    assertThat(results).hasSize(1);\n    assertThat(results.get(0).getLogin()).isEqualTo(\"marius\");\n\n    results = dao.selectNullableByScmAccountOrLoginOrEmail(session, \"marius@lesbronzes.fr\");\n    assertThat(results).hasSize(1);\n    assertThat(results.get(0).getLogin()).isEqualTo(\"marius\");\n\n    results = dao.selectNullableByScmAccountOrLoginOrEmail(session, \"m\");\n    assertThat(results).isEmpty();\n\n    results = dao.selectNullableByScmAccountOrLoginOrEmail(session, \"unknown\");\n    assertThat(results).isEmpty();\n  }","commit_id":"c173a87a511c1242e3c5c7ac6d0f637c7c2ad66b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  public UserDoc getNullableByScmAccount(String scmAccount) {\n    SearchRequestBuilder request = esClient.prepareSearch(UserIndexDefinition.INDEX)\n      .setTypes(UserIndexDefinition.TYPE_USER)\n      .setQuery(QueryBuilders.boolQuery()\n        .should(QueryBuilders.termQuery(UserIndexDefinition.FIELD_LOGIN, scmAccount))\n        .should(QueryBuilders.termQuery(UserIndexDefinition.FIELD_EMAIL, scmAccount))\n        .should(QueryBuilders.termQuery(UserIndexDefinition.FIELD_SCM_ACCOUNTS, scmAccount)))\n      .setSize(1);\n    SearchHit[] result = request.get().getHits().getHits();\n    if (result.length == 1) {\n      return new UserDoc(result[0].sourceAsMap());\n    }\n    return null;\n  }","id":38870,"modified_method":"@CheckForNull\n  public UserDoc getNullableByScmAccount(String scmAccount) {\n    SearchRequestBuilder request = esClient.prepareSearch(UserIndexDefinition.INDEX)\n      .setTypes(UserIndexDefinition.TYPE_USER)\n      .setQuery(QueryBuilders.boolQuery()\n        .should(QueryBuilders.termQuery(UserIndexDefinition.FIELD_LOGIN, scmAccount))\n        .should(QueryBuilders.termQuery(UserIndexDefinition.FIELD_EMAIL, scmAccount))\n        .should(QueryBuilders.termQuery(UserIndexDefinition.FIELD_SCM_ACCOUNTS, scmAccount)))\n      .setSize(2);\n    SearchHit[] result = request.get().getHits().getHits();\n    if (result.length == 1) {\n      return new UserDoc(result[0].sourceAsMap());\n    }\n    return null;\n  }","commit_id":"c173a87a511c1242e3c5c7ac6d0f637c7c2ad66b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void validateScmAccounts(DbSession dbSession, List<String> scmAccounts, @Nullable String login, @Nullable String email, @Nullable UserDto existingUser,\n    List<Message> messages) {\n    for (String scmAccount : scmAccounts) {\n      if (scmAccount.equals(login) || scmAccount.equals(email)) {\n        messages.add(Message.of(\"user.login_or_email_used_as_scm_account\"));\n      } else {\n        UserDto matchingUser = dbClient.userDao().selectNullableByScmAccountOrLoginOrName(dbSession, scmAccount);\n        if (matchingUser != null && (existingUser == null || !matchingUser.getId().equals(existingUser.getId()))) {\n          messages.add(Message.of(\"user.scm_account_already_used\", scmAccount, matchingUser.getName(), matchingUser.getLogin()));\n        }\n      }\n    }\n  }","id":38871,"modified_method":"private void validateScmAccounts(DbSession dbSession, List<String> scmAccounts, @Nullable String login, @Nullable String email, @Nullable UserDto existingUser,\n    List<Message> messages) {\n    for (String scmAccount : scmAccounts) {\n      if (scmAccount.equals(login) || scmAccount.equals(email)) {\n        messages.add(Message.of(\"user.login_or_email_used_as_scm_account\"));\n      } else {\n        List<UserDto> matchingUsers = dbClient.userDao().selectNullableByScmAccountOrLoginOrEmail(dbSession, scmAccount);\n        List<String> matchingUsersWithoutExistingUser = newArrayList();\n        for (UserDto matchingUser : matchingUsers) {\n          if (existingUser == null || !matchingUser.getId().equals(existingUser.getId())) {\n            matchingUsersWithoutExistingUser.add(matchingUser.getName() + \" (\" + matchingUser.getLogin() + \")\");\n          }\n        }\n        if (!matchingUsersWithoutExistingUser.isEmpty()) {\n          messages.add(Message.of(\"user.scm_account_already_used\", scmAccount, Joiner.on(\", \").join(matchingUsersWithoutExistingUser)));\n        }\n      }\n    }\n  }","commit_id":"c173a87a511c1242e3c5c7ac6d0f637c7c2ad66b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_create_user_when_scm_account_is_already_used() throws Exception {\n    db.prepareDbUnit(getClass(), \"fail_to_create_user_when_scm_account_is_already_used.xml\");\n\n    try {\n      userUpdater.create(NewUser.create()\n        .setLogin(\"marius\")\n        .setName(\"Marius2\")\n        .setEmail(\"marius2@mail.com\")\n        .setPassword(\"password2\")\n        .setPasswordConfirmation(\"password2\")\n        .setScmAccounts(newArrayList(\"jo\")));\n      fail();\n    } catch (BadRequestException e) {\n      assertThat(e.errors().messages()).containsOnly(Message.of(\"user.scm_account_already_used\", \"jo\", \"John\", \"john\"));\n    }\n  }","id":38872,"modified_method":"@Test\n  public void fail_to_create_user_when_scm_account_is_already_used() throws Exception {\n    db.prepareDbUnit(getClass(), \"fail_to_create_user_when_scm_account_is_already_used.xml\");\n\n    try {\n      userUpdater.create(NewUser.create()\n        .setLogin(\"marius\")\n        .setName(\"Marius\")\n        .setEmail(\"marius@mail.com\")\n        .setPassword(\"password\")\n        .setPasswordConfirmation(\"password\")\n        .setScmAccounts(newArrayList(\"jo\")));\n      fail();\n    } catch (BadRequestException e) {\n      assertThat(e.errors().messages()).containsOnly(Message.of(\"user.scm_account_already_used\", \"jo\", \"John (john)\"));\n    }\n  }","commit_id":"c173a87a511c1242e3c5c7ac6d0f637c7c2ad66b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_update_user_when_scm_account_is_already_used() throws Exception {\n    db.prepareDbUnit(getClass(), \"fail_to_update_user_when_scm_account_is_already_used.xml\");\n    createDefaultGroup();\n\n    try {\n      userUpdater.update(UpdateUser.create(\"marius\")\n        .setName(\"Marius2\")\n        .setEmail(\"marius2@mail.com\")\n        .setPassword(\"password2\")\n        .setPasswordConfirmation(\"password2\")\n        .setScmAccounts(newArrayList(\"jo\")));\n      fail();\n    } catch (BadRequestException e) {\n      assertThat(e.errors().messages()).containsOnly(Message.of(\"user.scm_account_already_used\", \"jo\", \"John\", \"john\"));\n    }\n  }","id":38873,"modified_method":"@Test\n  public void fail_to_update_user_when_scm_account_is_already_used() throws Exception {\n    db.prepareDbUnit(getClass(), \"fail_to_update_user_when_scm_account_is_already_used.xml\");\n    createDefaultGroup();\n\n    try {\n      userUpdater.update(UpdateUser.create(\"marius\")\n        .setName(\"Marius2\")\n        .setEmail(\"marius2@mail.com\")\n        .setPassword(\"password2\")\n        .setPasswordConfirmation(\"password2\")\n        .setScmAccounts(newArrayList(\"jo\")));\n      fail();\n    } catch (BadRequestException e) {\n      assertThat(e.errors().messages()).containsOnly(Message.of(\"user.scm_account_already_used\", \"jo\", \"John (john)\"));\n    }\n  }","commit_id":"c173a87a511c1242e3c5c7ac6d0f637c7c2ad66b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void saveUserInfo( IUser userInfo ) throws KettleException {\n    normalizeUserInfo( userInfo );\n    if ( !validateUserInfo( userInfo ) ) {\n      throw new KettleException( \"Empty name is not allowed\" );\n    }\n    userDelegate.saveUserInfo( userInfo );\n  }","id":38874,"modified_method":"/**\n   * This method creates new user after all validations have been done. For updating user's data please use {@linkplain\n   * #updateUser(IUser)}.\n   *\n   * @param userInfo user's info\n   * @throws KettleException\n   * @throws IllegalArgumentException if {@code userInfo.getObjectId() != null}\n   */\n  public void saveUserInfo( IUser userInfo ) throws KettleException {\n    normalizeUserInfo( userInfo );\n    if ( !validateUserInfo( userInfo ) ) {\n      throw new KettleException( \"Empty name is not allowed\" );\n    }\n\n    if ( userInfo.getObjectId() != null ) {\n      throw new IllegalArgumentException( \"Use updateUser() for updating\" );\n    }\n\n    String userLogin = userInfo.getLogin();\n    ObjectId exactMatch = userDelegate.getUserID( userLogin );\n    if ( exactMatch != null ) {\n      // found the corresponding record in db, prohibit creation!\n      throw new KettleException(\n        \"Cannot create a user with name [\" + userLogin + \"] because another one already exists: [\" + userLogin\n          + \"]. Please try different name.\" );\n    }\n\n    userDelegate.saveUserInfo( userInfo );\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Test( expected = KettleException.class )\n  public void saveUserInfo_NormalizesInfo_FailsIfStillBreaches() throws Exception {\n    UserInfo info = new UserInfo( \"    \" );\n    provider.saveUserInfo( info );\n  }","id":38875,"modified_method":"@Test( expected = KettleException.class )\n  public void saveUserInfo_NormalizesInfo_FailsIfStillBreaches() throws Exception {\n    provider.saveUserInfo( new UserInfo( \"    \" ) );\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Test\n  public void saveUserInfo_NormalizesInfo_PassesIfNoViolations() throws Exception {\n    UserInfo info = new UserInfo( \"login    \" );\n\n    ArgumentCaptor<UserInfo> captor = ArgumentCaptor.forClass( UserInfo.class );\n    provider.saveUserInfo( info );\n    verify( repository.userDelegate ).saveUserInfo( captor.capture() );\n\n    info = captor.getValue();\n    assertEquals( \"Spaces should be trimmed\", \"login\", info.getLogin() );\n  }","id":38876,"modified_method":"@Test\n  public void saveUserInfo_NormalizesInfo_PassesIfNoViolations() throws Exception {\n    testSaveUserInfo_Passes( \"login    \", \"login\" );\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void deleteUsers( List<IUser> users ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        userRoleWebService.deleteUsers( UserRoleHelper.convertToPentahoProxyUsers( users ) );\n        lookupCache.removeUsersFromLookupSet( users );\n        fireUserRoleListChange();\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0003_UNABLE_TO_DELETE_USERS\", e.getLocalizedMessage() ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38877,"modified_method":"public void deleteUsers( List<IUser> users ) throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      userRoleWebService.deleteUsers( UserRoleHelper.convertToPentahoProxyUsers( users ) );\n      lookupCache.removeUsersFromLookupSet( users );\n      fireUserRoleListChange();\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0003_UNABLE_TO_DELETE_USERS\", e.getLocalizedMessage() ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void createRole( IRole newRole ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        ProxyPentahoRole role = UserRoleHelper.convertToPentahoProxyRole( newRole );\n        userRoleWebService.createRole( role );\n        userRoleWebService.setUsers( role, UserRoleHelper.convertToPentahoProxyUsers( newRole.getUsers() ) );\n        lookupCache.insertRoleToLookupSet( newRole );\n        fireUserRoleListChange();\n      } catch ( UserRoleException e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0008_UNABLE_TO_CREATE_ROLE\", newRole.getName() ), e ); //$NON-NLS-1$\n      } catch ( Exception e ) { // it is the only way to determine AlreadyExistsException\n        if ( e.getCause().toString()\n            .contains( \"org.pentaho.platform.api.engine.security.userroledao.AlreadyExistsException\" ) ) {\n          throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n            \"UserRoleDelegate.ERROR_0016_ROLE_NAME_ALREADY_EXISTS\" ) );\n        }\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38878,"modified_method":"public void createRole( IRole newRole ) throws KettleException {\n    ensureHasPermissions();\n\n    ProxyPentahoRole role = UserRoleHelper.convertToPentahoProxyRole( newRole );\n    try {\n      ProxyPentahoRole[] existingRoles = userRoleWebService.getRoles();\n      if ( existsAmong( existingRoles, role ) ) {\n        throw userExistsException();\n      }\n    } catch ( UserRoleException e ) {\n      throw cannotCreateRoleException( newRole, e );\n    }\n\n    try {\n      userRoleWebService.createRole( role );\n      userRoleWebService.setUsers( role, UserRoleHelper.convertToPentahoProxyUsers( newRole.getUsers() ) );\n      lookupCache.insertRoleToLookupSet( newRole );\n      fireUserRoleListChange();\n    } catch ( UserRoleException e ) {\n      throw cannotCreateRoleException( newRole, e );\n    } catch ( Exception e ) { // it is the only way to determine AlreadyExistsException\n      if ( e.getCause().toString()\n        .contains( \"org.pentaho.platform.api.engine.security.userroledao.AlreadyExistsException\" ) ) {\n        throw roleExistsException();\n      }\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public IRole getRole( String name ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        return UserRoleHelper.convertFromProxyPentahoRole( userRoleWebService, UserRoleHelper.getProxyPentahoRole(\n          userRoleWebService, name ), lookupCache, rsm );\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0010_UNABLE_TO_GET_ROLE\", name ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38879,"modified_method":"public IRole getRole( String name ) throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      return UserRoleHelper.convertFromProxyPentahoRole( userRoleWebService, UserRoleHelper.getProxyPentahoRole(\n        userRoleWebService, name ), lookupCache, rsm );\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0010_UNABLE_TO_GET_ROLE\", name ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public IUser getUser( String name, String password ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      IUser userInfo = null;\n      try {\n        ProxyPentahoUser user = userRoleWebService.getUser( name );\n        if ( user != null && user.getName().equals( name ) && user.getPassword().equals( password ) ) {\n          userInfo = UserRoleHelper.convertToUserInfo( user, userRoleWebService.getRolesForUser( user ), rsm );\n        }\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0005_UNABLE_TO_GET_USER\", name ), e ); //$NON-NLS-1$\n      }\n      return userInfo;\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38880,"modified_method":"public IUser getUser( String name, String password ) throws KettleException {\n    ensureHasPermissions();\n\n    IUser userInfo = null;\n    try {\n      ProxyPentahoUser user = userRoleWebService.getUser( name );\n      if ( user != null && user.getName().equals( name ) && user.getPassword().equals( password ) ) {\n        userInfo = UserRoleHelper.convertToUserInfo( user, userRoleWebService.getRolesForUser( user ), rsm );\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0005_UNABLE_TO_GET_USER\", name ), e ); //$NON-NLS-1$\n    }\n    return userInfo;\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void deleteRole( String name ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        ProxyPentahoRole roleToDelete = UserRoleHelper.getProxyPentahoRole( userRoleWebService, name );\n        if ( roleToDelete != null ) {\n          ProxyPentahoRole[] roleArray = new ProxyPentahoRole[ 1 ];\n          roleArray[ 0 ] = roleToDelete;\n          userRoleWebService.deleteRoles( roleArray );\n          fireUserRoleListChange();\n        } else {\n          throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n            \"UserRoleDelegate.ERROR_0013_UNABLE_TO_DELETE_ROLE\", name ) ); //$NON-NLS-1$\n        }\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0013_UNABLE_TO_DELETE_ROLE\", name ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n\n  }","id":38881,"modified_method":"public void deleteRole( String name ) throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      ProxyPentahoRole roleToDelete = UserRoleHelper.getProxyPentahoRole( userRoleWebService, name );\n      if ( roleToDelete != null ) {\n        ProxyPentahoRole[] roleArray = new ProxyPentahoRole[ 1 ];\n        roleArray[ 0 ] = roleToDelete;\n        userRoleWebService.deleteRoles( roleArray );\n        fireUserRoleListChange();\n      } else {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0013_UNABLE_TO_DELETE_ROLE\", name ) ); //$NON-NLS-1$\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0013_UNABLE_TO_DELETE_ROLE\", name ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void deleteRoles( List<IRole> roles ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        userRoleWebService.deleteRoles( UserRoleHelper.convertToPentahoProxyRoles( roles ) );\n        lookupCache.removeRolesFromLookupSet( roles );\n        fireUserRoleListChange();\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0009_UNABLE_TO_DELETE_ROLES\" ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38882,"modified_method":"public void deleteRoles( List<IRole> roles ) throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      userRoleWebService.deleteRoles( UserRoleHelper.convertToPentahoProxyRoles( roles ) );\n      lookupCache.removeRolesFromLookupSet( roles );\n      fireUserRoleListChange();\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0009_UNABLE_TO_DELETE_ROLES\" ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void updateUser( IUser user ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        ProxyPentahoUser proxyUser = UserRoleHelper.convertToPentahoProxyUser( user );\n        userRoleWebService.updateUser( proxyUser );\n        if ( user instanceof IEEUser ) {\n          userRoleWebService\n            .setRoles( proxyUser, UserRoleHelper.convertToPentahoProxyRoles( ( (IEEUser) user ).getRoles() ) );\n        }\n        lookupCache.updateUserInLookupSet( user );\n        fireUserRoleListChange();\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0007_UNABLE_TO_UPDATE_USER\", user.getLogin() ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38883,"modified_method":"public void updateUser( IUser user ) throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      ProxyPentahoUser proxyUser = UserRoleHelper.convertToPentahoProxyUser( user );\n      userRoleWebService.updateUser( proxyUser );\n      if ( user instanceof IEEUser ) {\n        userRoleWebService\n          .setRoles( proxyUser, UserRoleHelper.convertToPentahoProxyRoles( ( (IEEUser) user ).getRoles() ) );\n      }\n      lookupCache.updateUserInLookupSet( user );\n      fireUserRoleListChange();\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0007_UNABLE_TO_UPDATE_USER\", user.getLogin() ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void createUser( IUser newUser ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        ProxyPentahoUser user = UserRoleHelper.convertToPentahoProxyUser( newUser );\n        userRoleWebService.createUser( user );\n        if ( newUser instanceof IEEUser ) {\n          userRoleWebService\n            .setRoles( user, UserRoleHelper.convertToPentahoProxyRoles( ( (IEEUser) newUser ).getRoles() ) );\n        }\n        lookupCache.insertUserToLookupSet( newUser );\n        fireUserRoleListChange();\n      } catch ( Exception e ) { // it is the only way to determine AlreadyExistsException\n        if ( e.getCause().toString()\n            .contains( \"org.pentaho.platform.api.engine.security.userroledao.AlreadyExistsException\" ) ) {\n          throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n            \"UserRoleDelegate.ERROR_0015_USER_NAME_ALREADY_EXISTS\" ) );\n        }\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0002_UNABLE_TO_CREATE_USER\", newUser.getLogin() ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n\n  }","id":38884,"modified_method":"public void createUser( IUser newUser ) throws KettleException {\n    ensureHasPermissions();\n\n    ProxyPentahoUser user = UserRoleHelper.convertToPentahoProxyUser( newUser );\n    try {\n      ProxyPentahoUser[] existingUsers = userRoleWebService.getUsers();\n      if ( existsAmong( existingUsers, user ) ) {\n        throw userExistsException();\n      }\n    } catch ( UserRoleException e ) {\n      throw cannotCreateUserException( newUser, e );\n    }\n\n    try {\n      userRoleWebService.createUser( user );\n      if ( newUser instanceof IEEUser ) {\n        userRoleWebService\n          .setRoles( user, UserRoleHelper.convertToPentahoProxyRoles( ( (IEEUser) newUser ).getRoles() ) );\n      }\n      lookupCache.insertUserToLookupSet( newUser );\n      fireUserRoleListChange();\n    } catch ( Exception e ) { // it is the only way to determine AlreadyExistsException\n      if ( e.getCause().toString()\n        .contains( \"org.pentaho.platform.api.engine.security.userroledao.AlreadyExistsException\" ) ) {\n        throw userExistsException();\n      }\n      throw cannotCreateUserException( newUser, e );\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void deleteUser( String name ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        ProxyPentahoUser user = userRoleWebService.getUser( name );\n        if ( user != null ) {\n          ProxyPentahoUser[] users = new ProxyPentahoUser[ 1 ];\n          users[ 0 ] = user;\n          userRoleWebService.deleteUsers( users );\n          fireUserRoleListChange();\n        } else {\n          throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n            \"UserRoleDelegate.ERROR_0004_UNABLE_TO_DELETE_USER\", name ) ); //$NON-NLS-1$       \n        }\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0004_UNABLE_TO_DELETE_USER\", name ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38885,"modified_method":"public void deleteUser( String name ) throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      ProxyPentahoUser user = userRoleWebService.getUser( name );\n      if ( user != null ) {\n        ProxyPentahoUser[] users = new ProxyPentahoUser[ 1 ];\n        users[ 0 ] = user;\n        userRoleWebService.deleteUsers( users );\n        fireUserRoleListChange();\n      } else {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0004_UNABLE_TO_DELETE_USER\", name ) ); //$NON-NLS-1$\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0004_UNABLE_TO_DELETE_USER\", name ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public IUser getUser( String name ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      IUser userInfo = null;\n      try {\n        ProxyPentahoUser user = userRoleWebService.getUser( name );\n        if ( user != null && user.getName().equals( name ) ) {\n          userInfo = UserRoleHelper.convertToUserInfo( user, userRoleWebService.getRolesForUser( user ), rsm );\n        }\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0005_UNABLE_TO_GET_USER\", name ), e ); //$NON-NLS-1$\n      }\n      return userInfo;\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38886,"modified_method":"public IUser getUser( String name ) throws KettleException {\n    ensureHasPermissions();\n\n    IUser userInfo = null;\n    try {\n      ProxyPentahoUser user = userRoleWebService.getUser( name );\n      if ( user != null && user.getName().equals( name ) ) {\n        userInfo = UserRoleHelper.convertToUserInfo( user, userRoleWebService.getRolesForUser( user ), rsm );\n      }\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0005_UNABLE_TO_GET_USER\", name ), e ); //$NON-NLS-1$\n    }\n    return userInfo;\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public UserRoleDelegate( IRoleSupportSecurityManager rsm, PurRepositoryMeta repositoryMeta, IUser userInfo,\n                           Log logger, ServiceManager serviceManager ) {\n    try {\n      this.logger = logger;\n      userDetailsRoleListWebService =\n        serviceManager.createService( userInfo.getLogin(), userInfo.getPassword(), IUserRoleListWebService.class );\n      userRoleWebService =\n        serviceManager.createService( userInfo.getLogin(), userInfo.getPassword(), IUserRoleWebService.class );\n      this.rsm = rsm;\n      initManaged( repositoryMeta, userInfo );\n      updateUserRoleInfo();\n    } catch ( Exception e ) {\n      this.logger.error( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0001_UNABLE_TO_INITIALIZE_USER_ROLE_WEBSVC\" ), e ); //$NON-NLS-1$\n    }\n  }","id":38887,"modified_method":"public UserRoleDelegate( IRoleSupportSecurityManager rsm, PurRepositoryMeta repositoryMeta, IUser userInfo,\n                           Log logger, ServiceManager serviceManager ) {\n    this.logger = logger;\n\n    String login = userInfo.getLogin();\n    String password = userInfo.getPassword();\n    try {\n      this.userDetailsRoleListWebService =\n        serviceManager.createService( login, password, IUserRoleListWebService.class );\n      this.userRoleWebService =\n        serviceManager.createService( login, password, IUserRoleWebService.class );\n      this.rsm = rsm;\n      initManaged( repositoryMeta, userInfo );\n      updateUserRoleInfo();\n    } catch ( Exception e ) {\n      this.logger.error( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0001_UNABLE_TO_INITIALIZE_USER_ROLE_WEBSVC\" ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void updateRole( IRole role ) throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        List<String> users = new ArrayList<String>();\n        for ( IUser user : role.getUsers() ) {\n          users.add( user.getLogin() );\n        }\n        userRoleWebService.updateRole( role.getName(), role.getDescription(), users );\n        lookupCache.updateRoleInLookupSet( role );\n        fireUserRoleListChange();\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0012_UNABLE_TO_UPDATE_ROLE\", role.getName() ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38888,"modified_method":"public void updateRole( IRole role ) throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      List<String> users = new ArrayList<String>();\n      for ( IUser user : role.getUsers() ) {\n        users.add( user.getLogin() );\n      }\n      userRoleWebService.updateRole( role.getName(), role.getDescription(), users );\n      lookupCache.updateRoleInLookupSet( role );\n      fireUserRoleListChange();\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0012_UNABLE_TO_UPDATE_ROLE\", role.getName() ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public List<IRole> getDefaultRoles() throws KettleException {\n    if ( hasNecessaryPermissions ) {\n      try {\n        return UserRoleHelper.convertToListFromProxyPentahoDefaultRoles( userRoleSecurityInfo, rsm );\n      } catch ( Exception e ) {\n        throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n          \"UserRoleDelegate.ERROR_0011_UNABLE_TO_GET_ROLES\" ), e ); //$NON-NLS-1$\n      }\n    } else {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0014_INSUFFICIENT_PRIVILEGES\" ) ); //$NON-NLS-1$\n    }\n  }","id":38889,"modified_method":"public List<IRole> getDefaultRoles() throws KettleException {\n    ensureHasPermissions();\n\n    try {\n      return UserRoleHelper.convertToListFromProxyPentahoDefaultRoles( userRoleSecurityInfo, rsm );\n    } catch ( Exception e ) {\n      throw new KettleException( BaseMessages.getString( UserRoleDelegate.class,\n        \"UserRoleDelegate.ERROR_0011_UNABLE_TO_GET_ROLES\" ), e ); //$NON-NLS-1$\n    }\n  }","commit_id":"80a3a8ad220495ec8ac89d112ea355ec5904ce88","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Creates authentication event with given parameters.\n     *\n     * @param node Node.\n     * @param msg Optional message.\n     * @param type Event type.\n     * @param subjType Subject type.\n     * @param subjId Subject ID.\n     */\n    public GridAuthenticationEvent(GridNode node, String msg, int type, GridSecuritySubjectType subjType,\n        UUID subjId) {\n        super(node, msg, type);\n\n        this.subjType = subjType;\n        this.subjId = subjId;\n    }","id":38890,"modified_method":"/**\n     * Creates authentication event with given parameters.\n     *\n     * @param node Node.\n     * @param msg Optional message.\n     * @param type Event type.\n     * @param subjType Subject type.\n     * @param subjId Subject ID.\n     */\n    public GridAuthenticationEvent(GridNode node, String msg, int type, GridSecuritySubjectType subjType,\n        UUID subjId, Object login) {\n        super(node, msg, type);\n\n        this.subjType = subjType;\n        this.subjId = subjId;\n        this.login = login;\n    }","commit_id":"aa3344bba43e3bc3d680cfd660d238d802b11d63","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Encode parameters map into \"application/x-www-form-urlencoded\" format.\n     *\n     * @param params Parameters map to encode.\n     * @return Form-encoded parameters.\n     * @throws IOException In case of error.\n     */\n    private StringBuilder encodeParams(Map<String, Object> params) throws IOException {\n        StringBuilder data = new StringBuilder();\n\n        for (Map.Entry<String, Object> e : params.entrySet()) {\n            if (e.getValue() instanceof String) {\n                if (data.length() > 0)\n                    data.append('&');\n\n                data.append(URLEncoder.encode(e.getKey(), \"UTF-8\")).append('=')\n                    .append(URLEncoder.encode((String)e.getValue(), \"UTF-8\"));\n            }\n            else if (e.getValue() instanceof GridSecurityCredentials) {\n                GridSecurityCredentials cred = (GridSecurityCredentials)e.getValue();\n\n                if (data.length() > 0)\n                    data.append('&');\n\n                if (!F.isEmpty(cred.getLogin()))\n                    data.append(\"gridgain.login=\").append(URLEncoder.encode(cred.getLogin(), \"UTF-8\"));\n\n                if (data.length() > 0)\n                    data.append('&');\n\n                if (!F.isEmpty(cred.getPassword()))\n                    data.append(\"gridgain.password=\").append(URLEncoder.encode(cred.getPassword(), \"UTF-8\"));\n            }\n            else\n                throw new IllegalArgumentException(\"Http connection supports only string arguments in requests\" +\n                    \", while received [key=\" + e.getKey() + \", value=\" + e.getValue() + \"]\");\n        }\n\n        return data;\n    }","id":38891,"modified_method":"/**\n     * Encode parameters map into \"application/x-www-form-urlencoded\" format.\n     *\n     * @param params Parameters map to encode.\n     * @return Form-encoded parameters.\n     * @throws IOException In case of error.\n     */\n    private StringBuilder encodeParams(Map<String, Object> params) throws IOException {\n        StringBuilder data = new StringBuilder();\n\n        for (Map.Entry<String, Object> e : params.entrySet()) {\n            if (e.getValue() instanceof String) {\n                if (data.length() > 0)\n                    data.append('&');\n\n                data.append(URLEncoder.encode(e.getKey(), \"UTF-8\")).append('=')\n                    .append(URLEncoder.encode((String)e.getValue(), \"UTF-8\"));\n            }\n            else if (e.getValue() instanceof GridSecurityCredentials) {\n                GridSecurityCredentials cred = (GridSecurityCredentials)e.getValue();\n\n                if (data.length() > 0)\n                    data.append('&');\n\n                Object login = cred.getLogin();\n\n                if (login != null) {\n                    if (!(login instanceof String))\n                        throw new IllegalArgumentException(\"Http connection supports only string login\" +\n                            \", while received: \" + login);\n\n                    data.append(\"gridgain.login=\").append(URLEncoder.encode((String)login, \"UTF-8\"));\n                }\n\n                if (data.length() > 0)\n                    data.append('&');\n\n                Object pwd = cred.getPassword();\n\n                if (pwd != null) {\n                    if (!(pwd instanceof String))\n                        throw new IllegalArgumentException(\"Http connection supports only string password\" +\n                            \", while received: \" + login);\n\n                    data.append(\"gridgain.password=\").append(URLEncoder.encode((String)pwd, \"UTF-8\"));\n                }\n            }\n            else\n                throw new IllegalArgumentException(\"Http connection supports only string arguments in requests\" +\n                    \", while received [key=\" + e.getKey() + \", value=\" + e.getValue() + \"]\");\n        }\n\n        return data;\n    }","commit_id":"aa3344bba43e3bc3d680cfd660d238d802b11d63","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void writeExternal(ObjectOutput out) throws IOException {\n        U.writeString(out, login);\n        U.writeString(out, password);\n        out.writeObject(userObj);\n    }","id":38892,"modified_method":"/** {@inheritDoc} */\n    @Override public void writeExternal(ObjectOutput out) throws IOException {\n        out.writeObject(login);\n        out.writeObject(password);\n        out.writeObject(userObj);\n    }","commit_id":"aa3344bba43e3bc3d680cfd660d238d802b11d63","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Sets password.\n     *\n     * @param password Password.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }","id":38893,"modified_method":"/**\n     * Sets password.\n     *\n     * @param password Password.\n     */\n    public void setPassword(Object password) {\n        this.password = password;\n    }","commit_id":"aa3344bba43e3bc3d680cfd660d238d802b11d63","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Gets password.\n     *\n     * @return Password.\n     */\n    public String getPassword() {\n        return password;\n    }","id":38894,"modified_method":"/**\n     * Gets password.\n     *\n     * @return Password.\n     */\n    public Object getPassword() {\n        return password;\n    }","commit_id":"aa3344bba43e3bc3d680cfd660d238d802b11d63","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Gets login.\n     *\n     * @return Login.\n     */\n    public String getLogin() {\n        return login;\n    }","id":38895,"modified_method":"/**\n     * Gets login.\n     *\n     * @return Login.\n     */\n    public Object getLogin() {\n        return login;\n    }","commit_id":"aa3344bba43e3bc3d680cfd660d238d802b11d63","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        login = U.readString(in);\n        password = U.readString(in);\n        userObj = in.readObject();\n    }","id":38896,"modified_method":"/** {@inheritDoc} */\n    @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        login = in.readObject();\n        password = in.readObject();\n        userObj = in.readObject();\n    }","commit_id":"aa3344bba43e3bc3d680cfd660d238d802b11d63","url":"https://github.com/apache/ignite"},{"original_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they are over the same sentence,\n    // have the same head span, the same type/subtype, and the same text.\n    // We need this for scoring NER, and in various places in KBP\n    //\n    if(sentence == otherEnt.sentence && textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","id":38897,"modified_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they are over the same sentence,\n    // have the same head span, the same type/subtype, and the same text.\n    // We need this for scoring NER, and in various places in KBP\n    //\n    if((sentence == otherEnt.sentence || sentence.equals(otherEnt.sentence)) && textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","commit_id":"b2447beb50b3988c67a867caadc6866e093f840b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Set the word value for the label.  Also, clears the lemma, since\n   * that may have changed if the word changed.\n   */\n  @Override\n  public void setWord(String word) {\n    set(CoreAnnotations.TextAnnotation.class, word);\n    // pado feb 09: if you change the word, delete the lemma.\n    remove(CoreAnnotations.LemmaAnnotation.class);\n  }","id":38898,"modified_method":"/**\n   * Set the word value for the label.  Also, clears the lemma, since\n   * that may have changed if the word changed.\n   */\n  @Override\n  public void setWord(String word) {\n    set(CoreAnnotations.TextAnnotation.class, word);\n    // pado feb 09: if you change the word, delete the lemma.\n    if (containsKey(CoreAnnotations.LemmaAnnotation.class)) {\n      set(CoreAnnotations.LemmaAnnotation.class, null);  // note[gabor]: set to null rather than removing for efficiency\n    }\n  }","commit_id":"70022a719a82483e7ee4ff76758991de269949ee","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Compares the text spans of the two entity mentions.\n   *\n   * @param otherEnt\n   */\n  public boolean textEquals(EntityMention otherEnt) {\n    //\n    // we attempt three comparisons:\n    // a) if syntactic heads are defined we consider two texts similar if they have the same syntactic head\n    //    (this is necessary because in NFL we compare entities with different spans but same heads, e.g. \"49ers\" vs \"San Francisco 49ers\"\n    // b) if head spans are defined we consider two texts similar if they have the same head span\n    // c) if extent spans are defined we consider two texts similar if they have the same extent span\n    //\n    if(syntacticHeadTokenPosition != -1 && otherEnt.syntacticHeadTokenPosition != -1){\n      if(syntacticHeadTokenPosition == otherEnt.syntacticHeadTokenPosition) return true;\n      return false;\n    }\n\n    if(headTokenSpan != null && otherEnt.headTokenSpan != null){\n      if(headTokenSpan.equals(otherEnt.headTokenSpan)) return true;\n      return false;\n    }\n\n    if(extentTokenSpan != null && otherEnt.extentTokenSpan != null){\n      if(extentTokenSpan.equals(otherEnt.extentTokenSpan)) return true;\n      return false;\n    }\n\n    return false;\n  }","id":38899,"modified_method":"/**\n   * Compares the text spans of the two entity mentions.\n   *\n   * @param otherEnt\n   */\n  public boolean textEquals(EntityMention otherEnt) {\n    //\n    // we attempt three comparisons:\n    // a) if syntactic heads are defined we consider two texts similar if they have the same syntactic head\n    //    (this is necessary because in NFL we compare entities with different spans but same heads, e.g. \"49ers\" vs \"San Francisco 49ers\"\n    // b) if head spans are defined we consider two texts similar if they have the same head span\n    // c) if extent spans are defined we consider two texts similar if they have the same extent span\n    //\n    if(syntacticHeadTokenPosition != -1 && otherEnt.syntacticHeadTokenPosition != -1){\n      if(syntacticHeadTokenPosition == otherEnt.syntacticHeadTokenPosition) return true;\n      return false;\n    }\n\n    if(headTokenSpan != null && otherEnt.headTokenSpan != null){\n      if(headTokenSpan.equals(otherEnt.headTokenSpan)) return true;\n      return false;\n    }\n\n    if(extentTokenSpan != null && otherEnt.extentTokenSpan != null){\n      if(extentTokenSpan.equals(otherEnt.extentTokenSpan)) return true;\n      return false;\n    }\n\n    if (!this.getExtentString().equals(otherEnt.getExtentString())) {\n      return false;\n    }\n\n    return false;\n  }","commit_id":"70022a719a82483e7ee4ff76758991de269949ee","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int hashCode() {\n    int result = mentionType != null ? mentionType.hashCode() : 0;\n    result = 31 * result + (headTokenSpan != null ? headTokenSpan.hashCode() : 0);\n    result = 31 * result + (normalizedName != null ? normalizedName.hashCode() : 0);\n    return result;\n  }","id":38900,"modified_method":"@Override\n  public int hashCode() {\n    int result = mentionType != null ? mentionType.hashCode() : 0;\n    result = 31 * result + (headTokenSpan != null ? headTokenSpan.hashCode() : 0);\n    result = 31 * result + (normalizedName != null ? normalizedName.hashCode() : 0);\n    result = 31 * result + (extentTokenSpan != null ? extentTokenSpan.hashCode() : 0);\n    return result;\n  }","commit_id":"70022a719a82483e7ee4ff76758991de269949ee","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they have the same head span, the same type/subtype, and the same text\n    // we need this for scoring NER\n    //\n    if(textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","id":38901,"modified_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they are over the same sentence,\n    // have the same head span, the same type/subtype, and the same text.\n    // We need this for scoring NER, and in various places in KBP\n    //\n    if(sentence == otherEnt.sentence && textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","commit_id":"70022a719a82483e7ee4ff76758991de269949ee","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they are over the same sentence,\n    // have the same head span, the same type/subtype, and the same text.\n    // We need this for scoring NER, and in various places in KBP\n    //\n    if(sentence == otherEnt.sentence && textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","id":38902,"modified_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they are over the same sentence,\n    // have the same head span, the same type/subtype, and the same text.\n    // We need this for scoring NER, and in various places in KBP\n    //\n    if((sentence == otherEnt.sentence || sentence.equals(otherEnt.sentence)) && textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","commit_id":"dab841de216df33ebaad67d4c22fae7678c0f95c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Set the word value for the label.  Also, clears the lemma, since\n   * that may have changed if the word changed.\n   */\n  @Override\n  public void setWord(String word) {\n    set(CoreAnnotations.TextAnnotation.class, word);\n    // pado feb 09: if you change the word, delete the lemma.\n    remove(CoreAnnotations.LemmaAnnotation.class);\n  }","id":38903,"modified_method":"/**\n   * Set the word value for the label.  Also, clears the lemma, since\n   * that may have changed if the word changed.\n   */\n  @Override\n  public void setWord(String word) {\n    set(CoreAnnotations.TextAnnotation.class, word);\n    // pado feb 09: if you change the word, delete the lemma.\n    if (containsKey(CoreAnnotations.LemmaAnnotation.class)) {\n      set(CoreAnnotations.LemmaAnnotation.class, null);  // note[gabor]: set to null rather than removing for efficiency\n    }\n  }","commit_id":"d2bfe9e4b593c5e669d475e5667cf8c26dcc943e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Compares the text spans of the two entity mentions.\n   *\n   * @param otherEnt\n   */\n  public boolean textEquals(EntityMention otherEnt) {\n    //\n    // we attempt three comparisons:\n    // a) if syntactic heads are defined we consider two texts similar if they have the same syntactic head\n    //    (this is necessary because in NFL we compare entities with different spans but same heads, e.g. \"49ers\" vs \"San Francisco 49ers\"\n    // b) if head spans are defined we consider two texts similar if they have the same head span\n    // c) if extent spans are defined we consider two texts similar if they have the same extent span\n    //\n    if(syntacticHeadTokenPosition != -1 && otherEnt.syntacticHeadTokenPosition != -1){\n      if(syntacticHeadTokenPosition == otherEnt.syntacticHeadTokenPosition) return true;\n      return false;\n    }\n\n    if(headTokenSpan != null && otherEnt.headTokenSpan != null){\n      if(headTokenSpan.equals(otherEnt.headTokenSpan)) return true;\n      return false;\n    }\n\n    if(extentTokenSpan != null && otherEnt.extentTokenSpan != null){\n      if(extentTokenSpan.equals(otherEnt.extentTokenSpan)) return true;\n      return false;\n    }\n\n    return false;\n  }","id":38904,"modified_method":"/**\n   * Compares the text spans of the two entity mentions.\n   *\n   * @param otherEnt\n   */\n  public boolean textEquals(EntityMention otherEnt) {\n    //\n    // we attempt three comparisons:\n    // a) if syntactic heads are defined we consider two texts similar if they have the same syntactic head\n    //    (this is necessary because in NFL we compare entities with different spans but same heads, e.g. \"49ers\" vs \"San Francisco 49ers\"\n    // b) if head spans are defined we consider two texts similar if they have the same head span\n    // c) if extent spans are defined we consider two texts similar if they have the same extent span\n    //\n    if(syntacticHeadTokenPosition != -1 && otherEnt.syntacticHeadTokenPosition != -1){\n      if(syntacticHeadTokenPosition == otherEnt.syntacticHeadTokenPosition) return true;\n      return false;\n    }\n\n    if(headTokenSpan != null && otherEnt.headTokenSpan != null){\n      if(headTokenSpan.equals(otherEnt.headTokenSpan)) return true;\n      return false;\n    }\n\n    if(extentTokenSpan != null && otherEnt.extentTokenSpan != null){\n      if(extentTokenSpan.equals(otherEnt.extentTokenSpan)) return true;\n      return false;\n    }\n\n    if (!this.getExtentString().equals(otherEnt.getExtentString())) {\n      return false;\n    }\n\n    return false;\n  }","commit_id":"d2bfe9e4b593c5e669d475e5667cf8c26dcc943e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they have the same head span, the same type/subtype, and the same text\n    // we need this for scoring NER\n    //\n    if(textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","id":38905,"modified_method":"public boolean equals(EntityMention otherEnt, boolean useSubType) {\n    //\n    // two mentions are equal if they are over the same sentence,\n    // have the same head span, the same type/subtype, and the same text.\n    // We need this for scoring NER, and in various places in KBP\n    //\n    if(sentence == otherEnt.sentence && textEquals(otherEnt) && labelEquals(otherEnt, useSubType)){\n      return true;\n    }\n    /*\n  \tif(((headTokenSpan != null && headTokenSpan.equals(otherEnt.headTokenSpan)) ||\n        (extentTokenSpan != null && extentTokenSpan.equals(otherEnt.extentTokenSpan))) &&\n        ((type != null && otherEnt.type != null && type.equals(otherEnt.type)) || (type == null && otherEnt.type == null)) &&\n        (! useSubType || ((subType != null && otherEnt.subType != null && subType.equals(otherEnt.subType)) || (subType == null && otherEnt.subType == null))) &&\n        AnnotationUtils.getTextContent(sentence, headTokenSpan).equals(AnnotationUtils.getTextContent(otherEnt.getSentence(), otherEnt.headTokenSpan))){\n      return true;\n    }\n     */\n    return false;\n  }","commit_id":"d2bfe9e4b593c5e669d475e5667cf8c26dcc943e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int hashCode() {\n    int result = mentionType != null ? mentionType.hashCode() : 0;\n    result = 31 * result + (headTokenSpan != null ? headTokenSpan.hashCode() : 0);\n    result = 31 * result + (normalizedName != null ? normalizedName.hashCode() : 0);\n    return result;\n  }","id":38906,"modified_method":"@Override\n  public int hashCode() {\n    int result = mentionType != null ? mentionType.hashCode() : 0;\n    result = 31 * result + (headTokenSpan != null ? headTokenSpan.hashCode() : 0);\n    result = 31 * result + (normalizedName != null ? normalizedName.hashCode() : 0);\n    result = 31 * result + (extentTokenSpan != null ? extentTokenSpan.hashCode() : 0);\n    return result;\n  }","commit_id":"d2bfe9e4b593c5e669d475e5667cf8c26dcc943e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main (String[] args) {\n\t    LinkedProperties preProcessedCommands = new LinkedProperties();\n\t\tString[] fileNames = null;\n\t\t\n\t\tList<String> argsList = Arrays.asList(args);\n\t\tIterator<String> iter = argsList.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tString arg = iter.next();\n\t\t\t// populate the file names\n\t\t\tif (arg.equals(\"-f\")) {\n\t\t\t\tfileNames = iter.next().split(\",\");\n\t\t\t}\n\t\t\tif (arg.equals(\"-d\")) {\n\t\t\t\tdirName = iter.next();\n\t\t\t}\n\t\t}\n\n\t\tif ((fileNames == null) || (fileNames.length == 0)){\n\t\t\tSystem.out.println(\"Please specify input file(s) separated by coma using -f option\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\t\n\t\tfor (String fileName : fileNames) {\n\t\t\ttry {\n\t\t\t\tFileInputStream in = new FileInputStream(fileName);\n\t\t\t\tpreProcessedCommands.load(in);\n\t\t\t}catch (FileNotFoundException ex) {\n\t\t\t    System.out.println(\"Can't find file \" + fileName);\n\t\t\t\tSystem.exit(2);\n\t\t\t} catch (IOException ex1) {\n\t\t\t    System.out.println(\"Error reading from file \" + ex1);\n\t\t\t\tSystem.exit(2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tIterator<?> propertiesIterator = preProcessedCommands.keys.iterator();\n\t\t//Get command classes and response object classes\n\t\twhile (propertiesIterator.hasNext()) {\n\t\t    String key = (String)propertiesIterator.next();\n            String preProcessedCommand = preProcessedCommands.getProperty(key);\n            String[] commandParts = preProcessedCommand.split(\";\");\n            String commandName = commandParts[0];\n            all_api_commands.put(key, commandName);\n            \n            short cmdPermissions = Short.parseShort(commandParts[1]);\n            if ((cmdPermissions & DOMAIN_ADMIN_COMMAND) != 0) {\n                domain_admin_api_commands.put(key, commandName);\n            }\n            if ((cmdPermissions & USER_COMMAND) != 0) {\n                regular_user_api_commands.put(key, commandName);\n            }\n\t\t}\n\t\t\n\t\tall_api_commands_sorted.putAll(all_api_commands);\n\t\tdomain_admin_api_commands_sorted.putAll(domain_admin_api_commands);\n\t\tregular_user_api_commands_sorted.putAll(regular_user_api_commands);\n\t\t\n\t\ttry {\n\t\t\t//Create object writer\n\t\t\tXStream xs = new XStream();\n\t\t\txs.alias(\"command\", Command.class);\n\t\t\txs.alias(\"arg\", Argument.class);\n\t\t\tString xmlDocDir =  dirName + \"/xmldoc\";\n\t\t\tString rootAdminDirName = xmlDocDir + \"/root_admin\";\n\t\t\tString domainAdminDirName = xmlDocDir + \"/domain_admin\";\n\t\t\tString regularUserDirName = xmlDocDir + \"/regular_user\";\n\t\t\t(new File(rootAdminDirName)).mkdirs();\n\t\t\t(new File(domainAdminDirName)).mkdirs();\n\t\t\t(new File(regularUserDirName)).mkdirs();\n\n\t\t\tObjectOutputStream out = xs.createObjectOutputStream(new FileWriter(dirName + \"/commands.xml\"), \"commands\");\n\t\t\tObjectOutputStream rootAdmin = xs.createObjectOutputStream(new FileWriter(rootAdminDirName + \"/\" + \"rootAdminSummary.xml\"), \"commands\");\n\t\t\tObjectOutputStream rootAdminSorted = xs.createObjectOutputStream(new FileWriter(rootAdminDirName + \"/\" + \"rootAdminSummarySorted.xml\"), \"commands\");\n\t\t\tObjectOutputStream domainAdmin = xs.createObjectOutputStream(new FileWriter(domainAdminDirName + \"/\" + \"domainAdminSummary.xml\"), \"commands\");\n\t\t\tObjectOutputStream outDomainAdminSorted = xs.createObjectOutputStream(new FileWriter(domainAdminDirName + \"/\" + \"domainAdminSummarySorted.xml\"), \"commands\");\n\t\t\tObjectOutputStream regularUser = xs.createObjectOutputStream(new FileWriter(regularUserDirName + \"/regularUserSummary.xml\"), \"commands\");\n\t\t\tObjectOutputStream regularUserSorted = xs.createObjectOutputStream(new FileWriter(regularUserDirName + \"/regularUserSummarySorted.xml\"), \"commands\");\n\t\n\t\t\t//Write commands in the order they are represented in commands.properties.in file\n\t\t\tIterator<?> it = all_api_commands.keySet().iterator();\n\t\t\twhile (it.hasNext()) {\t  \n\t\t\t    ObjectOutputStream singleCommandOs = null;\n\t\t\t\tString key = (String)it.next(); \n\t\t\t\t\n\t            //Write admin commands\n\t\t\t\twriteCommand(out, key);\n\t\t\t\twriteCommand(rootAdmin, key);\t\n\n\t\t\t\t//Write single commands to separate xml files\n\t\t\t\tsingleCommandOs = xs.createObjectOutputStream(new FileWriter(rootAdminDirName + \"/\" + key + \".xml\"), \"command\");\n\t\t\t\t\n\t\t\t\tif (domain_admin_api_commands.containsKey(key)){\n\t\t\t\t    writeCommand(domainAdmin, key);\n\t\t\t\t    singleCommandOs = xs.createObjectOutputStream(new FileWriter(domainAdminDirName + \"/\" + key + \".xml\"), \"command\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (regular_user_api_commands.containsKey(key)){\n\t\t\t\t    singleCommandOs = xs.createObjectOutputStream(new FileWriter(regularUserDirName + \"/\" + key + \".xml\"), \"command\");\n\t\t\t\t    writeCommand(regularUser, key);\n                }\n\t\t\t\twriteCommand(singleCommandOs, key);\n\t\t\t\tsingleCommandOs.close();\n\t\t\t}\n\t\t\t\n\t\t\t//Write sorted commands\n\t\t\tit = all_api_commands_sorted.keySet().iterator();\n\t\t\twhile (it.hasNext()) {     \n                String key = (String)it.next(); \n                \n                writeCommand(rootAdminSorted, key);\n                \n\n                if (domain_admin_api_commands.containsKey(key)){\n                    writeCommand(outDomainAdminSorted, key);    \n                }\n                \n                if (regular_user_api_commands.containsKey(key)){\n                    writeCommand(regularUserSorted, key);\n                }\n            }\n\t\t\t\n\t\t\tout.close();\n\t\t\trootAdmin.close();\n\t\t\trootAdminSorted.close();\n\t\t\tdomainAdmin.close();\n\t\t\toutDomainAdminSorted.close();\n\t\t\tregularUser.close();\n\t\t\tregularUserSorted.close();\n\t\t\t\n\t\t\t//gzip directory with xml doc\n\t\t\tzipDir(dirName + \"xmldoc.zip\", xmlDocDir);\n\t\t\t\n\t\t\t//Delete directory\n\t\t\tdeleteDir(new File(xmlDocDir));\n\t\t\t\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tSystem.exit(2);\n\t\t} \n\t}","id":38907,"modified_method":"public static void main (String[] args) {\n\t    LinkedProperties preProcessedCommands = new LinkedProperties();\n\t\tString[] fileNames = null;\n\t\t\n\t\tList<String> argsList = Arrays.asList(args);\n\t\tIterator<String> iter = argsList.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tString arg = iter.next();\n\t\t\t// populate the file names\n\t\t\tif (arg.equals(\"-f\")) {\n\t\t\t\tfileNames = iter.next().split(\",\");\n\t\t\t}\n\t\t\tif (arg.equals(\"-d\")) {\n\t\t\t\tdirName = iter.next();\n\t\t\t}\n\t\t}\n\n\t\tif ((fileNames == null) || (fileNames.length == 0)){\n\t\t\tSystem.out.println(\"Please specify input file(s) separated by coma using -f option\");\n\t\t\tSystem.exit(2);\n\t\t}\n\t\t\n\t\tfor (String fileName : fileNames) {\n\t\t\ttry {\n\t\t\t\tFileInputStream in = new FileInputStream(fileName);\n\t\t\t\tpreProcessedCommands.load(in);\n\t\t\t}catch (FileNotFoundException ex) {\n\t\t\t    System.out.println(\"Can't find file \" + fileName);\n\t\t\t\tSystem.exit(2);\n\t\t\t} catch (IOException ex1) {\n\t\t\t    System.out.println(\"Error reading from file \" + ex1);\n\t\t\t\tSystem.exit(2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tIterator<?> propertiesIterator = preProcessedCommands.keys.iterator();\n\t\t//Get command classes and response object classes\n\t\twhile (propertiesIterator.hasNext()) {\n\t\t    String key = (String)propertiesIterator.next();\n            String preProcessedCommand = preProcessedCommands.getProperty(key);\n            String[] commandParts = preProcessedCommand.split(\";\");\n            String commandName = commandParts[0];\n            all_api_commands.put(key, commandName);\n            \n            short cmdPermissions = Short.parseShort(commandParts[1]);\n            if ((cmdPermissions & DOMAIN_ADMIN_COMMAND) != 0) {\n                domain_admin_api_commands.put(key, commandName);\n            }\n            if ((cmdPermissions & USER_COMMAND) != 0) {\n                regular_user_api_commands.put(key, commandName);\n            }\n\t\t}\n\t\t\n\t\tall_api_commands_sorted.putAll(all_api_commands);\n\t\tdomain_admin_api_commands_sorted.putAll(domain_admin_api_commands);\n\t\tregular_user_api_commands_sorted.putAll(regular_user_api_commands);\n\t\t\n\t\ttry {\n\t\t\t//Create object writer\n\t\t\tXStream xs = new XStream();\n\t\t\txs.alias(\"command\", Command.class);\n\t\t\txs.alias(\"arg\", Argument.class);\n\t\t\tString xmlDocDir =  dirName + \"/xmldoc\";\n\t\t\tString rootAdminDirName = xmlDocDir + \"/root_admin\";\n\t\t\tString domainAdminDirName = xmlDocDir + \"/domain_admin\";\n\t\t\tString regularUserDirName = xmlDocDir + \"/regular_user\";\n\t\t\t(new File(rootAdminDirName)).mkdirs();\n\t\t\t(new File(domainAdminDirName)).mkdirs();\n\t\t\t(new File(regularUserDirName)).mkdirs();\n\n\t\t\tObjectOutputStream out = xs.createObjectOutputStream(new FileWriter(dirName + \"/commands.xml\"), \"commands\");\n\t\t\tObjectOutputStream rootAdmin = xs.createObjectOutputStream(new FileWriter(rootAdminDirName + \"/\" + \"rootAdminSummary.xml\"), \"commands\");\n\t\t\tObjectOutputStream rootAdminSorted = xs.createObjectOutputStream(new FileWriter(rootAdminDirName + \"/\" + \"rootAdminSummarySorted.xml\"), \"commands\");\n\t\t\tObjectOutputStream domainAdmin = xs.createObjectOutputStream(new FileWriter(domainAdminDirName + \"/\" + \"domainAdminSummary.xml\"), \"commands\");\n\t\t\tObjectOutputStream outDomainAdminSorted = xs.createObjectOutputStream(new FileWriter(domainAdminDirName + \"/\" + \"domainAdminSummarySorted.xml\"), \"commands\");\n\t\t\tObjectOutputStream regularUser = xs.createObjectOutputStream(new FileWriter(regularUserDirName + \"/regularUserSummary.xml\"), \"commands\");\n\t\t\tObjectOutputStream regularUserSorted = xs.createObjectOutputStream(new FileWriter(regularUserDirName + \"/regularUserSummarySorted.xml\"), \"commands\");\n\t\n\t\t\t//Write commands in the order they are represented in commands.properties.in file\n\t\t\tIterator<?> it = all_api_commands.keySet().iterator();\n\t\t\twhile (it.hasNext()) {\t  \n\t\t\t\tString key = (String)it.next(); \n\t\t\t\t\n\t            //Write admin commands\n\t\t\t\twriteCommand(out, key);\n\t\t\t\twriteCommand(rootAdmin, key);\t\n\n\t\t\t\t//Write single commands to separate xml files\n\t\t\t\tObjectOutputStream singleRootAdminCommandOs = xs.createObjectOutputStream(new FileWriter(rootAdminDirName + \"/\" + key + \".xml\"), \"command\");\n\t\t\t\twriteCommand(singleRootAdminCommandOs, key);\n\t\t\t\tsingleRootAdminCommandOs.close();\n\t\t\t\t\n\t\t\t\tif (domain_admin_api_commands.containsKey(key)){\n\t\t\t\t    writeCommand(domainAdmin, key);\n\t\t\t\t    ObjectOutputStream singleDomainAdminCommandOs = xs.createObjectOutputStream(new FileWriter(domainAdminDirName + \"/\" + key + \".xml\"), \"command\");\n\t\t\t\t    writeCommand(singleDomainAdminCommandOs, key);\n\t\t\t\t    singleDomainAdminCommandOs.close();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (regular_user_api_commands.containsKey(key)){\n\t\t\t\t    writeCommand(regularUser, key);\n\t\t\t\t    ObjectOutputStream singleRegularUserCommandOs = xs.createObjectOutputStream(new FileWriter(regularUserDirName + \"/\" + key + \".xml\"), \"command\");\n\t\t\t\t    writeCommand(singleRegularUserCommandOs, key);\n\t\t\t\t    singleRegularUserCommandOs.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Write sorted commands\n\t\t\tit = all_api_commands_sorted.keySet().iterator();\n\t\t\twhile (it.hasNext()) {     \n                String key = (String)it.next(); \n                writeCommand(rootAdminSorted, key);\n                \n\n                if (domain_admin_api_commands.containsKey(key)){\n                    writeCommand(outDomainAdminSorted, key);    \n                }\n                \n                if (regular_user_api_commands.containsKey(key)){\n                    writeCommand(regularUserSorted, key);\n                }\n            }\n\t\t\t\n\t\t\tout.close();\n\t\t\trootAdmin.close();\n\t\t\trootAdminSorted.close();\n\t\t\tdomainAdmin.close();\n\t\t\toutDomainAdminSorted.close();\n\t\t\tregularUser.close();\n\t\t\tregularUserSorted.close();\n\t\t\t\n\t\t\t//gzip directory with xml doc\n\t\t\tzipDir(dirName + \"xmldoc.zip\", xmlDocDir);\n\t\t\t\n\t\t\t//Delete directory\n\t\t\tdeleteDir(new File(xmlDocDir));\n\t\t\t\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tSystem.exit(2);\n\t\t} \n\t}","commit_id":"5dde719988ad570ce610853db9993540b6bb9ee7","url":"https://github.com/apache/cloudstack"},{"original_method":"public void onReset(LoggerContext context) {\n            addInfo(\"OsgiIntegrationListener : context reset detected. Adding LogManager to context map and firing\"\n                + \" listeners\");\n\n            // Attach a console appender to handle logging untill we configure\n            // one. This would be\n            // removed in LogConfigManager.reset\n            getLoggerContext().getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME).addAppender(\n                logConfigManager.getDefaultAppender());\n\n            // Now record the time of reset with a default appender attached to\n            // root logger\n            resetStartTime = System.currentTimeMillis();\n\n            context.putObject(LogbackManager.class.getName(), LogbackManager.this);\n            for (LogbackResetListener l : resetListeners) {\n                l.onReset(context);\n            }\n        }","id":38908,"modified_method":"public void onReset(LoggerContext context) {\n            addInfo(\"OsgiIntegrationListener : context reset detected. Adding LogManager to context map and firing\"\n                + \" listeners\");\n\n            // Attach a console appender to handle logging untill we configure\n            // one. This would be removed in LogConfigManager.reset\n            final Logger rootLogger = getLoggerContext().getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);\n            rootLogger.addAppender(logConfigManager.getDefaultAppender());\n            rootLogger.setLevel(Level.INFO);\n\n            // Now record the time of reset with a default appender attached to\n            // root logger. We also add a milli second extra to account for logs which would have\n            // got fired in same duration\n            resetStartTime = System.currentTimeMillis() + TimeUnit.MILLISECONDS.toMillis(1);\n\n            context.putObject(LogbackManager.class.getName(), LogbackManager.this);\n            for (LogbackResetListener l : resetListeners) {\n                l.onReset(context);\n            }\n        }","commit_id":"9a9a09e11bc9c7f76bd731d57e70a0d28bf5c0bd","url":"https://github.com/apache/sling"},{"original_method":"public LoggerRepository getLoggerRepository()\r\n    {\r\n        final ClassLoader ccl = Thread.currentThread().getContextClassLoader();\r\n\r\n        LoggerRepository repository = repos.get(ccl);\r\n        if (repository == null)\r\n        {\r\n            final RootLogger root = new RootLogger(Level.INFO);\r\n            repository = new Hierarchy(root);\r\n\r\n            try\r\n            {\r\n                String logName;\r\n                if (ccl instanceof MuleApplicationClassLoader)\r\n                {\r\n                    MuleApplicationClassLoader muleCL = (MuleApplicationClassLoader) ccl;\r\n                    logName = \"-app-\" + muleCL.getAppName();\r\n                }\r\n                else\r\n                {\r\n                    logName = \"\";\r\n                }\r\n                File logDir = new File(MuleContainerBootstrapUtils.getMuleHome(), \"logs\");\r\n                File logFile = new File(logDir, \"mule\" + logName + \".log\");\r\n                RollingFileAppender appender = new RollingFileAppender(new PatternLayout(\"%-5p %d [%t] %c: %m%n\"), logFile.getAbsolutePath(), true);\r\n                appender.setMaxBackupIndex(1);\r\n                appender.setMaximumFileSize(1000000);\r\n\r\n                root.addAppender(appender);\r\n\r\n                final LoggerRepository previous = repos.putIfAbsent(ccl, repository);\r\n                if (previous != null)\r\n                {\r\n                    repository = previous;\r\n                }\r\n            }\r\n            catch (IOException e)\r\n            {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n        return repository;\r\n    }","id":38909,"modified_method":"public LoggerRepository getLoggerRepository()\r\n    {\r\n        final ClassLoader ccl = Thread.currentThread().getContextClassLoader();\r\n\r\n        LoggerRepository repository = repos.get(ccl);\r\n        if (repository == null)\r\n        {\r\n            final RootLogger root = new RootLogger(Level.INFO);\r\n            repository = new Hierarchy(root);\r\n\r\n            try\r\n            {\r\n                String logName;\r\n                if (ccl instanceof MuleApplicationClassLoader)\r\n                {\r\n                    MuleApplicationClassLoader muleCL = (MuleApplicationClassLoader) ccl;\r\n                    logName = \"-app-\" + muleCL.getAppName();\r\n                    File logDir = new File(MuleContainerBootstrapUtils.getMuleHome(), \"logs\");\r\n                    File logFile = new File(logDir, \"mule\" + logName + \".log\");\r\n                    RollingFileAppender fileAppender = new RollingFileAppender(new PatternLayout(PATTERN_LAYOUT), logFile.getAbsolutePath(), true);\r\n                    fileAppender.setMaxBackupIndex(1);\r\n                    fileAppender.setMaximumFileSize(1000000);\r\n                    fileAppender.activateOptions();\r\n                    root.addAppender(fileAppender);\r\n                }\r\n                else\r\n                {\r\n                    // container logger handled by the wrapper, just output to the sys.out\r\n                    final ConsoleAppender appender = new ConsoleAppender(new PatternLayout(PATTERN_LAYOUT));\r\n                    appender.activateOptions();\r\n                    root.addAppender(appender);\r\n                }\r\n\r\n                final LoggerRepository previous = repos.putIfAbsent(ccl, repository);\r\n                if (previous != null)\r\n                {\r\n                    repository = previous;\r\n                }\r\n            }\r\n            catch (IOException e)\r\n            {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n        return repository;\r\n    }","commit_id":"f7b7c0cc9363a6db77ba015b8825d308fec5cf34","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n   * @since 5.2\n   */\n  public Batch executeTask(Map<String, String> analysisProperties, IssueListener issueListener) {\n    checkStarted();\n    bootstrapContainer.executeTask(analysisProperties, components, issueListener);\n    return this;\n  }","id":38910,"modified_method":"/**\n   * @since 5.2\n   */\n  public Batch executeTask(Map<String, String> analysisProperties, IssueListener issueListener) {\n    checkStarted();\n    configureTaskLogging(analysisProperties);\n    bootstrapContainer.executeTask(analysisProperties, components, issueListener);\n    configureLogging();\n    return this;\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @since 4.4\n   */\n  public Batch executeTask(Map<String, String> analysisProperties, Object... components) {\n    checkStarted();\n    bootstrapContainer.executeTask(analysisProperties, components);\n    return this;\n  }","id":38911,"modified_method":"/**\n   * @since 4.4\n   */\n  public Batch executeTask(Map<String, String> analysisProperties, Object... components) {\n    checkStarted();\n    configureTaskLogging(analysisProperties);\n    bootstrapContainer.executeTask(analysisProperties, components);\n    configureLogging();\n    return this;\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void configureLogging() {\n    if (loggingConfig != null) {\n      LoggingConfigurator.apply(loggingConfig);\n    }\n  }","id":38912,"modified_method":"private void configureLogging() {\n    if (loggingConfig != null) {\n      loggingConfig.setProperties(bootstrapProperties);\n      LoggingConfigurator.apply(loggingConfig);\n    }\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testNoStdLog() throws IOException {\n    File srcDir = new File(baseDir, \"src\");\n    srcDir.mkdir();\n\n    File xooFile = new File(srcDir, \"sample.xoo\");\n    FileUtils.write(xooFile, \"Sample xoo\\ncontent\");\n\n    tester.newTask()\n      .properties(builder\n        .put(\"sonar.sources\", \"src\")\n        .build())\n      .start();\n\n    assertNoStdOutput();\n    assertThat(logOutput).isNotEmpty();\n\n    synchronized (logOutput) {\n      for (LogEvent e : logOutput) {\n        savedStdOut.println(\"[captured]\" + e.level + \" \" + e.msg);\n      }\n    }\n  }","id":38913,"modified_method":"@Test\n  public void testNoStdLog() throws IOException {\n    File srcDir = new File(baseDir, \"src\");\n    srcDir.mkdir();\n\n    File xooFile = new File(srcDir, \"sample.xoo\");\n    FileUtils.write(xooFile, \"Sample xoo\\ncontent\");\n\n    tester.newTask()\n      .properties(builder\n        .put(\"sonar.sources\", \"src\")\n        .build())\n      .start();\n    tester.stop();\n\n    assertNoStdOutput();\n    assertThat(logOutput).isNotEmpty();\n\n    synchronized (logOutput) {\n      for (LogEvent e : logOutput) {\n        savedStdOut.println(\"[captured]\" + e.level + \" \" + e.msg);\n      }\n    }\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void log(String msg, Level level) {\n      logOutput.add(new LogEvent(msg, level));\n    }","id":38914,"modified_method":"@Override\n    public void log(String msg, Level level) {\n      logOutput.add(new LogEvent(msg, level));\n      logOutputStr.append(msg).append(\"\\n\");\n    }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testNoFormattedMsgs() throws IOException {\n    File srcDir = new File(baseDir, \"src\");\n    srcDir.mkdir();\n\n    File xooFile = new File(srcDir, \"sample.xoo\");\n    FileUtils.write(xooFile, \"Sample xoo\\ncontent\");\n\n    tester.newTask()\n      .properties(builder\n        .put(\"sonar.sources\", \"src\")\n        .build())\n      .start();\n\n    assertNoStdOutput();\n\n    synchronized (logOutput) {\n      for (LogEvent e : logOutput) {\n        assertMsgClean(e.msg);\n        savedStdOut.println(\"[captured]\" + e.level + \" \" + e.msg);\n      }\n    }\n  }","id":38915,"modified_method":"@Test\n  public void testNoFormattedMsgs() throws IOException {\n    File srcDir = new File(baseDir, \"src\");\n    srcDir.mkdir();\n\n    File xooFile = new File(srcDir, \"sample.xoo\");\n    FileUtils.write(xooFile, \"Sample xoo\\ncontent\");\n\n    tester.newTask()\n      .properties(builder\n        .put(\"sonar.sources\", \"src\")\n        .build())\n      .start();\n    tester.stop();\n\n    assertNoStdOutput();\n\n    synchronized (logOutput) {\n      for (LogEvent e : logOutput) {\n        assertMsgClean(e.msg);\n        savedStdOut.println(\"[captured]\" + e.level + \" \" + e.msg);\n      }\n    }\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void prepare() throws IOException {\n    System.setOut(new PrintStream(stdOutTarget));\n    System.setErr(new PrintStream(stdErrTarget));\n    // logger from the batch might write to it asynchronously\n    logOutput = Collections.synchronizedList(new LinkedList<LogEvent>());\n    tester.start();\n\n    baseDir = temp.getRoot();\n\n    builder = ImmutableMap.<String, String>builder()\n      .put(\"sonar.task\", \"scan\")\n      .put(\"sonar.projectBaseDir\", baseDir.getAbsolutePath())\n      .put(\"sonar.projectKey\", \"com.foo.project\")\n      .put(\"sonar.projectName\", \"Foo Project\")\n      .put(\"sonar.projectVersion\", \"1.0-SNAPSHOT\")\n      .put(\"sonar.projectDescription\", \"Description of Foo Project\");\n  }","id":38916,"modified_method":"@Before\n  public void prepare() throws IOException {\n    System.setOut(new PrintStream(stdOutTarget));\n    System.setErr(new PrintStream(stdErrTarget));\n    // logger from the batch might write to it asynchronously\n    logOutput = Collections.synchronizedList(new LinkedList<LogEvent>());\n    logOutputStr = new StringBuilder();\n    tester.start();\n\n    baseDir = temp.getRoot();\n\n    builder = ImmutableMap.<String, String>builder()\n      .put(\"sonar.task\", \"scan\")\n      .put(\"sonar.projectBaseDir\", baseDir.getAbsolutePath())\n      .put(\"sonar.projectKey\", \"com.foo.project\")\n      .put(\"sonar.projectName\", \"Foo Project\")\n      .put(\"sonar.projectVersion\", \"1.0-SNAPSHOT\")\n      .put(\"sonar.projectDescription\", \"Description of Foo Project\");\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public LoggingConfiguration setShowSql(Map<String, String> properties) {\n    String logLevel = properties.get(\"sonar.log.level\");\n    String deprecatedProfilingLevel = properties.get(\"sonar.log.profilingLevel\");\n    boolean sql = \"TRACE\".equals(logLevel) || \"FULL\".equals(deprecatedProfilingLevel);\n\n    return setShowSql(sql);\n  }","id":38917,"modified_method":"public LoggingConfiguration setShowSql(Map<String, String> properties, @Nullable Map<String, String> fallback) {\n    String logLevel = getFallback(\"sonar.log.level\", properties, fallback);\n    String deprecatedProfilingLevel = getFallback(\"sonar.log.profilingLevel\", properties, fallback);\n    boolean sql = \"TRACE\".equals(logLevel) || \"FULL\".equals(deprecatedProfilingLevel);\n\n    return setShowSql(sql);\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public LoggingConfiguration setProperties(Map<String, String> properties) {\n    setShowSql(properties);\n    setVerbose(properties);\n    return this;\n  }","id":38918,"modified_method":"public LoggingConfiguration setProperties(Map<String, String> properties) {\n    setShowSql(properties, null);\n    setVerbose(properties, null);\n    return this;\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public LoggingConfiguration setVerbose(Map<String, String> properties) {\n    String logLevel = properties.get(\"sonar.log.level\");\n    String deprecatedProfilingLevel = properties.get(\"sonar.log.profilingLevel\");\n    boolean verbose = \"true\".equals(properties.get(\"sonar.verbose\")) ||\n      \"DEBUG\".equals(logLevel) || \"TRACE\".equals(logLevel) ||\n      \"BASIC\".equals(deprecatedProfilingLevel) || \"FULL\".equals(deprecatedProfilingLevel);\n\n    return setVerbose(verbose);\n  }","id":38919,"modified_method":"public LoggingConfiguration setVerbose(Map<String, String> props, @Nullable Map<String, String> fallback) {\n    String logLevel = getFallback(\"sonar.log.level\", props, fallback);\n    String deprecatedProfilingLevel = getFallback(\"sonar.log.profilingLevel\", props, fallback);\n    boolean verbose = \"true\".equals(getFallback(\"sonar.verbose\", props, fallback)) ||\n      \"DEBUG\".equals(logLevel) || \"TRACE\".equals(logLevel) ||\n      \"BASIC\".equals(deprecatedProfilingLevel) || \"FULL\".equals(deprecatedProfilingLevel);\n\n    return setVerbose(verbose);\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void setCustomRootAppender(LoggingConfiguration conf) {\n    Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n    String pattern = StringUtils.defaultIfBlank(conf.getSubstitutionVariables().get(LoggingConfiguration.PROPERTY_FORMAT), LoggingConfiguration.FORMAT_DEFAULT);\n    String level = StringUtils.defaultIfBlank(conf.getSubstitutionVariables().get(LoggingConfiguration.PROPERTY_ROOT_LOGGER_LEVEL), LoggingConfiguration.LEVEL_ROOT_DEFAULT);\n\n    logger.detachAndStopAllAppenders();\n    logger.addAppender(createAppender(pattern, conf.getLogOutput()));\n    logger.setLevel(Level.toLevel(level));\n  }","id":38920,"modified_method":"private static void setCustomRootAppender(LoggingConfiguration conf) {\n    Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n    String level = StringUtils.defaultIfBlank(conf.getSubstitutionVariables().get(LoggingConfiguration.PROPERTY_ROOT_LOGGER_LEVEL), LoggingConfiguration.LEVEL_ROOT_DEFAULT);\n\n    if (logger.getAppender(CUSTOM_APPENDER_NAME) == null) {\n      logger.detachAndStopAllAppenders();\n      logger.addAppender(createAppender(conf.getLogOutput()));\n    }\n    logger.setLevel(Level.toLevel(level));\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static Appender<ILoggingEvent> createAppender(String pattern, LogOutput target) {\n    LogCallbackAppender appender = new LogCallbackAppender(target);\n    appender.setName(\"custom_stream\");\n    appender.start();\n\n    return appender;\n  }","id":38921,"modified_method":"private static Appender<ILoggingEvent> createAppender(LogOutput target) {\n    LogCallbackAppender appender = new LogCallbackAppender(target);\n    appender.setName(CUSTOM_APPENDER_NAME);\n    appender.start();\n\n    return appender;\n  }","commit_id":"ffbf06564219421bae3580215fff40cfe65adfc5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/** This method gets called everytime before any read/write to make sure\n     * that any change to localDirs is reflected immediately.\n     */\n    private synchronized void confChanged(Configuration conf) \n        throws IOException {\n      String newLocalDirs = conf.get(contextCfgItemName);\n      if (!newLocalDirs.equals(savedLocalDirs)) {\n        localDirs = conf.getTrimmedStrings(contextCfgItemName);\n        localFS = FileSystem.getLocal(conf);\n        int numDirs = localDirs.length;\n        ArrayList<String> dirs = new ArrayList<String>(numDirs);\n        ArrayList<DF> dfList = new ArrayList<DF>(numDirs);\n        for (int i = 0; i < numDirs; i++) {\n          try {\n            // filter problematic directories\n            Path tmpDir = new Path(localDirs[i]);\n            if(localFS.mkdirs(tmpDir)|| localFS.exists(tmpDir)) {\n              try {\n                DiskChecker.checkDir(new File(localDirs[i]));\n                dirs.add(localDirs[i]);\n                dfList.add(new DF(new File(localDirs[i]), 30000));\n              } catch (DiskErrorException de) {\n                LOG.warn( localDirs[i] + \" is not writable\\n\", de);\n              }\n            } else {\n              LOG.warn( \"Failed to create \" + localDirs[i]);\n            }\n          } catch (IOException ie) { \n            LOG.warn( \"Failed to create \" + localDirs[i] + \": \" +\n                ie.getMessage() + \"\\n\", ie);\n          } //ignore\n        }\n        localDirs = dirs.toArray(new String[dirs.size()]);\n        dirDF = dfList.toArray(new DF[dirs.size()]);\n        savedLocalDirs = newLocalDirs;\n        \n        // randomize the first disk picked in the round-robin selection \n        dirNumLastAccessed = dirIndexRandomizer.nextInt(dirs.size());\n      }\n    }","id":38922,"modified_method":"/** This method gets called everytime before any read/write to make sure\n     * that any change to localDirs is reflected immediately.\n     */\n    private synchronized void confChanged(Configuration conf) \n        throws IOException {\n      String newLocalDirs = conf.get(contextCfgItemName);\n      if (!newLocalDirs.equals(savedLocalDirs)) {\n        localDirs = conf.getTrimmedStrings(contextCfgItemName);\n        localFS = FileSystem.getLocal(conf);\n        int numDirs = localDirs.length;\n        ArrayList<String> dirs = new ArrayList<String>(numDirs);\n        ArrayList<DF> dfList = new ArrayList<DF>(numDirs);\n        for (int i = 0; i < numDirs; i++) {\n          try {\n            // filter problematic directories\n            Path tmpDir = new Path(localDirs[i]);\n            if(localFS.mkdirs(tmpDir)|| localFS.exists(tmpDir)) {\n              try {\n\n                File tmpFile = tmpDir.isAbsolute()\n                  ? new File(localFS.makeQualified(tmpDir).toUri())\n                  : new File(localDirs[i]);\n\n                DiskChecker.checkDir(tmpFile);\n                dirs.add(tmpFile.getPath());\n                dfList.add(new DF(tmpFile, 30000));\n\n              } catch (DiskErrorException de) {\n                LOG.warn( localDirs[i] + \" is not writable\\n\", de);\n              }\n            } else {\n              LOG.warn( \"Failed to create \" + localDirs[i]);\n            }\n          } catch (IOException ie) { \n            LOG.warn( \"Failed to create \" + localDirs[i] + \": \" +\n                ie.getMessage() + \"\\n\", ie);\n          } //ignore\n        }\n        localDirs = dirs.toArray(new String[dirs.size()]);\n        dirDF = dfList.toArray(new DF[dirs.size()]);\n        savedLocalDirs = newLocalDirs;\n        \n        // randomize the first disk picked in the round-robin selection \n        dirNumLastAccessed = dirIndexRandomizer.nextInt(dirs.size());\n      }\n    }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"private void validateTempDirCreation(int i) throws IOException {\n    File result = createTempFile(SMALL_FILE_SIZE);\n    assertTrue(\"Checking for \" + BUFFER_DIR[i] + \" in \" + result + \" - FAILED!\", \n        result.getPath().startsWith(new File(BUFFER_DIR[i], FILENAME).getPath()));\n  }","id":38923,"modified_method":"private static void validateTempDirCreation(String dir) throws IOException {\n    File result = createTempFile(SMALL_FILE_SIZE);\n    assertTrue(\"Checking for \" + dir + \" in \" + result + \" - FAILED!\",\n        result.getPath().startsWith(new Path(dir, FILENAME).toUri().getPath()));\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"private File createTempFile() throws IOException {\n    File result = dirAllocator.createTmpFileForWrite(FILENAME, -1, conf);\n    result.delete();\n    return result;\n  }","id":38924,"modified_method":"private static File createTempFile() throws IOException {\n    return createTempFile(-1);\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"/** Two buffer dirs. The first dir does not exist & is on a read-only disk; \n   * The second dir exists & is RW\n   * @throws Exception\n   */\n  public void test0() throws Exception {\n    if (isWindows) return;\n    try {\n      conf.set(CONTEXT, BUFFER_DIR[0]+\",\"+BUFFER_DIR[1]);\n      assertTrue(localFs.mkdirs(BUFFER_PATH[1]));\n      BUFFER_ROOT.setReadOnly();\n      validateTempDirCreation(1);\n      validateTempDirCreation(1);\n    } finally {\n      Shell.execCommand(new String[]{\"chmod\", \"u+w\", BUFFER_DIR_ROOT});\n      rmBufferDirs();\n    }\n  }","id":38925,"modified_method":"/** Two buffer dirs. The first dir does not exist & is on a read-only disk;\n   * The second dir exists & is RW\n   * @throws Exception\n   */\n  @Test\n  public void test0() throws Exception {\n    if (isWindows) return;\n    String dir0 = buildBufferDir(ROOT, 0);\n    String dir1 = buildBufferDir(ROOT, 1);\n    try {\n      conf.set(CONTEXT, dir0 + \",\" + dir1);\n      assertTrue(localFs.mkdirs(new Path(dir1)));\n      BUFFER_ROOT.setReadOnly();\n      validateTempDirCreation(dir1);\n      validateTempDirCreation(dir1);\n    } finally {\n      Shell.execCommand(new String[]{\"chmod\", \"u+w\", BUFFER_DIR_ROOT});\n      rmBufferDirs();\n    }\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"/** Two buffer dirs. Both exists and on a R/W disk. \n   * Later disk1 becomes read-only.\n   * @throws Exception\n   */\n  public void test3() throws Exception {\n    if (isWindows) return;\n    try {\n      conf.set(CONTEXT, BUFFER_DIR[3]+\",\"+BUFFER_DIR[4]);\n      assertTrue(localFs.mkdirs(BUFFER_PATH[3]));\n      assertTrue(localFs.mkdirs(BUFFER_PATH[4]));\n      \n      // create the first file with size, and then figure the round-robin sequence\n      createTempFile(SMALL_FILE_SIZE);\n\n      int nextDirIdx = (dirAllocator.getCurrentDirectoryIndex() == 0) ? 3 : 4;\n      validateTempDirCreation(nextDirIdx);\n\n      // change buffer directory 2 to be read only\n      new File(BUFFER_DIR[4]).setReadOnly();\n      validateTempDirCreation(3);\n      validateTempDirCreation(3);\n    } finally {\n      rmBufferDirs();\n    }\n  }","id":38926,"modified_method":"/** Two buffer dirs. Both exists and on a R/W disk.\n   * Later disk1 becomes read-only.\n   * @throws Exception\n   */\n  @Test\n  public void test3() throws Exception {\n    if (isWindows) return;\n    String dir3 = buildBufferDir(ROOT, 3);\n    String dir4 = buildBufferDir(ROOT, 4);\n    try {\n      conf.set(CONTEXT, dir3 + \",\" + dir4);\n      assertTrue(localFs.mkdirs(new Path(dir3)));\n      assertTrue(localFs.mkdirs(new Path(dir4)));\n\n      // Create the first small file\n      createTempFile(SMALL_FILE_SIZE);\n\n      // Determine the round-robin sequence\n      int nextDirIdx = (dirAllocator.getCurrentDirectoryIndex() == 0) ? 3 : 4;\n      validateTempDirCreation(buildBufferDir(ROOT, nextDirIdx));\n\n      // change buffer directory 2 to be read only\n      new File(new Path(dir4).toUri().getPath()).setReadOnly();\n      validateTempDirCreation(dir3);\n      validateTempDirCreation(dir3);\n    } finally {\n      rmBufferDirs();\n    }\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"/** Two buffer dirs. The first dir does not exist & is on a read-only disk; \n   * The second dir exists & is RW\n   * getLocalPathForWrite with checkAccess set to false should create a parent\n   * directory. With checkAccess true, the directory should not be created.\n   * @throws Exception\n   */\n  public void testLocalPathForWriteDirCreation() throws IOException {\n    try {\n      conf.set(CONTEXT, BUFFER_DIR[0] + \",\" + BUFFER_DIR[1]);\n      assertTrue(localFs.mkdirs(BUFFER_PATH[1]));\n      BUFFER_ROOT.setReadOnly();\n      Path p1 =\n          dirAllocator.getLocalPathForWrite(\"p1/x\", SMALL_FILE_SIZE, conf);\n      assertTrue(localFs.getFileStatus(p1.getParent()).isDirectory());\n\n      Path p2 =\n          dirAllocator.getLocalPathForWrite(\"p2/x\", SMALL_FILE_SIZE, conf,\n              false);\n      try {\n        localFs.getFileStatus(p2.getParent());\n      } catch (Exception e) {\n        assertEquals(e.getClass(), FileNotFoundException.class);\n      }\n    } finally {\n      Shell.execCommand(new String[] { \"chmod\", \"u+w\", BUFFER_DIR_ROOT });\n      rmBufferDirs();\n    }\n  }","id":38927,"modified_method":"/** Two buffer dirs. The first dir does not exist & is on a read-only disk;\n   * The second dir exists & is RW\n   * getLocalPathForWrite with checkAccess set to false should create a parent\n   * directory. With checkAccess true, the directory should not be created.\n   * @throws Exception\n   */\n  @Test\n  public void testLocalPathForWriteDirCreation() throws IOException {\n    String dir0 = buildBufferDir(ROOT, 0);\n    String dir1 = buildBufferDir(ROOT, 1);\n    try {\n      conf.set(CONTEXT, dir0 + \",\" + dir1);\n      assertTrue(localFs.mkdirs(new Path(dir1)));\n      BUFFER_ROOT.setReadOnly();\n      Path p1 =\n        dirAllocator.getLocalPathForWrite(\"p1/x\", SMALL_FILE_SIZE, conf);\n      assertTrue(localFs.getFileStatus(p1.getParent()).isDirectory());\n\n      Path p2 =\n        dirAllocator.getLocalPathForWrite(\"p2/x\", SMALL_FILE_SIZE, conf,\n            false);\n      try {\n        localFs.getFileStatus(p2.getParent());\n      } catch (Exception e) {\n        assertEquals(e.getClass(), FileNotFoundException.class);\n      }\n    } finally {\n      Shell.execCommand(new String[] { \"chmod\", \"u+w\", BUFFER_DIR_ROOT });\n      rmBufferDirs();\n    }\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"/** Two buffer dirs. The first dir exists & is on a read-only disk; \n   * The second dir exists & is RW\n   * @throws Exception\n   */\n  public void test1() throws Exception {\n    if (isWindows) return;\n    try {\n      conf.set(CONTEXT, BUFFER_DIR[1]+\",\"+BUFFER_DIR[2]);\n      assertTrue(localFs.mkdirs(BUFFER_PATH[2]));\n      BUFFER_ROOT.setReadOnly();\n      validateTempDirCreation(2);\n      validateTempDirCreation(2);\n    } finally {\n      Shell.execCommand(new String[]{\"chmod\", \"u+w\", BUFFER_DIR_ROOT});\n      rmBufferDirs();\n    }\n  }","id":38928,"modified_method":"/** Two buffer dirs. The first dir exists & is on a read-only disk;\n   * The second dir exists & is RW\n   * @throws Exception\n   */\n  @Test\n  public void test1() throws Exception {\n    if (isWindows) return;\n    String dir1 = buildBufferDir(ROOT, 1);\n    String dir2 = buildBufferDir(ROOT, 2);\n    try {\n      conf.set(CONTEXT, dir1 + \",\" + dir2);\n      assertTrue(localFs.mkdirs(new Path(dir2)));\n      BUFFER_ROOT.setReadOnly();\n      validateTempDirCreation(dir2);\n      validateTempDirCreation(dir2);\n    } finally {\n      Shell.execCommand(new String[]{\"chmod\", \"u+w\", BUFFER_DIR_ROOT});\n      rmBufferDirs();\n    }\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"public void test4() throws Exception {\n    if (isWindows) return;\n    try {\n\n      conf.set(CONTEXT, BUFFER_DIR[5]+\",\"+BUFFER_DIR[6]);\n      assertTrue(localFs.mkdirs(BUFFER_PATH[5]));\n      assertTrue(localFs.mkdirs(BUFFER_PATH[6]));\n        \n      int inDir5=0, inDir6=0;\n      for(int i = 0; i < TRIALS; ++i) {\n        File result = createTempFile();\n        if(result.getPath().startsWith(new File(BUFFER_DIR[5], FILENAME).getPath())) {\n          inDir5++;\n        } else  if(result.getPath().startsWith(new File(BUFFER_DIR[6], FILENAME).getPath())) {\n          inDir6++;\n        }\n        result.delete();\n      }\n      \n      assertTrue( inDir5 + inDir6 == TRIALS);\n        \n    } finally {\n      rmBufferDirs();\n    }\n  }","id":38929,"modified_method":"@Test\n  public void test4() throws Exception {\n    if (isWindows) return;\n    String dir5 = buildBufferDir(ROOT, 5);\n    String dir6 = buildBufferDir(ROOT, 6);\n    try {\n\n      conf.set(CONTEXT, dir5 + \",\" + dir6);\n      assertTrue(localFs.mkdirs(new Path(dir5)));\n      assertTrue(localFs.mkdirs(new Path(dir6)));\n\n      int inDir5=0, inDir6=0;\n      for(int i = 0; i < TRIALS; ++i) {\n        File result = createTempFile();\n        if(result.getPath().startsWith(\n              new Path(dir5, FILENAME).toUri().getPath())) {\n          inDir5++;\n        } else if(result.getPath().startsWith(\n              new Path(dir6, FILENAME).toUri().getPath())) {\n          inDir6++;\n        }\n        result.delete();\n      }\n\n      assertTrue(inDir5 + inDir6 == TRIALS);\n\n    } finally {\n      rmBufferDirs();\n    }\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"/** Two buffer dirs. Both do not exist but on a RW disk.\n   * Check if tmp dirs are allocated in a round-robin \n   */\n  public void test2() throws Exception {\n    if (isWindows) return;\n    try {\n      conf.set(CONTEXT, BUFFER_DIR[2]+\",\"+BUFFER_DIR[3]);\n\n      // create the first file, and then figure the round-robin sequence\n      createTempFile(SMALL_FILE_SIZE);\n      int firstDirIdx = (dirAllocator.getCurrentDirectoryIndex() == 0) ? 2 : 3;\n      int secondDirIdx = (firstDirIdx == 2) ? 3 : 2;\n      \n      // check if tmp dirs are allocated in a round-robin manner\n      validateTempDirCreation(firstDirIdx);\n      validateTempDirCreation(secondDirIdx);\n      validateTempDirCreation(firstDirIdx);\n    } finally {\n      rmBufferDirs();\n    }\n  }","id":38930,"modified_method":"/** Two buffer dirs. Both do not exist but on a RW disk.\n   * Check if tmp dirs are allocated in a round-robin\n   */\n  @Test\n  public void test2() throws Exception {\n    if (isWindows) return;\n    String dir2 = buildBufferDir(ROOT, 2);\n    String dir3 = buildBufferDir(ROOT, 3);\n    try {\n      conf.set(CONTEXT, dir2 + \",\" + dir3);\n\n      // create the first file, and then figure the round-robin sequence\n      createTempFile(SMALL_FILE_SIZE);\n      int firstDirIdx = (dirAllocator.getCurrentDirectoryIndex() == 0) ? 2 : 3;\n      int secondDirIdx = (firstDirIdx == 2) ? 3 : 2;\n\n      // check if tmp dirs are allocated in a round-robin manner\n      validateTempDirCreation(buildBufferDir(ROOT, firstDirIdx));\n      validateTempDirCreation(buildBufferDir(ROOT, secondDirIdx));\n      validateTempDirCreation(buildBufferDir(ROOT, firstDirIdx));\n    } finally {\n      rmBufferDirs();\n    }\n  }","commit_id":"d50ecc38a3e0f5405bcf14b22934e7a89a190f6e","url":"https://github.com/apache/hadoop"},{"original_method":"public Document getDocument() {\n    if (myDocument != null) return myDocument;\n    if (isBinary()) return null;\n    try {\n      String text = LineTokenizer.correctLineSeparators(new String(myBytes, myCharset));\n      myDocument = EditorFactory.getInstance().createDocument(text);\n      myDocument.setReadOnly(true);\n    }\n    catch (UnsupportedEncodingException e) {\n      LOG.error(e);\n    }\n    return myDocument;\n  }","id":38931,"modified_method":"@SuppressWarnings({\"EmptyCatchBlock\"})\n  @Nullable\n  public Document getDocument() {\n    if( myDocument == null )\n    {\n      if( isBinary() ) return null;\n\n      String text = null;\n      try {\n        if( CharsetSettings.SYSTEM_DEFAULT_CHARSET_NAME.equals( myCharset ))\n          text = new String(myBytes);\n        else\n          text = new String( myBytes, myCharset );\n      }\n      catch( UnsupportedEncodingException e ) {}\n      catch( IllegalCharsetNameException e )  {}\n\n      //  Still NULL? only if not supported or an exception was thrown.\n      //  Decode a string using the truly default encoding.\n      if( text == null )\n          text = new String( myBytes );\n      text = LineTokenizer.correctLineSeparators( text );\n\n      myDocument = EditorFactory.getInstance().createDocument( text );\n      myDocument.setReadOnly( true );\n    }\n    return myDocument;\n  }","commit_id":"8e70b3511824768801613dc9d3707654ca020ad1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String _formatP(String s) {\n\t\tStringBuilder sb = new StringBuilder(s.toLowerCase());\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\n\t\t\tif (Character.isUpperCase(c) && (i > 0) &&\n\t\t\t\t((i + 1) < s.length())) {\n\n\t\t\t\tif (Character.isUpperCase(c) &&\n\t\t\t\t\tCharacter.isLowerCase(s.charAt(i + 1))) {\n\n\t\t\t\t\tsb.insert(i, CharPool.DASH);\n\t\t\t\t}\n\t\t\t\telse if (Character.isLowerCase(s.charAt(i - 1)) &&\n\t\t\t\t\t\t Character.isUpperCase(c)) {\n\n\t\t\t\t\tsb.insert(i, CharPool.DASH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":38932,"modified_method":"private static String _formatP(String s) {\n\t\tStringBuilder sb = new StringBuilder(s.toLowerCase());\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\n\t\t\tif (Character.isUpperCase(c) && (i > 0) &&\n\t\t\t\t((i + 1) < s.length())) {\n\n\t\t\t\tint diff = sb.length() - s.length();\n\n\t\t\t\tif (Character.isLowerCase(s.charAt(i + 1))) {\n\t\t\t\t\tsb.insert(i + diff, CharPool.DASH);\n\t\t\t\t}\n\t\t\t\telse if (Character.isLowerCase(s.charAt(i - 1))) {\n\t\t\t\t\tsb.insert(i + diff, CharPool.DASH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"64eb75de13dff6a1ca47cf1d6cf128202fec99bc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String getCaseCorrectedLookupString(LookupElement item) {\n    String lookupString = item.getLookupString();\n    if (item.isCaseSensitive()) {\n      return lookupString;\n    }\n    \n    final String prefix = itemPattern(item);\n    final int length = prefix.length();\n    if (length == 0 || !StringUtil.startsWithIgnoreCase(lookupString, prefix)) return lookupString;\n    boolean isAllLower = true;\n    boolean isAllUpper = true;\n    boolean sameCase = true;\n    for (int i = 0; i < length && (isAllLower || isAllUpper || sameCase); i++) {\n      final char c = prefix.charAt(i);\n      isAllLower = isAllLower && Character.isLowerCase(c);\n      isAllUpper = isAllUpper && Character.isUpperCase(c);\n      sameCase = sameCase && Character.isLowerCase(c) == Character.isLowerCase(lookupString.charAt(i));\n    }\n    if (sameCase) return lookupString;\n    if (isAllLower) return lookupString.toLowerCase();\n    if (isAllUpper) return lookupString.toUpperCase();\n    return lookupString;\n  }","id":38933,"modified_method":"private String getCaseCorrectedLookupString(LookupElement item) {\n    String lookupString = item.getLookupString();\n    if (item.isCaseSensitive()) {\n      return lookupString;\n    }\n    \n    final String prefix = itemPattern(item);\n    final int length = prefix.length();\n    if (length == 0 || !StringUtil.startsWithIgnoreCase(lookupString, prefix)) return lookupString;\n    boolean isAllLower = true;\n    boolean isAllUpper = true;\n    boolean sameCase = true;\n    for (int i = 0; i < length && (isAllLower || isAllUpper || sameCase); i++) {\n      final char c = prefix.charAt(i);\n      boolean isLower = Character.isLowerCase(c);\n      boolean isUpper = Character.isUpperCase(c);\n      // do not take this kind of symbols into account ('_', '@', etc.)\n      if (!isLower && !isUpper) continue;\n      isAllLower = isAllLower && isLower;\n      isAllUpper = isAllUpper && isUpper;\n      sameCase = sameCase && isLower == Character.isLowerCase(lookupString.charAt(i));\n    }\n    if (sameCase) return lookupString;\n    if (isAllLower) return lookupString.toLowerCase();\n    if (isAllUpper) return lookupString.toUpperCase();\n    return lookupString;\n  }","commit_id":"905e1c65e25f2c9b183ae89b79834ec977195275","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract boolean consumeSemanticChildNodes(EObject semanticNode);","id":38934,"modified_method":"@Inject\n\tpublic AbstractSemanticModelTransformer(ILabelProvider labelProvider) {\n\t\tthis.labelProvider = labelProvider;\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean consumeSemanticNode(EObject semanticNode) {\n\t\tif (semanticNode != null) {\n\t\t\tString name = semanticNode.eClass().getName();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Consume semantic node type [\" + name + \"]?\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":38935,"modified_method":"@Inject\n\tpublic DefaultSemanticModelTransformer(ILocationInFileProvider locationProvider, ILabelProvider labelProvider) {\n\t\tsuper(labelProvider);\n\t\tthis.locationProvider = locationProvider;\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ISemanticModelTransformer getSemanticModelTransformer() {\n\t\treturn get(ISemanticModelTransformer.class);\n\t}","id":38936,"modified_method":"protected DefaultSemanticModelTransformer getSemanticModelTransformer() {\n\t\treturn new DefaultSemanticModelTransformer(new DefaultLocationInFileProvider(), new DefaultLabelProvider());\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testGetText() {\n\t\tDefaultSemanticModelTransformer transformer = (DefaultSemanticModelTransformer) getSemanticModelTransformer();\n\t\tString a1Text = transformer.getText(a1);\n\t\tassertEquals(\"A1\", a1Text);\n\t\tString a2Text = transformer.getText(a2);\n\t\tassertEquals(\"A2\", a2Text);\n\t}","id":38937,"modified_method":"public void testGetText() {\n\t\tDefaultSemanticModelTransformer transformer = getSemanticModelTransformer();\n\t\tString a1Text = transformer.getText(a1);\n\t\tassertEquals(\"A1\", a1Text);\n\t\tString a2Text = transformer.getText(a2);\n\t\tassertEquals(\"A2\", a2Text);\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\twith(new XtextGrammarTestLanguageUIModule(), new XtextGrammarTestLanguageRuntimeModule());\n\t\t\n\t\tXtextResourceSet resourceSet = new XtextResourceSet();\n\t\tresourceSet.setClasspathURIContext(getClass());\n\t\tresourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(\n\t\t\t\tResource.Factory.Registry.DEFAULT_EXTENSION, new XMIResourceFactoryImpl());\n\t\tResource resource = resourceSet.createResource(URI\n\t\t\t\t.createURI(\"classpath:/org/eclipse/xtext/ui/common/editor/outline/impl/simplestructure.xmi\"));\n\t\tresource.load(null);\n\t\troot = resource.getContents().get(0);\n\t\ta1 = root.eContents().get(0);\n\t\ta2 = root.eContents().get(1);\n\t}","id":38938,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tXtextResourceSet resourceSet = new XtextResourceSet();\n\t\tresourceSet.setClasspathURIContext(getClass());\n\t\tresourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(\n\t\t\t\tResource.Factory.Registry.DEFAULT_EXTENSION, new XMIResourceFactoryImpl());\n\t\tResource resource = resourceSet.createResource(URI\n\t\t\t\t.createURI(\"classpath:/org/eclipse/xtext/ui/common/editor/outline/impl/simplestructure.xmi\"));\n\t\tresource.load(null);\n\t\troot = resource.getContents().get(0);\n\t\ta1 = root.eContents().get(0);\n\t\ta2 = root.eContents().get(1);\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testNullSafety() {\n\t\tDefaultSemanticModelTransformer transformer = (DefaultSemanticModelTransformer) getSemanticModelTransformer();\n\t\tassertFalse(transformer.consumeSemanticChildNodes(null));\n\t\tassertFalse(transformer.consumeSemanticNode(null));\n\t\tassertEquals(\"<unknown>\", transformer.getText(null));\n\t}","id":38939,"modified_method":"public void testNullSafety() {\n\t\tDefaultSemanticModelTransformer transformer = getSemanticModelTransformer();\n\t\tassertFalse(transformer.consumeSemanticChildNodes(null));\n\t\tassertFalse(transformer.consumeSemanticNode(null));\n\t\tassertEquals(\"<unknown>\", transformer.getText(null));\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic String getText(EObject object) {\n\t\treturn provider.getText(object);\n\t}","id":38940,"modified_method":"public EcoreSemanticModelTransformer(ILocationInFileProvider locationProvider, ILabelProvider labelProvider) {\n\t\tsuper(locationProvider,labelProvider);\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic boolean consumeSemanticNode(EObject semanticNode) {\n\t\tif (semanticNode != null) {\n\t\t\treturn new XtextSwitch<Boolean>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Boolean caseTypeRef(org.eclipse.xtext.TypeRef object) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\tpublic Boolean caseGroup(org.eclipse.xtext.Group object) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Boolean defaultCase(EObject object) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}.doSwitch(semanticNode);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}","id":38941,"modified_method":"public XtextSemanticModelTransformer(ILocationInFileProvider locationProvider, ILabelProvider labelProvider) {\n\t\tsuper(locationProvider, labelProvider);\n\t}","commit_id":"5f2d803297f18de3f76e0b21b2373ec4e7c41f27","url":"https://github.com/eclipse/xtext"},{"original_method":"protected abstract boolean consumeSemanticChildNodes(EObject semanticNode);","id":38942,"modified_method":"@Inject\n\tpublic AbstractSemanticModelTransformer(ILabelProvider labelProvider) {\n\t\tthis.labelProvider = labelProvider;\n\t}","commit_id":"0ba4913b221a0d75c5a6f1336f36b7e4bbda801b","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean consumeSemanticNode(EObject semanticNode) {\n\t\tif (semanticNode != null) {\n\t\t\tString name = semanticNode.eClass().getName();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Consume semantic node type [\" + name + \"]?\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":38943,"modified_method":"@Inject\n\tpublic DefaultSemanticModelTransformer(ILocationInFileProvider locationProvider, ILabelProvider labelProvider) {\n\t\tsuper(labelProvider);\n\t\tthis.locationProvider = locationProvider;\n\t}","commit_id":"0ba4913b221a0d75c5a6f1336f36b7e4bbda801b","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testNullSafety() {\n\t\tDefaultSemanticModelTransformer transformer = (DefaultSemanticModelTransformer) getSemanticModelTransformer();\n\t\tassertFalse(transformer.consumeSemanticChildNodes(null));\n\t\tassertFalse(transformer.consumeSemanticNode(null));\n\t\tassertEquals(\"<unknown>\", transformer.getText(null));\n\t}","id":38944,"modified_method":"public void testNullSafety() {\n\t\tDefaultSemanticModelTransformer transformer = getSemanticModelTransformer();\n\t\tassertFalse(transformer.consumeSemanticChildNodes(null));\n\t\tassertFalse(transformer.consumeSemanticNode(null));\n\t\tassertEquals(\"<unknown>\", transformer.getText(null));\n\t}","commit_id":"0ba4913b221a0d75c5a6f1336f36b7e4bbda801b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\twith(new XtextGrammarTestLanguageUIModule(), new XtextGrammarTestLanguageRuntimeModule());\n\t\t\n\t\tXtextResourceSet resourceSet = new XtextResourceSet();\n\t\tresourceSet.setClasspathURIContext(getClass());\n\t\tresourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(\n\t\t\t\tResource.Factory.Registry.DEFAULT_EXTENSION, new XMIResourceFactoryImpl());\n\t\tResource resource = resourceSet.createResource(URI\n\t\t\t\t.createURI(\"classpath:/org/eclipse/xtext/ui/common/editor/outline/impl/simplestructure.xmi\"));\n\t\tresource.load(null);\n\t\troot = resource.getContents().get(0);\n\t\ta1 = root.eContents().get(0);\n\t\ta2 = root.eContents().get(1);\n\t}","id":38945,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tXtextResourceSet resourceSet = new XtextResourceSet();\n\t\tresourceSet.setClasspathURIContext(getClass());\n\t\tresourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(\n\t\t\t\tResource.Factory.Registry.DEFAULT_EXTENSION, new XMIResourceFactoryImpl());\n\t\tResource resource = resourceSet.createResource(URI\n\t\t\t\t.createURI(\"classpath:/org/eclipse/xtext/ui/common/editor/outline/impl/simplestructure.xmi\"));\n\t\tresource.load(null);\n\t\troot = resource.getContents().get(0);\n\t\ta1 = root.eContents().get(0);\n\t\ta2 = root.eContents().get(1);\n\t}","commit_id":"0ba4913b221a0d75c5a6f1336f36b7e4bbda801b","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ISemanticModelTransformer getSemanticModelTransformer() {\n\t\treturn get(ISemanticModelTransformer.class);\n\t}","id":38946,"modified_method":"protected DefaultSemanticModelTransformer getSemanticModelTransformer() {\n\t\treturn new DefaultSemanticModelTransformer(new DefaultLocationInFileProvider(), new DefaultLabelProvider());\n\t}","commit_id":"0ba4913b221a0d75c5a6f1336f36b7e4bbda801b","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testGetText() {\n\t\tDefaultSemanticModelTransformer transformer = (DefaultSemanticModelTransformer) getSemanticModelTransformer();\n\t\tString a1Text = transformer.getText(a1);\n\t\tassertEquals(\"A1\", a1Text);\n\t\tString a2Text = transformer.getText(a2);\n\t\tassertEquals(\"A2\", a2Text);\n\t}","id":38947,"modified_method":"public void testGetText() {\n\t\tDefaultSemanticModelTransformer transformer = getSemanticModelTransformer();\n\t\tString a1Text = transformer.getText(a1);\n\t\tassertEquals(\"A1\", a1Text);\n\t\tString a2Text = transformer.getText(a2);\n\t\tassertEquals(\"A2\", a2Text);\n\t}","commit_id":"0ba4913b221a0d75c5a6f1336f36b7e4bbda801b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic String getText(EObject object) {\n\t\treturn provider.getText(object);\n\t}","id":38948,"modified_method":"public EcoreSemanticModelTransformer(ILocationInFileProvider locationProvider, ILabelProvider labelProvider) {\n\t\tsuper(locationProvider,labelProvider);\n\t}","commit_id":"0ba4913b221a0d75c5a6f1336f36b7e4bbda801b","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\tif ((pageContext == null) || (key == null)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tPortletConfig portletConfig = (PortletConfig)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_PORTLET_CONFIG);\n\n\t\tLocale locale = _getLocale(request);\n\n\t\tif (portletConfig == null) {\n\t\t\treturn get(locale, key, defaultValue);\n\t\t}\n\n\t\tResourceBundle resourceBundle = portletConfig.getResourceBundle(locale);\n\n\t\tif (resourceBundle.containsKey(key)) {\n\t\t\treturn _get(resourceBundle, key);\n\t\t}\n\n\t\treturn get(locale, key, defaultValue);\n\t}","id":38949,"modified_method":"@Override\n\tpublic String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\tif ((pageContext == null) || (key == null)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tString value = null;\n\n\t\tResourceBundle resourceBundle = _getResourceBundle(pageContext);\n\n\t\tif (resourceBundle != null) {\n\t\t\tvalue = _get(resourceBundle, key);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tLocale locale = _getLocale(request);\n\n\t\t\tvalue = _get(LanguageResources.getResourceBundle(locale), key);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tvalue = defaultValue;\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"4dab7ee588abdb87482f0a7410c3710578ca51ab","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(Locale locale, String key, String defaultValue) {\n\t\tif (PropsValues.TRANSLATIONS_DISABLED) {\n\t\t\treturn key;\n\t\t}\n\n\t\tif ((locale == null) || (key == null)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tString value = LanguageResources.getMessage(locale, key);\n\n\t\tif (value != null) {\n\t\t\treturn LanguageResources.fixValue(value);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tif ((key.length() > 0) &&\n\t\t\t\t(key.charAt(key.length() - 1) == CharPool.CLOSE_BRACKET)) {\n\n\t\t\t\tint pos = key.lastIndexOf(CharPool.OPEN_BRACKET);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tkey = key.substring(0, pos);\n\n\t\t\t\t\treturn get(locale, key, defaultValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":38950,"modified_method":"@Override\n\tpublic String get(Locale locale, String key, String defaultValue) {\n\t\tResourceBundle resourceBundle = LanguageResources.getResourceBundle(\n\t\t\tlocale);\n\n\t\treturn _get(resourceBundle, key, defaultValue);\n\t}","commit_id":"4dab7ee588abdb87482f0a7410c3710578ca51ab","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(\n\t\tResourceBundle resourceBundle, String key, String defaultValue) {\n\n\t\ttry {\n\t\t\tString value = _get(resourceBundle, key);\n\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\tcatch (MissingResourceException mre) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(mre, mre);\n\t\t\t}\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":38951,"modified_method":"@Override\n\tpublic String get(\n\t\tResourceBundle resourceBundle, String key, String defaultValue) {\n\n\t\ttry {\n\t\t\tString value = _get(resourceBundle, key, defaultValue);\n\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\n\t\t\treturn defaultValue;\n\t\t}\n\t}","commit_id":"4dab7ee588abdb87482f0a7410c3710578ca51ab","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\ttry {\n\t\t\tResourceBundle resourceBundle = _getResourceBundle(pageContext);\n\n\t\t\treturn _get(resourceBundle, key, defaultValue);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\n\t\t\treturn defaultValue;\n\t\t}\n\t}","id":38952,"modified_method":"@Override\n\tpublic String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\tif (pageContext == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tPortletConfig portletConfig = (PortletConfig)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_PORTLET_CONFIG);\n\n\t\tLocale locale = _getLocale(request);\n\n\t\tif (portletConfig == null) {\n\t\t\treturn get(locale, key, defaultValue);\n\t\t}\n\n\t\tResourceBundle resourceBundle = portletConfig.getResourceBundle(locale);\n\n\t\tif (resourceBundle.containsKey(key)) {\n\t\t\treturn _get(resourceBundle, key);\n\t\t}\n\n\t\treturn get(locale, key, defaultValue);\n\t}","commit_id":"7ca4fea8f9a51346c48cedac3546c8fb9b8a080b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(\n\t\tResourceBundle resourceBundle, String key, String defaultValue) {\n\n\t\ttry {\n\t\t\treturn _get(resourceBundle, key, defaultValue);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\n\t\t\treturn defaultValue;\n\t\t}\n\t}","id":38953,"modified_method":"@Override\n\tpublic String get(\n\t\tResourceBundle resourceBundle, String key, String defaultValue) {\n\n\t\ttry {\n\t\t\tString value = _get(resourceBundle, key);\n\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\tcatch (MissingResourceException mre) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(mre, mre);\n\t\t\t}\n\t\t}\n\n\t\treturn defaultValue;\n\t}","commit_id":"7ca4fea8f9a51346c48cedac3546c8fb9b8a080b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(Locale locale, String key, String defaultValue) {\n\t\tResourceBundle resourceBundle = LanguageResources.getResourceBundle(\n\t\t\tlocale);\n\n\t\ttry {\n\t\t\treturn _get(resourceBundle, key, defaultValue);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}","id":38954,"modified_method":"@Override\n\tpublic String get(Locale locale, String key, String defaultValue) {\n\t\tif (PropsValues.TRANSLATIONS_DISABLED) {\n\t\t\treturn key;\n\t\t}\n\n\t\tif ((locale == null) || (key == null)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tString value = LanguageResources.getMessage(locale, key);\n\n\t\tif (value != null) {\n\t\t\treturn LanguageResources.fixValue(value);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tif ((key.length() > 0) &&\n\t\t\t\t(key.charAt(key.length() - 1) == CharPool.CLOSE_BRACKET)) {\n\n\t\t\t\tint pos = key.lastIndexOf(CharPool.OPEN_BRACKET);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tkey = key.substring(0, pos);\n\n\t\t\t\t\treturn get(locale, key, defaultValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn defaultValue;\n\t}","commit_id":"7ca4fea8f9a51346c48cedac3546c8fb9b8a080b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(\n\t\tResourceBundle resourceBundle, String key, String defaultValue) {\n\n\t\ttry {\n\t\t\tString value = _get(resourceBundle, key, defaultValue);\n\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\n\t\t\treturn defaultValue;\n\t\t}\n\t}","id":38955,"modified_method":"@Override\n\tpublic String get(\n\t\tResourceBundle resourceBundle, String key, String defaultValue) {\n\n\t\tString value = _get(resourceBundle, key);\n\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn defaultValue;\n\t}","commit_id":"3bce22e61bdc13d3ba20d1b3e123bc51a5728cde","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(Locale locale, String key, String defaultValue) {\n\t\tResourceBundle resourceBundle = LanguageResources.getResourceBundle(\n\t\t\tlocale);\n\n\t\treturn _get(resourceBundle, key, defaultValue);\n\t}","id":38956,"modified_method":"@Override\n\tpublic String get(Locale locale, String key, String defaultValue) {\n\t\tResourceBundle resourceBundle = LanguageResources.getResourceBundle(\n\t\t\tlocale);\n\n\t\treturn get(resourceBundle, key, defaultValue);\n\t}","commit_id":"3bce22e61bdc13d3ba20d1b3e123bc51a5728cde","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _get(ResourceBundle resourceBundle, String key) {\n\t\tif (PropsValues.TRANSLATIONS_DISABLED) {\n\t\t\treturn key;\n\t\t}\n\n\t\tif ((resourceBundle == null) || (key == null)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!resourceBundle.containsKey(key)) {\n\t\t\tif ((key.length() > 0) &&\n\t\t\t\t(key.charAt(key.length() - 1) == CharPool.CLOSE_BRACKET)) {\n\n\t\t\t\tint pos = key.lastIndexOf(CharPool.OPEN_BRACKET);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tkey = key.substring(0, pos);\n\n\t\t\t\t\treturn _get(resourceBundle, key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString value = ResourceBundleUtil.getString(resourceBundle, key);\n\n\t\tif (value != null) {\n\t\t\treturn LanguageResources.fixValue(value);\n\t\t}\n\n\t\treturn value;\n\t}","id":38957,"modified_method":"private String _get(ResourceBundle resourceBundle, String key) {\n\t\tif (PropsValues.TRANSLATIONS_DISABLED) {\n\t\t\treturn key;\n\t\t}\n\n\t\tif ((resourceBundle == null) || (key == null)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString value = ResourceBundleUtil.getString(resourceBundle, key);\n\n\t\tif (value != null) {\n\t\t\treturn LanguageResources.fixValue(value);\n\t\t}\n\n\t\tif ((key.length() > 0) &&\n\t\t\t(key.charAt(key.length() - 1) == CharPool.CLOSE_BRACKET)) {\n\n\t\t\tint pos = key.lastIndexOf(CharPool.OPEN_BRACKET);\n\n\t\t\tif (pos != -1) {\n\t\t\t\tkey = key.substring(0, pos);\n\n\t\t\t\treturn _get(resourceBundle, key);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"3bce22e61bdc13d3ba20d1b3e123bc51a5728cde","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\tif ((pageContext == null) || (key == null)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tString value = null;\n\n\t\tResourceBundle resourceBundle = _getResourceBundle(pageContext);\n\n\t\tif (resourceBundle != null) {\n\t\t\tvalue = _get(resourceBundle, key);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tHttpServletRequest request =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tLocale locale = _getLocale(request);\n\n\t\t\tvalue = _get(LanguageResources.getResourceBundle(locale), key);\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tvalue = defaultValue;\n\t\t}\n\n\t\treturn value;\n\t}","id":38958,"modified_method":"@Override\n\tpublic String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\tif ((pageContext == null) || (key == null)) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tPortletConfig portletConfig = (PortletConfig)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_PORTLET_CONFIG);\n\n\t\tLocale locale = _getLocale(request);\n\n\t\tif (portletConfig == null) {\n\t\t\treturn get(locale, key, defaultValue);\n\t\t}\n\n\t\tResourceBundle resourceBundle = portletConfig.getResourceBundle(locale);\n\n\t\tif (resourceBundle.containsKey(key)) {\n\t\t\treturn _get(resourceBundle, key);\n\t\t}\n\n\t\treturn get(locale, key, defaultValue);\n\t}","commit_id":"3bce22e61bdc13d3ba20d1b3e123bc51a5728cde","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected JweDecryptionProvider getInitializedDecryption() {\n        if (decryption != null) {\n            return decryption;    \n        } \n        try {\n            PrivateKey pk = CryptoUtils.loadPrivateKey(JAXRSUtils.getCurrentMessage(), \n                                                       RSSEC_ENCRYPTION_IN_PROPS, \n                                                       RSSEC_ENCRYPTION_PROPS,\n                                                       CryptoUtils.RSSEC_DECRYPT_KEY_PSWD_PROVIDER);\n            return new WrappedKeyJweDecryption(pk, cryptoProperties);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":38959,"modified_method":"protected JweDecryptionProvider getInitializedDecryptionProvider() {\n        if (decryption != null) {\n            return decryption;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, RSSEC_ENCRYPTION_IN_PROPS, RSSEC_ENCRYPTION_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            RSAPrivateKey pk = null;\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(CryptoUtils.RSSEC_KEY_STORE_TYPE))) {\n                //TODO: Private JWK sets can be JWE encrypted\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props);\n                pk = jwk.toRSAPrivateKey();\n            } else {\n                pk = (RSAPrivateKey)CryptoUtils.loadPrivateKey(m, props, \n                                                              CryptoUtils.RSSEC_DECRYPT_KEY_PSWD_PROVIDER);\n            }\n            return new WrappedKeyJweDecryption(pk, cryptoProperties);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n        \n    }","commit_id":"08e47a272be0cdaf769d4392ab8be845dade0668","url":"https://github.com/apache/cxf"},{"original_method":"protected JweDecryptionOutput decrypt(InputStream is) throws IOException {\n        JweDecryptionProvider theDecryptor = getInitializedDecryption();\n        JweDecryptionOutput out = theDecryptor.decrypt(new String(IOUtils.readBytesFromStream(is), \"UTF-8\"));\n        validateHeaders(out.getHeaders());\n        return out;\n    }","id":38960,"modified_method":"protected JweDecryptionOutput decrypt(InputStream is) throws IOException {\n        JweDecryptionProvider theDecryptor = getInitializedDecryptionProvider();\n        JweDecryptionOutput out = theDecryptor.decrypt(new String(IOUtils.readBytesFromStream(is), \"UTF-8\"));\n        validateHeaders(out.getHeaders());\n        return out;\n    }","commit_id":"08e47a272be0cdaf769d4392ab8be845dade0668","url":"https://github.com/apache/cxf"},{"original_method":"protected JwsSignatureVerifier getInitializedSigVerifier() {\n        if (sigVerifier != null) {\n            return sigVerifier;    \n        } \n        try {\n            PublicKey pk = CryptoUtils.loadPublicKey(JAXRSUtils.getCurrentMessage(), \n                                                     RSSEC_SIGNATURE_IN_PROPS,\n                                                     RSSEC_SIGNATURE_PROPS);\n            return new PublicKeyJwsSignatureVerifier(pk);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":38961,"modified_method":"protected JwsSignatureVerifier getInitializedSigVerifier() {\n        if (sigVerifier != null) {\n            return sigVerifier;    \n        } \n        \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, RSSEC_SIGNATURE_IN_PROPS, RSSEC_SIGNATURE_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            RSAPublicKey pk = null;\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(CryptoUtils.RSSEC_KEY_STORE_TYPE))) {\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props);\n                pk = jwk.toRSAPublicKey();\n            } else {\n                pk = (RSAPublicKey)CryptoUtils.loadPublicKey(m, props);\n            }\n            return new PublicKeyJwsSignatureVerifier(pk);\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"08e47a272be0cdaf769d4392ab8be845dade0668","url":"https://github.com/apache/cxf"},{"original_method":"protected JwsSignatureProvider getInitializedSigProvider() {\n        if (sigProvider != null) {\n            return sigProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, RSSEC_SIGNATURE_OUT_PROPS, RSSEC_SIGNATURE_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        try {\n            Properties props = ResourceUtils.loadProperties(propLoc, m.getExchange().getBus());\n            PrivateKey pk = CryptoUtils.loadPrivateKey(m, props, CryptoUtils.RSSEC_SIG_KEY_PSWD_PROVIDER);\n            if (!(pk instanceof RSAPrivateKey)) {\n                throw new SecurityException();\n            }\n            PrivateKeyJwsSignatureProvider provider = new PrivateKeyJwsSignatureProvider(pk);\n            provider.setDefaultJwtAlgorithm(props.getProperty(JSON_WEB_SIGNATURE_ALGO_PROP));\n            return provider;\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":38962,"modified_method":"protected JwsSignatureProvider getInitializedSigProvider() {\n        if (sigProvider != null) {\n            return sigProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, RSSEC_SIGNATURE_OUT_PROPS, RSSEC_SIGNATURE_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        try {\n            RSAPrivateKey pk = null;\n            Properties props = ResourceUtils.loadProperties(propLoc, m.getExchange().getBus());\n            String rsaSignatureAlgo = null;\n            if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(CryptoUtils.RSSEC_KEY_STORE_TYPE))) {\n                //TODO: Private JWK sets can be JWE encrypted\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props);\n                pk = jwk.toRSAPrivateKey();\n                rsaSignatureAlgo = jwk.getAlgorithm();\n            } else {\n                pk = (RSAPrivateKey)CryptoUtils.loadPrivateKey(m, props, \n                                                              CryptoUtils.RSSEC_SIG_KEY_PSWD_PROVIDER);\n            }\n            if (rsaSignatureAlgo == null) {\n                rsaSignatureAlgo = props.getProperty(JSON_WEB_SIGNATURE_ALGO_PROP);\n            }\n            PrivateKeyJwsSignatureProvider provider = new PrivateKeyJwsSignatureProvider(pk);\n            provider.setDefaultJwtAlgorithm(rsaSignatureAlgo);\n            return provider;\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"08e47a272be0cdaf769d4392ab8be845dade0668","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPublicSetAsMap() throws Exception {\n        JsonWebKeys jwks = readKeySet(\"jwkPublicSet.txt\");\n        Map<String, JsonWebKey> keysMap = jwks.getKeysMap();\n        assertEquals(2, keysMap.size());\n        \n        JsonWebKey rsaKey = keysMap.get(RSA_KID_VALUE);\n        assertEquals(5, rsaKey.asMap().size());\n        validatePublicRsaKey(rsaKey);\n        JsonWebKey ecKey = keysMap.get(EC_KID_VALUE);\n        assertEquals(6, ecKey.asMap().size());\n        validatePublicEcKey(ecKey);\n    }","id":38963,"modified_method":"@Test\n    public void testPublicSetAsMap() throws Exception {\n        JsonWebKeys jwks = readKeySet(\"jwkPublicSet.txt\");\n        Map<String, JsonWebKey> keysMap = jwks.getKeyIdMap();\n        assertEquals(2, keysMap.size());\n        \n        JsonWebKey rsaKey = keysMap.get(RSA_KID_VALUE);\n        assertEquals(5, rsaKey.asMap().size());\n        validatePublicRsaKey(rsaKey);\n        JsonWebKey ecKey = keysMap.get(EC_KID_VALUE);\n        assertEquals(6, ecKey.asMap().size());\n        validatePublicEcKey(ecKey);\n    }","commit_id":"08e47a272be0cdaf769d4392ab8be845dade0668","url":"https://github.com/apache/cxf"},{"original_method":"public Map<String, JsonWebKey> getKeysMap() {\n        List<JsonWebKey> keys = getKeys();\n        if (keys == null) {\n            return Collections.emptyMap();\n        }\n        Map<String, JsonWebKey> map = new LinkedHashMap<String, JsonWebKey>();\n        for (JsonWebKey key : keys) {\n            String kid = key.getKid();\n            if (kid != null) {\n                map.put(kid, key);\n            }\n        }\n        return map;\n    }","id":38964,"modified_method":"public Map<String, JsonWebKey> getKeyIdMap() {\n        List<JsonWebKey> keys = getKeys();\n        if (keys == null) {\n            return Collections.emptyMap();\n        }\n        Map<String, JsonWebKey> map = new LinkedHashMap<String, JsonWebKey>();\n        for (JsonWebKey key : keys) {\n            String kid = key.getKid();\n            if (kid != null) {\n                map.put(kid, key);\n            }\n        }\n        return map;\n    }","commit_id":"08e47a272be0cdaf769d4392ab8be845dade0668","url":"https://github.com/apache/cxf"},{"original_method":"protected JweEncryptionProvider getInitializedEncryptionProvider() {\n        if (encryptionProvider != null) {\n            return encryptionProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, JSON_ENCRYPTION_OUT_PROPS, JSON_ENCRYPTION_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            PublicKey pk = CryptoUtils.loadPublicKey(m, props);\n            if (!(pk instanceof RSAPublicKey)) {\n                throw new SecurityException();\n            }\n            JweHeaders headers = new JweHeaders(props.getProperty(JSON_WEB_ENCRYPTION_KEY_ALGO_PROP),\n                                                props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP));\n            String compression = props.getProperty(JSON_WEB_ENCRYPTION_ZIP_ALGO_PROP);\n            if (compression != null) {\n                headers.setZipAlgorithm(compression);\n            }\n            \n            return new WrappedKeyJweEncryption(headers, new RSAOaepKeyEncryptionAlgorithm((RSAPublicKey)pk));\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":38965,"modified_method":"protected JweEncryptionProvider getInitializedEncryptionProvider() {\n        if (encryptionProvider != null) {\n            return encryptionProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, RSSEC_ENCRYPTION_OUT_PROPS, RSSEC_ENCRYPTION_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            RSAPublicKey pk = null;\n            String rsaKeyEncryptionAlgo = null;\n            \n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(CryptoUtils.RSSEC_KEY_STORE_TYPE))) {\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props);\n                pk = jwk.toRSAPublicKey();\n                rsaKeyEncryptionAlgo = jwk.getAlgorithm();\n            } else {\n                pk = (RSAPublicKey)CryptoUtils.loadPublicKey(m, props);\n            }\n            if (rsaKeyEncryptionAlgo == null) {\n                rsaKeyEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_KEY_ALGO_PROP);\n            }\n            \n            JweHeaders headers = new JweHeaders(rsaKeyEncryptionAlgo,\n                                                props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP));\n            String compression = props.getProperty(JSON_WEB_ENCRYPTION_ZIP_ALGO_PROP);\n            if (compression != null) {\n                headers.setZipAlgorithm(compression);\n            }\n            \n            return new WrappedKeyJweEncryption(headers, new RSAOaepKeyEncryptionAlgorithm((RSAPublicKey)pk));\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"08e47a272be0cdaf769d4392ab8be845dade0668","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Returns a single (unspecified) service reference\n     */\n    ServiceReference getServiceReference()\n    {\n        synchronized ( m_tracked )\n        {\n            if ( m_tracked.size() > 0 )\n            {\n                return ( ServiceReference ) m_tracked.keySet().iterator().next();\n            }\n\n            return null;\n        }\n    }","id":38966,"modified_method":"/**\n     * Returns the first service reference returned by the\n     * {@link #getServiceReferences()} method or <code>null<\/code> if no\n     * matching service can be found. \n     */\n    ServiceReference getServiceReference()\n    {\n        ServiceReference[] sr = getServiceReferences();\n        return ( sr != null && sr.length > 0 ) ? sr[0] : null;\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Constructor that receives several parameters.\n     *\n     * @param dependency An object that contains data about the dependency\n     */\n    DependencyManager( AbstractComponentManager componentManager, ReferenceMetadata dependency )\n        throws InvalidSyntaxException\n    {\n        m_componentManager = componentManager;\n        m_dependencyMetadata = dependency;\n        m_bindUsesServiceReference = false;\n        m_tracked = new HashMap();\n\n        // register the service listener\n        String filterString = \"(\" + Constants.OBJECTCLASS + \"=\" + dependency.getInterface() + \")\";\n        if ( dependency.getTarget() != null )\n        {\n            filterString = \"(&\" + filterString + dependency.getTarget() + \")\";\n        }\n        componentManager.getActivator().getBundleContext().addServiceListener( this, filterString );\n\n        // initial registration of services\n        ServiceReference refs[] = componentManager.getActivator().getBundleContext().getServiceReferences( null,\n            filterString );\n        for ( int i = 0; refs != null && i < refs.length; i++ )\n        {\n            addingService( refs[i] );\n        }\n    }","id":38967,"modified_method":"/**\n     * Constructor that receives several parameters.\n     *\n     * @param dependency An object that contains data about the dependency\n     */\n    DependencyManager( AbstractComponentManager componentManager, ReferenceMetadata dependency )\n        throws InvalidSyntaxException\n    {\n        m_componentManager = componentManager;\n        m_dependencyMetadata = dependency;\n        m_bindUsesServiceReference = false;\n        m_bound = Collections.synchronizedMap( new HashMap() );\n\n        // register the service listener\n        String filterString = \"(\" + Constants.OBJECTCLASS + \"=\" + dependency.getInterface() + \")\";\n        if ( dependency.getTarget() != null )\n        {\n            filterString = \"(&\" + filterString + dependency.getTarget() + \")\";\n        }\n        componentManager.getActivator().getBundleContext().addServiceListener( this, filterString );\n\n        // get the current number of registered services available\n        ServiceReference refs[] = getServiceReferences();\n        m_size = (refs == null) ? 0 : refs.length;\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"public void serviceChanged( ServiceEvent event )\n    {\n        switch ( event.getType() )\n        {\n            case ServiceEvent.REGISTERED:\n                addingService( event.getServiceReference() );\n                break;\n            case ServiceEvent.MODIFIED:\n                removedService( event.getServiceReference() );\n                addingService( event.getServiceReference() );\n                break;\n            case ServiceEvent.UNREGISTERING:\n                removedService( event.getServiceReference() );\n                break;\n        }\n    }","id":38968,"modified_method":"public void serviceChanged( ServiceEvent event )\n    {\n        switch ( event.getType() )\n        {\n            case ServiceEvent.REGISTERED:\n                m_size++;\n                addingService( event.getServiceReference() );\n                break;\n            case ServiceEvent.MODIFIED:\n                removedService( event.getServiceReference() );\n                addingService( event.getServiceReference() );\n                break;\n            case ServiceEvent.UNREGISTERING:\n                m_size--;\n                removedService( event.getServiceReference() );\n                break;\n        }\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"public void removedService( ServiceReference reference )\n    {\n        // remove the service from the internal registry, ignore if not cached\n        Object service;\n        synchronized ( m_tracked )\n        {\n            service = m_tracked.remove( reference );\n        }\n\n        // do nothing in the unlikely case that we do not have it cached\n        if ( service == null )\n        {\n            return;\n        }\n\n        if ( handleServiceEvent() )\n        {\n            // A static dependency is broken the instance manager will\n            // be invalidated\n            if ( m_dependencyMetadata.isStatic() )\n            {\n                // setStateDependency(DependencyChangeEvent.DEPENDENCY_INVALID);\n                try\n                {\n                    m_componentManager.getActivator().log(\n                        LogService.LOG_DEBUG,\n                        \"Dependency Manager: Static dependency on \" + m_dependencyMetadata.getName() + \"/\"\n                            + m_dependencyMetadata.getInterface() + \" is broken\",\n                        m_componentManager.getComponentMetadata(), null );\n                    m_componentManager.reactivate();\n                }\n                catch ( Exception ex )\n                {\n                    m_componentManager.getActivator().log( LogService.LOG_ERROR,\n                        \"Exception while recreating dependency \", m_componentManager.getComponentMetadata(), ex );\n                }\n            }\n            // dynamic dependency\n            else\n            {\n                // Release references to the service, call unbinder\n                // method\n                // and eventually request service unregistration\n                Object instance = m_componentManager.getInstance();\n                invokeUnbindMethod( instance, reference, service );\n\n                // The only thing we need to do here is check if we can\n                // reinitialize\n                // once the bound services becomes zero. This tries to\n                // repair dynamic\n                // 1..1 or rebind 0..1, since replacement services may\n                // be available.\n                // In the case of aggregates, this will only invalidate\n                // them since they\n                // can't be repaired.\n                if ( size() == 0 )\n                {\n                    // try to reinitialize\n                    if ( !bind( instance ) )\n                    {\n                        if ( !m_dependencyMetadata.isOptional() )\n                        {\n                            m_componentManager.getActivator().log(\n                                LogService.LOG_DEBUG,\n                                \"Dependency Manager: Deactivating component due to mandatory dependency on \"\n                                    + m_dependencyMetadata.getName() + \"/\" + m_dependencyMetadata.getInterface()\n                                    + \" not fullfilled and no replacement(s) available\",\n                                m_componentManager.getComponentMetadata(), null );\n                            m_componentManager.deactivate();\n                        }\n                    }\n                }\n            }\n        }\n\n        // finally unget the service\n        m_componentManager.getActivator().getBundleContext().ungetService( reference );\n    }","id":38969,"modified_method":"public void removedService( ServiceReference reference )\n    {\n        // check whether we are bound to that service, do nothing if not\n        Object service = getBoundService( reference );\n        if ( service == null )\n        {\n            return;\n        }\n\n        if ( handleServiceEvent() )\n        {\n            // if the dependency is not satisfied anymore, we have to\n            // deactivate the component \n            if ( !isValid() )\n            {\n                m_componentManager.getActivator()\n                    .log(\n                        LogService.LOG_DEBUG,\n                        \"Dependency Manager: Deactivating component due to mandatory dependency on \"\n                            + m_dependencyMetadata.getName() + \"/\" + m_dependencyMetadata.getInterface()\n                            + \" not satisfied\", m_componentManager.getComponentMetadata(), null );\n\n                // deactivate the component now\n                m_componentManager.deactivate();\n            }\n\n            // if the dependency is static, we have to reactivate the component\n            // to \"remove\" the dependency\n            else if ( m_dependencyMetadata.isStatic() )\n            {\n                try\n                {\n                    m_componentManager.getActivator().log(\n                        LogService.LOG_DEBUG,\n                        \"Dependency Manager: Static dependency on \" + m_dependencyMetadata.getName() + \"/\"\n                            + m_dependencyMetadata.getInterface() + \" is broken\",\n                        m_componentManager.getComponentMetadata(), null );\n                    m_componentManager.reactivate();\n                }\n                catch ( Exception ex )\n                {\n                    m_componentManager.getActivator().log( LogService.LOG_ERROR,\n                        \"Exception while recreating dependency \", m_componentManager.getComponentMetadata(), ex );\n                }\n            }\n\n            // dynamic dependency, multiple or single but this service is the bound one\n            else\n            {\n\n                // the component instance to unbind/bind services\n                Object instance = m_componentManager.getInstance();\n\n                // call the unbind method if one is defined\n                if ( m_dependencyMetadata.getUnbind() != null )\n                {\n                    invokeUnbindMethod( instance, reference, service );\n                }\n                \n                // if binding to another service fails for a singleton\n                // reference, we have to deactivate the component\n                if ( !m_dependencyMetadata.isMultiple() )\n                {\n                    // in the unexpected case that rebinding fails, we will\n                    // deactivate the component\n                    if ( !bind( instance ) )\n                    {\n                        m_componentManager.getActivator().log(\n                            LogService.LOG_DEBUG,\n                            \"Dependency Manager: Deactivating component due to mandatory dependency on \"\n                                + m_dependencyMetadata.getName() + \"/\" + m_dependencyMetadata.getInterface()\n                                + \" not satisfied\", m_componentManager.getComponentMetadata(), null );\n                        m_componentManager.deactivate();\n\n                    }\n                }\n            }\n        }\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns the number of services currently tracked\n     */\n    int size()\n    {\n        synchronized ( m_tracked )\n        {\n            return m_tracked.size();\n        }\n    }","id":38970,"modified_method":"/**\n     * Returns the number of services currently registered in the system,\n     * which match the service criteria (interface and optional target filter)\n     * configured for this dependency. The number returned by this method has\n     * no correlation to the number of services bound to this dependency\n     * manager. It is actually the maximum number of services which may be\n     * bound to this dependency manager.\n     * \n     * @see #isValid()\n     */\n    int size()\n    {\n        return m_size;\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns a single service instance\n     */\n    Object getService()\n    {\n        synchronized ( m_tracked )\n        {\n            if ( m_tracked.size() > 0 )\n            {\n                return m_tracked.values().iterator().next();\n            }\n\n            return null;\n        }\n    }","id":38971,"modified_method":"/**\n     * Returns the service instance for the service reference returned by the\n     * {@link #getServiceReference()} method. If this returns a\n     * non-<code>null<\/code> service instance the service is then considered\n     * bound to this instance.\n     */\n    Object getService()\n    {\n        ServiceReference sr = getServiceReference();\n        return ( sr != null ) ? getService( sr ) : null;\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Revoke all bindings. This method cannot throw an exception since it must\n     * try to complete all that it can\n     */\n    void unbind( Object instance )\n    {\n        // if the instance is null, we do nothing actually\n        // the instance might be null in the delayed component situation\n        if ( instance == null )\n        {\n            return;\n        }\n\n        ServiceReference[] allrefs = getServiceReferences();\n\n        if ( allrefs == null )\n            return;\n\n        for ( int i = 0; i < allrefs.length; i++ )\n        {\n            invokeUnbindMethod( instance, allrefs[i], getService( allrefs[i] ) );\n        }\n    }","id":38972,"modified_method":"/**\n     * Revoke all bindings. This method cannot throw an exception since it must\n     * try to complete all that it can\n     */\n    void unbind( Object instance )\n    {\n        // if the instance is null, we do nothing actually\n        // the instance might be null in the delayed component situation.\n        // Additionally, we do nothing here in case there is no configured\n        // unbind method.\n        if ( instance == null || m_dependencyMetadata.getUnbind() == null )\n        {\n            return;\n        }\n\n        ServiceReference[] boundRefs = getBoundServiceReferences();\n        if ( boundRefs != null )\n        {\n            for ( int i = 0; i < boundRefs.length; i++ )\n            {\n                // get the service, don't try to unbind if the service has gone\n                // since we got the service references above\n                Object service = getBoundService( boundRefs[i] );\n                if ( service == null )\n                {\n                    m_componentManager.getActivator().log( LogService.LOG_INFO,\n                        \"Dependency Manager: Service \" + boundRefs[i] + \" has already gone, not unbinding now\",\n                        m_componentManager.getComponentMetadata(), null );\n                    continue;\n                }\n\n                invokeUnbindMethod( instance, boundRefs[i], service );\n            }\n        }\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Call the unbind method\n     *\n     * @param implementationObject The object from which the service is unbound\n     * @param ref A service reference corresponding to the service that will be\n     *            unbound\n     * @return true if the call was successful, false otherwise\n     */\n    private boolean invokeUnbindMethod( Object implementationObject, ServiceReference ref, Object service )\n    {\n        // The unbind method is only invoked if the implementation object is not\n        // null. This is valid for both immediate and delayed components\n        if ( implementationObject != null )\n        {\n            try\n            {\n                m_componentManager.getActivator().log( LogService.LOG_DEBUG,\n                    \"getting unbind: \" + m_dependencyMetadata.getUnbind(), m_componentManager.getComponentMetadata(),\n                    null );\n                Method unbindMethod = getBindingMethod( m_dependencyMetadata.getUnbind(), implementationObject\n                    .getClass(), m_dependencyMetadata.getInterface() );\n\n                // Recover the object that is bound from the map.\n                // Object parameter = m_boundServices.get(ref);\n                Object parameter = null;\n\n                if ( m_bindUsesServiceReference == true )\n                {\n                    parameter = ref;\n                }\n                else\n                {\n                    parameter = service;\n                }\n\n                if ( unbindMethod == null )\n                {\n                    // 112.3.1 If the method is not found , SCR must log an\n                    // error\n                    // message with the log service, if present, and ignore the\n                    // method\n                    m_componentManager.getActivator().log( LogService.LOG_ERROR, \"unbind() method not found\",\n                        m_componentManager.getComponentMetadata(), null );\n                    return false;\n                }\n\n                unbindMethod.invoke( implementationObject, new Object[]\n                    { parameter } );\n\n                m_componentManager.getActivator().log( LogService.LOG_DEBUG, \"unbound: \" + getName(),\n                    m_componentManager.getComponentMetadata(), null );\n\n                return true;\n            }\n            catch ( IllegalAccessException ex )\n            {\n                // 112.3.1 If the method is not is not declared protected or\n                // public, SCR must log an error\n                // message with the log service, if present, and ignore the\n                // method\n                m_componentManager.getActivator().log( LogService.LOG_ERROR, \"unbind() method cannot be called\",\n                    m_componentManager.getComponentMetadata(), ex );\n                return false;\n            }\n            catch ( InvocationTargetException ex )\n            {\n                m_componentManager.getActivator().log( LogService.LOG_ERROR,\n                    \"DependencyManager : exception while invoking \" + m_dependencyMetadata.getUnbind() + \"()\",\n                    m_componentManager.getComponentMetadata(), ex.getCause() );\n                return false;\n            }\n\n        }\n        else if ( implementationObject == null && m_componentManager.getComponentMetadata().isImmediate() == false )\n        {\n            return true;\n        }\n        else\n        {\n            // this is not expected: if the component is immediate the\n            // implementationObject is not null (asserted by the caller)\n            return false;\n        }\n    }","id":38973,"modified_method":"/**\n     * Calls the unbind method.\n     * <p>\n     * If the reference is singular and the given service is not the one bound\n     * to the component this method has no effect and just returns\n     * <code>true<\/code>.\n     *\n     * @param implementationObject The object from which the service is unbound\n     * @param ref A service reference corresponding to the service that will be\n     *            unbound\n     * @return true if the call was successful, false otherwise\n     */\n    private boolean invokeUnbindMethod( Object implementationObject, ServiceReference ref, Object service )\n    {\n        // The unbind method is only invoked if the implementation object is not\n        // null. This is valid for both immediate and delayed components\n        if ( implementationObject != null )\n        {\n            try\n            {\n                m_componentManager.getActivator().log( LogService.LOG_DEBUG,\n                    \"getting unbind: \" + m_dependencyMetadata.getUnbind(), m_componentManager.getComponentMetadata(),\n                    null );\n                Method unbindMethod = getBindingMethod( m_dependencyMetadata.getUnbind(), implementationObject\n                    .getClass(), m_dependencyMetadata.getInterface() );\n\n                // Recover the object that is bound from the map.\n                // Object parameter = m_boundServices.get(ref);\n                Object parameter = null;\n\n                if ( m_bindUsesServiceReference == true )\n                {\n                    parameter = ref;\n                }\n                else\n                {\n                    parameter = service;\n                }\n\n                if ( unbindMethod == null )\n                {\n                    // 112.3.1 If the method is not found , SCR must log an\n                    // error\n                    // message with the log service, if present, and ignore the\n                    // method\n                    m_componentManager.getActivator().log( LogService.LOG_ERROR, \"unbind() method not found\",\n                        m_componentManager.getComponentMetadata(), null );\n                    return false;\n                }\n\n                unbindMethod.invoke( implementationObject, new Object[]\n                    { parameter } );\n\n                m_componentManager.getActivator().log( LogService.LOG_DEBUG, \"unbound: \" + getName(),\n                    m_componentManager.getComponentMetadata(), null );\n\n                return true;\n            }\n            catch ( IllegalAccessException ex )\n            {\n                // 112.3.1 If the method is not is not declared protected or\n                // public, SCR must log an error\n                // message with the log service, if present, and ignore the\n                // method\n                m_componentManager.getActivator().log( LogService.LOG_ERROR, \"unbind() method cannot be called\",\n                    m_componentManager.getComponentMetadata(), ex );\n                return false;\n            }\n            catch ( InvocationTargetException ex )\n            {\n                m_componentManager.getActivator().log( LogService.LOG_ERROR,\n                    \"DependencyManager : exception while invoking \" + m_dependencyMetadata.getUnbind() + \"()\",\n                    m_componentManager.getComponentMetadata(), ex.getCause() );\n                return false;\n            }\n            finally\n            {\n                // ensure the service is not cached anymore\n                ungetService( ref );\n            }\n\n        }\n        else if ( implementationObject == null && m_componentManager.getComponentMetadata().isImmediate() == false )\n        {\n            return true;\n        }\n        else\n        {\n            // this is not expected: if the component is immediate the\n            // implementationObject is not null (asserted by the caller)\n            return false;\n        }\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns an array of service references of the currently tracked\n     * services\n     */\n    ServiceReference[] getServiceReferences()\n    {\n        synchronized ( m_tracked )\n        {\n            if ( m_tracked.size() > 0 )\n            {\n                return ( ServiceReference[] ) m_tracked.keySet().toArray( new ServiceReference[m_tracked.size()] );\n            }\n\n            return null;\n        }\n    }","id":38974,"modified_method":"/**\n     * Returns an array of <code>ServiceReference<\/code> instances for services\n     * implementing the interface and complying to the (optional) target filter\n     * declared for this dependency. If no matching service can be found\n     * <code>null<\/code> is returned. If the configured target filter is\n     * syntactically incorrect an error message is logged with the LogService\n     * and <code>null<\/code> is returned.\n     * <p>\n     * This method always directly accesses the framework's service registry\n     * and ignores the services bound by this dependency manager.\n     */\n    ServiceReference[] getServiceReferences()\n    {\n        try\n        {\n            return m_componentManager.getActivator().getBundleContext().getServiceReferences(\n                m_dependencyMetadata.getInterface(), m_dependencyMetadata.getTarget() );\n        }\n        catch ( InvalidSyntaxException ise )\n        {\n            m_componentManager.getActivator().log( LogService.LOG_ERROR,\n                \"Unexpected problem with filter '\" + m_dependencyMetadata.getTarget() + \"'\",\n                m_componentManager.getComponentMetadata(), ise );\n            return null;\n        }\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"private void addingService( ServiceReference reference )\n    {\n        // get the service and keep it here (for now or later)\n        Object service = m_componentManager.getActivator().getBundleContext().getService( reference );\n        synchronized ( m_tracked )\n        {\n            m_tracked.put( reference, service );\n        }\n\n        // forward the event if in event handling state\n        if ( handleServiceEvent() )\n        {\n\n            // the component is UNSATISFIED if enabled but any of the references\n            // have been missing when activate was running the last time or\n            // the component has been deactivated\n            if ( m_componentManager.getState() == AbstractComponentManager.STATE_UNSATISFIED )\n            {\n                m_componentManager.activate();\n            }\n\n            // Otherwise, this checks for dynamic 0..1, 0..N, and 1..N\n            // it never\n            // checks for 1..1 dynamic which is done above by the\n            // validate()\n            else if ( !m_dependencyMetadata.isStatic() )\n            {\n                // For dependency that are aggregates, always bind the\n                // service\n                // Otherwise only bind if bind services is zero, which\n                // captures the 0..1 case\n                // (size is still zero as we are called for the first service)\n                if ( m_dependencyMetadata.isMultiple() || size() == 0 )\n                {\n                    invokeBindMethod( m_componentManager.getInstance(), reference, service );\n                }\n            }\n        }\n    }","id":38975,"modified_method":"private void addingService( ServiceReference reference )\n    {\n        // if the component is currently unsatisfied, it may become satisfied\n        // by adding this service, try to activate\n        if ( m_componentManager.getState() == AbstractComponentManager.STATE_UNSATISFIED )\n        {\n            m_componentManager.activate();\n        }\n\n        // otherwise check whether the component is in a state to handle the event\n        else if ( handleServiceEvent() )\n        {\n            // if the dependency is static and adding the service has an\n            // influence on service binding because the dependency is multiple\n            // or optional and unbound, the component needs to be reactivated\n            if ( m_dependencyMetadata.isStatic() )\n            {\n                // only reactivate if the service has an influence on binding\n                if ( m_dependencyMetadata.isMultiple() || !isBound() )\n                {\n                    m_componentManager.reactivate();\n                }\n            }\n\n            // otherwise bind if we have a bind method and the service needs\n            // be bound\n            else if ( m_dependencyMetadata.getBind() != null && ( m_dependencyMetadata.isMultiple() || !isBound() ) )\n            {\n                // get the service (and cache) and invoke the bind method\n                Object service = getService( reference );\n                invokeBindMethod( m_componentManager.getInstance(), reference, service );\n            }\n        }\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns the service described by the ServiceReference\n     */\n    Object getService( ServiceReference serviceReference )\n    {\n        synchronized ( m_tracked )\n        {\n            return m_tracked.get( serviceReference );\n        }\n    }","id":38976,"modified_method":"/**\n     * Returns the service described by the ServiceReference. If this instance\n     * is already bound the given service, that bound service instance is\n     * returned. Otherwise the service retrieved from the service registry\n     * and kept as a bound service for future use.\n     * \n     * @param serviceReference The reference to the service to be returned\n     * \n     * @return The requested service or <code>null<\/code> if no service is\n     *      registered for the service reference (any more).\n     */\n    Object getService( ServiceReference serviceReference )\n    {\n        // check whether we already have the service and return that one\n        Object service = getBoundService( serviceReference );\n        if ( service != null )\n        {\n            return service;\n        }\n\n        // otherwise acquire the service and keep it\n        service = m_componentManager.getActivator().getBundleContext().getService( serviceReference );\n        if ( service != null )\n        {\n            m_bound.put( serviceReference, service );\n        }\n\n        // returne the acquired service (may be null of course)\n        return service;\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * initializes a dependency. This method binds all of the service\n     * occurrences to the instance object\n     *\n     * @return true if the operation was successful, false otherwise\n     */\n    boolean bind( Object instance )\n    {\n        // If no references were received, we have to check if the dependency\n        // is optional, if it is not then the dependency is invalid\n        if ( !isValid() )\n        {\n            return false;\n        }\n\n        // if the instance is null, we do nothing actually but assume success\n        // the instance might be null in the delayed component situation\n        if ( instance == null )\n        {\n            return true;\n        }\n\n        // Get service references\n        ServiceReference refs[] = getServiceReferences();\n\n        // refs can be null if the dependency is optional\n        if ( refs == null )\n        {\n            return true;\n        }\n        \n        // assume success to begin with: if the dependency is optional,\n        // we don't care, whether we can bind a service. Otherwise, we\n        /// require at least one service to be bound, thus we require\n        // flag being set in the loop below\n        boolean success = m_dependencyMetadata.isOptional();\n        \n        // number of services to bind\n        for ( int index = 0; index < refs.length; index++ )\n        {\n            // get the service, don't try to bind if the service has gone\n            // since we got the service references above\n            Object service = getService( refs[index] );\n            if ( service == null )\n            {\n                m_componentManager.getActivator().log( LogService.LOG_INFO,\n                    \"Dependency Manager: Service \" + refs[index] + \" has already gone, not binding\",\n                    m_componentManager.getComponentMetadata(), null );\n                continue;\n            }\n\n            // call the bind method, but ignore success:\n            // 112.5.7 If a bind method throws an exception, SCR must log\n            // an error message (done in invokeBindMethod) but the activation\n            // does not fail\n            invokeBindMethod( instance, refs[index], service );\n\n            // we have at least on service bound\n            success = true;\n            \n            // if the reference is not multiple, we are already done\n            if ( !m_dependencyMetadata.isMultiple() )\n            {\n                break;\n            }\n        }\n\n        // success will be true, if the service is optional or if at least\n        // one service was available to be bound (regardless of whether the\n        // bind method succeeded or not)\n        return success;\n    }","id":38977,"modified_method":"/**\n     * initializes a dependency. This method binds all of the service\n     * occurrences to the instance object\n     *\n     * @return true if the dependency is satisfied and at least the minimum\n     *      number of services could be bound. Otherwise false is returned.\n     */\n    boolean bind( Object instance )\n    {\n        // If no references were received, we have to check if the dependency\n        // is optional, if it is not then the dependency is invalid\n        if ( !isValid() )\n        {\n            return false;\n        }\n\n        // if no bind method is configured or if this is a delayed component,\n        // we have nothing to do and just signal success\n        if ( instance == null || m_dependencyMetadata.getBind() == null )\n        {\n            return true;\n        }\n\n        // Get service references\n        ServiceReference refs[] = getServiceReferences();\n\n        // refs can be null if the dependency is optional\n        if ( refs == null )\n        {\n            return true;\n        }\n        \n        // assume success to begin with: if the dependency is optional,\n        // we don't care, whether we can bind a service. Otherwise, we\n        // require at least one service to be bound, thus we require\n        // flag being set in the loop below\n        boolean success = m_dependencyMetadata.isOptional();\n        \n        // number of services to bind\n        for ( int index = 0; index < refs.length; index++ )\n        {\n            // get the service, don't try to bind if the service has gone\n            // since we got the service references above\n            Object service = getService( refs[index] );\n            if ( service == null )\n            {\n                m_componentManager.getActivator().log( LogService.LOG_INFO,\n                    \"Dependency Manager: Service \" + refs[index] + \" has already gone, not binding\",\n                    m_componentManager.getComponentMetadata(), null );\n                continue;\n            }\n\n            // call the bind method, but ignore success:\n            // 112.5.7 If a bind method throws an exception, SCR must log\n            // an error message (done in invokeBindMethod) but the activation\n            // does not fail\n            invokeBindMethod( instance, refs[index], service );\n\n            // we have at least on service bound\n            success = true;\n            \n            // if the reference is not multiple, we are already done\n            if ( !m_dependencyMetadata.isMultiple() )\n            {\n                break;\n            }\n        }\n\n        // success will be true, if the service is optional or if at least\n        // one service was available to be bound (regardless of whether the\n        // bind method succeeded or not)\n        return success;\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Stops using this dependency manager\n     */\n    void close()\n    {\n        BundleContext context = m_componentManager.getActivator().getBundleContext();\n        context.removeServiceListener( this );\n\n        synchronized ( m_tracked )\n        {\n            for ( Iterator ri = m_tracked.keySet().iterator(); ri.hasNext(); )\n            {\n                ServiceReference sr = ( ServiceReference ) ri.next();\n                context.ungetService( sr );\n                ri.remove();\n            }\n        }\n    }","id":38978,"modified_method":"/**\n     * Stops using this dependency manager\n     */\n    void close()\n    {\n        BundleContext context = m_componentManager.getActivator().getBundleContext();\n        context.removeServiceListener( this );\n\n        m_size = 0;\n\n        // unget all services we once got\n        ServiceReference[] boundRefs = getBoundServiceReferences();\n        if ( boundRefs != null )\n        {\n            for ( int i = 0; i < boundRefs.length; i++ )\n            {\n                ungetService( boundRefs[i] );\n            }\n        }\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Returns an array of service references of the currently tracked\n     * services\n     */\n    Object[] getServices()\n    {\n        synchronized ( m_tracked )\n        {\n            if ( m_tracked.size() > 0 )\n            {\n                return m_tracked.values().toArray( new ServiceReference[m_tracked.size()] );\n            }\n\n            return null;\n        }\n    }","id":38979,"modified_method":"/**\n     * Returns an array of service instances for the service references returned\n     * by the {@link #getServiceReference()} method. If no services match the\n     * criteria configured for this dependency <code>null<\/code> is returned.\n     * All services returned by this method will be considered bound after this\n     * method returns.\n     */\n    Object[] getServices()\n    {\n        ServiceReference[] sr = getServiceReferences();\n        if ( sr == null || sr.length == 0 )\n        {\n            return null;\n        }\n\n        List services = new ArrayList();\n        for ( int i = 0; i < sr.length; i++ )\n        {\n            Object service = getService( sr[i] );\n            if ( service != null )\n            {\n                services.add( service );\n            }\n        }\n\n        return ( services.size() > 0 ) ? services.toArray() : null;\n    }","commit_id":"43d2a71aed02f761b5ee441180fe7ac89dd8e4c5","url":"https://github.com/apache/felix"},{"original_method":"private ServiceReference[] getFrameworkServiceReferences( String targetFilter )\n    {\n        if ( hasGetPermission() )\n        {\n            try\n            {\n                return m_componentManager.getActivator().getBundleContext().getServiceReferences(\n                    m_dependencyMetadata.getInterface(), targetFilter );\n            }\n            catch ( InvalidSyntaxException ise )\n            {\n                m_componentManager.log( LogService.LOG_ERROR, \"Unexpected problem with filter ''{0}''\", new Object[]\n                    { targetFilter }, ise );\n                return null;\n            }\n        }\n\n        m_componentManager.log( LogService.LOG_DEBUG, \"No permission to access the services\", null );\n        return null;\n    }","id":38980,"modified_method":"private ServiceReference[] getFrameworkServiceReferences( String targetFilter )\n    {\n        if ( hasGetPermission() )\n        {\n            // component activator may be null if disposed concurrently\n            BundleComponentActivator bca = m_componentManager.getActivator();\n            if ( bca == null )\n            {\n                return null;\n            }\n\n            // get bundle context, may be null if component deactivated since getting bca\n            BundleContext bc = bca.getBundleContext();\n            if ( bc == null )\n            {\n                return null;\n            }\n\n            try\n            {\n                return bc.getServiceReferences(\n                    m_dependencyMetadata.getInterface(), targetFilter );\n            }\n            catch ( IllegalStateException ise )\n            {\n                // bundle context is not valid any longer, cannot log\n            }\n            catch ( InvalidSyntaxException ise )\n            {\n                m_componentManager.log( LogService.LOG_ERROR, \"Unexpected problem with filter ''{0}''\", new Object[]\n                    { targetFilter }, ise );\n                return null;\n            }\n        }\n\n        m_componentManager.log( LogService.LOG_DEBUG, \"No permission to access the services\", null );\n        return null;\n    }","commit_id":"98908c7ba2bcdc8a4cf38795117e1e991959d42b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Ungets the service described by the ServiceReference and removes it from\n     * the list of bound services.\n     */\n    void ungetService( ServiceReference serviceReference )\n    {\n        // check we really have this service, do nothing if not\n        Object service = m_bound.remove( serviceReference );\n        if ( service != null && service != BOUND_SERVICE_SENTINEL )\n        {\n            try\n            {\n                m_componentManager.getActivator().getBundleContext().ungetService( serviceReference );\n            }\n            catch ( IllegalStateException e )\n            {\n                m_componentManager.log( LogService.LOG_INFO,\n                    \"For dependency {0}, trying to unget ServiceReference {1} on invalid bundle context {2}\",\n                    new Object[]\n                        { m_dependencyMetadata.getName(), serviceReference.getProperty( Constants.SERVICE_ID ),\n                            serviceReference }, null );\n            }\n        }\n    }","id":38981,"modified_method":"/**\n     * Ungets the service described by the ServiceReference and removes it from\n     * the list of bound services.\n     */\n    void ungetService( ServiceReference serviceReference )\n    {\n        // check we really have this service, do nothing if not\n        Object service = m_bound.remove( serviceReference );\n        if ( service != null && service != BOUND_SERVICE_SENTINEL )\n        {\n            BundleComponentActivator activator = m_componentManager.getActivator();\n            if ( activator != null )\n            {\n                BundleContext bundleContext = activator.getBundleContext();\n                if ( bundleContext != null )\n                {\n                    try\n                    {\n                        bundleContext.ungetService( serviceReference );\n                    }\n                    catch ( IllegalStateException e )\n                    {\n                        m_componentManager.log( LogService.LOG_INFO,\n                            \"For dependency {0}, trying to unget ServiceReference {1} on invalid bundle context {2}\",\n                            new Object[]\n                                { m_dependencyMetadata.getName(), serviceReference.getProperty( Constants.SERVICE_ID ),\n                                    serviceReference }, null );\n                    }\n                }\n            }\n        }\n    }","commit_id":"dae9a632952fe1933d0c1795533f1c7586e863b6","url":"https://github.com/apache/felix"},{"original_method":"public CalendarResource addCalendarResource(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString classUuid, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tlong calendarResourceId = counterLocalService.increment();\n\n\t\tif (Validator.isNull(className)) {\n\t\t\tclassName = CalendarResource.class.getName();\n\t\t\tclassPK = calendarResourceId;\n\t\t}\n\n\t\tlong globalUserId = 0;\n\n\t\tif (CalendarResourceUtil.isGlobalResource(className, classPK)) {\n\t\t\tglobalUserId = CalendarResourceUtil.getGlobalResourceUserId(\n\t\t\t\tclassName, classPK);\n\t\t}\n\n\t\tif (globalUserId > 0) {\n\t\t\tuserId = globalUserId;\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(classNameId, classPK);\n\n\t\tCalendarResource calendarResource = calendarResourcePersistence.create(\n\t\t\tcalendarResourceId);\n\n\t\tcalendarResource.setUuid(serviceContext.getUuid());\n\t\tcalendarResource.setGroupId(groupId);\n\t\tcalendarResource.setCompanyId(user.getCompanyId());\n\t\tcalendarResource.setUserId(user.getUserId());\n\t\tcalendarResource.setUserName(user.getFullName());\n\t\tcalendarResource.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarResource.setClassNameId(classNameId);\n\t\tcalendarResource.setClassPK(classPK);\n\t\tcalendarResource.setClassUuid(classUuid);\n\t\tcalendarResource.setCode(code);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setType(type);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\treturn calendarResource;\n\t}","id":38982,"modified_method":"public CalendarResource addCalendarResource(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString classUuid, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, String type, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tif (Validator.isNull(className)) {\n\t\t\tclassName = CalendarResource.class.getName();\n\t\t}\n\n\t\tlong globalUserId = 0;\n\n\t\tif (CalendarResourceUtil.isGlobalResource(className, classPK)) {\n\t\t\tglobalUserId = CalendarResourceUtil.getGlobalResourceUserId(\n\t\t\t\tclassName, classPK);\n\t\t}\n\n\t\tif (globalUserId > 0) {\n\t\t\tuserId = globalUserId;\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\t\tDate now = new Date();\n\n\t\tvalidate(className, classPK);\n\n\t\tlong calendarResourceId = counterLocalService.increment();\n\n\t\tCalendarResource calendarResource = calendarResourcePersistence.create(\n\t\t\tcalendarResourceId);\n\n\t\tcalendarResource.setUuid(serviceContext.getUuid());\n\t\tcalendarResource.setGroupId(groupId);\n\t\tcalendarResource.setCompanyId(user.getCompanyId());\n\t\tcalendarResource.setUserId(user.getUserId());\n\t\tcalendarResource.setUserName(user.getFullName());\n\t\tcalendarResource.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarResource.setClassNameId(classNameId);\n\n\t\tif (className.equals(CalendarResource.class.getName())) {\n\t\t\tcalendarResource.setClassPK(calendarResourceId);\n\t\t}\n\t\telse {\n\t\t\tcalendarResource.setClassPK(classPK);\n\t\t}\n\n\t\tcalendarResource.setClassUuid(classUuid);\n\t\tcalendarResource.setCode(code);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setType(type);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource, false);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\treturn calendarResource;\n\t}","commit_id":"de69a6fb5e7991558b8b1d42ae6fce4ac757b362","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void validate(long classNameId, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarResource calendarResource =\n\t\t\tcalendarResourcePersistence.fetchByC_C(classNameId, classPK);\n\n\t\tif (Validator.isNotNull(calendarResource)) {\n\t\t\tthrow new DuplicateCalendarResourceException();\n\t\t}\n\t}","id":38983,"modified_method":"protected void validate(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!className.equals(CalendarResource.class.getName())) {\n\t\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\t\tCalendarResource calendarResource =\n\t\t\t\tcalendarResourcePersistence.fetchByC_C(classNameId, classPK);\n\n\t\t\tif (Validator.isNotNull(calendarResource)) {\n\t\t\t\tthrow new DuplicateCalendarResourceException();\n\t\t\t}\n\t\t}\n\t}","commit_id":"de69a6fb5e7991558b8b1d42ae6fce4ac757b362","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public List<CalendarResource> search(\n\t\t\tlong groupId, long classNameId, long classPK, String code,\n\t\t\tString name, String description, String type, Boolean active,\n\t\t\tboolean andOperator, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<CalendarResource> resources = calendarResourceLocalService.search(\n\t\t\tgroupId, classNameId, classPK, code, name, description, type,\n\t\t\tactive, andOperator, QueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\torderByComparator);\n\n\t\tList<CalendarResource> filteredList = new ArrayList<CalendarResource>();\n\n\t\tfor (CalendarResource resource : resources) {\n\t\t\tif (CalendarResourcePermission.contains(\n\t\t\t\tgetPermissionChecker(), resource, ActionKeys.VIEW)) {\n\n\t\t\t\tfilteredList.add(resource);\n\t\t\t}\n\t\t}\n\n\t\tif (start > QueryUtil.ALL_POS && end > QueryUtil.ALL_POS) {\n\t\t\treturn ListUtil.subList(filteredList, start, end);\n\t\t} else {\n\t\t\treturn filteredList;\n\t\t}\n\t}","id":38984,"modified_method":"public List<CalendarResource> search(\n\t\t\tlong groupId, long classNameId, long classPK, String code,\n\t\t\tString name, String description, String type, Boolean active,\n\t\t\tboolean andOperator, int start, int end,\n\t\t\tOrderByComparator orderByComparator)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<CalendarResource> resources = calendarResourceLocalService.search(\n\t\t\tgroupId, classNameId, classPK, code, name, description, type,\n\t\t\tactive, andOperator, QueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\torderByComparator);\n\n\t\tList<CalendarResource> filteredResources = filterResources(resources);\n\n\t\tif (start > QueryUtil.ALL_POS && end > QueryUtil.ALL_POS) {\n\t\t\treturn ListUtil.subList(filteredResources, start, end);\n\t\t}\n\t\telse {\n\t\t\treturn filteredResources;\n\t\t}\n\t}","commit_id":"de69a6fb5e7991558b8b1d42ae6fce4ac757b362","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic DLFileEntry addFileEntry(\n\t\t\tlong userId, long groupId, long repositoryId, long folderId,\n\t\t\tString sourceFileName, String mimeType, String title,\n\t\t\tString description, String changeLog, long fileEntryTypeId,\n\t\t\tMap<String, Fields> fieldsMap, File file, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tif (Validator.isNull(sourceFileName)) {\n\t\t\t\tthrow new FileNameException();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitle = sourceFileName;\n\t\t\t}\n\t\t}\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = dlFolderLocalService.getFolderId(\n\t\t\tuser.getCompanyId(), folderId);\n\t\tString name = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\t\tString extension = DLAppUtil.getExtension(title, sourceFileName);\n\n\t\tif (fileEntryTypeId == -1) {\n\t\t\tfileEntryTypeId =\n\t\t\t\tdlFileEntryTypeLocalService.getDefaultFileEntryTypeId(folderId);\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFileEntryTypeId(\n\t\t\tPortalUtil.getCurrentAndAncestorSiteGroupIds(groupId), folderId,\n\t\t\tfileEntryTypeId);\n\n\t\tvalidateFile(\n\t\t\tgroupId, folderId, 0, title, extension, sourceFileName, file, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tdlFileEntry.setUuid(serviceContext.getUuid());\n\t\tdlFileEntry.setGroupId(groupId);\n\t\tdlFileEntry.setCompanyId(user.getCompanyId());\n\t\tdlFileEntry.setUserId(user.getUserId());\n\t\tdlFileEntry.setUserName(user.getFullName());\n\t\tdlFileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tdlFileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\n\t\tDLFolder repositoryDLFolder = null;\n\n\t\tif (repositoryId != groupId) {\n\t\t\tRepository repository = repositoryLocalService.getRepository(\n\t\t\t\trepositoryId);\n\n\t\t\trepositoryDLFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\trepository.getDlFolderId());\n\t\t}\n\n\t\tif ((repositoryDLFolder != null) && repositoryDLFolder.isHidden()) {\n\t\t\tlong classNameId = classNameLocalService.getClassNameId(\n\t\t\t\t(String)serviceContext.getAttribute(\"className\"));\n\t\t\tlong classPK = ParamUtil.getLong(serviceContext, \"classPK\");\n\n\t\t\tif (Validator.isNotNull(classNameId) &&\n\t\t\t\tValidator.isNotNull(classPK)) {\n\n\t\t\t\tdlFileEntry.setClassNameId(classNameId);\n\t\t\t\tdlFileEntry.setClassPK(classPK);\n\t\t\t}\n\t\t}\n\n\t\tdlFileEntry.setRepositoryId(repositoryId);\n\t\tdlFileEntry.setFolderId(folderId);\n\t\tdlFileEntry.setTreePath(dlFileEntry.buildTreePath());\n\t\tdlFileEntry.setName(name);\n\t\tdlFileEntry.setExtension(extension);\n\t\tdlFileEntry.setMimeType(mimeType);\n\t\tdlFileEntry.setTitle(title);\n\t\tdlFileEntry.setDescription(description);\n\t\tdlFileEntry.setFileEntryTypeId(fileEntryTypeId);\n\t\tdlFileEntry.setVersion(DLFileEntryConstants.VERSION_DEFAULT);\n\t\tdlFileEntry.setSize(size);\n\t\tdlFileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\n\t\tdlFileEntryPersistence.update(dlFileEntry);\n\n\t\t// File version\n\n\t\taddFileVersion(\n\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now), extension,\n\t\t\tmimeType, title, description, changeLog, StringPool.BLANK,\n\t\t\tfileEntryTypeId, fieldsMap, DLFileEntryConstants.VERSION_DEFAULT,\n\t\t\tsize, WorkflowConstants.STATUS_DRAFT, serviceContext);\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tdlFolderLocalService.updateLastPostDate(\n\t\t\t\tdlFileEntry.getFolderId(), dlFileEntry.getModifiedDate());\n\t\t}\n\n\t\t// File\n\n\t\tif (file != null) {\n\t\t\tDLStoreUtil.addFile(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(), name,\n\t\t\t\tfalse, file);\n\t\t}\n\t\telse {\n\t\t\tDLStoreUtil.addFile(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(), name,\n\t\t\t\tfalse, is);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","id":38985,"modified_method":"@Override\n\tpublic DLFileEntry addFileEntry(\n\t\t\tlong userId, long groupId, long repositoryId, long folderId,\n\t\t\tString sourceFileName, String mimeType, String title,\n\t\t\tString description, String changeLog, long fileEntryTypeId,\n\t\t\tMap<String, Fields> fieldsMap, File file, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tif (Validator.isNull(sourceFileName)) {\n\t\t\t\tthrow new FileNameException();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitle = sourceFileName;\n\t\t\t}\n\t\t}\n\n\t\t// File entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tfolderId = dlFolderLocalService.getFolderId(\n\t\t\tuser.getCompanyId(), folderId);\n\t\tString name = String.valueOf(\n\t\t\tcounterLocalService.increment(DLFileEntry.class.getName()));\n\t\tString extension = DLAppUtil.getExtension(title, sourceFileName);\n\n\t\tif (fileEntryTypeId == -1) {\n\t\t\tfileEntryTypeId =\n\t\t\t\tdlFileEntryTypeLocalService.getDefaultFileEntryTypeId(folderId);\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidateFileEntryTypeId(\n\t\t\tPortalUtil.getCurrentAndAncestorSiteGroupIds(groupId), folderId,\n\t\t\tfileEntryTypeId);\n\n\t\tvalidateFile(\n\t\t\tgroupId, folderId, 0, title, extension, sourceFileName, file, is);\n\n\t\tlong fileEntryId = counterLocalService.increment();\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.create(fileEntryId);\n\n\t\tdlFileEntry.setUuid(serviceContext.getUuid());\n\t\tdlFileEntry.setGroupId(groupId);\n\t\tdlFileEntry.setCompanyId(user.getCompanyId());\n\t\tdlFileEntry.setUserId(user.getUserId());\n\t\tdlFileEntry.setUserName(user.getFullName());\n\t\tdlFileEntry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tdlFileEntry.setModifiedDate(serviceContext.getModifiedDate(now));\n\n\t\tDLFolder repositoryDLFolder = null;\n\n\t\tif (repositoryId != groupId) {\n\t\t\tRepository repository = repositoryLocalService.getRepository(\n\t\t\t\trepositoryId);\n\n\t\t\trepositoryDLFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\trepository.getDlFolderId());\n\t\t}\n\n\t\tlong classNameId = 0;\n\t\tlong classPK = 0;\n\n\t\tif ((repositoryDLFolder != null) && repositoryDLFolder.isHidden()) {\n\t\t\tclassNameId = classNameLocalService.getClassNameId(\n\t\t\t\t(String)serviceContext.getAttribute(\"className\"));\n\t\t\tclassPK = ParamUtil.getLong(serviceContext, \"classPK\");\n\t\t}\n\n\t\tdlFileEntry.setClassNameId(classNameId);\n\t\tdlFileEntry.setClassPK(classPK);\n\t\tdlFileEntry.setRepositoryId(repositoryId);\n\t\tdlFileEntry.setFolderId(folderId);\n\t\tdlFileEntry.setTreePath(dlFileEntry.buildTreePath());\n\t\tdlFileEntry.setName(name);\n\t\tdlFileEntry.setExtension(extension);\n\t\tdlFileEntry.setMimeType(mimeType);\n\t\tdlFileEntry.setTitle(title);\n\t\tdlFileEntry.setDescription(description);\n\t\tdlFileEntry.setFileEntryTypeId(fileEntryTypeId);\n\t\tdlFileEntry.setVersion(DLFileEntryConstants.VERSION_DEFAULT);\n\t\tdlFileEntry.setSize(size);\n\t\tdlFileEntry.setReadCount(DLFileEntryConstants.DEFAULT_READ_COUNT);\n\n\t\tdlFileEntryPersistence.update(dlFileEntry);\n\n\t\t// File version\n\n\t\taddFileVersion(\n\t\t\tuser, dlFileEntry, serviceContext.getModifiedDate(now), extension,\n\t\t\tmimeType, title, description, changeLog, StringPool.BLANK,\n\t\t\tfileEntryTypeId, fieldsMap, DLFileEntryConstants.VERSION_DEFAULT,\n\t\t\tsize, WorkflowConstants.STATUS_DRAFT, serviceContext);\n\n\t\t// Folder\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tdlFolderLocalService.updateLastPostDate(\n\t\t\t\tdlFileEntry.getFolderId(), dlFileEntry.getModifiedDate());\n\t\t}\n\n\t\t// File\n\n\t\tif (file != null) {\n\t\t\tDLStoreUtil.addFile(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(), name,\n\t\t\t\tfalse, file);\n\t\t}\n\t\telse {\n\t\t\tDLStoreUtil.addFile(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(), name,\n\t\t\t\tfalse, is);\n\t\t}\n\n\t\treturn dlFileEntry;\n\t}","commit_id":"1494785eb803bcb4119810ecbde6c782861a3c29","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic CalendarResource addCalendarResource(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString classUuid, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tlong calendarResourceId = counterLocalService.increment();\n\n\t\tif (Validator.isNull(className)) {\n\t\t\tclassName = CalendarResource.class.getName();\n\t\t\tclassPK = calendarResourceId;\n\t\t}\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tif (isGlobalResource(classNameId)) {\n\t\t\tuserId = getGlobalResourceUserId(classNameId, classPK);\n\n\t\t\tgroupId = getGlobalResourceGroupId(serviceContext.getCompanyId());\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (PortletPropsValues.CALENDAR_RESOURCE_FORCE_AUTOGENERATE_CODE ||\n\t\t\tValidator.isNull(code)) {\n\n\t\t\tcode = String.valueOf(calendarResourceId);\n\t\t}\n\t\telse {\n\t\t\tcode = code.trim();\n\t\t\tcode = code.toUpperCase();\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(groupId, classNameId, classPK, code, nameMap);\n\n\t\tCalendarResource calendarResource = calendarResourcePersistence.create(\n\t\t\tcalendarResourceId);\n\n\t\tcalendarResource.setUuid(serviceContext.getUuid());\n\t\tcalendarResource.setGroupId(groupId);\n\t\tcalendarResource.setCompanyId(user.getCompanyId());\n\t\tcalendarResource.setUserId(user.getUserId());\n\t\tcalendarResource.setUserName(user.getFullName());\n\t\tcalendarResource.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarResource.setClassNameId(classNameId);\n\n\t\tif (className.equals(CalendarResource.class.getName())) {\n\t\t\tcalendarResource.setClassPK(calendarResourceId);\n\t\t}\n\t\telse {\n\t\t\tcalendarResource.setClassPK(classPK);\n\t\t}\n\n\t\tcalendarResource.setClassUuid(classUuid);\n\t\tcalendarResource.setCode(code);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\t// Calendar\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tcalendarLocalService.addCalendar(\n\t\t\tuserId, groupId, calendarResourceId, nameMap, descriptionMap,\n\t\t\tPortletPropsValues.CALENDAR_COLOR_DEFAULT, true, false, false,\n\t\t\tserviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tcalendarResource.getUserId(), calendarResource,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\treturn calendarResource;\n\t}","id":38986,"modified_method":"@Override\n\tpublic CalendarResource addCalendarResource(\n\t\t\tlong userId, long groupId, long classNameId, long classPK,\n\t\t\tString classUuid, String code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Calendar resource\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tlong calendarResourceId = counterLocalService.increment();\n\n\t\tif (classNameId == PortalUtil.getClassNameId(CalendarResource.class)) {\n\t\t\tclassPK = calendarResourceId;\n\t\t}\n\n\t\tif (PortletPropsValues.CALENDAR_RESOURCE_FORCE_AUTOGENERATE_CODE ||\n\t\t\tValidator.isNull(code)) {\n\n\t\t\tcode = String.valueOf(calendarResourceId);\n\t\t}\n\t\telse {\n\t\t\tcode = code.trim();\n\t\t\tcode = code.toUpperCase();\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(groupId, classNameId, classPK, code, nameMap);\n\n\t\tCalendarResource calendarResource = calendarResourcePersistence.create(\n\t\t\tcalendarResourceId);\n\n\t\tcalendarResource.setUuid(serviceContext.getUuid());\n\t\tcalendarResource.setGroupId(groupId);\n\t\tcalendarResource.setCompanyId(user.getCompanyId());\n\t\tcalendarResource.setUserId(user.getUserId());\n\t\tcalendarResource.setUserName(user.getFullName());\n\t\tcalendarResource.setCreateDate(serviceContext.getCreateDate(now));\n\t\tcalendarResource.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarResource.setClassNameId(classNameId);\n\t\tcalendarResource.setClassPK(classPK);\n\t\tcalendarResource.setClassUuid(classUuid);\n\t\tcalendarResource.setCode(code);\n\t\tcalendarResource.setNameMap(nameMap);\n\t\tcalendarResource.setDescriptionMap(descriptionMap);\n\t\tcalendarResource.setActive(active);\n\n\t\tcalendarResourcePersistence.update(calendarResource);\n\n\t\t// Resources\n\n\t\tresourceLocalService.addModelResources(\n\t\t\tcalendarResource, serviceContext);\n\n\t\t// Calendar\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tcalendarLocalService.addCalendar(\n\t\t\tuserId, calendarResource.getGroupId(), calendarResourceId, nameMap,\n\t\t\tdescriptionMap, PortletPropsValues.CALENDAR_COLOR_DEFAULT, true,\n\t\t\tfalse, false, serviceContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tcalendarResource.getUserId(), calendarResource,\n\t\t\tserviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\treturn calendarResource;\n\t}","commit_id":"7face05a24d0d57d55768884457c2734689ce9cb","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic CalendarResource addCalendarResource(\n\t\t\tlong groupId, String className, long classPK, String classUuid,\n\t\t\tString code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarPortletPermission.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.ADD_RESOURCE);\n\n\t\treturn calendarResourceLocalService.addCalendarResource(\n\t\t\tgetUserId(), groupId, className, classPK, classUuid, code, nameMap,\n\t\t\tdescriptionMap, active, serviceContext);\n\t}","id":38987,"modified_method":"@Override\n\tpublic CalendarResource addCalendarResource(\n\t\t\tlong groupId, long classNameId, long classPK, String classUuid,\n\t\t\tString code, Map<Locale, String> nameMap,\n\t\t\tMap<Locale, String> descriptionMap, boolean active,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tCalendarPortletPermission.check(\n\t\t\tgetPermissionChecker(), groupId, ActionKeys.ADD_RESOURCE);\n\n\t\treturn calendarResourceLocalService.addCalendarResource(\n\t\t\tgetUserId(), groupId, classNameId, classPK, classUuid, code,\n\t\t\tnameMap, descriptionMap, active, serviceContext);\n\t}","commit_id":"7face05a24d0d57d55768884457c2734689ce9cb","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void schedule(DebuggerCommandImpl managerCommand) {\n    if(myEvents.isClosed()) {\n      managerCommand.notifyCancelled();\n    }\n    else {\n      super.schedule(managerCommand);\n    }\n  }","id":38988,"modified_method":"public boolean schedule(DebuggerCommandImpl managerCommand) {\n    final boolean scheduled = super.schedule(managerCommand);\n    if (!scheduled) {\n      managerCommand.notifyCancelled();\n    }\n    return scheduled;\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void pushBack(DebuggerCommandImpl managerCommand) {\n    if(myEvents.isClosed()) {\n      managerCommand.notifyCancelled();\n    }\n    else {\n      super.pushBack(managerCommand);\n    }\n  }","id":38989,"modified_method":"public boolean pushBack(DebuggerCommandImpl managerCommand) {\n    final boolean pushed = super.pushBack(managerCommand);\n    if (!pushed) {\n      managerCommand.notifyCancelled();\n    }\n    return pushed;\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void close(){\n    myLock.lock();\n    try {\n      assertOpen();\n      myIsClosed = true;\n      myEventsAvailable.signalAll();\n    }\n    finally {\n      myLock.unlock();\n    }\n  }","id":38990,"modified_method":"public void close(){\n    myLock.lock();\n    try {\n      myIsClosed = true;\n      myEventsAvailable.signalAll();\n    }\n    finally {\n      myLock.unlock();\n    }\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void put(@NotNull E event, int priority) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"put event \" + event);\n    }\n\n    myLock.lock();\n    try {\n      assertOpen();\n      getEventsList(priority).offer(event);\n      myEventsAvailable.signalAll();\n    }\n    finally {\n      myLock.unlock();\n    }\n  }","id":38991,"modified_method":"public boolean put(@NotNull E event, int priority) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"put event \" + event);\n    }\n\n    myLock.lock();\n    try {\n      if (isClosed()) {\n        return false;\n      }\n      getEventsList(priority).offer(event);\n      myEventsAvailable.signalAll();\n    }\n    finally {\n      myLock.unlock();\n    }\n    return true;\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void pushBack(@NotNull E event, int priority) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"pushBack event \" + event);\n    }\n\n    myLock.lock();\n    try {\n      assertOpen();\n      getEventsList(priority).addFirst(event);\n      myEventsAvailable.signalAll();\n    }\n    finally {\n      myLock.unlock();\n    }\n  }","id":38992,"modified_method":"public boolean pushBack(@NotNull E event, int priority) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"pushBack event \" + event);\n    }\n\n    myLock.lock();\n    try {\n      if (isClosed()) {\n        return false;\n      }\n      getEventsList(priority).addFirst(event);\n      myEventsAvailable.signalAll();\n    }\n    finally {\n      myLock.unlock();\n    }\n    return true;\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void pushBack(E e) {\n    super.pushBack(e);\n  }","id":38993,"modified_method":"public boolean pushBack(E e) {\n    return super.pushBack(e);\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * !!! Do not remove this code !!!\n   * Otherwise it will be impossible to override schedule method\n   */\n  public void schedule(E e) {\n    super.schedule(e);\n  }","id":38994,"modified_method":"/**\n   * !!! Do not remove this code !!!\n   * Otherwise it will be impossible to override schedule method\n   */\n  public boolean schedule(E e) {\n    return super.schedule(e);\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void pushBack(E r) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"pushBack \" + r + \" in \" + this);\n    }\n    myEvents.pushBack(r, r.getPriority().ordinal());\n  }","id":38995,"modified_method":"public boolean pushBack(E r) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"pushBack \" + r + \" in \" + this);\n    }\n    return myEvents.pushBack(r, r.getPriority().ordinal());\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void schedule(E r) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"schedule \" + r + \" in \" + this);\n    }\n    myEvents.put(r, r.getPriority().ordinal());\n  }","id":38996,"modified_method":"public boolean schedule(E r) {\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"schedule \" + r + \" in \" + this);\n    }\n    return myEvents.put(r, r.getPriority().ordinal());\n  }","commit_id":"ed4dd08df1f9f3f9258aaf41195f2cdfe7ff0f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Drawable getStackDrawable(int i){\n\t\twhile(i >= cacheStackDrawables.size()) {\n\t\t\tcacheStackDrawables.add(getResources().getDrawable(stackDrawable).mutate());\n\t\t}\n\t\treturn cacheStackDrawables.get(i);\n\t}","id":38997,"modified_method":"private Drawable getStackDrawable(int i){\n\t\twhile(i >= cacheStackDrawables.size()) {\n\t\t\tDrawable d = getResources().getDrawable(stackDrawable);\n\t\t\tif(Build.VERSION_CODES.FROYO <=  Build.VERSION.SDK_INT) {\n\t\t\t\td = d.mutate();\n\t\t\t}\n\t\t\tcacheStackDrawables.add(d);\n\t\t}\n\t\treturn cacheStackDrawables.get(i);\n\t}","commit_id":"656e4c3a325962a33183a63b7d96df33faa4d8f9","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private TextInfoControl createSpeedControl(){\n\t\tfinal TextInfoControl speedControl = new TextInfoControl(map, 0, paintText, paintSubText) {\n\t\t\tprivate float cachedSpeed = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\t// draw speed\n\t\t\t\tif (map.getLastKnownLocation() != null && map.getLastKnownLocation().hasSpeed()) {\n\t\t\t\t\tif (Math.abs(map.getLastKnownLocation().getSpeed() - cachedSpeed) > .3f) {\n\t\t\t\t\t\tcachedSpeed = map.getLastKnownLocation().getSpeed();\n\t\t\t\t\t\tString ds = OsmAndFormatter.getFormattedSpeed(cachedSpeed, map);\n\t\t\t\t\t\tint ls = ds.lastIndexOf(' ');\n\t\t\t\t\t\tif (ls == -1) {\n\t\t\t\t\t\t\tsetText(ds, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetText(ds.substring(0, ls), ds.substring(ls + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (cachedSpeed != 0) {\n\t\t\t\t\tcachedSpeed = 0;\n\t\t\t\t\tsetText(null, null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tspeedControl.setText(null, null);\n\t\treturn speedControl;\n\t}","id":38998,"modified_method":"private TextInfoControl createSpeedControl(){\n\t\tfinal TextInfoControl speedControl = new TextInfoControl(map, 3, paintText, paintSubText) {\n\t\t\tprivate float cachedSpeed = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\t// draw speed\n\t\t\t\tif (map.getLastKnownLocation() != null && map.getLastKnownLocation().hasSpeed()) {\n\t\t\t\t\tif (Math.abs(map.getLastKnownLocation().getSpeed() - cachedSpeed) > .3f) {\n\t\t\t\t\t\tcachedSpeed = map.getLastKnownLocation().getSpeed();\n\t\t\t\t\t\tString ds = OsmAndFormatter.getFormattedSpeed(cachedSpeed, map);\n\t\t\t\t\t\tint ls = ds.lastIndexOf(' ');\n\t\t\t\t\t\tif (ls == -1) {\n\t\t\t\t\t\t\tsetText(ds, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetText(ds.substring(0, ls), ds.substring(ls + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (cachedSpeed != 0) {\n\t\t\t\t\tcachedSpeed = 0;\n\t\t\t\t\tsetText(null, null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tspeedControl.setText(null, null);\n\t\treturn speedControl;\n\t}","commit_id":"79484705fe8e1e3456904f4dbb11dc29725e3fcc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void applyTheme() {\n\t\tint boxTop = R.drawable.box_top;\n\t\tint boxTopR = R.drawable.box_top_r;\n\t\tint boxTopL = R.drawable.box_top_l;\n\t\tint expand = R.drawable.box_expand;\n\t\tif(view.getSettings().TRANSPARENT_MAP_THEME.get()){\n\t\t\tboxTop = R.drawable.box_top_t;\n\t\t\tboxTopR = R.drawable.box_top_rt;\n\t\t\tboxTopL = R.drawable.box_top_lt;\n\t\t}\n\t\tint i = 0;\n\t\tfor(MapInfoControl m : rightStack.getAllViews()){\n\t\t\tm.setBackgroundDrawable(view.getResources().getDrawable(i == 0 ? boxTopR : boxTop).mutate());\n\t\t\ti++;\n\t\t}\n\t\trightStack.setExpandImageDrawable(view.getResources().getDrawable(expand).mutate());\n\t\ti = 0;\n\t\tfor(MapInfoControl m : leftStack.getAllViews()){\n\t\t\tm.setBackgroundDrawable(view.getResources().getDrawable(i < 2 ? boxTopL : boxTop).mutate());\n\t\t\ti++;\n\t\t}\n\t\tleftStack.setExpandImageDrawable(view.getResources().getDrawable(expand).mutate());\n\t\tstatusBar.setBackgroundDrawable(view.getResources().getDrawable(boxTop).mutate());\n\t\tshowAltitude = view.getSettings().SHOW_ALTITUDE_INFO.get();\n\t}","id":38999,"modified_method":"public void applyTheme() {\n\t\tint boxTop = R.drawable.box_top;\n\t\tint boxTopR = R.drawable.box_top_r;\n\t\tint boxTopL = R.drawable.box_top_l;\n\t\tint expand = R.drawable.box_expand;\n\t\tif(view.getSettings().TRANSPARENT_MAP_THEME.get()){\n\t\t\tboxTop = R.drawable.box_top_t;\n\t\t\tboxTopR = R.drawable.box_top_rt;\n\t\t\tboxTopL = R.drawable.box_top_lt;\n\t\t}\n\t\tint i = 0;\n\t\tfor(MapInfoControl m : rightStack.getAllViews()){\n\t\t\tm.setBackgroundDrawable(view.getResources().getDrawable(i == 0 ? boxTopR : boxTop));\n\t\t\ti++;\n\t\t}\n\t\trightStack.setExpandImageDrawable(view.getResources().getDrawable(expand));\n\t\ti = 0;\n\t\tfor(MapInfoControl m : leftStack.getAllViews()){\n\t\t\tm.setBackgroundDrawable(view.getResources().getDrawable(i < 2 ? boxTopL : boxTop));\n\t\t\ti++;\n\t\t}\n\t\tleftStack.setExpandImageDrawable(view.getResources().getDrawable(expand));\n\t\tstatusBar.setBackgroundDrawable(view.getResources().getDrawable(boxTop));\n\t\tshowAltitude = view.getSettings().SHOW_ALTITUDE_INFO.get();\n\t}","commit_id":"79484705fe8e1e3456904f4dbb11dc29725e3fcc","url":"https://github.com/osmandapp/Osmand"}]